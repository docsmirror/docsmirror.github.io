<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ext="http://exslt.org/common">
  <head>
    <title>PMEVTYPER&lt;n&gt;_EL0</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">PMEVTYPER&lt;n&gt;_EL0, Performance Monitors Event Type Registers, n = 0 - 30</h1><p>The PMEVTYPER&lt;n&gt;_EL0 characteristics are:</p><h2>Purpose</h2>
        <p>Configures event counter n, where n is 0 to 30.</p>
      <h2>Configuration</h2><p>AArch64 System register PMEVTYPER&lt;n&gt;_EL0 bits [31:0] are architecturally mapped to AArch32 System register <a href="AArch32-pmevtypern.html">PMEVTYPER&lt;n&gt;[31:0]</a>.</p><p>AArch64 System register PMEVTYPER&lt;n&gt;_EL0 bits [31:0] are architecturally mapped to External register <a href="pmu.pmevtypern_el0.html">PMU.PMEVTYPER&lt;n&gt;_EL0[31:0]</a>.</p><p>AArch64 System register PMEVTYPER&lt;n&gt;_EL0 bits [63:32] are architecturally mapped to External register <a href="pmu.pmevtypern_el0.html">PMU.PMEVTYPER&lt;n&gt;_EL0[63:32]</a> when FEAT_PMUv3_TH is implemented, or FEAT_PMUv3p8 is implemented, or FEAT_PMUv3_EXT64 is implemented or FEAT_PMUv3_SME is implemented.</p><p>This register is present only when FEAT_PMUv3 is implemented. Otherwise, direct accesses to PMEVTYPER&lt;n&gt;_EL0 are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2>
        <p>PMEVTYPER&lt;n&gt;_EL0 is a 64-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram" id="fieldset_0"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="3"><a href="#fieldset_0-63_61-1">TC</a></td><td class="lr" colspan="1"><a href="#fieldset_0-60_60-1">TE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-59_59">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-58_58-1">SYNC</a></td><td class="lr" colspan="2"><a href="#fieldset_0-57_56-1">VS</a></td><td class="lr" colspan="2"><a href="#fieldset_0-55_54-1">TLC</a></td><td class="lr" colspan="10"><a href="#fieldset_0-53_44">RES0</a></td><td class="lr" colspan="12"><a href="#fieldset_0-43_32-1">TH</a></td></tr><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-31_31">P</a></td><td class="lr" colspan="1"><a href="#fieldset_0-30_30">U</a></td><td class="lr" colspan="1"><a href="#fieldset_0-29_29-1">NSK</a></td><td class="lr" colspan="1"><a href="#fieldset_0-28_28-1">NSU</a></td><td class="lr" colspan="1"><a href="#fieldset_0-27_27-1">NSH</a></td><td class="lr" colspan="1"><a href="#fieldset_0-26_26-1">M</a></td><td class="lr" colspan="1"><a href="#fieldset_0-25_25-1">MT</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_24-1">SH</a></td><td class="lr" colspan="1"><a href="#fieldset_0-23_23-1">T</a></td><td class="lr" colspan="1"><a href="#fieldset_0-22_22-1">RLK</a></td><td class="lr" colspan="1"><a href="#fieldset_0-21_21-1">RLU</a></td><td class="lr" colspan="1"><a href="#fieldset_0-20_20-1">RLH</a></td><td class="lr" colspan="4"><a href="#fieldset_0-19_16">RES0</a></td><td class="lr" colspan="6"><a href="#fieldset_0-15_10-1">evtCount[15:10]</a></td><td class="lr" colspan="10"><a href="#fieldset_0-9_0">evtCount[9:0]</a></td></tr></tbody></table><h4 id="fieldset_0-63_61-1">TC, bits [63:61]<span class="condition"><br/>When FEAT_PMUv3_TH is implemented, (FEAT_PMUv3_EDGE is not implemented or PMEVTYPER&lt;n&gt;_EL0.TE == 0) and (FEAT_PMUv3_TH2 is not implemented, or n is even or PMEVTYPER&lt;n&gt;_EL0.TLC IN {0b0x}):
                        </span></h4><div class="field"><p>Threshold Control. Defines the threshold function. In the description of this field:</p>
<ul>
<li>V<sub>B</sub>[n] is the value the event specified by PMEVTYPER&lt;n&gt;_EL0 would increment event counter n by on a processor cycle if the threshold function is disabled.
</li><li>For odd values of n, V[n-1] is the value that event counter n-1 increments by on the same processor cycle. V[n-1] is the result of applying the threshold and edge functions on event counter n-1. If event counter n-1 is disabled then V[n-1] is zero. V[n-1] is not defined for even values of n.
</li><li>TH[n] is the value of PMEVTYPER&lt;n&gt;_EL0.TH.
</li></ul><table class="valuetable"><tr><th>TC</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td>
          <p>Not-equal. The counter increments by V<sub>B</sub>[n] on each processor cycle when V<sub>B</sub>[n] is not equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b001</td><td>
          <p>Not-equal, count. The counter increments by 1 on each processor cycle when V<sub>B</sub>[n] is not equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b010</td><td>
          <p>Equals. The counter increments by V<sub>B</sub>[n] on each processor cycle when V<sub>B</sub>[n] is equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b011</td><td>
          <p>Equals, count. The counter increments by 1 on each processor cycle when V<sub>B</sub>[n] is equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b100</td><td>
          <p>Greater-than-or-equal. The counter increments by V<sub>B</sub>[n] on each processor cycle when V<sub>B</sub>[n] is greater than or equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b101</td><td>
          <p>Greater-than-or-equal, count. The counter increments by 1 on each processor cycle when V<sub>B</sub>[n] is greater than or equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b110</td><td>
          <p>Less-than. The counter increments by V<sub>B</sub>[n] on each processor cycle when V<sub>B</sub>[n] is less than TH[n].</p>
        </td></tr><tr><td class="bitfield">0b111</td><td>
          <p>Less-than, count. The counter increments by 1 on each processor cycle when V<sub>B</sub>[n] is less than TH[n].</p>
        </td></tr></table><p>Comparisons treat V<sub>B</sub>[n] and TH[n] as unsigned integer values.</p>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC[2:1] is true:</p>
<ul>
<li>If PMEVTYPER&lt;n&gt;_EL0.TC[0] is 0, then the counter increments by V<sub>B</sub>[n].
</li><li>If PMEVTYPER&lt;n&gt;_EL0.TC[0] is 1, then the counter increments by 1.
</li></ul>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC[2:1] is false:</p>
<ul>
<li>If FEAT_PMUv3_TH2 is implemented, n is odd, and PMEVTYPER&lt;n&gt;_EL0.TLC is <span class="binarynumber">0b01</span>, then the counter increments by V[n-1].
</li><li>Otherwise, the counter does not increment.
</li></ul>
<p>If PMEVTYPER&lt;n&gt;_EL0.{TC, TLC, TH} are zero then the threshold function is disabled.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When AArch32 is supported,
            this field resets to
            <span class="binarynumber">0</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-63_61-2"><span class="condition"><br/>When FEAT_PMUv3_TH2 is implemented, PMEVTYPER&lt;n&gt;_EL0.TE == 0, n is odd and PMEVTYPER&lt;n&gt;_EL0.TLC == 0b10:
                        </span></h4><div class="field"><p>Threshold Control. Defines the threshold function. In the description of this field:</p>
<ul>
<li>V<sub>B</sub>[n] is the value the event specified by PMEVTYPER&lt;n&gt;_EL0 would increment event counter n by on a processor cycle if the threshold function is disabled.
</li><li>V[n-1] is the value that event counter n-1 increments by on the same processor cycle. V[n-1] is the result of applying the threshold and edge functions on event counter n-1. If event counter n-1 is disabled then V[n-1] is zero.
</li><li>TH[n] is the value of PMEVTYPER&lt;n&gt;_EL0.TH.
</li></ul><table class="valuetable"><tr><th>TC</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td>
          <p>Not-equal. The counter increments by V[n-1] on each processor cycle when V<sub>B</sub>[n] is not equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b010</td><td>
          <p>Equals. The counter increments by V[n-1] on each processor cycle when V<sub>B</sub>[n] is equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b100</td><td>
          <p>Greater-than-or-equal. The counter increments by V[n-1] on each processor cycle when V<sub>B</sub>[n] is greater than or equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b110</td><td>
          <p>Less-than. The counter increments by V[n-1] on each processor cycle when V<sub>B</sub>[n] is less than TH[n].</p>
        </td></tr></table><p>All other values are reserved.</p>
<p>Comparisons treat V<sub>B</sub>[n] and TH[n] as unsigned integer values.</p>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC is true, the counter increments by V[n-1].</p>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC is false, the counter does not increment.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When AArch32 is supported,
            this field resets to
            <span class="binarynumber">0</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-63_61-3"><span class="condition"><br/>When FEAT_PMUv3_EDGE is implemented and PMEVTYPER&lt;n&gt;_EL0.TE == 1:
                        </span></h4><div class="field"><p>Threshold Control. Defines the threshold function. In the description of this field:</p>
<ul>
<li>V<sub>B</sub>[n] is the value the event specified by PMEVTYPER&lt;n&gt;_EL0 would increment event counter n by on a processor cycle if the threshold function is disabled.
</li><li>For odd values of n, V[n-1] is the value that event counter n-1 increments by on the same processor cycle. V[n-1] is the result of applying the threshold and edge functions on event counter n-1. If event counter n-1 is disabled then V[n-1] is zero. V[n-1] is not defined for even values of n.
</li><li>TH[n] is the value of PMEVTYPER&lt;n&gt;_EL0.TH.
</li></ul><table class="valuetable"><tr><th>TC</th><th>Meaning</th></tr><tr><td class="bitfield">0b001</td><td>
          <p>Equal to not-equal. The counter increments on each processor cycle when V<sub>B</sub>[n] is not equal to TH[n] and V<sub>B</sub>[n] was equal to TH[n] on the previous processor cycle.</p>
        </td></tr><tr><td class="bitfield">0b010</td><td><p>Equal to/from not-equal. The counter increments on each processor cycle when either:</p>
<ul>
<li>V<sub>B</sub>[n] is not equal to TH[n]  and V<sub>B</sub>[n] was equal to TH[n] on the previous processor cycle.
</li><li>V<sub>B</sub>[n] is equal to TH[n] and V<sub>B</sub>[n] was not equal to TH[n] on the previous processor cycle.
</li></ul></td></tr><tr><td class="bitfield">0b011</td><td>
          <p>Not-equal to equal. The counter increments on each processor cycle when V<sub>B</sub>[n] is equal to TH[n] and V<sub>B</sub>[n] was not equal to TH[n] on the previous processor cycle.</p>
        </td></tr><tr><td class="bitfield">0b101</td><td>
          <p>Less-than to greater-than-or-equal. The counter increments on each processor cycle when V<sub>B</sub>[n] is greater than or equal to TH[n] and V<sub>B</sub>[n] was less than TH[n] on the previous processor cycle.</p>
        </td></tr><tr><td class="bitfield">0b110</td><td><p>Less-than to/from greater-than-or-equal. The counter increments on each processor cycle when either:</p>
<ul>
<li>V<sub>B</sub>[n] is greater than or equal to TH[n] and V<sub>B</sub>[n] was less than TH[n] on the previous processor cycle.
</li><li>V<sub>B</sub>[n] is less than TH[n] and V<sub>B</sub>[n] was greater than or equal to TH[n] on the previous processor cycle.
</li></ul></td></tr><tr><td class="bitfield">0b111</td><td>
          <p>Greater-than-or-equal to less-than. The counter increments on each processor cycle when V<sub>B</sub>[n] is less than TH[n] and V<sub>B</sub>[n] was greater than or equal to TH[n] on the previous processor cycle.</p>
        </td></tr></table><p>All other values are reserved.</p>
<p>Comparisons treat V<sub>B</sub>[n] and TH[n] as unsigned integer values.</p>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC is true:</p>
<ul>
<li>If FEAT_PMUv3_TH2 is implemented, n is odd, and PMEVTYPER&lt;n&gt;_EL0.TLC is <span class="binarynumber">0b10</span>, then the counter increments by V[n-1].
</li><li>Otherwise, the counter increments by 1.
</li></ul>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC is false, the counter does not increment.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When AArch32 is supported,
            this field resets to
            <span class="binarynumber">0</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-63_61-4"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-60_60-1">TE, bit [60]<span class="condition"><br/>When FEAT_PMUv3_EDGE is implemented:
                        </span></h4><div class="field">
      <p>Threshold Edge. Enables the edge condition. When PMEVTYPER&lt;n&gt;_EL0.TE is 1, the event counter increments on cycles when the result of the threshold condition changes. See PMEVTYPER&lt;n&gt;_EL0.TC for more information.</p>
    <table class="valuetable"><tr><th>TE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Threshold edge condition disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Threshold edge condition enabled.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When AArch32 is supported,
            this field resets to
            <span class="binarynumber">0</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-60_60-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-59_59">Bit [59]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-58_58-1">SYNC, bit [58]<span class="condition"><br/>When FEAT_SEBEP is implemented:
                        </span></h4><div class="field">
      <p>Synchronous mode. Controls whether a PMU exception generated by the counter is synchronous or asynchronous.</p>
    <table class="valuetable"><tr><th>SYNC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Asynchronous PMU exception is enabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Synchronous PMU exception is enabled.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When AArch32 is supported,
            this field resets to
            <span class="binarynumber">0</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-58_58-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-57_56-1">VS, bits [57:56]<span class="condition"><br/>When FEAT_PMUv3_SME is implemented:
                        </span></h4><div class="field">
      <p>SVE mode filtering. Controls counting events in Streaming and Non-streaming SVE modes.</p>
    <table class="valuetable"><tr><th>VS</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>This mechanism has no effect on the filtering of events.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>The PE does not count events in Streaming SVE mode.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>The PE does not count events in Non-streaming SVE mode.</p>
        </td></tr></table>
      <p>All other values are reserved.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When AArch32 is supported,
            this field resets to
            <span class="binarynumber">0</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-57_56-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-55_54-1">TLC, bits [55:54]<span class="condition"><br/>When FEAT_PMUv3_TH2 is implemented and n is odd:
                        </span></h4><div class="field">
      <p>Threshold Linking Control. Extends PMEVTYPER&lt;n&gt;_EL0.TC with additional controls for event linking. See PMEVTYPER&lt;n&gt;_EL0.TC.</p>
    <table class="valuetable"><tr><th>TLC</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>Threshold linking disabled.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>Threshold linking enabled. If the threshold condition described by PMEVTYPER&lt;n&gt;_EL0.TC is false, the counter increments by V[n-1]. Otherwise, the counter increments as described by PMEVTYPER&lt;n&gt;_EL0.TC.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>Threshold linking enabled. If the threshold condition described by PMEVTYPER&lt;n&gt;_EL0.TC is true, the counter increments by V[n-1]. Otherwise, the counter does not increment.</p>
        </td></tr></table><p>All other values are reserved.</p>
<p>See PMEVTYPER&lt;n&gt;_EL0.TC for more information</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_54-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-53_44">Bits [53:44]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-43_32-1">TH, bits [43:32]<span class="condition"><br/>When FEAT_PMUv3_TH is implemented:
                        </span></h4><div class="field">
      <p>Threshold value. Provides the unsigned value for the threshold function defined by PMEVTYPER&lt;n&gt;_EL0.TC.</p>
    <p>If PMEVTYPER&lt;n&gt;_EL0.{TC, TH} are both zero and either FEAT_PMUv3_TH2 is not implemented or PMEVTYPER&lt;n&gt;_EL0.TLC is also zero, then the threshold function is disabled.</p>
<p>If <a href="AArch64-pmmir_el1.html">PMMIR_EL1</a>.THWIDTH is less than 12, then bits PMEVTYPER&lt;n&gt;_EL0.TH[11:UInt(<a href="AArch64-pmmir_el1.html">PMMIR_EL1</a>.THWIDTH)] are <span class="arm-defined-word">RES0</span>. This accounts for the behavior when writing a value greater-than-or-equal-to 2<sup>UInt(<a href="AArch64-pmmir_el1.html">PMMIR_EL1</a>.THWIDTH)</sup>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When AArch32 is supported,
            this field resets to
            <span class="binarynumber">0</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-43_32-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-31_31">P, bit [31]</h4><div class="field">
      <p>EL1 filtering. Controls counting events in EL1.</p>
    <table class="valuetable"><tr><th>P</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This mechanism has no effect on filtering of events.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>The PE does not count events in EL1.</p>
        </td></tr></table><p>If Secure and Non-secure states are implemented, then counting events in Non-secure EL1 is further controlled by PMEVTYPER&lt;n&gt;_EL0.NSK.</p>
<p>If <span class="xref">FEAT_RME</span> is implemented, then counting events in Realm EL1 is further controlled by PMEVTYPER&lt;n&gt;_EL0.RLK.</p>
<p>If EL3 is implemented, then counting events in EL3 is further controlled by PMEVTYPER&lt;n&gt;_EL0.M.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-30_30">U, bit [30]</h4><div class="field">
      <p>EL0 filtering. Controls counting events in EL0.</p>
    <table class="valuetable"><tr><th>U</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This mechanism has no effect on filtering of events.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>The PE does not count events in EL0.</p>
        </td></tr></table><p>If Secure and Non-secure states are implemented, then counting events in Non-secure EL0 is further controlled by PMEVTYPER&lt;n&gt;_EL0.NSU.</p>
<p>If <span class="xref">FEAT_RME</span> is implemented, then counting events in Realm EL0 is further controlled by PMEVTYPER&lt;n&gt;_EL0.RLU.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-29_29-1">NSK, bit [29]<span class="condition"><br/>When EL3 is implemented:
                        </span></h4><div class="field">
      <p>Non-secure EL1 filtering. Controls counting events in Non-secure EL1. If PMEVTYPER&lt;n&gt;_EL0.NSK is not equal to PMEVTYPER&lt;n&gt;_EL0.P, then the PE does not count events in Non-secure EL1. Otherwise, this mechanism has no effect on filtering of events in Non-secure EL1.</p>
    <table class="valuetable"><tr><th>NSK</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, the PE does not count events in Non-secure EL1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, the PE does not count events in Non-secure EL1.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-29_29-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-28_28-1">NSU, bit [28]<span class="condition"><br/>When EL3 is implemented:
                        </span></h4><div class="field">
      <p>Non-secure EL0 filtering. Controls counting events in Non-secure EL0. If PMEVTYPER&lt;n&gt;_EL0.NSU is not equal to PMEVTYPER&lt;n&gt;_EL0.U, then the PE does not count events in Non-secure EL0. Otherwise, this mechanism has no effect on filtering of events in Non-secure EL0.</p>
    <table class="valuetable"><tr><th>NSU</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.U == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.U == 1, the PE does not count events in Non-secure EL0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.U == 0, the PE does not count events in Non-secure EL0.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.U == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-28_28-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-27_27-1">NSH, bit [27]<span class="condition"><br/>When EL2 is implemented:
                        </span></h4><div class="field">
      <p>EL2 filtering. Controls counting events in EL2.</p>
    <table class="valuetable"><tr><th>NSH</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>The PE does not count events in EL2.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This mechanism has no effect on filtering of events.</p>
        </td></tr></table><p>If EL3 is implemented and <span class="xref">FEAT_SEL2</span> is implemented, then counting events in Secure EL2 is further controlled by PMEVTYPER&lt;n&gt;_EL0.SH.</p>
<p>If <span class="xref">FEAT_RME</span> is implemented, then counting events in Realm EL2 is further controlled by PMEVTYPER&lt;n&gt;_EL0.RLH.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-27_27-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-26_26-1">M, bit [26]<span class="condition"><br/>When EL3 is implemented:
                        </span></h4><div class="field">
      <p>EL3 filtering. Controls counting events in  EL3. If PMEVTYPER&lt;n&gt;_EL0.M is not equal to PMEVTYPER&lt;n&gt;_EL0.P, then the PE does not count events in  EL3. Otherwise, this mechanism has no effect on filtering of events in  EL3.</p>
    <table class="valuetable"><tr><th>M</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, the PE does not count events in  EL3.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, the PE does not count events in  EL3.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-26_26-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-25_25-1">MT, bit [25]<span class="condition"><br/>When FEAT_MTPMU is implemented or an IMPLEMENTATION DEFINED multi-threaded PMU extension is implemented:
                        </span></h4><div class="field">
      <p>Multithreading.</p>
    <table class="valuetable"><tr><th>MT</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Count events only on controlling PE.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Count events from any PE with the same affinity at level 1 and above as this PE.</p>
        </td></tr></table><p>From Armv8.6, the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> multi-threaded PMU extension is not permitted, meaning if <span class="xref">FEAT_MTPMU</span> is not implemented, this field is <span class="arm-defined-word">RES0</span>. See <a href="AArch64-id_aa64dfr0_el1.html">ID_AA64DFR0_EL1</a>.MTPMU.</p>
<p>This field is ignored by the PE and treated as zero when <span class="xref">FEAT_MTPMU</span> is implemented and disabled.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-25_25-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-24_24-1">SH, bit [24]<span class="condition"><br/>When EL3 is implemented and FEAT_SEL2 is implemented:
                        </span></h4><div class="field">
      <p>Secure EL2 filtering. Controls counting events in Secure EL2. If PMEVTYPER&lt;n&gt;_EL0.SH is equal to PMEVTYPER&lt;n&gt;_EL0.NSH, then the PE does not count events in Secure EL2. Otherwise, this mechanism has no effect on filtering of events in Secure EL2.</p>
    <table class="valuetable"><tr><th>SH</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 0, the PE does not count events in Secure EL2.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 1, this mechanism has no effect on filtering of events.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 1, the PE does not count events in Secure EL2.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><p>When Secure EL2 is not implemented, access to this field is <span class="access_level">
          <span class="arm-defined-word">RES0</span>
        </span>.</p></div><h4 id="fieldset_0-24_24-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-23_23-1">T, bit [23]<span class="condition"><br/>When FEAT_TME is implemented:
                        </span></h4><div class="field">
      <p>Non-Transactional state filtering bit. Controls counting of events in Non-transactional state.</p>
    <table class="valuetable"><tr><th>T</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This bit has no effect on the filtering of events.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Do not count Attributable events in Non-transactional state.</p>
        </td></tr></table>
      <p>For each Unattributable event, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the filtering applies.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-23_23-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-22_22-1">RLK, bit [22]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Realm EL1 filtering. Controls counting events in Realm EL1. If PMEVTYPER&lt;n&gt;_EL0.RLK is not equal to PMEVTYPER&lt;n&gt;_EL0.P, then the PE does not count events in Realm EL1. Otherwise, this mechanism has no effect on filtering of events in Realm EL1.</p>
    <table class="valuetable"><tr><th>RLK</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, the PE does not count events in Realm EL1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, the PE does not count events in Realm EL1.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-22_22-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-21_21-1">RLU, bit [21]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Realm EL0 filtering. Controls counting events in Realm EL0. If PMEVTYPER&lt;n&gt;_EL0.RLU is not equal to PMEVTYPER&lt;n&gt;_EL0.U, then the PE does not count events in Realm EL0. Otherwise, this mechanism has no effect on filtering of events in Realm EL0.</p>
    <table class="valuetable"><tr><th>RLU</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.U == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.U == 1, the PE does not count events in Realm EL0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.U == 0, the PE does not count events in Realm EL0.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.U == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-21_21-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-20_20-1">RLH, bit [20]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Realm EL2 filtering. Controls counting events in Realm EL2. If PMEVTYPER&lt;n&gt;_EL0.RLH is equal to PMEVTYPER&lt;n&gt;_EL0.NSH, then the PE does not count events in Realm EL2. Otherwise, this mechanism has no effect on filtering of events in Realm EL2.</p>
    <table class="valuetable"><tr><th>RLH</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 0, the PE does not count events in Realm EL2.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 1, this mechanism has no effect on filtering of events.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 1, the PE does not count events in Realm EL2.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-20_20-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-19_16">Bits [19:16]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-15_10-1">evtCount[15:10], bits [15:10]<span class="condition"><br/>When FEAT_PMUv3p1 is implemented:
                        </span></h4><div class="field">
      <p>Extension to evtCount[9:0]. For more information, see evtCount[9:0].</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-15_10-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-9_0">evtCount[9:0], bits [9:0]</h4><div class="field"><p>Event to count.</p>
<p>The event number of the event that is counted by event counter <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>.</p>
<p>The ranges of event numbers allocated to each type of event are shown in <span class="xref">'Allocation of the PMU event number space'</span>.</p>
<p>If <span class="xref">FEAT_PMUv3p8</span> is implemented and PMEVTYPER&lt;n&gt;_EL0.evtCount is programmed to an event that is reserved or not supported by the PE, no events are counted and the value returned by a direct or external read of the PMEVTYPER&lt;n&gt;_EL0.evtCount field is the value written to the field.</p>
<div class="note"><span class="note-header">Note</span><p>Arm recommends this behavior for all implementations of <span class="xref">FEAT_PMUv3</span>.</p></div><p>Otherwise, if PMEVTYPER&lt;n&gt;_EL0.evtCount is programmed to an event that is reserved or not supported by the PE, the behavior depends on the value written:</p>
<ul>
<li>For the range <span class="hexnumber">0x0000</span> to <span class="hexnumber">0x003F</span>, no events are counted and the value returned by a direct or external read of the PMEVTYPER&lt;n&gt;_EL0.evtCount field is the value written to the field.
</li><li>If <span class="xref">FEAT_PMUv3p1</span> is implemented, for the range <span class="hexnumber">0x4000</span> to <span class="hexnumber">0x403F</span>, no events are counted and the value returned by a direct or external read of the PMEVTYPER&lt;n&gt;_EL0.evtCount field is the value written to the field.
</li><li>For other values, it is <span class="arm-defined-word">UNPREDICTABLE</span> what event, if any, is counted and the value returned by a direct or external read of the PMEVTYPER&lt;n&gt;_EL0.evtCount field is <span class="arm-defined-word">UNKNOWN</span>.
</li></ul>
<div class="note"><span class="note-header">Note</span><p><span class="arm-defined-word">UNPREDICTABLE</span> means the event must not expose privileged information.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="access_mechanisms"><h2>Accessing PMEVTYPER&lt;n&gt;_EL0</h2>
        <p>PMEVTYPER&lt;n&gt;_EL0 can also be accessed by using <a href="AArch64-pmxevtyper_el0.html">PMXEVTYPER_EL0</a> with <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a>.SEL set to n.</p>

      
        <p>If <span class="xref">FEAT_FGT</span> is implemented and &lt;n&gt; is greater than or equal to the number of accessible event counters, then the behavior of permitted reads and writes of PMEVTYPER&lt;n&gt;_EL0 is as follows:</p>

      
        <ul>
<li>If &lt;n&gt; is an unimplemented event counter, the access is <span class="arm-defined-word">UNDEFINED</span>.
</li><li>Otherwise, the access is trapped to EL2.
</li></ul>

      
        <p>If <span class="xref">FEAT_FGT</span> is not implemented and &lt;n&gt; is greater than or equal to the number of accessible event counters, then reads and writes of PMEVTYPER&lt;n&gt;_EL0 are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, and the following behaviors are permitted:</p>

      
        <ul>
<li>Accesses to the register are <span class="arm-defined-word">UNDEFINED</span>.
</li><li>Accesses to the register behave as RAZ/WI.
</li><li>Accesses to the register execute as a <span class="instruction">NOP</span>.
</li><li>Accesses to the register behave as if &lt;n&gt; is an <span class="arm-defined-word">UNKNOWN</span> value less-than-or-equal-to the index of the highest accessible event counter.
</li><li>If EL2 is implemented and enabled in the current Security state, and &lt;n&gt; is less than the number of implemented event counters, accesses from EL1 or permitted accesses from EL0 are trapped to EL2.
</li></ul>

      
        <p>Permitted reads and writes of PMEVTYPER&lt;n&gt;_EL0 are RAZ/WI if all of the following are true:</p>

      
        <ul>
<li>FEAT_PMUv3p9 is implemented.
</li><li>PSTATE.EL == EL0.
</li><li><a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.UEN == 1.
</li><li><a href="AArch64-pmuacr_el1.html">PMUACR_EL1</a>.P&lt;n&gt; == 0.
</li></ul>

      
        <p>Permitted writes of PMEVTYPER&lt;n&gt;_EL0 are ignored if all of the following are true:</p>

      
        <ul>
<li>FEAT_PMUv3p9 is implemented.
</li><li>PSTATE.EL == EL0.
</li><li><a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.{UEN,ER} == {1,1}.
</li></ul>

      
        <div class="note"><span class="note-header">Note</span><p>In EL0, an access is permitted if it is enabled by <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.{UEN,EN}.</p><p>If EL2 is implemented and enabled in the current Security state, in EL1 and EL0, <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN identifies the number of accessible event counters. Otherwise, the number of accessible event counters is the number of implemented event counters. For more information, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p></div>
      <p>Accesses to this register use the following encodings in the System register encoding space:</p><div><h4 class="assembler">MRS &lt;Xt&gt;, PMEVTYPER&lt;m&gt;_EL0
      ; Where m = 0-30</h4></div><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b011</td><td>0b1110</td><td>0b11:m[4:3]</td><td>m[2:0]</td></tr></table><p class="pseudocode">
integer m = UInt(CRm&lt;1:0&gt;:op2&lt;2:0&gt;);

if m &gt;= NUM_PMU_COUNTERS then
    if IsFeatureImplemented(FEAT_FGT) then
        UNDEFINED;
    else
        ConstrainUnpredictableProcedure(Unpredictable_PMUEVENTCOUNTER);
elsif PSTATE.EL == EL0 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3.TPM == '1' then
        UNDEFINED;
    elsif PMUSERENR_EL0.EN == '0' &amp;&amp; (!IsFeatureImplemented(FEAT_PMUv3p9) || PMUSERENR_EL0.UEN == '0') then
        if EL2Enabled() &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.SystemAccessTrap(EL2, 0x18);
        else
            AArch64.SystemAccessTrap(EL1, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELIsInHost(EL0) &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGRTR_EL2.PMEVTYPERn_EL0 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; m &gt;= GetNumEventCountersAccessible() then
        if !IsFeatureImplemented(FEAT_FGT) then
            ConstrainUnpredictableProcedure(Unpredictable_PMUEVENTCOUNTER);
        else
            AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    elsif IsFeatureImplemented(FEAT_PMUv3p9) &amp;&amp; PMUSERENR_EL0.UEN == '1' &amp;&amp; PMUACR_EL1[m] == '0' then
        X[t, 64] = Zeros(64);
    else
        X[t, 64] = PMEVTYPER_EL0[m];
elsif PSTATE.EL == EL1 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3.TPM == '1' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGRTR_EL2.PMEVTYPERn_EL0 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; m &gt;= GetNumEventCountersAccessible() then
        if !IsFeatureImplemented(FEAT_FGT) then
            ConstrainUnpredictableProcedure(Unpredictable_PMUEVENTCOUNTER);
        else
            AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        X[t, 64] = PMEVTYPER_EL0[m];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3.TPM == '1' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        X[t, 64] = PMEVTYPER_EL0[m];
elsif PSTATE.EL == EL3 then
    X[t, 64] = PMEVTYPER_EL0[m];
                </p><div><h4 class="assembler">MSR PMEVTYPER&lt;m&gt;_EL0, &lt;Xt&gt;
      ; Where m = 0-30</h4></div><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b011</td><td>0b1110</td><td>0b11:m[4:3]</td><td>m[2:0]</td></tr></table><p class="pseudocode">
integer m = UInt(CRm&lt;1:0&gt;:op2&lt;2:0&gt;);

if m &gt;= NUM_PMU_COUNTERS then
    if IsFeatureImplemented(FEAT_FGT) then
        UNDEFINED;
    else
        ConstrainUnpredictableProcedure(Unpredictable_PMUEVENTCOUNTER);
elsif PSTATE.EL == EL0 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3.TPM == '1' then
        UNDEFINED;
    elsif PMUSERENR_EL0.EN == '0' &amp;&amp; (!IsFeatureImplemented(FEAT_PMUv3p9) || PMUSERENR_EL0.UEN == '0') then
        if EL2Enabled() &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.SystemAccessTrap(EL2, 0x18);
        else
            AArch64.SystemAccessTrap(EL1, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELIsInHost(EL0) &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.PMEVTYPERn_EL0 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; m &gt;= GetNumEventCountersAccessible() then
        if !IsFeatureImplemented(FEAT_FGT) then
            ConstrainUnpredictableProcedure(Unpredictable_PMUEVENTCOUNTER);
        else
            AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    elsif IsFeatureImplemented(FEAT_PMUv3p9) &amp;&amp; PMUSERENR_EL0.UEN == '1' &amp;&amp; (PMUACR_EL1[m] == '0' || PMUSERENR_EL0.ER == '1') then
        return;
    else
        PMEVTYPER_EL0[m] = X[t, 64];
elsif PSTATE.EL == EL1 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3.TPM == '1' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.PMEVTYPERn_EL0 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; m &gt;= GetNumEventCountersAccessible() then
        if !IsFeatureImplemented(FEAT_FGT) then
            ConstrainUnpredictableProcedure(Unpredictable_PMUEVENTCOUNTER);
        else
            AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        PMEVTYPER_EL0[m] = X[t, 64];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3.TPM == '1' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        PMEVTYPER_EL0[m] = X[t, 64];
elsif PSTATE.EL == EL3 then
    PMEVTYPER_EL0[m] = X[t, 64];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">26/03/2024 09:49; 67c0ae5282a7629ba0ea0ba7267b43cd4f7939f6</p><p class="copyconf">Copyright © 2010-2024 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
