<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ext="http://exslt.org/common">
  <head>
    <title>PMBIDR_EL1</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">PMBIDR_EL1, Profiling Buffer ID Register</h1><p>The PMBIDR_EL1 characteristics are:</p><h2>Purpose</h2>
        <p>Provides information to software as to whether the buffer can be programmed at the current Exception level.</p>
      <h2>Configuration</h2><p>This register is present only when FEAT_SPE is implemented. Otherwise, direct accesses to PMBIDR_EL1 are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2>
        <p>PMBIDR_EL1 is a 64-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram" id="fieldset_0"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_0-63_48">RES0</a></td><td class="lr" colspan="16"><a href="#fieldset_0-47_32">MaxBuffSize</a></td></tr><tr class="firstrow"><td class="lr" colspan="20"><a href="#fieldset_0-31_12">RES0</a></td><td class="lr" colspan="4"><a href="#fieldset_0-11_8">EA</a></td><td class="lr" colspan="2"><a href="#fieldset_0-7_6-1">AddrMode</a></td><td class="lr" colspan="1"><a href="#fieldset_0-5_5">F</a></td><td class="lr" colspan="1"><a href="#fieldset_0-4_4">P</a></td><td class="lr" colspan="4"><a href="#fieldset_0-3_0">Align</a></td></tr></tbody></table><h4 id="fieldset_0-63_48">Bits [63:48]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-47_32">MaxBuffSize, bits [47:32]</h4><div class="field">
      <p>Maximum supported Profiling Buffer size. Reserved for software use.</p>
    <p>The only permitted value is <span class="hexnumber">0x0000</span>, indicating there is no limit to the maximum buffer size.</p>
<div class="note"><span class="note-header">Note</span><p>Permitted values relate to the values an implementation is permitted to set this field to. A hypervisor might trap accesses to this register and use other values to describe limitations of its virtualization support to a guest operating system, as follows:</p><ul><li>MaxBuffSize bits[8:0] encodes a mantissa value, M.</li><li>MaxBuffSize bits[13:9] encodes an exponent value, E.</li><li>MaxBuffSize bits[15:14] are reserved.</li></ul><p>The maximum buffer size, in bytes, is expressed using the following function:</p><p> if IsZero(E) then UInt(M:Zeros(12)) else UInt('1':M:Zeros(UInt(E)+11)) </p><p>For example:</p><ul><li>A value of <span class="hexnumber">0x0001</span> means a maximum buffer size of 4KB.</li><li>A value of <span class="hexnumber">0x3FFF</span> means a maximum buffer size of 4092TB.</li></ul></div><p>Reads as <span class="hexnumber">0x0000</span>.</p><p>Access to this field is <span class="access_level">RO</span>.</p></div><h4 id="fieldset_0-31_12">Bits [31:12]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-11_8">EA, bits [11:8]</h4><div class="field">
      <p>External Abort handling. Describes how the PE manages External aborts on writes made by the Statistical Profiling Unit to the Profiling Buffer.</p>
    <p> The value of this field is an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> choice of:</p><table class="valuetable"><tr><th>EA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0000</td><td>
          <p>Not described.</p>
        </td></tr><tr><td class="bitfield">0b0001</td><td>
          <p>The PE ignores External aborts on writes made by the Statistical Profiling Unit.</p>
        </td></tr><tr><td class="bitfield">0b0010</td><td>
          <p>An External abort on a write made by the Statistical Profiling Unit generates an asynchronous SError exception at the PE.</p>
        </td></tr></table><p>All other values are reserved.</p>
<p>From Armv8.8, the value <span class="binarynumber">0b0000</span> is not permitted.</p>
<p>PMBIDR_EL1.EA describes only External aborts generated by the write to memory. External aborts on a translation table walk made by the Statistical Profiling Unit generate Profiling Buffer management events reported as MMU faults using <a href="AArch64-pmbsr_elx.html">PMBSR_ELx</a>.</p><p>Access to this field is <span class="access_level">RO</span>.</p></div><h4 id="fieldset_0-7_6-1">AddrMode, bits [7:6]<span class="condition"><br/>When FEAT_SPE_nVM is implemented:
                        </span></h4><div class="field">
      <p>Address Modes. Describes the addressing modes available for the Profiling Buffer.</p>
    <table class="valuetable"><tr><th>AddrMode</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>Only virtual address mode is supported.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>Virtual and physical address modes are supported.</p>
        </td></tr><tr><td class="bitfield">0b11</td><td>
          <p>Reserved for software use under virtualization, to show that only physical address mode is supported.</p>
        </td></tr></table><p>Other values are reserved.</p>
<p>If the Effective value of <a href="AArch64-pmscr_el2.html">PMSCR_EL2</a>.EnVM is 1 and the value returned for PMBIDR_EL1.P is 0, then this field reads as <span class="binarynumber">0b01</span>. Otherwise, this field reads as <span class="binarynumber">0b00</span>.</p>
<div class="note"><span class="note-header">Note</span><p>A hypervisor might trap accesses to this register to describe limitations of its virtualization support to a guest operating system.</p></div></div><h4 id="fieldset_0-7_6-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-5_5">F, bit [5]</h4><div class="field">
      <p>Flag updates. Describes how address translations performed by the Statistical Profiling Unit manage the Access flag and dirty state.</p>
    <p> The value of this field is an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> choice of:</p><table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Hardware management of the Access flag and dirty state for accesses made by the Statistical Profiling Unit is always disabled for all translation stages.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Hardware management of the Access flag and dirty state for accesses made by the Statistical Profiling Unit is controlled in the same way as explicit memory accesses in the Profiling Buffer owning translation regime.</p>
        </td></tr></table>
      <div class="note"><span class="note-header">Note</span>
        <p>If hardware management of the Access flag is disabled for a stage of translation, an access to a Page or Block with the Access flag bit not set in the descriptor will generate an Access Flag fault.</p>
        <p>If hardware management of the dirty state is disabled for a stage of translation, an access to a Page or Block will ignore the Dirty Bit Modifier in the descriptor and might generate a Permission fault, depending on the values of the access permission bits in the descriptor.</p>
      </div>
      <p>From Armv8.8, the value 0 is not permitted.</p>
    <p>Access to this field is <span class="access_level">RO</span>.</p></div><h4 id="fieldset_0-4_4">P, bit [4]</h4><div class="field">
      <p>Programming not allowed. When read at EL3, this field reads as zero. Otherwise, indicates that the Profiling Buffer owning Exception level is a higher Exception level or the Profiling Buffer owning Security state is not the current Security state.</p>
    <table class="valuetable"><tr><th>P</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Programming is allowed.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Programming not allowed.</p>
        </td></tr></table><p>The value read from this field depends on the current Exception level and the Effective values of 
<a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.NSPB, <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.NSPBE, and <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.E2PB:</p>
<ul>
<li>If EL3 is implemented, <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.NSPB is <span class="binarynumber">0b0x</span>, and either <span class="xref">FEAT_RME</span> is not implemented, or Secure state is implemented and <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.NSPBE is 0, then this field reads as one from:<ul>
<li>Non-secure EL1 and Non-secure EL2.
</li><li>If <span class="xref">FEAT_RME</span> is implemented, Realm EL1 and Realm EL2.
</li><li>If Secure EL2 is implemented and enabled, and <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.E2PB is <span class="binarynumber">0b00</span>, Secure EL1.
</li></ul>

</li><li>If EL3 is implemented, <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.NSPB is <span class="binarynumber">0b1x</span> and either <span class="xref">FEAT_RME</span> is not implemented or <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.NSPBE is 0, then this field reads as one from:<ul>
<li>If Secure state is implemented, Secure EL1.
</li><li>If Secure EL2 is implemented, Secure EL2.
</li><li>If EL2 is implemented and <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.E2PB is <span class="binarynumber">0b00</span>, Non-secure EL1.
</li><li>If <span class="xref">FEAT_RME</span> is implemented, Realm EL1 and Realm EL2.
</li></ul>

</li><li>If <span class="xref">FEAT_RME</span> is implemented, and <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.{NSPB, NSPBE} is {<span class="binarynumber">0b1x</span>, 1}, then this field reads as one from:<ul>
<li>Non-secure EL1 and Non-secure EL2.
</li><li>If Secure state is implemented, Secure EL1 and Secure EL2.
</li><li>If <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.E2PB is <span class="binarynumber">0b00</span>, Realm EL1.
</li></ul>

</li><li>If EL3 is not implemented, EL2 is implemented, and <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.E2PB is <span class="binarynumber">0b00</span>, then this field reads as one from EL1.
</li></ul>
<p>Otherwise, this field reads as zero.</p></div><h4 id="fieldset_0-3_0">Align, bits [3:0]</h4><div class="field">
      <p>Defines the minimum alignment constraint for writes to <a href="AArch64-pmbptr_el1.html">PMBPTR_EL1</a>.</p>
    <p> The value of this field is an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> choice of:</p><table class="valuetable"><tr><th>Align</th><th>Meaning</th></tr><tr><td class="bitfield">0b0000</td><td>
          <p>Byte.</p>
        </td></tr><tr><td class="bitfield">0b0001</td><td>
          <p>Halfword.</p>
        </td></tr><tr><td class="bitfield">0b0010</td><td>
          <p>Word.</p>
        </td></tr><tr><td class="bitfield">0b0011</td><td>
          <p>Doubleword.</p>
        </td></tr><tr><td class="bitfield">0b0100</td><td>
          <p>16 bytes.</p>
        </td></tr><tr><td class="bitfield">0b0101</td><td>
          <p>32 bytes.</p>
        </td></tr><tr><td class="bitfield">0b0110</td><td>
          <p>64 bytes.</p>
        </td></tr><tr><td class="bitfield">0b0111</td><td>
          <p>128 bytes.</p>
        </td></tr><tr><td class="bitfield">0b1000</td><td>
          <p>256 bytes.</p>
        </td></tr><tr><td class="bitfield">0b1001</td><td>
          <p>512 bytes.</p>
        </td></tr><tr><td class="bitfield">0b1010</td><td>
          <p>1KB.</p>
        </td></tr><tr><td class="bitfield">0b1011</td><td>
          <p>2KB.</p>
        </td></tr></table><p>All other values are reserved.</p>
<p>For more information, see <span class="xref">'Restrictions on the current write pointer'</span>.</p>
<p>If this field is nonzero, then every record is a multiple of this size.</p><p>Access to this field is <span class="access_level">RO</span>.</p></div><div class="access_mechanisms"><h2>Accessing PMBIDR_EL1</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><div><h4 class="assembler">MRS &lt;Xt&gt;, PMBIDR_EL1</h4></div><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b1001</td><td>0b1010</td><td>0b111</td></tr></table><p class="pseudocode">
if !IsFeatureImplemented(FEAT_SPE) then
    UNDEFINED;
elsif PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGRTR_EL2.PMBIDR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        X[t, 64] = PMBIDR_EL1;
elsif PSTATE.EL == EL2 then
    X[t, 64] = PMBIDR_EL1;
elsif PSTATE.EL == EL3 then
    X[t, 64] = PMBIDR_EL1;
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">2025-06-23 17:47:32, 2025-06_rel</p><p class="copyconf">Copyright Â© 2010-2025 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
