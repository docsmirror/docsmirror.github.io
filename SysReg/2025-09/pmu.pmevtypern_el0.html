<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ext="http://exslt.org/common">
  <head>
    <title>PMEVTYPER&lt;n&gt;_EL0</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">PMEVTYPER&lt;n&gt;_EL0, Performance Monitors Event Type Registers, n = 0 - 30</h1><p>The PMEVTYPER&lt;n&gt;_EL0 characteristics are:</p><h2>Purpose</h2>
        <p>Configures event counter n, where n is 0 to 30.</p>
      <h2>Configuration</h2><p>External register PMEVTYPER&lt;n&gt;_EL0 bits [31:0] are architecturally mapped to AArch64 System register <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n&gt;_EL0[31:0]</a>.</p><p>External register PMEVTYPER&lt;n&gt;_EL0 bits [63:32] are architecturally mapped to AArch64 System register <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n&gt;_EL0[63:32]</a> when FEAT_PMUv3_TH is implemented, or FEAT_PMUv3p8 is implemented, or FEAT_PMUv3_EXT64 is implemented.</p><p>External register PMEVTYPER&lt;n&gt;_EL0 bits [31:0] are architecturally mapped to AArch32 System register <a href="AArch32-pmevtypern.html">PMEVTYPER&lt;n&gt;[31:0]</a>.</p><p>This register is present only when FEAT_PMUv3_EXT is implemented. Otherwise, direct accesses to PMEVTYPER&lt;n&gt;_EL0 are <span class="arm-defined-word">RES0</span>.</p>
        <p>PMEVTYPER&lt;n&gt;_EL0 is in the Core power domain.</p>

      
        <p>If event counter n is not implemented:</p>

      
        <ul>
<li>When IsCorePowered() &amp;&amp; !DoubleLockStatus() &amp;&amp; !OSLockStatus() &amp;&amp; AllowExternalPMUAccess(), accesses are <span class="arm-defined-word">RES0</span>.
</li><li>Otherwise, it is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span> whether accesses to this register are <span class="arm-defined-word">RES0</span> or generate an error response.
</li></ul>
      <h2>Attributes</h2>
        <p>PMEVTYPER&lt;n&gt;_EL0 is a 64-bit register.</p>
      <p>This  register is part of the <a href="pmu.html">PMU</a> block.</p><h2>Field descriptions</h2><table class="regdiagram" id="fieldset_0"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="3"><a href="#fieldset_0-63_61-1">TC</a></td><td class="lr" colspan="1"><a href="#fieldset_0-60_60-1">TE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-59_59">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-58_58-1">SYNC</a></td><td class="lr" colspan="2"><a href="#fieldset_0-57_56-1">VS</a></td><td class="lr" colspan="2"><a href="#fieldset_0-55_54-1">TLC</a></td><td class="lr" colspan="10"><a href="#fieldset_0-53_44">RES0</a></td><td class="lr" colspan="12"><a href="#fieldset_0-43_32-1">TH</a></td></tr><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-31_31">P</a></td><td class="lr" colspan="1"><a href="#fieldset_0-30_30">U</a></td><td class="lr" colspan="1"><a href="#fieldset_0-29_29-1">NSK</a></td><td class="lr" colspan="1"><a href="#fieldset_0-28_28-1">NSU</a></td><td class="lr" colspan="1"><a href="#fieldset_0-27_27-1">NSH</a></td><td class="lr" colspan="1"><a href="#fieldset_0-26_26-1">M</a></td><td class="lr" colspan="1"><a href="#fieldset_0-25_25-1">MT</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_24-1">SH</a></td><td class="lr" colspan="1"><a href="#fieldset_0-23_23">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-22_22-1">RLK</a></td><td class="lr" colspan="1"><a href="#fieldset_0-21_21-1">RLU</a></td><td class="lr" colspan="1"><a href="#fieldset_0-20_20-1">RLH</a></td><td class="lr" colspan="4"><a href="#fieldset_0-19_16">RES0</a></td><td class="lr" colspan="6"><a href="#fieldset_0-15_10-1">evtCount[15:10]</a></td><td class="lr" colspan="10"><a href="#fieldset_0-9_0">evtCount[9:0]</a></td></tr></tbody></table><h4 id="fieldset_0-63_61-1">TC, bits [63:61]<span class="condition"><br/>When FEAT_PMUv3_TH is implemented, (FEAT_PMUv3_EDGE is not implemented or PMU.PMEVTYPER&lt;n&gt;_EL0.TE == 0), and (FEAT_PMUv3_TH2 is not implemented, or n is even, or PMU.PMEVTYPER&lt;n&gt;_EL0.TLC IN {0b0x}):
                        </span></h4><div class="field"><p>Threshold Control. Defines the threshold function. In the description of this field:</p>
<ul>
<li>V<sub>B</sub>[n] is the value the event specified by PMEVTYPER&lt;n&gt;_EL0 would increment event counter n by on a processor cycle if the threshold function is disabled.
</li><li>For odd values of n, V[n-1] is the value that event counter n-1 increments by on the same processor cycle. V[n-1] is the result of applying the threshold and edge functions on event counter n-1. If event counter n-1 is disabled, then V[n-1] is zero. V[n-1] is not defined for even values of n.
</li><li>TH[n] is the value of PMEVTYPER&lt;n&gt;_EL0.TH.
</li></ul><table class="valuetable"><tr><th>TC</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td>
          <p>Not-equal. The counter increments by V<sub>B</sub>[n] on each processor cycle when V<sub>B</sub>[n] is not equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b001</td><td>
          <p>Not-equal, count. The counter increments by 1 on each processor cycle when V<sub>B</sub>[n] is not equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b010</td><td>
          <p>Equals. The counter increments by V<sub>B</sub>[n] on each processor cycle when V<sub>B</sub>[n] is equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b011</td><td>
          <p>Equals, count. The counter increments by 1 on each processor cycle when V<sub>B</sub>[n] is equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b100</td><td>
          <p>Greater-than-or-equal. The counter increments by V<sub>B</sub>[n] on each processor cycle when V<sub>B</sub>[n] is greater than or equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b101</td><td>
          <p>Greater-than-or-equal, count. The counter increments by 1 on each processor cycle when V<sub>B</sub>[n] is greater than or equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b110</td><td>
          <p>Less-than. The counter increments by V<sub>B</sub>[n] on each processor cycle when V<sub>B</sub>[n] is less than TH[n].</p>
        </td></tr><tr><td class="bitfield">0b111</td><td>
          <p>Less-than, count. The counter increments by 1 on each processor cycle when V<sub>B</sub>[n] is less than TH[n].</p>
        </td></tr></table><p>Comparisons treat V<sub>B</sub>[n] and TH[n] as unsigned integer values.</p>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC[2:1] is true:</p>
<ul>
<li>If PMEVTYPER&lt;n&gt;_EL0.TC[0] is 0, then the counter increments by V<sub>B</sub>[n].
</li><li>If PMEVTYPER&lt;n&gt;_EL0.TC[0] is 1, then the counter increments by 1.
</li></ul>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC[2:1] is false:</p>
<ul>
<li>If FEAT_PMUv3_TH2 is implemented, n is odd, and PMEVTYPER&lt;n&gt;_EL0.TLC is <span class="binarynumber">0b01</span>, then the counter increments by V[n-1].
</li><li>Otherwise, the counter does not increment.
</li></ul>
<p>If PMEVTYPER&lt;n&gt;_EL0.{TC, TLC, TH} are zero, then the threshold function is disabled.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset:<ul>
            <li>When FEAT_AA32EL1 is implemented,
            this field resets to
            <span class="binarynumber">'000'</span>.
</li>
          
            <li>When FEAT_PMUv3_EXTPMN is not implemented,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-63_61-2"><span class="condition"><br/>When FEAT_PMUv3_TH2 is implemented, PMU.PMEVTYPER&lt;n&gt;_EL0.TE == 0, n is odd, and PMU.PMEVTYPER&lt;n&gt;_EL0.TLC == 0b10:
                        </span></h4><div class="field"><p>Threshold Control. Defines the threshold function. In the description of this field:</p>
<ul>
<li>V<sub>B</sub>[n] is the value the event specified by PMEVTYPER&lt;n&gt;_EL0 would increment event counter n by on a processor cycle if the threshold function is disabled.
</li><li>V[n-1] is the value that event counter n-1 increments by on the same processor cycle. V[n-1] is the result of applying the threshold and edge functions on event counter n-1. If event counter n-1 is disabled, then V[n-1] is zero.
</li><li>TH[n] is the value of PMEVTYPER&lt;n&gt;_EL0.TH.
</li></ul><table class="valuetable"><tr><th>TC</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td>
          <p>Not-equal. The counter increments by V[n-1] on each processor cycle when V<sub>B</sub>[n] is not equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b010</td><td>
          <p>Equals. The counter increments by V[n-1] on each processor cycle when V<sub>B</sub>[n] is equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b100</td><td>
          <p>Greater-than-or-equal. The counter increments by V[n-1] on each processor cycle when V<sub>B</sub>[n] is greater than or equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b110</td><td>
          <p>Less-than. The counter increments by V[n-1] on each processor cycle when V<sub>B</sub>[n] is less than TH[n].</p>
        </td></tr></table><p>All other values are reserved.</p>
<p>Comparisons treat V<sub>B</sub>[n] and TH[n] as unsigned integer values.</p>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC is true, the counter increments by V[n-1].</p>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC is false, the counter does not increment.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset:<ul>
            <li>When FEAT_AA32EL1 is implemented,
            this field resets to
            <span class="binarynumber">'000'</span>.
</li>
          
            <li>When FEAT_PMUv3_EXTPMN is not implemented,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-63_61-3"><span class="condition"><br/>When FEAT_PMUv3_EDGE is implemented and PMU.PMEVTYPER&lt;n&gt;_EL0.TE == 1:
                        </span></h4><div class="field"><p>Threshold Control. Defines the threshold function. In the description of this field:</p>
<ul>
<li>V<sub>B</sub>[n] is the value the event specified by PMEVTYPER&lt;n&gt;_EL0 would increment event counter n by on a processor cycle if the threshold function is disabled.
</li><li>For odd values of n, V[n-1] is the value that event counter n-1 increments by on the same processor cycle. V[n-1] is the result of applying the threshold and edge functions on event counter n-1. If event counter n-1 is disabled, then V[n-1] is zero. V[n-1] is not defined for even values of n.
</li><li>TH[n] is the value of PMEVTYPER&lt;n&gt;_EL0.TH.
</li></ul><table class="valuetable"><tr><th>TC</th><th>Meaning</th></tr><tr><td class="bitfield">0b001</td><td>
          <p>Equal to not-equal. The counter increments on each processor cycle when V<sub>B</sub>[n] is not equal to TH[n] and V<sub>B</sub>[n] was equal to TH[n] on the previous processor cycle.</p>
        </td></tr><tr><td class="bitfield">0b010</td><td><p>Equal to/from not-equal. The counter increments on each processor cycle when either:</p>
<ul>
<li>V<sub>B</sub>[n] is not equal to TH[n]  and V<sub>B</sub>[n] was equal to TH[n] on the previous processor cycle.
</li><li>V<sub>B</sub>[n] is equal to TH[n] and V<sub>B</sub>[n] was not equal to TH[n] on the previous processor cycle.
</li></ul></td></tr><tr><td class="bitfield">0b011</td><td>
          <p>Not-equal to equal. The counter increments on each processor cycle when V<sub>B</sub>[n] is equal to TH[n] and V<sub>B</sub>[n] was not equal to TH[n] on the previous processor cycle.</p>
        </td></tr><tr><td class="bitfield">0b101</td><td>
          <p>Less-than to greater-than-or-equal. The counter increments on each processor cycle when V<sub>B</sub>[n] is greater than or equal to TH[n] and V<sub>B</sub>[n] was less than TH[n] on the previous processor cycle.</p>
        </td></tr><tr><td class="bitfield">0b110</td><td><p>Less-than to/from greater-than-or-equal. The counter increments on each processor cycle when either:</p>
<ul>
<li>V<sub>B</sub>[n] is greater than or equal to TH[n] and V<sub>B</sub>[n] was less than TH[n] on the previous processor cycle.
</li><li>V<sub>B</sub>[n] is less than TH[n] and V<sub>B</sub>[n] was greater than or equal to TH[n] on the previous processor cycle.
</li></ul></td></tr><tr><td class="bitfield">0b111</td><td>
          <p>Greater-than-or-equal to less-than. The counter increments on each processor cycle when V<sub>B</sub>[n] is less than TH[n] and V<sub>B</sub>[n] was greater than or equal to TH[n] on the previous processor cycle.</p>
        </td></tr></table><p>All other values are reserved.</p>
<p>Comparisons treat V<sub>B</sub>[n] and TH[n] as unsigned integer values.</p>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC is true:</p>
<ul>
<li>If FEAT_PMUv3_TH2 is implemented, n is odd, and PMEVTYPER&lt;n&gt;_EL0.TLC is <span class="binarynumber">0b10</span>, then the counter increments by V[n-1].
</li><li>Otherwise, the counter increments by 1.
</li></ul>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC is false, the counter does not increment.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset:<ul>
            <li>When FEAT_AA32EL1 is implemented,
            this field resets to
            <span class="binarynumber">'000'</span>.
</li>
          
            <li>When FEAT_PMUv3_EXTPMN is not implemented,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-63_61-4"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-60_60-1">TE, bit [60]<span class="condition"><br/>When FEAT_PMUv3_EDGE is implemented:
                        </span></h4><div class="field">
      <p>Threshold Edge. Enables the edge condition. When PMEVTYPER&lt;n&gt;_EL0.TE is 1, the event counter increments on cycles when the result of the threshold condition changes. See PMEVTYPER&lt;n&gt;_EL0.TC for more information.</p>
    <table class="valuetable"><tr><th>TE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Threshold edge condition disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Threshold edge condition enabled.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset:<ul>
            <li>When FEAT_AA32EL1 is implemented,
            this field resets to
            <span class="binarynumber">'0'</span>.
</li>
          
            <li>When FEAT_PMUv3_EXTPMN is not implemented,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-60_60-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-59_59">Bit [59]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-58_58-1">SYNC, bit [58]<span class="condition"><br/>When FEAT_SEBEP is implemented:
                        </span></h4><div class="field">
      <p>Synchronous mode. Controls whether a PMU Profiling exception generated by the counter is synchronous or asynchronous.</p>
    <table class="valuetable"><tr><th>SYNC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Asynchronous PMU Profiling exception is enabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Synchronous PMU Profiling exception is enabled.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-58_58-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-57_56-1">VS, bits [57:56]<span class="condition"><br/>When FEAT_PMUv3_SME is implemented:
                        </span></h4><div class="field">
      <p>SVE mode filtering. Controls counting events in Streaming and Non-streaming SVE modes.</p>
    <table class="valuetable"><tr><th>VS</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>This mechanism has no effect on the filtering of events.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>The PE does not count events in Streaming SVE mode.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>The PE does not count events in Non-streaming SVE mode.</p>
        </td></tr></table>
      <p>All other values are reserved.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-57_56-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-55_54-1">TLC, bits [55:54]<span class="condition"><br/>When FEAT_PMUv3_TH2 is implemented and n is odd:
                        </span></h4><div class="field">
      <p>Threshold Linking Control. Extends PMEVTYPER&lt;n&gt;_EL0.TC with additional controls for event linking. See PMEVTYPER&lt;n&gt;_EL0.TC.</p>
    <table class="valuetable"><tr><th>TLC</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>Threshold linking disabled.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>Threshold linking enabled. If the threshold condition described by PMEVTYPER&lt;n&gt;_EL0.TC is false, the counter increments by V[n-1]. Otherwise, the counter increments as described by PMEVTYPER&lt;n&gt;_EL0.TC.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>Threshold linking enabled. If the threshold condition described by PMEVTYPER&lt;n&gt;_EL0.TC is true, the counter increments by V[n-1]. Otherwise, the counter does not increment.</p>
        </td></tr></table><p>All other values are reserved.</p>
<p>See PMEVTYPER&lt;n&gt;_EL0.TC for more information</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_54-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-53_44">Bits [53:44]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-43_32-1">TH, bits [43:32]<span class="condition"><br/>When FEAT_PMUv3_TH is implemented:
                        </span></h4><div class="field">
      <p>Threshold value. Provides the unsigned value for the threshold function defined by PMEVTYPER&lt;n&gt;_EL0.TC.</p>
    <p>If PMEVTYPER&lt;n&gt;_EL0.{TC, TH} are both zero and either FEAT_PMUv3_TH2 is not implemented or PMEVTYPER&lt;n&gt;_EL0.TLC is also zero, then the threshold function is disabled.</p>
<p>If PMU.PMMIR_EL1.THWIDTH is less than 12, then bits PMEVTYPER&lt;n&gt;_EL0.TH[11:UInt(PMU.PMMIR_EL1.THWIDTH)] are <span class="arm-defined-word">RES0</span>. This accounts for the behavior when writing a value greater-than-or-equal-to 2<sup>UInt(PMU.PMMIR_EL1.THWIDTH)</sup>.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset:<ul>
            <li>When FEAT_AA32EL1 is implemented,
            this field resets to
            <span class="binarynumber">'000000000000'</span>.
</li>
          
            <li>When FEAT_PMUv3_EXTPMN is not implemented,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-43_32-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-31_31">P, bit [31]</h4><div class="field">
      <p>EL1 filtering. Controls counting events in EL1.</p>
    <table class="valuetable"><tr><th>P</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This mechanism has no effect on filtering of events.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>The PE does not count events in EL1.</p>
        </td></tr></table><p>If Secure and Non-secure states are implemented, then counting events in Non-secure EL1 is further controlled by PMEVTYPER&lt;n&gt;_EL0.NSK.</p>
<p>If <span class="xref">FEAT_RME</span> is implemented, then counting events in Realm EL1 is further controlled by PMEVTYPER&lt;n&gt;_EL0.RLK.</p>
<p>If EL3 is implemented, then counting events in EL3 is further controlled by PMEVTYPER&lt;n&gt;_EL0.M.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-30_30">U, bit [30]</h4><div class="field">
      <p>EL0 filtering. Controls counting events in EL0.</p>
    <table class="valuetable"><tr><th>U</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This mechanism has no effect on filtering of events.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>The PE does not count events in EL0.</p>
        </td></tr></table><p>If Secure and Non-secure states are implemented, then counting events in Non-secure EL0 is further controlled by PMEVTYPER&lt;n&gt;_EL0.NSU.</p>
<p>If <span class="xref">FEAT_RME</span> is implemented, then counting events in Realm EL0 is further controlled by PMEVTYPER&lt;n&gt;_EL0.RLU.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-29_29-1">NSK, bit [29]<span class="condition"><br/>When EL3 is implemented:
                        </span></h4><div class="field">
      <p>Non-secure EL1 filtering. Controls counting events in Non-secure EL1. If PMEVTYPER&lt;n&gt;_EL0.NSK is not equal to PMEVTYPER&lt;n&gt;_EL0.P, then the PE does not count events in Non-secure EL1. Otherwise, this mechanism has no effect on filtering of events in Non-secure EL1.</p>
    <table class="valuetable"><tr><th>NSK</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, the PE does not count events in Non-secure EL1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, the PE does not count events in Non-secure EL1.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-29_29-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-28_28-1">NSU, bit [28]<span class="condition"><br/>When EL3 is implemented:
                        </span></h4><div class="field">
      <p>Non-secure EL0 filtering. Controls counting events in Non-secure EL0. If PMEVTYPER&lt;n&gt;_EL0.NSU is not equal to PMEVTYPER&lt;n&gt;_EL0.U, then the PE does not count events in Non-secure EL0. Otherwise, this mechanism has no effect on filtering of events in Non-secure EL0.</p>
    <table class="valuetable"><tr><th>NSU</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.U == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.U == 1, the PE does not count events in Non-secure EL0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.U == 0, the PE does not count events in Non-secure EL0.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.U == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-28_28-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-27_27-1">NSH, bit [27]<span class="condition"><br/>When EL2 is implemented:
                        </span></h4><div class="field">
      <p>EL2 filtering. Controls counting events in EL2.</p>
    <table class="valuetable"><tr><th>NSH</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>The PE does not count events in EL2.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This mechanism has no effect on filtering of events.</p>
        </td></tr></table><p>If EL3 is implemented and <span class="xref">FEAT_SEL2</span> is implemented, then counting events in Secure EL2 is further controlled by PMEVTYPER&lt;n&gt;_EL0.SH.</p>
<p>If <span class="xref">FEAT_RME</span> is implemented, then counting events in Realm EL2 is further controlled by PMEVTYPER&lt;n&gt;_EL0.RLH.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-27_27-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-26_26-1">M, bit [26]<span class="condition"><br/>When EL3 is implemented and FEAT_AA64 is implemented:
                        </span></h4><div class="field">
      <p>EL3 filtering. Controls counting events in  EL3. If PMEVTYPER&lt;n&gt;_EL0.M is not equal to PMEVTYPER&lt;n&gt;_EL0.P, then the PE does not count events in  EL3. Otherwise, this mechanism has no effect on filtering of events in  EL3.</p>
    <table class="valuetable"><tr><th>M</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, the PE does not count events in  EL3.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, the PE does not count events in  EL3.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-26_26-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-25_25-1">MT, bit [25]<span class="condition"><br/>When FEAT_MTPMU is implemented or an IMPLEMENTATION DEFINED multi-threaded PMU extension is implemented:
                        </span></h4><div class="field">
      <p>Multithreading.</p>
    <table class="valuetable"><tr><th>MT</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Count events only on controlling PE.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Count events from any PE with the same affinity at level 1 and above as this PE.</p>
        </td></tr></table><p>Unless otherwise stated:</p>
<ul>
<li>If the event counts PE cycles when a stall condition is true and a second condition is true, then the counter counts Processor cycles when the stall condition is true for all of these PEs, and the second condition is true for any of these PEs.
</li><li>If the event counts PE cycles when any other condition is true, then the counter counts Processor cycles when the condition is true for any of these PEs.
</li><li>Otherwise, the event counts by the sum of the count across all of these PEs.
</li></ul>
<p>For the stall events, the stall condition means the applicable condition described by the STALL, STALL_FRONTEND, or STALL_BACKEND event.</p>
<p>The second condition is any condition in addition to this.</p>
<p>For example, for the STALL_FRONTEND_L1I event, the stall condition is STALL_FRONTEND, and the second condition is when there is a demand instruction miss in the first level of instruction cache.</p>
<p>For the STALL, STALL_FRONTEND, and STALL_BACKEND events themselves, the second condition is the null TRUE condition.</p>
<p>See <span class="xref">'Multithreaded implementations'</span> and <span class="xref">'Cycle event counting in multithreaded implementations'</span>.</p>
<p>From Armv8.6, the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> multi-threaded PMU extension is not permitted, meaning if <span class="xref">FEAT_MTPMU</span> is not implemented, this field is <span class="arm-defined-word">RES0</span>. See <a href="AArch64-id_aa64dfr0_el1.html">ID_AA64DFR0_EL1</a>.MTPMU.</p>
<p>This field is ignored by the PE and treated as zero when <span class="xref">FEAT_MTPMU</span> is implemented and disabled.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-25_25-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-24_24-1">SH, bit [24]<span class="condition"><br/>When EL3 is implemented and FEAT_SEL2 is implemented:
                        </span></h4><div class="field">
      <p>Secure EL2 filtering. Controls counting events in Secure EL2. If PMEVTYPER&lt;n&gt;_EL0.SH is equal to PMEVTYPER&lt;n&gt;_EL0.NSH, then the PE does not count events in Secure EL2. Otherwise, this mechanism has no effect on filtering of events in Secure EL2.</p>
    <table class="valuetable"><tr><th>SH</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 0, the PE does not count events in Secure EL2.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 1, this mechanism has no effect on filtering of events.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 1, the PE does not count events in Secure EL2.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><p>When Secure EL2 is not implemented, access to this field is <span class="access_level">
          <span class="arm-defined-word">RES0</span>
        </span>.</p></div><h4 id="fieldset_0-24_24-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-23_23">Bit [23]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-22_22-1">RLK, bit [22]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Realm EL1 filtering. Controls counting events in Realm EL1. If PMEVTYPER&lt;n&gt;_EL0.RLK is not equal to PMEVTYPER&lt;n&gt;_EL0.P, then the PE does not count events in Realm EL1. Otherwise, this mechanism has no effect on filtering of events in Realm EL1.</p>
    <table class="valuetable"><tr><th>RLK</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, the PE does not count events in Realm EL1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, the PE does not count events in Realm EL1.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-22_22-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-21_21-1">RLU, bit [21]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Realm EL0 filtering. Controls counting events in Realm EL0. If PMEVTYPER&lt;n&gt;_EL0.RLU is not equal to PMEVTYPER&lt;n&gt;_EL0.U, then the PE does not count events in Realm EL0. Otherwise, this mechanism has no effect on filtering of events in Realm EL0.</p>
    <table class="valuetable"><tr><th>RLU</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.U == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.U == 1, the PE does not count events in Realm EL0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.U == 0, the PE does not count events in Realm EL0.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.U == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-21_21-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-20_20-1">RLH, bit [20]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Realm EL2 filtering. Controls counting events in Realm EL2. If PMEVTYPER&lt;n&gt;_EL0.RLH is equal to PMEVTYPER&lt;n&gt;_EL0.NSH, then the PE does not count events in Realm EL2. Otherwise, this mechanism has no effect on filtering of events in Realm EL2.</p>
    <table class="valuetable"><tr><th>RLH</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 0, the PE does not count events in Realm EL2.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 1, this mechanism has no effect on filtering of events.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 1, the PE does not count events in Realm EL2.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-20_20-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-19_16">Bits [19:16]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-15_10-1">evtCount[15:10], bits [15:10]<span class="condition"><br/>When FEAT_PMUv3p1 is implemented:
                        </span></h4><div class="field">
      <p>Extension to evtCount[9:0]. For more information, see evtCount[9:0].</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-15_10-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-9_0">evtCount[9:0], bits [9:0]</h4><div class="field"><p>Event to count.</p>
<p>The event number of the event that is counted by event counter PMU.PMEVCNTR&lt;n&gt;_EL0.</p>
<p>The ranges of event numbers allocated to each type of event are shown in <span class="xref">'Allocation of the PMU event number space'</span>.</p>
<p>If <span class="xref">FEAT_PMUv3p8</span> is implemented and PMEVTYPER&lt;n&gt;_EL0.evtCount is programmed to an event that is reserved or not supported by the PE, no events are counted and the value returned by a direct or external read of the PMEVTYPER&lt;n&gt;_EL0.evtCount field is the value written to the field.</p>
<div class="note"><span class="note-header">Note</span><p>Arm recommends this behavior for all implementations of <span class="xref">FEAT_PMUv3</span>.</p></div><p>Otherwise, if PMEVTYPER&lt;n&gt;_EL0.evtCount is programmed to an event that is reserved or not supported by the PE, the behavior depends on the value written:</p>
<ul>
<li>For the range <span class="hexnumber">0x0000</span> to <span class="hexnumber">0x003F</span>, no events are counted and the value returned by a direct or external read of the PMEVTYPER&lt;n&gt;_EL0.evtCount field is the value written to the field.
</li><li>If <span class="xref">FEAT_PMUv3p1</span> is implemented, for the range <span class="hexnumber">0x4000</span> to <span class="hexnumber">0x403F</span>, no events are counted and the value returned by a direct or external read of the PMEVTYPER&lt;n&gt;_EL0.evtCount field is the value written to the field.
</li><li>For other values, it is <span class="arm-defined-word">UNPREDICTABLE</span> what event, if any, is counted and the value returned by a direct or external read of the PMEVTYPER&lt;n&gt;_EL0.evtCount field is <span class="arm-defined-word">UNKNOWN</span>.
</li></ul>
<div class="note"><span class="note-header">Note</span><p><span class="arm-defined-word">UNPREDICTABLE</span> means the event must not expose privileged information.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="access_mechanisms"><h2>Accessing PMEVTYPER&lt;n&gt;_EL0</h2>
        <p>If <span class="xref">FEAT_PMUv3_EXT32</span> is implemented and any of the following apply, then bits [63:32] of this register are accessible at offset <span class="hexnumber">0xA00</span> + (4*n):</p>

      
        <ul>
<li><span class="xref">FEAT_PMUv3_TH</span> is implemented.
</li><li><span class="xref">FEAT_PMUv3p8</span> is implemented.
</li><li><span class="xref">FEAT_PMUv3_SME</span> is implemented.
</li></ul>

      
        <p>Otherwise accesses at this offset are <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>

      
        <div class="note"><span class="note-header">Note</span><p>SoftwareLockStatus() depends on the type of access attempted and AllowExternalPMUAccess() has a new definition from Armv8.4. Refer to the Pseudocode definitions for more information.</p></div>
      <p>Accesses to this register use the following encodings:</p><div><h4 class="condition">
When FEAT_PMUv3_EXT64 is implemented
        </h4><p>[63:0] Accessible at offset <span class="hexnumber">0x400 + (8 * n)</span> from PMU</p></div><ul><li>When DoubleLockStatus(), or !IsCorePowered(), or !AllowExternalPMUAccess(addrdesc), accesses to this register generate an error response.
          </li><li>When (FEAT_PMUv3_EXTPMN is not implemented, or !IsMostSecureAccess(addrdesc), or PMCCR().OSLO == 0) and OSLockStatus(), accesses to this register generate an error response.
          </li><li>When FEAT_PMUv3_EXTPMN is implemented, IsRange3Counter(n), and !IsMostSecureAccess(addrdesc), accesses to this register are <span class="access_level">RAZ/WI</span>.
          </li><li>Otherwise, accesses to this register are <span class="access_level">RW</span>.
          </li></ul><table class="access_instructions"><tr/><tr/></table><div><h4 class="condition">
When FEAT_PMUv3_EXT32 is implemented
        </h4><p>[31:0] Accessible at offset <span class="hexnumber">0x400 + (4 * n)</span> from PMU</p></div><ul><li>When DoubleLockStatus(), or !IsCorePowered(), or !AllowExternalPMUAccess(addrdesc), accesses to this register generate an error response.
          </li><li>When (FEAT_PMUv3_EXTPMN is not implemented, or !IsMostSecureAccess(addrdesc), or PMCCR().OSLO == 0) and OSLockStatus(), accesses to this register generate an error response.
          </li><li>When FEAT_PMUv3_EXTPMN is implemented, IsRange3Counter(n), and !IsMostSecureAccess(addrdesc), accesses to this register are <span class="access_level">RAZ/WI</span>.
          </li><li>When SoftwareLockStatus(), accesses to this register are <span class="access_level">RO</span>.
          </li><li>Otherwise, accesses to this register are <span class="access_level">RW</span>.
          </li></ul><table class="access_instructions"><tr/><tr/></table><div><h4 class="condition">
When FEAT_PMUv3_EXT32 is implemented and (FEAT_PMUv3_TH is implemented, or FEAT_PMUv3p8 is implemented, or FEAT_PMUv3_SME is implemented)
        </h4><p>[63:32] Accessible at offset <span class="hexnumber">0xA00 + (4 * n)</span> from PMU</p></div><ul><li>When DoubleLockStatus(), or !IsCorePowered(), or !AllowExternalPMUAccess(addrdesc), accesses to this register generate an error response.
          </li><li>When (FEAT_PMUv3_EXTPMN is not implemented, or !IsMostSecureAccess(addrdesc), or PMCCR().OSLO == 0) and OSLockStatus(), accesses to this register generate an error response.
          </li><li>When FEAT_PMUv3_EXTPMN is implemented, IsRange3Counter(n), and !IsMostSecureAccess(addrdesc), accesses to this register are <span class="access_level">RAZ/WI</span>.
          </li><li>When SoftwareLockStatus(), accesses to this register are <span class="access_level">RO</span>.
          </li><li>Otherwise, accesses to this register are <span class="access_level">RW</span>.
          </li></ul><table class="access_instructions"><tr/><tr/></table></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">2025-10-24 11:39:28, 2025-09_rel_asl1</p><p class="copyconf">Copyright  2010-2025 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
