<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ext="http://exslt.org/common">
  <head>
    <title>PMEVTYPER&lt;n&gt;_EL0</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">PMEVTYPER&lt;n&gt;_EL0, Performance Monitors Event Type Registers, n = 0 - 30</h1><p>The PMEVTYPER&lt;n&gt;_EL0 characteristics are:</p><h2>Purpose</h2>
        <p>Configures event counter n, where n is 0 to 30.</p>
      <h2>Configuration</h2><p>AArch64 System register PMEVTYPER&lt;n&gt;_EL0 bits [31:0] are architecturally mapped to AArch32 System register <a href="AArch32-pmevtypern.html">PMEVTYPER&lt;n&gt;[31:0]</a>.</p><p>AArch64 System register PMEVTYPER&lt;n&gt;_EL0 bits [31:0] are architecturally mapped to External register <a href="pmu.pmevtypern_el0.html">PMEVTYPER&lt;n&gt;_EL0[31:0]</a>.</p><p>AArch64 System register PMEVTYPER&lt;n&gt;_EL0 bits [63:32] are architecturally mapped to External register <a href="pmu.pmevtypern_el0.html">PMEVTYPER&lt;n&gt;_EL0[63:32]</a> when FEAT_PMUv3_TH is implemented, or FEAT_PMUv3p8 is implemented, or FEAT_PMUv3_EXT64 is implemented, or FEAT_PMUv3_SME is implemented.</p><p>This register is present only when FEAT_PMUv3 is implemented and FEAT_AA64 is implemented. Otherwise, direct accesses to PMEVTYPER&lt;n&gt;_EL0 are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2>
        <p>PMEVTYPER&lt;n&gt;_EL0 is a 64-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram" id="fieldset_0"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="3"><a href="#fieldset_0-63_61-1">TC</a></td><td class="lr" colspan="1"><a href="#fieldset_0-60_60-1">TE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-59_59">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-58_58-1">SYNC</a></td><td class="lr" colspan="2"><a href="#fieldset_0-57_56-1">VS</a></td><td class="lr" colspan="2"><a href="#fieldset_0-55_54-1">TLC</a></td><td class="lr" colspan="10"><a href="#fieldset_0-53_44">RES0</a></td><td class="lr" colspan="12"><a href="#fieldset_0-43_32-1">TH</a></td></tr><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-31_31">P</a></td><td class="lr" colspan="1"><a href="#fieldset_0-30_30">U</a></td><td class="lr" colspan="1"><a href="#fieldset_0-29_29-1">NSK</a></td><td class="lr" colspan="1"><a href="#fieldset_0-28_28-1">NSU</a></td><td class="lr" colspan="1"><a href="#fieldset_0-27_27-1">NSH</a></td><td class="lr" colspan="1"><a href="#fieldset_0-26_26-1">M</a></td><td class="lr" colspan="1"><a href="#fieldset_0-25_25-1">MT</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_24-1">SH</a></td><td class="lr" colspan="1"><a href="#fieldset_0-23_23">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-22_22-1">RLK</a></td><td class="lr" colspan="1"><a href="#fieldset_0-21_21-1">RLU</a></td><td class="lr" colspan="1"><a href="#fieldset_0-20_20-1">RLH</a></td><td class="lr" colspan="4"><a href="#fieldset_0-19_16">RES0</a></td><td class="lr" colspan="6"><a href="#fieldset_0-15_10-1">evtCount[15:10]</a></td><td class="lr" colspan="10"><a href="#fieldset_0-9_0">evtCount[9:0]</a></td></tr></tbody></table><h4 id="fieldset_0-63_61-1">TC, bits [63:61]<span class="condition"><br/>When FEAT_PMUv3_TH is implemented, (FEAT_PMUv3_EDGE is not implemented or PMEVTYPER&lt;n&gt;_EL0.TE == 0), and (FEAT_PMUv3_TH2 is not implemented, or n is even, or PMEVTYPER&lt;n&gt;_EL0.TLC IN {0b0x}):
                        </span></h4><div class="field"><p>Threshold Control. Defines the threshold function. In the description of this field:</p>
<ul>
<li>V<sub>B</sub>[n] is the value the event specified by PMEVTYPER&lt;n&gt;_EL0 would increment event counter n by on a processor cycle if the threshold function is disabled.
</li><li>For odd values of n, V[n-1] is the value that event counter n-1 increments by on the same processor cycle. V[n-1] is the result of applying the threshold and edge functions on event counter n-1. If event counter n-1 is disabled, then V[n-1] is zero. V[n-1] is not defined for even values of n.
</li><li>TH[n] is the value of PMEVTYPER&lt;n&gt;_EL0.TH.
</li></ul><table class="valuetable"><tr><th>TC</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td>
          <p>Not-equal. The counter increments by V<sub>B</sub>[n] on each processor cycle when V<sub>B</sub>[n] is not equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b001</td><td>
          <p>Not-equal, count. The counter increments by 1 on each processor cycle when V<sub>B</sub>[n] is not equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b010</td><td>
          <p>Equals. The counter increments by V<sub>B</sub>[n] on each processor cycle when V<sub>B</sub>[n] is equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b011</td><td>
          <p>Equals, count. The counter increments by 1 on each processor cycle when V<sub>B</sub>[n] is equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b100</td><td>
          <p>Greater-than-or-equal. The counter increments by V<sub>B</sub>[n] on each processor cycle when V<sub>B</sub>[n] is greater than or equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b101</td><td>
          <p>Greater-than-or-equal, count. The counter increments by 1 on each processor cycle when V<sub>B</sub>[n] is greater than or equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b110</td><td>
          <p>Less-than. The counter increments by V<sub>B</sub>[n] on each processor cycle when V<sub>B</sub>[n] is less than TH[n].</p>
        </td></tr><tr><td class="bitfield">0b111</td><td>
          <p>Less-than, count. The counter increments by 1 on each processor cycle when V<sub>B</sub>[n] is less than TH[n].</p>
        </td></tr></table><p>Comparisons treat V<sub>B</sub>[n] and TH[n] as unsigned integer values.</p>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC[2:1] is true:</p>
<ul>
<li>If PMEVTYPER&lt;n&gt;_EL0.TC[0] is 0, then the counter increments by V<sub>B</sub>[n].
</li><li>If PMEVTYPER&lt;n&gt;_EL0.TC[0] is 1, then the counter increments by 1.
</li></ul>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC[2:1] is false:</p>
<ul>
<li>If FEAT_PMUv3_TH2 is implemented, n is odd, and PMEVTYPER&lt;n&gt;_EL0.TLC is <span class="binarynumber">0b01</span>, then the counter increments by V[n-1].
</li><li>Otherwise, the counter does not increment.
</li></ul>
<p>If PMEVTYPER&lt;n&gt;_EL0.{TC, TLC, TH} are zero, then the threshold function is disabled.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset:<ul>
            <li>When FEAT_AA32EL1 is implemented,
            this field resets to
            <span class="binarynumber">'000'</span>.
</li>
          
            <li>When FEAT_PMUv3_EXTPMN is not implemented,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-63_61-2"><span class="condition"><br/>When FEAT_PMUv3_TH2 is implemented, PMEVTYPER&lt;n&gt;_EL0.TE == 0, n is odd, and PMEVTYPER&lt;n&gt;_EL0.TLC == 0b10:
                        </span></h4><div class="field"><p>Threshold Control. Defines the threshold function. In the description of this field:</p>
<ul>
<li>V<sub>B</sub>[n] is the value the event specified by PMEVTYPER&lt;n&gt;_EL0 would increment event counter n by on a processor cycle if the threshold function is disabled.
</li><li>V[n-1] is the value that event counter n-1 increments by on the same processor cycle. V[n-1] is the result of applying the threshold and edge functions on event counter n-1. If event counter n-1 is disabled, then V[n-1] is zero.
</li><li>TH[n] is the value of PMEVTYPER&lt;n&gt;_EL0.TH.
</li></ul><table class="valuetable"><tr><th>TC</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td>
          <p>Not-equal. The counter increments by V[n-1] on each processor cycle when V<sub>B</sub>[n] is not equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b010</td><td>
          <p>Equals. The counter increments by V[n-1] on each processor cycle when V<sub>B</sub>[n] is equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b100</td><td>
          <p>Greater-than-or-equal. The counter increments by V[n-1] on each processor cycle when V<sub>B</sub>[n] is greater than or equal to TH[n].</p>
        </td></tr><tr><td class="bitfield">0b110</td><td>
          <p>Less-than. The counter increments by V[n-1] on each processor cycle when V<sub>B</sub>[n] is less than TH[n].</p>
        </td></tr></table><p>All other values are reserved.</p>
<p>Comparisons treat V<sub>B</sub>[n] and TH[n] as unsigned integer values.</p>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC is true, the counter increments by V[n-1].</p>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC is false, the counter does not increment.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset:<ul>
            <li>When FEAT_AA32EL1 is implemented,
            this field resets to
            <span class="binarynumber">'000'</span>.
</li>
          
            <li>When FEAT_PMUv3_EXTPMN is not implemented,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-63_61-3"><span class="condition"><br/>When FEAT_PMUv3_EDGE is implemented and PMEVTYPER&lt;n&gt;_EL0.TE == 1:
                        </span></h4><div class="field"><p>Threshold Control. Defines the threshold function. In the description of this field:</p>
<ul>
<li>V<sub>B</sub>[n] is the value the event specified by PMEVTYPER&lt;n&gt;_EL0 would increment event counter n by on a processor cycle if the threshold function is disabled.
</li><li>For odd values of n, V[n-1] is the value that event counter n-1 increments by on the same processor cycle. V[n-1] is the result of applying the threshold and edge functions on event counter n-1. If event counter n-1 is disabled, then V[n-1] is zero. V[n-1] is not defined for even values of n.
</li><li>TH[n] is the value of PMEVTYPER&lt;n&gt;_EL0.TH.
</li></ul><table class="valuetable"><tr><th>TC</th><th>Meaning</th></tr><tr><td class="bitfield">0b001</td><td>
          <p>Equal to not-equal. The counter increments on each processor cycle when V<sub>B</sub>[n] is not equal to TH[n] and V<sub>B</sub>[n] was equal to TH[n] on the previous processor cycle.</p>
        </td></tr><tr><td class="bitfield">0b010</td><td><p>Equal to/from not-equal. The counter increments on each processor cycle when either:</p>
<ul>
<li>V<sub>B</sub>[n] is not equal to TH[n]  and V<sub>B</sub>[n] was equal to TH[n] on the previous processor cycle.
</li><li>V<sub>B</sub>[n] is equal to TH[n] and V<sub>B</sub>[n] was not equal to TH[n] on the previous processor cycle.
</li></ul></td></tr><tr><td class="bitfield">0b011</td><td>
          <p>Not-equal to equal. The counter increments on each processor cycle when V<sub>B</sub>[n] is equal to TH[n] and V<sub>B</sub>[n] was not equal to TH[n] on the previous processor cycle.</p>
        </td></tr><tr><td class="bitfield">0b101</td><td>
          <p>Less-than to greater-than-or-equal. The counter increments on each processor cycle when V<sub>B</sub>[n] is greater than or equal to TH[n] and V<sub>B</sub>[n] was less than TH[n] on the previous processor cycle.</p>
        </td></tr><tr><td class="bitfield">0b110</td><td><p>Less-than to/from greater-than-or-equal. The counter increments on each processor cycle when either:</p>
<ul>
<li>V<sub>B</sub>[n] is greater than or equal to TH[n] and V<sub>B</sub>[n] was less than TH[n] on the previous processor cycle.
</li><li>V<sub>B</sub>[n] is less than TH[n] and V<sub>B</sub>[n] was greater than or equal to TH[n] on the previous processor cycle.
</li></ul></td></tr><tr><td class="bitfield">0b111</td><td>
          <p>Greater-than-or-equal to less-than. The counter increments on each processor cycle when V<sub>B</sub>[n] is less than TH[n] and V<sub>B</sub>[n] was greater than or equal to TH[n] on the previous processor cycle.</p>
        </td></tr></table><p>All other values are reserved.</p>
<p>Comparisons treat V<sub>B</sub>[n] and TH[n] as unsigned integer values.</p>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC is true:</p>
<ul>
<li>If FEAT_PMUv3_TH2 is implemented, n is odd, and PMEVTYPER&lt;n&gt;_EL0.TLC is <span class="binarynumber">0b10</span>, then the counter increments by V[n-1].
</li><li>Otherwise, the counter increments by 1.
</li></ul>
<p>On each processor cycle when the condition specified by PMEVTYPER&lt;n&gt;_EL0.TC is false, the counter does not increment.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset:<ul>
            <li>When FEAT_AA32EL1 is implemented,
            this field resets to
            <span class="binarynumber">'000'</span>.
</li>
          
            <li>When FEAT_PMUv3_EXTPMN is not implemented,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-63_61-4"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-60_60-1">TE, bit [60]<span class="condition"><br/>When FEAT_PMUv3_EDGE is implemented:
                        </span></h4><div class="field">
      <p>Threshold Edge. Enables the edge condition. When PMEVTYPER&lt;n&gt;_EL0.TE is 1, the event counter increments on cycles when the result of the threshold condition changes. See PMEVTYPER&lt;n&gt;_EL0.TC for more information.</p>
    <table class="valuetable"><tr><th>TE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Threshold edge condition disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Threshold edge condition enabled.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset:<ul>
            <li>When FEAT_AA32EL1 is implemented,
            this field resets to
            <span class="binarynumber">'0'</span>.
</li>
          
            <li>When FEAT_PMUv3_EXTPMN is not implemented,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-60_60-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-59_59">Bit [59]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-58_58-1">SYNC, bit [58]<span class="condition"><br/>When FEAT_SEBEP is implemented:
                        </span></h4><div class="field">
      <p>Synchronous mode. Controls whether a PMU Profiling exception generated by the counter is synchronous or asynchronous.</p>
    <table class="valuetable"><tr><th>SYNC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Asynchronous PMU Profiling exception is enabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Synchronous PMU Profiling exception is enabled.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-58_58-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-57_56-1">VS, bits [57:56]<span class="condition"><br/>When FEAT_PMUv3_SME is implemented:
                        </span></h4><div class="field">
      <p>SVE mode filtering. Controls counting events in Streaming and Non-streaming SVE modes.</p>
    <table class="valuetable"><tr><th>VS</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>This mechanism has no effect on the filtering of events.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>The PE does not count events in Streaming SVE mode.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>The PE does not count events in Non-streaming SVE mode.</p>
        </td></tr></table>
      <p>All other values are reserved.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-57_56-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-55_54-1">TLC, bits [55:54]<span class="condition"><br/>When FEAT_PMUv3_TH2 is implemented and n is odd:
                        </span></h4><div class="field">
      <p>Threshold Linking Control. Extends PMEVTYPER&lt;n&gt;_EL0.TC with additional controls for event linking. See PMEVTYPER&lt;n&gt;_EL0.TC.</p>
    <table class="valuetable"><tr><th>TLC</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>Threshold linking disabled.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>Threshold linking enabled. If the threshold condition described by PMEVTYPER&lt;n&gt;_EL0.TC is false, the counter increments by V[n-1]. Otherwise, the counter increments as described by PMEVTYPER&lt;n&gt;_EL0.TC.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>Threshold linking enabled. If the threshold condition described by PMEVTYPER&lt;n&gt;_EL0.TC is true, the counter increments by V[n-1]. Otherwise, the counter does not increment.</p>
        </td></tr></table><p>All other values are reserved.</p>
<p>See PMEVTYPER&lt;n&gt;_EL0.TC for more information</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_54-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-53_44">Bits [53:44]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-43_32-1">TH, bits [43:32]<span class="condition"><br/>When FEAT_PMUv3_TH is implemented:
                        </span></h4><div class="field">
      <p>Threshold value. Provides the unsigned value for the threshold function defined by PMEVTYPER&lt;n&gt;_EL0.TC.</p>
    <p>If PMEVTYPER&lt;n&gt;_EL0.{TC, TH} are both zero and either FEAT_PMUv3_TH2 is not implemented or PMEVTYPER&lt;n&gt;_EL0.TLC is also zero, then the threshold function is disabled.</p>
<p>If <a href="AArch64-pmmir_el1.html">PMMIR_EL1</a>.THWIDTH is less than 12, then bits PMEVTYPER&lt;n&gt;_EL0.TH[11:UInt(<a href="AArch64-pmmir_el1.html">PMMIR_EL1</a>.THWIDTH)] are <span class="arm-defined-word">RES0</span>. This accounts for the behavior when writing a value greater-than-or-equal-to 2<sup>UInt(<a href="AArch64-pmmir_el1.html">PMMIR_EL1</a>.THWIDTH)</sup>.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset:<ul>
            <li>When FEAT_AA32EL1 is implemented,
            this field resets to
            <span class="binarynumber">'000000000000'</span>.
</li>
          
            <li>When FEAT_PMUv3_EXTPMN is not implemented,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-43_32-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-31_31">P, bit [31]</h4><div class="field">
      <p>EL1 filtering. Controls counting events in EL1.</p>
    <table class="valuetable"><tr><th>P</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This mechanism has no effect on filtering of events.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>The PE does not count events in EL1.</p>
        </td></tr></table><p>If Secure and Non-secure states are implemented, then counting events in Non-secure EL1 is further controlled by PMEVTYPER&lt;n&gt;_EL0.NSK.</p>
<p>If <span class="xref">FEAT_RME</span> is implemented, then counting events in Realm EL1 is further controlled by PMEVTYPER&lt;n&gt;_EL0.RLK.</p>
<p>If EL3 is implemented, then counting events in EL3 is further controlled by PMEVTYPER&lt;n&gt;_EL0.M.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-30_30">U, bit [30]</h4><div class="field">
      <p>EL0 filtering. Controls counting events in EL0.</p>
    <table class="valuetable"><tr><th>U</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This mechanism has no effect on filtering of events.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>The PE does not count events in EL0.</p>
        </td></tr></table><p>If Secure and Non-secure states are implemented, then counting events in Non-secure EL0 is further controlled by PMEVTYPER&lt;n&gt;_EL0.NSU.</p>
<p>If <span class="xref">FEAT_RME</span> is implemented, then counting events in Realm EL0 is further controlled by PMEVTYPER&lt;n&gt;_EL0.RLU.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-29_29-1">NSK, bit [29]<span class="condition"><br/>When EL3 is implemented:
                        </span></h4><div class="field">
      <p>Non-secure EL1 filtering. Controls counting events in Non-secure EL1. If PMEVTYPER&lt;n&gt;_EL0.NSK is not equal to PMEVTYPER&lt;n&gt;_EL0.P, then the PE does not count events in Non-secure EL1. Otherwise, this mechanism has no effect on filtering of events in Non-secure EL1.</p>
    <table class="valuetable"><tr><th>NSK</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, the PE does not count events in Non-secure EL1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, the PE does not count events in Non-secure EL1.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-29_29-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-28_28-1">NSU, bit [28]<span class="condition"><br/>When EL3 is implemented:
                        </span></h4><div class="field">
      <p>Non-secure EL0 filtering. Controls counting events in Non-secure EL0. If PMEVTYPER&lt;n&gt;_EL0.NSU is not equal to PMEVTYPER&lt;n&gt;_EL0.U, then the PE does not count events in Non-secure EL0. Otherwise, this mechanism has no effect on filtering of events in Non-secure EL0.</p>
    <table class="valuetable"><tr><th>NSU</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.U == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.U == 1, the PE does not count events in Non-secure EL0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.U == 0, the PE does not count events in Non-secure EL0.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.U == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-28_28-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-27_27-1">NSH, bit [27]<span class="condition"><br/>When EL2 is implemented:
                        </span></h4><div class="field">
      <p>EL2 filtering. Controls counting events in EL2.</p>
    <table class="valuetable"><tr><th>NSH</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>The PE does not count events in EL2.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This mechanism has no effect on filtering of events.</p>
        </td></tr></table><p>If EL3 is implemented and <span class="xref">FEAT_SEL2</span> is implemented, then counting events in Secure EL2 is further controlled by PMEVTYPER&lt;n&gt;_EL0.SH.</p>
<p>If <span class="xref">FEAT_RME</span> is implemented, then counting events in Realm EL2 is further controlled by PMEVTYPER&lt;n&gt;_EL0.RLH.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-27_27-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-26_26-1">M, bit [26]<span class="condition"><br/>When EL3 is implemented:
                        </span></h4><div class="field">
      <p>EL3 filtering. Controls counting events in  EL3. If PMEVTYPER&lt;n&gt;_EL0.M is not equal to PMEVTYPER&lt;n&gt;_EL0.P, then the PE does not count events in  EL3. Otherwise, this mechanism has no effect on filtering of events in  EL3.</p>
    <table class="valuetable"><tr><th>M</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, the PE does not count events in  EL3.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, the PE does not count events in  EL3.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-26_26-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-25_25-1">MT, bit [25]<span class="condition"><br/>When FEAT_MTPMU is implemented or an IMPLEMENTATION DEFINED multi-threaded PMU extension is implemented:
                        </span></h4><div class="field">
      <p>Multithreading.</p>
    <table class="valuetable"><tr><th>MT</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Count events only on controlling PE.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Count events from any PE with the same affinity at level 1 and above as this PE.</p>
        </td></tr></table><p>Unless otherwise stated:</p>
<ul>
<li>If the event counts PE cycles when a stall condition is true and a second condition is true, then the counter counts Processor cycles when the stall condition is true for all of these PEs, and the second condition is true for any of these PEs.
</li><li>If the event counts PE cycles when any other condition is true, then the counter counts Processor cycles when the condition is true for any of these PEs.
</li><li>Otherwise, the event counts by the sum of the count across all of these PEs.
</li></ul>
<p>For the stall events, the stall condition means the applicable condition described by the STALL, STALL_FRONTEND, or STALL_BACKEND event.</p>
<p>The second condition is any condition in addition to this.</p>
<p>For example, for the STALL_FRONTEND_L1I event, the stall condition is STALL_FRONTEND, and the second condition is when there is a demand instruction miss in the first level of instruction cache.</p>
<p>For the STALL, STALL_FRONTEND, and STALL_BACKEND events themselves, the second condition is the null TRUE condition.</p>
<p>See <span class="xref">'Multithreaded implementations'</span> and <span class="xref">'Cycle event counting in multithreaded implementations'</span>.</p>
<p>From Armv8.6, the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> multi-threaded PMU extension is not permitted, meaning if <span class="xref">FEAT_MTPMU</span> is not implemented, this field is <span class="arm-defined-word">RES0</span>. See <a href="AArch64-id_aa64dfr0_el1.html">ID_AA64DFR0_EL1</a>.MTPMU.</p>
<p>This field is ignored by the PE and treated as zero when <span class="xref">FEAT_MTPMU</span> is implemented and disabled.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-25_25-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-24_24-1">SH, bit [24]<span class="condition"><br/>When EL3 is implemented and FEAT_SEL2 is implemented:
                        </span></h4><div class="field">
      <p>Secure EL2 filtering. Controls counting events in Secure EL2. If PMEVTYPER&lt;n&gt;_EL0.SH is equal to PMEVTYPER&lt;n&gt;_EL0.NSH, then the PE does not count events in Secure EL2. Otherwise, this mechanism has no effect on filtering of events in Secure EL2.</p>
    <table class="valuetable"><tr><th>SH</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 0, the PE does not count events in Secure EL2.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 1, this mechanism has no effect on filtering of events.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 1, the PE does not count events in Secure EL2.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><p>When Secure EL2 is not implemented, access to this field is <span class="access_level">
          <span class="arm-defined-word">RES0</span>
        </span>.</p></div><h4 id="fieldset_0-24_24-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-23_23">Bit [23]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-22_22-1">RLK, bit [22]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Realm EL1 filtering. Controls counting events in Realm EL1. If PMEVTYPER&lt;n&gt;_EL0.RLK is not equal to PMEVTYPER&lt;n&gt;_EL0.P, then the PE does not count events in Realm EL1. Otherwise, this mechanism has no effect on filtering of events in Realm EL1.</p>
    <table class="valuetable"><tr><th>RLK</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, the PE does not count events in Realm EL1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.P == 0, the PE does not count events in Realm EL1.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.P == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-22_22-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-21_21-1">RLU, bit [21]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Realm EL0 filtering. Controls counting events in Realm EL0. If PMEVTYPER&lt;n&gt;_EL0.RLU is not equal to PMEVTYPER&lt;n&gt;_EL0.U, then the PE does not count events in Realm EL0. Otherwise, this mechanism has no effect on filtering of events in Realm EL0.</p>
    <table class="valuetable"><tr><th>RLU</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.U == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.U == 1, the PE does not count events in Realm EL0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.U == 0, the PE does not count events in Realm EL0.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.U == 1, this mechanism has no effect on filtering of events.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-21_21-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-20_20-1">RLH, bit [20]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Realm EL2 filtering. Controls counting events in Realm EL2. If PMEVTYPER&lt;n&gt;_EL0.RLH is equal to PMEVTYPER&lt;n&gt;_EL0.NSH, then the PE does not count events in Realm EL2. Otherwise, this mechanism has no effect on filtering of events in Realm EL2.</p>
    <table class="valuetable"><tr><th>RLH</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 0, the PE does not count events in Realm EL2.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 1, this mechanism has no effect on filtering of events.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 0, this mechanism has no effect on filtering of events.</p>
<p>When PMEVTYPER&lt;n&gt;_EL0.NSH == 1, the PE does not count events in Realm EL2.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-20_20-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-19_16">Bits [19:16]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-15_10-1">evtCount[15:10], bits [15:10]<span class="condition"><br/>When FEAT_PMUv3p1 is implemented:
                        </span></h4><div class="field">
      <p>Extension to evtCount[9:0]. For more information, see evtCount[9:0].</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-15_10-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-9_0">evtCount[9:0], bits [9:0]</h4><div class="field"><p>Event to count.</p>
<p>The event number of the event that is counted by event counter <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>.</p>
<p>The ranges of event numbers allocated to each type of event are shown in <span class="xref">'Allocation of the PMU event number space'</span>.</p>
<p>If <span class="xref">FEAT_PMUv3p8</span> is implemented and PMEVTYPER&lt;n&gt;_EL0.evtCount is programmed to an event that is reserved or not supported by the PE, no events are counted and the value returned by a direct or external read of the PMEVTYPER&lt;n&gt;_EL0.evtCount field is the value written to the field.</p>
<div class="note"><span class="note-header">Note</span><p>Arm recommends this behavior for all implementations of <span class="xref">FEAT_PMUv3</span>.</p></div><p>Otherwise, if PMEVTYPER&lt;n&gt;_EL0.evtCount is programmed to an event that is reserved or not supported by the PE, the behavior depends on the value written:</p>
<ul>
<li>For the range <span class="hexnumber">0x0000</span> to <span class="hexnumber">0x003F</span>, no events are counted and the value returned by a direct or external read of the PMEVTYPER&lt;n&gt;_EL0.evtCount field is the value written to the field.
</li><li>If <span class="xref">FEAT_PMUv3p1</span> is implemented, for the range <span class="hexnumber">0x4000</span> to <span class="hexnumber">0x403F</span>, no events are counted and the value returned by a direct or external read of the PMEVTYPER&lt;n&gt;_EL0.evtCount field is the value written to the field.
</li><li>For other values, it is <span class="arm-defined-word">UNPREDICTABLE</span> what event, if any, is counted and the value returned by a direct or external read of the PMEVTYPER&lt;n&gt;_EL0.evtCount field is <span class="arm-defined-word">UNKNOWN</span>.
</li></ul>
<div class="note"><span class="note-header">Note</span><p><span class="arm-defined-word">UNPREDICTABLE</span> means the event must not expose privileged information.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, when FEAT_PMUv3_EXTPMN is implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li><li>On a Warm reset, when FEAT_PMUv3_EXTPMN is not implemented, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="access_mechanisms"><h2>Accessing PMEVTYPER&lt;n&gt;_EL0</h2>
        <p>PMEVTYPER&lt;n&gt;_EL0 can also be accessed by using <a href="AArch64-pmxevtyper_el0.html">PMXEVTYPER_EL0</a> with <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a>.SEL set to n.</p>

      
        <p>If <span class="xref">FEAT_FGT</span> is implemented and &lt;n&gt; is greater than or equal to the number of accessible event counters, then the behavior of permitted reads and writes of PMEVTYPER&lt;n&gt;_EL0 is as follows:</p>

      
        <ul>
<li>If &lt;n&gt; is greater than or equal to the Effective value of <a href="pmu.pmccr.html">PMCCR</a>.EPMN, the access is <span class="arm-defined-word">UNDEFINED</span>.
</li><li>Otherwise, the access is trapped to EL2.
</li></ul>

      
        <p>If <span class="xref">FEAT_FGT</span> is not implemented and &lt;n&gt; is greater than or equal to the number of accessible event counters, then reads and writes of PMEVTYPER&lt;n&gt;_EL0 are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, and the following behaviors are permitted:</p>

      
        <ul>
<li>Accesses to the register are <span class="arm-defined-word">UNDEFINED</span>.
</li><li>Accesses to the register behave as RAZ/WI.
</li><li>Accesses to the register execute as a <span class="instruction">NOP</span>.
</li><li>Accesses to the register behave as if &lt;n&gt; is an <span class="arm-defined-word">UNKNOWN</span> value less-than-or-equal-to the index of the highest accessible event counter.
</li><li>If EL2 is implemented and enabled in the current Security state, and &lt;n&gt; is less than the number of implemented event counters, accesses from EL1 or permitted accesses from EL0 are trapped to EL2.
</li></ul>

      
        <p>Permitted reads and writes of PMEVTYPER&lt;n&gt;_EL0 are RAZ/WI if all of the following are true:</p>

      
        <ul>
<li>FEAT_PMUv3p9 is implemented.
</li><li>PSTATE.EL == EL0.
</li><li><a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.UEN == 1.
</li><li><a href="AArch64-pmuacr_el1.html">PMUACR_EL1</a>.P&lt;n&gt; == 0.
</li></ul>

      
        <p>Permitted writes of PMEVTYPER&lt;n&gt;_EL0 are ignored if all of the following are true:</p>

      
        <ul>
<li>FEAT_PMUv3p9 is implemented.
</li><li>PSTATE.EL == EL0.
</li><li><a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.{UEN,ER} == {1,1}.
</li></ul>

      
        <div class="note"><span class="note-header">Note</span><p>In EL0, an access is permitted if it is enabled by <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.{UEN,EN}.</p><p>If EL2 is implemented and enabled in the current Security state, in EL1 and EL0, <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN identifies the number of accessible event counters. Otherwise, the number of accessible event counters is the number of implemented event counters. For more information, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p></div>
      <p>Accesses to this register use the following encodings in the System register encoding space:</p><div><h4 class="assembler">MRS &lt;Xt&gt;, PMEVTYPER&lt;m&gt;_EL0
      ; Where m = 0-30</h4></div><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b011</td><td>0b1110</td><td>0b11:m[4:3]</td><td>m[2:0]</td></tr></table><p class="pseudocode">
let m:integer = UInt(CRm[1:0] :: op2[2:0]);

if !(IsFeatureImplemented(FEAT_PMUv3) &amp;&amp; IsFeatureImplemented(FEAT_AA64)) then
    Undefined();
elsif m &gt;= GetNumEventCountersSelfHosted() then
    if IsFeatureImplemented(FEAT_FGT) then
        Undefined();
    else
        ConstrainUnpredictableProcedure(Unpredictable_PMUEVENTCOUNTER);
    end;
elsif PSTATE.EL == EL0 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3().TPM == '1' then
        Undefined();
    elsif PMUSERENR_EL0().EN == '0' &amp;&amp; (!IsFeatureImplemented(FEAT_PMUv3p9) || PMUSERENR_EL0().UEN == '0') then
        if EL2Enabled() &amp;&amp; HCR_EL2().TGE == '1' then
            AArch64_SystemAccessTrap(EL2, 0x18);
        else
            AArch64_SystemAccessTrap(EL1, 0x18);
        end;
    elsif EL2Enabled() &amp;&amp; !ELIsInHost(EL0) &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3().FGTEn == '1') &amp;&amp; HDFGRTR_EL2().PMEVTYPERn_EL0 == '1' then
        AArch64_SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2().TPM == '1' then
        AArch64_SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; m &gt;= GetNumEventCountersAccessible() then
        if !IsFeatureImplemented(FEAT_FGT) then
            ConstrainUnpredictableProcedure(Unpredictable_PMUEVENTCOUNTER);
        else
            AArch64_SystemAccessTrap(EL2, 0x18);
        end;
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3().TPM == '1' then
        if EL3SDDUndef() then
            Undefined();
        else
            AArch64_SystemAccessTrap(EL3, 0x18);
        end;
    elsif IsFeatureImplemented(FEAT_PMUv3p9) &amp;&amp; PMUSERENR_EL0().UEN == '1' &amp;&amp; PMUACR_EL1()[m] == '0' then
        X{64}(t) = Zeros{64};
    else
        X{64}(t) = PMEVTYPER_EL0(m);
    end;
elsif PSTATE.EL == EL1 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3().TPM == '1' then
        Undefined();
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3().FGTEn == '1') &amp;&amp; HDFGRTR_EL2().PMEVTYPERn_EL0 == '1' then
        AArch64_SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2().TPM == '1' then
        AArch64_SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; m &gt;= GetNumEventCountersAccessible() then
        if !IsFeatureImplemented(FEAT_FGT) then
            ConstrainUnpredictableProcedure(Unpredictable_PMUEVENTCOUNTER);
        else
            AArch64_SystemAccessTrap(EL2, 0x18);
        end;
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3().TPM == '1' then
        if EL3SDDUndef() then
            Undefined();
        else
            AArch64_SystemAccessTrap(EL3, 0x18);
        end;
    else
        X{64}(t) = PMEVTYPER_EL0(m);
    end;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3().TPM == '1' then
        Undefined();
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3().TPM == '1' then
        if EL3SDDUndef() then
            Undefined();
        else
            AArch64_SystemAccessTrap(EL3, 0x18);
        end;
    else
        X{64}(t) = PMEVTYPER_EL0(m);
    end;
elsif PSTATE.EL == EL3 then
    X{64}(t) = PMEVTYPER_EL0(m);
end;
                </p><div><h4 class="assembler">MSR PMEVTYPER&lt;m&gt;_EL0, &lt;Xt&gt;
      ; Where m = 0-30</h4></div><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b011</td><td>0b1110</td><td>0b11:m[4:3]</td><td>m[2:0]</td></tr></table><p class="pseudocode">
let m:integer = UInt(CRm[1:0] :: op2[2:0]);

if !(IsFeatureImplemented(FEAT_PMUv3) &amp;&amp; IsFeatureImplemented(FEAT_AA64)) then
    Undefined();
elsif m &gt;= GetNumEventCountersSelfHosted() then
    if IsFeatureImplemented(FEAT_FGT) then
        Undefined();
    else
        ConstrainUnpredictableProcedure(Unpredictable_PMUEVENTCOUNTER);
    end;
elsif PSTATE.EL == EL0 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3().TPM == '1' then
        Undefined();
    elsif PMUSERENR_EL0().EN == '0' &amp;&amp; (!IsFeatureImplemented(FEAT_PMUv3p9) || PMUSERENR_EL0().UEN == '0') then
        if EL2Enabled() &amp;&amp; HCR_EL2().TGE == '1' then
            AArch64_SystemAccessTrap(EL2, 0x18);
        else
            AArch64_SystemAccessTrap(EL1, 0x18);
        end;
    elsif EL2Enabled() &amp;&amp; !ELIsInHost(EL0) &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3().FGTEn == '1') &amp;&amp; HDFGWTR_EL2().PMEVTYPERn_EL0 == '1' then
        AArch64_SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2().TPM == '1' then
        AArch64_SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; m &gt;= GetNumEventCountersAccessible() then
        if !IsFeatureImplemented(FEAT_FGT) then
            ConstrainUnpredictableProcedure(Unpredictable_PMUEVENTCOUNTER);
        else
            AArch64_SystemAccessTrap(EL2, 0x18);
        end;
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3().TPM == '1' then
        if EL3SDDUndef() then
            Undefined();
        else
            AArch64_SystemAccessTrap(EL3, 0x18);
        end;
    elsif IsFeatureImplemented(FEAT_PMUv3p9) &amp;&amp; PMUSERENR_EL0().UEN == '1' &amp;&amp; (PMUACR_EL1()[m] == '0' || PMUSERENR_EL0().ER == '1') then
        return;
    else
        PMEVTYPER_EL0(m) = X{64}(t);
    end;
elsif PSTATE.EL == EL1 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3().TPM == '1' then
        Undefined();
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3().FGTEn == '1') &amp;&amp; HDFGWTR_EL2().PMEVTYPERn_EL0 == '1' then
        AArch64_SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2().TPM == '1' then
        AArch64_SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; m &gt;= GetNumEventCountersAccessible() then
        if !IsFeatureImplemented(FEAT_FGT) then
            ConstrainUnpredictableProcedure(Unpredictable_PMUEVENTCOUNTER);
        else
            AArch64_SystemAccessTrap(EL2, 0x18);
        end;
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3().TPM == '1' then
        if EL3SDDUndef() then
            Undefined();
        else
            AArch64_SystemAccessTrap(EL3, 0x18);
        end;
    else
        PMEVTYPER_EL0(m) = X{64}(t);
    end;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3().TPM == '1' then
        Undefined();
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3().TPM == '1' then
        if EL3SDDUndef() then
            Undefined();
        else
            AArch64_SystemAccessTrap(EL3, 0x18);
        end;
    else
        PMEVTYPER_EL0(m) = X{64}(t);
    end;
elsif PSTATE.EL == EL3 then
    PMEVTYPER_EL0(m) = X{64}(t);
end;
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">2025-10-24 11:39:28, 2025-09_rel_asl1</p><p class="copyconf">Copyright  2010-2025 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
