<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ext="http://exslt.org/common">
  <head>
    <title>SSBS</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">SSBS, Speculative Store Bypass Safe</h1><p>The SSBS characteristics are:</p><h2>Purpose</h2>
        <p>Allows access to the Speculative Store Bypass Safe bit.</p>
      <h2>Configuration</h2><p>This register is present only when FEAT_SSBS2 is implemented and FEAT_AA64 is implemented. Otherwise, direct accesses to SSBS are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2>
        <p>SSBS is a 64-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram" id="fieldset_0"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_0-63_13">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="19"><a href="#fieldset_0-63_13">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-12_12">SSBS</a></td><td class="lr" colspan="12"><a href="#fieldset_0-11_0">RES0</a></td></tr></tbody></table><h4 id="fieldset_0-63_13">Bits [63:13]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-12_12">SSBS, bit [12]</h4><div class="field"><p>Speculative Store Bypass Safe.</p>
<p>Prohibits speculative loads or stores which might practically allow a cache timing side channel.</p>
<p>A speculative value in a register is used in a potentially speculatively exploitable manner if it is used to form an address, generate condition codes, or generate SVE predicate values to be used by other instructions in the speculative sequence or if the execution timing of any other instructions in the speculative sequence is a function of the data loaded under speculation.</p><table class="valuetable"><tr><th>SSBS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Hardware is not permitted to use speculative register values in a potentially speculatively exploitable manner if the speculative read that loads the register is from earlier in the coherence order than the entry generated by the latest store to that location using the same virtual address as the load instruction.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>When the value of PSTATE.SSBS is 1, hardware is permitted to use speculative register values in a potentially speculatively exploitable manner if the speculative read that loads the register is from earlier in the coherence order than the entry generated by the latest store to that location using the same virtual address as the load instruction.</p>
        </td></tr></table>
      <p>The value of this bit is set to the value in the SCTLR_ELx.DSSBS field on taking an exception to ELx.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</li></ul></div><h4 id="fieldset_0-11_0">Bits [11:0]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><div class="access_mechanisms"><h2>Accessing SSBS</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><div><h4 class="assembler">MRS &lt;Xt&gt;, SSBS</h4></div><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b011</td><td>0b0100</td><td>0b0010</td><td>0b110</td></tr></table><p class="pseudocode">
if !(IsFeatureImplemented(FEAT_SSBS2) &amp;&amp; IsFeatureImplemented(FEAT_AA64)) then
    Undefined();
elsif PSTATE.EL == EL0 then
    X{64}(t) = Zeros{51} :: PSTATE.SSBS :: Zeros{12};
elsif PSTATE.EL == EL1 then
    X{64}(t) = Zeros{51} :: PSTATE.SSBS :: Zeros{12};
elsif PSTATE.EL == EL2 then
    X{64}(t) = Zeros{51} :: PSTATE.SSBS :: Zeros{12};
elsif PSTATE.EL == EL3 then
    X{64}(t) = Zeros{51} :: PSTATE.SSBS :: Zeros{12};
end;
                </p><div><h4 class="assembler">MSR SSBS, &lt;Xt&gt;</h4></div><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b011</td><td>0b0100</td><td>0b0010</td><td>0b110</td></tr></table><p class="pseudocode">
if !(IsFeatureImplemented(FEAT_SSBS2) &amp;&amp; IsFeatureImplemented(FEAT_AA64)) then
    Undefined();
elsif PSTATE.EL == EL0 then
    PSTATE.SSBS = X{64}(t)[12];
elsif PSTATE.EL == EL1 then
    PSTATE.SSBS = X{64}(t)[12];
elsif PSTATE.EL == EL2 then
    PSTATE.SSBS = X{64}(t)[12];
elsif PSTATE.EL == EL3 then
    PSTATE.SSBS = X{64}(t)[12];
end;
                </p><div><h4 class="assembler">MSR SSBS, #&lt;imm&gt;</h4></div><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>op2</th></tr><tr><td>0b00</td><td>0b011</td><td>0b0100</td><td>0b001</td></tr></table></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">2025-10-24 11:39:28, 2025-09_rel_asl1</p><p class="copyconf">Copyright Â© 2010-2025 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
