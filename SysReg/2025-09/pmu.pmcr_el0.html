<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ext="http://exslt.org/common">
  <head>
    <title>PMCR_EL0</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">PMCR_EL0, Performance Monitors Control Register</h1><p>The PMCR_EL0 characteristics are:</p><h2>Purpose</h2>
        <p>Configures and controls the Performance Monitors counters.</p>
      <h2>Configuration</h2><p>External register PMCR_EL0 bits [63:32] are architecturally mapped to AArch64 System register <a href="AArch64-pmcr_el0.html">PMCR_EL0[63:32]</a> when FEAT_PMUv3_EXT64 is implemented.</p><p>External register PMCR_EL0 bits [31:0] are architecturally mapped to AArch64 System register <a href="AArch64-pmcr_el0.html">PMCR_EL0[31:0]</a>.</p><p>External register PMCR_EL0 bits [10:0] are architecturally mapped to AArch32 System register <a href="AArch32-pmcr.html">PMCR[10:0]</a>.</p><p>This register is present only when FEAT_PMUv3_EXT is implemented. Otherwise, direct accesses to PMCR_EL0 are <span class="arm-defined-word">RES0</span>.</p>
        <p>PMCR_EL0 is in the Core power domain.</p>

      
        <p>This register is only partially mapped to the internal <a href="AArch32-pmcr.html">PMCR</a> System register. An external agent must use other means to discover the information held in <a href="AArch32-pmcr.html">PMCR</a>[31:11], such as accessing <a href="pmu.pmcfgr.html">PMCFGR</a> and the ID registers.</p>
      <h2>Attributes</h2>
        <p>PMCR_EL0 is a:</p>

      
        <ul>
<li>64-bit register when FEAT_PMUv3_EXT64 is implemented
</li><li>32-bit register otherwise
</li></ul>
      <p>This  register is part of the <a href="pmu.html">PMU</a> block.</p><h2>Field descriptions</h2><h3>When FEAT_PMUv3_EXT64 is implemented:</h3><table class="regdiagram" id="fieldset_0"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="31"><a href="#fieldset_0-63_33">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-32_32-1">FZS</a></td></tr><tr class="firstrow"><td class="lr" colspan="21"><a href="#fieldset_0-31_11">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#fieldset_0-10_10">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-9_9-1">FZO</a></td><td class="lr" colspan="1"><a href="#fieldset_0-8_8">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-7_7-1">LP</a></td><td class="lr" colspan="1"><a href="#fieldset_0-6_6-1">LC</a></td><td class="lr" colspan="1"><a href="#fieldset_0-5_5-1">DP</a></td><td class="lr" colspan="1"><a href="#fieldset_0-4_4-1">X</a></td><td class="lr" colspan="1"><a href="#fieldset_0-3_3-1">D</a></td><td class="lr" colspan="1"><a href="#fieldset_0-2_2">C</a></td><td class="lr" colspan="1"><a href="#fieldset_0-1_1">P</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0">E</a></td></tr></tbody></table><h4 id="fieldset_0-63_33">Bits [63:33]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-32_32-1">FZS, bit [32]<span class="condition"><br/>When FEAT_SPEv1p2 is implemented:
                        </span></h4><div class="field">
      <p>Freeze-on-SPE event. Stop counters when <a href="AArch64-pmblimitr_el1.html">PMBLIMITR_EL1</a>.{PMFZ,E} is {1,1} and profiling is stopped.</p>
    <table class="valuetable"><tr><th>FZS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Do not freeze on a Statistical Profiling Buffer Management event.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Affected counters do not count following a Statistical Profiling Buffer Management event.</p>
        </td></tr></table><p>The pseudocode function <span class="function">SPEProfilingStopped</span> describes when profiling is stopped.</p>
<p>The counters affected by this field are:</p>
<ul>
<li>The event counters in the first range.
</li><li>If <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, the instruction counter <a href="pmu.pmicntr_el0.html">PMICNTR_EL0</a>.
</li><li>If <span class="xref">FEAT_SPE_DPFZS</span> is implemented and PMCR_EL0.DP is 1, the cycle counter <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a>.
</li></ul>
<p>Other event counters are not affected by this field.</p>
<p>When <span class="xref">FEAT_SPE_DPFZS</span> is not implemented or PMCR_EL0.DP is 0, <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this field.</p>
<p>For more information about event counter ranges, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When FEAT_AA32 is implemented,
            this field resets to
            <span class="binarynumber">'0'</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-32_32-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-31_11">Bits [31:11]</h4><div class="field">
      <p>Reserved, RAZ/WI.</p>
    
      <p>Hardware must implement this field as RAZ/WI. Software must not rely on the register reading as zero, and must use a read-modify-write sequence to write to the register.</p>
    </div><h4 id="fieldset_0-10_10">Bit [10]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-9_9-1">FZO, bit [9]<span class="condition"><br/>When FEAT_PMUv3p7 is implemented:
                        </span></h4><div class="field">
      <p>Freeze-on-overflow. Stop event counters on overflow.</p>
    <table class="valuetable"><tr><th>FZO</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Do not freeze on overflow.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td><p>Affected counters do not count when any of the following applies:</p>
<ul>
<li>
<p>For any event counter <a href="pmu.pmevcntrn_el0.html">PMEVCNTR&lt;m&gt;_EL0</a> in the first range, <a href="pmu.pmovsclr_el0.html">PMOVSCLR_EL0</a>[m] is 1, and either <span class="xref">FEAT_SEBEP</span> is not implemented or <a href="pmu.pmevtypern_el0.html">PMEVTYPER&lt;m&gt;_EL0</a>.SYNC is 0.</p>

</li><li>
<p><span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, <a href="pmu.pmovsclr_el0.html">PMOVSCLR_EL0</a>.F0 is 1, and either <span class="xref">FEAT_SEBEP</span> is not implemented or <a href="pmu.pmicfiltr_el0.html">PMICFILTR_EL0</a>.SYNC is 0.</p>

</li></ul></td></tr></table><p>The counters affected by this field are:</p>
<ul>
<li>The event counters in the first range.
</li><li>If <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, the instruction counter <a href="pmu.pmicntr_el0.html">PMICNTR_EL0</a>.
</li><li>If PMCR_EL0.DP is 1, the cycle counter <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a>.
</li></ul>
<p>Other event counters are not affected by this field.</p>
<p>When PMCR_EL0.DP is 0, <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this field.</p>
<p>For more information about event counter ranges, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-9_9-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-8_8">Bit [8]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-7_7-1">LP, bit [7]<span class="condition"><br/>When FEAT_PMUv3p5 is implemented:
                        </span></h4><div class="field">
      <p>Long event counter enable. Determines when unsigned overflow is recorded by <a href="pmu.pmovsclr_el0.html">PMOVSCLR_EL0</a>.P[n].</p>
    <table class="valuetable"><tr><th>LP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Event counter overflow on increment that causes unsigned overflow of <a href="pmu.pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>[31:0].</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Event counter overflow on increment that causes unsigned overflow of <a href="pmu.pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>[63:0].</p>
        </td></tr></table><p>When <span class="xref">FEAT_EBEP</span> is implemented and the PMU Profiling exception is enabled, the Effective value of this field is 1.</p>
<p>The counters affected by this field are the event counters in the first range.
For more information about event counter ranges, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p>
<p>Other event counters and <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> are not affected by this field.</p>
<p>When <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, <a href="pmu.pmicntr_el0.html">PMICNTR_EL0</a> is not affected by this field.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When FEAT_AA64 is not implemented,
            this field resets to
            <span class="binarynumber">'0'</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-7_7-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-6_6-1">LC, bit [6]<span class="condition"><br/>When FEAT_AA32 is implemented:
                        </span></h4><div class="field">
      <p>Long cycle counter enable. Determines when unsigned overflow is recorded by <a href="pmu.pmovsclr_el0.html">PMOVSCLR_EL0</a>.C.</p>
    <table class="valuetable"><tr><th>LC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Cycle counter overflow on increment that causes unsigned overflow of <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a>[31:0].</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Cycle counter overflow on increment that causes unsigned overflow of <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a>[63:0].</p>
        </td></tr></table><p>When <span class="xref">FEAT_EBEP</span> is implemented and the PMU Profiling exception is enabled, the Effective value of this field is 1.</p>
<p>Arm deprecates use of PMCR_EL0.LC = 0.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-6_6-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
    </div><h4 id="fieldset_0-5_5-1">DP, bit [5]<span class="condition"><br/>When EL3 is implemented, or (FEAT_PMUv3p1 is implemented and EL2 is implemented), or FEAT_PMUv3p7 is implemented, or FEAT_SPE_DPFZS is implemented:
                        </span></h4><div class="field">
      <p>Disable cycle counter when event counting is prohibited.</p>
    <table class="valuetable"><tr><th>DP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this mechanism.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td><p>Cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is disabled in prohibited regions and when event counting is frozen:</p>
<ul>
<li>If <span class="xref">FEAT_PMUv3p1</span> is implemented, EL2 is implemented, and <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMD or <a href="AArch32-hdcr.html">HDCR</a>.HPMD is 1, then cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is disabled at EL2.
</li><li>If <span class="xref">FEAT_SPE_DPFZS</span> is implemented and event counting is frozen by PMCR_EL0.FZS, then cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is disabled.
</li><li>If <span class="xref">FEAT_PMUv3p7</span> is implemented and event counting is frozen by PMCR_EL0.FZO, then cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is disabled.
</li><li>If <span class="xref">FEAT_PMUv3p7</span> is implemented, EL3 is implemented and using AArch64, and <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.MPMX is 1, then cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is disabled at EL3.
</li><li>If EL3 is implemented, <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.SPME or <a href="AArch32-sdcr.html">SDCR</a>.SPME is 0, and one of <span class="xref">FEAT_PMUv3p7</span> is not implemented, EL3 is using AArch32, or <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.MPMX is 0, then cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is disabled at EL3 and in Secure state.
</li></ul></td></tr></table><p>The conditions when this field disables the cycle counter are the same as when event counting by an event counter  in the first range is prohibited or frozen.
For more information about event counter ranges, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p>
<p>If <span class="xref">FEAT_PMUv3p7</span> and <span class="xref">FEAT_SPEv1p2</span> are implemented, meaning PMCR_EL0.FZS is implemented, and <span class="xref">FEAT_SPE_DPFZS</span> is not implemented, then cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by PMCR_EL0.FZS.</p>
<p>For more information, see <span class="xref">'Prohibiting event and cycle counting'</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When FEAT_AA64 is not implemented,
            this field resets to
            <span class="binarynumber">'0'</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-5_5-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-4_4-1">X, bit [4]<span class="condition"><br/>When the implementation includes a PMU event export bus:
                        </span></h4><div class="field">
      <p>Enable export of events in an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> PMU event export bus.</p>
    <table class="valuetable"><tr><th>X</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Do not export events.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Export events where not prohibited.</p>
        </td></tr></table><p>This field enables the exporting of events over an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> PMU event export bus to another device.</p>
<p>No events are exported when counting is prohibited.</p>
<p>This field does not affect the generation of Performance Monitors overflow interrupt requests or signaling to a cross-trigger interface (CTI) that can be implemented as signals exported from the PE.</p>
<p>If <span class="xref">FEAT_ETE</span> is implemented, this field does not affect the use of PMU events as an External Input by the trace unit.</p>
<p>If <span class="xref">FEAT_ETMv4</span> is implemented, this field does affect the use of PMU events as an External Input by the trace unit.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When FEAT_AA64 is not implemented,
            this field resets to
            <span class="binarynumber">'0'</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-4_4-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, RAZ/WI.</p>
    </div><h4 id="fieldset_0-3_3-1">D, bit [3]<span class="condition"><br/>When FEAT_AA32 is implemented:
                        </span></h4><div class="field">
      <p>Clock divider.</p>
    <table class="valuetable"><tr><th>D</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>When enabled, <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> counts every clock cycle.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>When enabled, <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> counts once every 64 clock cycles.</p>
        </td></tr></table><p>If the Effective value of PMCR_EL0.LC is 1, then this field is ignored and the cycle counter counts every clock cycle.</p>
<p>Arm deprecates use of PMCR_EL0.D = 1.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When FEAT_AA64 is not implemented,
            this field resets to
            <span class="binarynumber">'0'</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-3_3-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-2_2">C, bit [2]</h4><div class="field">
      <p>Cycle counter reset. The effects of writing to this field are:</p>
    <table class="valuetable"><tr><th>C</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>No action.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Reset <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> to zero.</p>
        </td></tr></table>
      <div class="note"><span class="note-header">Note</span>
        <p>Resetting <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> does not change the cycle counter overflow field. The value of PMCR_EL0.LC is ignored, and bits [63:0] of the cycle counter are reset.</p>
      </div>
    <p>Access to this field is <span class="access_level">WO/RAZ</span>.</p></div><h4 id="fieldset_0-1_1">P, bit [1]</h4><div class="field">
      <p>Event counter reset.</p>
    <table class="valuetable"><tr><th>P</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>No action.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Reset all affected event counters <a href="pmu.pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a> to zero.</p>
        </td></tr></table><p>The event counters affected by this field are:</p>
<ul>
<li>If FEAT_PMUv3_EXTPMN is implemented and the access to this register is a Most secure access, all event counters.
</li><li>Otherwise, only event counters in the first and second ranges.
</li></ul>
<p>Writes to this field do not affect other event counters, the cycle counter <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a>, or the instruction counter <a href="pmu.pmicntr_el0.html">PMICNTR_EL0</a>.</p>
<p>For more information about event counter ranges, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p>
<div class="note"><span class="note-header">Note</span><p>Resetting the event counters does not change the event counter overflow fields. If <span class="xref">FEAT_PMUv3p5</span> is implemented, the values of <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HLP  or <a href="AArch32-hdcr.html">HDCR</a>.HLP and PMCR_EL0.LP are ignored, and bits [63:0] of all affected event counters are reset.</p></div><p>Access to this field is <span class="access_level">WO/RAZ</span>.</p></div><h4 id="fieldset_0-0_0">E, bit [0]</h4><div class="field">
      <p>Enable.</p>
    <table class="valuetable"><tr><th>E</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Affected counters are disabled and do not count.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Affected counters are enabled by <a href="pmu.pmcntenset_el0.html">PMCNTENSET_EL0</a>.</p>
        </td></tr></table><p>The counters affected by this field are:</p>
<ul>
<li>The event counters in the first range.
For more information about event counter ranges, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.
</li><li>If <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, the instruction counter <a href="pmu.pmicntr_el0.html">PMICNTR_EL0</a>.
</li><li>The cycle counter <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a>.
</li></ul>
<p>Other event counters are not affected by this field.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">'0'</span>.
</li></ul></div><h3>Otherwise:</h3><table class="regdiagram" id="fieldset_1"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="21"><a href="#fieldset_1-31_11">RAZ/WI</a></td><td class="lr" colspan="1"><a href="#fieldset_1-10_10">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_1-9_9-1">FZO</a></td><td class="lr" colspan="1"><a href="#fieldset_1-8_8">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_1-7_7-1">LP</a></td><td class="lr" colspan="1"><a href="#fieldset_1-6_6-1">LC</a></td><td class="lr" colspan="1"><a href="#fieldset_1-5_5-1">DP</a></td><td class="lr" colspan="1"><a href="#fieldset_1-4_4-1">X</a></td><td class="lr" colspan="1"><a href="#fieldset_1-3_3-1">D</a></td><td class="lr" colspan="1"><a href="#fieldset_1-2_2">C</a></td><td class="lr" colspan="1"><a href="#fieldset_1-1_1">P</a></td><td class="lr" colspan="1"><a href="#fieldset_1-0_0">E</a></td></tr></tbody></table><h4 id="fieldset_1-31_11">Bits [31:11]</h4><div class="field">
      <p>Reserved, RAZ/WI.</p>
    
      <p>Hardware must implement this field as RAZ/WI. Software must not rely on the register reading as zero, and must use a read-modify-write sequence to write to the register.</p>
    </div><h4 id="fieldset_1-10_10">Bit [10]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_1-9_9-1">FZO, bit [9]<span class="condition"><br/>When FEAT_PMUv3p7 is implemented:
                        </span></h4><div class="field">
      <p>Freeze-on-overflow. Stop event counters on overflow.</p>
    <table class="valuetable"><tr><th>FZO</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Do not freeze on overflow.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td><p>Affected counters do not count when any of the following applies:</p>
<ul>
<li>
<p>For any event counter <a href="pmu.pmevcntrn_el0.html">PMEVCNTR&lt;m&gt;_EL0</a> in the first range, <a href="pmu.pmovsclr_el0.html">PMOVSCLR_EL0</a>[m] is 1, and either <span class="xref">FEAT_SEBEP</span> is not implemented or <a href="pmu.pmevtypern_el0.html">PMEVTYPER&lt;m&gt;_EL0</a>.SYNC is 0.</p>

</li><li>
<p><span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, <a href="pmu.pmovsclr_el0.html">PMOVSCLR_EL0</a>.F0 is 1, and either <span class="xref">FEAT_SEBEP</span> is not implemented or <a href="pmu.pmicfiltr_el0.html">PMICFILTR_EL0</a>.SYNC is 0.</p>

</li></ul></td></tr></table><p>The counters affected by this field are:</p>
<ul>
<li>The event counters in the first range.
</li><li>If <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, the instruction counter <a href="pmu.pmicntr_el0.html">PMICNTR_EL0</a>.
</li><li>If PMCR_EL0.DP is 1, the cycle counter <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a>.
</li></ul>
<p>Other event counters are not affected by this field.</p>
<p>When PMCR_EL0.DP is 0, <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this field.</p>
<p>For more information about event counter ranges, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-9_9-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_1-8_8">Bit [8]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_1-7_7-1">LP, bit [7]<span class="condition"><br/>When FEAT_PMUv3p5 is implemented:
                        </span></h4><div class="field">
      <p>Long event counter enable. Determines when unsigned overflow is recorded by <a href="pmu.pmovsclr_el0.html">PMOVSCLR_EL0</a>.P[n].</p>
    <table class="valuetable"><tr><th>LP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Event counter overflow on increment that causes unsigned overflow of <a href="pmu.pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>[31:0].</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Event counter overflow on increment that causes unsigned overflow of <a href="pmu.pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>[63:0].</p>
        </td></tr></table><p>When <span class="xref">FEAT_EBEP</span> is implemented and the PMU Profiling exception is enabled, the Effective value of this field is 1.</p>
<p>The counters affected by this field are the event counters in the first range.
For more information about event counter ranges, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p>
<p>Other event counters and <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> are not affected by this field.</p>
<p>When <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, <a href="pmu.pmicntr_el0.html">PMICNTR_EL0</a> is not affected by this field.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When FEAT_AA64 is not implemented,
            this field resets to
            <span class="binarynumber">'0'</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_1-7_7-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_1-6_6-1">LC, bit [6]<span class="condition"><br/>When FEAT_AA32 is implemented:
                        </span></h4><div class="field">
      <p>Long cycle counter enable. Determines when unsigned overflow is recorded by <a href="pmu.pmovsclr_el0.html">PMOVSCLR_EL0</a>.C.</p>
    <table class="valuetable"><tr><th>LC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Cycle counter overflow on increment that causes unsigned overflow of <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a>[31:0].</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Cycle counter overflow on increment that causes unsigned overflow of <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a>[63:0].</p>
        </td></tr></table><p>When <span class="xref">FEAT_EBEP</span> is implemented and the PMU Profiling exception is enabled, the Effective value of this field is 1.</p>
<p>Arm deprecates use of PMCR_EL0.LC = 0.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-6_6-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
    </div><h4 id="fieldset_1-5_5-1">DP, bit [5]<span class="condition"><br/>When EL3 is implemented, or (FEAT_PMUv3p1 is implemented and EL2 is implemented), or FEAT_PMUv3p7 is implemented, or FEAT_SPE_DPFZS is implemented:
                        </span></h4><div class="field">
      <p>Disable cycle counter when event counting is prohibited.</p>
    <table class="valuetable"><tr><th>DP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this mechanism.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td><p>Cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is disabled in prohibited regions and when event counting is frozen:</p>
<ul>
<li>If <span class="xref">FEAT_PMUv3p1</span> is implemented, EL2 is implemented, and <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMD or <a href="AArch32-hdcr.html">HDCR</a>.HPMD is 1, then cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is disabled at EL2.
</li><li>If <span class="xref">FEAT_SPE_DPFZS</span> is implemented and event counting is frozen by PMCR_EL0.FZS, then cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is disabled.
</li><li>If <span class="xref">FEAT_PMUv3p7</span> is implemented and event counting is frozen by PMCR_EL0.FZO, then cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is disabled.
</li><li>If <span class="xref">FEAT_PMUv3p7</span> is implemented, EL3 is implemented and using AArch64, and <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.MPMX is 1, then cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is disabled at EL3.
</li><li>If EL3 is implemented, <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.SPME or <a href="AArch32-sdcr.html">SDCR</a>.SPME is 0, and one of <span class="xref">FEAT_PMUv3p7</span> is not implemented, EL3 is using AArch32, or <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.MPMX is 0, then cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is disabled at EL3 and in Secure state.
</li></ul></td></tr></table><p>The conditions when this field disables the cycle counter are the same as when event counting by an event counter  in the first range is prohibited or frozen.
For more information about event counter ranges, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p>
<p>If <span class="xref">FEAT_PMUv3p7</span> and <span class="xref">FEAT_SPEv1p2</span> are implemented, meaning PMCR_EL0.FZS is implemented, and <span class="xref">FEAT_SPE_DPFZS</span> is not implemented, then cycle counting by <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by PMCR_EL0.FZS.</p>
<p>For more information, see <span class="xref">'Prohibiting event and cycle counting'</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When FEAT_AA64 is not implemented,
            this field resets to
            <span class="binarynumber">'0'</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_1-5_5-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_1-4_4-1">X, bit [4]<span class="condition"><br/>When the implementation includes a PMU event export bus:
                        </span></h4><div class="field">
      <p>Enable export of events in an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> PMU event export bus.</p>
    <table class="valuetable"><tr><th>X</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Do not export events.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Export events where not prohibited.</p>
        </td></tr></table><p>This field enables the exporting of events over an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> PMU event export bus to another device.</p>
<p>No events are exported when counting is prohibited.</p>
<p>This field does not affect the generation of Performance Monitors overflow interrupt requests or signaling to a cross-trigger interface (CTI) that can be implemented as signals exported from the PE.</p>
<p>If <span class="xref">FEAT_ETE</span> is implemented, this field does not affect the use of PMU events as an External Input by the trace unit.</p>
<p>If <span class="xref">FEAT_ETMv4</span> is implemented, this field does affect the use of PMU events as an External Input by the trace unit.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When FEAT_AA64 is not implemented,
            this field resets to
            <span class="binarynumber">'0'</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_1-4_4-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, RAZ/WI.</p>
    </div><h4 id="fieldset_1-3_3-1">D, bit [3]<span class="condition"><br/>When FEAT_AA32 is implemented:
                        </span></h4><div class="field">
      <p>Clock divider.</p>
    <table class="valuetable"><tr><th>D</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>When enabled, <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> counts every clock cycle.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>When enabled, <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> counts once every 64 clock cycles.</p>
        </td></tr></table><p>If the Effective value of PMCR_EL0.LC is 1, then this field is ignored and the cycle counter counts every clock cycle.</p>
<p>Arm deprecates use of PMCR_EL0.D = 1.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When FEAT_AA64 is not implemented,
            this field resets to
            <span class="binarynumber">'0'</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_1-3_3-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_1-2_2">C, bit [2]</h4><div class="field">
      <p>Cycle counter reset. The effects of writing to this field are:</p>
    <table class="valuetable"><tr><th>C</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>No action.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Reset <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> to zero.</p>
        </td></tr></table>
      <div class="note"><span class="note-header">Note</span>
        <p>Resetting <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a> does not change the cycle counter overflow field. The value of PMCR_EL0.LC is ignored, and bits [63:0] of the cycle counter are reset.</p>
      </div>
    <p>Access to this field is <span class="access_level">WO/RAZ</span>.</p></div><h4 id="fieldset_1-1_1">P, bit [1]</h4><div class="field">
      <p>Event counter reset.</p>
    <table class="valuetable"><tr><th>P</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>No action.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Reset all affected event counters <a href="pmu.pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a> to zero.</p>
        </td></tr></table><p>The event counters affected by this field are:</p>
<ul>
<li>If FEAT_PMUv3_EXTPMN is implemented and the access to this register is a Most secure access, all event counters.
</li><li>Otherwise, only event counters in the first and second ranges.
</li></ul>
<p>Writes to this field do not affect other event counters, the cycle counter <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a>, or the instruction counter <a href="pmu.pmicntr_el0.html">PMICNTR_EL0</a>.</p>
<p>For more information about event counter ranges, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.</p>
<div class="note"><span class="note-header">Note</span><p>Resetting the event counters does not change the event counter overflow fields. If <span class="xref">FEAT_PMUv3p5</span> is implemented, the values of <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HLP  or <a href="AArch32-hdcr.html">HDCR</a>.HLP and PMCR_EL0.LP are ignored, and bits [63:0] of all affected event counters are reset.</p></div><p>Access to this field is <span class="access_level">WO/RAZ</span>.</p></div><h4 id="fieldset_1-0_0">E, bit [0]</h4><div class="field">
      <p>Enable.</p>
    <table class="valuetable"><tr><th>E</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Affected counters are disabled and do not count.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Affected counters are enabled by <a href="pmu.pmcntenset_el0.html">PMCNTENSET_EL0</a>.</p>
        </td></tr></table><p>The counters affected by this field are:</p>
<ul>
<li>The event counters in the first range.
For more information about event counter ranges, see <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.
</li><li>If <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, the instruction counter <a href="pmu.pmicntr_el0.html">PMICNTR_EL0</a>.
</li><li>The cycle counter <a href="pmu.pmccntr_el0.html">PMCCNTR_EL0</a>.
</li></ul>
<p>Other event counters are not affected by this field.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">'0'</span>.
</li></ul></div><div class="access_mechanisms"><h2>Accessing PMCR_EL0</h2>
        <div class="note"><span class="note-header">Note</span><p>SoftwareLockStatus() depends on the type of access attempted and AllowExternalPMUAccess() has a new definition from Armv8.4. Refer to the Pseudocode definitions for more information.</p></div>
      <p>Accesses to this register use the following encodings:</p><div><h4 class="condition">
When FEAT_PMUv3_EXT32 is implemented
        </h4><p>Accessible at offset <span class="hexnumber">0xE04</span> from PMU</p></div><ul><li>When DoubleLockStatus(), or !IsCorePowered(), or !AllowExternalPMUAccess(addrdesc), accesses to this register generate an error response.
          </li><li>When (FEAT_PMUv3_EXTPMN is not implemented, or !IsMostSecureAccess(addrdesc), or PMCCR().OSLO == 0) and OSLockStatus(), accesses to this register generate an error response.
          </li><li>When SoftwareLockStatus(), accesses to this register are <span class="access_level">RO</span>.
          </li><li>Otherwise, accesses to this register are <span class="access_level">RW</span>.
          </li></ul><table class="access_instructions"><tr/><tr/></table><div><h4 class="condition">
When FEAT_PMUv3_EXT64 is implemented
        </h4><p>Accessible at offset <span class="hexnumber">0xE10</span> from PMU</p></div><ul><li>When DoubleLockStatus(), or !IsCorePowered(), or !AllowExternalPMUAccess(addrdesc), accesses to this register generate an error response.
          </li><li>When (FEAT_PMUv3_EXTPMN is not implemented, or !IsMostSecureAccess(addrdesc), or PMCCR().OSLO == 0) and OSLockStatus(), accesses to this register generate an error response.
          </li><li>Otherwise, accesses to this register are <span class="access_level">RW</span>.
          </li></ul><table class="access_instructions"><tr/><tr/></table></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">2025-10-24 11:39:28, 2025-09_rel_asl1</p><p class="copyconf">Copyright Â© 2010-2025 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
