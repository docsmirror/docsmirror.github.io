<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>A64 Instruction Summary -- Shared Pseudocode</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">Shared Pseudocode Functions</h2><p>This page displays common pseudocode functions shared by many pages</p><h2 class="pseudocode">Pseudocodes</h2>
    <div class="ps"><a id="aarch32.at.AArch32.AT"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.AT</h3>
      <p class="pseudocode">// AArch32.AT()
// ============
// Perform address translation as per AT instructions.

<a id="AArch32.AT.4"/>AArch32.AT(bits(32) vaddress, <a href="shared_pseudocode.html#TranslationStage" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage</a> stage_in, bits(2) el, <a href="shared_pseudocode.html#ATAccess" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess</a> ataccess)
    <a href="shared_pseudocode.html#TranslationStage" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage</a> stage = stage_in;
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss;
    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime;
    boolean eae;

    // ATS1Hx instructions
    if el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        regime = <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
        eae = TRUE;
        ss = <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;

    // ATS1Cxx instructions
    elsif stage == <a href="shared_pseudocode.html#TranslationStage_1" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a> || (stage == <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>)) then
        stage = <a href="shared_pseudocode.html#TranslationStage_1" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a>;
        ss = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
        regime = if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> else <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
        eae = TTBCR.EAE == '1';

    // ATS12NSOxx instructions
    else
        regime = <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
        eae = if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then TTBCR_NS.EAE == '1' else TTBCR.EAE == '1';
        ss = <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> addrdesc;
    <a href="shared_pseudocode.html#SDFType" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> sdftype;
    boolean aligned = TRUE;
    bit supersection = '0';

    boolean write = ataccess IN {<a href="shared_pseudocode.html#ATAccess_WritePAN" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_WritePAN</a>, <a href="shared_pseudocode.html#ATAccess_Write" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Write</a>};
    boolean pan   = ataccess IN {<a href="shared_pseudocode.html#ATAccess_WritePAN" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_WritePAN</a>, <a href="shared_pseudocode.html#ATAccess_ReadPAN" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_ReadPAN</a>};
    accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescAT.4" title="function: AccessDescriptor CreateAccDescAT(SecurityState ss, bits(2) el, boolean write, boolean pan)">CreateAccDescAT</a>(ss, el, write, pan);

    // Prepare fault fields in case a fault is detected
    fault = <a href="shared_pseudocode.html#impl-shared.NoFault.1" title="function: FaultRecord NoFault(AccessDescriptor accdesc)">NoFault</a>(accdesc);

    if eae then
        (fault, addrdesc) = <a href="shared_pseudocode.html#AArch32.S1TranslateLD.5" title="function: (FaultRecord, AddressDescriptor) AArch32.S1TranslateLD(FaultRecord fault_in, Regime regime,&#13; bits(32) va, boolean aligned,&#13; AccessDescriptor accdesc)">AArch32.S1TranslateLD</a>(fault, regime, vaddress, aligned, accdesc);
    else
        (fault, addrdesc, sdftype) = <a href="shared_pseudocode.html#AArch32.S1TranslateSD.5" title="function: (FaultRecord, AddressDescriptor, SDFType) AArch32.S1TranslateSD(FaultRecord fault_in, Regime regime,&#13; bits(32) va, boolean aligned,&#13; AccessDescriptor accdesc)">AArch32.S1TranslateSD</a>(fault, regime, vaddress, aligned,
                                                           accdesc);
        supersection = if sdftype == <a href="shared_pseudocode.html#SDFType_Supersection" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a> then '1' else '0';

    // ATS12NSOxx instructions
    if stage == <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        (fault, addrdesc) = <a href="shared_pseudocode.html#AArch32.S2Translate.4" title="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean aligned, AccessDescriptor accdesc)">AArch32.S2Translate</a>(fault, addrdesc, aligned, accdesc);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        // Take exception on External abort or when a fault occurs on translation table walk
        if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) || (PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; fault.s2fs1walk) then
            PAR = bits(64) UNKNOWN;
            <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(vaddress, fault);

    addrdesc.fault = fault;

    if (eae || (stage == <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; (HCR.VM == '1' || HCR.DC == '1'))
            || (stage == <a href="shared_pseudocode.html#TranslationStage_1" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a> &amp;&amp; el != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>)) then
        <a href="shared_pseudocode.html#AArch32.EncodePARLD.2" title="function: AArch32.EncodePARLD(AddressDescriptor addrdesc, SecurityState ss)">AArch32.EncodePARLD</a>(addrdesc, ss);
    else
        <a href="shared_pseudocode.html#AArch32.EncodePARSD.3" title="function: AArch32.EncodePARSD(AddressDescriptor addrdesc_in, bit supersection, SecurityState ss)">AArch32.EncodePARSD</a>(addrdesc, supersection, ss);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32.EncodePARLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.EncodePARLD</h3>
      <p class="pseudocode">// AArch32.EncodePARLD()
// =====================
// Returns 64-bit format PAR on address translation instruction.

<a id="AArch32.EncodePARLD.2"/>AArch32.EncodePARLD(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> addrdesc, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)

    if !<a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(addrdesc) then
        bit ns;
        if ss == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
            ns = bit UNKNOWN;
        elsif addrdesc.paddress.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
            ns = '0';
        else
            ns = '1';
        PAR.F      = '0';
        PAR.SH     = ReportedPARShareability(<a href="shared_pseudocode.html#impl-shared.PAREncodeShareability.1" title="function: bits(2) PAREncodeShareability(MemoryAttributes memattrs)">PAREncodeShareability</a>(addrdesc.memattrs));
        PAR.NS     = ns;
        PAR&lt;10&gt;    = bit IMPLEMENTATION_DEFINED "Non-Faulting PAR";               // IMPDEF
        PAR.LPAE   = '1';
        PAR.PA     = addrdesc.paddress.address&lt;39:12&gt;;
        PAR.ATTR   = ReportedPARAttrs(<a href="shared_pseudocode.html#impl-shared.EncodePARAttrs.1" title="function: bits(8) EncodePARAttrs(MemoryAttributes memattrs)">EncodePARAttrs</a>(addrdesc.memattrs));
    else
        PAR.F      = '1';
        PAR.FST    = <a href="shared_pseudocode.html#AArch32.PARFaultStatusLD.1" title="function: bits(6) AArch32.PARFaultStatusLD(FaultRecord fault)">AArch32.PARFaultStatusLD</a>(addrdesc.fault);
        PAR.S2WLK  = if addrdesc.fault.s2fs1walk then '1' else '0';
        PAR.FSTAGE = if addrdesc.fault.secondstage then '1' else '0';
        PAR.LPAE   = '1';
        PAR&lt;63:48&gt; = bits(16) IMPLEMENTATION_DEFINED "Faulting PAR";              // IMPDEF
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32.EncodePARSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.EncodePARSD</h3>
      <p class="pseudocode">// AArch32.EncodePARSD()
// =====================
// Returns 32-bit format PAR on address translation instruction.

<a id="AArch32.EncodePARSD.3"/>AArch32.EncodePARSD(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> addrdesc_in, bit supersection, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> addrdesc = addrdesc_in;
    if !<a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(addrdesc) then
        if (addrdesc.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> ||
                (addrdesc.memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp;
                 addrdesc.memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>)) then
            addrdesc.memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        bit ns;
        if ss == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
            ns = bit UNKNOWN;
        elsif addrdesc.paddress.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
            ns = '0';
        else
            ns = '1';
        bits(2) sh = if addrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then '01' else '00';
        PAR.F      = '0';
        PAR.SS     = supersection;
        PAR.Outer  = AArch32.ReportedOuterAttrs(<a href="shared_pseudocode.html#AArch32.PAROuterAttrs.1" title="function: bits(2) AArch32.PAROuterAttrs(MemoryAttributes memattrs)">AArch32.PAROuterAttrs</a>(addrdesc.memattrs));
        PAR.Inner  = AArch32.ReportedInnerAttrs(<a href="shared_pseudocode.html#AArch32.PARInnerAttrs.1" title="function: bits(3) AArch32.PARInnerAttrs(MemoryAttributes memattrs)">AArch32.PARInnerAttrs</a>(addrdesc.memattrs));
        PAR.SH     = ReportedPARShareability(sh);
        PAR&lt;8&gt;     = bit IMPLEMENTATION_DEFINED "Non-Faulting PAR";               // IMPDEF
        PAR.NS     = ns;
        PAR.NOS    = if addrdesc.memattrs.shareability == <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> then '0' else '1';
        PAR.LPAE   = '0';
        PAR.PA     = addrdesc.paddress.address&lt;39:12&gt;;
    else
        PAR.F      = '1';
        PAR.FST    = <a href="shared_pseudocode.html#AArch32.PARFaultStatusSD.1" title="function: bits(6) AArch32.PARFaultStatusSD(FaultRecord fault)">AArch32.PARFaultStatusSD</a>(addrdesc.fault);
        PAR.LPAE   = '0';
        PAR&lt;31:16&gt; = bits(16) IMPLEMENTATION_DEFINED "Faulting PAR";              // IMPDEF
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32.PARFaultStatusLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.PARFaultStatusLD</h3>
      <p class="pseudocode">// AArch32.PARFaultStatusLD()
// ==========================
// Fault status field decoding of 64-bit PAR

bits(6) <a id="AArch32.PARFaultStatusLD.1"/>AArch32.PARFaultStatusLD(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    bits(6) syndrome;

    if fault.statuscode == <a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a> then
        // Report Domain fault
        assert fault.level IN {1,2};
        syndrome&lt;1:0&gt; = if fault.level == 1 then '01' else '10';
        syndrome&lt;5:2&gt; = '1111';
    else
        syndrome = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);
    return syndrome;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32.PARFaultStatusSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.PARFaultStatusSD</h3>
      <p class="pseudocode">// AArch32.PARFaultStatusSD()
// ==========================
// Fault status field decoding of 32-bit PAR.

bits(6) <a id="AArch32.PARFaultStatusSD.1"/>AArch32.PARFaultStatusSD(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    bits(6) syndrome;

    syndrome&lt;5&gt; = if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then fault.extflag else '0';
    syndrome&lt;4:0&gt; = <a href="shared_pseudocode.html#impl-aarch32.EncodeSDFSC.2" title="function: bits(5) EncodeSDFSC(Fault statuscode, integer level)">EncodeSDFSC</a>(fault.statuscode, fault.level);
    return syndrome;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32.PARInnerAttrs"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.PARInnerAttrs</h3>
      <p class="pseudocode">// AArch32.PARInnerAttrs()
// =======================
// Convert orthogonal attributes and hints to 32-bit PAR Inner field.

bits(3) <a id="AArch32.PARInnerAttrs.1"/>AArch32.PARInnerAttrs(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs)
    bits(3) result;

    if memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        if memattrs.device == <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a> then
            result = '001'; // Non-cacheable
        elsif memattrs.device == <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a> then
            result = '011'; // Non-cacheable
    else
        <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> inner = memattrs.inner;
        if inner.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
            result = '000'; // Non-cacheable
        elsif inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; inner.hints&lt;0&gt; == '1' then
            result = '101'; // Write-Back, Write-Allocate
        elsif inner.attrs == <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> then
            result = '110'; // Write-Through
        elsif inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; inner.hints&lt;0&gt; == '0' then
            result = '111'; // Write-Back, no Write-Allocate
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32.PAROuterAttrs"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.PAROuterAttrs</h3>
      <p class="pseudocode">// AArch32.PAROuterAttrs()
// =======================
// Convert orthogonal attributes and hints to 32-bit PAR Outer field.

bits(2) <a id="AArch32.PAROuterAttrs.1"/>AArch32.PAROuterAttrs(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs)
    bits(2) result;

    if memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        result = bits(2) UNKNOWN;
    else
        <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> outer = memattrs.outer;
        if outer.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
            result = '00'; // Non-cacheable
        elsif outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; outer.hints&lt;0&gt; == '1' then
            result = '01'; // Write-Back, Write-Allocate
        elsif outer.attrs == <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> &amp;&amp; outer.hints&lt;0&gt; == '0' then
            result = '10'; // Write-Through, no Write-Allocate
        elsif outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; outer.hints&lt;0&gt; == '0' then
            result = '11'; // Write-Back, no Write-Allocate
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.dc.AArch32.DC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/dc/AArch32.DC</h3>
      <p class="pseudocode">// AArch32.DC()
// ============
// Perform Data Cache Operation.

<a id="AArch32.DC.3"/>AArch32.DC(bits(32) regval, <a href="shared_pseudocode.html#CacheOp" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp</a> cacheop, <a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    <a href="shared_pseudocode.html#CacheRecord" title="type CacheRecord is ( AccessType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache;

    cache.acctype   = <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>;
    cache.cacheop   = cacheop;
    cache.opscope   = opscope;
    cache.cachetype = <a href="shared_pseudocode.html#CacheType_Data" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data</a>;
    cache.security  = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);

    if opscope == <a href="shared_pseudocode.html#CacheOpScope_SetWay" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_SetWay</a> then
        cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        (cache.set, cache.way, cache.level) = <a href="shared_pseudocode.html#impl-shared.DecodeSW.2" title="function: (integer, integer, integer) DecodeSW(bits(64) regval, CacheType cachetype)">DecodeSW</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(regval, 64), <a href="shared_pseudocode.html#CacheType_Data" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data</a>);

        if (cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
            ((!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (HCR_EL2.SWIO == '1' || HCR_EL2.&lt;DC,VM&gt; != '00')) ||
              (<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (HCR.SWIO == '1' || HCR.&lt;DC,VM&gt; != '00')))) then
            cache.cacheop = <a href="shared_pseudocode.html#CacheOp_CleanInvalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a>;
        <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
        return;

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
            cache.is_vmid_valid = TRUE;
            cache.vmid          = VMID[];
        else
            cache.is_vmid_valid = FALSE;
    else
        cache.is_vmid_valid = FALSE;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        cache.is_asid_valid = TRUE;
        cache.asid          = <a href="shared_pseudocode.html#impl-shared.ASID.read.0" title="accessor: bits(16) ASID[]">ASID</a>[];
    else
        cache.is_asid_valid = FALSE;

    need_translate = <a href="shared_pseudocode.html#impl-shared.DCInstNeedsTranslation.1" title="function: boolean DCInstNeedsTranslation(CacheOpScope opscope)">DCInstNeedsTranslation</a>(opscope);
    vaddress = regval;

    size = 0;        // by default no watchpoint address
    if cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> then
        size = integer IMPLEMENTATION_DEFINED "Data Cache Invalidate Watchpoint Size";
        assert size &gt;= 4*(2^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(CTR_EL0.DminLine))) &amp;&amp; size &lt;= 2048;
        assert <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size&lt;32:0&gt; AND (size-1)&lt;32:0&gt;) == 0; // size is power of 2
        vaddress = <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(regval, size);

    cache.translated = need_translate;
    cache.vaddress   = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(vaddress, 64);

    if need_translate then
        boolean aligned = TRUE;
        <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescDC.1" title="function: AccessDescriptor CreateAccDescDC(CacheRecord cache)">CreateAccDescDC</a>(cache);
        <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc = <a href="shared_pseudocode.html#AArch32.TranslateAddress.4" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch32.TranslateAddress</a>(vaddress, accdesc, aligned, size);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
            <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(regval, memaddrdesc.fault);

        cache.paddress = memaddrdesc.paddress;
        if opscope == <a href="shared_pseudocode.html#CacheOpScope_PoC" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a> then
            cache.shareability = memaddrdesc.memattrs.shareability;
        else
            cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
    else
        cache.shareability = <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> UNKNOWN;
        cache.paddress     = <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> UNKNOWN;

    if (cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
            ((!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.&lt;DC,VM&gt; != '00') ||
              (<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR.&lt;DC,VM&gt; != '00'))) then
        cache.cacheop = <a href="shared_pseudocode.html#CacheOp_CleanInvalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a>;

    <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.VCRMatch.AArch32.VCRMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/VCRMatch/AArch32.VCRMatch</h3>
      <p class="pseudocode">// AArch32.VCRMatch()
// ==================

boolean <a id="AArch32.VCRMatch.1"/>AArch32.VCRMatch(bits(32) vaddress)

    boolean match;
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        // Each bit position in this string corresponds to a bit in DBGVCR and an exception vector.
        match_word = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);

        ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
        if vaddress&lt;31:5&gt; == <a href="shared_pseudocode.html#impl-aarch32.ExcVectorBase.0" title="function: bits(32) ExcVectorBase()">ExcVectorBase</a>()&lt;31:5&gt; then
            if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; ss == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
                match_word&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;4:2&gt;) + 24&gt; = '1';     // Non-secure vectors
            else
                match_word&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;4:2&gt;) + 0&gt; = '1';      // Secure vectors (or no EL3)

        if (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; vaddress&lt;31:5&gt; == MVBAR&lt;31:5&gt; &amp;&amp;
            ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then
            match_word&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;4:2&gt;) + 8&gt; = '1';          // Monitor vectors

        // Mask out bits not corresponding to vectors.
        bits(32) mask;
        if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            mask = '00000000':'00000000':'00000000':'11011110'; // DBGVCR[31:8] are RES0
        elsif !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            mask = '11011110':'00000000':'00000000':'11011110'; // DBGVCR[15:8] are RES0
        else
            mask = '11011110':'00000000':'11011100':'11011110';

        match_word = match_word AND DBGVCR AND mask;
        match = !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(match_word);

        // Check for UNPREDICTABLE case - match on Prefetch Abort and Data Abort vectors
        if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(match_word&lt;28:27,12:11,4:3&gt;) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.DebugTarget.0" title="function: bits(2) DebugTarget()">DebugTarget</a>() == PSTATE.EL then
            match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_VCMATCHDAPA" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_VCMATCHDAPA</a>);

        if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(vaddress&lt;1:0&gt;) &amp;&amp; match then
            match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_VCMATCHHALF" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_VCMATCHHALF</a>);
    else
        match = FALSE;

    return match;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.authentication.AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/authentication/AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled</h3>
      <p class="pseudocode">// AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled()
// ========================================================

boolean <a id="AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled.0"/>AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled()
    // The definition of this function is IMPLEMENTATION DEFINED.
    // In the recommended interface, AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled returns
    // the state of the (DBGEN AND SPIDEN) signal.
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.NonSecureOnlyImplementation.0" title="function: boolean NonSecureOnlyImplementation()">NonSecureOnlyImplementation</a>() then return FALSE;
    return DBGEN == HIGH &amp;&amp; SPIDEN == HIGH;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.breakpoint.AArch32.BreakpointMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32.BreakpointMatch</h3>
      <p class="pseudocode">// AArch32.BreakpointMatch()
// =========================
// Breakpoint matching in an AArch32 translation regime.

(boolean,boolean) <a id="AArch32.BreakpointMatch.4"/>AArch32.BreakpointMatch(integer n, bits(32) vaddress, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc,
                                          integer size)
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt; <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>();

    enabled    = DBGBCR[n].E == '1';
    isbreakpnt = TRUE;
    linked     = DBGBCR[n].BT IN {'0x01'};
    linked_to  = FALSE;

    state_match = <a href="shared_pseudocode.html#AArch32.StateMatch.7" title="function: boolean AArch32.StateMatch(bits(2) ssc_in,  bit hmc_in, bits(2) pxc_in, boolean linked_in,&#13; bits(4) lbn, boolean isbreakpnt, AccessDescriptor accdesc)">AArch32.StateMatch</a>(DBGBCR[n].SSC, DBGBCR[n].HMC, DBGBCR[n].PMC,
                                     linked, DBGBCR[n].LBN, isbreakpnt,  accdesc);
    (value_match, value_mismatch) = <a href="shared_pseudocode.html#AArch32.BreakpointValueMatch.3" title="function: (boolean, boolean) AArch32.BreakpointValueMatch(integer n_in, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</a>(n, vaddress, linked_to);

    if size == 4 then                    // Check second halfword
        // If the breakpoint address and BAS of an Address breakpoint match the address of the
        // second halfword of an instruction, but not the address of the first halfword, it is
        // CONSTRAINED UNPREDICTABLE whether or not this breakpoint generates a Breakpoint debug
        // event.
        (match_i, mismatch_i) = <a href="shared_pseudocode.html#AArch32.BreakpointValueMatch.3" title="function: (boolean, boolean) AArch32.BreakpointValueMatch(integer n_in, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</a>(n, vaddress + 2, linked_to);

        if !value_match &amp;&amp; match_i then
            value_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_BPMATCHHALF</a>);

        if value_mismatch &amp;&amp; !mismatch_i then
            value_mismatch = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMISMATCHHALF" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_BPMISMATCHHALF</a>);

    if vaddress&lt;1&gt; == '1' &amp;&amp; DBGBCR[n].BAS == '1111' then
        // The above notwithstanding, if DBGBCR[n].BAS == '1111', then it is CONSTRAINED
        // UNPREDICTABLE whether or not a Breakpoint debug event is generated for an instruction
        // at the address DBGBVR[n]+2.
        if value_match then
            value_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_BPMATCHHALF</a>);

        if !value_mismatch then
            value_mismatch = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMISMATCHHALF" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_BPMISMATCHHALF</a>);

    match    = value_match &amp;&amp; state_match &amp;&amp; enabled;
    mismatch = value_mismatch &amp;&amp; state_match &amp;&amp; enabled;

    return (match, mismatch);</p>
    </div>
    <div class="ps"><a id="aarch32.debug.breakpoint.AArch32.BreakpointValueMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32.BreakpointValueMatch</h3>
      <p class="pseudocode">// AArch32.BreakpointValueMatch()
// ==============================
// The first result is whether an Address Match or Context breakpoint is programmed on the
// instruction at "address". The second result is whether an Address Mismatch breakpoint is
// programmed on the instruction, that is, whether the instruction should be stepped.

(boolean, boolean) <a id="AArch32.BreakpointValueMatch.3"/>AArch32.BreakpointValueMatch(integer n_in, bits(32) vaddress, boolean linked_to)

    // "n" is the identity of the breakpoint unit to match against.
    // "vaddress" is the current instruction address, ignored if linked_to is TRUE and for Context
    //   matching breakpoints.
    // "linked_to" is TRUE if this is a call from StateMatch for linking.
    integer n = n_in;

    // If a non-existent breakpoint then it is CONSTRAINED UNPREDICTABLE whether this gives
    // no match or the breakpoint is mapped to another UNKNOWN implemented breakpoint.
    if n &gt;= <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() then
        <a href="shared_pseudocode.html#Constraint" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
        (c, n) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high,&#13; Unpredictable which)">ConstrainUnpredictableInteger</a>(0, <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1,
                                               <a href="shared_pseudocode.html#Unpredictable_BPNOTIMPL" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_BPNOTIMPL</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return (FALSE, FALSE);

    // If this breakpoint is not enabled, it cannot generate a match. (This could also happen on a
    // call from StateMatch for linking).
    if DBGBCR[n].E == '0' then return (FALSE, FALSE);

    context_aware = (n &gt;= (<a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - <a href="shared_pseudocode.html#impl-shared.NumContextAwareBreakpointsImplemented.0" title="function: integer NumContextAwareBreakpointsImplemented()">NumContextAwareBreakpointsImplemented</a>()));

    // If BT is set to a reserved type, behaves either as disabled or as a not-reserved type.
    dbgtype = DBGBCR[n].BT;

    if ((dbgtype IN {'011x','11xx'} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveV82Debug.0" title="function: boolean HaveV82Debug()">HaveV82Debug</a>()) ||    // Context matching
          (dbgtype IN {'010x'} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>()) ||                // Address mismatch
          (!(dbgtype IN {'0x0x'}) &amp;&amp; !context_aware) ||                             // Context matching
          (dbgtype IN {'1xxx'} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>))) then                               // EL2 extension
        <a href="shared_pseudocode.html#Constraint" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
        (c, dbgtype) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESBPTYPE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESBPTYPE</a>, 4);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return (FALSE, FALSE);
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    // Determine what to compare against.
    match_addr = (dbgtype IN {'0x0x'});
    mismatch   = (dbgtype IN {'010x'});
    match_vmid = (dbgtype IN {'10xx'});
    match_cid1 = (dbgtype IN {'xx1x'});
    match_cid2 = (dbgtype IN {'11xx'});
    linked     = (dbgtype IN {'xxx1'});

    // If this is a call from StateMatch, return FALSE if the breakpoint is not programmed for a
    // VMID and/or context ID match, of if not context-aware. The above assertions mean that the
    // code can just test for match_addr == TRUE to confirm all these things.
    if linked_to &amp;&amp; (!linked || match_addr) then return (FALSE, FALSE);

    // If called from BreakpointMatch return FALSE for Linked context ID and/or VMID matches.
    if !linked_to &amp;&amp; linked &amp;&amp; !match_addr then return (FALSE, FALSE);

    boolean bvr_match  = FALSE;
    boolean bxvr_match = FALSE;

    // Do the comparison.
    if match_addr then
        integer byte = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;1:0&gt;);
        assert byte IN {0,2};                     // "vaddress" is halfword aligned

        boolean byte_select_match = (DBGBCR[n].BAS&lt;byte&gt; == '1');
        integer top = 31;
        bvr_match = (vaddress&lt;top:2&gt; == DBGBVR[n]&lt;top:2&gt;) &amp;&amp; byte_select_match;

    elsif match_cid1 then
        bvr_match = (PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; CONTEXTIDR == DBGBVR[n]&lt;31:0&gt;);

    if match_vmid then
        bits(16) vmid;
        bits(16) bvr_vmid;

        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR.VMID, 16);
            bvr_vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DBGBXVR[n]&lt;7:0&gt;, 16);
        elsif !<a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()">Have16bitVMID</a>() || VTCR_EL2.VS == '0' then
            vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0&gt;, 16);
            bvr_vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DBGBXVR[n]&lt;7:0&gt;, 16);
        else
            vmid = VTTBR_EL2.VMID;
            bvr_vmid = DBGBXVR[n]&lt;15:0&gt;;

        bxvr_match = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; vmid == bvr_vmid);

    elsif match_cid2 then
        bxvr_match = (PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
                      DBGBXVR[n]&lt;31:0&gt; == CONTEXTIDR_EL2&lt;31:0&gt;);

    bvr_match_valid  = (match_addr || match_cid1);
    bxvr_match_valid = (match_vmid || match_cid2);

    match = (!bxvr_match_valid || bxvr_match) &amp;&amp; (!bvr_match_valid || bvr_match);

    return (match &amp;&amp; !mismatch, !match &amp;&amp; mismatch);</p>
    </div>
    <div class="ps"><a id="aarch32.debug.breakpoint.AArch32.StateMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32.StateMatch</h3>
      <p class="pseudocode">// AArch32.StateMatch()
// ====================
// Determine whether a breakpoint or watchpoint is enabled in the current mode and state.

boolean <a id="AArch32.StateMatch.7"/>AArch32.StateMatch(bits(2) ssc_in,  bit hmc_in, bits(2) pxc_in, boolean linked_in,
                           bits(4) lbn, boolean isbreakpnt, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)

    // "ssc_in","hmc_in","pxc_in" are the control fields from the DBGBCR[n] or DBGWCR[n] register.
    // "linked_in" is TRUE if this is a linked breakpoint/watchpoint type.
    // "lbn" is the linked breakpoint number from the DBGBCR[n] or DBGWCR[n] register.
    // "isbreakpnt" is TRUE for breakpoints, FALSE for watchpoints.
    // "accdesc" describes the properties of the access being matched.
    bits(2) ssc    = ssc_in;
    bit hmc        = hmc_in;
    bits(2) pxc    = pxc_in;
    boolean linked = linked_in;

    // If parameters are set to a reserved type, behaves as either disabled or a defined type
    <a href="shared_pseudocode.html#Constraint" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
    // SSCE value discarded as there is no SSCE bit in AArch32.
    (c, ssc, -, hmc, pxc) = <a href="shared_pseudocode.html#impl-shared.CheckValidStateMatch.5" title="function: (Constraint, bits(2), bit, bit, bits(2)) CheckValidStateMatch(bits(2) ssc_in, bit ssce_in, bit hmc_in,&#13; bits(2) pxc_in, boolean isbreakpnt)">CheckValidStateMatch</a>(ssc, '0', hmc, pxc, isbreakpnt);
    if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return FALSE;
    // Otherwise the hmc,ssc,pxc values are either valid or the values returned by
    // CheckValidStateMatch are valid.

    pl2_match = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; ((hmc == '1' &amp;&amp; (ssc:pxc != '1000')) || ssc == '11');
    pl1_match = pxc&lt;0&gt; == '1';
    pl0_match = pxc&lt;1&gt; == '1';
    ssu_match = isbreakpnt &amp;&amp; hmc == '0' &amp;&amp; pxc == '00' &amp;&amp; ssc != '11';

    boolean priv_match;
    if ssu_match then
        priv_match = PSTATE.M IN {<a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>,<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>,<a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>};
    else
        case accdesc.el of
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> priv_match = pl1_match;           // EL3 and EL1 are both PL1
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> priv_match = pl2_match;
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> priv_match = pl1_match;
            when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> priv_match = pl0_match;

    // Security state match
    boolean ss_match;
    case ssc of
        when '00' ss_match = TRUE;                                     // Both
        when '01' ss_match = accdesc.ss == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;               // Non-secure only
        when '10' ss_match = accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;                  // Secure only
        when '11' ss_match = (hmc == '1' || accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>);  // HMC=1 -&gt; Both,
                                                                       // HMC=0 -&gt; Secure only

    boolean linked_match = FALSE;

    if linked then
        // "lbn" must be an enabled context-aware breakpoint unit. If it is not context-aware then
        // it is CONSTRAINED UNPREDICTABLE whether this gives no match, gives a match without linking,
        // or lbn is mapped to some UNKNOWN breakpoint that is context-aware.
        integer int_lbn = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(lbn);
        first_ctx_cmp = <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - <a href="shared_pseudocode.html#impl-shared.NumContextAwareBreakpointsImplemented.0" title="function: integer NumContextAwareBreakpointsImplemented()">NumContextAwareBreakpointsImplemented</a>();
        last_ctx_cmp = <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1;

        if (int_lbn &lt; first_ctx_cmp || int_lbn &gt; last_ctx_cmp) then
            (c, int_lbn) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high,&#13; Unpredictable which)">ConstrainUnpredictableInteger</a>(first_ctx_cmp, last_ctx_cmp,
                                                         <a href="shared_pseudocode.html#Unpredictable_BPNOTCTXCMP" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_BPNOTCTXCMP</a>);
            assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};

            case c of
                when <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>  return FALSE;      // Disabled
                when <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>      linked = FALSE;    // No linking
                // Otherwise ConstrainUnpredictableInteger returned a context-aware breakpoint

        vaddress  = bits(32) UNKNOWN;
        linked_to = TRUE;
        (linked_match,-) = <a href="shared_pseudocode.html#AArch32.BreakpointValueMatch.3" title="function: (boolean, boolean) AArch32.BreakpointValueMatch(integer n_in, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</a>(int_lbn, vaddress, linked_to);

    return priv_match &amp;&amp; ss_match &amp;&amp; (!linked || linked_match);</p>
    </div>
    <div class="ps"><a id="aarch32.debug.enables.AArch32.GenerateDebugExceptions"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/enables/AArch32.GenerateDebugExceptions</h3>
      <p class="pseudocode">// AArch32.GenerateDebugExceptions()
// =================================

boolean <a id="AArch32.GenerateDebugExceptions.0"/>AArch32.GenerateDebugExceptions()
    ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    return <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptionsFrom.2" title="function: boolean AArch32.GenerateDebugExceptionsFrom(bits(2) from_el, SecurityState from_state)">AArch32.GenerateDebugExceptionsFrom</a>(PSTATE.EL, ss);</p>
    </div>
    <div class="ps"><a id="aarch32.debug.enables.AArch32.GenerateDebugExceptionsFrom"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/enables/AArch32.GenerateDebugExceptionsFrom</h3>
      <p class="pseudocode">// AArch32.GenerateDebugExceptionsFrom()
// =====================================

boolean <a id="AArch32.GenerateDebugExceptionsFrom.2"/>AArch32.GenerateDebugExceptionsFrom(bits(2) from_el, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> from_state)

    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.DebugTargetFrom.1" title="function: bits(2) DebugTargetFrom(SecurityState from_state)">DebugTargetFrom</a>(from_state)) then
        mask = '0';    // No PSTATE.D in AArch32 state
        return <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from_el, SecurityState from_state, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(from_el, from_state, mask);

    if DBGOSLSR.OSLK == '1' || <a href="shared_pseudocode.html#impl-shared.DoubleLockStatus.0" title="function: boolean DoubleLockStatus()">DoubleLockStatus</a>() || <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then
        return FALSE;

    boolean enabled;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; from_state == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        assert from_el != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;    // Secure EL2 always uses AArch64
        if <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() then
            // Implies that EL3 and EL2 both using AArch64
            enabled = MDCR_EL3.SDD == '0';
        else
            spd = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.SPD else MDCR_EL3.SPD32;
            if spd&lt;1&gt; == '1' then
                enabled = spd&lt;0&gt; == '1';
            else
                // SPD == 0b01 is reserved, but behaves the same as 0b00.
                enabled = <a href="shared_pseudocode.html#AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled.0" title="function: boolean AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled()">AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled</a>();
        if from_el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then enabled = enabled || SDER.SUIDEN == '1';
    else
        enabled = from_el != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    return enabled;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.ClearEventCounters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.ClearEventCounters</h3>
      <p class="pseudocode">// AArch32.ClearEventCounters()
// ============================
// Zero all the event counters.

<a id="AArch32.ClearEventCounters.0"/>AArch32.ClearEventCounters()
    if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        // Force the counter to be cleared as a 64-bit counter.
        <a href="shared_pseudocode.html#AArch64.ClearEventCounters.0" title="function: AArch64.ClearEventCounters()">AArch64.ClearEventCounters</a>();
        return;

    integer counters = <a href="shared_pseudocode.html#AArch32.GetNumEventCountersAccessible.0" title="function: integer AArch32.GetNumEventCountersAccessible()">AArch32.GetNumEventCountersAccessible</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            PMEVCNTR[idx] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.CountPMUEvents"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.CountPMUEvents</h3>
      <p class="pseudocode">// AArch32.CountPMUEvents()
// ========================
// Return TRUE if counter "idx" should count its event.
// For the cycle counter, idx == CYCLE_COUNTER_ID.

boolean <a id="AArch32.CountPMUEvents.1"/>AArch32.CountPMUEvents(integer idx)
    constant integer num_counters = <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    assert idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> || idx &lt; num_counters;

    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then return <a href="shared_pseudocode.html#AArch64.CountPMUEvents.1" title="function: boolean AArch64.CountPMUEvents(integer idx)">AArch64.CountPMUEvents</a>(idx);
    boolean debug;
    boolean enabled;
    boolean prohibited;
    boolean filtered;
    boolean frozen;
    boolean resvd_for_el2;
    bit E;
    bit spme;
    bits(32) ovflws;
    // Event counting is disabled in Debug state
    debug = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();

    // Software can reserve some counters for EL2
    resvd_for_el2 = <a href="shared_pseudocode.html#AArch32.PMUCounterIsHyp.1" title="function: boolean AArch32.PMUCounterIsHyp(integer n)">AArch32.PMUCounterIsHyp</a>(idx);
    ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();

    // Main enable controls
    if idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        enabled = PMCR.E == '1' &amp;&amp; PMCNTENSET.C == '1';
    else
        if resvd_for_el2 then
            E = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HDCR.HPME else MDCR_EL2.HPME;
        else
            E = PMCR.E;
        enabled = E == '1' &amp;&amp; PMCNTENSET&lt;idx&gt; == '1';

    // Event counting is allowed unless it is prohibited by any rule below
    prohibited = FALSE;

    // Event counting in Secure state is prohibited if all of:
    // * EL3 is implemented
    // * One of the following is true:
    //   - EL3 is using AArch64, MDCR_EL3.SPME == 0, and either:
    //     - FEAT_PMUv3p7 is not implemented
    //     - MDCR_EL3.MPMX == 0
    //   - EL3 is using AArch32 and SDCR.SPME == 0
    // * Not executing at EL0, or SDER.SUNIDEN == 0
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        spme = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.SPME else MDCR_EL3.SPME;
        if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HavePMUv3p7.0" title="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
            prohibited = spme == '0' &amp;&amp; MDCR_EL3.MPMX == '0';
        else
            prohibited = spme == '0';
        if prohibited &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            prohibited = SDER.SUNIDEN == '0';

    // Event counting at EL2 is prohibited if all of:
    // * The HPMD Extension is implemented
    // * PMNx is not reserved for EL2
    // * HDCR.HPMD == 1
    if !prohibited &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveHPMDExt.0" title="function: boolean HaveHPMDExt()">HaveHPMDExt</a>() &amp;&amp; !resvd_for_el2 then
        prohibited = HDCR.HPMD == '1';

    // The IMPLEMENTATION DEFINED authentication interface might override software
    if prohibited &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveNoSecurePMUDisableOverride.0" title="function: boolean HaveNoSecurePMUDisableOverride()">HaveNoSecurePMUDisableOverride</a>() then
        prohibited = !<a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>();

    // Event counting might be frozen
    frozen = FALSE;

    // If FEAT_PMUv3p7 is implemented, event counting can be frozen
    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p7.0" title="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
        bit FZ;
        if resvd_for_el2 then
            FZ = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HDCR.HPMFZO else MDCR_EL2.HPMFZO;
        else
            FZ = PMCR.FZO;

        frozen = (FZ == '1') &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HiLoPMUOverflow.1" title="function: boolean HiLoPMUOverflow(boolean resvd_for_el2)">HiLoPMUOverflow</a>(resvd_for_el2);

    // PMCR.DP disables the cycle counter when event counting is prohibited
    if (prohibited || frozen) &amp;&amp; idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        enabled = enabled &amp;&amp; (PMCR.DP == '0');
        // Otherwise whether event counting is prohibited does not affect the cycle counter
        prohibited = FALSE;
        frozen = FALSE;

    // If FEAT_PMUv3p5 is implemented, cycle counting can be prohibited.
    // This is not overridden by PMCR.DP.
    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p5.0" title="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() &amp;&amp; idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
            sccd = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.SCCD else MDCR_EL3.SCCD;
            if sccd == '1' then prohibited = TRUE;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; HDCR.HCCD == '1' then
            prohibited = TRUE;

    // Event counting can be filtered by the {P, U, NSK, NSU, NSH} bits
    filter = if idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then PMCCFILTR else PMEVTYPER[idx];

    P   = filter&lt;31&gt;;
    U   = filter&lt;30&gt;;
    NSK = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;29&gt; else '0';
    NSU = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;28&gt; else '0';
    NSH = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then filter&lt;27&gt; else '0';

    ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> filtered = if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then U == '1' else U != NSU;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> filtered = if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then P == '1' else P != NSK;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> filtered = NSH == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> filtered = P == '1';

    return !debug &amp;&amp; enabled &amp;&amp; !prohibited &amp;&amp; !filtered &amp;&amp; !frozen;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.GetNumEventCountersAccessible"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.GetNumEventCountersAccessible</h3>
      <p class="pseudocode">// AArch32.GetNumEventCountersAccessible()
// =======================================
// Return the number of event counters that can be accessed at the current Exception level.

integer <a id="AArch32.GetNumEventCountersAccessible.0"/>AArch32.GetNumEventCountersAccessible()
    integer n;
    integer total_counters = <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    // Software can reserve some counters for EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPMN else HDCR.HPMN);
        if n &gt; total_counters || (!<a href="shared_pseudocode.html#impl-shared.HaveFeatHPMN0.0" title="function: boolean HaveFeatHPMN0()">HaveFeatHPMN0</a>() &amp;&amp; n == 0) then
            (-, n) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high,&#13; Unpredictable which)">ConstrainUnpredictableInteger</a>(0, total_counters,
                                                   <a href="shared_pseudocode.html#Unpredictable_PMUEVENTCOUNTER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_PMUEVENTCOUNTER</a>);
    else
        n = total_counters;

    return n;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.IncrementCycleCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.IncrementCycleCounter</h3>
      <p class="pseudocode">// AArch32.IncrementCycleCounter()
// ===============================
// Increment the cycle counter and possibly set overflow bits.

<a id="AArch32.IncrementCycleCounter.0"/>AArch32.IncrementCycleCounter()
    if (<a href="shared_pseudocode.html#AArch32.CountPMUEvents.1" title="function: boolean AArch32.CountPMUEvents(integer idx)">AArch32.CountPMUEvents</a>(<a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>) &amp;&amp;
        (PMCR.LC == '1' || PMCR.D == '0' || <a href="shared_pseudocode.html#impl-shared.HasElapsed64Cycles.0" title="function: boolean HasElapsed64Cycles()">HasElapsed64Cycles</a>())) then
        integer old_value = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMCCNTR);
        integer new_value = old_value + 1;
        PMCCNTR = new_value&lt;63:0&gt;;

        integer ovflw = if PMCR.LC == '1' then 64 else 32;

        if old_value&lt;64:ovflw&gt; != new_value&lt;64:ovflw&gt; then
            PMOVSSET.C = '1';
            PMOVSR.C = '1';</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.IncrementEventCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.IncrementEventCounter</h3>
      <p class="pseudocode">// AArch32.IncrementEventCounter()
// ===============================
// Increment the specified event counter by the specified amount.

<a id="AArch32.IncrementEventCounter.2"/>AArch32.IncrementEventCounter(integer idx, integer increment)
    if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        // Force the counter to be incremented as a 64-bit counter.
        <a href="shared_pseudocode.html#AArch64.IncrementEventCounter.2" title="function: AArch64.IncrementEventCounter(integer idx, integer increment)">AArch64.IncrementEventCounter</a>(idx, increment);
        return;

    // In this model, event counters in an AArch32-only implementation are 32 bits and
    // the LP bits are RES0 in this model, even if FEAT_PMUv3p5 is implemented.
    integer old_value;
    integer new_value;
    integer ovflw;
    bit lp;
    old_value = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMEVCNTR[idx]);
    new_value = old_value + <a href="shared_pseudocode.html#impl-shared.PMUCountValue.2" title="function: integer PMUCountValue(integer n, integer v)">PMUCountValue</a>(idx, increment);

    PMEVCNTR[idx] = new_value&lt;31:0&gt;;
    ovflw = 32;

    if old_value&lt;64:ovflw&gt; != new_value&lt;64:ovflw&gt; then
        PMOVSSET&lt;idx&gt; = '1';
        PMOVSR&lt;idx&gt; = '1';
        // Check for the CHAIN event from an even counter
        if idx&lt;0&gt; == '0' &amp;&amp; idx + 1 &lt; <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>() then
            <a href="shared_pseudocode.html#impl-shared.PMUEvent.3" title="function: PMUEvent(bits(16) event, integer increment, integer idx)">PMUEvent</a>(PMU_EVENT_CHAIN, 1, idx + 1);</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.PMUCounterIsHyp"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.PMUCounterIsHyp</h3>
      <p class="pseudocode">// AArch32.PMUCounterIsHyp
// =======================
// Returns TRUE if a counter is reserved for use by EL2, FALSE otherwise.

boolean <a id="AArch32.PMUCounterIsHyp.1"/>AArch32.PMUCounterIsHyp(integer n)
    if n == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then return FALSE;

    boolean resvd_for_el2;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then     // Software can reserve some event counters for EL2
        bits(5) hpmn_bits = if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPMN else HDCR.HPMN;
        resvd_for_el2 = n &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(hpmn_bits);
        if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(hpmn_bits) &gt; <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>() || (!<a href="shared_pseudocode.html#impl-shared.HaveFeatHPMN0.0" title="function: boolean HaveFeatHPMN0()">HaveFeatHPMN0</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(hpmn_bits)) then
            resvd_for_el2 = boolean UNKNOWN;
    else
        resvd_for_el2 = FALSE;

    return resvd_for_el2;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.PMUCycle"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.PMUCycle</h3>
      <p class="pseudocode">// AArch32.PMUCycle()
// ==================
// Called at the end of each cycle to increment event counters and
// check for PMU overflow. In pseudocode, a cycle ends after the
// execution of the operational pseudocode.

<a id="AArch32.PMUCycle.0"/>AArch32.PMUCycle()
    if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        <a href="shared_pseudocode.html#AArch64.PMUCycle.0" title="function: AArch64.PMUCycle()">AArch64.PMUCycle</a>();
        return;

    if !<a href="shared_pseudocode.html#impl-shared.HavePMUv3.0" title="function: boolean HavePMUv3()">HavePMUv3</a>() then
        return;

    <a href="shared_pseudocode.html#impl-shared.PMUEvent.1" title="function: PMUEvent(bits(16) event)">PMUEvent</a>(PMU_EVENT_CPU_CYCLES);

    integer counters = <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            if <a href="shared_pseudocode.html#AArch32.CountPMUEvents.1" title="function: boolean AArch32.CountPMUEvents(integer idx)">AArch32.CountPMUEvents</a>(idx) then
                integer accumulated = PMUEventAccumulator[idx];
                <a href="shared_pseudocode.html#AArch32.IncrementEventCounter.2" title="function: AArch32.IncrementEventCounter(integer idx, integer increment)">AArch32.IncrementEventCounter</a>(idx, accumulated);
            PMUEventAccumulator[idx] = 0;

    <a href="shared_pseudocode.html#AArch32.IncrementCycleCounter.0" title="function: AArch32.IncrementCycleCounter()">AArch32.IncrementCycleCounter</a>();
    <a href="shared_pseudocode.html#impl-shared.CheckForPMUOverflow.0" title="function: CheckForPMUOverflow()">CheckForPMUOverflow</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.PMUSwIncrement"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.PMUSwIncrement</h3>
      <p class="pseudocode">// AArch32.PMUSwIncrement()
// ========================
// Generate PMU Events on a write to PMSWINC.

<a id="AArch32.PMUSwIncrement.1"/>AArch32.PMUSwIncrement(bits(32) sw_incr)
    integer counters = <a href="shared_pseudocode.html#AArch32.GetNumEventCountersAccessible.0" title="function: integer AArch32.GetNumEventCountersAccessible()">AArch32.GetNumEventCountersAccessible</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            if sw_incr&lt;idx&gt; == '1' then
                <a href="shared_pseudocode.html#impl-shared.PMUEvent.3" title="function: PMUEvent(bits(16) event, integer increment, integer idx)">PMUEvent</a>(PMU_EVENT_SW_INCR, 1, idx);</p>
    </div>
    <div class="ps"><a id="aarch32.debug.takeexceptiondbg.AArch32.EnterHypModeInDebugState"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/takeexceptiondbg/AArch32.EnterHypModeInDebugState</h3>
      <p class="pseudocode">// AArch32.EnterHypModeInDebugState()
// ==================================
// Take an exception in Debug state to Hyp mode.

<a id="AArch32.EnterHypModeInDebugState.1"/>AArch32.EnterHypModeInDebugState(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    <a href="shared_pseudocode.html#AArch32.ReportHypEntry.1" title="function: AArch32.ReportHypEntry(ExceptionRecord exception)">AArch32.ReportHypEntry</a>(exception);
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(32) UNKNOWN;
    ELR_hyp = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F&gt; = bits(4) UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    PSTATE.E = HSCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
    EDSCR.ERR = '1';
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.debug.takeexceptiondbg.AArch32.EnterModeInDebugState"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/takeexceptiondbg/AArch32.EnterModeInDebugState</h3>
      <p class="pseudocode">// AArch32.EnterModeInDebugState()
// ===============================
// Take an exception in Debug state to a mode other than Monitor and Hyp mode.

<a id="AArch32.EnterModeInDebugState.1"/>AArch32.EnterModeInDebugState(bits(5) target_mode)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(target_mode);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(32) UNKNOWN;
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F&gt; = bits(4) UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; SCTLR.SPAN == '0' then PSTATE.PAN = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
    EDSCR.ERR = '1';
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR processor state flags.

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.debug.takeexceptiondbg.AArch32.EnterMonitorModeInDebugState"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/takeexceptiondbg/AArch32.EnterMonitorModeInDebugState</h3>
      <p class="pseudocode">// AArch32.EnterMonitorModeInDebugState()
// ======================================
// Take an exception in Debug state to Monitor mode.

<a id="AArch32.EnterMonitorModeInDebugState.0"/>AArch32.EnterMonitorModeInDebugState()
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    from_secure = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(32) UNKNOWN;
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F&gt; = bits(4) UNKNOWN;
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() then
        if !from_secure then
            PSTATE.PAN = '0';
        elsif SCTLR.SPAN == '0' then
            PSTATE.PAN = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    EDSCR.ERR = '1';
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR processor state flags.

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.debug.watchpoint.AArch32.WatchpointByteMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/watchpoint/AArch32.WatchpointByteMatch</h3>
      <p class="pseudocode">// AArch32.WatchpointByteMatch()
// =============================

boolean <a id="AArch32.WatchpointByteMatch.2"/>AArch32.WatchpointByteMatch(integer n, bits(32) vaddress)

    integer top = 31;
    bottom = if DBGWVR[n]&lt;2&gt; == '1' then 2 else 3;            // Word or doubleword
    byte_select_match = (DBGWCR[n].BAS&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;bottom-1:0&gt;)&gt; != '0');
    mask = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGWCR[n].MASK);

    // If DBGWCR[n].MASK is non-zero value and DBGWCR[n].BAS is not set to '11111111', or
    // DBGWCR[n].BAS specifies a non-contiguous set of bytes behavior is CONSTRAINED
    // UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGWCR[n].BAS) then
        byte_select_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPMASKANDBAS" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_WPMASKANDBAS</a>);
    else
        LSB = (DBGWCR[n].BAS AND NOT(DBGWCR[n].BAS - 1));  MSB = (DBGWCR[n].BAS + LSB);
        if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(MSB AND (MSB - 1)) then                     // Not contiguous
            byte_select_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPBASCONTIGUOUS" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_WPBASCONTIGUOUS</a>);
            bottom = 3;                                        // For the whole doubleword

    // If the address mask is set to a reserved value, the behavior is CONSTRAINED UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; mask &lt;= 2 then
        <a href="shared_pseudocode.html#Constraint" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
        (c, mask) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high,&#13; Unpredictable which)">ConstrainUnpredictableInteger</a>(3, 31, <a href="shared_pseudocode.html#Unpredictable_RESWPMASK" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESWPMASK</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        case c of
            when <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>  return FALSE;            // Disabled
            when <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>      mask = 0;                // No masking
            // Otherwise the value returned by ConstrainUnpredictableInteger is a not-reserved value

    boolean WVR_match;
    if mask &gt; bottom then
        WVR_match = (vaddress&lt;top:mask&gt; == DBGWVR[n]&lt;top:mask&gt;);
        // If masked bits of DBGWVR_EL1[n] are not zero, the behavior is CONSTRAINED UNPREDICTABLE.
        if WVR_match &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGWVR[n]&lt;mask-1:bottom&gt;) then
            WVR_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPMASKEDBITS" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_WPMASKEDBITS</a>);
    else
        WVR_match = vaddress&lt;top:bottom&gt; == DBGWVR[n]&lt;top:bottom&gt;;

    return WVR_match &amp;&amp; byte_select_match;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.watchpoint.AArch32.WatchpointMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/watchpoint/AArch32.WatchpointMatch</h3>
      <p class="pseudocode">// AArch32.WatchpointMatch()
// =========================
// Watchpoint matching in an AArch32 translation regime.

boolean <a id="AArch32.WatchpointMatch.4"/>AArch32.WatchpointMatch(integer n, bits(32) vaddress, integer size,
                                <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt; <a href="shared_pseudocode.html#impl-shared.NumWatchpointsImplemented.0" title="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>();

    enabled = DBGWCR[n].E == '1';
    linked = DBGWCR[n].WT == '1';
    isbreakpnt = FALSE;

    state_match = <a href="shared_pseudocode.html#AArch32.StateMatch.7" title="function: boolean AArch32.StateMatch(bits(2) ssc_in,  bit hmc_in, bits(2) pxc_in, boolean linked_in,&#13; bits(4) lbn, boolean isbreakpnt, AccessDescriptor accdesc)">AArch32.StateMatch</a>(DBGWCR[n].SSC, DBGWCR[n].HMC, DBGWCR[n].PAC,
                                     linked, DBGWCR[n].LBN, isbreakpnt, accdesc);

    boolean ls_match;
    case DBGWCR[n].LSC&lt;1:0&gt; of
        when '00' ls_match = FALSE;
        when '01' ls_match = accdesc.read;
        when '10' ls_match = accdesc.write || accdesc.acctype == <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>;
        when '11' ls_match = TRUE;

    value_match = FALSE;
    for byte = 0 to size - 1
        value_match = value_match || <a href="shared_pseudocode.html#AArch32.WatchpointByteMatch.2" title="function: boolean AArch32.WatchpointByteMatch(integer n, bits(32) vaddress)">AArch32.WatchpointByteMatch</a>(n, vaddress + byte);

    return value_match &amp;&amp; state_match &amp;&amp; ls_match &amp;&amp; enabled;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.Abort"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.Abort</h3>
      <p class="pseudocode">// AArch32.Abort()
// ===============
// Abort and Debug exception handling in an AArch32 translation regime.

<a id="AArch32.Abort.2"/>AArch32.Abort(bits(32) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = (HCR_EL2.TGE == '1' || <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) ||
                            (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR_EL2.TEA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                            (<a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; MDCR_EL2.TDE == '1'));

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.EA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);

    if route_to_aarch64 then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(vaddress,  64), fault);
    elsif fault.access.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        <a href="shared_pseudocode.html#AArch32.TakePrefetchAbortException.2" title="function: AArch32.TakePrefetchAbortException(bits(32) vaddress, FaultRecord fault)">AArch32.TakePrefetchAbortException</a>(vaddress, fault);
    else
        <a href="shared_pseudocode.html#AArch32.TakeDataAbortException.2" title="function: AArch32.TakeDataAbortException(bits(32) vaddress, FaultRecord fault)">AArch32.TakeDataAbortException</a>(vaddress, fault);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.AbortSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.AbortSyndrome</h3>
      <p class="pseudocode">// AArch32.AbortSyndrome()
// =======================
// Creates an exception syndrome record for Abort  exceptions taken to Hyp mode
// from an AArch32 translation regime.

ExceptionRecord <a id="AArch32.AbortSyndrome.3"/>AArch32.AbortSyndrome(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault, bits(32) vaddress)
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(exceptype);

    d_side = exceptype == <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>;

    exception.syndrome = <a href="shared_pseudocode.html#AArch32.FaultSyndrome.2" title="function: bits(25) AArch32.FaultSyndrome(boolean d_side, FaultRecord fault)">AArch32.FaultSyndrome</a>(d_side, fault);

    exception.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(vaddress, 64);

    if <a href="shared_pseudocode.html#impl-shared.IPAValid.1" title="function: boolean IPAValid(FaultRecord fault)">IPAValid</a>(fault) then
        exception.ipavalid = TRUE;
        exception.NS = if fault.ipaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then '1' else '0';
        exception.ipaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(fault.ipaddress.address,  56);
    else
        exception.ipavalid = FALSE;

    return exception;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.CheckPCAlignment"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.CheckPCAlignment</h3>
      <p class="pseudocode">// AArch32.CheckPCAlignment()
// ==========================

<a id="AArch32.CheckPCAlignment.0"/>AArch32.CheckPCAlignment()
    bits(32) pc = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);

    if (<a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> &amp;&amp; pc&lt;1&gt; == '1') || pc&lt;0&gt; == '1' then
        if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then <a href="shared_pseudocode.html#AArch64.PCAlignmentFault.0" title="function: AArch64.PCAlignmentFault()">AArch64.PCAlignmentFault</a>();

        <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescIFetch.0" title="function: AccessDescriptor CreateAccDescIFetch()">CreateAccDescIFetch</a>();
        <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.NoFault.1" title="function: FaultRecord NoFault(AccessDescriptor accdesc)">NoFault</a>(accdesc);
        // Generate an Alignment fault Prefetch Abort exception
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(pc, fault);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.CommonFaultStatus"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.CommonFaultStatus</h3>
      <p class="pseudocode">// AArch32.CommonFaultStatus()
// ===========================
// Return the common part of the fault status on reporting a Data
// or Prefetch Abort.

bits(32) <a id="AArch32.CommonFaultStatus.2"/>AArch32.CommonFaultStatus(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault, boolean long_format)
    bits(32) target = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault) then
        <a href="shared_pseudocode.html#ErrorState" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState</a> errstate = <a href="shared_pseudocode.html#AArch32.PEErrorState.1" title="function: ErrorState AArch32.PEErrorState(FaultRecord fault)">AArch32.PEErrorState</a>(fault);
        target&lt;15:14&gt; = <a href="shared_pseudocode.html#AArch32.EncodeAsyncErrorSyndrome.1" title="function: bits(2) AArch32.EncodeAsyncErrorSyndrome(ErrorState errorstate)">AArch32.EncodeAsyncErrorSyndrome</a>(errstate);   // AET
    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then target&lt;12&gt; = fault.extflag;        // ExT
    target&lt;9&gt; = if long_format then '1' else '0';                     // LPAE
    if long_format then                                               // Long-descriptor format
        target&lt;5:0&gt;    = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);  // STATUS
    else                                                              // Short-descriptor format
        target&lt;10,3:0&gt; = <a href="shared_pseudocode.html#impl-aarch32.EncodeSDFSC.2" title="function: bits(5) EncodeSDFSC(Fault statuscode, integer level)">EncodeSDFSC</a>(fault.statuscode, fault.level);  // FS
    return target;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.ReportDataAbort"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.ReportDataAbort</h3>
      <p class="pseudocode">// AArch32.ReportDataAbort()
// =========================
// Report syndrome information for aborts taken to modes other than Hyp mode.

<a id="AArch32.ReportDataAbort.3"/>AArch32.ReportDataAbort(boolean route_to_monitor, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault,
                        bits(32) vaddress)
    long_format = FALSE;
    if route_to_monitor &amp;&amp; <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        long_format = ((TTBCR_S.EAE == '1') ||
                       (<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) &amp;&amp; ((PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || TTBCR.EAE == '1') ||
                        (fault.secondstage &amp;&amp; boolean IMPLEMENTATION_DEFINED "Stage 2 synchronous External abort reports using Long-descriptor format when TTBCR_S.EAE is 0b0"))));
    else
        long_format = TTBCR.EAE == '1';
    bits(32) syndrome = <a href="shared_pseudocode.html#AArch32.CommonFaultStatus.2" title="function: bits(32) AArch32.CommonFaultStatus(FaultRecord fault, boolean long_format)">AArch32.CommonFaultStatus</a>(fault, long_format);

    // bits of syndrome that are not common to I and D side
    if fault.access.acctype IN {<a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>, <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_AT" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_AT</a>} then
        syndrome&lt;13&gt; = '1';                              // CM
        syndrome&lt;11&gt; = '1';                              // WnR
    else
        syndrome&lt;11&gt; = if fault.write then '1' else '0'; // WnR

    if !long_format then
        syndrome&lt;7:4&gt; = fault.domain;                    // Domain

    if fault.access.acctype == <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a> then
        bits(32) i_syndrome;
        if (!long_format &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Report I-cache maintenance fault in IFSR") then
            i_syndrome = syndrome;
            syndrome&lt;10,3:0&gt; = <a href="shared_pseudocode.html#impl-aarch32.EncodeSDFSC.2" title="function: bits(5) EncodeSDFSC(Fault statuscode, integer level)">EncodeSDFSC</a>(<a href="shared_pseudocode.html#Fault_ICacheMaint" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_ICacheMaint</a>, 1);
        else
            i_syndrome = bits(32) UNKNOWN;
        if route_to_monitor then
            IFSR_S = i_syndrome;
        else
            IFSR = i_syndrome;

    if route_to_monitor then
        DFSR_S = syndrome;
        DFAR_S = vaddress;
    else
        DFSR = syndrome;
        DFAR = vaddress;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.ReportPrefetchAbort"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.ReportPrefetchAbort</h3>
      <p class="pseudocode">// AArch32.ReportPrefetchAbort()
// =============================
// Report syndrome information for aborts taken to modes other than Hyp mode.

<a id="AArch32.ReportPrefetchAbort.3"/>AArch32.ReportPrefetchAbort(boolean route_to_monitor, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault, bits(32) vaddress)
    // The encoding used in the IFSR can be Long-descriptor format or Short-descriptor format.
    // Normally, the current translation table format determines the format. For an abort from
    // Non-secure state to Monitor mode, the IFSR uses the Long-descriptor format if any of the
    // following applies:
    // * The Secure TTBCR.EAE is set to 1.
    // * It is taken from Hyp mode.
    // * It is taken from EL1 or EL0, and the Non-secure TTBCR.EAE is set to 1.
    long_format = FALSE;
    if route_to_monitor &amp;&amp; <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        long_format = TTBCR_S.EAE == '1' || PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || TTBCR.EAE == '1';
    else
        long_format = TTBCR.EAE == '1';

    bits(32) fsr = <a href="shared_pseudocode.html#AArch32.CommonFaultStatus.2" title="function: bits(32) AArch32.CommonFaultStatus(FaultRecord fault, boolean long_format)">AArch32.CommonFaultStatus</a>(fault, long_format);

    if route_to_monitor then
        IFSR_S = fsr;
        IFAR_S = vaddress;
    else
        IFSR = fsr;
        IFAR = vaddress;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.TakeDataAbortException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.TakeDataAbortException</h3>
      <p class="pseudocode">// AArch32.TakeDataAbortException()
// ================================

<a id="AArch32.TakeDataAbortException.2"/>AArch32.TakeDataAbortException(bits(32) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);
    route_to_hyp = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR.TGE == '1' ||
                     (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR2.TEA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                     (<a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; HDCR.TDE == '1') ||
                     <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);
    vect_offset = 0x10;
    lr_offset = 8;

    if <a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) then DBGDSCRext.MOE = fault.debugmoe;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault,&#13; bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#AArch32.AbortSyndrome.3" title="function: ExceptionRecord AArch32.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, fault, vaddress);
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault,&#13; bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.TakePrefetchAbortException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.TakePrefetchAbortException</h3>
      <p class="pseudocode">// AArch32.TakePrefetchAbortException()
// ====================================

<a id="AArch32.TakePrefetchAbortException.2"/>AArch32.TakePrefetchAbortException(bits(32) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);

    route_to_hyp = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR.TGE == '1' ||
                     (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR2.TEA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                     (<a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; HDCR.TDE == '1') ||
                     <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));

    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);
    vect_offset = 0x0C;
    lr_offset = 4;

    if <a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) then DBGDSCRext.MOE = fault.debugmoe;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.ReportPrefetchAbort.3" title="function: AArch32.ReportPrefetchAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportPrefetchAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        if fault.statuscode == <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a> then             // PC Alignment fault
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>);
            exception.vaddress = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
        else
            exception = <a href="shared_pseudocode.html#AArch32.AbortSyndrome.3" title="function: ExceptionRecord AArch32.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>, fault, vaddress);
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.ReportPrefetchAbort.3" title="function: AArch32.ReportPrefetchAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportPrefetchAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32.TakePhysicalFIQException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32.TakePhysicalFIQException</h3>
      <p class="pseudocode">// AArch32.TakePhysicalFIQException()
// ==================================

<a id="AArch32.TakePhysicalFIQException.0"/>AArch32.TakePhysicalFIQException()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || (HCR_EL2.FMO == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>());

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.FIQ == '1';

    if route_to_aarch64 then <a href="shared_pseudocode.html#AArch64.TakePhysicalFIQException.0" title="function: AArch64.TakePhysicalFIQException()">AArch64.TakePhysicalFIQException</a>();
    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.FIQ == '1';
    route_to_hyp = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR.TGE == '1' || HCR.FMO == '1'));
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);
    vect_offset = 0x1C;
    lr_offset = 4;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>);
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32.TakePhysicalIRQException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32.TakePhysicalIRQException</h3>
      <p class="pseudocode">// AArch32.TakePhysicalIRQException()
// ==================================
// Take an enabled physical IRQ exception.

<a id="AArch32.TakePhysicalIRQException.0"/>AArch32.TakePhysicalIRQException()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || (HCR_EL2.IMO == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>());
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.IRQ == '1';

    if route_to_aarch64 then <a href="shared_pseudocode.html#AArch64.TakePhysicalIRQException.0" title="function: AArch64.TakePhysicalIRQException()">AArch64.TakePhysicalIRQException</a>();

    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.IRQ == '1';
    route_to_hyp = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR.TGE == '1' || HCR.IMO == '1'));
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);
    vect_offset = 0x18;
    lr_offset = 4;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>);
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32.TakePhysicalSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32.TakePhysicalSErrorException</h3>
      <p class="pseudocode">// AArch32.TakePhysicalSErrorException()
// =====================================

<a id="AArch32.TakePhysicalSErrorException.1"/>AArch32.TakePhysicalSErrorException(boolean implicit_esb)
    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = (HCR_EL2.TGE == '1' || (!<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; HCR_EL2.AMO == '1'));
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.EA == '1';

    if route_to_aarch64 then
        <a href="shared_pseudocode.html#AArch64.TakePhysicalSErrorException.1" title="function: AArch64.TakePhysicalSErrorException(boolean implicit_esb)">AArch64.TakePhysicalSErrorException</a>(implicit_esb);

    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1';
    route_to_hyp = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR.TGE == '1' || HCR.AMO == '1'));
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);
    vect_offset = 0x10;
    lr_offset = 8;

    bits(2) target_el;
    if route_to_monitor then
        target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.GetPendingPhysicalSError.0" title="function: FaultRecord GetPendingPhysicalSError()">GetPendingPhysicalSError</a>();
    vaddress = bits(32) UNKNOWN;
    exception = <a href="shared_pseudocode.html#AArch32.AbortSyndrome.3" title="function: ExceptionRecord AArch32.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, fault, vaddress);

    if <a href="shared_pseudocode.html#impl-shared.IsSErrorEdgeTriggered.2" title="function: boolean IsSErrorEdgeTriggered(bits(2) target_el, bits(25) syndrome)">IsSErrorEdgeTriggered</a>(target_el, exception.syndrome) then
        <a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();
    case target_el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault,&#13; bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
            <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
                <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
            else
                <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault,&#13; bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
            <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32.TakeVirtualFIQException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32.TakeVirtualFIQException</h3>
      <p class="pseudocode">// AArch32.TakeVirtualFIQException()
// =================================

<a id="AArch32.TakeVirtualFIQException.0"/>AArch32.TakeVirtualFIQException()
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then  // Virtual IRQ enabled if TGE==0 and FMO==1
        assert HCR.TGE == '0' &amp;&amp; HCR.FMO == '1';
    else
        assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.FMO == '1';
    // Check if routed to AArch64 state
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then <a href="shared_pseudocode.html#AArch64.TakeVirtualFIQException.0" title="function: AArch64.TakeVirtualFIQException()">AArch64.TakeVirtualFIQException</a>();

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);
    vect_offset = 0x1C;
    lr_offset = 4;

    <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32.TakeVirtualIRQException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32.TakeVirtualIRQException</h3>
      <p class="pseudocode">// AArch32.TakeVirtualIRQException()
// =================================

<a id="AArch32.TakeVirtualIRQException.0"/>AArch32.TakeVirtualIRQException()
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then   // Virtual IRQs enabled if TGE==0 and IMO==1
        assert HCR.TGE == '0' &amp;&amp; HCR.IMO == '1';
    else
        assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.IMO == '1';

    // Check if routed to AArch64 state
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then <a href="shared_pseudocode.html#AArch64.TakeVirtualIRQException.0" title="function: AArch64.TakeVirtualIRQException()">AArch64.TakeVirtualIRQException</a>();

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);
    vect_offset = 0x18;
    lr_offset = 4;

    <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32.TakeVirtualSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32.TakeVirtualSErrorException</h3>
      <p class="pseudocode">// AArch32.TakeVirtualSErrorException()
// ====================================

<a id="AArch32.TakeVirtualSErrorException.0"/>AArch32.TakeVirtualSErrorException()

    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then   // Virtual SError enabled if TGE==0 and AMO==1
        assert HCR.TGE == '0' &amp;&amp; HCR.AMO == '1';
    else
        assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';
    // Check if routed to AArch64 state
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then <a href="shared_pseudocode.html#AArch64.TakeVirtualSErrorException.0" title="function: AArch64.TakeVirtualSErrorException()">AArch64.TakeVirtualSErrorException</a>();
    route_to_monitor = FALSE;

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);
    vect_offset = 0x10;
    lr_offset = 8;

    vaddress = bits(32) UNKNOWN;
    parity = FALSE;
    <a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> fault = <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>;
    integer level = integer UNKNOWN;
    bits(32) fsr = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() then
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            fsr&lt;15:14&gt; =  VDFSR.AET;
            fsr&lt;12&gt; =  VDFSR.ExT;
        else
            fsr&lt;15:14&gt; =  VSESR_EL2.AET;
            fsr&lt;12&gt; =  VSESR_EL2.ExT;
    else
        fsr&lt;12&gt; = bit IMPLEMENTATION_DEFINED "Virtual External abort type";
    if TTBCR.EAE == '1' then // Long-descriptor format
        fsr&lt;9&gt; = '1';
        fsr&lt;5:0&gt; = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault, level);
    else                     // Short-descriptor format
        fsr&lt;9&gt; = '0';
        fsr&lt;10,3:0&gt; = <a href="shared_pseudocode.html#impl-aarch32.EncodeSDFSC.2" title="function: bits(5) EncodeSDFSC(Fault statuscode, integer level)">EncodeSDFSC</a>(fault, level);
    DFSR = fsr;
    DFAR = bits(32) UNKNOWN;
    <a href="shared_pseudocode.html#impl-shared.ClearPendingVirtualSError.0" title="function: ClearPendingVirtualSError()">ClearPendingVirtualSError</a>();
    <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.debug.AArch32.SoftwareBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/debug/AArch32.SoftwareBreakpoint</h3>
      <p class="pseudocode">// AArch32.SoftwareBreakpoint()
// ============================

<a id="AArch32.SoftwareBreakpoint.1"/>AArch32.SoftwareBreakpoint(bits(16) immediate)

    if (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
        (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1')) || !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.SoftwareBreakpoint.1" title="function: AArch64.SoftwareBreakpoint(bits(16) immediate)">AArch64.SoftwareBreakpoint</a>(immediate);

    accdesc  = <a href="shared_pseudocode.html#impl-shared.CreateAccDescIFetch.0" title="function: AccessDescriptor CreateAccDescIFetch()">CreateAccDescIFetch</a>();
    fault    = <a href="shared_pseudocode.html#impl-shared.NoFault.1" title="function: FaultRecord NoFault(AccessDescriptor accdesc)">NoFault</a>(accdesc);
    vaddress = bits(32) UNKNOWN;

    fault.statuscode = <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;
    fault.debugmoe   = <a href="shared_pseudocode.html#DebugException_BKPT" title="constant bits(4) DebugException_BKPT = '0011'">DebugException_BKPT</a>;

    <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(vaddress, fault);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.debug.DebugException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/debug/DebugException</h3>
      <p class="pseudocode">constant bits(4) <a id="DebugException_Breakpoint"/>DebugException_Breakpoint  = '0001';
constant bits(4) <a id="DebugException_BKPT"/>DebugException_BKPT        = '0011';
constant bits(4) <a id="DebugException_VectorCatch"/>DebugException_VectorCatch = '0101';
constant bits(4) <a id="DebugException_Watchpoint"/>DebugException_Watchpoint  = '1010';</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32.CheckAdvSIMDOrFPRegisterTraps"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.CheckAdvSIMDOrFPRegisterTraps</h3>
      <p class="pseudocode">// AArch32.CheckAdvSIMDOrFPRegisterTraps()
// =======================================
// Check if an instruction that accesses an Advanced SIMD and
// floating-point System register is trapped by an appropriate HCR.TIDx
// ID group trap control.

<a id="AArch32.CheckAdvSIMDOrFPRegisterTraps.1"/>AArch32.CheckAdvSIMDOrFPRegisterTraps(bits(4) reg)

    if PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        tid0 = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HCR.TID0 else HCR_EL2.TID0;
        tid3 = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HCR.TID3 else HCR_EL2.TID3;

        if (tid0 == '1' &amp;&amp; reg == '0000')                             // FPSID
          || (tid3 == '1' &amp;&amp; reg IN {'0101', '0110', '0111'}) then    // MVFRx
            if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
                <a href="shared_pseudocode.html#AArch32.SystemAccessTrap.2" title="function: AArch32.SystemAccessTrap(bits(5) mode, integer ec)">AArch32.SystemAccessTrap</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>, 0x8);               // Exception_AdvSIMDFPAccessTrap
            else
                <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, 0x8);            // Exception_AdvSIMDFPAccessTrap</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32.ExceptionClass"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.ExceptionClass</h3>
      <p class="pseudocode">// AArch32.ExceptionClass()
// ========================
// Returns the Exception Class and Instruction Length fields to be reported in HSR

(integer,bit) <a id="AArch32.ExceptionClass.1"/>AArch32.ExceptionClass(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype)

    il_is_valid = TRUE;
    integer ec;
    case exceptype of
        when <a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>        ec = 0x00; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>              ec = 0x01;
        when <a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>           ec = 0x03;
        when <a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>          ec = 0x04;
        when <a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>           ec = 0x05;
        when <a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>           ec = 0x06;
        when <a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>  ec = 0x07;
        when <a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>             ec = 0x08;
        when <a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACTrap</a>              ec = 0x09;
        when <a href="shared_pseudocode.html#Exception_TSTARTAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_TSTARTAccessTrap</a>     ec = 0x1B;
        when <a href="shared_pseudocode.html#Exception_GPC" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_GPC</a>                  ec = 0x1E;
        when <a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>          ec = 0x0C;
        when <a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>         ec = 0x0D;
        when <a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>         ec = 0x0E; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>       ec = 0x11;
        when <a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>       ec = 0x12;
        when <a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>          ec = 0x13;
        when <a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>     ec = 0x20; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>          ec = 0x22; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>            ec = 0x24;
        when <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>         ec = 0x25;
        when <a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPTrappedException</a>   ec = 0x28;
        otherwise                           <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    if ec IN {0x20,0x24} &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        ec = ec + 1;
    bit il;
    if il_is_valid then
        il = if <a href="shared_pseudocode.html#impl-shared.ThisInstrLength.0" title="function: integer ThisInstrLength()">ThisInstrLength</a>() == 32 then '1' else '0';
    else
        il = '1';

    return (ec,il);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32.GeneralExceptionsToAArch64"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.GeneralExceptionsToAArch64</h3>
      <p class="pseudocode">// AArch32.GeneralExceptionsToAArch64()
// ====================================
// Returns TRUE if exceptions normally routed to EL1 are being handled at an Exception
// level using AArch64, because either EL1 is using AArch64 or TGE is in force and EL2
// is using AArch64.

boolean <a id="AArch32.GeneralExceptionsToAArch64.0"/>AArch32.GeneralExceptionsToAArch64()
    return ((PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) ||
            (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '1'));</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32.ReportHypEntry"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.ReportHypEntry</h3>
      <p class="pseudocode">// AArch32.ReportHypEntry()
// ========================
// Report syndrome information to Hyp mode registers.

<a id="AArch32.ReportHypEntry.1"/>AArch32.ReportHypEntry(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception)

    <a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype = exception.exceptype;

    (ec,il) = <a href="shared_pseudocode.html#AArch32.ExceptionClass.1" title="function: (integer,bit) AArch32.ExceptionClass(Exception exceptype)">AArch32.ExceptionClass</a>(exceptype);
    iss  = exception.syndrome;
    iss2 = exception.syndrome2;

    // IL is not valid for Data Abort exceptions without valid instruction syndrome information
    if ec IN {0x24,0x25} &amp;&amp; iss&lt;24&gt; == '0' then
        il = '1';

    HSR = ec&lt;5:0&gt;:il:iss;

    if exceptype IN {<a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>, <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>} then
        HIFAR = exception.vaddress&lt;31:0&gt;;
        HDFAR = bits(32) UNKNOWN;
    elsif exceptype == <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a> then
        HIFAR = bits(32) UNKNOWN;
        HDFAR = exception.vaddress&lt;31:0&gt;;

    if exception.ipavalid then
        HPFAR&lt;31:4&gt; = exception.ipaddress&lt;39:12&gt;;
    else
        HPFAR&lt;31:4&gt; = bits(28) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32.ResetControlRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.ResetControlRegisters</h3>
      <p class="pseudocode">// Resets System registers and memory-mapped control registers that have architecturally-defined
// reset values to those values.
<a id="AArch32.ResetControlRegisters.1"/>AArch32.ResetControlRegisters(boolean cold_reset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32.TakeReset"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.TakeReset</h3>
      <p class="pseudocode">// AArch32.TakeReset()
// ===================
// Reset into AArch32 state

<a id="AArch32.TakeReset.1"/>AArch32.TakeReset(boolean cold_reset)
    assert !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>();

    // Enter the highest implemented Exception level in AArch32 state
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>);
        SCR.NS = '0';                     // Secure state
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
    else
        <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>);

    // Reset System registers in the coproc=0b111x encoding space and other system components
    <a href="shared_pseudocode.html#AArch32.ResetControlRegisters.1" title="function: AArch32.ResetControlRegisters(boolean cold_reset)">AArch32.ResetControlRegisters</a>(cold_reset);
    FPEXC.EN = '0';

    // Reset all other PSTATE fields, including instruction set and endianness according to the
    // SCTLR values produced by the above call to ResetControlRegisters()
    PSTATE.&lt;A,I,F&gt; = '111';       // All asynchronous exceptions masked
    PSTATE.IT = '00000000';       // IT block state reset
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        PSTATE.T = HSCTLR.TE;     // Instruction set: TE=0: A32, TE=1: T32. PSTATE.J is RES0.
        PSTATE.E = HSCTLR.EE;     // Endianness: EE=0: little-endian, EE=1: big-endian
    else
        PSTATE.T = SCTLR.TE;      // Instruction set: TE=0: A32, TE=1: T32. PSTATE.J is RES0.
        PSTATE.E = SCTLR.EE;      // Endianness: EE=0: little-endian, EE=1: big-endian
    PSTATE.IL = '0';              // Clear Illegal Execution state bit

    // All registers, bits and fields not reset by the above pseudocode or by the BranchTo() call
    // below are UNKNOWN bitstrings after reset. In particular, the return information registers
    // R14 or ELR_hyp and SPSR have UNKNOWN values, so that it
    // is impossible to return from a reset in an architecturally defined way.
    <a href="shared_pseudocode.html#AArch32.ResetGeneralRegisters.0" title="function: AArch32.ResetGeneralRegisters()">AArch32.ResetGeneralRegisters</a>();
    <a href="shared_pseudocode.html#AArch32.ResetSIMDFPRegisters.0" title="function: AArch32.ResetSIMDFPRegisters()">AArch32.ResetSIMDFPRegisters</a>();
    <a href="shared_pseudocode.html#AArch32.ResetSpecialRegisters.0" title="function: AArch32.ResetSpecialRegisters()">AArch32.ResetSpecialRegisters</a>();
    <a href="shared_pseudocode.html#impl-shared.ResetExternalDebugRegisters.1" title="function: ResetExternalDebugRegisters(boolean cold_reset)">ResetExternalDebugRegisters</a>(cold_reset);

    bits(32) rv;                      // IMPLEMENTATION DEFINED reset vector

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if MVBAR&lt;0&gt; == '1' then           // Reset vector in MVBAR
            rv = MVBAR&lt;31:1&gt;:'0';
        else
            rv = bits(32) IMPLEMENTATION_DEFINED "reset vector address";
    else
        rv = RVBAR&lt;31:1&gt;:'0';

    // The reset vector must be correctly aligned
    assert rv&lt;0&gt; == '0' &amp;&amp; (PSTATE.T == '1' || rv&lt;1&gt; == '0');

    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(rv, <a href="shared_pseudocode.html#BranchType_RESET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RESET</a>, branch_conditional);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.ExcVectorBase"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/ExcVectorBase</h3>
      <p class="pseudocode">// ExcVectorBase()
// ===============

bits(32) <a id="impl-aarch32.ExcVectorBase.0"/>ExcVectorBase()
    if SCTLR.V == '1' then  // Hivecs selected, base = 0xFFFF0000
        return <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(16):<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    else
        return VBAR&lt;31:5&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(5);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.ieeefp.AArch32.FPTrappedException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/ieeefp/AArch32.FPTrappedException</h3>
      <p class="pseudocode">// AArch32.FPTrappedException()
// ============================

<a id="AArch32.FPTrappedException.1"/>AArch32.FPTrappedException(bits(8) accumulated_exceptions)
    if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then
        is_ase = FALSE;
        element = 0;
        <a href="shared_pseudocode.html#AArch64.FPTrappedException.2" title="function: AArch64.FPTrappedException(boolean is_ase, bits(8) accumulated_exceptions)">AArch64.FPTrappedException</a>(is_ase, accumulated_exceptions);
    FPEXC.DEX    = '1';
    FPEXC.TFV    = '1';
    FPEXC&lt;7,4:0&gt; = accumulated_exceptions&lt;7,4:0&gt;;                  // IDF,IXF,UFF,OFF,DZF,IOF
    FPEXC&lt;10:8&gt;  = '111';                                          // VECITR is RES1

    <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32.CallHypervisor"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.CallHypervisor</h3>
      <p class="pseudocode">// AArch32.CallHypervisor()
// ========================
// Performs a HVC call

<a id="AArch32.CallHypervisor.1"/>AArch32.CallHypervisor(bits(16) immediate)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        <a href="shared_pseudocode.html#AArch64.CallHypervisor.1" title="function: AArch64.CallHypervisor(bits(16) immediate)">AArch64.CallHypervisor</a>(immediate);
    else
        <a href="shared_pseudocode.html#AArch32.TakeHVCException.1" title="function: AArch32.TakeHVCException(bits(16) immediate)">AArch32.TakeHVCException</a>(immediate);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32.CallSupervisor"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.CallSupervisor</h3>
      <p class="pseudocode">// AArch32.CallSupervisor()
// ========================
// Calls the Supervisor

<a id="AArch32.CallSupervisor.1"/>AArch32.CallSupervisor(bits(16) immediate_in)
    bits(16) immediate = immediate_in;
    if <a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() != '1110' then
        immediate = bits(16) UNKNOWN;
    if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then
        <a href="shared_pseudocode.html#AArch64.CallSupervisor.1" title="function: AArch64.CallSupervisor(bits(16) immediate_in)">AArch64.CallSupervisor</a>(immediate);
    else
        <a href="shared_pseudocode.html#AArch32.TakeSVCException.1" title="function: AArch32.TakeSVCException(bits(16) immediate)">AArch32.TakeSVCException</a>(immediate);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32.TakeHVCException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.TakeHVCException</h3>
      <p class="pseudocode">// AArch32.TakeHVCException()
// ==========================

<a id="AArch32.TakeHVCException.1"/>AArch32.TakeHVCException(bits(16) immediate)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.1" title="function: bits(N) NextInstrAddr(integer N)">NextInstrAddr</a>(32);
    vect_offset = 0x08;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32.TakeSMCException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.TakeSMCException</h3>
      <p class="pseudocode">// AArch32.TakeSMCException()
// ==========================

<a id="AArch32.TakeSMCException.0"/>AArch32.TakeSMCException()
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.1" title="function: bits(N) NextInstrAddr(integer N)">NextInstrAddr</a>(32);
    vect_offset = 0x08;
    lr_offset = 0;

    <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32.TakeSVCException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.TakeSVCException</h3>
      <p class="pseudocode">// AArch32.TakeSVCException()
// ==========================

<a id="AArch32.TakeSVCException.1"/>AArch32.TakeSVCException(bits(16) immediate)

    <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    route_to_hyp = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR.TGE == '1';

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.1" title="function: bits(N) NextInstrAddr(integer N)">NextInstrAddr</a>(32);
    vect_offset = 0x08;
    lr_offset = 0;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>);
        exception.syndrome&lt;15:0&gt; = immediate;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.takeexception.AArch32.EnterHypMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/takeexception/AArch32.EnterHypMode</h3>
      <p class="pseudocode">// AArch32.EnterHypMode()
// ======================
// Take an exception to Hyp mode.

<a id="AArch32.EnterHypMode.3"/>AArch32.EnterHypMode(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception, bits(32) preferred_exception_return,
                     integer vect_offset)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    bits(32) spsr = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.2" title="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState, integer N)">GetPSRFromPSTATE</a>(<a href="shared_pseudocode.html#AArch32_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a>, 32);
    if !(exception.exceptype IN {<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>, <a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>}) then
        <a href="shared_pseudocode.html#AArch32.ReportHypEntry.1" title="function: AArch32.ReportHypEntry(ExceptionRecord exception)">AArch32.ReportHypEntry</a>(exception);
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = spsr;
    ELR_hyp = preferred_exception_return;
    PSTATE.T = HSCTLR.TE;                       // PSTATE.J is RES0
    PSTATE.SS = '0';
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].EA == '0' then PSTATE.A = '1';
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].IRQ == '0' then PSTATE.I = '1';
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].FIQ == '0' then PSTATE.F = '1';
    PSTATE.E = HSCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = HSCTLR.DSSBS;
    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(HVBAR&lt;31:5&gt;:vect_offset&lt;4:0&gt;, <a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>, branch_conditional);

    <a href="shared_pseudocode.html#impl-shared.CheckExceptionCatch.1" title="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(TRUE);                  // Check for debug event on exception entry

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.takeexception.AArch32.EnterMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/takeexception/AArch32.EnterMode</h3>
      <p class="pseudocode">// AArch32.EnterMode()
// ===================
// Take an exception to a mode other than Monitor and Hyp mode.

<a id="AArch32.EnterMode.4"/>AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,
                  integer vect_offset)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    bits(32) spsr = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.2" title="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState, integer N)">GetPSRFromPSTATE</a>(<a href="shared_pseudocode.html#AArch32_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a>, 32);
    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(target_mode);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = spsr;
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = preferred_exception_return + lr_offset;
    PSTATE.T = SCTLR.TE;                        // PSTATE.J is RES0
    PSTATE.SS = '0';
    if target_mode == <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a> then
        PSTATE.&lt;A,I,F&gt; = '111';
    elsif target_mode IN {<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>} then
        PSTATE.&lt;A,I&gt; = '11';
    else
        PSTATE.I = '1';
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; SCTLR.SPAN == '0' then PSTATE.PAN = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = SCTLR.DSSBS;
    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(<a href="shared_pseudocode.html#impl-aarch32.ExcVectorBase.0" title="function: bits(32) ExcVectorBase()">ExcVectorBase</a>()&lt;31:5&gt;:vect_offset&lt;4:0&gt;, <a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>, branch_conditional);

    <a href="shared_pseudocode.html#impl-shared.CheckExceptionCatch.1" title="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(TRUE);                  // Check for debug event on exception entry

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.takeexception.AArch32.EnterMonitorMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/takeexception/AArch32.EnterMonitorMode</h3>
      <p class="pseudocode">// AArch32.EnterMonitorMode()
// ==========================
// Take an exception to Monitor mode.

<a id="AArch32.EnterMonitorMode.3"/>AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,
                         integer vect_offset)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    from_secure = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
    bits(32) spsr = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.2" title="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState, integer N)">GetPSRFromPSTATE</a>(<a href="shared_pseudocode.html#AArch32_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a>, 32);
    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = spsr;
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = preferred_exception_return + lr_offset;
    PSTATE.T = SCTLR.TE;                        // PSTATE.J is RES0
    PSTATE.SS = '0';
    PSTATE.&lt;A,I,F&gt; = '111';
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() then
        if !from_secure then
            PSTATE.PAN = '0';
        elsif SCTLR.SPAN == '0' then
            PSTATE.PAN = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = SCTLR.DSSBS;
    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(MVBAR&lt;31:5&gt;:vect_offset&lt;4:0&gt;, <a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>, branch_conditional);

    <a href="shared_pseudocode.html#impl-shared.CheckExceptionCatch.1" title="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(TRUE);                  // Check for debug event on exception entry

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckAdvSIMDOrFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckAdvSIMDOrFPEnabled</h3>
      <p class="pseudocode">// AArch32.CheckAdvSIMDOrFPEnabled()
// =================================
// Check against CPACR, FPEXC, HCPTR, NSACR, and CPTR_EL3.

<a id="AArch32.CheckAdvSIMDOrFPEnabled.2"/>AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() || (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '0')) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        // The PE behaves as if FPEXC.EN is 1
        <a href="shared_pseudocode.html#AArch64.CheckFPEnabled.0" title="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</a>();
        <a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDEnabled.0" title="function: AArch64.CheckFPAdvSIMDEnabled()">AArch64.CheckFPAdvSIMDEnabled</a>();
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        if fpexc_check &amp;&amp; HCR_EL2.RW == '0' then
            fpexc_en = bits(1) IMPLEMENTATION_DEFINED "FPEXC.EN value when TGE==1 and RW==0";
            if fpexc_en == '0' then UNDEFINED;
        <a href="shared_pseudocode.html#AArch64.CheckFPEnabled.0" title="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</a>();
    else
        cpacr_asedis = CPACR.ASEDIS;
        cpacr_cp10 = CPACR.cp10;

        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
            // Check if access disabled in NSACR
            if NSACR.NSASEDIS == '1' then cpacr_asedis = '1';
            if NSACR.cp10 == '0' then cpacr_cp10 = '00';

        if PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            // Check if Advanced SIMD disabled in CPACR
            if advsimd &amp;&amp; cpacr_asedis == '1' then UNDEFINED;

            // Check if access disabled in CPACR
            boolean disabled;
            case cpacr_cp10 of
                when '00' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
                when '10' disabled = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_RESCPACR" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESCPACR</a>);
                when '11' disabled = FALSE;
            if disabled then UNDEFINED;

        // If required, check FPEXC enabled bit.
        if fpexc_check &amp;&amp; FPEXC.EN == '0' then UNDEFINED;

        <a href="shared_pseudocode.html#AArch32.CheckFPAdvSIMDTrap.1" title="function: AArch32.CheckFPAdvSIMDTrap(boolean advsimd)">AArch32.CheckFPAdvSIMDTrap</a>(advsimd);    // Also check against HCPTR and CPTR_EL3</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckFPAdvSIMDTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckFPAdvSIMDTrap</h3>
      <p class="pseudocode">// AArch32.CheckFPAdvSIMDTrap()
// ============================
// Check against CPTR_EL2 and CPTR_EL3.

<a id="AArch32.CheckFPAdvSIMDTrap.1"/>AArch32.CheckFPAdvSIMDTrap(boolean advsimd)
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        <a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDTrap.0" title="function: AArch64.CheckFPAdvSIMDTrap()">AArch64.CheckFPAdvSIMDTrap</a>();
    else
        if (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp;
            CPTR_EL3.TFP == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>()) then
            UNDEFINED;

        ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; ss != <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
            hcptr_tase = HCPTR.TASE;
            hcptr_cp10 = HCPTR.TCP10;

            if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
                // Check if access disabled in NSACR
                if NSACR.NSASEDIS == '1' then hcptr_tase = '1';
                if NSACR.cp10 == '0' then hcptr_cp10 = '1';

            // Check if access disabled in HCPTR
            if (advsimd &amp;&amp; hcptr_tase == '1') || hcptr_cp10 == '1' then
                exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
                exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();

                if advsimd then
                    exception.syndrome&lt;5&gt; = '1';
                else
                    exception.syndrome&lt;5&gt; = '0';
                    exception.syndrome&lt;3:0&gt; = '1010';         // coproc field, always 0xA

                if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
                    <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.1" title="function: AArch32.TakeUndefInstrException(ExceptionRecord exception)">AArch32.TakeUndefInstrException</a>(exception);
                else
                    <a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);

        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            // Check if access disabled in CPTR_EL3
            if CPTR_EL3.TFP == '1' then
                if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
                    UNDEFINED;
                else
                    <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckForSMCUndefOrTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckForSMCUndefOrTrap</h3>
      <p class="pseudocode">// AArch32.CheckForSMCUndefOrTrap()
// ================================
// Check for UNDEFINED or trap on SMC instruction

<a id="AArch32.CheckForSMCUndefOrTrap.0"/>AArch32.CheckForSMCUndefOrTrap()
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        UNDEFINED;

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        <a href="shared_pseudocode.html#AArch64.CheckForSMCUndefOrTrap.1" title="function: AArch64.CheckForSMCUndefOrTrap(bits(16) imm)">AArch64.CheckForSMCUndefOrTrap</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16));
    else
        route_to_hyp = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; HCR.TSC == '1';
        if route_to_hyp then
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>);
            <a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckForSVCTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckForSVCTrap</h3>
      <p class="pseudocode">// AArch32.CheckForSVCTrap()
// =========================
// Check for trap on SVC instruction

<a id="AArch32.CheckForSVCTrap.1"/>AArch32.CheckForSVCTrap(bits(16) immediate)
    if <a href="shared_pseudocode.html#impl-shared.HaveFGTExt.0" title="function: boolean HaveFGTExt()">HaveFGTExt</a>() then
        route_to_el2 = FALSE;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            route_to_el2 = (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HFGITR_EL2.SVC_EL0 == '1' &amp;&amp;
                           (HCR_EL2.&lt;E2H, TGE&gt; != '11' &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.FGTEn == '1')));

        if route_to_el2 then
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>);
            exception.syndrome&lt;15:0&gt; = immediate;
            exception.trappedsyscallinst = TRUE;
            bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
            vect_offset = 0x0;

            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckForWFxTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckForWFxTrap</h3>
      <p class="pseudocode">// AArch32.CheckForWFxTrap()
// =========================
// Check for trap on WFE or WFI instruction

<a id="AArch32.CheckForWFxTrap.2"/>AArch32.CheckForWFxTrap(bits(2) target_el, <a href="shared_pseudocode.html#WFxType" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el);

    // Check for routing to AArch64
    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) then
        <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(target_el, wfxtype);
        return;

    boolean is_wfe = wfxtype == <a href="shared_pseudocode.html#WFxType_WFE" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</a>;
    boolean trap;
    case target_el of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            trap = (if is_wfe then SCTLR.nTWE else SCTLR.nTWI) == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            trap = (if is_wfe then HCR.TWE else HCR.TWI) == '1';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            trap = (if is_wfe then SCR.TWE else SCR.TWI) == '1';

    if trap then
        if target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '1' then
            <a href="shared_pseudocode.html#AArch64.WFxTrap.2" title="function: AArch64.WFxTrap(WFxType wfxtype, bits(2) target_el)">AArch64.WFxTrap</a>(wfxtype, target_el);

        if target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            <a href="shared_pseudocode.html#AArch32.TakeMonitorTrapException.0" title="function: AArch32.TakeMonitorTrapException()">AArch32.TakeMonitorTrapException</a>();
        elsif target_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>);
            exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();

            case wfxtype of
                when <a href="shared_pseudocode.html#WFxType_WFI" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFI</a>
                    exception.syndrome&lt;0&gt; = '0';
                when <a href="shared_pseudocode.html#WFxType_WFE" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</a>
                    exception.syndrome&lt;0&gt; = '1';

            <a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);
        else
            <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckITEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckITEnabled</h3>
      <p class="pseudocode">// AArch32.CheckITEnabled()
// ========================
// Check whether the T32 IT instruction is disabled.

<a id="AArch32.CheckITEnabled.1"/>AArch32.CheckITEnabled(bits(4) mask)
    bit it_disabled;
    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        it_disabled = HSCTLR.ITD;
    else
        it_disabled = (if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then SCTLR.ITD else SCTLR[].ITD);
    if it_disabled == '1' then
        if mask != '1000' then UNDEFINED;

        accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescIFetch.0" title="function: AccessDescriptor CreateAccDescIFetch()">CreateAccDescIFetch</a>();
        aligned = TRUE;
        // Otherwise whether the IT block is allowed depends on hw1 of the next instruction.
        next_instr = <a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned]">AArch32.MemSingle</a>[<a href="shared_pseudocode.html#impl-shared.NextInstrAddr.1" title="function: bits(N) NextInstrAddr(integer N)">NextInstrAddr</a>(32), 2, accdesc, aligned];

        if next_instr IN {'11xxxxxxxxxxxxxx', '1011xxxxxxxxxxxx', '10100xxxxxxxxxxx',
                          '01001xxxxxxxxxxx', '010001xxx1111xxx', '010001xx1xxxx111'} then
            // It is IMPLEMENTATION DEFINED whether the Undefined Instruction exception is
            // taken on the IT instruction or the next instruction. This is not reflected in
            // the pseudocode, which always takes the exception on the IT instruction. This
            // also does not take into account cases where the next instruction is UNPREDICTABLE.
            UNDEFINED;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckIllegalState"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckIllegalState</h3>
      <p class="pseudocode">// AArch32.CheckIllegalState()
// ===========================
// Check PSTATE.IL bit and generate Illegal Execution state exception if set.

<a id="AArch32.CheckIllegalState.0"/>AArch32.CheckIllegalState()
    if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then
        <a href="shared_pseudocode.html#AArch64.CheckIllegalState.0" title="function: AArch64.CheckIllegalState()">AArch64.CheckIllegalState</a>();
    elsif PSTATE.IL == '1' then
        route_to_hyp = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR.TGE == '1';

        bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);
        vect_offset = 0x04;

        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>);
            if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
                <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
            else
                <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
        else
            <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckSETENDEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckSETENDEnabled</h3>
      <p class="pseudocode">// AArch32.CheckSETENDEnabled()
// ============================
// Check whether the AArch32 SETEND instruction is disabled.

<a id="AArch32.CheckSETENDEnabled.0"/>AArch32.CheckSETENDEnabled()
    bit setend_disabled;
    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        setend_disabled = HSCTLR.SED;
    else
        setend_disabled = (if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then SCTLR.SED else SCTLR[].SED);
    if setend_disabled == '1' then
        UNDEFINED;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.SystemAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.SystemAccessTrap</h3>
      <p class="pseudocode">// AArch32.SystemAccessTrap()
// ==========================
// Trapped  System register access.

<a id="AArch32.SystemAccessTrap.2"/>AArch32.SystemAccessTrap(bits(5) mode, integer ec)
    (valid, target_el) = <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(mode);
    assert valid &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; target_el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    if target_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        exception = <a href="shared_pseudocode.html#AArch32.SystemAccessTrapSyndrome.2" title="function: ExceptionRecord AArch32.SystemAccessTrapSyndrome(bits(32) instr, integer ec)">AArch32.SystemAccessTrapSyndrome</a>(<a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>(), ec);
        <a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);
    else
        <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.SystemAccessTrapSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.SystemAccessTrapSyndrome</h3>
      <p class="pseudocode">// AArch32.SystemAccessTrapSyndrome()
// ==================================
// Returns the syndrome information for traps on AArch32 MCR, MCRR, MRC, MRRC, and VMRS, VMSR instructions,
// other than traps that are due to HCPTR or CPACR.

ExceptionRecord <a id="AArch32.SystemAccessTrapSyndrome.2"/>AArch32.SystemAccessTrapSyndrome(bits(32) instr, integer ec)
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;

    case ec of
        when 0x0    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
        when 0x3    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>);
        when 0x4    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>);
        when 0x5    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>);
        when 0x6    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>);
        when 0x7    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
        when 0x8    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>);
        when 0xC    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>);
        otherwise   <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    bits(20) iss = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(20);

    if exception.exceptype == <a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a> then
        return exception;
    elsif exception.exceptype IN {<a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>, <a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>, <a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>} then
        // Trapped MRC/MCR, VMRS on FPSID
        iss&lt;13:10&gt; = instr&lt;19:16&gt;;        // CRn, Reg in case of VMRS
        iss&lt;8:5&gt;   = instr&lt;15:12&gt;;        // Rt
        iss&lt;9&gt;     = '0';                 // RES0

        if exception.exceptype != <a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a> then    // When trap is not for VMRS
            iss&lt;19:17&gt; = instr&lt;7:5&gt;;          // opc2
            iss&lt;16:14&gt; = instr&lt;23:21&gt;;        // opc1
            iss&lt;4:1&gt;   = instr&lt;3:0&gt;;          //CRm
        else //VMRS Access
            iss&lt;19:17&gt; = '000';               //opc2 - Hardcoded for VMRS
            iss&lt;16:14&gt; = '111';               //opc1 - Hardcoded for VMRS
            iss&lt;4:1&gt;   = '0000';              //CRm  - Hardcoded for VMRS
    elsif exception.exceptype IN {<a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>, <a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>, <a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>} then
        // Trapped MRRC/MCRR, VMRS/VMSR
        iss&lt;19:16&gt; = instr&lt;7:4&gt;;          // opc1
        iss&lt;13:10&gt; = instr&lt;19:16&gt;;        // Rt2
        iss&lt;8:5&gt; = instr&lt;15:12&gt;;          // Rt
        iss&lt;4:1&gt;   = instr&lt;3:0&gt;;         // CRm
    elsif exception.exceptype == <a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a> then
        // Trapped LDC/STC
        iss&lt;19:12&gt; = instr&lt;7:0&gt;;         // imm8
        iss&lt;4&gt;     = instr&lt;23&gt;;          // U
        iss&lt;2:1&gt;   = instr&lt;24,21&gt;;       // P,W
        if instr&lt;19:16&gt; == '1111' then   // Rn==15, LDC(Literal addressing)/STC
            iss&lt;8:5&gt; = bits(4) UNKNOWN;
            iss&lt;3&gt;   = '1';
    iss&lt;0&gt; = instr&lt;20&gt;;                  // Direction

    exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
    exception.syndrome&lt;19:0&gt;  = iss;

    return exception;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.TakeHypTrapException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.TakeHypTrapException</h3>
      <p class="pseudocode">// AArch32.TakeHypTrapException()
// ==============================
// Exceptions routed to Hyp mode as a Hyp Trap exception.

<a id="AArch32.TakeHypTrapException.1"/>AArch32.TakeHypTrapException(integer ec)
    exception = <a href="shared_pseudocode.html#AArch32.SystemAccessTrapSyndrome.2" title="function: ExceptionRecord AArch32.SystemAccessTrapSyndrome(bits(32) instr, integer ec)">AArch32.SystemAccessTrapSyndrome</a>(<a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>(), ec);
    <a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);

// AArch32.TakeHypTrapException()
// ==============================
// Exceptions routed to Hyp mode as a Hyp Trap exception.

<a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);
    vect_offset = 0x14;

    <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.TakeMonitorTrapException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.TakeMonitorTrapException</h3>
      <p class="pseudocode">// AArch32.TakeMonitorTrapException()
// ==================================
// Exceptions routed to Monitor mode as a Monitor Trap exception.

<a id="AArch32.TakeMonitorTrapException.0"/>AArch32.TakeMonitorTrapException()
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);
    vect_offset = 0x04;
    lr_offset = if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then 4 else 2;

    <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.TakeUndefInstrException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.TakeUndefInstrException</h3>
      <p class="pseudocode">// AArch32.TakeUndefInstrException()
// =================================

<a id="AArch32.TakeUndefInstrException.0"/>AArch32.TakeUndefInstrException()
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
    <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.1" title="function: AArch32.TakeUndefInstrException(ExceptionRecord exception)">AArch32.TakeUndefInstrException</a>(exception);

// AArch32.TakeUndefInstrException()
// =================================

<a id="AArch32.TakeUndefInstrException.1"/>AArch32.TakeUndefInstrException(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception)

    route_to_hyp = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR.TGE == '1';
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(32);
    vect_offset = 0x04;
    lr_offset = if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then 4 else 2;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    elsif route_to_hyp then
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.UndefinedFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.UndefinedFault</h3>
      <p class="pseudocode">// AArch32.UndefinedFault()
// ========================

<a id="AArch32.UndefinedFault.0"/>AArch32.UndefinedFault()

    if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then <a href="shared_pseudocode.html#AArch64.UndefinedFault.0" title="function: AArch64.UndefinedFault()">AArch64.UndefinedFault</a>();
    <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.functions.aborts.AArch32.DomainValid"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32.DomainValid</h3>
      <p class="pseudocode">// AArch32.DomainValid()
// =====================
// Returns TRUE if the Domain is valid for a Short-descriptor translation scheme.

boolean <a id="AArch32.DomainValid.2"/>AArch32.DomainValid(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode, integer level)
    assert statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    case statuscode of
        when <a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a>
            return TRUE;
        when <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>, <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>, <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>, <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>
            return level == 2;
        otherwise
            return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.aborts.AArch32.FaultSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32.FaultSyndrome</h3>
      <p class="pseudocode">// AArch32.FaultSyndrome()
// =======================
// Creates an exception syndrome value for Abort and Watchpoint exceptions taken to
// AArch32 Hyp mode.

bits(25) <a id="AArch32.FaultSyndrome.2"/>AArch32.FaultSyndrome(boolean d_side, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    assert fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    bits(25) iss  = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(25);
    bits(24) iss2 = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24);

    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault) then
        <a href="shared_pseudocode.html#ErrorState" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState</a> errstate = <a href="shared_pseudocode.html#AArch32.PEErrorState.1" title="function: ErrorState AArch32.PEErrorState(FaultRecord fault)">AArch32.PEErrorState</a>(fault);
        iss&lt;11:10&gt; = <a href="shared_pseudocode.html#AArch32.EncodeAsyncErrorSyndrome.1" title="function: bits(2) AArch32.EncodeAsyncErrorSyndrome(ErrorState errorstate)">AArch32.EncodeAsyncErrorSyndrome</a>(errstate); // AET

    if d_side then
        if (<a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) &amp;&amp; !fault.s2fs1walk &amp;&amp;
            (!<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) ||
            (!<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; fault.access.acctype == <a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a> &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "ISV on second stage translation table walk"))) then
            iss&lt;24:14&gt; = <a href="shared_pseudocode.html#impl-shared.LSInstructionSyndrome.0" title="function: bits(11) LSInstructionSyndrome()">LSInstructionSyndrome</a>();

        if fault.access.acctype IN {<a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>, <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_AT" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_AT</a>} then
            iss&lt;8&gt; = '1';

        if fault.access.acctype IN {<a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>, <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_AT" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_AT</a>} then
            iss&lt;6&gt; = '1';
        elsif fault.statuscode IN {<a href="shared_pseudocode.html#Fault_HWUpdateAccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_HWUpdateAccessFlag</a>, <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>} then
            iss&lt;6&gt; = bit UNKNOWN;
        elsif fault.access.atomicop &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then
            iss&lt;6&gt; = bit UNKNOWN;
        else
            iss&lt;6&gt; = if fault.write then '1' else '0';

    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then iss&lt;9&gt; = fault.extflag;
    iss&lt;7&gt; = if fault.s2fs1walk then '1' else '0';
    iss&lt;5:0&gt; = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);

    return (iss);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.aborts.EncodeSDFSC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/EncodeSDFSC</h3>
      <p class="pseudocode">// EncodeSDFSC()
// =============
// Function that gives the Short-descriptor FSR code for different types of Fault

bits(5) <a id="impl-aarch32.EncodeSDFSC.2"/>EncodeSDFSC(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode, integer level)

    bits(5) result;
    case statuscode of
        when <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>
            assert level IN {1,2};
            result = if level == 1 then '00011' else '00110';
        when <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>
            result = '00001';
        when <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>
            assert level IN {1,2};
            result = if level == 1 then '01101' else '01111';
        when <a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a>
            assert level IN {1,2};
            result = if level == 1 then '01001' else '01011';
        when <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>
            assert level IN {1,2};
            result = if level == 1 then '00101' else '00111';
        when <a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>
            result = '01000';
        when <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>
            assert level IN {1,2};
            result = if level == 1 then '01100' else '01110';
        when <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>
            result = '11001';
        when <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>
            assert level IN {1,2};
            result = if level == 1 then '11100' else '11110';
        when <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>
            result = '11000';
        when <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>
            result = '10110';
        when <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>
            result = '00010';
        when <a href="shared_pseudocode.html#Fault_TLBConflict" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_TLBConflict</a>
            result = '10000';
        when <a href="shared_pseudocode.html#Fault_Lockdown" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Lockdown</a>
            result = '10100';   // IMPLEMENTATION DEFINED
        when <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>
            result = '10101';   // IMPLEMENTATION DEFINED
        when <a href="shared_pseudocode.html#Fault_ICacheMaint" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_ICacheMaint</a>
            result = '00100';
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.A32ExpandImm"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/A32ExpandImm</h3>
      <p class="pseudocode">// A32ExpandImm()
// ==============

bits(32) <a id="impl-aarch32.A32ExpandImm.1"/>A32ExpandImm(bits(12) imm12)

    // PSTATE.C argument to following function call does not affect the imm32 result.
    (imm32, -) = <a href="shared_pseudocode.html#impl-aarch32.A32ExpandImm_C.2" title="function: (bits(32), bit) A32ExpandImm_C(bits(12) imm12, bit carry_in)">A32ExpandImm_C</a>(imm12, PSTATE.C);

    return imm32;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.A32ExpandImm_C"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/A32ExpandImm_C</h3>
      <p class="pseudocode">// A32ExpandImm_C()
// ================

(bits(32), bit) <a id="impl-aarch32.A32ExpandImm_C.2"/>A32ExpandImm_C(bits(12) imm12, bit carry_in)

    unrotated_value = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(imm12&lt;7:0&gt;, 32);
    (imm32, carry_out) = <a href="shared_pseudocode.html#impl-aarch32.Shift_C.4" title="function: (bits(N), bit) Shift_C(bits(N) value, SRType srtype, integer amount, bit carry_in)">Shift_C</a>(unrotated_value, <a href="shared_pseudocode.html#SRType_ROR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>, 2*<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm12&lt;11:8&gt;), carry_in);

    return (imm32, carry_out);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.DecodeImmShift"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/DecodeImmShift</h3>
      <p class="pseudocode">// DecodeImmShift()
// ================

(SRType, integer) <a id="impl-aarch32.DecodeImmShift.2"/>DecodeImmShift(bits(2) srtype, bits(5) imm5)

    <a href="shared_pseudocode.html#SRType" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</a> shift_t;
    integer shift_n;
    case srtype of
        when '00'
            shift_t = <a href="shared_pseudocode.html#SRType_LSL" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>;  shift_n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm5);
        when '01'
            shift_t = <a href="shared_pseudocode.html#SRType_LSR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</a>;  shift_n = if imm5 == '00000' then 32 else <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm5);
        when '10'
            shift_t = <a href="shared_pseudocode.html#SRType_ASR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</a>;  shift_n = if imm5 == '00000' then 32 else <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm5);
        when '11'
            if imm5 == '00000' then
                shift_t = <a href="shared_pseudocode.html#SRType_RRX" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</a>;  shift_n = 1;
            else
                shift_t = <a href="shared_pseudocode.html#SRType_ROR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>;  shift_n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm5);

    return (shift_t, shift_n);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.DecodeRegShift"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/DecodeRegShift</h3>
      <p class="pseudocode">// DecodeRegShift()
// ================

SRType <a id="impl-aarch32.DecodeRegShift.1"/>DecodeRegShift(bits(2) srtype)
    <a href="shared_pseudocode.html#SRType" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</a> shift_t;
    case srtype of
        when '00'  shift_t = <a href="shared_pseudocode.html#SRType_LSL" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>;
        when '01'  shift_t = <a href="shared_pseudocode.html#SRType_LSR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</a>;
        when '10'  shift_t = <a href="shared_pseudocode.html#SRType_ASR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</a>;
        when '11'  shift_t = <a href="shared_pseudocode.html#SRType_ROR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>;
    return shift_t;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.RRX"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/RRX</h3>
      <p class="pseudocode">// RRX()
// =====

bits(N) <a id="impl-aarch32.RRX.2"/>RRX(bits(N) x, bit carry_in)
    (result, -) = <a href="shared_pseudocode.html#impl-aarch32.RRX_C.2" title="function: (bits(N), bit) RRX_C(bits(N) x, bit carry_in)">RRX_C</a>(x, carry_in);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.RRX_C"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/RRX_C</h3>
      <p class="pseudocode">// RRX_C()
// =======

(bits(N), bit) <a id="impl-aarch32.RRX_C.2"/>RRX_C(bits(N) x, bit carry_in)
    result = carry_in : x&lt;N-1:1&gt;;
    carry_out = x&lt;0&gt;;
    return (result, carry_out);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.SRType"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/SRType</h3>
      <p class="pseudocode">enumeration <a id="SRType"/>SRType {<a id="SRType_LSL"/>SRType_LSL, <a id="SRType_LSR"/>SRType_LSR, <a id="SRType_ASR"/>SRType_ASR, <a id="SRType_ROR"/>SRType_ROR, <a id="SRType_RRX"/>SRType_RRX};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.Shift"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/Shift</h3>
      <p class="pseudocode">// Shift()
// =======

bits(N) <a id="impl-aarch32.Shift.4"/>Shift(bits(N) value, <a href="shared_pseudocode.html#SRType" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</a> srtype, integer amount, bit carry_in)
    (result, -) = <a href="shared_pseudocode.html#impl-aarch32.Shift_C.4" title="function: (bits(N), bit) Shift_C(bits(N) value, SRType srtype, integer amount, bit carry_in)">Shift_C</a>(value, srtype, amount, carry_in);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.Shift_C"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/Shift_C</h3>
      <p class="pseudocode">// Shift_C()
// =========

(bits(N), bit) <a id="impl-aarch32.Shift_C.4"/>Shift_C(bits(N) value, <a href="shared_pseudocode.html#SRType" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</a> srtype, integer amount, bit carry_in)
    assert !(srtype == <a href="shared_pseudocode.html#SRType_RRX" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</a> &amp;&amp; amount != 1);

    bits(N) result;
    bit carry_out;
    if amount == 0 then
        (result, carry_out) = (value, carry_in);
    else
        case srtype of
            when <a href="shared_pseudocode.html#SRType_LSL" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-shared.LSL_C.2" title="function: (bits(N), bit) LSL_C(bits(N) x, integer shift)">LSL_C</a>(value, amount);
            when <a href="shared_pseudocode.html#SRType_LSR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-shared.LSR_C.2" title="function: (bits(N), bit) LSR_C(bits(N) x, integer shift)">LSR_C</a>(value, amount);
            when <a href="shared_pseudocode.html#SRType_ASR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-shared.ASR_C.2" title="function: (bits(N), bit) ASR_C(bits(N) x, integer shift)">ASR_C</a>(value, amount);
            when <a href="shared_pseudocode.html#SRType_ROR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-shared.ROR_C.2" title="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)">ROR_C</a>(value, amount);
            when <a href="shared_pseudocode.html#SRType_RRX" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-aarch32.RRX_C.2" title="function: (bits(N), bit) RRX_C(bits(N) x, bit carry_in)">RRX_C</a>(value, carry_in);

    return (result, carry_out);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.T32ExpandImm"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/T32ExpandImm</h3>
      <p class="pseudocode">// T32ExpandImm()
// ==============

bits(32) <a id="impl-aarch32.T32ExpandImm.1"/>T32ExpandImm(bits(12) imm12)

    // PSTATE.C argument to following function call does not affect the imm32 result.
    (imm32, -) = <a href="shared_pseudocode.html#impl-aarch32.T32ExpandImm_C.2" title="function: (bits(32), bit) T32ExpandImm_C(bits(12) imm12, bit carry_in)">T32ExpandImm_C</a>(imm12, PSTATE.C);

    return imm32;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.T32ExpandImm_C"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/T32ExpandImm_C</h3>
      <p class="pseudocode">// T32ExpandImm_C()
// ================

(bits(32), bit) <a id="impl-aarch32.T32ExpandImm_C.2"/>T32ExpandImm_C(bits(12) imm12, bit carry_in)
    bits(32) imm32;
    bit carry_out;
    if imm12&lt;11:10&gt; == '00' then
        case imm12&lt;9:8&gt; of
            when '00'
                imm32 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(imm12&lt;7:0&gt;, 32);
            when '01'
                imm32 = '00000000' : imm12&lt;7:0&gt; : '00000000' : imm12&lt;7:0&gt;;
            when '10'
                imm32 = imm12&lt;7:0&gt; : '00000000' : imm12&lt;7:0&gt; : '00000000';
            when '11'
                imm32 = imm12&lt;7:0&gt; : imm12&lt;7:0&gt; : imm12&lt;7:0&gt; : imm12&lt;7:0&gt;;
        carry_out = carry_in;
    else
        unrotated_value = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>('1':imm12&lt;6:0&gt;, 32);
        (imm32, carry_out) = <a href="shared_pseudocode.html#impl-shared.ROR_C.2" title="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)">ROR_C</a>(unrotated_value, <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm12&lt;11:7&gt;));

    return (imm32, carry_out);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.VBitOps"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/VBitOps</h3>
      <p class="pseudocode">enumeration <a id="VBitOps"/>VBitOps {<a id="VBitOps_VBIF"/>VBitOps_VBIF, <a id="VBitOps_VBIT"/>VBitOps_VBIT, <a id="VBitOps_VBSL"/>VBitOps_VBSL};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.VCGEType"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/VCGEType</h3>
      <p class="pseudocode">enumeration <a id="VCGEType"/>VCGEType {<a id="VCGEType_signed"/>VCGEType_signed, <a id="VCGEType_unsigned"/>VCGEType_unsigned, <a id="VCGEType_fp"/>VCGEType_fp};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.VCGTtype"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/VCGTtype</h3>
      <p class="pseudocode">enumeration <a id="VCGTtype"/>VCGTtype {<a id="VCGTtype_signed"/>VCGTtype_signed, <a id="VCGTtype_unsigned"/>VCGTtype_unsigned, <a id="VCGTtype_fp"/>VCGTtype_fp};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.VFPNegMul"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/VFPNegMul</h3>
      <p class="pseudocode">enumeration <a id="VFPNegMul"/>VFPNegMul {<a id="VFPNegMul_VNMLA"/>VFPNegMul_VNMLA, <a id="VFPNegMul_VNMLS"/>VFPNegMul_VNMLS, <a id="VFPNegMul_VNMUL"/>VFPNegMul_VNMUL};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.coproc.AArch32.CheckCP15InstrCoarseTraps"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/coproc/AArch32.CheckCP15InstrCoarseTraps</h3>
      <p class="pseudocode">// AArch32.CheckCP15InstrCoarseTraps()
// ===================================
// Check for coarse-grained  traps to System registers in the
// coproc=0b1111 encoding space by HSTR and HCR.

<a id="AArch32.CheckCP15InstrCoarseTraps.3"/>AArch32.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) ||
            (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>))) then
        <a href="shared_pseudocode.html#AArch64.CheckCP15InstrCoarseTraps.3" title="function: AArch64.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)">AArch64.CheckCP15InstrCoarseTraps</a>(CRn, nreg, CRm);

    trapped_encoding = ((CRn == 9  &amp;&amp; CRm IN {0,1,2,    5,6,7,8   }) ||
                        (CRn == 10 &amp;&amp; CRm IN {0,1,    4,      8   }) ||
                        (CRn == 11 &amp;&amp; CRm IN {0,1,2,3,4,5,6,7,8,15}));

    // Check for coarse-grained Hyp traps
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        major = if nreg == 1 then CRn else CRm;
        // Check for MCR, MRC, MCRR, and MRRC disabled by HSTR&lt;CRn/CRm&gt;
        // and MRC and MCR disabled by HCR.TIDCP.
        if ((!(major IN {4,14}) &amp;&amp; HSTR&lt;major&gt; == '1') ||
                (HCR.TIDCP == '1' &amp;&amp; nreg == 1 &amp;&amp; trapped_encoding)) then
            if (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp;
                    boolean IMPLEMENTATION_DEFINED "UNDEF unallocated CP15 access at <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>") then
                UNDEFINED;
            if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
                <a href="shared_pseudocode.html#AArch32.SystemAccessTrap.2" title="function: AArch32.SystemAccessTrap(bits(5) mode, integer ec)">AArch32.SystemAccessTrap</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>, 0x3);
            else
                <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, 0x3);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.exclusive.AArch32.ExclusiveMonitorsPass"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/exclusive/AArch32.ExclusiveMonitorsPass</h3>
      <p class="pseudocode">// AArch32.ExclusiveMonitorsPass()
// ===============================
// Return TRUE if the Exclusives monitors for the current PE include all of the addresses
// associated with the virtual address region of size bytes starting at address.
// The immediately following memory write must be to the same addresses.

boolean <a id="AArch32.ExclusiveMonitorsPass.2"/>AArch32.ExclusiveMonitorsPass(bits(32) address, integer size)

    // It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
    // before or after the check on the local Exclusives monitor. As a result a failure
    // of the local monitor can occur on some implementations even if the memory
    // access would give an memory abort.
    boolean acqrel = FALSE;
    boolean tagchecked = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescExLDST.3" title="function: AccessDescriptor CreateAccDescExLDST(MemOp memop, boolean acqrel, boolean tagchecked)">CreateAccDescExLDST</a>(<a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>, acqrel, tagchecked);
    boolean aligned = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, size);

    if !aligned then
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    if !<a href="shared_pseudocode.html#AArch32.IsExclusiveVA.3" title="function: boolean AArch32.IsExclusiveVA(bits(32) address, integer processorid, integer size)">AArch32.IsExclusiveVA</a>(address, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size) then
        return FALSE;

    memaddrdesc = <a href="shared_pseudocode.html#AArch32.TranslateAddress.4" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch32.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, memaddrdesc.fault);

    passed = <a href="shared_pseudocode.html#impl-shared.IsExclusiveLocal.3" title="function: boolean IsExclusiveLocal(FullAddress paddress, integer processorid, integer size)">IsExclusiveLocal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>());

    if passed &amp;&amp; memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        passed = <a href="shared_pseudocode.html#impl-shared.IsExclusiveGlobal.3" title="function: boolean IsExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">IsExclusiveGlobal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    return passed;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.exclusive.AArch32.IsExclusiveVA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/exclusive/AArch32.IsExclusiveVA</h3>
      <p class="pseudocode">// An optional IMPLEMENTATION DEFINED test for an exclusive access to a virtual
// address region of size bytes starting at address.
//
// It is permitted (but not required) for this function to return FALSE and
// cause a store exclusive to fail if the virtual address region is not
// totally included within the region recorded by MarkExclusiveVA().
//
// It is always safe to return TRUE which will check the physical address only.
boolean <a id="AArch32.IsExclusiveVA.3"/>AArch32.IsExclusiveVA(bits(32) address, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.exclusive.AArch32.MarkExclusiveVA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/exclusive/AArch32.MarkExclusiveVA</h3>
      <p class="pseudocode">// Optionally record an exclusive access to the virtual address region of size bytes
// starting at address for processorid.
<a id="AArch32.MarkExclusiveVA.3"/>AArch32.MarkExclusiveVA(bits(32) address, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.exclusive.AArch32.SetExclusiveMonitors"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/exclusive/AArch32.SetExclusiveMonitors</h3>
      <p class="pseudocode">// AArch32.SetExclusiveMonitors()
// ==============================
// Sets the Exclusives monitors for the current PE to record the addresses associated
// with the virtual address region of size bytes starting at address.

<a id="AArch32.SetExclusiveMonitors.2"/>AArch32.SetExclusiveMonitors(bits(32) address, integer size)
    boolean acqrel = FALSE;
    boolean tagchecked = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescExLDST.3" title="function: AccessDescriptor CreateAccDescExLDST(MemOp memop, boolean acqrel, boolean tagchecked)">CreateAccDescExLDST</a>(<a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>, acqrel, tagchecked);
    boolean aligned = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, size);

    if !aligned then
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    memaddrdesc = <a href="shared_pseudocode.html#AArch32.TranslateAddress.4" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch32.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        return;

    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.MarkExclusiveGlobal.3" title="function: MarkExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveGlobal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a href="shared_pseudocode.html#impl-shared.MarkExclusiveLocal.3" title="function: MarkExclusiveLocal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveLocal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a href="shared_pseudocode.html#AArch32.MarkExclusiveVA.3" title="function: AArch32.MarkExclusiveVA(bits(32) address, integer processorid, integer size)">AArch32.MarkExclusiveVA</a>(address, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.CheckAdvSIMDEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/CheckAdvSIMDEnabled</h3>
      <p class="pseudocode">// CheckAdvSIMDEnabled()
// =====================

<a id="impl-aarch32.CheckAdvSIMDEnabled.0"/>CheckAdvSIMDEnabled()

    fpexc_check = TRUE;
    advsimd = TRUE;

    <a href="shared_pseudocode.html#AArch32.CheckAdvSIMDOrFPEnabled.2" title="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)">AArch32.CheckAdvSIMDOrFPEnabled</a>(fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if Advanced SIMD access is permitted

    // Make temporary copy of D registers
    // _Dclone[] is used as input data for instruction pseudocode
    for i = 0 to 31
        _Dclone[i] = <a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[i];

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.CheckAdvSIMDOrVFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/CheckAdvSIMDOrVFPEnabled</h3>
      <p class="pseudocode">// CheckAdvSIMDOrVFPEnabled()
// ==========================

<a id="impl-aarch32.CheckAdvSIMDOrVFPEnabled.2"/>CheckAdvSIMDOrVFPEnabled(boolean include_fpexc_check, boolean advsimd)
    <a href="shared_pseudocode.html#AArch32.CheckAdvSIMDOrFPEnabled.2" title="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)">AArch32.CheckAdvSIMDOrFPEnabled</a>(include_fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if VFP access is permitted
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.CheckCryptoEnabled32"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/CheckCryptoEnabled32</h3>
      <p class="pseudocode">// CheckCryptoEnabled32()
// ======================

<a id="impl-aarch32.CheckCryptoEnabled32.0"/>CheckCryptoEnabled32()
    <a href="shared_pseudocode.html#impl-aarch32.CheckAdvSIMDEnabled.0" title="function: CheckAdvSIMDEnabled()">CheckAdvSIMDEnabled</a>();
    // Return from CheckAdvSIMDEnabled() occurs only if access is permitted
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.CheckVFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/CheckVFPEnabled</h3>
      <p class="pseudocode">// CheckVFPEnabled()
// =================

<a id="impl-aarch32.CheckVFPEnabled.1"/>CheckVFPEnabled(boolean include_fpexc_check)
    advsimd = FALSE;
    <a href="shared_pseudocode.html#AArch32.CheckAdvSIMDOrFPEnabled.2" title="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)">AArch32.CheckAdvSIMDOrFPEnabled</a>(include_fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if VFP access is permitted
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.FPHalvedSub"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/FPHalvedSub</h3>
      <p class="pseudocode">// FPHalvedSub()
// =============

bits(N) <a id="impl-aarch32.FPHalvedSub.3"/>FPHalvedSub(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);  inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);     zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('0', N);
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('1', N);
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 != sign2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign1, N);
        else
            result_value = (value1 - value2) / 2.0;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(result_sign, N);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, integer N)">FPRound</a>(result_value, fpcr, N);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.FPRSqrtStep"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/FPRSqrtStep</h3>
      <p class="pseudocode">// FPRSqrtStep()
// =============

bits(N) <a id="impl-aarch32.FPRSqrtStep.2"/>FPRSqrtStep(bits(N) op1, bits(N) op2)
    assert N IN {16,32};
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = <a href="shared_pseudocode.html#impl-aarch32.StandardFPSCRValue.0" title="function: FPCRType StandardFPSCRValue()">StandardFPSCRValue</a>();
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);  inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);     zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        bits(N) product;
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            product = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>('0', N);
        else
            product = <a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</a>(op1, op2, fpcr);
        bits(N) three = <a href="shared_pseudocode.html#impl-shared.FPThree.2" title="function: bits(N) FPThree(bit sign, integer N)">FPThree</a>('0', N);
        result = <a href="shared_pseudocode.html#impl-aarch32.FPHalvedSub.3" title="function: bits(N) FPHalvedSub(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPHalvedSub</a>(three, product, fpcr);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.FPRecipStep"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/FPRecipStep</h3>
      <p class="pseudocode">// FPRecipStep()
// =============

bits(N) <a id="impl-aarch32.FPRecipStep.2"/>FPRecipStep(bits(N) op1, bits(N) op2)
    assert N IN {16,32};
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = <a href="shared_pseudocode.html#impl-aarch32.StandardFPSCRValue.0" title="function: FPCRType StandardFPSCRValue()">StandardFPSCRValue</a>();
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);  inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);     zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        bits(N) product;
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            product = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>('0', N);
        else
            product = <a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</a>(op1, op2, fpcr);
        bits(N) two = <a href="shared_pseudocode.html#impl-shared.FPTwo.2" title="function: bits(N) FPTwo(bit sign, integer N)">FPTwo</a>('0', N);
        result = <a href="shared_pseudocode.html#impl-shared.FPSub.3" title="function: bits(N) FPSub(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPSub</a>(two, product, fpcr);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.StandardFPSCRValue"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/StandardFPSCRValue</h3>
      <p class="pseudocode">// StandardFPSCRValue()
// ====================

FPCRType <a id="impl-aarch32.StandardFPSCRValue.0"/>StandardFPSCRValue()
    bits(32) value = '00000' : FPSCR.AHP : '110000' : FPSCR.FZ16 : '0000000000000000000';
    return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, 64);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.AArch32.MemSingle"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/AArch32.MemSingle</h3>
      <p class="pseudocode">// AArch32.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8) <a id="AArch32.MemSingle.read.4"/>AArch32.MemSingle[bits(32) address, integer size,
                               <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, boolean aligned]
    boolean ispair = FALSE;
    return <a href="shared_pseudocode.html#AArch32.MemSingle.read.5" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair]">AArch32.MemSingle</a>[address, size, accdesc, aligned, ispair];

// AArch32.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8) <a id="AArch32.MemSingle.read.5"/>AArch32.MemSingle[bits(32) address, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in,
                               boolean aligned, boolean ispair]
    assert size IN {1, 2, 4, 8, 16};
    bits(size*8) value;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;
    assert <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, size);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    memaddrdesc = <a href="shared_pseudocode.html#AArch32.TranslateAddress.4" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch32.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, memaddrdesc.fault);

    // Memory array access
    <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
    (memstatus, value) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size, accdesc);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size, accdesc);
    return value;

// AArch32.MemSingle[] - assignment (write) form
// =============================================

<a id="AArch32.MemSingle.write.4"/>AArch32.MemSingle[bits(32) address, integer size,
                  <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, boolean aligned] = bits(size*8) value
    boolean ispair = FALSE;
    <a href="shared_pseudocode.html#AArch32.MemSingle.write.5" title="accessor: AArch32.MemSingle[bits(32) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair] = bits(size*8) value">AArch32.MemSingle</a>[address, size, accdesc, aligned, ispair] = value;
    return;

// AArch32.MemSingle[] - assignment (write) form
// =============================================
// Perform an atomic, little-endian write of 'size' bytes.

<a id="AArch32.MemSingle.write.5"/>AArch32.MemSingle[bits(32) address, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in,
                  boolean aligned, boolean ispair] = bits(size*8) value
    assert size IN {1, 2, 4, 8, 16};
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;
    assert <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, size);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    memaddrdesc = <a href="shared_pseudocode.html#AArch32.TranslateAddress.4" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch32.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
    memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size, accdesc, value);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size, accdesc);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.AArch32.UnalignedAccessFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/AArch32.UnalignedAccessFaults</h3>
      <p class="pseudocode">// AArch32.UnalignedAccessFaults()
// ===============================
// Determine whether the unaligned access generates an Alignment fault

boolean <a id="AArch32.UnalignedAccessFaults.1"/>AArch32.UnalignedAccessFaults(<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    return (<a href="shared_pseudocode.html#impl-shared.AlignmentEnforced.0" title="function: boolean AlignmentEnforced()">AlignmentEnforced</a>() ||
            accdesc.a32lsmd     ||
            accdesc.exclusive   ||
            accdesc.acqsc       ||
            accdesc.relsc);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.Hint_PreloadData"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/Hint_PreloadData</h3>
      <p class="pseudocode"><a id="impl-aarch32.Hint_PreloadData.1"/>Hint_PreloadData(bits(32) address);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.Hint_PreloadDataForWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/Hint_PreloadDataForWrite</h3>
      <p class="pseudocode"><a id="impl-aarch32.Hint_PreloadDataForWrite.1"/>Hint_PreloadDataForWrite(bits(32) address);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.Hint_PreloadInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/Hint_PreloadInstr</h3>
      <p class="pseudocode"><a id="impl-aarch32.Hint_PreloadInstr.1"/>Hint_PreloadInstr(bits(32) address);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemA</h3>
      <p class="pseudocode">// MemA[] - non-assignment form
// ============================

bits(8*size) <a id="impl-aarch32.MemA.read.2"/>MemA[bits(32) address, integer size]
    boolean acqrel = FALSE;
    boolean tagchecked = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescExLDST.3" title="function: AccessDescriptor CreateAccDescExLDST(MemOp memop, boolean acqrel, boolean tagchecked)">CreateAccDescExLDST</a>(<a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>, acqrel, tagchecked);
    return <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccessDescriptor accdesc]">Mem_with_type</a>[address, size, accdesc];

// MemA[] - assignment form
// ========================

<a id="impl-aarch32.MemA.write.2"/>MemA[bits(32) address, integer size] = bits(8*size) value
    boolean acqrel = FALSE;
    boolean tagchecked = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescExLDST.3" title="function: AccessDescriptor CreateAccDescExLDST(MemOp memop, boolean acqrel, boolean tagchecked)">CreateAccDescExLDST</a>(<a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>, acqrel, tagchecked);
    Mem_with_type[address, size, accdesc] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemO"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemO</h3>
      <p class="pseudocode">// MemO[] - non-assignment form
// ============================

bits(8*size) <a id="impl-aarch32.MemO.read.2"/>MemO[bits(32) address, integer size]
    boolean tagchecked = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescAcqRel.2" title="function: AccessDescriptor CreateAccDescAcqRel(MemOp memop, boolean tagchecked)">CreateAccDescAcqRel</a>(<a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>, tagchecked);
    return <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccessDescriptor accdesc]">Mem_with_type</a>[address, size, accdesc];

// MemO[] - assignment form
// ========================

<a id="impl-aarch32.MemO.write.2"/>MemO[bits(32) address, integer size] = bits(8*size) value
    boolean tagchecked = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescAcqRel.2" title="function: AccessDescriptor CreateAccDescAcqRel(MemOp memop, boolean tagchecked)">CreateAccDescAcqRel</a>(<a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>, tagchecked);
    Mem_with_type[address, size, accdesc] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemS"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemS</h3>
      <p class="pseudocode">// MemS[] - non-assignment form
// ============================
// Memory accessor for streaming load multiple instructions

bits(8*size) <a id="impl-aarch32.MemS.read.2"/>MemS[bits(32) address, integer size]
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescA32LSMD.1" title="function: AccessDescriptor CreateAccDescA32LSMD(MemOp memop)">CreateAccDescA32LSMD</a>(<a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>);
    return <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccessDescriptor accdesc]">Mem_with_type</a>[address, size, accdesc];

// MemS[] - assignment form
// ========================
// Memory accessor for streaming store multiple instructions

<a id="impl-aarch32.MemS.write.2"/>MemS[bits(32) address, integer size] = bits(8*size) value
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescA32LSMD.1" title="function: AccessDescriptor CreateAccDescA32LSMD(MemOp memop)">CreateAccDescA32LSMD</a>(<a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>);
    Mem_with_type[address, size, accdesc] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemU"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemU</h3>
      <p class="pseudocode">// MemU[] - non-assignment form
// ============================

bits(8*size) <a id="impl-aarch32.MemU.read.2"/>MemU[bits(32) address, integer size]
    boolean nontemporal = FALSE;
    boolean privileged = PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    boolean tagchecked = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescGPR.4" title="function: AccessDescriptor CreateAccDescGPR(MemOp memop, boolean nontemporal, boolean privileged,&#13; boolean tagchecked)">CreateAccDescGPR</a>(<a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>, nontemporal, privileged, tagchecked);
    return <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccessDescriptor accdesc]">Mem_with_type</a>[address, size, accdesc];

// MemU[] - assignment form
// ========================

<a id="impl-aarch32.MemU.write.2"/>MemU[bits(32) address, integer size] = bits(8*size) value
    boolean nontemporal = FALSE;
    boolean privileged = PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    boolean tagchecked = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescGPR.4" title="function: AccessDescriptor CreateAccDescGPR(MemOp memop, boolean nontemporal, boolean privileged,&#13; boolean tagchecked)">CreateAccDescGPR</a>(<a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>, nontemporal, privileged, tagchecked);
    Mem_with_type[address, size, accdesc] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemU_unpriv"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemU_unpriv</h3>
      <p class="pseudocode">// MemU_unpriv[] - non-assignment form
// ===================================

bits(8*size) <a id="impl-aarch32.MemU_unpriv.read.2"/>MemU_unpriv[bits(32) address, integer size]
    boolean nontemporal = FALSE;
    boolean privileged = FALSE;
    boolean tagchecked = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescGPR.4" title="function: AccessDescriptor CreateAccDescGPR(MemOp memop, boolean nontemporal, boolean privileged,&#13; boolean tagchecked)">CreateAccDescGPR</a>(<a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>, nontemporal, privileged, tagchecked);
    return <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccessDescriptor accdesc]">Mem_with_type</a>[address, size, accdesc];

// MemU_unpriv[] - assignment form
// ===============================

<a id="impl-aarch32.MemU_unpriv.write.2"/>MemU_unpriv[bits(32) address, integer size] = bits(8*size) value
    boolean nontemporal = FALSE;
    boolean privileged = FALSE;
    boolean tagchecked = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescGPR.4" title="function: AccessDescriptor CreateAccDescGPR(MemOp memop, boolean nontemporal, boolean privileged,&#13; boolean tagchecked)">CreateAccDescGPR</a>(<a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>, nontemporal, privileged, tagchecked);
    Mem_with_type[address, size, accdesc] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.Mem_with_type"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/Mem_with_type</h3>
      <p class="pseudocode">// Mem_with_type[] - non-assignment (read) form
// ============================================
// Perform a read of 'size' bytes. The access byte order is reversed for a big-endian access.
// Instruction fetches would call AArch32.MemSingle directly.

bits(size*8) <a id="impl-aarch32.Mem_with_type.read.3"/>Mem_with_type[bits(32) address, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc]
    boolean ispair = FALSE;
    return <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.4" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccessDescriptor accdesc, boolean ispair]">Mem_with_type</a>[address, size, accdesc, ispair];

bits(size*8) <a id="impl-aarch32.Mem_with_type.read.4"/>Mem_with_type[bits(32) address, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, boolean ispair]
    assert size IN {1, 2, 4, 8, 16};
    constant halfsize = size DIV 2;
    bits(size * 8) value;

    // Check alignment on size of element accessed, not overall access size
    integer alignment = if ispair then halfsize else size;
    boolean aligned   = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, alignment);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#AArch32.UnalignedAccessFaults.1" title="function: boolean AArch32.UnalignedAccessFaults(AccessDescriptor accdesc)">AArch32.UnalignedAccessFaults</a>(accdesc) then
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    if aligned then
        value = <a href="shared_pseudocode.html#AArch32.MemSingle.read.5" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair]">AArch32.MemSingle</a>[address, size, accdesc, aligned, ispair];
    else
        assert size &gt; 1;
        value&lt;7:0&gt; = <a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned]">AArch32.MemSingle</a>[address, 1, accdesc, aligned];

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_DEVPAGE2</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
        if c == <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

        for i = 1 to size-1
            value&lt;8*i+7:8*i&gt; = <a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned]">AArch32.MemSingle</a>[address+i, 1, accdesc, aligned];

    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccessType acctype)">BigEndian</a>(accdesc.acctype) then
        value = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    return value;

// Mem_with_type[] - assignment (write) form
// =========================================
// Perform a write of 'size' bytes. The byte order is reversed for a big-endian access.

Mem_with_type[bits(32) address, integer size, AccessDescriptor accdesc] = bits(size*8) value_in
    boolean ispair = FALSE;
    Mem_with_type[address, size, accdesc, ispair] = value_in;

Mem_with_type[bits(32) address, integer size, AccessDescriptor accdesc,
        boolean ispair] = bits(size*8) value_in
    constant halfsize = size DIV 2;
    bits(size*8) value = value_in;

    // Check alignment on size of element accessed, not overall access size
    integer alignment = if ispair then halfsize else size;
    boolean aligned   = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, alignment);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#AArch32.UnalignedAccessFaults.1" title="function: boolean AArch32.UnalignedAccessFaults(AccessDescriptor accdesc)">AArch32.UnalignedAccessFaults</a>(accdesc) then
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccessType acctype)">BigEndian</a>(accdesc.acctype) then
        value = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    if aligned then
        <a href="shared_pseudocode.html#AArch32.MemSingle.write.5" title="accessor: AArch32.MemSingle[bits(32) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair] = bits(size*8) value">AArch32.MemSingle</a>[address, size, accdesc, aligned, ispair] = value;
    else
        assert size &gt; 1;
        <a href="shared_pseudocode.html#AArch32.MemSingle.write.4" title="accessor: AArch32.MemSingle[bits(32) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned] = bits(size*8) value">AArch32.MemSingle</a>[address, 1, accdesc, aligned] = value&lt;7:0&gt;;

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.

        c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_DEVPAGE2</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
        if c == <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

        for i = 1 to size-1
            <a href="shared_pseudocode.html#AArch32.MemSingle.write.4" title="accessor: AArch32.MemSingle[bits(32) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned] = bits(size*8) value">AArch32.MemSingle</a>[address+i, 1, accdesc, aligned] = value&lt;8*i+7:8*i&gt;;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32.ESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32.ESBOperation</h3>
      <p class="pseudocode">// AArch32.ESBOperation()
// ======================
// Perform the AArch32 ESB operation for ESB executed in AArch32 state

<a id="AArch32.ESBOperation.0"/>AArch32.ESBOperation()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || HCR_EL2.AMO == '1';
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.EA == '1';

    if route_to_aarch64 then
        <a href="shared_pseudocode.html#AArch64.ESBOperation.0" title="function: AArch64.ESBOperation()">AArch64.ESBOperation</a>();
        return;

    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1';
    route_to_hyp = PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; (HCR.TGE == '1' || HCR.AMO == '1');

    bits(5) target;
    if route_to_monitor then
        target = <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>;
    elsif route_to_hyp || PSTATE.M == <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a> then
        target = <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>;
    else
        target = <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>;

    boolean mask_active;
    if <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        mask_active = TRUE;
    elsif target == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then
        mask_active = SCR.AW == '1' &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) || (HCR.TGE == '0' &amp;&amp; HCR.AMO == '0'));
    else
        mask_active = target == <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a> || PSTATE.M == <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>;

    mask_set = PSTATE.A == '1';
    (-, el)  = <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(target);
    intdis   = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</a>(el);
    masked   = intdis || (mask_active &amp;&amp; mask_set);

    // Check for a masked Physical SError pending that can be synchronized
    // by an Error synchronization event.
    if masked &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsSynchronizablePhysicalSErrorPending.0" title="function: boolean IsSynchronizablePhysicalSErrorPending()">IsSynchronizablePhysicalSErrorPending</a>() then
        bits(32) syndrome = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);
        syndrome&lt;31&gt; = '1';  // A
        syndrome&lt;15:0&gt; = <a href="shared_pseudocode.html#AArch32.PhysicalSErrorSyndrome.0" title="function: bits(16) AArch32.PhysicalSErrorSyndrome()">AArch32.PhysicalSErrorSyndrome</a>();
        DISR = syndrome;
        <a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32.EncodeAsyncErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32.EncodeAsyncErrorSyndrome</h3>
      <p class="pseudocode">// AArch32.EncodeAsyncErrorSyndrome()
// ==================================
// Return the corresponding encoding for ErrorState.

bits(2) <a id="AArch32.EncodeAsyncErrorSyndrome.1"/>AArch32.EncodeAsyncErrorSyndrome(<a href="shared_pseudocode.html#ErrorState" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState</a> errorstate)
    case errorstate of
        when <a href="shared_pseudocode.html#ErrorState_UC" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UC</a>   return '00';
        when <a href="shared_pseudocode.html#ErrorState_UEU" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UEU</a>  return '01';
        when <a href="shared_pseudocode.html#ErrorState_UEO" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UEO</a>  return '10';
        when <a href="shared_pseudocode.html#ErrorState_UER" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UER</a>  return '11';
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32.PhysicalSErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32.PhysicalSErrorSyndrome</h3>
      <p class="pseudocode">// AArch32.PhysicalSErrorSyndrome()
// ================================
// Generate SError syndrome.

bits(16) <a id="AArch32.PhysicalSErrorSyndrome.0"/>AArch32.PhysicalSErrorSyndrome()
    bits(32) syndrome = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.GetPendingPhysicalSError.0" title="function: FaultRecord GetPendingPhysicalSError()">GetPendingPhysicalSError</a>();
    boolean long_format = TTBCR.EAE == '1';
    syndrome = <a href="shared_pseudocode.html#AArch32.CommonFaultStatus.2" title="function: bits(32) AArch32.CommonFaultStatus(FaultRecord fault, boolean long_format)">AArch32.CommonFaultStatus</a>(fault, long_format);
    return syndrome&lt;15:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32.vESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32.vESBOperation</h3>
      <p class="pseudocode">// AArch32.vESBOperation()
// =======================
// Perform the ESB operation for virtual SError interrupts executed in AArch32 state

<a id="AArch32.vESBOperation.0"/>AArch32.vESBOperation()
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    // Check for EL2 using AArch64 state
    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        <a href="shared_pseudocode.html#AArch64.vESBOperation.0" title="function: AArch64.vESBOperation()">AArch64.vESBOperation</a>();
        return;

    // If physical SError interrupts are routed to Hyp mode, and TGE is not set,
    // then a virtual SError interrupt might be pending
    vSEI_enabled = HCR.TGE == '0' &amp;&amp; HCR.AMO == '1';
    vSEI_pending = vSEI_enabled &amp;&amp; HCR.VA == '1';
    vintdis      = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    vmasked      = vintdis || PSTATE.A == '1';

    // Check for a masked virtual SError pending
    if vSEI_pending &amp;&amp; vmasked then
        bits(32) syndrome = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);
        syndrome&lt;31&gt; = '1';              // A
        syndrome&lt;15:14&gt; = VDFSR&lt;15:14&gt;;  // AET
        syndrome&lt;12&gt;    = VDFSR&lt;12&gt;;     // ExT
        syndrome&lt;9&gt;     = TTBCR.EAE;     // LPAE
        if TTBCR.EAE == '1' then         // Long-descriptor format
            syndrome&lt;5:0&gt;    = '010001'; // STATUS
        else                             // Short-descriptor format
            syndrome&lt;10,3:0&gt; = '10110';  // FS
        VDISR = syndrome;
        HCR.VA = '0';                    // Clear pending virtual SError

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.AArch32.ResetGeneralRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/AArch32.ResetGeneralRegisters</h3>
      <p class="pseudocode">// AArch32.ResetGeneralRegisters()
// ===============================

<a id="AArch32.ResetGeneralRegisters.0"/>AArch32.ResetGeneralRegisters()

    for i = 0 to 7
        <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[i] = bits(32) UNKNOWN;
    for i = 8 to 12
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>] = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>] = bits(32) UNKNOWN;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[13, <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>] = bits(32) UNKNOWN;   // No R14_hyp
    for i = 13 to 14
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>] = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>] = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>] = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>] = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>] = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>] = bits(32) UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>] = bits(32) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.AArch32.ResetSIMDFPRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/AArch32.ResetSIMDFPRegisters</h3>
      <p class="pseudocode">// AArch32.ResetSIMDFPRegisters()
// ==============================

<a id="AArch32.ResetSIMDFPRegisters.0"/>AArch32.ResetSIMDFPRegisters()

    for i = 0 to 15
        <a href="shared_pseudocode.html#impl-aarch32.Q.write.1" title="accessor: Q[integer n] = bits(128) value">Q</a>[i] = bits(128) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.AArch32.ResetSpecialRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/AArch32.ResetSpecialRegisters</h3>
      <p class="pseudocode">// AArch32.ResetSpecialRegisters()
// ===============================

<a id="AArch32.ResetSpecialRegisters.0"/>AArch32.ResetSpecialRegisters()

    // AArch32 special registers
    SPSR_fiq&lt;31:0&gt; = bits(32) UNKNOWN;
    SPSR_irq&lt;31:0&gt; = bits(32) UNKNOWN;
    SPSR_svc&lt;31:0&gt; = bits(32) UNKNOWN;
    SPSR_abt&lt;31:0&gt; = bits(32) UNKNOWN;
    SPSR_und&lt;31:0&gt; = bits(32) UNKNOWN;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        SPSR_hyp = bits(32) UNKNOWN;
        ELR_hyp = bits(32) UNKNOWN;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        SPSR_mon = bits(32) UNKNOWN;

    // External debug special registers
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.AArch32.ResetSystemRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/AArch32.ResetSystemRegisters</h3>
      <p class="pseudocode"><a id="AArch32.ResetSystemRegisters.1"/>AArch32.ResetSystemRegisters(boolean cold_reset);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.ALUExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/ALUExceptionReturn</h3>
      <p class="pseudocode">// ALUExceptionReturn()
// ====================

<a id="impl-aarch32.ALUExceptionReturn.1"/>ALUExceptionReturn(bits(32) address)
    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        UNDEFINED;
    elsif PSTATE.M IN {<a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>,<a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>} then
        <a href="shared_pseudocode.html#Constraint" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_ALUEXCEPTIONRETURN" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_ALUEXCEPTIONRETURN</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>, <a href="shared_pseudocode.html#Constraint_NOP" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NOP</a>};
        case c of
            when <a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>
                UNDEFINED;
            when <a href="shared_pseudocode.html#Constraint_NOP" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NOP</a>
                <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();
    else
        <a href="shared_pseudocode.html#AArch32.ExceptionReturn.2" title="function: AArch32.ExceptionReturn(bits(32) new_pc_in, bits(32) spsr)">AArch32.ExceptionReturn</a>(address, <a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(N) SPSR[]">SPSR</a>[]);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.ALUWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/ALUWritePC</h3>
      <p class="pseudocode">// ALUWritePC()
// ============

<a id="impl-aarch32.ALUWritePC.1"/>ALUWritePC(bits(32) address)
    if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then
        <a href="shared_pseudocode.html#impl-aarch32.BXWritePC.2" title="function: BXWritePC(bits(32) address_in, BranchType branch_type)">BXWritePC</a>(address, <a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>);
    else
        <a href="shared_pseudocode.html#impl-aarch32.BranchWritePC.2" title="function: BranchWritePC(bits(32) address_in, BranchType branch_type)">BranchWritePC</a>(address, <a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.BXWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/BXWritePC</h3>
      <p class="pseudocode">// BXWritePC()
// ===========

<a id="impl-aarch32.BXWritePC.2"/>BXWritePC(bits(32) address_in, <a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> branch_type)
    bits(32) address = address_in;
    if address&lt;0&gt; == '1' then
        <a href="shared_pseudocode.html#impl-aarch32.SelectInstrSet.1" title="function: SelectInstrSet(InstrSet iset)">SelectInstrSet</a>(<a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>);
        address&lt;0&gt; = '0';
    else
        <a href="shared_pseudocode.html#impl-aarch32.SelectInstrSet.1" title="function: SelectInstrSet(InstrSet iset)">SelectInstrSet</a>(<a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>);
        // For branches to an unaligned PC counter in A32 state, the processor takes the branch
        // and does one of:
        // * Forces the address to be aligned
        // * Leaves the PC unaligned, meaning the target generates a PC Alignment fault.
        if address&lt;1&gt; == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_A32FORCEALIGNPC" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_A32FORCEALIGNPC</a>) then
            address&lt;1&gt; = '0';
    boolean branch_conditional = !(<a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() IN {'111x'});
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(address, branch_type, branch_conditional);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.BranchWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/BranchWritePC</h3>
      <p class="pseudocode">// BranchWritePC()
// ===============

<a id="impl-aarch32.BranchWritePC.2"/>BranchWritePC(bits(32) address_in, <a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> branch_type)
    bits(32) address = address_in;
    if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then
        address&lt;1:0&gt; = '00';
    else
        address&lt;0&gt; = '0';
    boolean branch_conditional = !(<a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() IN {'111x'});
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(address, branch_type, branch_conditional);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.CBWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/CBWritePC</h3>
      <p class="pseudocode">// CBWritePC()
// ===========
// Takes a branch from a CBNZ/CBZ instruction.

<a id="impl-aarch32.CBWritePC.1"/>CBWritePC(bits(32) address_in)
    bits(32) address = address_in;
    assert <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>;
    address&lt;0&gt; = '0';
    boolean branch_conditional = TRUE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(address, <a href="shared_pseudocode.html#BranchType_DIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIR</a>, branch_conditional);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.D"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/D</h3>
      <p class="pseudocode">// D[] - non-assignment form
// =========================

bits(64) <a id="impl-aarch32.D.read.1"/>D[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 2) * 64;
    bits(128) vreg = V[n DIV 2, 128];
    return vreg&lt;base+63:base&gt;;

// D[] - assignment form
// =====================

<a id="impl-aarch32.D.write.1"/>D[integer n] = bits(64) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 2) * 64;
    bits(128) vreg = V[n DIV 2, 128];
    vreg&lt;base+63:base&gt; = value;
    V[n DIV 2, 128] = vreg;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Din"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Din</h3>
      <p class="pseudocode">// Din[] - non-assignment form
// ===========================

bits(64) <a id="impl-aarch32.Din.read.1"/>Din[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    return _Dclone[n];</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.LR"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/LR</h3>
      <p class="pseudocode">// LR - assignment form
// ====================

<a id="impl-aarch32.LR.write.none"/>LR = bits(32) value
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = value;
    return;

// LR - non-assignment form
// ========================

bits(32) <a id="impl-aarch32.LR.read.none"/>LR
    return <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[14];</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.LoadWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/LoadWritePC</h3>
      <p class="pseudocode">// LoadWritePC()
// =============

<a id="impl-aarch32.LoadWritePC.1"/>LoadWritePC(bits(32) address)
    <a href="shared_pseudocode.html#impl-aarch32.BXWritePC.2" title="function: BXWritePC(bits(32) address_in, BranchType branch_type)">BXWritePC</a>(address, <a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.LookUpRIndex"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/LookUpRIndex</h3>
      <p class="pseudocode">// LookUpRIndex()
// ==============

integer <a id="impl-aarch32.LookUpRIndex.2"/>LookUpRIndex(integer n, bits(5) mode)
    assert n &gt;= 0 &amp;&amp; n &lt;= 14;

    integer result;
    case n of  // Select  index by mode:     usr fiq irq svc abt und hyp
        when 8     result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode,  8, 24,  8,  8,  8,  8,  8);
        when 9     result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode,  9, 25,  9,  9,  9,  9,  9);
        when 10    result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 10, 26, 10, 10, 10, 10, 10);
        when 11    result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 11, 27, 11, 11, 11, 11, 11);
        when 12    result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 12, 28, 12, 12, 12, 12, 12);
        when 13    result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 13, 29, 17, 19, 21, 23, 15);
        when 14    result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 14, 30, 16, 18, 20, 22, 14);
        otherwise  result = n;

    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Monitor_mode_registers"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Monitor_mode_registers</h3>
      <p class="pseudocode">bits(32) SP_mon;
bits(32) <a id="impl-aarch32.LR.read.none_2"/>LR_mon;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.PC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/PC</h3>
      <p class="pseudocode">// PC - non-assignment form
// ========================

bits(32) <a id="impl-aarch32.PC.read.none"/>PC
    return <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[15];               // This includes the offset from AArch32 state</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.PCStoreValue"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/PCStoreValue</h3>
      <p class="pseudocode">// PCStoreValue()
// ==============

bits(32) <a id="impl-aarch32.PCStoreValue.0"/>PCStoreValue()
    // This function returns the PC value. On architecture versions before Armv7, it
    // is permitted to instead return PC+4, provided it does so consistently. It is
    // used only to describe A32 instructions, so it returns the address of the current
    // instruction plus 8 (normally) or 12 (when the alternative is permitted).
    return <a href="shared_pseudocode.html#impl-aarch32.PC.read.none" title="accessor: bits(32) PC">PC</a>;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Q"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Q</h3>
      <p class="pseudocode">// Q[] - non-assignment form
// =========================

bits(128) <a id="impl-aarch32.Q.read.1"/>Q[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 15;
    return V[n, 128];

// Q[] - assignment form
// =====================

<a id="impl-aarch32.Q.write.1"/>Q[integer n] = bits(128) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 15;
    V[n, 128] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Qin"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Qin</h3>
      <p class="pseudocode">// Qin[] - non-assignment form
// ===========================

bits(128) <a id="impl-aarch32.Qin.read.1"/>Qin[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 15;
    return <a href="shared_pseudocode.html#impl-aarch32.Din.read.1" title="accessor: bits(64) Din[integer n]">Din</a>[2*n+1]:<a href="shared_pseudocode.html#impl-aarch32.Din.read.1" title="accessor: bits(64) Din[integer n]">Din</a>[2*n];</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.R"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/R</h3>
      <p class="pseudocode">// R[] - assignment form
// =====================

<a id="impl-aarch32.R.write.1"/>R[integer n] = bits(32) value
    <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[n, PSTATE.M] = value;
    return;

// R[] - non-assignment form
// =========================

bits(32) <a id="impl-aarch32.R.read.1"/>R[integer n]
    if n == 15 then
        offset = (if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then 8 else 4);
        return _PC&lt;31:0&gt; + offset;
    else
        return <a href="shared_pseudocode.html#impl-aarch32.Rmode.read.2" title="accessor: bits(32) Rmode[integer n, bits(5) mode]">Rmode</a>[n, PSTATE.M];</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.RBankSelect"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/RBankSelect</h3>
      <p class="pseudocode">// RBankSelect()
// =============

integer <a id="impl-aarch32.RBankSelect.8"/>RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,
                    integer svc, integer abt, integer und, integer hyp)

    integer result;
    case mode of
        when <a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>    result = usr;  // User mode
        when <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>     result = fiq;  // FIQ mode
        when <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>     result = irq;  // IRQ mode
        when <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>     result = svc;  // Supervisor mode
        when <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>   result = abt;  // Abort mode
        when <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>     result = hyp;  // Hyp mode
        when <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>   result = und;  // Undefined mode
        when <a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>  result = usr;  // System mode uses User mode registers
        otherwise        <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>(); // Monitor mode

    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Rmode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Rmode</h3>
      <p class="pseudocode">// Rmode[] - non-assignment form
// =============================

bits(32) <a id="impl-aarch32.Rmode.read.2"/>Rmode[integer n, bits(5) mode]
    assert n &gt;= 0 &amp;&amp; n &lt;= 14;

    // Check for attempted use of Monitor mode in Non-secure state.
    if <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then assert mode != <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>;
    assert !<a href="shared_pseudocode.html#impl-aarch32.BadMode.1" title="function: boolean BadMode(bits(5) mode)">BadMode</a>(mode);

    if mode == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then
        if n == 13 then return SP_mon;
        elsif n == 14 then return LR_mon;
        else return _R[n]&lt;31:0&gt;;
    else
        return _R[<a href="shared_pseudocode.html#impl-aarch32.LookUpRIndex.2" title="function: integer LookUpRIndex(integer n, bits(5) mode)">LookUpRIndex</a>(n, mode)]&lt;31:0&gt;;

// Rmode[] - assignment form
// =========================

<a id="impl-aarch32.Rmode.write.2"/>Rmode[integer n, bits(5) mode] = bits(32) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 14;

    // Check for attempted use of Monitor mode in Non-secure state.
    if <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then assert mode != <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>;
    assert !<a href="shared_pseudocode.html#impl-aarch32.BadMode.1" title="function: boolean BadMode(bits(5) mode)">BadMode</a>(mode);

    if mode == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then
        if n == 13 then SP_mon = value;
        elsif n == 14 then LR_mon = value;
        else _R[n]&lt;31:0&gt; = value;
    else
        // It is CONSTRAINED UNPREDICTABLE whether the upper 32 bits of the X
        // register are unchanged or set to zero. This is also tested for on
        // exception entry, as this applies to all AArch32 registers.
        if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ZEROUPPER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_ZEROUPPER</a>) then
            _R[<a href="shared_pseudocode.html#impl-aarch32.LookUpRIndex.2" title="function: integer LookUpRIndex(integer n, bits(5) mode)">LookUpRIndex</a>(n, mode)] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, 64);
        else
            _R[<a href="shared_pseudocode.html#impl-aarch32.LookUpRIndex.2" title="function: integer LookUpRIndex(integer n, bits(5) mode)">LookUpRIndex</a>(n, mode)]&lt;31:0&gt; = value;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.S"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/S</h3>
      <p class="pseudocode">// S[] - non-assignment form
// =========================

bits(32) <a id="impl-aarch32.S.read.1"/>S[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 4) * 32;
    bits(128) vreg = V[n DIV 4, 128];
    return vreg&lt;base+31:base&gt;;

// S[] - assignment form
// =====================

<a id="impl-aarch32.S.write.1"/>S[integer n] = bits(32) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 4) * 32;
    bits(128) vreg = V[n DIV 4, 128];
    vreg&lt;base+31:base&gt; = value;
    V[n DIV 4, 128] = vreg;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers._Dclone"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/_Dclone</h3>
      <p class="pseudocode">array bits(64) _Dclone[0..31];</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.ExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.ExceptionReturn</h3>
      <p class="pseudocode">// AArch32.ExceptionReturn()
// =========================

<a id="AArch32.ExceptionReturn.2"/>AArch32.ExceptionReturn(bits(32) new_pc_in, bits(32) spsr)
    bits(32) new_pc = new_pc_in;
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    // Attempts to change to an illegal mode or state will invoke the Illegal Execution state
    // mechanism
    <a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr);
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>());
    <a href="shared_pseudocode.html#impl-shared.SendEventLocal.0" title="function: SendEventLocal()">SendEventLocal</a>();

    if PSTATE.IL == '1' then
        // If the exception return is illegal, PC[1:0] are UNKNOWN
        new_pc&lt;1:0&gt; = bits(2) UNKNOWN;
    else
        // LR[1:0] or LR[0] are treated as being 0, depending on the target instruction set state
        if PSTATE.T == '1' then
            new_pc&lt;0&gt; = '0';                 // T32
        else
            new_pc&lt;1:0&gt; = '00';              // A32

    boolean branch_conditional = !(<a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() IN {'111x'});
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(new_pc, <a href="shared_pseudocode.html#BranchType_ERET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_ERET</a>, branch_conditional);

    <a href="shared_pseudocode.html#impl-shared.CheckExceptionCatch.1" title="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(FALSE);              // Check for debug event on exception return</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.ExecutingCP10or11Instr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.ExecutingCP10or11Instr</h3>
      <p class="pseudocode">// AArch32.ExecutingCP10or11Instr()
// ================================

boolean <a id="AArch32.ExecutingCP10or11Instr.0"/>AArch32.ExecutingCP10or11Instr()
    instr =  <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>();
    instr_set = <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>();
    assert instr_set IN {<a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>, <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>};

    if instr_set == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then
        return ((instr&lt;27:24&gt; == '1110' || instr&lt;27:25&gt; == '110') &amp;&amp; instr&lt;11:8&gt; IN {'101x'});
    else // InstrSet_T32
        return (instr&lt;31:28&gt; IN {'111x'} &amp;&amp; (instr&lt;27:24&gt; == '1110' || instr&lt;27:25&gt; == '110') &amp;&amp; instr&lt;11:8&gt; IN {'101x'});</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.ITAdvance"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.ITAdvance</h3>
      <p class="pseudocode">// AArch32.ITAdvance()
// ===================

<a id="AArch32.ITAdvance.0"/>AArch32.ITAdvance()
    if PSTATE.IT&lt;2:0&gt; == '000' then
        PSTATE.IT = '00000000';
    else
        PSTATE.IT&lt;4:0&gt; = <a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(PSTATE.IT&lt;4:0&gt;, 1);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.SysRegRead"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.SysRegRead</h3>
      <p class="pseudocode">// Read from a 32-bit AArch32 System register and write the register's contents to R[t].
<a id="AArch32.SysRegRead.3"/>AArch32.SysRegRead(integer cp_num, bits(32) instr, integer t);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.SysRegRead64"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.SysRegRead64</h3>
      <p class="pseudocode">// Read from a 64-bit AArch32 System register and write the register's contents to R[t] and R[t2].
<a id="AArch32.SysRegRead64.4"/>AArch32.SysRegRead64(integer cp_num, bits(32) instr, integer t, integer t2);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.SysRegReadCanWriteAPSR"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.SysRegReadCanWriteAPSR</h3>
      <p class="pseudocode">// AArch32.SysRegReadCanWriteAPSR()
// ================================
// Determines whether the AArch32 System register read instruction can write to APSR flags.

boolean <a id="AArch32.SysRegReadCanWriteAPSR.2"/>AArch32.SysRegReadCanWriteAPSR(integer cp_num, bits(32) instr)
    assert <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    assert (cp_num IN {14,15});
    assert cp_num == <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;11:8&gt;);

    opc1 = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;23:21&gt;);
    opc2 = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;7:5&gt;);
    CRn  = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;19:16&gt;);
    CRm  = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;3:0&gt;);

    if cp_num == 14 &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0 then // DBGDSCRint
        return TRUE;

    return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.SysRegWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.SysRegWrite</h3>
      <p class="pseudocode">// Read the contents of R[t] and write to a 32-bit AArch32 System register.
<a id="AArch32.SysRegWrite.3"/>AArch32.SysRegWrite(integer cp_num, bits(32) instr, integer t);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.SysRegWrite64"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.SysRegWrite64</h3>
      <p class="pseudocode">// Read the contents of R[t] and R[t2] and write to a 64-bit AArch32 System register.
<a id="AArch32.SysRegWrite64.4"/>AArch32.SysRegWrite64(integer cp_num, bits(32) instr, integer t, integer t2);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.SysRegWriteM"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.SysRegWriteM</h3>
      <p class="pseudocode">// Read a value from a virtual address and write it to an AArch32 System register.
<a id="AArch32.SysRegWriteM.3"/>AArch32.SysRegWriteM(integer cp_num, bits(32) instr, bits(32) address);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.WriteMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.WriteMode</h3>
      <p class="pseudocode">// AArch32.WriteMode()
// ===================
// Function for dealing with writes to PSTATE.M from AArch32 state only.
// This ensures that PSTATE.EL and PSTATE.SP are always valid.

<a id="AArch32.WriteMode.1"/>AArch32.WriteMode(bits(5) mode)
    (valid,el) = <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(mode);
    assert valid;
    PSTATE.M   = mode;
    PSTATE.EL  = el;
    PSTATE.nRW = '1';
    PSTATE.SP  = (if mode IN {<a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>,<a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>} then '0' else '1');
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.WriteModeByInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.WriteModeByInstr</h3>
      <p class="pseudocode">// AArch32.WriteModeByInstr()
// ==========================
// Function for dealing with writes to PSTATE.M from an AArch32 instruction, and ensuring that
// illegal state changes are correctly flagged in PSTATE.IL.

<a id="AArch32.WriteModeByInstr.1"/>AArch32.WriteModeByInstr(bits(5) mode)
    (valid,el) = <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(mode);

    // 'valid' is set to FALSE if' mode' is invalid for this implementation or the current value
    // of SCR.NS/SCR_EL3.NS. Additionally, it is illegal for an instruction to write 'mode' to
    // PSTATE.EL if it would result in any of:
    // * A change to a mode that would cause entry to a higher Exception level.
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(el) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then
        valid = FALSE;

    // * A change to or from Hyp mode.
    if (PSTATE.M == <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a> || mode == <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>) &amp;&amp; PSTATE.M != mode then
        valid = FALSE;

    // * When EL2 is implemented, the value of HCR.TGE is '1', a change to a Non-secure EL1 mode.
    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; SCR.NS == '1' &amp;&amp; HCR.TGE == '1' then
        valid = FALSE;

    if !valid then
        PSTATE.IL = '1';
    else
        <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(mode);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.BadMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/BadMode</h3>
      <p class="pseudocode">// BadMode()
// =========

boolean <a id="impl-aarch32.BadMode.1"/>BadMode(bits(5) mode)
    // Return TRUE if 'mode' encodes a mode that is not valid for this implementation
    boolean valid;
    case mode of
        when <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>
            valid = <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        when <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>
            valid = <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        when <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>, <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>, <a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>
            // If EL3 is implemented and using AArch32, then these modes are EL3 modes in Secure
            // state, and EL1 modes in Non-secure state. If EL3 is not implemented or is using
            // AArch64, then these modes are EL1 modes.
            // Therefore it is sufficient to test this implementation supports EL1 using AArch32.
            valid = <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
        when <a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>
            valid = <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>);
        otherwise
            valid = FALSE;           // Passed an illegal mode value
    return !valid;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.BankedRegisterAccessValid"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/BankedRegisterAccessValid</h3>
      <p class="pseudocode">// BankedRegisterAccessValid()
// ===========================
// Checks for MRS (Banked register) or MSR (Banked register) accesses to registers
// other than the SPSRs that are invalid. This includes ELR_hyp accesses.

<a id="impl-aarch32.BankedRegisterAccessValid.2"/>BankedRegisterAccessValid(bits(5) SYSm, bits(5) mode)

    case SYSm of
        when '000xx', '00100'                          // R8_usr to R12_usr
            if mode != <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a> then UNPREDICTABLE;
        when '00101'                                   // SP_usr
            if mode == <a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a> then UNPREDICTABLE;
        when '00110'                                   // LR_usr
            if mode IN {<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>,<a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>} then UNPREDICTABLE;
        when '010xx', '0110x', '01110'                 // R8_fiq to R12_fiq, SP_fiq, LR_fiq
            if mode == <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a> then UNPREDICTABLE;
        when '1000x'                                   // LR_irq, SP_irq
            if mode == <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a> then UNPREDICTABLE;
        when '1001x'                                   // LR_svc, SP_svc
            if mode == <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a> then UNPREDICTABLE;
        when '1010x'                                   // LR_abt, SP_abt
            if mode == <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a> then UNPREDICTABLE;
        when '1011x'                                   // LR_und, SP_und
            if mode == <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a> then UNPREDICTABLE;
        when '1110x'                                   // LR_mon, SP_mon
            if (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> ||
                mode == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>) then UNPREDICTABLE;
        when '11110'                                   // ELR_hyp, only from Monitor or Hyp mode
            if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) || !(mode IN {<a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>,<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>}) then UNPREDICTABLE;
        when '11111'                                   // SP_hyp, only from Monitor mode
            if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) || mode != <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then UNPREDICTABLE;
        otherwise
            UNPREDICTABLE;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.CPSRWriteByInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/CPSRWriteByInstr</h3>
      <p class="pseudocode">// CPSRWriteByInstr()
// ==================
// Update PSTATE.&lt;N,Z,C,V,Q,GE,E,A,I,F,M&gt; from a CPSR value written by an MSR instruction.

<a id="impl-aarch32.CPSRWriteByInstr.2"/>CPSRWriteByInstr(bits(32) value, bits(4) bytemask)
    privileged = PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;              // PSTATE.&lt;A,I,F,M&gt; are not writable at EL0

    // Write PSTATE from 'value', ignoring bytes masked by 'bytemask'
    if bytemask&lt;3&gt; == '1' then
        PSTATE.&lt;N,Z,C,V,Q&gt; = value&lt;31:27&gt;;
        // Bits &lt;26:24&gt; are ignored

    if bytemask&lt;2&gt; == '1' then
        if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then
            PSTATE.SSBS = value&lt;23&gt;;
        if privileged then
            PSTATE.PAN = value&lt;22&gt;;
        if <a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()">HaveDITExt</a>() then
            PSTATE.DIT = value&lt;21&gt;;
        // Bit &lt;20&gt; is RES0
        PSTATE.GE = value&lt;19:16&gt;;

    if bytemask&lt;1&gt; == '1' then
        // Bits &lt;15:10&gt; are RES0
        PSTATE.E = value&lt;9&gt;;                    // PSTATE.E is writable at EL0
        if privileged then
            PSTATE.A = value&lt;8&gt;;

    if bytemask&lt;0&gt; == '1' then
        if privileged then
            PSTATE.&lt;I,F&gt; = value&lt;7:6&gt;;
            // Bit &lt;5&gt; is RES0
            // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.
            <a href="shared_pseudocode.html#AArch32.WriteModeByInstr.1" title="function: AArch32.WriteModeByInstr(bits(5) mode)">AArch32.WriteModeByInstr</a>(value&lt;4:0&gt;);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.ConditionPassed"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/ConditionPassed</h3>
      <p class="pseudocode">// ConditionPassed()
// =================

boolean <a id="impl-aarch32.ConditionPassed.0"/>ConditionPassed()
    return <a href="shared_pseudocode.html#impl-shared.ConditionHolds.1" title="function: boolean ConditionHolds(bits(4) cond)">ConditionHolds</a>(<a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>());</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.CurrentCond"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/CurrentCond</h3>
      <p class="pseudocode">bits(4) <a id="AArch32.CurrentCond.0"/>AArch32.CurrentCond();</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.InITBlock"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/InITBlock</h3>
      <p class="pseudocode">// InITBlock()
// ===========

boolean <a id="impl-aarch32.InITBlock.0"/>InITBlock()
    if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a> then
        return PSTATE.IT&lt;3:0&gt; != '0000';
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.LastInITBlock"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/LastInITBlock</h3>
      <p class="pseudocode">// LastInITBlock()
// ===============

boolean <a id="impl-aarch32.LastInITBlock.0"/>LastInITBlock()
    return (PSTATE.IT&lt;3:0&gt; == '1000');</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.SPSRWriteByInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/SPSRWriteByInstr</h3>
      <p class="pseudocode">// SPSRWriteByInstr()
// ==================

<a id="impl-aarch32.SPSRWriteByInstr.2"/>SPSRWriteByInstr(bits(32) value, bits(4) bytemask)

    bits(32) new_spsr = <a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(N) SPSR[]">SPSR</a>[];

    if bytemask&lt;3&gt; == '1' then
        new_spsr&lt;31:24&gt; = value&lt;31:24&gt;;  // N,Z,C,V,Q flags, IT[1:0],J bits

    if bytemask&lt;2&gt; == '1' then
        new_spsr&lt;23:16&gt; = value&lt;23:16&gt;;  // IL bit, GE[3:0] flags

    if bytemask&lt;1&gt; == '1' then
        new_spsr&lt;15:8&gt; = value&lt;15:8&gt;;    // IT[7:2] bits, E bit, A interrupt mask

    if bytemask&lt;0&gt; == '1' then
        new_spsr&lt;7:0&gt; = value&lt;7:0&gt;;      // I,F interrupt masks, T bit, Mode bits

    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = new_spsr;                   // UNPREDICTABLE if User or System mode

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.SPSRaccessValid"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/SPSRaccessValid</h3>
      <p class="pseudocode">// SPSRaccessValid()
// =================
// Checks for MRS (Banked register) or MSR (Banked register) accesses to the SPSRs
// that are UNPREDICTABLE

<a id="impl-aarch32.SPSRaccessValid.2"/>SPSRaccessValid(bits(5) SYSm, bits(5) mode)
    case SYSm of
        when '01110'                                                   // SPSR_fiq
            if mode == <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>   then UNPREDICTABLE;
        when '10000'                                                   // SPSR_irq
            if mode == <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>   then UNPREDICTABLE;
        when '10010'                                                   // SPSR_svc
            if mode == <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>   then UNPREDICTABLE;
        when '10100'                                                   // SPSR_abt
            if mode == <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a> then UNPREDICTABLE;
        when '10110'                                                   // SPSR_und
            if mode == <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a> then UNPREDICTABLE;
        when '11100'                                                   // SPSR_mon
            if (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || mode == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> ||
                <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then UNPREDICTABLE;
        when '11110'                                                   // SPSR_hyp
            if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) || mode != <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then UNPREDICTABLE;
        otherwise
            UNPREDICTABLE;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.SelectInstrSet"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/SelectInstrSet</h3>
      <p class="pseudocode">// SelectInstrSet()
// ================

<a id="impl-aarch32.SelectInstrSet.1"/>SelectInstrSet(<a href="shared_pseudocode.html#InstrSet" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet</a> iset)
    assert <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() IN {<a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>, <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>};
    assert iset IN {<a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>, <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>};

    PSTATE.T = if iset == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then '0' else '1';

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.v6simd.Sat"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/v6simd/Sat</h3>
      <p class="pseudocode">// Sat()
// =====

bits(N) <a id="impl-aarch32.Sat.3"/>Sat(integer i, integer N, boolean unsigned)
    result = if unsigned then <a href="shared_pseudocode.html#impl-aarch32.UnsignedSat.2" title="function: bits(N) UnsignedSat(integer i, integer N)">UnsignedSat</a>(i, N) else <a href="shared_pseudocode.html#impl-aarch32.SignedSat.2" title="function: bits(N) SignedSat(integer i, integer N)">SignedSat</a>(i, N);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.v6simd.SignedSat"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/v6simd/SignedSat</h3>
      <p class="pseudocode">// SignedSat()
// ===========

bits(N) <a id="impl-aarch32.SignedSat.2"/>SignedSat(integer i, integer N)
    (result, -) = <a href="shared_pseudocode.html#impl-shared.SignedSatQ.2" title="function: (bits(N), boolean) SignedSatQ(integer i, integer N)">SignedSatQ</a>(i, N);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.v6simd.UnsignedSat"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/v6simd/UnsignedSat</h3>
      <p class="pseudocode">// UnsignedSat()
// =============

bits(N) <a id="impl-aarch32.UnsignedSat.2"/>UnsignedSat(integer i, integer N)
    (result, -) = <a href="shared_pseudocode.html#impl-shared.UnsignedSatQ.2" title="function: (bits(N), boolean) UnsignedSatQ(integer i, integer N)">UnsignedSatQ</a>(i, N);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.ic.AArch32.IC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/ic/AArch32.IC</h3>
      <p class="pseudocode">// AArch32.IC()
// ============
// Perform Instruction Cache Operation.

<a id="AArch32.IC.1"/>AArch32.IC(<a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    regval = bits(32) UNKNOWN;
    <a href="shared_pseudocode.html#AArch32.IC.2" title="function: AArch32.IC(bits(32) regval, CacheOpScope opscope)">AArch32.IC</a>(regval, opscope);

// AArch32.IC()
// ============
// Perform Instruction Cache Operation.

<a id="AArch32.IC.2"/>AArch32.IC(bits(32) regval, <a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    <a href="shared_pseudocode.html#CacheRecord" title="type CacheRecord is ( AccessType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache;

    cache.acctype   = <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>;
    cache.cachetype = <a href="shared_pseudocode.html#CacheType_Instruction" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Instruction</a>;
    cache.cacheop   = <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a>;
    cache.opscope   = opscope;
    cache.security  = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);

    if opscope IN {<a href="shared_pseudocode.html#CacheOpScope_ALLU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</a>, <a href="shared_pseudocode.html#CacheOpScope_ALLUIS" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</a>} then
        if opscope == <a href="shared_pseudocode.html#CacheOpScope_ALLUIS" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</a> || (opscope == <a href="shared_pseudocode.html#CacheOpScope_ALLU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
                &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR.FB == '1') then
            cache.shareability = <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
        else
            cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        cache.regval = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(regval, 64);
        <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    else
        assert opscope == <a href="shared_pseudocode.html#CacheOpScope_PoU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoU</a>;

        if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
            if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
                cache.is_vmid_valid = TRUE;
                cache.vmid          = VMID[];
            else
                cache.is_vmid_valid = FALSE;
        else
            cache.is_vmid_valid = FALSE;

        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            cache.is_asid_valid = TRUE;
            cache.asid          = <a href="shared_pseudocode.html#impl-shared.ASID.read.0" title="accessor: bits(16) ASID[]">ASID</a>[];
        else
            cache.is_asid_valid = FALSE;

        need_translate = <a href="shared_pseudocode.html#impl-shared.ICInstNeedsTranslation.1" title="function: boolean ICInstNeedsTranslation(CacheOpScope opscope)">ICInstNeedsTranslation</a>(opscope);

        cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        cache.vaddress     = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(regval, 64);
        cache.translated   = need_translate;

        if !need_translate then
            cache.paddress = <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> UNKNOWN;
            <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
            return;

        integer size    = 0;
        boolean aligned = TRUE;
        <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescIC.1" title="function: AccessDescriptor CreateAccDescIC(CacheRecord cache)">CreateAccDescIC</a>(cache);
        <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc = <a href="shared_pseudocode.html#AArch32.TranslateAddress.4" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch32.TranslateAddress</a>(regval, accdesc, aligned, size);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
            <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(regval, memaddrdesc.fault);

        cache.paddress = memaddrdesc.paddress;
        <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.predictionrestrict.AArch32.RestrictPrediction"/><h3 class="pseudocode">
            Library pseudocode for aarch32/predictionrestrict/AArch32.RestrictPrediction</h3>
      <p class="pseudocode">// AArch32.RestrictPrediction()
// ============================
// Clear all predictions in the context.

<a id="AArch32.RestrictPrediction.2"/>AArch32.RestrictPrediction(bits(32) val, <a href="shared_pseudocode.html#RestrictType" title="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch,&#13; RestrictType_Other }">RestrictType</a> restriction)

    <a href="shared_pseudocode.html#ExecutionCntxt" title="type ExecutionCntxt is ( boolean is_vmid_valid, boolean all_vmid, bits(16) vmid, boolean is_asid_valid, boolean all_asid, bits(16) asid, bits(2) target_el, SecurityState security, RestrictType restriction )">ExecutionCntxt</a> c;
    target_el    = val&lt;25:24&gt;;

    // If the target EL is not implemented or the instruction is executed at an
    // EL lower than the specified level, the instruction is treated as a NOP.
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) || <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();

    bit ns  = val&lt;26&gt;;
    bit nse = bit UNKNOWN;
    ss = <a href="shared_pseudocode.html#impl-shared.TargetSecurityState.2" title="function: SecurityState TargetSecurityState(bit NS, bit NSE)">TargetSecurityState</a>(ns, nse);

    c.security  = ss;
    c.target_el = target_el;

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = FALSE;
            c.vmid          = VMID[];

        elsif target_el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = val&lt;27&gt; == '1';
            c.vmid          = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(val&lt;23:16&gt;, 16);      // Only valid if  val&lt;27&gt; == '0';
        else
            c.is_vmid_valid = FALSE;
    else
        c.is_vmid_valid = FALSE;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = FALSE;
        c.asid          = <a href="shared_pseudocode.html#impl-shared.ASID.read.0" title="accessor: bits(16) ASID[]">ASID</a>[];

    elsif target_el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = val&lt;8&gt; == '1';
        c.asid          = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(val&lt;7:0&gt;, 16);            // Only valid if  val&lt;8&gt; == '0';

    else
        c.is_asid_valid = FALSE;

    c.restriction = restriction;
    <a href="shared_pseudocode.html#impl-shared.RESTRICT_PREDICTIONS.1" title="function: RESTRICT_PREDICTIONS(ExecutionCntxt c)">RESTRICT_PREDICTIONS</a>(c);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.attrs.AArch32.DefaultTEXDecode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/attrs/AArch32.DefaultTEXDecode</h3>
      <p class="pseudocode">// AArch32.DefaultTEXDecode()
// ==========================
// Apply short-descriptor format memory region attributes, without TEX remap

MemoryAttributes <a id="AArch32.DefaultTEXDecode.4"/>AArch32.DefaultTEXDecode(bits(3) TEX_in, bit C_in, bit B_in, bit s)
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs;
    bits(3) TEX = TEX_in;
    bit C = C_in;
    bit B = B_in;

    // Reserved values map to allocated values
    if (TEX == '001' &amp;&amp; C:B == '01') || (TEX == '010' &amp;&amp; C:B != '00') || TEX == '011' then
        bits(5) texcb;
        (-, texcb) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESTEXCB" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESTEXCB</a>, 5);
        TEX = texcb&lt;4:2&gt;;  C = texcb&lt;1&gt;;  B = texcb&lt;0&gt;;

    // Distinction between Inner Shareable and Outer Shareable is not supported in this format
    // A memory region is either Non-shareable or Outer Shareable
    case TEX:C:B of
        when '00000'
            // Device-nGnRnE
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '00001', '01000'
            // Device-nGnRE
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '00010'
            // Write-through Read allocate
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner.attrs  = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.inner.hints  = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.outer.attrs  = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.outer.hints  = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.shareability = if s == '1' then <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> else <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        when '00011'
            // Write-back Read allocate
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner.attrs  = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.inner.hints  = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.outer.attrs  = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.outer.hints  = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.shareability = if s == '1' then <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> else <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        when '00100'
            // Non-cacheable
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner.attrs  = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.outer.attrs  = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '00110'
            memattrs = <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> IMPLEMENTATION_DEFINED;
        when '00111'
            // Write-back Read and Write allocate
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner.attrs  = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.inner.hints  = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.outer.attrs  = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.outer.hints  = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.shareability = if s == '1' then <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> else <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        when '1xxxx'
            // Cacheable, TEX&lt;1:0&gt; = Outer attrs, {C,B} = Inner attrs
            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner   = <a href="shared_pseudocode.html#impl-shared.DecodeSDFAttr.1" title="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(C:B);
            memattrs.outer   = <a href="shared_pseudocode.html#impl-shared.DecodeSDFAttr.1" title="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(TEX&lt;1:0&gt;);

            if memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
                memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
            else
                memattrs.shareability = if s == '1' then <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> else <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        otherwise
            // Reserved, handled above
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    // The Transient hint is not supported in this format
    memattrs.inner.transient = FALSE;
    memattrs.outer.transient = FALSE;
    memattrs.tags            = <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;

    if memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> then
        memattrs.xs = '0';
    else
        memattrs.xs = '1';

    return memattrs;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.attrs.AArch32.MAIRAttr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/attrs/AArch32.MAIRAttr</h3>
      <p class="pseudocode">// AArch32.MAIRAttr()
// ==================
// Retrieve the memory attribute encoding indexed in the given MAIR

bits(8) AArch32.MAIRAttr(integer index, MAIRType mair)
    assert (index &lt; 8);
    bit_index = 8 * index;
    return mair&lt;bit_index+7:bit_index&gt;;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.attrs.AArch32.RemappedTEXDecode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/attrs/AArch32.RemappedTEXDecode</h3>
      <p class="pseudocode">// AArch32.RemappedTEXDecode()
// ===========================
// Apply short-descriptor format memory region attributes, with TEX remap

MemoryAttributes <a id="AArch32.RemappedTEXDecode.5"/>AArch32.RemappedTEXDecode(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(3) TEX, bit C, bit B, bit s)

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs;
    PRRR_Type prrr;
    NMRR_Type nmrr;

    region = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(TEX&lt;0&gt;:C:B);         // TEX&lt;2:1&gt; are ignored in this mapping scheme
    if region == 6 then
        return <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> IMPLEMENTATION_DEFINED;

    if regime == <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        prrr = PRRR_S;
        nmrr = NMRR_S;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        prrr = PRRR_NS;
        nmrr = NMRR_NS;
    else
        prrr = PRRR;
        nmrr = NMRR;

    base = 2 * region;
    attrfield = prrr&lt;base+1:base&gt;;

    if attrfield == '11' then      // Reserved, maps to allocated value
        (-, attrfield) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESPRRR" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESPRRR</a>, 2);

    case attrfield of
        when '00'                  // Device-nGnRnE
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '01'                  // Device-nGnRE
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '10'
            NSn  = if s == '0' then prrr.NS0 else prrr.NS1;
            NOSm = prrr&lt;region+24&gt; AND NSn;
            IRn  = nmrr&lt;base+1:base&gt;;
            ORn  = nmrr&lt;base+17:base+16&gt;;

            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner   = <a href="shared_pseudocode.html#impl-shared.DecodeSDFAttr.1" title="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(IRn);
            memattrs.outer   = <a href="shared_pseudocode.html#impl-shared.DecodeSDFAttr.1" title="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(ORn);
            if memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
                memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
            else
                bits(2) sh = NSn:NOSm;
                memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.DecodeShareability.1" title="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(sh);
        when '11'
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    // The Transient hint is not supported in this format
    memattrs.inner.transient = FALSE;
    memattrs.outer.transient = FALSE;
    memattrs.tags            = <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;

    if memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> then
        memattrs.xs = '0';
    else
        memattrs.xs = '1';

    return memattrs;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.debug.AArch32.CheckBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/debug/AArch32.CheckBreakpoint</h3>
      <p class="pseudocode">// AArch32.CheckBreakpoint()
// =========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch32
// translation regime, when either debug exceptions are enabled, or halting debug is enabled
// and halting is allowed.

FaultRecord <a id="AArch32.CheckBreakpoint.4"/>AArch32.CheckBreakpoint(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, bits(32) vaddress,
                                    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, integer size)
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert size IN {2,4};

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;
    match = FALSE;
    mismatch = FALSE;

    for i = 0 to <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1
        (match_i, mismatch_i) = <a href="shared_pseudocode.html#AArch32.BreakpointMatch.4" title="function: (boolean,boolean) AArch32.BreakpointMatch(integer n, bits(32) vaddress, AccessDescriptor accdesc,&#13; integer size)">AArch32.BreakpointMatch</a>(i, vaddress, accdesc, size);
        match = match || match_i;
        mismatch = mismatch || mismatch_i;

    if match &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() then
        reason = <a href="shared_pseudocode.html#DebugHalt_Breakpoint" title="constant bits(6) DebugHalt_Breakpoint = '000111'">DebugHalt_Breakpoint</a>;
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(reason);
    elsif (match || mismatch) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;
        fault.debugmoe   = <a href="shared_pseudocode.html#DebugException_Breakpoint" title="constant bits(4) DebugException_Breakpoint = '0001'">DebugException_Breakpoint</a>;

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.debug.AArch32.CheckDebug"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/debug/AArch32.CheckDebug</h3>
      <p class="pseudocode">// AArch32.CheckDebug()
// ====================
// Called on each access to check for a debug exception or entry to Debug state.

FaultRecord <a id="AArch32.CheckDebug.3"/>AArch32.CheckDebug(bits(32) vaddress, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, integer size)

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.NoFault.1" title="function: FaultRecord NoFault(AccessDescriptor accdesc)">NoFault</a>(accdesc);

    boolean d_side = (<a href="shared_pseudocode.html#impl-shared.IsDataAccess.1" title="function: boolean IsDataAccess(AccessType acctype)">IsDataAccess</a>(accdesc.acctype) || accdesc.acctype == <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>);
    boolean i_side = (accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a>);
    generate_exception = <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()">AArch32.GenerateDebugExceptions</a>() &amp;&amp; DBGDSCRext.MDBGen == '1';
    halt = <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>();
    // Relative priority of Vector Catch and Breakpoint exceptions not defined in the architecture
    vector_catch_first = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPVECTORCATCHPRI" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_BPVECTORCATCHPRI</a>);

    if i_side &amp;&amp; vector_catch_first &amp;&amp; generate_exception then
        fault = <a href="shared_pseudocode.html#AArch32.CheckVectorCatch.3" title="function: FaultRecord AArch32.CheckVectorCatch(FaultRecord fault_in, bits(32) vaddress, integer size)">AArch32.CheckVectorCatch</a>(fault, vaddress, size);

    if fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> &amp;&amp; (generate_exception || halt) then
        if d_side then
            fault = <a href="shared_pseudocode.html#AArch32.CheckWatchpoint.4" title="function: FaultRecord AArch32.CheckWatchpoint(FaultRecord fault_in, bits(32) vaddress,&#13; AccessDescriptor accdesc, integer size)">AArch32.CheckWatchpoint</a>(fault, vaddress, accdesc, size);
        elsif i_side then
            fault = <a href="shared_pseudocode.html#AArch32.CheckBreakpoint.4" title="function: FaultRecord AArch32.CheckBreakpoint(FaultRecord fault_in, bits(32) vaddress,&#13; AccessDescriptor accdesc, integer size)">AArch32.CheckBreakpoint</a>(fault, vaddress, accdesc, size);

    if fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> &amp;&amp; i_side &amp;&amp; !vector_catch_first &amp;&amp; generate_exception then
        return <a href="shared_pseudocode.html#AArch32.CheckVectorCatch.3" title="function: FaultRecord AArch32.CheckVectorCatch(FaultRecord fault_in, bits(32) vaddress, integer size)">AArch32.CheckVectorCatch</a>(fault, vaddress, size);

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.debug.AArch32.CheckVectorCatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/debug/AArch32.CheckVectorCatch</h3>
      <p class="pseudocode">// AArch32.CheckVectorCatch()
// ==========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch32
// translation regime, when debug exceptions are enabled.

FaultRecord <a id="AArch32.CheckVectorCatch.3"/>AArch32.CheckVectorCatch(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, bits(32) vaddress, integer size)
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;
    match = <a href="shared_pseudocode.html#AArch32.VCRMatch.1" title="function: boolean AArch32.VCRMatch(bits(32) vaddress)">AArch32.VCRMatch</a>(vaddress);
    if size == 4 &amp;&amp; !match &amp;&amp; <a href="shared_pseudocode.html#AArch32.VCRMatch.1" title="function: boolean AArch32.VCRMatch(bits(32) vaddress)">AArch32.VCRMatch</a>(vaddress + 2) then
        match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_VCMATCHHALF" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_VCMATCHHALF</a>);

    if match then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;
        fault.debugmoe   = <a href="shared_pseudocode.html#DebugException_VectorCatch" title="constant bits(4) DebugException_VectorCatch = '0101'">DebugException_VectorCatch</a>;

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.debug.AArch32.CheckWatchpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/debug/AArch32.CheckWatchpoint</h3>
      <p class="pseudocode">// AArch32.CheckWatchpoint()
// =========================
// Called before accessing the memory location of "size" bytes at "address",
// when either debug exceptions are enabled for the access, or halting debug
// is enabled and halting is allowed.

FaultRecord <a id="AArch32.CheckWatchpoint.4"/>AArch32.CheckWatchpoint(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, bits(32) vaddress,
                                    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, integer size)
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;

    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a> then
        if accdesc.cacheop != <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> then
            return fault;
        elsif !(boolean IMPLEMENTATION_DEFINED "DCIMVAC generates watchpoint") then
            return fault;
    elsif !<a href="shared_pseudocode.html#impl-shared.IsDataAccess.1" title="function: boolean IsDataAccess(AccessType acctype)">IsDataAccess</a>(accdesc.acctype) then
        return fault;

    match = FALSE;
    for i = 0 to <a href="shared_pseudocode.html#impl-shared.NumWatchpointsImplemented.0" title="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>() - 1
        if <a href="shared_pseudocode.html#AArch32.WatchpointMatch.4" title="function: boolean AArch32.WatchpointMatch(integer n, bits(32) vaddress, integer size,&#13; AccessDescriptor accdesc)">AArch32.WatchpointMatch</a>(i, vaddress, size, accdesc) then
            match = TRUE;

    if match &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() then
        reason = <a href="shared_pseudocode.html#DebugHalt_Watchpoint" title="constant bits(6) DebugHalt_Watchpoint = '101011'">DebugHalt_Watchpoint</a>;
        EDWAR = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(vaddress, 64);
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(reason);
    elsif match then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;
        fault.debugmoe   = <a href="shared_pseudocode.html#DebugException_Watchpoint" title="constant bits(4) DebugException_Watchpoint = '1010'">DebugException_Watchpoint</a>;

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.IPAIsOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.IPAIsOutOfRange</h3>
      <p class="pseudocode">// AArch32.IPAIsOutOfRange()
// =========================
// Check intermediate physical address bits not resolved by translation are ZERO

boolean AArch32.IPAIsOutOfRange(S2TTWParams walkparams, bits(40) ipa)
    // Input Address size
    iasize = <a href="shared_pseudocode.html#AArch32.S2IASize.1" title="function: integer AArch32.S2IASize(bits(4) t0sz)">AArch32.S2IASize</a>(walkparams.t0sz);

    return iasize &lt; 40 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ipa&lt;39:iasize&gt;);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.S1HasAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.S1HasAlignmentFault</h3>
      <p class="pseudocode">// AArch32.S1HasAlignmentFault()
// =============================
// Returns whether stage 1 output fails alignment requirement on data accesses
// to Device memory

boolean <a id="AArch32.S1HasAlignmentFault.4"/>AArch32.S1HasAlignmentFault(<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, boolean aligned,
                                    bit ntlsmd, <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs)
    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        return FALSE;
    elsif accdesc.a32lsmd &amp;&amp; ntlsmd == '0' then
        return memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp;  memattrs.device != <a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</a>;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#AccessType_DCZero" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DCZero</a> then
        return memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
    else
        return memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp; !aligned;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.S1LDHasPermissionsFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.S1LDHasPermissionsFault</h3>
      <p class="pseudocode">// AArch32.S1LDHasPermissionsFault()
// =================================
// Returns whether an access using stage 1 long-descriptor translation
// violates permissions of target memory

boolean AArch32.S1LDHasPermissionsFault(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, S1TTWParams walkparams, <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> perms,
                                        <a href="shared_pseudocode.html#MemType" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a> memtype, <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> paspace, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    bit  r,  w,  x;
    bit pr, pw;
    bit ur, uw;
    bit xn;
    if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        // Apply leaf permissions
        case perms.ap&lt;2:1&gt; of
            when '00' (pr,pw,ur,uw) = ('1','1','0','0'); // R/W at PL1 only
            when '01' (pr,pw,ur,uw) = ('1','1','1','1'); // R/W at any PL
            when '10' (pr,pw,ur,uw) = ('1','0','0','0'); // RO at PL1 only
            when '11' (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL

        // Apply hierarchical permissions
        case perms.ap_table of
            when '00' (pr,pw,ur,uw) = ( pr, pw, ur, uw); // No effect
            when '01' (pr,pw,ur,uw) = ( pr, pw,'0','0'); // Privileged access
            when '10' (pr,pw,ur,uw) = ( pr,'0', ur,'0'); // Read-only
            when '11' (pr,pw,ur,uw) = ( pr,'0','0','0'); // Read-only, privileged access

        xn   = perms.xn OR perms.xn_table;
        pxn  = perms.pxn OR perms.pxn_table;

        ux = ur AND NOT(xn OR (uw AND walkparams.wxn));
        px = pr AND NOT(xn OR pxn OR (pw AND walkparams.wxn) OR (uw AND walkparams.uwxn));

        if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; accdesc.pan then
            pan = PSTATE.PAN AND (ur OR uw);
            pr  = pr AND NOT(pan);
            pw  = pw AND NOT(pan);

        (r,w,x) = if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then (ur,uw,ux) else (pr,pw,px);

        // Prevent execution from Non-secure space by PE in Secure state if SIF is set
        if accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
            x = x AND NOT(walkparams.sif);
    else
        // Apply leaf permissions
        case perms.ap&lt;2&gt; of
            when '0' (r,w) = ('1','1'); // No effect
            when '1' (r,w) = ('1','0'); // Read-only

        // Apply hierarchical permissions
        case perms.ap_table&lt;1&gt; of
            when '0' (r,w) = ( r , w ); // No effect
            when '1' (r,w) = ( r ,'0'); // Read-only

        xn = perms.xn OR perms.xn_table;
        x  = NOT(xn OR (w AND walkparams.wxn));

    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        constraint = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_INSTRDEVICE</a>);
        if constraint == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> &amp;&amp; memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            return TRUE;
        else
            return x == '0';
    elsif accdesc.acctype IN {<a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>} then
        return FALSE;
    elsif accdesc.write then
        return w == '0';
    else
        return r == '0';</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.S1SDHasPermissionsFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.S1SDHasPermissionsFault</h3>
      <p class="pseudocode">// AArch32.S1SDHasPermissionsFault()
// =================================
// Returns whether an access using stage 1 short-descriptor translation
// violates permissions of target memory

boolean <a id="AArch32.S1SDHasPermissionsFault.5"/>AArch32.S1SDHasPermissionsFault(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> perms_in, <a href="shared_pseudocode.html#MemType" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a> memtype,
                                        <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> paspace, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> perms = perms_in;
    bit pr, pw;
    bit ur, uw;
    SCTLR_Type sctlr;
    if regime == <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        sctlr = SCTLR_S;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        sctlr = SCTLR_NS;
    else
        sctlr = SCTLR;

    if sctlr.AFE == '0' then
        // Map Reserved encoding '100'
        if perms.ap == '100' then
            perms.ap = bits(3) IMPLEMENTATION_DEFINED "Reserved short descriptor AP encoding";

        case perms.ap of
            when '000' (pr,pw,ur,uw) = ('0','0','0','0'); // No access
            when '001' (pr,pw,ur,uw) = ('1','1','0','0'); // R/W at PL1 only
            when '010' (pr,pw,ur,uw) = ('1','1','1','0'); // R/W at PL1, RO at PL0
            when '011' (pr,pw,ur,uw) = ('1','1','1','1'); // R/W at any PL
            //   '100' is reserved
            when '101' (pr,pw,ur,uw) = ('1','0','0','0'); // RO at PL1 only
            when '110' (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL (deprecated)
            when '111' (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL
    else // Simplified access permissions model
        case perms.ap&lt;2:1&gt; of
            when '00' (pr,pw,ur,uw) = ('1','1','0','0'); // R/W at PL1 only
            when '01' (pr,pw,ur,uw) = ('1','1','1','1'); // R/W at any PL
            when '10' (pr,pw,ur,uw) = ('1','0','0','0'); // RO at PL1 only
            when '11' (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL

    ux = ur AND NOT(perms.xn OR (uw AND sctlr.WXN));
    px = pr AND NOT(perms.xn OR perms.pxn OR (pw AND sctlr.WXN) OR (uw AND sctlr.UWXN));

    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; accdesc.pan then
        pan = PSTATE.PAN AND (ur OR uw);
        pr  = pr AND NOT(pan);
        pw  = pw AND NOT(pan);

    (r,w,x) = if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then (ur,uw,ux) else (pr,pw,px);

    // Prevent execution from Non-secure space by PE in Secure state if SIF is set
    if accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
        x = x AND NOT(if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCR.SIF else SCR_EL3.SIF);

    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        if (memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp;
                <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_INSTRDEVICE</a>) == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>) then
            return TRUE;
        else
            return x == '0';
    elsif accdesc.acctype IN {<a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>} then
        return FALSE;
    elsif accdesc.write then
        return w == '0';
    else
        return r == '0';</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.S2HasAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.S2HasAlignmentFault</h3>
      <p class="pseudocode">// AArch32.S2HasAlignmentFault()
// =============================
// Returns whether stage 2 output fails alignment requirement on data accesses
// to Device memory

boolean <a id="AArch32.S2HasAlignmentFault.3"/>AArch32.S2HasAlignmentFault(<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, boolean aligned,
                                    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs)
    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        return FALSE;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#AccessType_DCZero" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DCZero</a> then
        return memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
    else
        return memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp; !aligned;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.S2HasPermissionsFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.S2HasPermissionsFault</h3>
      <p class="pseudocode">// AArch32.S2HasPermissionsFault()
// ===============================
// Returns whether stage 2 access violates permissions of target memory

boolean AArch32.S2HasPermissionsFault(S2TTWParams walkparams, <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> perms, <a href="shared_pseudocode.html#MemType" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a> memtype,
                                      <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    bit px;
    bit ux;
    r = perms.s2ap&lt;0&gt;;
    w = perms.s2ap&lt;1&gt;;
    bit x;
    if <a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()">HaveExtendedExecuteNeverExt</a>() then
        case perms.s2xn:perms.s2xnx of
            when '00'  (px, ux) = ( r , r );
            when '01'  (px, ux) = ('0', r );
            when '10'  (px, ux) = ('0','0');
            when '11'  (px, ux) = ( r ,'0');

        x = if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then ux else px;
    else
        x = r AND NOT(perms.s2xn);

    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a> then
        return (walkparams.ptw == '1' &amp;&amp; memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>) || r == '0';

    elsif accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        constraint = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_INSTRDEVICE</a>);
        return (constraint == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> &amp;&amp; memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>) || x == '0';

    elsif accdesc.acctype IN {<a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>} then
        return FALSE;

    elsif accdesc.write then
        return w == '0';

    else
        return r == '0';</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.S2InconsistentSL"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.S2InconsistentSL</h3>
      <p class="pseudocode">// AArch32.S2InconsistentSL()
// ==========================
// Detect inconsistent configuration of stage 2 T0SZ and SL fields

boolean AArch32.S2InconsistentSL(S2TTWParams walkparams)
    startlevel  = <a href="shared_pseudocode.html#AArch32.S2StartLevel.1" title="function: integer AArch32.S2StartLevel(bits(2) sl0)">AArch32.S2StartLevel</a>(walkparams.sl0);
    levels      = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;

    // Input address size must at least be large enough to be resolved from the start level
    sl_min_iasize = (
        levels * stride // Bits resolved by table walk, except initial level
        + granulebits   // Bits directly mapped to output address
        + 1);           // At least 1 more bit to be decoded by initial level

    // Can accomodate 1 more stride in the level + concatenation of up to 2^4 tables
    sl_max_iasize = sl_min_iasize + (stride-1) + 4;
    // Configured Input Address size
    iasize        = <a href="shared_pseudocode.html#AArch32.S2IASize.1" title="function: integer AArch32.S2IASize(bits(4) t0sz)">AArch32.S2IASize</a>(walkparams.t0sz);

    return iasize &lt; sl_min_iasize || iasize &gt; sl_max_iasize;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.VAIsOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.VAIsOutOfRange</h3>
      <p class="pseudocode">// AArch32.VAIsOutOfRange()
// ========================
// Check virtual address bits not resolved by translation are identical
// and of accepted value

boolean AArch32.VAIsOutOfRange(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, S1TTWParams walkparams, bits(32) va)
    if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> then
        // Input Address size
        iasize = <a href="shared_pseudocode.html#AArch32.S1IASize.1" title="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(walkparams.t0sz);
        return walkparams.t0sz != '000' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:iasize&gt;);
    elsif walkparams.t1sz != '000' &amp;&amp; walkparams.t0sz != '000' then
        // Lower range Input Address size
        lo_iasize = <a href="shared_pseudocode.html#AArch32.S1IASize.1" title="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(walkparams.t0sz);
        // Upper range Input Address size
        up_iasize = <a href="shared_pseudocode.html#AArch32.S1IASize.1" title="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(walkparams.t1sz);
        return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:lo_iasize&gt;) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(va&lt;31:up_iasize&gt;);
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32.GetS1TLBContext"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32.GetS1TLBContext</h3>
      <p class="pseudocode">// AArch32.GetS1TLBContext()
// =========================
// Gather translation context for accesses with VA to match against TLB entries

TLBContext <a id="AArch32.GetS1TLBContext.3"/>AArch32.GetS1TLBContext(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(32) va)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> tlbcontext;

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  tlbcontext = <a href="shared_pseudocode.html#AArch32.TLBContextEL2.1" title="function: TLBContext AArch32.TLBContextEL2(bits(32) va)">AArch32.TLBContextEL2</a>(va);
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> tlbcontext = <a href="shared_pseudocode.html#AArch32.TLBContextEL10.2" title="function: TLBContext AArch32.TLBContextEL10(SecurityState ss, bits(32) va)">AArch32.TLBContextEL10</a>(ss, va);
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> tlbcontext = <a href="shared_pseudocode.html#AArch32.TLBContextEL30.1" title="function: TLBContext AArch32.TLBContextEL30(bits(32) va)">AArch32.TLBContextEL30</a>(va);

    tlbcontext.includes_s1 = TRUE;
    // The following may be amended for EL1&amp;0 Regime if caching of stage 2 is successful
    tlbcontext.includes_s2 = FALSE;
    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32.GetS2TLBContext"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32.GetS2TLBContext</h3>
      <p class="pseudocode">// AArch32.GetS2TLBContext()
// =========================
// Gather translation context for accesses with IPA to match against TLB entries

TLBContext <a id="AArch32.GetS2TLBContext.1"/>AArch32.GetS2TLBContext(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> ipa)
    assert ipa.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss          = <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    tlbcontext.regime      = <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    tlbcontext.ipaspace    = ipa.paspace;
    tlbcontext.vmid        = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR.VMID, 16);
    tlbcontext.tg          = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    tlbcontext.includes_s1 = FALSE;
    tlbcontext.includes_s2 = TRUE;
    tlbcontext.ia          = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.address, 64);
    tlbcontext.cnp         = if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then VTTBR.CnP else '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32.TLBContextEL10"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32.TLBContextEL10</h3>
      <p class="pseudocode">// AArch32.TLBContextEL10()
// ========================
// Gather translation context for accesses under EL10 regime
// (PL10 when EL3 is A64) to match against TLB entries

TLBContext <a id="AArch32.TLBContextEL10.2"/>AArch32.TLBContextEL10(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(32) va)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> tlbcontext;
    TTBCR_Type ttbcr;
    TTBR0_Type ttbr0;
    TTBR1_Type ttbr1;
    CONTEXTIDR_Type contextidr;

    if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        ttbcr      = TTBCR_NS;
        ttbr0      = TTBR0_NS;
        ttbr1      = TTBR1_NS;
        contextidr = CONTEXTIDR_NS;
    else
        ttbcr      = TTBCR;
        ttbr0      = TTBR0;
        ttbr1      = TTBR1;
        contextidr = CONTEXTIDR;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;

    if <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) then
        tlbcontext.vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR.VMID, 16);

    if ttbcr.EAE == '1' then
        tlbcontext.asid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(if ttbcr.A1 == '0' then ttbr0.ASID else ttbr1.ASID, 16);
    else
        tlbcontext.asid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(contextidr.ASID, 16);

    tlbcontext.tg = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    tlbcontext.ia = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64);

    if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() &amp;&amp; ttbcr.EAE == '1' then
        if <a href="shared_pseudocode.html#AArch32.GetVARange.3" title="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, ttbcr.T0SZ, ttbcr.T1SZ) == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            tlbcontext.cnp = ttbr0.CnP;
        else
            tlbcontext.cnp = ttbr1.CnP;
    else
        tlbcontext.cnp = '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32.TLBContextEL2"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32.TLBContextEL2</h3>
      <p class="pseudocode">// AArch32.TLBContextEL2()
// =======================
// Gather translation context for accesses under EL2 regime to match against TLB entries

TLBContext <a id="AArch32.TLBContextEL2.1"/>AArch32.TLBContextEL2(bits(32) va)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
    tlbcontext.ia     = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64);
    tlbcontext.tg     = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    tlbcontext.cnp    = if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then HTTBR.CnP else '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32.TLBContextEL30"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32.TLBContextEL30</h3>
      <p class="pseudocode">// AArch32.TLBContextEL30()
// ========================
// Gather translation context for accesses under EL30 regime
// (PL10 in Secure state and EL3 is A32) to match against TLB entries

TLBContext <a id="AArch32.TLBContextEL30.1"/>AArch32.TLBContextEL30(bits(32) va)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a>;

    if TTBCR_S.EAE == '1' then
        tlbcontext.asid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(if TTBCR_S.A1 == '0' then TTBR0_S.ASID else TTBR1_S.ASID, 16);
    else
        tlbcontext.asid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(CONTEXTIDR_S.ASID, 16);

    tlbcontext.tg = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    tlbcontext.ia = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64);

    if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() &amp;&amp; TTBCR_S.EAE == '1' then
        if <a href="shared_pseudocode.html#AArch32.GetVARange.3" title="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, TTBCR_S.T0SZ, TTBCR_S.T1SZ) == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            tlbcontext.cnp = TTBR0_S.CnP;
        else
            tlbcontext.cnp = TTBR1_S.CnP;
    else
        tlbcontext.cnp = '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.EL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.EL2Enabled</h3>
      <p class="pseudocode">// AArch32.EL2Enabled()
// ====================
// Returns whether EL2 is enabled for the given Security State

boolean <a id="AArch32.EL2Enabled.1"/>AArch32.EL2Enabled(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        if !(<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>()) then
            return FALSE;
        elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            return SCR_EL3.EEL2 == '1';
        else
            return boolean IMPLEMENTATION_DEFINED "Secure-only implementation";
    else
        return <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.FullTranslate"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.FullTranslate</h3>
      <p class="pseudocode">// AArch32.FullTranslate()
// =======================
// Perform address translation as specified by VMSA-A32

AddressDescriptor <a id="AArch32.FullTranslate.3"/>AArch32.FullTranslate(bits(32) va, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, boolean aligned)

    // Prepare fault fields in case a fault is detected
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.NoFault.1" title="function: FaultRecord NoFault(AccessDescriptor accdesc)">NoFault</a>(accdesc);
    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.1" title="function: Regime TranslationRegime(bits(2) el)">TranslationRegime</a>(accdesc.el);

    // First Stage Translation
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> ipa;
    if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> || TTBCR.EAE == '1' then
        (fault, ipa) = <a href="shared_pseudocode.html#AArch32.S1TranslateLD.5" title="function: (FaultRecord, AddressDescriptor) AArch32.S1TranslateLD(FaultRecord fault_in, Regime regime,&#13; bits(32) va, boolean aligned,&#13; AccessDescriptor accdesc)">AArch32.S1TranslateLD</a>(fault, regime, va, aligned, accdesc);
    else
        (fault, ipa, -) = <a href="shared_pseudocode.html#AArch32.S1TranslateSD.5" title="function: (FaultRecord, AddressDescriptor, SDFType) AArch32.S1TranslateSD(FaultRecord fault_in, Regime regime,&#13; bits(32) va, boolean aligned,&#13; AccessDescriptor accdesc)">AArch32.S1TranslateSD</a>(fault, regime, va, aligned, accdesc);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return <a href="shared_pseudocode.html#impl-shared.CreateFaultyAddressDescriptor.2" title="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64), fault);

    if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        ipa.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64);
        <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> pa;
        (fault, pa) = <a href="shared_pseudocode.html#AArch32.S2Translate.4" title="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean aligned, AccessDescriptor accdesc)">AArch32.S2Translate</a>(fault, ipa, aligned, accdesc);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return <a href="shared_pseudocode.html#impl-shared.CreateFaultyAddressDescriptor.2" title="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64), fault);
        else
            return pa;
    else
        return ipa;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.OutputDomain"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.OutputDomain</h3>
      <p class="pseudocode">// AArch32.OutputDomain()
// ======================
// Determine the domain the translated output address

bits(2) <a id="AArch32.OutputDomain.2"/>AArch32.OutputDomain(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(4) domain)
    bits(2) Dn;
    index = 2 * <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(domain);
    if regime == <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        Dn = DACR_S&lt;index+1:index&gt;;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        Dn = DACR_NS&lt;index+1:index&gt;;
    else
        Dn = DACR&lt;index+1:index&gt;;

    if Dn == '10' then
        // Reserved value maps to an allocated value
        (-, Dn) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESDACR" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESDACR</a>, 2);

    return Dn;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.S1DisabledOutput"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.S1DisabledOutput</h3>
      <p class="pseudocode">// AArch32.S1DisabledOutput()
// ==========================
// Flat map the VA to IPA/PA, depending on the regime, assigning default memory attributes

(FaultRecord, AddressDescriptor) <a id="AArch32.S1DisabledOutput.5"/>AArch32.S1DisabledOutput(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                          bits(32) va, boolean aligned,
                                                          <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;
    // No memory page is guarded when stage 1 address translation is disabled
    SetInGuardedPage(FALSE);

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs;
    bit default_cacheable;
    if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(accdesc.ss) then
        if <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then
            default_cacheable = HCR.DC;
        else
            default_cacheable = HCR_EL2.DC;
    else
        default_cacheable = '0';

    if default_cacheable == '1' then
        // Use default cacheable settings
        memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.inner.attrs  = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
        memattrs.inner.hints  = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
        memattrs.outer.attrs  = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
        memattrs.outer.hints  = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
        memattrs.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        if (!<a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) &amp;&amp;
                <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; HCR_EL2.DCT == '1') then
            memattrs.tags   = <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a>;
        else
            memattrs.tags   = <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        memattrs.tags         = <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;
        if <a href="shared_pseudocode.html#AArch32.S1ICacheEnabled.1" title="function: boolean AArch32.S1ICacheEnabled(Regime regime)">AArch32.S1ICacheEnabled</a>(regime) then
            memattrs.inner.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.inner.hints = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.outer.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.outer.hints = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
        else
            memattrs.inner.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.outer.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
    else
        // Treat memory region as Device
        memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
        memattrs.device       = <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
        memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        memattrs.tags         = <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;

    bit ntlsmd;
    if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        case regime of
            when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> ntlsmd = SCTLR_S.nTLSMD;
            when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  ntlsmd = HSCTLR.nTLSMD;
            when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> ntlsmd = if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.nTLSMD else SCTLR.nTLSMD;
    else
        ntlsmd = '1';

    if <a href="shared_pseudocode.html#AArch32.S1HasAlignmentFault.4" title="function: boolean AArch32.S1HasAlignmentFault(AccessDescriptor accdesc, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch32.S1HasAlignmentFault</a>(accdesc, aligned, ntlsmd, memattrs) then
        fault.statuscode  = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> oa;
    oa.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 56);
    oa.paspace = if accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> else <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    ipa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64), oa, memattrs);

    return (fault, ipa);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.S1Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.S1Enabled</h3>
      <p class="pseudocode">// AArch32.S1Enabled()
// ===================
// Returns whether stage 1 translation is enabled for the active translation regime

boolean <a id="AArch32.S1Enabled.2"/>AArch32.S1Enabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> then
        return HSCTLR.M == '1';
    elsif regime == <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        return SCTLR_S.M == '1';
    elsif !<a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) then
        return (if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.M else SCTLR.M) == '1';
    elsif <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then
        return HCR.&lt;TGE,DC&gt; == '00' &amp;&amp; (if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.M else SCTLR.M) == '1';
    else
        return HCR_EL2.&lt;TGE,DC&gt; == '00' &amp;&amp; SCTLR.M == '1';</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.S1TranslateLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.S1TranslateLD</h3>
      <p class="pseudocode">// AArch32.S1TranslateLD()
// =======================
// Perform a stage 1 translation using long-descriptor format mapping VA to IPA/PA
// depending on the regime

(FaultRecord, AddressDescriptor) <a id="AArch32.S1TranslateLD.5"/>AArch32.S1TranslateLD(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                       bits(32) va, boolean aligned,
                                                       <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;

    if !<a href="shared_pseudocode.html#AArch32.S1Enabled.2" title="function: boolean AArch32.S1Enabled(Regime regime, SecurityState ss)">AArch32.S1Enabled</a>(regime, accdesc.ss) then
        return <a href="shared_pseudocode.html#AArch32.S1DisabledOutput.5" title="function: (FaultRecord, AddressDescriptor) AArch32.S1DisabledOutput(FaultRecord fault_in, Regime regime,&#13; bits(32) va, boolean aligned,&#13; AccessDescriptor accdesc)">AArch32.S1DisabledOutput</a>(fault, regime, va, aligned, accdesc);

    walkparams = AArch32.GetS1TTWParams(regime, va);

    if AArch32.VAIsOutOfRange(regime, walkparams, va) then
        fault.level      = 1;
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    (fault, walkstate) = AArch32.S1WalkLD(fault, regime, walkparams, accdesc, va);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    SetInGuardedPage(FALSE);  // AArch32-VMSA does not guard any pages

    if <a href="shared_pseudocode.html#AArch32.S1HasAlignmentFault.4" title="function: boolean AArch32.S1HasAlignmentFault(AccessDescriptor accdesc, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch32.S1HasAlignmentFault</a>(accdesc, aligned, walkparams.ntlsmd, walkstate.memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
    elsif AArch32.S1LDHasPermissionsFault(regime, walkparams,
                                          walkstate.permissions,
                                          walkstate.memattrs.memtype,
                                          walkstate.baseaddress.paspace,
                                          accdesc) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs;
    if ((accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || !<a href="shared_pseudocode.html#AArch32.S1ICacheEnabled.1" title="function: boolean AArch32.S1ICacheEnabled(Regime regime)">AArch32.S1ICacheEnabled</a>(regime))) ||
        (accdesc.acctype != <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp; !<a href="shared_pseudocode.html#AArch32.S1DCacheEnabled.1" title="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</a>(regime))) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;
    else
        memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(accdesc.ss) &amp;&amp;
        (if <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, accdesc.ss==<a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then HCR.VM else HCR_EL2.VM) == '1' &amp;&amp;
        !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        memattrs.shareability = walkstate.memattrs.shareability;
    else
        memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);

    // Output Address
    oa = <a href="shared_pseudocode.html#impl-shared.StageOA.4" title="function: FullAddress StageOA(bits(64) ia, bit d128, TGx tgx, TTWState walkstate)">StageOA</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64), walkparams.d128, walkparams.tgx, walkstate);
    ipa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64), oa, memattrs);

    return (fault, ipa);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.S1TranslateSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.S1TranslateSD</h3>
      <p class="pseudocode">// AArch32.S1TranslateSD()
// =======================
// Perform a stage 1 translation using short-descriptor format mapping VA to IPA/PA
// depending on the regime

(FaultRecord, AddressDescriptor, SDFType) <a id="AArch32.S1TranslateSD.5"/>AArch32.S1TranslateSD(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                                bits(32) va, boolean aligned,
                                                                <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;

    if !<a href="shared_pseudocode.html#AArch32.S1Enabled.2" title="function: boolean AArch32.S1Enabled(Regime regime, SecurityState ss)">AArch32.S1Enabled</a>(regime, accdesc.ss) then
        <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> ipa;
        (fault, ipa) = <a href="shared_pseudocode.html#AArch32.S1DisabledOutput.5" title="function: (FaultRecord, AddressDescriptor) AArch32.S1DisabledOutput(FaultRecord fault_in, Regime regime,&#13; bits(32) va, boolean aligned,&#13; AccessDescriptor accdesc)">AArch32.S1DisabledOutput</a>(fault, regime, va, aligned, accdesc);
        return (fault, ipa, <a href="shared_pseudocode.html#SDFType" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> UNKNOWN);

    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    (fault, walkstate) = <a href="shared_pseudocode.html#AArch32.S1WalkSD.4" title="function: (FaultRecord, TTWState) AArch32.S1WalkSD(FaultRecord fault_in, Regime regime,&#13; AccessDescriptor accdesc, bits(32) va)">AArch32.S1WalkSD</a>(fault, regime, accdesc, va);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#SDFType" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> UNKNOWN);

    domain = <a href="shared_pseudocode.html#AArch32.OutputDomain.2" title="function: bits(2) AArch32.OutputDomain(Regime regime, bits(4) domain)">AArch32.OutputDomain</a>(regime, walkstate.domain);
    SetInGuardedPage(FALSE);  // AArch32-VMSA does not guard any pages

    bit ntlsmd;
    if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        case regime of
            when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> ntlsmd = SCTLR_S.nTLSMD;
            when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> ntlsmd = if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.nTLSMD else SCTLR.nTLSMD;
    else
        ntlsmd = '1';

    if <a href="shared_pseudocode.html#AArch32.S1HasAlignmentFault.4" title="function: boolean AArch32.S1HasAlignmentFault(AccessDescriptor accdesc, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch32.S1HasAlignmentFault</a>(accdesc, aligned, ntlsmd, walkstate.memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
    elsif (!(accdesc.acctype IN {<a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>}) &amp;&amp;
            domain == <a href="shared_pseudocode.html#Domain_NoAccess" title="constant bits(2) Domain_NoAccess = '00'">Domain_NoAccess</a>) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a>;
    elsif domain == <a href="shared_pseudocode.html#Domain_Client" title="constant bits(2) Domain_Client = '01'">Domain_Client</a> then
        if <a href="shared_pseudocode.html#AArch32.S1SDHasPermissionsFault.5" title="function: boolean AArch32.S1SDHasPermissionsFault(Regime regime, Permissions perms_in, MemType memtype,&#13; PASpace paspace, AccessDescriptor accdesc)">AArch32.S1SDHasPermissionsFault</a>(regime, walkstate.permissions,
                                           walkstate.memattrs.memtype,
                                           walkstate.baseaddress.paspace,
                                           accdesc) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        fault.domain = walkstate.domain;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, walkstate.sdftype);

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs;
    if ((accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || !<a href="shared_pseudocode.html#AArch32.S1ICacheEnabled.1" title="function: boolean AArch32.S1ICacheEnabled(Regime regime)">AArch32.S1ICacheEnabled</a>(regime))) ||
        (accdesc.acctype != <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp; !<a href="shared_pseudocode.html#AArch32.S1DCacheEnabled.1" title="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</a>(regime))) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;
    else
        memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(accdesc.ss) &amp;&amp;
        (if <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, accdesc.ss==<a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then HCR.VM else HCR_EL2.VM) == '1' &amp;&amp;
        !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        memattrs.shareability = walkstate.memattrs.shareability;
    else
        memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);

    // Output Address
    oa = <a href="shared_pseudocode.html#AArch32.SDStageOA.3" title="function: FullAddress AArch32.SDStageOA(FullAddress baseaddress, bits(32) va, SDFType sdftype)">AArch32.SDStageOA</a>(walkstate.baseaddress, va, walkstate.sdftype);
    ipa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64), oa, memattrs);

    return (fault, ipa, walkstate.sdftype);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.S2Translate"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.S2Translate</h3>
      <p class="pseudocode">// AArch32.S2Translate()
// =====================
// Perform a stage 2 translation mapping an IPA to a PA

(FaultRecord, AddressDescriptor) <a id="AArch32.S2Translate.4"/>AArch32.S2Translate(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> ipa,
                                                     boolean aligned, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;
    assert <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ipa.paddress.address&lt;55:40&gt;);

    if !<a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then
        s1aarch64 = FALSE;
        return <a href="shared_pseudocode.html#AArch64.S2Translate.5" title="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean s1aarch64, boolean aligned,&#13; AccessDescriptor accdesc)">AArch64.S2Translate</a>(fault, ipa, s1aarch64, aligned, accdesc);

    // Prepare fault fields in case a fault is detected
    fault.statuscode  = <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    fault.secondstage = TRUE;
    fault.s2fs1walk   = accdesc.acctype == <a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a>;
    fault.ipaddress   = ipa.paddress;

    walkparams = AArch32.GetS2TTWParams();

    if walkparams.vm == '0' then
        // Stage 2 is disabled
        return (fault, ipa);

    if AArch32.IPAIsOutOfRange(walkparams, ipa.paddress.address&lt;39:0&gt;) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 1;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    (fault, walkstate) = AArch32.S2Walk(fault, walkparams, accdesc, ipa);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    if <a href="shared_pseudocode.html#AArch32.S2HasAlignmentFault.3" title="function: boolean AArch32.S2HasAlignmentFault(AccessDescriptor accdesc, boolean aligned,&#13; MemoryAttributes memattrs)">AArch32.S2HasAlignmentFault</a>(accdesc, aligned, walkstate.memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
    elsif AArch32.S2HasPermissionsFault(walkparams,
                                        walkstate.permissions,
                                        walkstate.memattrs.memtype,
                                        accdesc) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> s2_memattrs;
    if ((accdesc.acctype == <a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a> &amp;&amp;
             walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>) ||
        (accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || HCR2.ID == '1')) ||
        (accdesc.acctype != <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp; HCR2.CD == '1')) then
        // Treat memory attributes as Normal Non-Cacheable
        s2_memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        s2_memattrs.xs = walkstate.memattrs.xs;
    else
        s2_memattrs = walkstate.memattrs;

    memattrs = <a href="shared_pseudocode.html#impl-shared.S2CombineS1MemAttrs.2" title="function: MemoryAttributes S2CombineS1MemAttrs(MemoryAttributes s1_memattrs,&#13; MemoryAttributes s2_memattrs)">S2CombineS1MemAttrs</a>(ipa.memattrs, s2_memattrs);
    ipa_64 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address&lt;39:0&gt;, 64);
    // Output Address
    oa = <a href="shared_pseudocode.html#impl-shared.StageOA.4" title="function: FullAddress StageOA(bits(64) ia, bit d128, TGx tgx, TTWState walkstate)">StageOA</a>(ipa_64, walkparams.d128, walkparams.tgx, walkstate);
    pa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(ipa.vaddress, oa, memattrs);

    return (fault, pa);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.SDStageOA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.SDStageOA</h3>
      <p class="pseudocode">// AArch32.SDStageOA()
// ===================
// Given the final walk state of a short-descriptor translation walk,
// map the untranslated input address bits to the base output address

FullAddress <a id="AArch32.SDStageOA.3"/>AArch32.SDStageOA(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> baseaddress, bits(32) va, <a href="shared_pseudocode.html#SDFType" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> sdftype)
    integer tsize;
    case sdftype of
        when <a href="shared_pseudocode.html#SDFType_SmallPage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</a>      tsize = 12;
        when <a href="shared_pseudocode.html#SDFType_LargePage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</a>      tsize = 16;
        when <a href="shared_pseudocode.html#SDFType_Section" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</a>        tsize = 20;
        when <a href="shared_pseudocode.html#SDFType_Supersection" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a>   tsize = 24;

    // Output Address
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> oa;
    oa.address = baseaddress.address&lt;55:tsize&gt;:va&lt;tsize-1:0&gt;;
    oa.paspace = baseaddress.paspace;
    return oa;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.TranslateAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.TranslateAddress</h3>
      <p class="pseudocode">// AArch32.TranslateAddress()
// ==========================
// Main entry point for translating an address

AddressDescriptor <a id="AArch32.TranslateAddress.4"/>AArch32.TranslateAddress(bits(32) va, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc,
                                           boolean aligned, integer size)

    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.1" title="function: Regime TranslationRegime(bits(2) el)">TranslationRegime</a>(PSTATE.EL);
    if !<a href="shared_pseudocode.html#impl-shared.RegimeUsingAArch32.1" title="function: boolean RegimeUsingAArch32(Regime regime)">RegimeUsingAArch32</a>(regime) then
        return <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64), accdesc, aligned, size);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> result = <a href="shared_pseudocode.html#AArch32.FullTranslate.3" title="function: AddressDescriptor AArch32.FullTranslate(bits(32) va, AccessDescriptor accdesc, boolean aligned)">AArch32.FullTranslate</a>(va, accdesc, aligned);

    if !<a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(result) then
        result.fault = <a href="shared_pseudocode.html#AArch32.CheckDebug.3" title="function: FaultRecord AArch32.CheckDebug(bits(32) vaddress, AccessDescriptor accdesc, integer size)">AArch32.CheckDebug</a>(va, accdesc, size);

    // Update virtual address for abort functions
    result.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.DecodeDescriptorTypeLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.DecodeDescriptorTypeLD</h3>
      <p class="pseudocode">// AArch32.DecodeDescriptorTypeLD()
// ================================
// Determine whether the long-descriptor is a page, block or table

DescriptorType <a id="AArch32.DecodeDescriptorTypeLD.2"/>AArch32.DecodeDescriptorTypeLD(bits(64) descriptor, integer level)
    if descriptor&lt;1:0&gt; == '11' &amp;&amp; level == <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
        return <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>;
    elsif descriptor&lt;1:0&gt; == '11' then
        return <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>;
    elsif descriptor&lt;1:0&gt; == '01' &amp;&amp; level != <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
        return <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>;
    else
        return <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.DecodeDescriptorTypeSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.DecodeDescriptorTypeSD</h3>
      <p class="pseudocode">// AArch32.DecodeDescriptorTypeSD()
// ================================
// Determine the type of the short-descriptor

SDFType <a id="AArch32.DecodeDescriptorTypeSD.2"/>AArch32.DecodeDescriptorTypeSD(bits(32) descriptor, integer level)
    if level == 1 &amp;&amp; descriptor&lt;1:0&gt; == '01' then
        return <a href="shared_pseudocode.html#SDFType_Table" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Table</a>;
    elsif level == 1 &amp;&amp; descriptor&lt;18,1&gt; == '01' then
        return <a href="shared_pseudocode.html#SDFType_Section" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</a>;
    elsif level == 1 &amp;&amp; descriptor&lt;18,1&gt; == '11' then
        return <a href="shared_pseudocode.html#SDFType_Supersection" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a>;
    elsif level == 2 &amp;&amp; descriptor&lt;1:0&gt; == '01' then
        return <a href="shared_pseudocode.html#SDFType_LargePage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</a>;
    elsif level == 2 &amp;&amp; descriptor&lt;1:0&gt; IN {'1x'} then
        return <a href="shared_pseudocode.html#SDFType_SmallPage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</a>;
    else
        return <a href="shared_pseudocode.html#SDFType_Invalid" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Invalid</a>;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.S1IASize"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.S1IASize</h3>
      <p class="pseudocode">// AArch32.S1IASize()
// ==================
// Retrieve the number of bits containing the input address for stage 1 translation

integer <a id="AArch32.S1IASize.1"/>AArch32.S1IASize(bits(3) txsz)
    return 32 - <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(txsz);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.S1WalkLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.S1WalkLD</h3>
      <p class="pseudocode">// AArch32.S1WalkLD()
// ==================
// Traverse stage 1 translation tables in long format to obtain the final descriptor

(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a>, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>) AArch32.S1WalkLD(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                         S1TTWParams walkparams, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc,
                                         bits(32) va)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;
    bits(3) txsz;
    bits(64) ttbr;
    bit epd;
    <a href="shared_pseudocode.html#VARange" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> varange;
    if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> then
        ttbr = HTTBR;
        txsz = walkparams.t0sz;
        varange = <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    else
        varange = <a href="shared_pseudocode.html#AArch32.GetVARange.3" title="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, walkparams.t0sz, walkparams.t1sz);
        bits(64) ttbr0;
        bits(64) ttbr1;
        TTBCR_Type ttbcr;
        if regime == <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
            ttbcr = TTBCR_S;
            ttbr0 = TTBR0_S;
            ttbr1 = TTBR1_S;
        elsif <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            ttbcr = TTBCR_NS;
            ttbr0 = TTBR0_NS;
            ttbr1 = TTBR1_NS;
        else
            ttbcr = TTBCR;
            ttbr0 = TTBR0;
            ttbr1 = TTBR1;

        assert ttbcr.EAE == '1';
        if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            txsz = walkparams.t0sz;
            ttbr = ttbr0;
            epd  = ttbcr.EPD0;
        else
            txsz = walkparams.t1sz;
            ttbr = ttbr1;
            epd  = ttbcr.EPD1;

    if regime != <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> &amp;&amp; epd == '1' then
        fault.level      = 1;
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Input Address size
    iasize      = <a href="shared_pseudocode.html#AArch32.S1IASize.1" title="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(txsz);
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;
    startlevel  = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - (((iasize-1) - granulebits) DIV stride);
    levels      = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ttbr&lt;47:40&gt;) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> baseaddress;
    baselsb = (iasize - (levels*stride + granulebits)) + 3;
    baseaddress.paspace = if accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> else <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ttbr&lt;39:baselsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(baselsb), 56);

    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    walkstate.baseaddress = baseaddress;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    // In regimes that support global and non-global translations, translation
    // table entries from lookup levels other than the final level of lookup
    // are treated as being non-global
    walkstate.nG          = if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then '1' else '0';
    walkstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);
    walkstate.permissions.ap_table  = '00';
    walkstate.permissions.xn_table  = '0';
    walkstate.permissions.pxn_table = '0';

    indexmsb = iasize - 1;
    bits(64) descriptor;
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> walkaddress;

    walkaddress.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64);

    if !<a href="shared_pseudocode.html#AArch32.S1DCacheEnabled.1" title="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</a>(regime) then
        walkaddress.memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(accdesc.ss) &amp;&amp;
        (if <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, accdesc.ss==<a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then HCR.VM else HCR_EL2.VM) == '1' &amp;&amp;
        !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        walkaddress.memattrs.shareability = walkstate.memattrs.shareability;
    else
        walkaddress.memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

    integer indexlsb;
    <a href="shared_pseudocode.html#DescriptorType" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType</a> desctype;
    repeat
        fault.level = walkstate.level;
        indexlsb = (<a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - walkstate.level)*stride + granulebits;
        bits(40) index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va&lt;indexmsb:indexlsb&gt;:'000', 40);

        walkaddress.paddress.address = walkstate.baseaddress.address OR <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(index, 56);
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;

        boolean toplevel = walkstate.level == startlevel;
        <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> walkaccess = <a href="shared_pseudocode.html#impl-shared.CreateAccDescS1TTW.3" title="function: AccessDescriptor CreateAccDescS1TTW(boolean toplevel, VARange varange, AccessDescriptor accdesc_in)">CreateAccDescS1TTW</a>(toplevel, varange, accdesc);
        // If there are two stages of translation, then the first stage table walk addresses
        // are themselves subject to translation
        if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(accdesc.ss) then
            s2aligned = TRUE;
            (s2fault, s2walkaddress) = <a href="shared_pseudocode.html#AArch32.S2Translate.4" title="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean aligned, AccessDescriptor accdesc)">AArch32.S2Translate</a>(fault, walkaddress, s2aligned,
                                                           walkaccess);
            // Check for a fault on the stage 2 walk
            if s2fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                return (s2fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.5" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; AccessDescriptor walkaccess, FaultRecord fault_in,&#13; integer N)">FetchDescriptor</a>(walkparams.ee, s2walkaddress, walkaccess,
                                                  fault, 64);
        else
            (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.5" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; AccessDescriptor walkaccess, FaultRecord fault_in,&#13; integer N)">FetchDescriptor</a>(walkparams.ee, walkaddress, walkaccess,
                                                  fault, 64);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

        desctype = <a href="shared_pseudocode.html#AArch32.DecodeDescriptorTypeLD.2" title="function: DescriptorType AArch32.DecodeDescriptorTypeLD(bits(64) descriptor, integer level)">AArch32.DecodeDescriptorTypeLD</a>(descriptor, walkstate.level);

        case desctype of
            when <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>
                if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(descriptor&lt;47:40&gt;) then
                    fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
                    return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(descriptor&lt;39:12&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12), 56);
                if walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> &amp;&amp; descriptor&lt;63&gt; == '1' then
                    walkstate.baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

                if walkparams.hpd == '0' then
                    walkstate.permissions.xn_table  = (walkstate.permissions.xn_table  OR
                                                        descriptor&lt;60&gt;);
                    walkstate.permissions.ap_table  = (walkstate.permissions.ap_table  OR
                                                        descriptor&lt;62:61&gt;);
                    walkstate.permissions.pxn_table = (walkstate.permissions.pxn_table OR
                                                        descriptor&lt;59&gt;);

                walkstate.level = walkstate.level + 1;
                indexmsb = indexlsb - 1;

            when <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            when <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>
                walkstate.istable = FALSE;

    until desctype == <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>;

    // Check the output address is inside the supported range
    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(descriptor&lt;47:40&gt;) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Check the access flag
    if descriptor&lt;10&gt; == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    walkstate.permissions.xn  = descriptor&lt;54&gt;;
    walkstate.permissions.pxn = descriptor&lt;53&gt;;
    walkstate.permissions.ap  = descriptor&lt;7:6&gt;:'1';
    walkstate.contiguous      = descriptor&lt;52&gt;;
    if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> then
        // All EL2 regime accesses are treated as Global
        walkstate.nG = '0';
    elsif accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
        // When a PE is using the Long-descriptor translation table format,
        // and is in Secure state, a translation must be treated as non-global,
        // regardless of the value of the nG bit,
        // if NSTable is set to 1 at any level of the translation table walk.
        walkstate.nG = '1';
    else
        walkstate.nG = descriptor&lt;11&gt;;

    walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(descriptor&lt;39:indexlsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(indexlsb), 56);
    if walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> &amp;&amp; descriptor&lt;5&gt; == '1' then
        walkstate.baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    memattr = descriptor&lt;4:2&gt;;
    sh      = descriptor&lt;9:8&gt;;
    attr    = AArch32.MAIRAttr(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(memattr), walkparams.mair);
    s1aarch64 = FALSE;
    walkstate.memattrs = S1DecodeMemAttrs(attr, sh, s1aarch64, walkparams);

    return (fault, walkstate);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.S1WalkSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.S1WalkSD</h3>
      <p class="pseudocode">// AArch32.S1WalkSD()
// ==================
// Traverse stage 1 translation tables in short format to obtain the final descriptor

(FaultRecord, TTWState) <a id="AArch32.S1WalkSD.4"/>AArch32.S1WalkSD(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                         <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, bits(32) va)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;
    SCTLR_Type sctlr;
    TTBCR_Type ttbcr;
    TTBR0_Type ttbr0;
    TTBR1_Type ttbr1;
    // Determine correct translation control registers to use.
    if regime == <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        sctlr = SCTLR_S;
        ttbcr = TTBCR_S;
        ttbr0 = TTBR0_S;
        ttbr1 = TTBR1_S;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        sctlr = SCTLR_NS;
        ttbcr = TTBCR_NS;
        ttbr0 = TTBR0_NS;
        ttbr1 = TTBR1_NS;
    else
        sctlr = SCTLR;
        ttbcr = TTBCR;
        ttbr0 = TTBR0;
        ttbr1 = TTBR1;

    assert ttbcr.EAE == '0';
    ee  = sctlr.EE;
    afe = sctlr.AFE;
    tre = sctlr.TRE;
    n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ttbcr.N);
    bits(32) ttb;
    bits(1) pd;
    bits(2) irgn;
    bits(2) rgn;
    bits(1) s;
    bits(1) nos;
    <a href="shared_pseudocode.html#VARange" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> varange;
    if n == 0 || <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:(32-n)&gt;) then
        ttb  = ttbr0.TTB0:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(7);
        pd   = ttbcr.PD0;
        irgn = ttbr0.IRGN;
        rgn  = ttbr0.RGN;
        s    = ttbr0.S;
        nos  = ttbr0.NOS;
        varange = <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    else
        n    = 0;  // TTBR1 translation always treats N as 0
        ttb  = ttbr1.TTB1:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(7);
        pd   = ttbcr.PD1;
        irgn = ttbr1.IRGN;
        rgn  = ttbr1.RGN;
        s    = ttbr1.S;
        nos  = ttbr1.NOS;
        varange = <a href="shared_pseudocode.html#VARange_UPPER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a>;

    // Check if Translation table walk disabled for translations with this Base register.
    if pd == '1' then
        fault.level      = 1;
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> baseaddress;
    baseaddress.paspace = if accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> else <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ttb&lt;31:14-n&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(14-n), 56);

    constant integer startlevel = 1;
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    walkstate.baseaddress = baseaddress;
    // In regimes that support global and non-global translations, translation
    // table entries from lookup levels other than the final level of lookup
    // are treated as being non-global. Translations in Short-Descriptor Format
    // always support global &amp; non-global translations.
    walkstate.nG          = '1';
    walkstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(s:nos, irgn, rgn);
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;

    bits(4) domain;
    bits(32) descriptor;
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> walkaddress;

    walkaddress.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64);

    if !<a href="shared_pseudocode.html#AArch32.S1DCacheEnabled.1" title="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</a>(regime) then
        walkaddress.memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(accdesc.ss) &amp;&amp;
        (if <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, accdesc.ss==<a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then HCR.VM else HCR_EL2.VM) == '1' &amp;&amp;
        !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        walkaddress.memattrs.shareability = walkstate.memattrs.shareability;
    else
        walkaddress.memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

    bit nG;
    bit ns;
    bit pxn;
    bits(3) ap;
    bits(3) tex;
    bit c;
    bit b;
    bit xn;
    repeat
        fault.level = walkstate.level;

        bits(32) index;
        if walkstate.level == 1 then
            index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va&lt;31-n:20&gt;:'00', 32);
        else
            index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va&lt;19:12&gt;:'00', 32);

        walkaddress.paddress.address = walkstate.baseaddress.address OR <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(index,
                                                                                   56);
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;

        boolean toplevel = walkstate.level == startlevel;
        <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> walkaccess = <a href="shared_pseudocode.html#impl-shared.CreateAccDescS1TTW.3" title="function: AccessDescriptor CreateAccDescS1TTW(boolean toplevel, VARange varange, AccessDescriptor accdesc_in)">CreateAccDescS1TTW</a>(toplevel, varange, accdesc);
        if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(accdesc.ss) then
            s2aligned = TRUE;
            (s2fault, s2walkaddress) = <a href="shared_pseudocode.html#AArch32.S2Translate.4" title="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean aligned, AccessDescriptor accdesc)">AArch32.S2Translate</a>(fault, walkaddress, s2aligned,
                                                           walkaccess);

            if s2fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                return (s2fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.5" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; AccessDescriptor walkaccess, FaultRecord fault_in,&#13; integer N)">FetchDescriptor</a>(ee, s2walkaddress, walkaccess, fault, 32);
        else
            (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.5" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; AccessDescriptor walkaccess, FaultRecord fault_in,&#13; integer N)">FetchDescriptor</a>(ee, walkaddress, walkaccess, fault, 32);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

        walkstate.sdftype = <a href="shared_pseudocode.html#AArch32.DecodeDescriptorTypeSD.2" title="function: SDFType AArch32.DecodeDescriptorTypeSD(bits(32) descriptor, integer level)">AArch32.DecodeDescriptorTypeSD</a>(descriptor, walkstate.level);

        case walkstate.sdftype of
            when <a href="shared_pseudocode.html#SDFType_Invalid" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Invalid</a>
                fault.domain     = domain;
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            when <a href="shared_pseudocode.html#SDFType_Table" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Table</a>
                domain = descriptor&lt;8:5&gt;;
                ns     = descriptor&lt;3&gt;;
                pxn    = descriptor&lt;2&gt;;

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(descriptor&lt;31:10&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(10),
                                                           56);
                walkstate.level = 2;

            when <a href="shared_pseudocode.html#SDFType_SmallPage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</a>
                nG  = descriptor&lt;11&gt;;
                s   = descriptor&lt;10&gt;;
                ap  = descriptor&lt;9,5:4&gt;;
                tex = descriptor&lt;8:6&gt;;
                c   = descriptor&lt;3&gt;;
                b   = descriptor&lt;2&gt;;
                xn  = descriptor&lt;0&gt;;

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(descriptor&lt;31:12&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12),
                                                           56);
                walkstate.istable = FALSE;

            when <a href="shared_pseudocode.html#SDFType_LargePage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</a>
                xn  = descriptor&lt;15&gt;;
                tex = descriptor&lt;14:12&gt;;
                nG  = descriptor&lt;11&gt;;
                s   = descriptor&lt;10&gt;;
                ap  = descriptor&lt;9,5:4&gt;;
                c   = descriptor&lt;3&gt;;
                b   = descriptor&lt;2&gt;;

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(descriptor&lt;31:16&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16),
                                                           56);
                walkstate.istable = FALSE;

            when <a href="shared_pseudocode.html#SDFType_Section" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</a>
                ns     = descriptor&lt;19&gt;;
                nG     = descriptor&lt;17&gt;;
                s      = descriptor&lt;16&gt;;
                ap     = descriptor&lt;15,11:10&gt;;
                tex    = descriptor&lt;14:12&gt;;
                domain = descriptor&lt;8:5&gt;;
                xn     = descriptor&lt;4&gt;;
                c      = descriptor&lt;3&gt;;
                b      = descriptor&lt;2&gt;;
                pxn    = descriptor&lt;0&gt;;

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(descriptor&lt;31:20&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(20),
                                                           56);
                walkstate.istable = FALSE;

            when <a href="shared_pseudocode.html#SDFType_Supersection" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a>
                ns     = descriptor&lt;19&gt;;
                nG     = descriptor&lt;17&gt;;
                s      = descriptor&lt;16&gt;;
                ap     = descriptor&lt;15,11:10&gt;;
                tex    = descriptor&lt;14:12&gt;;
                xn     = descriptor&lt;4&gt;;
                c      = descriptor&lt;3&gt;;
                b      = descriptor&lt;2&gt;;
                pxn    = descriptor&lt;0&gt;;
                domain = '0000';

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(descriptor&lt;8:5,23:20,31:24&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24),
                                                           56);
                walkstate.istable = FALSE;

    until walkstate.sdftype != <a href="shared_pseudocode.html#SDFType_Table" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Table</a>;

    if afe == '1' &amp;&amp; ap&lt;0&gt; == '0' then
        fault.domain     = domain;
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Decode the TEX, C, B and S bits to produce target memory attributes
    if tre == '1' then
        walkstate.memattrs = <a href="shared_pseudocode.html#AArch32.RemappedTEXDecode.5" title="function: MemoryAttributes AArch32.RemappedTEXDecode(Regime regime, bits(3) TEX, bit C, bit B, bit s)">AArch32.RemappedTEXDecode</a>(regime, tex, c, b, s);
    elsif <a href="shared_pseudocode.html#impl-aarch32.RemapRegsHaveResetValues.0" title="function: boolean RemapRegsHaveResetValues()">RemapRegsHaveResetValues</a>() then
        walkstate.memattrs = <a href="shared_pseudocode.html#AArch32.DefaultTEXDecode.4" title="function: MemoryAttributes AArch32.DefaultTEXDecode(bits(3) TEX_in, bit C_in, bit B_in, bit s)">AArch32.DefaultTEXDecode</a>(tex, c, b, s);
    else
        walkstate.memattrs = <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> IMPLEMENTATION_DEFINED;

    walkstate.permissions.ap  = ap;
    walkstate.permissions.xn  = xn;
    walkstate.permissions.pxn = pxn;
    walkstate.domain = domain;
    walkstate.nG     = nG;

    if accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; ns == '0' then
        walkstate.baseaddress.paspace = <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
    else
        walkstate.baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    return (fault, walkstate);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.S2IASize"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.S2IASize</h3>
      <p class="pseudocode">// AArch32.S2IASize()
// ==================
// Retrieve the number of bits containing the input address for stage 2 translation

integer <a id="AArch32.S2IASize.1"/>AArch32.S2IASize(bits(4) t0sz)
    return 32 - <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(t0sz);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.S2StartLevel"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.S2StartLevel</h3>
      <p class="pseudocode">// AArch32.S2StartLevel()
// ======================
// Determine the initial lookup level when performing a stage 2 translation
// table walk

integer <a id="AArch32.S2StartLevel.1"/>AArch32.S2StartLevel(bits(2) sl0)
    return 2 - <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(sl0);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.S2Walk"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.S2Walk</h3>
      <p class="pseudocode">// AArch32.S2Walk()
// ================
// Traverse stage 2 translation tables in long format to obtain the final descriptor

(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a>, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>) AArch32.S2Walk(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, S2TTWParams walkparams,
                                       <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> ipa)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;

    if walkparams.sl0 IN {'1x'} || AArch32.S2InconsistentSL(walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 1;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Input Address size
    iasize      = <a href="shared_pseudocode.html#AArch32.S2IASize.1" title="function: integer AArch32.S2IASize(bits(4) t0sz)">AArch32.S2IASize</a>(walkparams.t0sz);
    startlevel  = <a href="shared_pseudocode.html#AArch32.S2StartLevel.1" title="function: integer AArch32.S2StartLevel(bits(2) sl0)">AArch32.S2StartLevel</a>(walkparams.sl0);
    levels      = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(VTTBR&lt;47:40&gt;) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> baseaddress;
    baselsb = (iasize - (levels*stride + granulebits)) + 3;
    baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR&lt;39:baselsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(baselsb), 56);

    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    walkstate.baseaddress = baseaddress;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    walkstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn,
                                         walkparams.orgn);

    indexmsb = iasize - 1;
    bits(64) descriptor;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> walkaccess = <a href="shared_pseudocode.html#impl-shared.CreateAccDescS2TTW.1" title="function: AccessDescriptor CreateAccDescS2TTW(AccessDescriptor accdesc_in)">CreateAccDescS2TTW</a>(accdesc);
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> walkaddress;

    walkaddress.vaddress = ipa.vaddress;

    if HCR2.CD == '1' then
        walkaddress.memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;

    walkaddress.memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

    integer indexlsb;
    <a href="shared_pseudocode.html#DescriptorType" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType</a> desctype;
    repeat
        fault.level = walkstate.level;

        indexlsb = (<a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - walkstate.level)*stride + granulebits;
        bits(40) index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address&lt;indexmsb:indexlsb&gt;:'000', 40);

        walkaddress.paddress.address = walkstate.baseaddress.address OR <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(index, 56);
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;

        (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.5" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; AccessDescriptor walkaccess, FaultRecord fault_in,&#13; integer N)">FetchDescriptor</a>(walkparams.ee, walkaddress, walkaccess, fault, 64);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

        desctype = <a href="shared_pseudocode.html#AArch32.DecodeDescriptorTypeLD.2" title="function: DescriptorType AArch32.DecodeDescriptorTypeLD(bits(64) descriptor, integer level)">AArch32.DecodeDescriptorTypeLD</a>(descriptor, walkstate.level);

        case desctype of
            when <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>
                if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(descriptor&lt;47:40&gt;) then
                    fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
                    return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(descriptor&lt;39:12&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12), 56);
                walkstate.level = walkstate.level + 1;
                indexmsb = indexlsb - 1;

            when <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            when <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>
                walkstate.istable = FALSE;

    until desctype IN {<a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>};

    // Check the output address is inside the supported range
    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(descriptor&lt;47:40&gt;) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Check the access flag
    if descriptor&lt;10&gt; == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Unpack the descriptor into address and upper and lower block attributes
    walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(descriptor&lt;39:indexlsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(indexlsb), 56);

    walkstate.permissions.s2ap = descriptor&lt;7:6&gt;;
    walkstate.permissions.s2xn = descriptor&lt;54&gt;;
    if <a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()">HaveExtendedExecuteNeverExt</a>() then
        walkstate.permissions.s2xnx = descriptor&lt;53&gt;;
    else
        walkstate.permissions.s2xnx = '0';

    memattr = descriptor&lt;5:2&gt;;
    sh      = descriptor&lt;9:8&gt;;
    s2aarch64 = FALSE;
    walkstate.memattrs   = <a href="shared_pseudocode.html#impl-shared.S2DecodeMemAttrs.3" title="function: MemoryAttributes S2DecodeMemAttrs(bits(4) attr, bits(2) sh, boolean s2aarch64)">S2DecodeMemAttrs</a>(memattr, sh, s2aarch64);
    walkstate.contiguous = descriptor&lt;52&gt;;

    return (fault, walkstate);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.TranslationSizeSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.TranslationSizeSD</h3>
      <p class="pseudocode">// AArch32.TranslationSizeSD()
// ===========================
// Determine the size of the translation

integer <a id="AArch32.TranslationSizeSD.1"/>AArch32.TranslationSizeSD(<a href="shared_pseudocode.html#SDFType" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> sdftype)
    integer tsize;
    case sdftype of
        when <a href="shared_pseudocode.html#SDFType_SmallPage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</a>      tsize = 12;
        when <a href="shared_pseudocode.html#SDFType_LargePage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</a>      tsize = 16;
        when <a href="shared_pseudocode.html#SDFType_Section" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</a>        tsize = 20;
        when <a href="shared_pseudocode.html#SDFType_Supersection" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a>   tsize = 24;

    return tsize;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.RemapRegsHaveResetValues"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/RemapRegsHaveResetValues</h3>
      <p class="pseudocode">boolean <a id="impl-aarch32.RemapRegsHaveResetValues.0"/>RemapRegsHaveResetValues();</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.GetS1TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.GetS1TTWParams</h3>
      <p class="pseudocode">// AArch32.GetS1TTWParams()
// ========================
// Returns stage 1 translation table walk parameters from respective controlling
// System registers.

S1TTWParams AArch32.GetS1TTWParams(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(32) va)
    S1TTWParams walkparams;

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  walkparams = AArch32.S1TTWParamsEL2();
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> walkparams = AArch32.S1TTWParamsEL10(va);
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> walkparams = AArch32.S1TTWParamsEL30(va);

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.GetS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.GetS2TTWParams</h3>
      <p class="pseudocode">// AArch32.GetS2TTWParams()
// ========================
// Gather walk parameters for stage 2 translation

S2TTWParams AArch32.GetS2TTWParams()
    S2TTWParams walkparams;

    walkparams.tgx  = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    walkparams.s    = VTCR.S;
    walkparams.t0sz = VTCR.T0SZ;
    walkparams.sl0  = VTCR.SL0;
    walkparams.irgn = VTCR.IRGN0;
    walkparams.orgn = VTCR.ORGN0;
    walkparams.sh   = VTCR.SH0;
    walkparams.ee   = HSCTLR.EE;
    walkparams.ptw  = HCR.PTW;
    walkparams.vm   = HCR.VM OR HCR.DC;

    // VTCR.S must match VTCR.T0SZ[3]
    if walkparams.s != walkparams.t0sz&lt;3&gt; then
        (-, walkparams.t0sz) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESVTCRS" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESVTCRS</a>, 4);

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.GetVARange"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.GetVARange</h3>
      <p class="pseudocode">// AArch32.GetVARange()
// ====================
// Select the translation base address for stage 1 long-descriptor walks

VARange <a id="AArch32.GetVARange.3"/>AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)
    // Lower range Input Address size
    lo_iasize = <a href="shared_pseudocode.html#AArch32.S1IASize.1" title="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(t0sz);
    // Upper range Input Address size
    up_iasize = <a href="shared_pseudocode.html#AArch32.S1IASize.1" title="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(t1sz);

    if t1sz == '000' &amp;&amp; t0sz == '000' then
        return <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    elsif t1sz == '000' then
        return if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:lo_iasize&gt;) then <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> else <a href="shared_pseudocode.html#VARange_UPPER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a>;
    elsif t0sz == '000' then
        return if <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(va&lt;31:up_iasize&gt;) then <a href="shared_pseudocode.html#VARange_UPPER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a> else <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:lo_iasize&gt;) then
        return <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(va&lt;31:up_iasize&gt;) then
        return <a href="shared_pseudocode.html#VARange_UPPER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a>;
    else
        // Will be reported as a Translation Fault
        return <a href="shared_pseudocode.html#VARange" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> UNKNOWN;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.S1DCacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.S1DCacheEnabled</h3>
      <p class="pseudocode">// AArch32.S1DCacheEnabled()
// =========================
// Determine cacheability of stage 1 data accesses

boolean <a id="AArch32.S1DCacheEnabled.1"/>AArch32.S1DCacheEnabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> return SCTLR_S.C == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return HSCTLR.C == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return (if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.C else SCTLR.C) == '1';</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.S1ICacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.S1ICacheEnabled</h3>
      <p class="pseudocode">// AArch32.S1ICacheEnabled()
// =========================
// Determine cacheability of stage 1 instruction fetches

boolean <a id="AArch32.S1ICacheEnabled.1"/>AArch32.S1ICacheEnabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> return SCTLR_S.I == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return HSCTLR.I == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return (if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.I else SCTLR.I) == '1';</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.S1TTWParamsEL10"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.S1TTWParamsEL10</h3>
      <p class="pseudocode">// AArch32.S1TTWParamsEL10()
// =========================
// Gather stage 1 translation table walk parameters for EL1&amp;0 regime
// (with EL2 enabled or disabled).

S1TTWParams AArch32.S1TTWParamsEL10(bits(32) va)
    bits(64) mair;
    bit sif;
    TTBCR_Type ttbcr;
    TTBCR2_Type ttbcr2;
    SCTLR_Type sctlr;

    if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        ttbcr  = TTBCR_NS;
        ttbcr2 = TTBCR2_NS;
        sctlr  = SCTLR_NS;
        mair   = MAIR1_NS:MAIR0_NS;
        sif    = SCR.SIF;
    else
        ttbcr  = TTBCR;
        ttbcr2 = TTBCR2;
        sctlr  = SCTLR;
        mair   = MAIR1:MAIR0;
        sif    = SCR_EL3.SIF;

    assert ttbcr.EAE == '1';
    S1TTWParams walkparams;

    walkparams.t0sz   = ttbcr.T0SZ;
    walkparams.t1sz   = ttbcr.T1SZ;
    walkparams.ee     = sctlr.EE;
    walkparams.wxn    = sctlr.WXN;
    walkparams.uwxn   = sctlr.UWXN;
    walkparams.ntlsmd = if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then sctlr.nTLSMD else '1';
    walkparams.mair   = mair;
    walkparams.sif    = sif;

    varange = <a href="shared_pseudocode.html#AArch32.GetVARange.3" title="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, walkparams.t0sz, walkparams.t1sz);
    if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
        walkparams.sh   = ttbcr.SH0;
        walkparams.irgn = ttbcr.IRGN0;
        walkparams.orgn = ttbcr.ORGN0;
        walkparams.hpd  = if <a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then ttbcr.T2E AND ttbcr2.HPD0 else '0';
    else
        walkparams.sh   = ttbcr.SH1;
        walkparams.irgn = ttbcr.IRGN1;
        walkparams.orgn = ttbcr.ORGN1;
        walkparams.hpd  = if <a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then ttbcr.T2E AND ttbcr2.HPD1 else '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.S1TTWParamsEL2"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.S1TTWParamsEL2</h3>
      <p class="pseudocode">// AArch32.S1TTWParamsEL2()
// ========================
// Gather stage 1 translation table walk parameters for EL2 regime

S1TTWParams AArch32.S1TTWParamsEL2()
    S1TTWParams walkparams;

    walkparams.tgx  = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    walkparams.t0sz = HTCR.T0SZ;
    walkparams.irgn = HTCR.SH0;
    walkparams.orgn = HTCR.IRGN0;
    walkparams.sh   = HTCR.ORGN0;
    walkparams.hpd  = if <a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then HTCR.HPD else '0';
    walkparams.ee   = HSCTLR.EE;
    walkparams.wxn  = HSCTLR.WXN;
    if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        walkparams.ntlsmd = HSCTLR.nTLSMD;
    else
        walkparams.ntlsmd = '1';

    walkparams.mair = HMAIR1:HMAIR0;

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.S1TTWParamsEL30"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.S1TTWParamsEL30</h3>
      <p class="pseudocode">// AArch32.S1TTWParamsEL30()
// =========================
// Gather stage 1 translation table walk parameters for EL3&amp;0 regime

S1TTWParams AArch32.S1TTWParamsEL30(bits(32) va)
    assert TTBCR_S.EAE == '1';
    S1TTWParams walkparams;

    walkparams.t0sz   = TTBCR_S.T0SZ;
    walkparams.t1sz   = TTBCR_S.T1SZ;
    walkparams.ee     = SCTLR_S.EE;
    walkparams.wxn    = SCTLR_S.WXN;
    walkparams.uwxn   = SCTLR_S.UWXN;
    walkparams.ntlsmd = if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then SCTLR_S.nTLSMD else '1';
    walkparams.mair   = MAIR1_S:MAIR0_S;
    walkparams.sif    = SCR.SIF;

    varange = <a href="shared_pseudocode.html#AArch32.GetVARange.3" title="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, walkparams.t0sz, walkparams.t1sz);
    if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
        walkparams.sh   = TTBCR_S.SH0;
        walkparams.irgn = TTBCR_S.IRGN0;
        walkparams.orgn = TTBCR_S.ORGN0;
        walkparams.hpd  = if <a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then TTBCR_S.T2E AND TTBCR2_S.HPD0 else '0';
    else
        walkparams.sh   = TTBCR_S.SH1;
        walkparams.irgn = TTBCR_S.IRGN1;
        walkparams.orgn = TTBCR_S.ORGN1;
        walkparams.hpd  = if <a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then TTBCR_S.T2E AND TTBCR2_S.HPD1 else '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBCycleCountingEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBCycleCountingEnabled</h3>
      <p class="pseudocode">// BRBCycleCountingEnabled()
// =========================
// Returns TRUE if the BRBINF&lt;n&gt;_EL1.{CCU, CC} fields are valid, FALSE otherwise.

boolean <a id="impl-aarch64.BRBCycleCountingEnabled.0"/>BRBCycleCountingEnabled()
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; BRBCR_EL2.CC == '0' then return FALSE;
    if BRBCR_EL1.CC == '0' then return FALSE;
    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEBranch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEBranch</h3>
      <p class="pseudocode">// BRBEBranch()
// ============
// Called to write branch record for the following branches when BRB is active:
// direct branches,
// indirect branches,
// direct branches with link,
// indirect branches with link,
// returns from subroutines.

<a id="impl-aarch64.BRBEBranch.3"/>BRBEBranch(<a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> br_type, boolean cond, bits(64) target_address)
    if <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(PSTATE.EL) &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.FilterBranchRecord.2" title="function: boolean FilterBranchRecord(BranchType br, boolean cond)">FilterBranchRecord</a>(br_type, cond) then
        bits(6) branch_type;
        case br_type of
            when <a href="shared_pseudocode.html#BranchType_DIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIR</a>
                branch_type = if cond then '001000' else '000000';
            when <a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>      branch_type = '000001';
            when <a href="shared_pseudocode.html#BranchType_DIRCALL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIRCALL</a>    branch_type = '000010';
            when <a href="shared_pseudocode.html#BranchType_INDCALL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDCALL</a>    branch_type = '000011';
            when <a href="shared_pseudocode.html#BranchType_RET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RET</a>        branch_type = '000101';
            otherwise                  <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

        bit ccu;
        bits(14) cc;
        (ccu, cc) = <a href="shared_pseudocode.html#impl-aarch64.BranchEncCycleCount.0" title="function: (bit, bits(14)) BranchEncCycleCount()">BranchEncCycleCount</a>();
        bit lastfailed = if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then BRBFCR_EL1.LASTFAILED else '0';
        bit transactional = if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then '1' else '0';
        bits(2) el = PSTATE.EL;
        bit mispredict = if <a href="shared_pseudocode.html#impl-aarch64.BRBEMispredictAllowed.0" title="function: boolean BRBEMispredictAllowed()">BRBEMispredictAllowed</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.BranchMispredict.0" title="function: boolean BranchMispredict()">BranchMispredict</a>() then '1' else '0';

        <a href="shared_pseudocode.html#impl-aarch64.UpdateBranchRecordBuffer.10" title="function: UpdateBranchRecordBuffer(bit ccu, bits(14) cc, bit lastfailed, bit transactional, bits(6) branch_type, bits(2) el,&#13; bit mispredict, bits(2) valid, bits(64) source_address, bits(64) target_address)">UpdateBranchRecordBuffer</a>(ccu, cc, lastfailed, transactional, branch_type, el, mispredict,
                                 '11', <a href="shared_pseudocode.html#impl-aarch64.PC.read.0" title="accessor: bits(64) PC[]">PC</a>[], target_address);

        BRBFCR_EL1.LASTFAILED = '0';

        <a href="shared_pseudocode.html#impl-shared.PMUEvent.1" title="function: PMUEvent(bits(16) event)">PMUEvent</a>(PMU_EVENT_BRB_FILTRATE);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEBranchOnISB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEBranchOnISB</h3>
      <p class="pseudocode">// BRBEBranchOnISB()
// =================
// Returns TRUE if ISBs generate Branch records, and FALSE otherwise.

boolean <a id="impl-aarch64.BRBEBranchOnISB.0"/>BRBEBranchOnISB()
    return boolean IMPLEMENTATION_DEFINED "ISB generates Branch records";</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEDebugStateExit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEDebugStateExit</h3>
      <p class="pseudocode">// BRBEDebugStateExit()
// ====================
// Called to write Debug state exit branch record when BRB is active.

<a id="impl-aarch64.BRBEDebugStateExit.1"/>BRBEDebugStateExit(bits(64) target_address)
    if <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(PSTATE.EL) then
        // Debug state is a prohibited region, therefore ccu=1, cc=0, source_address=0
        bits(6) branch_type = '111001';
        bit ccu = '1';
        bits(14) cc = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(14);
        bit lastfailed = if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then BRBFCR_EL1.LASTFAILED else '0';
        bit transactional = '0';
        bits(2) el = PSTATE.EL;
        bit mispredict = '0';

        <a href="shared_pseudocode.html#impl-aarch64.UpdateBranchRecordBuffer.10" title="function: UpdateBranchRecordBuffer(bit ccu, bits(14) cc, bit lastfailed, bit transactional, bits(6) branch_type, bits(2) el,&#13; bit mispredict, bits(2) valid, bits(64) source_address, bits(64) target_address)">UpdateBranchRecordBuffer</a>(ccu, cc, lastfailed, transactional, branch_type, el, mispredict,
                                 '01', <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64), target_address);

        BRBFCR_EL1.LASTFAILED = '0';

        <a href="shared_pseudocode.html#impl-shared.PMUEvent.1" title="function: PMUEvent(bits(16) event)">PMUEvent</a>(PMU_EVENT_BRB_FILTRATE);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEException</h3>
      <p class="pseudocode">// BRBEException()
// ===============
// Called to write exception branch record when BRB is active.

<a id="impl-aarch64.BRBEException.5"/>BRBEException(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exception, bits(64) preferred_exception_return,
              bits(64) target_address_in, bits(2) target_el, boolean trappedsyscallinst)
    bits(64) target_address = target_address_in;
    case target_el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  if !<a href="shared_pseudocode.html#impl-shared.HaveBRBEv1p1.0" title="function: boolean HaveBRBEv1p1()">HaveBRBEv1p1</a>() || (MDCR_EL3.E3BREC == MDCR_EL3.E3BREW) then return;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  if BRBCR_EL2.EXCEPTION == '0' then return;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  if BRBCR_EL1.EXCEPTION == '0' then return;

    boolean source_valid = <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(PSTATE.EL);
    boolean target_valid = <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(target_el);

    if source_valid || target_valid then
        bits(6) branch_type;
        case exception of
            when <a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>        branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>              branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>           branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>          branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>           branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>           branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>  branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>             branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACTrap</a>              branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_TSTARTAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_TSTARTAccessTrap</a>     branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>          branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>         branch_type = '101011'; // Inst Fault
            when <a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>         branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>
                if !trappedsyscallinst then     branch_type = '100010'; // Call
                else                            branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>       branch_type = '100010'; // Call
            when <a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>
                if !trappedsyscallinst then     branch_type = '100010'; // Call
                else                            branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_SystemRegisterTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SystemRegisterTrap</a>   branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_SVEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SVEAccessTrap</a>        branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_SMEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SMEAccessTrap</a>        branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_ERetTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_ERetTrap</a>             branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_PACFail" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACFail</a>              branch_type = '101100'; // Data Fault
            when <a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>     branch_type = '101011'; // Inst Fault
            when <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>          branch_type = '101010'; // Alignment
            when <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>            branch_type = '101100'; // Data Fault
            when <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>         branch_type = '101100'; // Data Fault
            when <a href="shared_pseudocode.html#Exception_SPAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SPAlignment</a>          branch_type = '101010'; // Alignment
            when <a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPTrappedException</a>   branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>               branch_type = '100100'; // System Error
            when <a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>           branch_type = '100110'; // Inst debug
            when <a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>         branch_type = '100110'; // Inst debug
            when <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>           branch_type = '100111'; // Data debug
            when <a href="shared_pseudocode.html#Exception_NV2Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>        branch_type = '100111'; // Data debug
            when <a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a>   branch_type = '100110'; // Inst debug
            when <a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>                  branch_type = '101110'; // IRQ
            when <a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>                  branch_type = '101111'; // FIQ
            when <a href="shared_pseudocode.html#Exception_MemCpyMemSet" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MemCpyMemSet</a>         branch_type = '100011'; // Trap
            otherwise                           <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

        bit ccu;
        bits(14) cc;
        (ccu, cc) = <a href="shared_pseudocode.html#impl-aarch64.BranchEncCycleCount.0" title="function: (bit, bits(14)) BranchEncCycleCount()">BranchEncCycleCount</a>();
        bit lastfailed = if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then BRBFCR_EL1.LASTFAILED else '0';
        bit transactional = if source_valid &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then '1' else '0';
        bits(2) el = if target_valid then target_el else '00';
        bit mispredict = '0';
        bit sv = if source_valid then '1' else '0';
        bit tv = if target_valid then '1' else '0';
        bits(64) source_address = if source_valid then preferred_exception_return else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

        if !target_valid then
            target_address = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        else
            target_address = <a href="shared_pseudocode.html#AArch64.BranchAddr.2" title="function: bits(64) AArch64.BranchAddr(bits(64) vaddress, bits(2) el)">AArch64.BranchAddr</a>(target_address, target_el);

        <a href="shared_pseudocode.html#impl-aarch64.UpdateBranchRecordBuffer.10" title="function: UpdateBranchRecordBuffer(bit ccu, bits(14) cc, bit lastfailed, bit transactional, bits(6) branch_type, bits(2) el,&#13; bit mispredict, bits(2) valid, bits(64) source_address, bits(64) target_address)">UpdateBranchRecordBuffer</a>(ccu, cc, lastfailed, transactional, branch_type, el, mispredict,
                                 sv:tv, source_address, target_address);

        BRBFCR_EL1.LASTFAILED = '0';

        <a href="shared_pseudocode.html#impl-shared.PMUEvent.1" title="function: PMUEvent(bits(16) event)">PMUEvent</a>(PMU_EVENT_BRB_FILTRATE);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEExceptionReturn</h3>
      <p class="pseudocode">// BRBEExceptionReturn()
// =====================
// Called to write exception return branch record when BRB is active.

<a id="impl-aarch64.BRBEExceptionReturn.2"/>BRBEExceptionReturn(bits(64) target_address_in, bits(2) source_el)
    bits(64) target_address = target_address_in;
    case source_el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  if !<a href="shared_pseudocode.html#impl-shared.HaveBRBEv1p1.0" title="function: boolean HaveBRBEv1p1()">HaveBRBEv1p1</a>() || (MDCR_EL3.E3BREC == MDCR_EL3.E3BREW) then return;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  if BRBCR_EL2.ERTN == '0' then return;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  if BRBCR_EL1.ERTN == '0' then return;

    boolean source_valid = <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(source_el);
    boolean target_valid = <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(PSTATE.EL);

    if source_valid || target_valid then
        bits(6) branch_type = '000111';
        bit ccu;
        bits(14) cc;
        (ccu, cc) = <a href="shared_pseudocode.html#impl-aarch64.BranchEncCycleCount.0" title="function: (bit, bits(14)) BranchEncCycleCount()">BranchEncCycleCount</a>();
        bit lastfailed = if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then BRBFCR_EL1.LASTFAILED else '0';
        bit transactional = if source_valid &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then '1' else '0';
        bits(2) el = if target_valid then PSTATE.EL else '00';
        bit mispredict = if source_valid &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.BRBEMispredictAllowed.0" title="function: boolean BRBEMispredictAllowed()">BRBEMispredictAllowed</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.BranchMispredict.0" title="function: boolean BranchMispredict()">BranchMispredict</a>() then '1' else '0';
        bit sv = if source_valid then '1' else '0';
        bit tv = if target_valid then '1' else '0';
        bits(64) source_address = if source_valid then <a href="shared_pseudocode.html#impl-aarch64.PC.read.0" title="accessor: bits(64) PC[]">PC</a>[] else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        if !target_valid then
            target_address = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

        <a href="shared_pseudocode.html#impl-aarch64.UpdateBranchRecordBuffer.10" title="function: UpdateBranchRecordBuffer(bit ccu, bits(14) cc, bit lastfailed, bit transactional, bits(6) branch_type, bits(2) el,&#13; bit mispredict, bits(2) valid, bits(64) source_address, bits(64) target_address)">UpdateBranchRecordBuffer</a>(ccu, cc, lastfailed, transactional, branch_type, el, mispredict,
                                 sv:tv, source_address, target_address);

        BRBFCR_EL1.LASTFAILED = '0';

        <a href="shared_pseudocode.html#impl-shared.PMUEvent.1" title="function: PMUEvent(bits(16) event)">PMUEvent</a>(PMU_EVENT_BRB_FILTRATE);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEFreeze"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEFreeze</h3>
      <p class="pseudocode">// BRBEFreeze()
// ============
// Generates BRBE freeze event.

<a id="impl-aarch64.BRBEFreeze.0"/>BRBEFreeze()
    BRBFCR_EL1.PAUSED = '1';
    BRBTS_EL1 = <a href="shared_pseudocode.html#impl-shared.GetTimestamp.1" title="function: bits(64) GetTimestamp(TimeStamp timeStampType)">GetTimestamp</a>(<a href="shared_pseudocode.html#impl-aarch64.BRBETimeStamp.0" title="function: TimeStamp BRBETimeStamp()">BRBETimeStamp</a>());</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEISB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEISB</h3>
      <p class="pseudocode">// BRBEISB()
// =========
// Handles ISB instruction for BRBE.

<a id="impl-aarch64.BRBEISB.0"/>BRBEISB()
    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-aarch64.BRBEBranch.3" title="function: BRBEBranch(BranchType br_type, boolean cond, bits(64) target_address)">BRBEBranch</a>(<a href="shared_pseudocode.html#BranchType_DIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIR</a>, branch_conditional, <a href="shared_pseudocode.html#impl-aarch64.PC.read.0" title="accessor: bits(64) PC[]">PC</a>[] + 4);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEMispredictAllowed"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEMispredictAllowed</h3>
      <p class="pseudocode">// BRBEMispredictAllowed()
// =======================
// Returns TRUE if the recording of branch misprediction is allowed, FALSE otherwise.

boolean <a id="impl-aarch64.BRBEMispredictAllowed.0"/>BRBEMispredictAllowed()
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; BRBCR_EL2.MPRED == '0' then return FALSE;
    if BRBCR_EL1.MPRED == '0' then return FALSE;
    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBETimeStamp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBETimeStamp</h3>
      <p class="pseudocode">// BRBETimeStamp()
// ===============
// Returns captured timestamp.

TimeStamp <a id="impl-aarch64.BRBETimeStamp.0"/>BRBETimeStamp()
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        TS_el2 = BRBCR_EL2.TS;
        if !<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; TS_el2 == '10' then
            // Reserved value
            (-, TS_el2) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_EL2TIMESTAMP" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_EL2TIMESTAMP</a>, 2);
        case TS_el2 of
            when '00'
                // Falls out to check BRBCR_EL1.TS
            when '01'
                return <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
            when '10'
                assert <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>(); // Otherwise ConstrainUnpredictableBits removes this case
                return <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
            when '11'
                return <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;

    TS_el1 = BRBCR_EL1.TS;
    if TS_el1 == '00' || (!<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; TS_el1 == '10') then
        // Reserved value
        (-, TS_el1) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_EL1TIMESTAMP" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_EL1TIMESTAMP</a>, 2);
    case TS_el1 of
        when '01'
            return <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
        when '10'
            return <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
        when '11'
            return <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();           // ConstrainUnpredictableBits removes this case</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRB_IALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRB_IALL</h3>
      <p class="pseudocode">// BRB_IALL()
// ==========
// Called to perform invalidation of branch records

<a id="impl-aarch64.BRB_IALL.0"/>BRB_IALL()
    for i = 0 to <a href="shared_pseudocode.html#impl-aarch64.GetBRBENumRecords.0" title="function: integer GetBRBENumRecords()">GetBRBENumRecords</a>() - 1
        Records_SRC[i] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        Records_TGT[i] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        Records_INF[i] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRB_INJ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRB_INJ</h3>
      <p class="pseudocode">// BRB_INJ()
// =========
// Called to perform manual injection of branch records.

<a id="impl-aarch64.BRB_INJ.0"/>BRB_INJ()
    <a href="shared_pseudocode.html#impl-aarch64.UpdateBranchRecordBuffer.10" title="function: UpdateBranchRecordBuffer(bit ccu, bits(14) cc, bit lastfailed, bit transactional, bits(6) branch_type, bits(2) el,&#13; bit mispredict, bits(2) valid, bits(64) source_address, bits(64) target_address)">UpdateBranchRecordBuffer</a>(BRBINFINJ_EL1.CCU, BRBINFINJ_EL1.CC, BRBINFINJ_EL1.LASTFAILED,
                             BRBINFINJ_EL1.T, BRBINFINJ_EL1.TYPE, BRBINFINJ_EL1.EL,
                             BRBINFINJ_EL1.MPRED, BRBINFINJ_EL1.VALID, BRBSRCINJ_EL1.ADDRESS,
                             BRBTGTINJ_EL1.ADDRESS);
    BRBINFINJ_EL1 = bits(64) UNKNOWN;
    BRBSRCINJ_EL1 = bits(64) UNKNOWN;
    BRBTGTINJ_EL1 = bits(64) UNKNOWN;

    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BRBFILTRATE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_BRBFILTRATE</a>) then <a href="shared_pseudocode.html#impl-shared.PMUEvent.1" title="function: PMUEvent(bits(16) event)">PMUEvent</a>(PMU_EVENT_BRB_FILTRATE);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.Branch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/Branch</h3>
      <p class="pseudocode">type <a id="BRBSRCType"/>BRBSRCType;
type <a id="BRBTGTType"/>BRBTGTType;
type <a id="BRBINFType"/>BRBINFType;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BranchEncCycleCount"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BranchEncCycleCount</h3>
      <p class="pseudocode">// The first return result is '1' if either of the following is true, and '0' otherwise:
// - This is the first Branch record after the PE exited a Prohibited Region.
// - This is the first Branch record after cycle counting has been enabled.
// If the first return return is '0', the second return result is the encoded cycle count
// since the last branch.
// The format of this field uses a mantissa and exponent to express the cycle count value.
//  - bits[7:0] indicate the mantissa M.
//  - bits[13:8] indicate the exponent E.
// The cycle count is expressed using the following function:
//   cycle_count = (if IsZero(E) then UInt(M) else UInt('1':M:Zeros(UInt(E)-1)))
// A value of all ones in both the mantissa and exponent indicates the cycle count value
// exceeded the size of the cycle counter.
// If the cycle count is not known, the second return result is zero.
(bit, bits(14)) <a id="impl-aarch64.BranchEncCycleCount.0"/>BranchEncCycleCount();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BranchMispredict"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BranchMispredict</h3>
      <p class="pseudocode">// Returns TRUE if the branch being executed was mispredicted, FALSE otherwise.
boolean <a id="impl-aarch64.BranchMispredict.0"/>BranchMispredict();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BranchRawCycleCount"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BranchRawCycleCount</h3>
      <p class="pseudocode">// If the cycle count is known, the return result is the cycle count since the last branch.
integer <a id="impl-aarch64.BranchRawCycleCount.0"/>BranchRawCycleCount();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BranchRecordAllowed"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BranchRecordAllowed</h3>
      <p class="pseudocode">// BranchRecordAllowed()
// =====================
// Returns TRUE if branch recording is allowed, FALSE otherwise.

boolean <a id="impl-aarch64.BranchRecordAllowed.1"/>BranchRecordAllowed(bits(2) el)
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el) then
        return FALSE;

    if BRBFCR_EL1.PAUSED == '1' then
        return FALSE;

    if el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveBRBEv1p1.0" title="function: boolean HaveBRBEv1p1()">HaveBRBEv1p1</a>() then
        return (MDCR_EL3.E3BREC != MDCR_EL3.E3BREW);

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; (MDCR_EL3.SBRBE == '00' ||
        (<a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; MDCR_EL3.SBRBE == '01')) then
        return FALSE;

    case el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  return FALSE;                // FEAT_BRBEv1p1 not implemented
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  return BRBCR_EL2.E2BRE == '1';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  return BRBCR_EL1.E1BRE == '1';
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
                return BRBCR_EL2.E0HBRE == '1';
            else
                return BRBCR_EL1.E0BRE == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.Contents"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/Contents</h3>
      <p class="pseudocode">array [0..63] of <a href="shared_pseudocode.html#BRBSRCType" title="type BRBSRCType">BRBSRCType</a> Records_SRC;

array [0..63] of <a href="shared_pseudocode.html#BRBTGTType" title="type BRBTGTType">BRBTGTType</a> Records_TGT;

array [0..63] of <a href="shared_pseudocode.html#BRBINFType" title="type BRBINFType">BRBINFType</a> Records_INF;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.FilterBranchRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/FilterBranchRecord</h3>
      <p class="pseudocode">// FilterBranchRecord()
// ====================
// Returns TRUE if the branch record is not filtered out, FALSE otherwise.

boolean <a id="impl-aarch64.FilterBranchRecord.2"/>FilterBranchRecord(<a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> br, boolean cond)
    case br of
        when <a href="shared_pseudocode.html#BranchType_DIRCALL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIRCALL</a>
            return BRBFCR_EL1.DIRCALL != BRBFCR_EL1.EnI;
        when <a href="shared_pseudocode.html#BranchType_INDCALL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDCALL</a>
            return BRBFCR_EL1.INDCALL != BRBFCR_EL1.EnI;
        when <a href="shared_pseudocode.html#BranchType_RET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RET</a>
            return BRBFCR_EL1.RTN != BRBFCR_EL1.EnI;
        when <a href="shared_pseudocode.html#BranchType_DIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIR</a>
            if cond then
                return BRBFCR_EL1.CONDDIR != BRBFCR_EL1.EnI;
            else
                return BRBFCR_EL1.DIRECT != BRBFCR_EL1.EnI;
        when <a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>
            return BRBFCR_EL1.INDIRECT != BRBFCR_EL1.EnI;
        otherwise  <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.FirstBranchAfterProhibited"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/FirstBranchAfterProhibited</h3>
      <p class="pseudocode">// Returns TRUE if branch recorded is the first branch after a prohibited region,
// FALSE otherwise.
<a id="impl-aarch64.FirstBranchAfterProhibited.0"/>FirstBranchAfterProhibited();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.GetBRBENumRecords"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/GetBRBENumRecords</h3>
      <p class="pseudocode">// GetBRBENumRecords()
// ===================
// Returns the number of branch records implemented.

integer <a id="impl-aarch64.GetBRBENumRecords.0"/>GetBRBENumRecords()
    assert <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(BRBIDR0_EL1.NUMREC) IN {0x08, 0x10, 0x20, 0x40};
    return integer IMPLEMENTATION_DEFINED "Number of BRB records";</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.Getter"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/Getter</h3>
      <p class="pseudocode">// Getter functions for branch records
// ===================================
// Functions used by MRS instructions that access branch records

BRBSRCType <a id="impl-aarch64.BRBSRC_EL1.read.1"/>BRBSRC_EL1[integer n]
    assert n IN {0..31};
    integer record = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(BRBFCR_EL1.BANK:n&lt;4:0&gt;);
    if record &lt; <a href="shared_pseudocode.html#impl-aarch64.GetBRBENumRecords.0" title="function: integer GetBRBENumRecords()">GetBRBENumRecords</a>() then
        return Records_SRC[record];
    else
        return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

BRBTGTType <a id="impl-aarch64.BRBTGT_EL1.read.1"/>BRBTGT_EL1[integer n]
    assert n IN {0..31};
    integer record = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(BRBFCR_EL1.BANK:n&lt;4:0&gt;);
    if record &lt; <a href="shared_pseudocode.html#impl-aarch64.GetBRBENumRecords.0" title="function: integer GetBRBENumRecords()">GetBRBENumRecords</a>() then
        return Records_TGT[record];
    else
        return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

BRBINFType <a id="impl-aarch64.BRBINF_EL1.read.1"/>BRBINF_EL1[integer n]
    assert n IN {0..31};
    integer record = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(BRBFCR_EL1.BANK:n&lt;4:0&gt;);
    if record &lt; <a href="shared_pseudocode.html#impl-aarch64.GetBRBENumRecords.0" title="function: integer GetBRBENumRecords()">GetBRBENumRecords</a>() then
        return Records_INF[record];
    else
        return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.ShouldBRBEFreeze"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/ShouldBRBEFreeze</h3>
      <p class="pseudocode">// ShouldBRBEFreeze()
// ==================
// Returns TRUE if the BRBE freeze event conditions have been met, and FALSE otherwise.

boolean <a id="impl-aarch64.ShouldBRBEFreeze.0"/>ShouldBRBEFreeze()
    if !<a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(PSTATE.EL) then return FALSE;
    boolean check_e      = FALSE;
    boolean check_cnten  = FALSE;
    boolean check_inten  = FALSE;
    boolean exclude_sync = FALSE;
    boolean exclude_cyc  = TRUE;
    boolean include_lo;
    boolean include_hi;

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        include_lo = (BRBCR_EL1.FZP == '1');
        include_hi = (BRBCR_EL2.FZP == '1');
    else
        include_lo = TRUE;
        include_hi = TRUE;

    return <a href="shared_pseudocode.html#impl-shared.PMUOverflowCondition.7" title="function: boolean PMUOverflowCondition(boolean check_e, boolean check_cnten,&#13; boolean check_inten,&#13; boolean include_hi, boolean include_lo,&#13; boolean exclude_cyc, boolean exclude_sync)">PMUOverflowCondition</a>(check_e, check_cnten, check_inten,
                                include_hi, include_lo, exclude_cyc,
                                exclude_sync);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.UpdateBranchRecordBuffer"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/UpdateBranchRecordBuffer</h3>
      <p class="pseudocode">// UpdateBranchRecordBuffer()
// ==========================
// Add a new Branch record to the buffer.

<a id="impl-aarch64.UpdateBranchRecordBuffer.10"/>UpdateBranchRecordBuffer(bit ccu, bits(14) cc, bit lastfailed, bit transactional, bits(6) branch_type, bits(2) el,
                         bit mispredict, bits(2) valid, bits(64) source_address, bits(64) target_address)
    // Shift the Branch Records in the buffer
    for i = <a href="shared_pseudocode.html#impl-aarch64.GetBRBENumRecords.0" title="function: integer GetBRBENumRecords()">GetBRBENumRecords</a>() - 1 downto 1
        Records_SRC[i] = Records_SRC[i - 1];
        Records_TGT[i] = Records_TGT[i - 1];
        Records_INF[i] = Records_INF[i - 1];

    Records_INF[0].CCU        = ccu;
    Records_INF[0].CC         = cc;

    Records_INF[0].EL         = el;
    Records_INF[0].VALID      = valid;
    Records_INF[0].T          = transactional;
    Records_INF[0].LASTFAILED = lastfailed;
    Records_INF[0].MPRED      = mispredict;
    Records_INF[0].TYPE       = branch_type;

    Records_SRC[0] = source_address;
    Records_TGT[0] = target_address;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.AArch64.BreakpointMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/AArch64.BreakpointMatch</h3>
      <p class="pseudocode">// AArch64.BreakpointMatch()
// =========================
// Breakpoint matching in an AArch64 translation regime.

boolean <a id="AArch64.BreakpointMatch.4"/>AArch64.BreakpointMatch(integer n, bits(64) vaddress, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc,
                                integer size)
    assert !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt; <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>();

    enabled = <a href="shared_pseudocode.html#impl-aarch64.IsBreakpointEnabled.1" title="function: boolean IsBreakpointEnabled(integer n)">IsBreakpointEnabled</a>(n);
    linked  = DBGBCR_EL1[n].BT IN {'0x01'};
    isbreakpnt = TRUE;
    linked_to  = FALSE;

    ssce = if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then DBGBCR_EL1[n].SSCE else '0';
    state_match = <a href="shared_pseudocode.html#AArch64.StateMatch.8" title="function: boolean AArch64.StateMatch(bits(2) ssc_in, bit ssce_in, bit hmc_in,&#13; bits(2) pxc_in, boolean linked_in, bits(4) lbn,&#13; boolean isbreakpnt, AccessDescriptor accdesc)">AArch64.StateMatch</a>(DBGBCR_EL1[n].SSC, ssce, DBGBCR_EL1[n].HMC, DBGBCR_EL1[n].PMC,
                                     linked, DBGBCR_EL1[n].LBN, isbreakpnt, accdesc);
    value_match = <a href="shared_pseudocode.html#AArch64.BreakpointValueMatch.3" title="function: boolean AArch64.BreakpointValueMatch(integer n_in, bits(64) vaddress, boolean linked_to)">AArch64.BreakpointValueMatch</a>(n, vaddress, linked_to);

    if <a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() &amp;&amp; size == 4 then                    // Check second halfword
        // If the breakpoint address and BAS of an Address breakpoint match the address of the
        // second halfword of an instruction, but not the address of the first halfword, it is
        // CONSTRAINED UNPREDICTABLE whether or not this breakpoint generates a Breakpoint debug
        // event.
        match_i = <a href="shared_pseudocode.html#AArch64.BreakpointValueMatch.3" title="function: boolean AArch64.BreakpointValueMatch(integer n_in, bits(64) vaddress, boolean linked_to)">AArch64.BreakpointValueMatch</a>(n, vaddress + 2, linked_to);
        if !value_match &amp;&amp; match_i then
            value_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_BPMATCHHALF</a>);

    if vaddress&lt;1&gt; == '1' &amp;&amp; DBGBCR_EL1[n].BAS == '1111' then
        // The above notwithstanding, if DBGBCR_EL1[n].BAS == '1111', then it is CONSTRAINED
        // UNPREDICTABLE whether or not a Breakpoint debug event is generated for an instruction
        // at the address DBGBVR_EL1[n]+2.
        if value_match then value_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_BPMATCHHALF</a>);

    match = value_match &amp;&amp; state_match &amp;&amp; enabled;

    return match;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.AArch64.BreakpointValueMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/AArch64.BreakpointValueMatch</h3>
      <p class="pseudocode">// AArch64.BreakpointValueMatch()
// ==============================

boolean <a id="AArch64.BreakpointValueMatch.3"/>AArch64.BreakpointValueMatch(integer n_in, bits(64) vaddress, boolean linked_to)

    // "n" is the identity of the breakpoint unit to match against.
    // "vaddress" is the current instruction address, ignored if linked_to is TRUE and for Context
    //   matching breakpoints.
    // "linked_to" is TRUE if this is a call from StateMatch for linking.
    integer n = n_in;

    // If a non-existent breakpoint then it is CONSTRAINED UNPREDICTABLE whether this gives
    // no match or the breakpoint is mapped to another UNKNOWN implemented breakpoint.
    if n &gt;= <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() then
        <a href="shared_pseudocode.html#Constraint" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
        (c, n) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high,&#13; Unpredictable which)">ConstrainUnpredictableInteger</a>(0, <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1,
                                               <a href="shared_pseudocode.html#Unpredictable_BPNOTIMPL" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_BPNOTIMPL</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return FALSE;

    // If this breakpoint is not enabled, it cannot generate a match. (This could also happen on a
    // call from StateMatch for linking).
    if !<a href="shared_pseudocode.html#impl-aarch64.IsBreakpointEnabled.1" title="function: boolean IsBreakpointEnabled(integer n)">IsBreakpointEnabled</a>(n) then return FALSE;

    context_aware = <a href="shared_pseudocode.html#impl-shared.IsContextMatchingBreakpoint.1" title="function: boolean IsContextMatchingBreakpoint(integer n)">IsContextMatchingBreakpoint</a>(n);

    // If BT is set to a reserved type, behaves either as disabled or as a not-reserved type.
    dbgtype = DBGBCR_EL1[n].BT;

    if ((dbgtype IN {'011x','11xx'} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveV82Debug.0" title="function: boolean HaveV82Debug()">HaveV82Debug</a>()) ||      // Context matching
          dbgtype IN {'010x'} ||                                                      // Reserved
          (!(dbgtype IN {'0x0x'}) &amp;&amp; !context_aware) ||                               // Context matching
          (dbgtype IN {'1xxx'} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>))) then                                 // EL2 extension
        <a href="shared_pseudocode.html#Constraint" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
        (c, dbgtype) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESBPTYPE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESBPTYPE</a>, 4);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return FALSE;
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    // Determine what to compare against.
    match_addr = (dbgtype IN {'0x0x'});
    match_vmid = (dbgtype IN {'10xx'});
    match_cid  = (dbgtype IN {'001x'});
    match_cid1 = (dbgtype IN {'101x', 'x11x'});
    match_cid2 = (dbgtype IN {'11xx'});
    linked     = (dbgtype IN {'xxx1'});

    // If this is a call from StateMatch, return FALSE if the breakpoint is not programmed for a
    // VMID and/or context ID match, of if not context-aware. The above assertions mean that the
    // code can just test for match_addr == TRUE to confirm all these things.
    if linked_to &amp;&amp; (!linked || match_addr) then return FALSE;

    // If called from BreakpointMatch return FALSE for Linked context ID and/or VMID matches.
    if !linked_to &amp;&amp; linked &amp;&amp; !match_addr then return FALSE;

    boolean bvr_match  = FALSE;
    boolean bxvr_match = FALSE;

    // Do the comparison.
    if match_addr then
        boolean byte_select_match;
        integer byte = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;1:0&gt;);

        if <a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() then
            // T32 instructions can be executed at EL0 in an AArch64 translation regime.
            assert byte IN {0,2};                 // "vaddress" is halfword aligned
            byte_select_match = (DBGBCR_EL1[n].BAS&lt;byte&gt; == '1');
        else
            assert byte == 0;                     // "vaddress" is word aligned
            byte_select_match = TRUE;             // DBGBCR_EL1[n].BAS&lt;byte&gt; is RES1

        // If the DBGBVR_EL1[n].RESS field bits are not a sign extension of the MSB
        // of DBGBVR_EL1[n].VA, it is UNPREDICTABLE whether they appear to be
        // included in the match.
        // If 'vaddress' is outside of the current virtual address space, then the access
        // generates a Translation fault.
        integer top = <a href="shared_pseudocode.html#AArch64.VAMax.0" title="function: integer AArch64.VAMax()">AArch64.VAMax</a>();
        if !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGBVR_EL1[n]&lt;63:top&gt;) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGBVR_EL1[n]&lt;63:top&gt;) then
            if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_DBGxVR_RESS" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_DBGxVR_RESS</a>) then
                top = 63;
        bvr_match = (vaddress&lt;top:2&gt; == DBGBVR_EL1[n]&lt;top:2&gt;) &amp;&amp; byte_select_match;

    elsif match_cid then
        if <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            bvr_match = (CONTEXTIDR_EL2&lt;31:0&gt; == DBGBVR_EL1[n]&lt;31:0&gt;);
        else
            bvr_match = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; CONTEXTIDR_EL1&lt;31:0&gt; == DBGBVR_EL1[n]&lt;31:0&gt;);

    elsif match_cid1 then
        bvr_match = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp;
                     CONTEXTIDR_EL1&lt;31:0&gt; == DBGBVR_EL1[n]&lt;31:0&gt;);

    if match_vmid then
        bits(16) vmid;
        bits(16) bvr_vmid;

        if !<a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()">Have16bitVMID</a>() || VTCR_EL2.VS == '0' then
            vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0&gt;, 16);
            bvr_vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DBGBVR_EL1[n]&lt;39:32&gt;, 16);
        else
            vmid     = VTTBR_EL2.VMID;
            bvr_vmid = DBGBVR_EL1[n]&lt;47:32&gt;;

        bxvr_match = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; vmid == bvr_vmid);

    elsif match_cid2 then
        bxvr_match = (PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                      DBGBVR_EL1[n]&lt;63:32&gt; == CONTEXTIDR_EL2&lt;31:0&gt;);

    bvr_match_valid  = (match_addr || match_cid || match_cid1);
    bxvr_match_valid = (match_vmid || match_cid2);

    match = (!bxvr_match_valid || bxvr_match) &amp;&amp; (!bvr_match_valid || bvr_match);

    return match;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.AArch64.StateMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/AArch64.StateMatch</h3>
      <p class="pseudocode">// AArch64.StateMatch()
// ====================
// Determine whether a breakpoint or watchpoint is enabled in the current mode and state.

boolean <a id="AArch64.StateMatch.8"/>AArch64.StateMatch(bits(2) ssc_in, bit ssce_in, bit hmc_in,
                           bits(2) pxc_in, boolean linked_in, bits(4) lbn,
                           boolean isbreakpnt, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    if !<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then assert ssce_in == '0';

    // "ssc_in","ssce_in","hmc_in","pxc_in" are the control fields from
    // the DBGBCR_EL1[n] or DBGWCR_EL1[n] register.
    // "linked_in" is TRUE if this is a linked breakpoint/watchpoint type.
    // "lbn" is the linked breakpoint number from the DBGBCR_EL1[n] or DBGWCR_EL1[n] register.
    // "isbreakpnt" is TRUE for breakpoints, FALSE for watchpoints.
    // "accdesc" describes the properties of the access being matched.
    bits(2) ssc = ssc_in;
    bit ssce    = ssce_in;
    bit hmc     = hmc_in;
    bits(2) pxc = pxc_in;
    boolean linked = linked_in;

    // If parameters are set to a reserved type, behaves as either disabled or a defined type
    <a href="shared_pseudocode.html#Constraint" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
    (c, ssc, ssce, hmc, pxc) = <a href="shared_pseudocode.html#impl-shared.CheckValidStateMatch.5" title="function: (Constraint, bits(2), bit, bit, bits(2)) CheckValidStateMatch(bits(2) ssc_in, bit ssce_in, bit hmc_in,&#13; bits(2) pxc_in, boolean isbreakpnt)">CheckValidStateMatch</a>(ssc, ssce, hmc, pxc, isbreakpnt);
    if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return FALSE;
    // Otherwise the hmc,ssc,ssce,pxc values are either valid or the values returned by
    // CheckValidStateMatch are valid.

    EL3_match = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; hmc == '1' &amp;&amp; ssc&lt;0&gt; == '0';
    EL2_match = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; ((hmc == '1' &amp;&amp; (ssc:pxc != '1000')) || ssc == '11');
    EL1_match = pxc&lt;0&gt; == '1';
    EL0_match = pxc&lt;1&gt; == '1';

    boolean priv_match;
    case accdesc.el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  priv_match = EL3_match;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  priv_match = EL2_match;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  priv_match = EL1_match;
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  priv_match = EL0_match;

    // Security state match
    boolean ss_match;
    case ssce:ssc of
        when '000' ss_match = hmc == '1' || accdesc.ss != <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>;
        when '001' ss_match = accdesc.ss == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
        when '010' ss_match = (hmc == '1' &amp;&amp; accdesc.ss == <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>) || accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
        when '011' ss_match = (hmc == '1' &amp;&amp; accdesc.ss != <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>) || accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
        when '101' ss_match = accdesc.ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>;

    boolean linked_match = FALSE;

    if linked then
        // "lbn" must be an enabled context-aware breakpoint unit. If it is not context-aware then
        // it is CONSTRAINED UNPREDICTABLE whether this gives no match, gives a match without linking,
        // or lbn is mapped to some UNKNOWN breakpoint that is context-aware.
        integer linked_n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(lbn);

        if !<a href="shared_pseudocode.html#impl-shared.IsContextMatchingBreakpoint.1" title="function: boolean IsContextMatchingBreakpoint(integer n)">IsContextMatchingBreakpoint</a>(linked_n) then
            (first_ctx_cmp, last_ctx_cmp) = <a href="shared_pseudocode.html#impl-shared.ContextMatchingBreakpointRange.0" title="function: (integer, integer) ContextMatchingBreakpointRange()">ContextMatchingBreakpointRange</a>();
            (c, linked_n) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high,&#13; Unpredictable which)">ConstrainUnpredictableInteger</a>(first_ctx_cmp, last_ctx_cmp,
                                                         <a href="shared_pseudocode.html#Unpredictable_BPNOTCTXCMP" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_BPNOTCTXCMP</a>);
            assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};

            case c of
                when <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>  return FALSE;      // Disabled
                when <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>      linked = FALSE;    // No linking
                // Otherwise ConstrainUnpredictableInteger returned a context-aware breakpoint

        vaddress  = bits(64) UNKNOWN;
        linked_to = TRUE;
        linked_match = <a href="shared_pseudocode.html#AArch64.BreakpointValueMatch.3" title="function: boolean AArch64.BreakpointValueMatch(integer n_in, bits(64) vaddress, boolean linked_to)">AArch64.BreakpointValueMatch</a>(linked_n, vaddress, linked_to);

    return priv_match &amp;&amp; ss_match &amp;&amp; (!linked || linked_match);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.EffectiveMDSELR_EL1_BANK"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/EffectiveMDSELR_EL1_BANK</h3>
      <p class="pseudocode">// EffectiveMDSELR_EL1_BANK()
// ==========================
// Return the effective value of MDSELR_EL1.BANK.

bits(2) <a id="impl-aarch64.EffectiveMDSELR_EL1_BANK.0"/>EffectiveMDSELR_EL1_BANK()
    if !<a href="shared_pseudocode.html#impl-aarch64.SelfHostedExtendedBPWPEnabled.0" title="function: boolean SelfHostedExtendedBPWPEnabled()">SelfHostedExtendedBPWPEnabled</a>() then
        return '00';

    return MDSELR_EL1.BANK;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.IsBreakpointEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/IsBreakpointEnabled</h3>
      <p class="pseudocode">// IsBreakpointEnabled()
// =====================
// Returns TRUE if the effective value of DBGBCR_EL1[n].E is '1', and FALSE otherwise.

boolean <a id="impl-aarch64.IsBreakpointEnabled.1"/>IsBreakpointEnabled(integer n)
    if (n &gt; 15 &amp;&amp;
            ((!<a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.SelfHostedExtendedBPWPEnabled.0" title="function: boolean SelfHostedExtendedBPWPEnabled()">SelfHostedExtendedBPWPEnabled</a>()) ||
            (<a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() &amp;&amp; EDSCR2.EBWE == '0'))) then
        return FALSE;

    return DBGBCR_EL1[n].E == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.SelfHostedExtendedBPWPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/SelfHostedExtendedBPWPEnabled</h3>
      <p class="pseudocode">// SelfHostedExtendedBPWPEnabled()
// ===============================
// Returns TRUE if the extended breakpoints and watchpoints are enabled, and FALSE otherwise
// from a self-hosted Debug perspective.

boolean <a id="impl-aarch64.SelfHostedExtendedBPWPEnabled.0"/>SelfHostedExtendedBPWPEnabled()
    if <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() &lt;= 16 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.NumWatchpointsImplemented.0" title="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>() &lt;= 16 then
        return FALSE;

    if ((<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; MDCR_EL3.EBWE == '0') ||
            (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; MDCR_EL2.EBWE == '0')) then
        return FALSE;

    return MDSCR_EL1.EBWE == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.enables.AArch64.GenerateDebugExceptions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/enables/AArch64.GenerateDebugExceptions</h3>
      <p class="pseudocode">// AArch64.GenerateDebugExceptions()
// =================================

boolean <a id="AArch64.GenerateDebugExceptions.0"/>AArch64.GenerateDebugExceptions()
    ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    return <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from_el, SecurityState from_state, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(PSTATE.EL, ss, PSTATE.D);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.enables.AArch64.GenerateDebugExceptionsFrom"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/enables/AArch64.GenerateDebugExceptionsFrom</h3>
      <p class="pseudocode">// AArch64.GenerateDebugExceptionsFrom()
// =====================================

boolean <a id="AArch64.GenerateDebugExceptionsFrom.3"/>AArch64.GenerateDebugExceptionsFrom(bits(2) from_el, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> from_state, bit mask)

    if OSLSR_EL1.OSLK == '1' || <a href="shared_pseudocode.html#impl-shared.DoubleLockStatus.0" title="function: boolean DoubleLockStatus()">DoubleLockStatus</a>() || <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then
        return FALSE;

    route_to_el2 = (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (from_state != <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> || <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) &amp;&amp;
                   (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));
    target = (if route_to_el2 then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    boolean enabled;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; from_state == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        enabled = MDCR_EL3.SDD == '0';
        if from_el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
            enabled = enabled || SDER32_EL3.SUIDEN == '1';
    else
        enabled = TRUE;

    if from_el == target then
        enabled = enabled &amp;&amp; MDSCR_EL1.KDE == '1' &amp;&amp; mask == '0';
    else
        enabled = enabled &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(from_el);

    return enabled;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.ite.AArch64.TRCIT"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/ite/AArch64.TRCIT</h3>
      <p class="pseudocode">// AArch64.TRCIT()
// ===============
// Determines whether an Instrumentation trace packet should
// be generated and then generates an instrumentation trace packet
// containing the value of the register passed as an argument

<a id="AArch64.TRCIT.1"/>AArch64.TRCIT(bits(64) Xt)
    ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    if <a href="shared_pseudocode.html#impl-shared.TraceInstrumentationAllowed.2" title="function: boolean TraceInstrumentationAllowed(SecurityState ss, bits(2) el)">TraceInstrumentationAllowed</a>(ss, PSTATE.EL) then
        <a href="shared_pseudocode.html#impl-aarch64.TraceInstrumentation.1" title="function: TraceInstrumentation(bits(64) Xt)">TraceInstrumentation</a>(Xt);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.ite.TraceInstrumentation"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/ite/TraceInstrumentation</h3>
      <p class="pseudocode">// Generates an instrumentation trace packet
// containing the value of the register passed as an argument
<a id="impl-aarch64.TraceInstrumentation.1"/>TraceInstrumentation(bits(64) Xt);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.ClearEventCounters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.ClearEventCounters</h3>
      <p class="pseudocode">// AArch64.ClearEventCounters()
// ============================
// Zero all the event counters.

<a id="AArch64.ClearEventCounters.0"/>AArch64.ClearEventCounters()
    integer counters = <a href="shared_pseudocode.html#AArch64.GetNumEventCountersAccessible.0" title="function: integer AArch64.GetNumEventCountersAccessible()">AArch64.GetNumEventCountersAccessible</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            PMEVCNTR_EL0[idx] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.CountPMUEvents"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.CountPMUEvents</h3>
      <p class="pseudocode">// AArch64.CountPMUEvents()
// ========================
// Return TRUE if counter "idx" should count its event.
// For the cycle counter, idx == CYCLE_COUNTER_ID.
// For the instruction counter, idx == INSTRUCTION_COUNTER_ID.

boolean <a id="AArch64.CountPMUEvents.1"/>AArch64.CountPMUEvents(integer idx)
    constant integer num_counters = <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    assert (idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> || idx &lt; num_counters ||
            (idx == <a href="shared_pseudocode.html#INSTRUCTION_COUNTER_ID" title="constant integer INSTRUCTION_COUNTER_ID = 32">INSTRUCTION_COUNTER_ID</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HavePMUv3ICNTR.0" title="function: boolean HavePMUv3ICNTR()">HavePMUv3ICNTR</a>()));

    boolean debug;
    boolean enabled;
    boolean prohibited;
    boolean filtered;
    boolean frozen;
    boolean resvd_for_el2;
    bit E;
    bit spme;
    bits(32) ovflws;
    // Event counting is disabled in Debug state
    debug = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();

    // Software can reserve some counters for EL2
    resvd_for_el2 = <a href="shared_pseudocode.html#AArch64.PMUCounterIsHyp.1" title="function: boolean AArch64.PMUCounterIsHyp(integer n)">AArch64.PMUCounterIsHyp</a>(idx);
    ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();

    // Main enable controls
    if idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        enabled = PMCR_EL0.E == '1' &amp;&amp; PMCNTENSET_EL0.C == '1';
    else
        E = if resvd_for_el2 then MDCR_EL2.HPME else PMCR_EL0.E;
        enabled = E == '1' &amp;&amp; PMCNTENSET_EL0&lt;idx&gt; == '1';

    // Event counting is allowed unless it is prohibited by any rule below
    prohibited = FALSE;

    // Event counting in Secure state is prohibited if all of:
    // * EL3 is implemented
    // * MDCR_EL3.SPME == 0, and either:
    //   - FEAT_PMUv3p7 is not implemented
    //   - MDCR_EL3.MPMX == 0
    // * Not executing at EL0 using AArch32, or EL1 is
    //   using AArch32 and SDER32_EL3.SUNIDEN == 0
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p7.0" title="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
            prohibited = MDCR_EL3.&lt;SPME,MPMX&gt; == '00';
        else
            prohibited = MDCR_EL3.SPME == '0';
        if prohibited &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
            prohibited = SDER32_EL3.SUNIDEN == '0';

    // Event counting at EL3 is prohibited if all of:
    // * FEAT_PMUv3p7 is implemented
    // * One of the following is true:
    //   - MDCR_EL3.SPME == 0
    //   - PMNx is not reserved for EL2
    // * MDCR_EL3.MPMX == 1
    if !prohibited &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HavePMUv3p7.0" title="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
        prohibited = MDCR_EL3.MPMX == '1' &amp;&amp; (MDCR_EL3.SPME == '0' || !resvd_for_el2);

    // Event counting at EL2 is prohibited if all of:
    // * The HPMD Extension is implemented
    // * PMNx is not reserved for EL2
    // * MDCR_EL2.HPMD == 1
    if !prohibited &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveHPMDExt.0" title="function: boolean HaveHPMDExt()">HaveHPMDExt</a>() &amp;&amp; !resvd_for_el2 then
        prohibited = MDCR_EL2.HPMD == '1';

    // The IMPLEMENTATION DEFINED authentication interface might override software
    if prohibited &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveNoSecurePMUDisableOverride.0" title="function: boolean HaveNoSecurePMUDisableOverride()">HaveNoSecurePMUDisableOverride</a>() then
        prohibited = !<a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>();

    // Event counting might be frozen
    frozen = FALSE;

    // If FEAT_PMUv3p7 is implemented, event counting can be frozen
    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p7.0" title="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
        bit FZ;
        if resvd_for_el2 then
            FZ = MDCR_EL2.HPMFZO;
        else
            FZ = PMCR_EL0.FZO;

        frozen = (FZ == '1') &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HiLoPMUOverflow.1" title="function: boolean HiLoPMUOverflow(boolean resvd_for_el2)">HiLoPMUOverflow</a>(resvd_for_el2);

    // PMCR_EL0.DP disables the cycle counter when event counting is prohibited
    if (prohibited || frozen) &amp;&amp; idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        enabled = enabled &amp;&amp; (PMCR_EL0.DP == '0');
        // Otherwise whether event counting is prohibited does not affect the cycle counter
        prohibited = FALSE;
        frozen = FALSE;

    // If FEAT_PMUv3p5 is implemented, cycle counting can be prohibited.
    // This is not overridden by PMCR_EL0.DP.
    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p5.0" title="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() &amp;&amp; idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        if (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp;
            MDCR_EL3.SCCD == '1') then
            prohibited = TRUE;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; MDCR_EL2.HCCD == '1' then
            prohibited = TRUE;

    // If FEAT_PMUv3p7 is implemented, cycle counting an be prohibited at EL3.
    // This is not overriden by PMCR_EL0.DP.
    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p7.0" title="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() &amp;&amp; idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; MDCR_EL3.MCCD == '1' then
            prohibited = TRUE;

    // Event counting can be filtered by the {P, U, NSK, NSU, NSH, M, SH, RLK, RLU, RLH} bits
    bits(32) filter;
    case idx of
        when <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>       filter = PMCCFILTR_EL0&lt;31:0&gt;;
        when <a href="shared_pseudocode.html#INSTRUCTION_COUNTER_ID" title="constant integer INSTRUCTION_COUNTER_ID = 32">INSTRUCTION_COUNTER_ID</a> filter = PMICFILTR_EL0&lt;31:0&gt;;
        otherwise                   filter = PMEVTYPER_EL0[idx]&lt;31:0&gt;;

    P   = filter&lt;31&gt;;
    U   = filter&lt;30&gt;;
    NSK = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;29&gt; else '0';
    NSU = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;28&gt; else '0';
    NSH = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then filter&lt;27&gt; else '0';
    M   = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;26&gt; else '0';
    SH  = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() then filter&lt;24&gt; else '0';
    RLK = if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then filter&lt;22&gt; else '0';
    RLU = if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then filter&lt;21&gt; else '0';
    RLH = if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then filter&lt;20&gt; else '0';

    ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            case ss of
                when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> filtered = U != NSU;
                when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    filtered = U == '1';
                when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     filtered = U != RLU;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            case ss of
                when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> filtered = P != NSK;
                when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    filtered = P == '1';
                when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     filtered = P != RLK;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            case ss of
                when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> filtered = NSH == '0';
                when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    filtered = NSH == SH;
                when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     filtered = NSH == RLH;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            filtered = M != P;

    return !debug &amp;&amp; enabled &amp;&amp; !prohibited &amp;&amp; !filtered &amp;&amp; !frozen;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.GetNumEventCountersAccessible"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.GetNumEventCountersAccessible</h3>
      <p class="pseudocode">// AArch64.GetNumEventCountersAccessible()
// =======================================
// Return the number of event counters that can be accessed at the current Exception level.

integer <a id="AArch64.GetNumEventCountersAccessible.0"/>AArch64.GetNumEventCountersAccessible()
    integer n;
    integer total_counters = <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    // Software can reserve some counters for EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN);
        if n &gt; total_counters || (!<a href="shared_pseudocode.html#impl-shared.HaveFeatHPMN0.0" title="function: boolean HaveFeatHPMN0()">HaveFeatHPMN0</a>() &amp;&amp; n == 0) then
            (-, n) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high,&#13; Unpredictable which)">ConstrainUnpredictableInteger</a>(0, total_counters,
                                                   <a href="shared_pseudocode.html#Unpredictable_PMUEVENTCOUNTER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_PMUEVENTCOUNTER</a>);
    else
        n = total_counters;

    return n;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.IncrementCycleCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.IncrementCycleCounter</h3>
      <p class="pseudocode">// AArch64.IncrementCycleCounter()
// ===============================
// Increment the cycle counter and possibly set overflow bits.

<a id="AArch64.IncrementCycleCounter.0"/>AArch64.IncrementCycleCounter()
    if (<a href="shared_pseudocode.html#AArch64.CountPMUEvents.1" title="function: boolean AArch64.CountPMUEvents(integer idx)">AArch64.CountPMUEvents</a>(<a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>) &amp;&amp;
        (!<a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() || PMCR_EL0.LC == '1' || PMCR_EL0.D == '0' || <a href="shared_pseudocode.html#impl-shared.HasElapsed64Cycles.0" title="function: boolean HasElapsed64Cycles()">HasElapsed64Cycles</a>())) then
        integer old_value = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMCCNTR_EL0);
        integer new_value = old_value + 1;
        PMCCNTR_EL0 = new_value&lt;63:0&gt;;

        integer ovflw;
        if <a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() then
            ovflw = if PMCR_EL0.LC == '1' then 64 else 32;
        else
            ovflw = 64;

        if old_value&lt;64:ovflw&gt; != new_value&lt;64:ovflw&gt; then
            PMOVSSET_EL0.C = '1';
            PMOVSCLR_EL0.C = '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.IncrementEventCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.IncrementEventCounter</h3>
      <p class="pseudocode">// AArch64.IncrementEventCounter()
// ===============================
// Increment the specified event counter by the specified amount.

<a id="AArch64.IncrementEventCounter.2"/>AArch64.IncrementEventCounter(integer idx, integer increment)
    integer old_value;
    integer new_value;
    integer ovflw;
    bit lp;
    old_value = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMEVCNTR_EL0[idx]);
    new_value = old_value + <a href="shared_pseudocode.html#impl-shared.PMUCountValue.2" title="function: integer PMUCountValue(integer n, integer v)">PMUCountValue</a>(idx, increment);

    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p5.0" title="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() then
        PMEVCNTR_EL0[idx] = new_value&lt;63:0&gt;;
        lp = if <a href="shared_pseudocode.html#AArch64.PMUCounterIsHyp.1" title="function: boolean AArch64.PMUCounterIsHyp(integer n)">AArch64.PMUCounterIsHyp</a>(idx) then MDCR_EL2.HLP else PMCR_EL0.LP;
        ovflw = if lp == '1' then 64 else 32;
    else
        PMEVCNTR_EL0[idx] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(new_value&lt;31:0&gt;, 64);
        ovflw = 32;

    if old_value&lt;64:ovflw&gt; != new_value&lt;64:ovflw&gt; then
        PMOVSSET_EL0&lt;idx&gt; = '1';
        PMOVSCLR_EL0&lt;idx&gt; = '1';
        // Check for the CHAIN event from an even counter
        if idx&lt;0&gt; == '0' &amp;&amp; idx + 1 &lt; <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>() &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HavePMUv3p5.0" title="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() || lp == '0') then
            <a href="shared_pseudocode.html#impl-shared.PMUEvent.3" title="function: PMUEvent(bits(16) event, integer increment, integer idx)">PMUEvent</a>(PMU_EVENT_CHAIN, 1, idx + 1);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.PMUCounterIsHyp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.PMUCounterIsHyp</h3>
      <p class="pseudocode">// AArch64.PMUCounterIsHyp
// =======================
// Returns TRUE if a counter is reserved for use by EL2, FALSE otherwise.

boolean <a id="AArch64.PMUCounterIsHyp.1"/>AArch64.PMUCounterIsHyp(integer n)
    if n == <a href="shared_pseudocode.html#INSTRUCTION_COUNTER_ID" title="constant integer INSTRUCTION_COUNTER_ID = 32">INSTRUCTION_COUNTER_ID</a> then return FALSE;
    if n == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then return FALSE;

    boolean resvd_for_el2;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then     // Software can reserve some event counters for EL2
        resvd_for_el2 = n &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN);
        if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN) &gt; <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>() || (!<a href="shared_pseudocode.html#impl-shared.HaveFeatHPMN0.0" title="function: boolean HaveFeatHPMN0()">HaveFeatHPMN0</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(MDCR_EL2.HPMN)) then
            resvd_for_el2 = boolean UNKNOWN;
    else
        resvd_for_el2 = FALSE;

    return resvd_for_el2;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.PMUCycle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.PMUCycle</h3>
      <p class="pseudocode">// AArch64.PMUCycle()
// ==================
// Called at the end of each cycle to increment event counters and
// check for PMU overflow. In pseudocode, a cycle ends after the
// execution of the operational pseudocode.

<a id="AArch64.PMUCycle.0"/>AArch64.PMUCycle()
    if !<a href="shared_pseudocode.html#impl-shared.HavePMUv3.0" title="function: boolean HavePMUv3()">HavePMUv3</a>() then
        return;

    <a href="shared_pseudocode.html#impl-shared.PMUEvent.1" title="function: PMUEvent(bits(16) event)">PMUEvent</a>(PMU_EVENT_CPU_CYCLES);

    integer counters = <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            if <a href="shared_pseudocode.html#AArch64.CountPMUEvents.1" title="function: boolean AArch64.CountPMUEvents(integer idx)">AArch64.CountPMUEvents</a>(idx) then
                integer accumulated = PMUEventAccumulator[idx];
                <a href="shared_pseudocode.html#AArch64.IncrementEventCounter.2" title="function: AArch64.IncrementEventCounter(integer idx, integer increment)">AArch64.IncrementEventCounter</a>(idx, accumulated);
            PMUEventAccumulator[idx] = 0;

    <a href="shared_pseudocode.html#AArch64.IncrementCycleCounter.0" title="function: AArch64.IncrementCycleCounter()">AArch64.IncrementCycleCounter</a>();
    <a href="shared_pseudocode.html#impl-shared.CheckForPMUOverflow.0" title="function: CheckForPMUOverflow()">CheckForPMUOverflow</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.PMUSwIncrement"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.PMUSwIncrement</h3>
      <p class="pseudocode">// AArch64.PMUSwIncrement()
// ========================
// Generate PMU Events on a write to PMSWINC_EL0.

<a id="AArch64.PMUSwIncrement.1"/>AArch64.PMUSwIncrement(bits(32) sw_incr)
    integer counters = <a href="shared_pseudocode.html#AArch64.GetNumEventCountersAccessible.0" title="function: integer AArch64.GetNumEventCountersAccessible()">AArch64.GetNumEventCountersAccessible</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            if sw_incr&lt;idx&gt; == '1' then
                <a href="shared_pseudocode.html#impl-shared.PMUEvent.3" title="function: PMUEvent(bits(16) event, integer increment, integer idx)">PMUEvent</a>(PMU_EVENT_SW_INCR, 1, idx);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CollectContextIDR1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CollectContextIDR1</h3>
      <p class="pseudocode">// CollectContextIDR1()
// ====================

boolean <a id="impl-aarch64.CollectContextIDR1.0"/>CollectContextIDR1()
    if !<a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>() then return FALSE;
    if  PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then return FALSE;
    return PMSCR_EL1.CX == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CollectContextIDR2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CollectContextIDR2</h3>
      <p class="pseudocode">// CollectContextIDR2()
// ====================

boolean <a id="impl-aarch64.CollectContextIDR2.0"/>CollectContextIDR2()
    if !<a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>() then return FALSE;
    if !<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then return FALSE;
    return PMSCR_EL2.CX == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CollectPhysicalAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CollectPhysicalAddress</h3>
      <p class="pseudocode">// CollectPhysicalAddress()
// ========================

boolean <a id="impl-aarch64.CollectPhysicalAddress.0"/>CollectPhysicalAddress()
    if !<a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>() then return FALSE;
    (owning_ss, owning_el) = <a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (SecurityState, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</a>();
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (owning_ss != <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> || <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) then
        return PMSCR_EL2.PA == '1' &amp;&amp; (owning_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || PMSCR_EL1.PA == '1');
    else
        return PMSCR_EL1.PA == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CollectTimeStamp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CollectTimeStamp</h3>
      <p class="pseudocode">// CollectTimeStamp()
// ==================

TimeStamp <a id="impl-aarch64.CollectTimeStamp.0"/>CollectTimeStamp()
    if !<a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>() then return <a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</a>;
    (-, owning_el) = <a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (SecurityState, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</a>();

    if owning_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        if PMSCR_EL2.TS == '0' then return <a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</a>;
    else
        if PMSCR_EL1.TS == '0' then return <a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</a>;

    bits(2) PCT_el1;
    if !<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() then
        PCT_el1 = '0':PMSCR_EL1.PCT&lt;0&gt;;       // PCT&lt;1&gt; is RES0
    else
        PCT_el1 = PMSCR_EL1.PCT;
        if PCT_el1 == '10' then
            // Reserved value
            (-, PCT_el1) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_PMSCR_PCT" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_PMSCR_PCT</a>, 2);
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        bits(2) PCT_el2;
        if !<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() then
            PCT_el2 = '0':PMSCR_EL2.PCT&lt;0&gt;;   // PCT&lt;1&gt; is RES0
        else
            PCT_el2 = PMSCR_EL2.PCT;
            if PCT_el2 == '10' then
                // Reserved value
                (-, PCT_el2) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_PMSCR_PCT" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_PMSCR_PCT</a>, 2);
        case PCT_el2 of
            when '00'
                return if <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a> else <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
            when '01'
                if owning_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then return <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;
            when '11'
                assert <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>();          // FEAT_ECV must be implemented
                if owning_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; PCT_el1 == '00' then
                    return if <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a> else <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
                else
                    return <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
            otherwise
                <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    case PCT_el1 of
        when '00' return if <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a> else <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
        when '01' return <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;
        when '11'
            assert <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>();              // FEAT_ECV must be implemented
            return <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.OpType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/OpType</h3>
      <p class="pseudocode">enumeration <a id="OpType"/>OpType {
    <a id="OpType_Load"/>OpType_Load,           // Any memory-read operation other than atomics, compare-and-swap, and swap
    <a id="OpType_Store"/>OpType_Store,          // Any memory-write operation, including atomics without return
    <a id="OpType_LoadAtomic"/>OpType_LoadAtomic,     // Atomics with return, compare-and-swap and swap
    <a id="OpType_Branch"/>OpType_Branch,         // Software write to the PC
    <a id="OpType_Other"/>OpType_Other           // Any other class of operation
};</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.ProfilingBufferEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/ProfilingBufferEnabled</h3>
      <p class="pseudocode">// ProfilingBufferEnabled()
// ========================

boolean <a id="impl-aarch64.ProfilingBufferEnabled.0"/>ProfilingBufferEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()">HaveStatisticalProfiling</a>() then return FALSE;
    (owning_ss, owning_el) = <a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (SecurityState, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</a>();
    bits(2) state_bits;
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        state_bits = SCR_EL3.&lt;NSE,NS&gt;;
    else
        state_bits = '0' : SCR_EL3.NS;

    boolean state_match;
    case owning_ss of
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    state_match = state_bits == '00';
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> state_match = state_bits == '01';
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     state_match = state_bits == '11';
    return (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(owning_el) &amp;&amp; state_match &amp;&amp;
            PMBLIMITR_EL1.E == '1' &amp;&amp; PMBSR_EL1.S == '0');</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.ProfilingBufferOwner"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/ProfilingBufferOwner</h3>
      <p class="pseudocode">// ProfilingBufferOwner()
// ======================

(SecurityState, bits(2)) <a id="impl-aarch64.ProfilingBufferOwner.0"/>ProfilingBufferOwner()
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> owning_ss;

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        bits(3) state_bits;
        if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
            state_bits = MDCR_EL3.&lt;NSPBE,NSPB&gt;;
            if state_bits IN {'10x'} then
                // Reserved value
                (-, state_bits) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESERVEDNSxB" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESERVEDNSxB</a>, 3);
        else
            state_bits = '0' : MDCR_EL3.NSPB;

        case state_bits of
            when '00x' owning_ss = <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
            when '01x' owning_ss = <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
            when '11x' owning_ss = <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>;
    else
        owning_ss = if <a href="shared_pseudocode.html#impl-shared.SecureOnlyImplementation.0" title="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</a>() then <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> else <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;

    bits(2) owning_el;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (owning_ss != <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> || <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) then
        owning_el = if MDCR_EL2.E2PB == '00' then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    else
        owning_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    return (owning_ss, owning_el);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.ProfilingSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/ProfilingSynchronizationBarrier</h3>
      <p class="pseudocode">// Barrier to ensure that all existing profiling data has been formatted, and profiling buffer
// addresses have been translated such that writes to the profiling buffer have been initiated.
// A following DSB completes when writes to the profiling buffer have completed.
<a id="impl-aarch64.ProfilingSynchronizationBarrier.0"/>ProfilingSynchronizationBarrier();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.StatisticalProfilingEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/StatisticalProfilingEnabled</h3>
      <p class="pseudocode">// StatisticalProfilingEnabled()
// =============================

boolean <a id="impl-aarch64.StatisticalProfilingEnabled.0"/>StatisticalProfilingEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()">HaveStatisticalProfiling</a>() || <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() || !<a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferEnabled.0" title="function: boolean ProfilingBufferEnabled()">ProfilingBufferEnabled</a>() then
        return FALSE;

    tge_set = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';
    (owning_ss, owning_el) = <a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (SecurityState, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</a>();
    if (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(owning_el) &lt;  <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) || (tge_set &amp;&amp; owning_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) ||
        owning_ss != <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>())  then
        return FALSE;
    bit spe_bit;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  spe_bit = PMSCR_EL2.E2SPE;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  spe_bit = PMSCR_EL1.E1SPE;
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  spe_bit = (if tge_set then PMSCR_EL2.E0HSPE else PMSCR_EL1.E0SPE);

    return spe_bit == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.TimeStamp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/TimeStamp</h3>
      <p class="pseudocode">enumeration <a id="TimeStamp"/>TimeStamp {
    <a id="TimeStamp_None"/>TimeStamp_None,              // No timestamp
    <a id="TimeStamp_CoreSight"/>TimeStamp_CoreSight,         // CoreSight time (IMPLEMENTATION DEFINED)
    <a id="TimeStamp_Physical"/>TimeStamp_Physical,          // Physical counter value with no offset
    <a id="TimeStamp_OffsetPhysical"/>TimeStamp_OffsetPhysical,    // Physical counter value minus CNTPOFF_EL2
    <a id="TimeStamp_Virtual"/>TimeStamp_Virtual  };        // Physical counter value minus CNTVOFF_EL2</p>
    </div>
    <div class="ps"><a id="aarch64.debug.takeexceptiondbg.AArch64.TakeExceptionInDebugState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/takeexceptiondbg/AArch64.TakeExceptionInDebugState</h3>
      <p class="pseudocode">// AArch64.TakeExceptionInDebugState()
// ===================================
// Take an exception in Debug state to an Exception level using AArch64.

<a id="AArch64.TakeExceptionInDebugState.2"/>AArch64.TakeExceptionInDebugState(bits(2) target_el, <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception_in)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception = exception_in;
    boolean sync_errors;
    boolean iesb_req;
    if <a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()">HaveIESB</a>() then
        sync_errors = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.1" title="accessor: SCTLRType SCTLR[bits(2) regime]">SCTLR</a>[target_el].IESB == '1';
        if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then
            sync_errors = sync_errors || (SCR_EL3.&lt;EA,NMEA&gt; == '11' &amp;&amp; target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        // SCTLR[].IESB and/or SCR_EL3.NMEA (if applicable) might be ignored in Debug state.
        if !<a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_IESBinDebug</a>) then
            sync_errors = FALSE;
    else
        sync_errors = FALSE;

    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then
        <a href="shared_pseudocode.html#TMFailure" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure</a> cause;
        case exception.exceptype of
            when <a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a> cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            when <a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>         cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            when <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>         cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            when <a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>       cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            otherwise                         cause = <a href="shared_pseudocode.html#TMFailure_ERR" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_ERR</a>;
        <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(cause, FALSE);

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();

    // If coming from AArch32 state, the top parts of the X[] registers might be set to zero
    from_32 = <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    if from_32 then <a href="shared_pseudocode.html#AArch64.MaybeZeroRegisterUppers.0" title="function: AArch64.MaybeZeroRegisterUppers()">AArch64.MaybeZeroRegisterUppers</a>();
    if from_32 &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' then
        <a href="shared_pseudocode.html#impl-aarch64.ResetSVEState.0" title="function: ResetSVEState()">ResetSVEState</a>();
    else
        <a href="shared_pseudocode.html#impl-aarch64.MaybeZeroSVEUppers.1" title="function: MaybeZeroSVEUppers(bits(2) target_el)">MaybeZeroSVEUppers</a>(target_el);

    <a href="shared_pseudocode.html#AArch64.ReportException.2" title="function: AArch64.ReportException(ExceptionRecord exception, bits(2) target_el)">AArch64.ReportException</a>(exception, target_el);

    PSTATE.EL = target_el;
    PSTATE.nRW = '0';
    PSTATE.SP = '1';

    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(64) UNKNOWN;
    <a href="shared_pseudocode.html#impl-aarch64.ELR.write.0" title="accessor: ELR[] = bits(64) value">ELR</a>[] = bits(64) UNKNOWN;

    // PSTATE.{SS,D,A,I,F} are not observable and ignored in Debug state, so behave as if UNKNOWN.
    PSTATE.&lt;SS,D,A,I,F&gt; = bits(5) UNKNOWN;
    PSTATE.IL = '0';
    if from_32 then                             // Coming from AArch32
        PSTATE.IT = '00000000';
        PSTATE.T = '0';                         // PSTATE.J is RES0
    if (<a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; (PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>))) &amp;&amp;
        <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SPAN == '0') then
        PSTATE.PAN = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then PSTATE.BTYPE = '00';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
    if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = '1';

    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(64) UNKNOWN;

    EDSCR.ERR = '1';
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR processor state flags.

    if sync_errors then
        <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()">SynchronizeErrors</a>();

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.watchpoint.AArch64.WatchpointByteMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/watchpoint/AArch64.WatchpointByteMatch</h3>
      <p class="pseudocode">// AArch64.WatchpointByteMatch()
// =============================

boolean <a id="AArch64.WatchpointByteMatch.2"/>AArch64.WatchpointByteMatch(integer n, bits(64) vaddress)

    integer top = <a href="shared_pseudocode.html#AArch64.VAMax.0" title="function: integer AArch64.VAMax()">AArch64.VAMax</a>();
    bottom = if DBGWVR_EL1[n]&lt;2&gt; == '1' then 2 else 3;            // Word or doubleword
    byte_select_match = (DBGWCR_EL1[n].BAS&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;bottom-1:0&gt;)&gt; != '0');
    mask = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGWCR_EL1[n].MASK);

    // If DBGWCR_EL1[n].MASK is non-zero value and DBGWCR_EL1[n].BAS is not set to '11111111', or
    // DBGWCR_EL1[n].BAS specifies a non-contiguous set of bytes behavior is CONSTRAINED
    // UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGWCR_EL1[n].BAS) then
        byte_select_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPMASKANDBAS" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_WPMASKANDBAS</a>);
    else
        LSB = (DBGWCR_EL1[n].BAS AND NOT(DBGWCR_EL1[n].BAS - 1));  MSB = (DBGWCR_EL1[n].BAS + LSB);
        if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(MSB AND (MSB - 1)) then                     // Not contiguous
            byte_select_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPBASCONTIGUOUS" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_WPBASCONTIGUOUS</a>);
            bottom = 3;                                        // For the whole doubleword

    // If the address mask is set to a reserved value, the behavior is CONSTRAINED UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; mask &lt;= 2 then
        <a href="shared_pseudocode.html#Constraint" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
        (c, mask) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high,&#13; Unpredictable which)">ConstrainUnpredictableInteger</a>(3, 31, <a href="shared_pseudocode.html#Unpredictable_RESWPMASK" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESWPMASK</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        case c of
            when <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>  return FALSE;            // Disabled
            when <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>      mask = 0;                // No masking
            // Otherwise the value returned by ConstrainUnpredictableInteger is a not-reserved value

    boolean WVR_match;
    if mask &gt; bottom then
        // If the DBGxVR&lt;n&gt;_EL1.RESS field bits are not a sign extension of the MSB
        // of DBGxVR&lt;n&gt;_EL1.VA, it is UNPREDICTABLE whether they appear to be
        // included in the match.
        if !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGWVR_EL1[n]&lt;63:top&gt;) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGWVR_EL1[n]&lt;63:top&gt;) then
            if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_DBGxVR_RESS" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_DBGxVR_RESS</a>) then
                top = 63;

        WVR_match = (vaddress&lt;top:mask&gt; == DBGWVR_EL1[n]&lt;top:mask&gt;);
        // If masked bits of DBGWVR_EL1[n] are not zero, the behavior is CONSTRAINED UNPREDICTABLE.
        if WVR_match &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGWVR_EL1[n]&lt;mask-1:bottom&gt;) then
            WVR_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPMASKEDBITS" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_WPMASKEDBITS</a>);
    else
        WVR_match = vaddress&lt;top:bottom&gt; == DBGWVR_EL1[n]&lt;top:bottom&gt;;

    return WVR_match &amp;&amp; byte_select_match;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.watchpoint.AArch64.WatchpointMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/watchpoint/AArch64.WatchpointMatch</h3>
      <p class="pseudocode">// AArch64.WatchpointMatch()
// =========================
// Watchpoint matching in an AArch64 translation regime.

boolean <a id="AArch64.WatchpointMatch.4"/>AArch64.WatchpointMatch(integer n, bits(64) vaddress, integer size,
                                <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    assert !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt; <a href="shared_pseudocode.html#impl-shared.NumWatchpointsImplemented.0" title="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>();

    enabled = <a href="shared_pseudocode.html#impl-aarch64.IsWatchpointEnabled.1" title="function: boolean IsWatchpointEnabled(integer n)">IsWatchpointEnabled</a>(n);
    linked = DBGWCR_EL1[n].WT == '1';
    isbreakpnt = FALSE;

    ssce = if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then DBGWCR_EL1[n].SSCE else '0';
    state_match = <a href="shared_pseudocode.html#AArch64.StateMatch.8" title="function: boolean AArch64.StateMatch(bits(2) ssc_in, bit ssce_in, bit hmc_in,&#13; bits(2) pxc_in, boolean linked_in, bits(4) lbn,&#13; boolean isbreakpnt, AccessDescriptor accdesc)">AArch64.StateMatch</a>(DBGWCR_EL1[n].SSC, ssce, DBGWCR_EL1[n].HMC, DBGWCR_EL1[n].PAC,
                                     linked, DBGWCR_EL1[n].LBN, isbreakpnt, accdesc);

    boolean ls_match;
    case DBGWCR_EL1[n].LSC&lt;1:0&gt; of
        when '00' ls_match = FALSE;
        when '01' ls_match = accdesc.read;
        when '10' ls_match = accdesc.write || accdesc.acctype == <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>;
        when '11' ls_match = TRUE;

    value_match = FALSE;
    for byte = 0 to size - 1
        value_match = value_match || <a href="shared_pseudocode.html#AArch64.WatchpointByteMatch.2" title="function: boolean AArch64.WatchpointByteMatch(integer n, bits(64) vaddress)">AArch64.WatchpointByteMatch</a>(n, vaddress + byte);

    return value_match &amp;&amp; state_match &amp;&amp; ls_match &amp;&amp; enabled;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.watchpoint.IsWatchpointEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/watchpoint/IsWatchpointEnabled</h3>
      <p class="pseudocode">// IsWatchpointEnabled()
// =====================
// Returns TRUE if the effective value of DBGBCR_EL1[n].E is '1', and FALSE otherwise.

boolean <a id="impl-aarch64.IsWatchpointEnabled.1"/>IsWatchpointEnabled(integer n)
    if (n &gt; 15 &amp;&amp;
            ((!<a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.SelfHostedExtendedBPWPEnabled.0" title="function: boolean SelfHostedExtendedBPWPEnabled()">SelfHostedExtendedBPWPEnabled</a>()) ||
            (<a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() &amp;&amp; EDSCR2.EBWE == '0'))) then
        return FALSE;
    return DBGWCR_EL1[n].E == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.Abort"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.Abort</h3>
      <p class="pseudocode">// AArch64.Abort()
// ===============
// Abort and Debug exception handling in an AArch64 translation regime.

<a id="AArch64.Abort.2"/>AArch64.Abort(bits(64) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)

    if <a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) then
        if fault.access.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
            if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fault.debugmoe == <a href="shared_pseudocode.html#DebugException_VectorCatch" title="constant bits(4) DebugException_VectorCatch = '0101'">DebugException_VectorCatch</a> then
                <a href="shared_pseudocode.html#AArch64.VectorCatchException.1" title="function: AArch64.VectorCatchException(FaultRecord fault)">AArch64.VectorCatchException</a>(fault);
            else
                <a href="shared_pseudocode.html#AArch64.BreakpointException.1" title="function: AArch64.BreakpointException(FaultRecord fault)">AArch64.BreakpointException</a>(fault);
        else
            <a href="shared_pseudocode.html#AArch64.WatchpointException.2" title="function: AArch64.WatchpointException(bits(64) vaddress, FaultRecord fault)">AArch64.WatchpointException</a>(vaddress, fault);
    elsif fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ReportAsGPCException.1" title="function: boolean ReportAsGPCException(FaultRecord fault)">ReportAsGPCException</a>(fault) then
        <a href="shared_pseudocode.html#impl-aarch64.TakeGPCException.2" title="function: TakeGPCException(bits(64) vaddress, FaultRecord fault)">TakeGPCException</a>(vaddress, fault);
    elsif fault.access.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        <a href="shared_pseudocode.html#AArch64.InstructionAbort.2" title="function: AArch64.InstructionAbort(bits(64) vaddress, FaultRecord fault)">AArch64.InstructionAbort</a>(vaddress, fault);
    else
        <a href="shared_pseudocode.html#AArch64.DataAbort.2" title="function: AArch64.DataAbort(bits(64) vaddress, FaultRecord fault)">AArch64.DataAbort</a>(vaddress, fault);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.AbortSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.AbortSyndrome</h3>
      <p class="pseudocode">// AArch64.AbortSyndrome()
// =======================
// Creates an exception syndrome record for Abort and Watchpoint exceptions
// from an AArch64 translation regime.

ExceptionRecord <a id="AArch64.AbortSyndrome.3"/>AArch64.AbortSyndrome(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault, bits(64) vaddress)
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(exceptype);

    d_side = exceptype IN {<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>, <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>, <a href="shared_pseudocode.html#Exception_NV2Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>};

    (exception.syndrome, exception.syndrome2) = <a href="shared_pseudocode.html#AArch64.FaultSyndrome.2" title="function: (bits(25), bits(24)) AArch64.FaultSyndrome(boolean d_side, FaultRecord fault)">AArch64.FaultSyndrome</a>(d_side, fault);

    if fault.statuscode == <a href="shared_pseudocode.html#Fault_TagCheck" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_TagCheck</a> then
        if <a href="shared_pseudocode.html#impl-shared.HaveMTE4Ext.0" title="function: boolean HaveMTE4Ext()">HaveMTE4Ext</a>() then
            exception.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(vaddress, 64);
        else
            exception.vaddress = bits(4) UNKNOWN : vaddress&lt;59:0&gt;;
    else
        exception.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(vaddress, 64);

    if <a href="shared_pseudocode.html#impl-shared.IPAValid.1" title="function: boolean IPAValid(FaultRecord fault)">IPAValid</a>(fault) then
        exception.ipavalid = TRUE;
        exception.NS = if fault.ipaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then '1' else '0';
        exception.ipaddress = fault.ipaddress.address;
    else
        exception.ipavalid = FALSE;

    return exception;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.CheckPCAlignment"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.CheckPCAlignment</h3>
      <p class="pseudocode">// AArch64.CheckPCAlignment()
// ==========================

<a id="AArch64.CheckPCAlignment.0"/>AArch64.CheckPCAlignment()
    bits(64) pc = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);

    if pc&lt;1:0&gt; != '00' then
        <a href="shared_pseudocode.html#AArch64.PCAlignmentFault.0" title="function: AArch64.PCAlignmentFault()">AArch64.PCAlignmentFault</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.DataAbort"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.DataAbort</h3>
      <p class="pseudocode">// AArch64.DataAbort()
// ===================

<a id="AArch64.DataAbort.2"/>AArch64.DataAbort(bits(64) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    bits(2) target_el;
    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then
        target_el = <a href="shared_pseudocode.html#AArch64.SyncExternalAbortTarget.1" title="function: bits(2) AArch64.SyncExternalAbortTarget(FaultRecord fault)">AArch64.SyncExternalAbortTarget</a>(fault);
    else
        route_to_el2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                        (HCR_EL2.TGE == '1' ||
                         (<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; fault.gpcf.gpf == <a href="shared_pseudocode.html#GPCF_Fail" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Fail</a> &amp;&amp; HCR_EL2.GPF == '1') ||
                         (<a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.access.acctype == <a href="shared_pseudocode.html#AccessType_NV2" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_NV2</a>) ||
                         <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));

        if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
        elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
            target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
        else
            target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    integer vect_offset;

    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) &amp;&amp; <a href="shared_pseudocode.html#AArch64.RouteToSErrorOffset.1" title="function: boolean AArch64.RouteToSErrorOffset(bits(2) target_el)">AArch64.RouteToSErrorOffset</a>(target_el) then
        vect_offset = 0x180;
    else
        vect_offset = 0x0;

    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
    if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.access.acctype == <a href="shared_pseudocode.html#AccessType_NV2" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_NV2</a> then
        exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>, fault, vaddress);
    else
        exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, fault, vaddress);
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.EffectiveTCF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.EffectiveTCF</h3>
      <p class="pseudocode">// AArch64.EffectiveTCF()
// ======================
// Returns the TCF field applied to tag check faults in the given Exception level.

bits(2) <a id="AArch64.EffectiveTCF.1"/>AArch64.EffectiveTCF(bits(2) el)
    bits(2) tcf;

    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.1" title="function: Regime TranslationRegime(bits(2) el)">TranslationRegime</a>(el);

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  tcf = SCTLR_EL3.TCF;
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  tcf = SCTLR_EL2.TCF;
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> tcf = if el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then SCTLR_EL2.TCF0 else SCTLR_EL2.TCF;
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> tcf = if el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then SCTLR_EL1.TCF0 else SCTLR_EL1.TCF;
        otherwise        <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    if tcf == '11' then        //reserved value
        if !<a href="shared_pseudocode.html#impl-shared.HaveMTEAsymFaultExt.0" title="function: boolean HaveMTEAsymFaultExt()">HaveMTEAsymFaultExt</a>() then
            (-,tcf) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESTCF" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESTCF</a>, 2);

    return tcf;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.InstructionAbort"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.InstructionAbort</h3>
      <p class="pseudocode">// AArch64.InstructionAbort()
// ==========================

<a id="AArch64.InstructionAbort.2"/>AArch64.InstructionAbort(bits(64) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    // External aborts on instruction fetch must be taken synchronously
    if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then assert fault.statuscode != <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>;

    bits(2) target_el;
    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then
        target_el = <a href="shared_pseudocode.html#AArch64.SyncExternalAbortTarget.1" title="function: bits(2) AArch64.SyncExternalAbortTarget(FaultRecord fault)">AArch64.SyncExternalAbortTarget</a>(fault);
    else
        route_to_el2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                        (HCR_EL2.TGE == '1' ||
                         (<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; fault.gpcf.gpf == <a href="shared_pseudocode.html#GPCF_Fail" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Fail</a> &amp;&amp; HCR_EL2.GPF == '1') ||
                         <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));

        if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
        elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
            target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
        else
            target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    integer vect_offset;

    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) &amp;&amp; <a href="shared_pseudocode.html#AArch64.RouteToSErrorOffset.1" title="function: boolean AArch64.RouteToSErrorOffset(bits(2) target_el)">AArch64.RouteToSErrorOffset</a>(target_el) then
        vect_offset = 0x180;
    else
        vect_offset = 0x0;

    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>, fault, vaddress);
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.PCAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.PCAlignmentFault</h3>
      <p class="pseudocode">// AArch64.PCAlignmentFault()
// ==========================
// Called on unaligned program counter in AArch64 state.

<a id="AArch64.PCAlignmentFault.0"/>AArch64.PCAlignmentFault()

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>);
    exception.vaddress = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    bits(2) target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.PhysicalSErrorTarget"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.PhysicalSErrorTarget</h3>
      <p class="pseudocode">// AArch64.PhysicalSErrorTarget()
// ==============================
// Returns a tuple of whether SError exception can be taken and, if so, the target Exception level.

(boolean, bits(2)) <a id="AArch64.PhysicalSErrorTarget.0"/>AArch64.PhysicalSErrorTarget()
    boolean route_to_el3;
    boolean route_to_el2;

    // The exception is explicitly routed to EL3.
    if PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        route_to_el3 = (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EA == '1');
    else
        route_to_el3 = FALSE;

    // The exception is explicitly routed to EL2.
    if !route_to_el3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
        route_to_el2 = (HCR_EL2.AMO == '1');
    elsif !route_to_el3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        route_to_el2 = (!<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; HCR_EL2.&lt;TGE,AMO&gt; != '00');
    else
        route_to_el2 = FALSE;

    // The exception is "masked".
    boolean masked;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            masked = (SCR_EL3.EA == '0' || PSTATE.A == '1');
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            masked = (!route_to_el3 &amp;&amp;
                      (HCR_EL2.&lt;TGE,AMO&gt; == '00' || PSTATE.A == '1'));
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            masked = (!route_to_el3 &amp;&amp; !route_to_el2 &amp;&amp; PSTATE.A == '1');

    // When FEAT_DoubleFault is implemented, the mask might be overridden.
    if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        bit nmea_bit = SCR_EL3.NMEA AND SCR_EL3.EA;
        masked = masked &amp;&amp; (nmea_bit == '0');

    // The exception is taken at EL3.
    take_in_el3 = PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; !masked;

    // The exception is taken at EL2 or in the Host EL0.
    take_in_el2_0 = ((PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) &amp;&amp;
                     !route_to_el3  &amp;&amp; !masked);

    // The exception is taken at EL1 or in the non-Host EL0.
    take_in_el1_0 = ((PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>())) &amp;&amp;
                     !route_to_el2 &amp;&amp; !route_to_el3 &amp;&amp; !masked);

    bits(2) target_el;
    if take_in_el3 || route_to_el3 then
        masked = FALSE;  target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif take_in_el2_0 || route_to_el2 then
        masked = FALSE;  target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    elsif take_in_el1_0 then
        masked = FALSE;  target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    else
        masked = TRUE;  target_el = bits(2) UNKNOWN;

    return (masked, target_el);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.RaiseTagCheckFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.RaiseTagCheckFault</h3>
      <p class="pseudocode">// AArch64.RaiseTagCheckFault()
// ============================
// Raise a tag check fault exception.

<a id="AArch64.RaiseTagCheckFault.2"/>AArch64.RaiseTagCheckFault(bits(64) va, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    integer vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, fault, va);

    bits(2) target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.ReportTagCheckFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.ReportTagCheckFault</h3>
      <p class="pseudocode">// AArch64.ReportTagCheckFault()
// =============================
// Records a tag check fault exception into the appropriate TFSR_ELx.

<a id="AArch64.ReportTagCheckFault.2"/>AArch64.ReportTagCheckFault(bits(2) el, bit ttbr)
    case el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> assert ttbr == '0'; TFSR_EL3.TF0   = '1';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> if ttbr == '0' then TFSR_EL2.TF0   = '1'; else TFSR_EL2.TF1   = '1';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> if ttbr == '0' then TFSR_EL1.TF0   = '1'; else TFSR_EL1.TF1   = '1';
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> if ttbr == '0' then TFSRE0_EL1.TF0 = '1'; else TFSRE0_EL1.TF1 = '1';</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.RouteToSErrorOffset"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.RouteToSErrorOffset</h3>
      <p class="pseudocode">// AArch64.RouteToSErrorOffset()
// =============================
// Returns TRUE if synchronous External abort exceptions are taken to the
// appropriate SError vector offset, and FALSE otherwise.

boolean <a id="AArch64.RouteToSErrorOffset.1"/>AArch64.RouteToSErrorOffset(bits(2) target_el)
    if !<a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then return FALSE;

    bit ease_bit;
    case target_el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            ease_bit = SCR_EL3.EASE;
        otherwise
            ease_bit = '0';

    return (ease_bit == '1');</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.SPAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.SPAlignmentFault</h3>
      <p class="pseudocode">// AArch64.SPAlignmentFault()
// ==========================
// Called on an unaligned stack pointer in AArch64 state.

<a id="AArch64.SPAlignmentFault.0"/>AArch64.SPAlignmentFault()

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SPAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SPAlignment</a>);

    bits(2) target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.SyncExternalAbortTarget"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.SyncExternalAbortTarget</h3>
      <p class="pseudocode">// AArch64.SyncExternalAbortTarget()
// =================================
// Returns the target Exception level for a Synchronous External
// Data or Instruction Abort.

bits(2) <a id="AArch64.SyncExternalAbortTarget.1"/>AArch64.SyncExternalAbortTarget(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    boolean route_to_el3;

    // The exception is explicitly routed to EL3
    if PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        route_to_el3 = (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EA == '1');
    else
        route_to_el3 = FALSE;

    // The exception is explicitly routed to EL2
    bit tea_bit = (if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() then HCR_EL2.TEA else '0');

    boolean route_to_el2;
    if !route_to_el3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
        route_to_el2 = (tea_bit == '1' ||
                        fault.access.acctype == <a href="shared_pseudocode.html#AccessType_NV2" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_NV2</a> ||
                        <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault));

    elsif !route_to_el3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        route_to_el2 = (!<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; (HCR_EL2.TGE == '1' || tea_bit == '1' ||
                        <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));
    else
        route_to_el2 = FALSE;

    // The exception is taken at EL3
    take_in_el3 = PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    // The exception is taken at EL2 or in the Host EL0
    take_in_el2_0 = ((PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) &amp;&amp;
                     !route_to_el3);

    // The exception is taken at EL1 or in the non-Host EL0
    take_in_el1_0 = ((PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>())) &amp;&amp;
                     !route_to_el2 &amp;&amp; !route_to_el3);

    bits(2) target_el;
    if take_in_el3 || route_to_el3  then
        target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif take_in_el2_0 || route_to_el2 then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    elsif take_in_el1_0 then
        target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    else
        assert(FALSE);

    return target_el;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.TagCheckFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.TagCheckFault</h3>
      <p class="pseudocode">// AArch64.TagCheckFault()
// =======================
// Handle a tag check fault condition.

<a id="AArch64.TagCheckFault.2"/>AArch64.TagCheckFault(bits(64) vaddress, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    bits(2) tcf;

    tcf = <a href="shared_pseudocode.html#AArch64.EffectiveTCF.1" title="function: bits(2) AArch64.EffectiveTCF(bits(2) el)">AArch64.EffectiveTCF</a>(accdesc.el);

    fault = <a href="shared_pseudocode.html#impl-shared.NoFault.1" title="function: FaultRecord NoFault(AccessDescriptor accdesc)">NoFault</a>(accdesc);
    fault.statuscode = <a href="shared_pseudocode.html#Fault_TagCheck" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_TagCheck</a>;

    case tcf of
        when '00'   // Tag Check Faults have no effect on the PE
            return;
        when '01'   // Tag Check Faults cause a synchronous exception
            <a href="shared_pseudocode.html#AArch64.RaiseTagCheckFault.2" title="function: AArch64.RaiseTagCheckFault(bits(64) va, FaultRecord fault)">AArch64.RaiseTagCheckFault</a>(vaddress, fault);
        when '10'
            if <a href="shared_pseudocode.html#impl-shared.HaveMTEAsyncExt.0" title="function: boolean HaveMTEAsyncExt()">HaveMTEAsyncExt</a>() then
                // If asynchronous faults are implemented,
                // Tag Check Faults are asynchronously accumulated
                <a href="shared_pseudocode.html#AArch64.ReportTagCheckFault.2" title="function: AArch64.ReportTagCheckFault(bits(2) el, bit ttbr)">AArch64.ReportTagCheckFault</a>(accdesc.el, vaddress&lt;55&gt;);
            else
                // Otherwise, Tag Check Faults have no effect on the PE.
                return;
        when '11'
            if <a href="shared_pseudocode.html#impl-shared.HaveMTEAsymFaultExt.0" title="function: boolean HaveMTEAsymFaultExt()">HaveMTEAsymFaultExt</a>() then
                // Tag Check Faults cause a synchronous exception on reads or on
                // a read/write access, and are asynchronously accumulated on writes
                if accdesc.read then
                    <a href="shared_pseudocode.html#AArch64.RaiseTagCheckFault.2" title="function: AArch64.RaiseTagCheckFault(bits(64) va, FaultRecord fault)">AArch64.RaiseTagCheckFault</a>(vaddress, fault);
                else
                    <a href="shared_pseudocode.html#AArch64.ReportTagCheckFault.2" title="function: AArch64.ReportTagCheckFault(bits(2) el, bit ttbr)">AArch64.ReportTagCheckFault</a>(accdesc.el, vaddress&lt;55&gt;);
            else
                // Otherwise, Tag Check Faults have no effect on the PE.
                return;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.BranchTargetException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/BranchTargetException</h3>
      <p class="pseudocode">// BranchTargetException()
// =======================
// Raise branch target exception.

<a id="AArch64.BranchTargetException.1"/>AArch64.BranchTargetException(bits(52) vaddress)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>);
    exception.syndrome&lt;1:0&gt;   = PSTATE.BTYPE;
    exception.syndrome&lt;24:2&gt;  = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(23);         // RES0

    bits(2) target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.TakeGPCException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/TakeGPCException</h3>
      <p class="pseudocode">// TakeGPCException()
// ==================
// Report Granule Protection Exception faults

<a id="impl-aarch64.TakeGPCException.2"/>TakeGPCException(bits(64) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    assert <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveAtomicExt.0" title="function: boolean HaveAtomicExt()">HaveAtomicExt</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>();

    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;

    exception.exceptype = <a href="shared_pseudocode.html#Exception_GPC" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_GPC</a>;
    exception.vaddress  = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(vaddress, 64);
    exception.paddress  = fault.paddress;

    if <a href="shared_pseudocode.html#impl-shared.IPAValid.1" title="function: boolean IPAValid(FaultRecord fault)">IPAValid</a>(fault) then
        exception.ipavalid  = TRUE;
        exception.NS        = if fault.ipaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then '1' else '0';
        exception.ipaddress = fault.ipaddress.address;
    else
        exception.ipavalid = FALSE;

    // Populate the fields grouped in ISS
    exception.syndrome&lt;24:22&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(3); // RES0
    exception.syndrome&lt;21&gt;    = if fault.gpcfs2walk then '1' else '0';  // S2PTW
    if fault.access.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        exception.syndrome&lt;20&gt; = '1'; // InD
    else
        exception.syndrome&lt;20&gt; = '0'; // InD
    exception.syndrome&lt;19:14&gt; = <a href="shared_pseudocode.html#impl-aarch64.EncodeGPCSC.1" title="function: bits(6) EncodeGPCSC(GPCFRecord gpcf)">EncodeGPCSC</a>(fault.gpcf); // GPCSC
    if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.access.acctype == <a href="shared_pseudocode.html#AccessType_NV2" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_NV2</a> then
        exception.syndrome&lt;13&gt; = '1'; // VNCR
    else
        exception.syndrome&lt;13&gt; = '0'; // VNCR
    exception.syndrome&lt;12:11&gt; = '00'; // RES0
    exception.syndrome&lt;10:9&gt;  = '00'; // RES0

    if fault.access.acctype IN {<a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>, <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_AT" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_AT</a>} then
        exception.syndrome&lt;8&gt; = '1'; // CM
    else
        exception.syndrome&lt;8&gt; = '0';  // CM

    exception.syndrome&lt;7&gt; = if fault.s2fs1walk then '1' else '0'; // S1PTW

    if fault.access.acctype IN {<a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>, <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_AT" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_AT</a>} then
        exception.syndrome&lt;6&gt; = '1';                              // WnR
    elsif fault.statuscode IN {<a href="shared_pseudocode.html#Fault_HWUpdateAccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_HWUpdateAccessFlag</a>, <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>} then
        exception.syndrome&lt;6&gt; = bit UNKNOWN;                      // WnR
    elsif fault.access.atomicop &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then
        exception.syndrome&lt;6&gt; = bit UNKNOWN;                      // WnR
    else
        exception.syndrome&lt;6&gt; = if fault.write then '1' else '0'; // WnR

    exception.syndrome&lt;5:0&gt; = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level); // xFSC

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    bits(2) target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    integer vect_offset;
    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) &amp;&amp; <a href="shared_pseudocode.html#AArch64.RouteToSErrorOffset.1" title="function: boolean AArch64.RouteToSErrorOffset(bits(2) target_el)">AArch64.RouteToSErrorOffset</a>(target_el) then
        vect_offset = 0x180;
    else
        vect_offset = 0x0;

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64.TakePhysicalFIQException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64.TakePhysicalFIQException</h3>
      <p class="pseudocode">// AArch64.TakePhysicalFIQException()
// ==================================

<a id="AArch64.TakePhysicalFIQException.0"/>AArch64.TakePhysicalFIQException()

    route_to_el3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.FIQ == '1';
    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || HCR_EL2.FMO == '1'));
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x100;
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>);

    if route_to_el3 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        assert PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64.TakePhysicalIRQException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64.TakePhysicalIRQException</h3>
      <p class="pseudocode">// AArch64.TakePhysicalIRQException()
// ==================================
// Take an enabled physical IRQ exception.

<a id="AArch64.TakePhysicalIRQException.0"/>AArch64.TakePhysicalIRQException()

    route_to_el3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.IRQ == '1';
    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || HCR_EL2.IMO == '1'));
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x80;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>);

    if route_to_el3 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        assert PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64.TakePhysicalSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64.TakePhysicalSErrorException</h3>
      <p class="pseudocode">// AArch64.TakePhysicalSErrorException()
// =====================================

<a id="AArch64.TakePhysicalSErrorException.1"/>AArch64.TakePhysicalSErrorException(boolean implicit_esb)

    route_to_el3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EA == '1';
    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || (!<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; HCR_EL2.AMO == '1')));
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x180;

    bits(2) target_el;
    if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> || route_to_el3 then
        target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>);
    bits(25) syndrome = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(25);
    syndrome = <a href="shared_pseudocode.html#AArch64.PhysicalSErrorSyndrome.1" title="function: bits(25) AArch64.PhysicalSErrorSyndrome(boolean implicit_esb)">AArch64.PhysicalSErrorSyndrome</a>(implicit_esb);
    if <a href="shared_pseudocode.html#impl-shared.IsSErrorEdgeTriggered.2" title="function: boolean IsSErrorEdgeTriggered(bits(2) target_el, bits(25) syndrome)">IsSErrorEdgeTriggered</a>(target_el, syndrome) then
        <a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();
    exception.syndrome = syndrome;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64.TakeVirtualFIQException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64.TakeVirtualFIQException</h3>
      <p class="pseudocode">// AArch64.TakeVirtualFIQException()
// =================================

<a id="AArch64.TakeVirtualFIQException.0"/>AArch64.TakeVirtualFIQException()
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.FMO == '1';  // Virtual IRQ enabled if TGE==0 and FMO==1

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x100;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>);

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64.TakeVirtualIRQException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64.TakeVirtualIRQException</h3>
      <p class="pseudocode">// AArch64.TakeVirtualIRQException()
// =================================

<a id="AArch64.TakeVirtualIRQException.0"/>AArch64.TakeVirtualIRQException()
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.IMO == '1';  // Virtual IRQ enabled if TGE==0 and IMO==1

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x80;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>);

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64.TakeVirtualSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64.TakeVirtualSErrorException</h3>
      <p class="pseudocode">// AArch64.TakeVirtualSErrorException()
// ====================================

<a id="AArch64.TakeVirtualSErrorException.0"/>AArch64.TakeVirtualSErrorException()

    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';  // Virtual SError enabled if TGE==0 and AMO==1

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x180;
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>);

    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() then
        exception.syndrome&lt;24&gt;   = VSESR_EL2.IDS;
        exception.syndrome&lt;23:0&gt; = VSESR_EL2.ISS;
    else
        bits(25) syndrome = bits(25) IMPLEMENTATION_DEFINED "Virtual SError syndrome";
        impdef_syndrome = syndrome&lt;24&gt; == '1';
        if impdef_syndrome then exception.syndrome = syndrome;

    <a href="shared_pseudocode.html#impl-shared.ClearPendingVirtualSError.0" title="function: ClearPendingVirtualSError()">ClearPendingVirtualSError</a>();
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64.BreakpointException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64.BreakpointException</h3>
      <p class="pseudocode">// AArch64.BreakpointException()
// =============================

<a id="AArch64.BreakpointException.1"/>AArch64.BreakpointException(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    assert PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    vaddress = bits(64) UNKNOWN;
    exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>, fault, vaddress);

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64.SoftwareBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64.SoftwareBreakpoint</h3>
      <p class="pseudocode">// AArch64.SoftwareBreakpoint()
// ============================

<a id="AArch64.SoftwareBreakpoint.1"/>AArch64.SoftwareBreakpoint(bits(16) immediate)

    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64.SoftwareStepException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64.SoftwareStepException</h3>
      <p class="pseudocode">// AArch64.SoftwareStepException()
// ===============================

<a id="AArch64.SoftwareStepException.0"/>AArch64.SoftwareStepException()
    assert PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>);
    if <a href="shared_pseudocode.html#impl-shared.SoftwareStep_DidNotStep.0" title="function: boolean SoftwareStep_DidNotStep()">SoftwareStep_DidNotStep</a>() then
        exception.syndrome&lt;24&gt; = '0';
    else
        exception.syndrome&lt;24&gt; = '1';
        exception.syndrome&lt;6&gt; = if <a href="shared_pseudocode.html#impl-shared.SoftwareStep_SteppedEX.0" title="function: boolean SoftwareStep_SteppedEX()">SoftwareStep_SteppedEX</a>() then '1' else '0';
    exception.syndrome&lt;5:0&gt; = '100010';                // IFSC = Debug Exception

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64.VectorCatchException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64.VectorCatchException</h3>
      <p class="pseudocode">// AArch64.VectorCatchException()
// ==============================
// Vector Catch taken from EL0 or EL1 to EL2. This can only be called when debug exceptions are
// being routed to EL2, as Vector Catch is a legacy debug event.

<a id="AArch64.VectorCatchException.1"/>AArch64.VectorCatchException(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    assert PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    assert <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1');

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    vaddress = bits(64) UNKNOWN;
    exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_VectorCatch" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_VectorCatch</a>, fault, vaddress);

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64.WatchpointException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64.WatchpointException</h3>
      <p class="pseudocode">// AArch64.WatchpointException()
// =============================

<a id="AArch64.WatchpointException.2"/>AArch64.WatchpointException(bits(64) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    assert PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
    if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.access.acctype == <a href="shared_pseudocode.html#AccessType_NV2" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_NV2</a> then
        exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_NV2Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>, fault, vaddress);
    else
        exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>, fault, vaddress);

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.exceptions.AArch64.ExceptionClass"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/exceptions/AArch64.ExceptionClass</h3>
      <p class="pseudocode">// AArch64.ExceptionClass()
// ========================
// Returns the Exception Class and Instruction Length fields to be reported in ESR

(integer,bit) <a id="AArch64.ExceptionClass.2"/>AArch64.ExceptionClass(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype, bits(2) target_el)

    il_is_valid = TRUE;
    from_32 = <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    integer ec;
    case exceptype of
        when <a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>        ec = 0x00; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>              ec = 0x01;
        when <a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>           ec = 0x03; assert from_32;
        when <a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>          ec = 0x04; assert from_32;
        when <a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>           ec = 0x05; assert from_32;
        when <a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>           ec = 0x06; assert from_32;
        when <a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>  ec = 0x07;
        when <a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>             ec = 0x08;
        when <a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACTrap</a>              ec = 0x09;
        when <a href="shared_pseudocode.html#Exception_LDST64BTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_LDST64BTrap</a>          ec = 0x0A;
        when <a href="shared_pseudocode.html#Exception_TSTARTAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_TSTARTAccessTrap</a>     ec = 0x1B;
        when <a href="shared_pseudocode.html#Exception_GPC" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_GPC</a>                  ec = 0x1E;
        when <a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>          ec = 0x0C; assert from_32;
        when <a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>         ec = 0x0D;
        when <a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>         ec = 0x0E; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>       ec = 0x11;
        when <a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>       ec = 0x12;
        when <a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>          ec = 0x13;
        when <a href="shared_pseudocode.html#Exception_SystemRegisterTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SystemRegisterTrap</a>   ec = 0x18; assert !from_32;
        when <a href="shared_pseudocode.html#Exception_SVEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SVEAccessTrap</a>        ec = 0x19; assert !from_32;
        when <a href="shared_pseudocode.html#Exception_ERetTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_ERetTrap</a>             ec = 0x1A; assert !from_32;
        when <a href="shared_pseudocode.html#Exception_PACFail" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACFail</a>              ec = 0x1C; assert !from_32;
        when <a href="shared_pseudocode.html#Exception_SMEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SMEAccessTrap</a>        ec = 0x1D; assert !from_32;
        when <a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>     ec = 0x20; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>          ec = 0x22; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>            ec = 0x24;
        when <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>         ec = 0x25;
        when <a href="shared_pseudocode.html#Exception_SPAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SPAlignment</a>          ec = 0x26; il_is_valid = FALSE; assert !from_32;
        when <a href="shared_pseudocode.html#Exception_MemCpyMemSet" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MemCpyMemSet</a>         ec = 0x27;
        when <a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPTrappedException</a>   ec = 0x28;
        when <a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>               ec = 0x2F; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>           ec = 0x30; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>         ec = 0x32; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>           ec = 0x34; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_NV2Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>        ec = 0x35; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a>   ec = 0x38;
        when <a href="shared_pseudocode.html#Exception_VectorCatch" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_VectorCatch</a>          ec = 0x3A; il_is_valid = FALSE; assert from_32;
        otherwise                           <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    if ec IN {0x20,0x24,0x30,0x32,0x34} &amp;&amp; target_el == PSTATE.EL then
        ec = ec + 1;

    if ec IN {0x11,0x12,0x13,0x28,0x38} &amp;&amp; !from_32 then
        ec = ec + 4;
    bit il;
    if il_is_valid then
        il = if <a href="shared_pseudocode.html#impl-shared.ThisInstrLength.0" title="function: integer ThisInstrLength()">ThisInstrLength</a>() == 32 then '1' else '0';
    else
        il = '1';
    assert from_32 || il == '1';            // AArch64 instructions always 32-bit

    return (ec,il);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.exceptions.AArch64.ReportException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/exceptions/AArch64.ReportException</h3>
      <p class="pseudocode">// AArch64.ReportException()
// =========================
// Report syndrome information for exception taken to AArch64 state.

<a id="AArch64.ReportException.2"/>AArch64.ReportException(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception, bits(2) target_el)

    <a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype = exception.exceptype;

    (ec,il) = <a href="shared_pseudocode.html#AArch64.ExceptionClass.2" title="function: (integer,bit) AArch64.ExceptionClass(Exception exceptype, bits(2) target_el)">AArch64.ExceptionClass</a>(exceptype, target_el);
    iss  = exception.syndrome;
    iss2 = exception.syndrome2;

    // IL is not valid for Data Abort exceptions without valid instruction syndrome information
    if ec IN {0x24,0x25} &amp;&amp; iss&lt;24&gt; == '0' then
        il = '1';

    <a href="shared_pseudocode.html#impl-aarch64.ESR.write.1" title="accessor: ESR[bits(2) regime] = ESRType value">ESR</a>[target_el] = (<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8)  :   // &lt;63:56&gt;
                      iss2      :   // &lt;55:32&gt;
                      ec&lt;5:0&gt;   :   // &lt;31:26&gt;
                      il        :   // &lt;25&gt;
                      iss);         // &lt;24:0&gt;

    if exceptype IN {
        <a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>,
        <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>,
        <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>,
        <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>,
        <a href="shared_pseudocode.html#Exception_NV2Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>,
        <a href="shared_pseudocode.html#Exception_GPC" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_GPC</a>,
        <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>
    } then
        <a href="shared_pseudocode.html#impl-aarch64.FAR.write.1" title="accessor: FAR[bits(2) regime] = bits(64) value">FAR</a>[target_el] = exception.vaddress;
    else
        <a href="shared_pseudocode.html#impl-aarch64.FAR.write.1" title="accessor: FAR[bits(2) regime] = bits(64) value">FAR</a>[target_el] = bits(64) UNKNOWN;

    if exception.ipavalid then
        HPFAR_EL2&lt;47:4&gt; = exception.ipaddress&lt;55:12&gt;;
        if <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
            HPFAR_EL2.NS = exception.NS;
        else
            HPFAR_EL2.NS = '0';
    elsif target_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        HPFAR_EL2&lt;47:4&gt; = bits(44) UNKNOWN;

    if exception.exceptype == <a href="shared_pseudocode.html#Exception_GPC" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_GPC</a> then
        MFAR_EL3.FPA = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(exception.paddress.address&lt;<a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>()-1:12&gt;, 44);
        case exception.paddress.paspace of
            when <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>     MFAR_EL3.&lt;NSE,NS&gt; = '00';
            when <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>  MFAR_EL3.&lt;NSE,NS&gt; = '01';
            when <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>       MFAR_EL3.&lt;NSE,NS&gt; = '10';
            when <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>      MFAR_EL3.&lt;NSE,NS&gt; = '11';
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.exceptions.AArch64.ResetControlRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/exceptions/AArch64.ResetControlRegisters</h3>
      <p class="pseudocode">// Resets System registers and memory-mapped control registers that have architecturally-defined
// reset values to those values.
<a id="AArch64.ResetControlRegisters.1"/>AArch64.ResetControlRegisters(boolean cold_reset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.exceptions.AArch64.TakeReset"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/exceptions/AArch64.TakeReset</h3>
      <p class="pseudocode">// AArch64.TakeReset()
// ===================
// Reset into AArch64 state

<a id="AArch64.TakeReset.1"/>AArch64.TakeReset(boolean cold_reset)
    assert <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>();

    // Enter the highest implemented Exception level in AArch64 state
    PSTATE.nRW = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        PSTATE.EL = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        PSTATE.EL = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        PSTATE.EL = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    // Reset System registers and other system components
    <a href="shared_pseudocode.html#AArch64.ResetControlRegisters.1" title="function: AArch64.ResetControlRegisters(boolean cold_reset)">AArch64.ResetControlRegisters</a>(cold_reset);

    // Reset all other PSTATE fields
    PSTATE.SP = '1';              // Select stack pointer
    PSTATE.&lt;D,A,I,F&gt;  = '1111';   // All asynchronous exceptions masked
    PSTATE.SS = '0';              // Clear software step bit
    PSTATE.DIT = '0';             // PSTATE.DIT is reset to 0 when resetting into AArch64
    PSTATE.IL = '0';              // Clear Illegal Execution state bit

    TSTATE.depth = 0;             // Non-transactional state

    // All registers, bits and fields not reset by the above pseudocode or by the BranchTo() call
    // below are UNKNOWN bitstrings after reset. In particular, the return information registers
    // ELR_ELx and SPSR_ELx have UNKNOWN values, so that it
    // is impossible to return from a reset in an architecturally defined way.
    <a href="shared_pseudocode.html#AArch64.ResetGeneralRegisters.0" title="function: AArch64.ResetGeneralRegisters()">AArch64.ResetGeneralRegisters</a>();
    <a href="shared_pseudocode.html#AArch64.ResetSIMDFPRegisters.0" title="function: AArch64.ResetSIMDFPRegisters()">AArch64.ResetSIMDFPRegisters</a>();
    <a href="shared_pseudocode.html#AArch64.ResetSpecialRegisters.0" title="function: AArch64.ResetSpecialRegisters()">AArch64.ResetSpecialRegisters</a>();
    <a href="shared_pseudocode.html#impl-shared.ResetExternalDebugRegisters.1" title="function: ResetExternalDebugRegisters(boolean cold_reset)">ResetExternalDebugRegisters</a>(cold_reset);

    bits(64) rv;                      // IMPLEMENTATION DEFINED reset vector

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        rv = RVBAR_EL3;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        rv = RVBAR_EL2;
    else
        rv = RVBAR_EL1;

    // The reset vector must be correctly aligned
    assert <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(rv&lt;63:<a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>()&gt;) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(rv&lt;1:0&gt;);

    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(rv, <a href="shared_pseudocode.html#BranchType_RESET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RESET</a>, branch_conditional);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.ieeefp.AArch64.FPTrappedException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/ieeefp/AArch64.FPTrappedException</h3>
      <p class="pseudocode">// AArch64.FPTrappedException()
// ============================

<a id="AArch64.FPTrappedException.2"/>AArch64.FPTrappedException(boolean is_ase, bits(8) accumulated_exceptions)
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPTrappedException</a>);
    if is_ase then
        if boolean IMPLEMENTATION_DEFINED "vector instructions set TFV to 1" then
            exception.syndrome&lt;23&gt; = '1';                          // TFV
        else
            exception.syndrome&lt;23&gt; = '0';                          // TFV
    else
        exception.syndrome&lt;23&gt; = '1';                              // TFV
    exception.syndrome&lt;10:8&gt; = bits(3) UNKNOWN;                    // VECITR
    if exception.syndrome&lt;23&gt; == '1' then
        exception.syndrome&lt;7,4:0&gt; = accumulated_exceptions&lt;7,4:0&gt;; // IDF,IXF,UFF,OFF,DZF,IOF
    else
        exception.syndrome&lt;7,4:0&gt; = bits(6) UNKNOWN;

    route_to_el2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.syscalls.AArch64.CallHypervisor"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/syscalls/AArch64.CallHypervisor</h3>
      <p class="pseudocode">// AArch64.CallHypervisor()
// ========================
// Performs a HVC call

<a id="AArch64.CallHypervisor.1"/>AArch64.CallHypervisor(bits(16) immediate)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.1" title="function: bits(N) NextInstrAddr(integer N)">NextInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.syscalls.AArch64.CallSecureMonitor"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/syscalls/AArch64.CallSecureMonitor</h3>
      <p class="pseudocode">// AArch64.CallSecureMonitor()
// ===========================

<a id="AArch64.CallSecureMonitor.1"/>AArch64.CallSecureMonitor(bits(16) immediate)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.1" title="function: bits(N) NextInstrAddr(integer N)">NextInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.syscalls.AArch64.CallSupervisor"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/syscalls/AArch64.CallSupervisor</h3>
      <p class="pseudocode">// AArch64.CallSupervisor()
// ========================
// Calls the Supervisor

<a id="AArch64.CallSupervisor.1"/>AArch64.CallSupervisor(bits(16) immediate_in)
    bits(16) immediate = immediate_in;
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.1" title="function: bits(N) NextInstrAddr(integer N)">NextInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.takeexception.AArch64.TakeException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/takeexception/AArch64.TakeException</h3>
      <p class="pseudocode">// AArch64.TakeException()
// =======================
// Take an exception to an Exception level using AArch64.

<a id="AArch64.TakeException.4"/>AArch64.TakeException(bits(2) target_el, <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception_in,
                      bits(64) preferred_exception_return, integer vect_offset_in)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception = exception_in;
    boolean sync_errors;
    boolean iesb_req;
    if <a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()">HaveIESB</a>() then
        sync_errors = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.1" title="accessor: SCTLRType SCTLR[bits(2) regime]">SCTLR</a>[target_el].IESB == '1';
        if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then
            sync_errors = sync_errors || (SCR_EL3.&lt;EA,NMEA&gt; == '11' &amp;&amp; target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        if sync_errors &amp;&amp; <a href="shared_pseudocode.html#impl-shared.InsertIESBBeforeException.1" title="function: boolean InsertIESBBeforeException(bits(2) el)">InsertIESBBeforeException</a>(target_el) then
            <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()">SynchronizeErrors</a>();
            iesb_req = FALSE;
            sync_errors = FALSE;
            <a href="shared_pseudocode.html#impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" title="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)">TakeUnmaskedPhysicalSErrorInterrupts</a>(iesb_req);
    else
        sync_errors = FALSE;

    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then
        <a href="shared_pseudocode.html#TMFailure" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure</a> cause;
        case exception.exceptype of
            when <a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a> cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            when <a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>         cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            when <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>         cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            when <a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>       cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            otherwise                         cause = <a href="shared_pseudocode.html#TMFailure_ERR" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_ERR</a>;
        <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(cause, FALSE);

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();

    // If coming from AArch32 state, the top parts of the X[] registers might be set to zero
    from_32 = <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    if from_32 then <a href="shared_pseudocode.html#AArch64.MaybeZeroRegisterUppers.0" title="function: AArch64.MaybeZeroRegisterUppers()">AArch64.MaybeZeroRegisterUppers</a>();
    if from_32 &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' then
        <a href="shared_pseudocode.html#impl-aarch64.ResetSVEState.0" title="function: ResetSVEState()">ResetSVEState</a>();
    else
        <a href="shared_pseudocode.html#impl-aarch64.MaybeZeroSVEUppers.1" title="function: MaybeZeroSVEUppers(bits(2) target_el)">MaybeZeroSVEUppers</a>(target_el);

    integer vect_offset = vect_offset_in;
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then
        boolean lower_32;
        if target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
                lower_32 = <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
            else
                lower_32 = <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
        elsif <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            lower_32 = <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>);
        else
            lower_32 = <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el - 1);
        vect_offset = vect_offset + (if lower_32 then 0x600 else 0x400);

    elsif PSTATE.SP == '1' then
        vect_offset = vect_offset + 0x200;

    bits(64) spsr = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.2" title="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState, integer N)">GetPSRFromPSTATE</a>(<a href="shared_pseudocode.html#AArch64_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch64_NonDebugState</a>, 64);

    if PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; (HCR_EL2.&lt;NV,NV1,NV2&gt; == '100' || HCR_EL2.&lt;NV,NV1,NV2&gt; == '111') then
            spsr&lt;3:2&gt; = '10';
        else
            if <a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.&lt;NV,NV1&gt; == '10' then
                spsr&lt;3:2&gt; = '10';

    if <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        boolean zero_btype;
        // SPSR[].BTYPE is only guaranteed valid for these exception types
        if exception.exceptype IN {<a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>, <a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>, <a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>,
                              <a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>, <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>,
                              <a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>, <a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>,
                              <a href="shared_pseudocode.html#Exception_VectorCatch" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_VectorCatch</a>, <a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a>,
                              <a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>, <a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>} then
            zero_btype = FALSE;
        else
            zero_btype = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ZEROBTYPE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_ZEROBTYPE</a>);
        if zero_btype then spsr&lt;11:10&gt; = '00';

    if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; exception.exceptype == <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        // External aborts are configured to be taken to EL3
        exception.exceptype = <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>;
    if !(exception.exceptype IN {<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>, <a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>}) then
        <a href="shared_pseudocode.html#AArch64.ReportException.2" title="function: AArch64.ReportException(ExceptionRecord exception, bits(2) target_el)">AArch64.ReportException</a>(exception, target_el);

    if <a href="shared_pseudocode.html#impl-shared.HaveBRBExt.0" title="function: boolean HaveBRBExt()">HaveBRBExt</a>() then
        <a href="shared_pseudocode.html#impl-aarch64.BRBEException.5" title="function: BRBEException(Exception exception, bits(64) preferred_exception_return,&#13; bits(64) target_address_in, bits(2) target_el, boolean trappedsyscallinst)">BRBEException</a>(exception.exceptype, preferred_exception_return,
                      <a href="shared_pseudocode.html#impl-aarch64.VBAR.read.1" title="accessor: bits(64) VBAR[bits(2) regime]">VBAR</a>[target_el]&lt;63:11&gt;:vect_offset&lt;10:0&gt;, target_el,
                      exception.trappedsyscallinst);

    PSTATE.EL = target_el;
    PSTATE.nRW = '0';
    PSTATE.SP = '1';

    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = spsr;
    <a href="shared_pseudocode.html#impl-aarch64.ELR.write.0" title="accessor: ELR[] = bits(64) value">ELR</a>[] = preferred_exception_return;

    PSTATE.SS = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveFeatNMI.0" title="function: boolean HaveFeatNMI()">HaveFeatNMI</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) then PSTATE.ALLINT = NOT <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SPINTMASK;
    PSTATE.&lt;D,A,I,F&gt; = '1111';
    PSTATE.IL = '0';
    if from_32 then                             // Coming from AArch32
        PSTATE.IT = '00000000';
        PSTATE.T = '0';                         // PSTATE.J is RES0
    if (<a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; (PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>))) &amp;&amp;
        <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SPAN == '0') then
        PSTATE.PAN = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then PSTATE.BTYPE = '00';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].DSSBS;
    if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = '1';

    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(<a href="shared_pseudocode.html#impl-aarch64.VBAR.read.0" title="accessor: bits(64) VBAR[]">VBAR</a>[]&lt;63:11&gt;:vect_offset&lt;10:0&gt;, <a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>, branch_conditional);

    <a href="shared_pseudocode.html#impl-shared.CheckExceptionCatch.1" title="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(TRUE);                  // Check for debug event on exception entry

    if sync_errors then
        <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()">SynchronizeErrors</a>();
        iesb_req = TRUE;
        <a href="shared_pseudocode.html#impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" title="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)">TakeUnmaskedPhysicalSErrorInterrupts</a>(iesb_req);

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.AArch32SystemAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.AArch32SystemAccessTrap</h3>
      <p class="pseudocode">// AArch64.AArch32SystemAccessTrap()
// =================================
// Trapped AARCH32 System register access.

<a id="AArch64.AArch32SystemAccessTrap.2"/>AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; target_el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrapSyndrome.2" title="function: ExceptionRecord AArch64.AArch32SystemAccessTrapSyndrome(bits(32) instr, integer ec)">AArch64.AArch32SystemAccessTrapSyndrome</a>(<a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>(), ec);
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.AArch32SystemAccessTrapSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.AArch32SystemAccessTrapSyndrome</h3>
      <p class="pseudocode">// AArch64.AArch32SystemAccessTrapSyndrome()
// =========================================
// Returns the syndrome information for traps on AArch32 MCR, MCRR, MRC, MRRC, and VMRS, VMSR instructions,
// other than traps that are due to HCPTR or CPACR.

ExceptionRecord <a id="AArch64.AArch32SystemAccessTrapSyndrome.2"/>AArch64.AArch32SystemAccessTrapSyndrome(bits(32) instr, integer ec)
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;

    case ec of
        when 0x0    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
        when 0x3    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>);
        when 0x4    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>);
        when 0x5    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>);
        when 0x6    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>);
        when 0x7    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
        when 0x8    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>);
        when 0xC    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>);
        otherwise   <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    bits(20) iss = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(20);

    if exception.exceptype == <a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a> then
        return exception;
    elsif exception.exceptype IN {<a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>, <a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>, <a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>} then
        // Trapped MRC/MCR, VMRS on FPSID
        if exception.exceptype != <a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a> then    // When trap is not for VMRS
            iss&lt;19:17&gt; = instr&lt;7:5&gt;;           // opc2
            iss&lt;16:14&gt; = instr&lt;23:21&gt;;         // opc1
            iss&lt;13:10&gt; = instr&lt;19:16&gt;;         // CRn
            iss&lt;4:1&gt;   = instr&lt;3:0&gt;;           // CRm
        else
            iss&lt;19:17&gt; = '000';
            iss&lt;16:14&gt; = '111';
            iss&lt;13:10&gt; = instr&lt;19:16&gt;;         // reg
            iss&lt;4:1&gt;   = '0000';

        if instr&lt;20&gt; == '1' &amp;&amp; instr&lt;15:12&gt; == '1111' then    // MRC, Rt==15
            iss&lt;9:5&gt; = '11111';
        elsif instr&lt;20&gt; == '0' &amp;&amp; instr&lt;15:12&gt; == '1111' then // MCR, Rt==15
            iss&lt;9:5&gt; = bits(5) UNKNOWN;
        else
            iss&lt;9:5&gt; = LookUpRIndex(UInt(instr&lt;15:12&gt;), PSTATE.M)&lt;4:0&gt;;
    elsif exception.exceptype IN {<a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>, <a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>, <a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>} then
        // Trapped MRRC/MCRR, VMRS/VMSR
        iss&lt;19:16&gt; = instr&lt;7:4&gt;;          // opc1
        if instr&lt;19:16&gt; == '1111' then    // Rt2==15
            iss&lt;14:10&gt; = bits(5) UNKNOWN;
        else
            iss&lt;14:10&gt; = LookUpRIndex(UInt(instr&lt;19:16&gt;), PSTATE.M)&lt;4:0&gt;;

        if instr&lt;15:12&gt; == '1111' then    // Rt==15
            iss&lt;9:5&gt; = bits(5) UNKNOWN;
        else
            iss&lt;9:5&gt; = LookUpRIndex(UInt(instr&lt;15:12&gt;), PSTATE.M)&lt;4:0&gt;;
        iss&lt;4:1&gt;   = instr&lt;3:0&gt;;         // CRm
    elsif exception.exceptype == <a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a> then
        // Trapped LDC/STC
        iss&lt;19:12&gt; = instr&lt;7:0&gt;;         // imm8
        iss&lt;4&gt;     = instr&lt;23&gt;;          // U
        iss&lt;2:1&gt;   = instr&lt;24,21&gt;;       // P,W
        if instr&lt;19:16&gt; == '1111' then   // Rn==15, LDC(Literal addressing)/STC
            iss&lt;9:5&gt; = bits(5) UNKNOWN;
            iss&lt;3&gt;   = '1';
    iss&lt;0&gt; = instr&lt;20&gt;;                  // Direction

    exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
    exception.syndrome&lt;19:0&gt;  = iss;

    return exception;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.AdvSIMDFPAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.AdvSIMDFPAccessTrap</h3>
      <p class="pseudocode">// AArch64.AdvSIMDFPAccessTrap()
// =============================
// Trapped access to Advanced SIMD or FP registers due to CPACR[].

<a id="AArch64.AdvSIMDFPAccessTrap.1"/>AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
    vect_offset = 0x0;

    route_to_el2 = (target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1');

    if route_to_el2 then
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
        exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckCP15InstrCoarseTraps"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckCP15InstrCoarseTraps</h3>
      <p class="pseudocode">// AArch64.CheckCP15InstrCoarseTraps()
// ===================================
// Check for coarse-grained AArch32  traps to System registers in the
// coproc=0b1111 encoding space by HSTR_EL2, HCR_EL2, and SCTLR_ELx.

<a id="AArch64.CheckCP15InstrCoarseTraps.3"/>AArch64.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)
    trapped_encoding = ((CRn == 9  &amp;&amp; CRm IN {0,1,2,    5,6,7,8   }) ||
                        (CRn == 10 &amp;&amp; CRm IN {0,1,    4,      8   }) ||
                        (CRn == 11 &amp;&amp; CRm IN {0,1,2,3,4,5,6,7,8,15}));

    // Check for MRC and MCR disabled by SCTLR_EL1.TIDCP.
    if (<a href="shared_pseudocode.html#impl-shared.HaveFeatTIDCP1.0" title="function: boolean HaveFeatTIDCP1()">HaveFeatTIDCP1</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp;
           !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; SCTLR_EL1.TIDCP == '1' &amp;&amp; trapped_encoding) then
        if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
            <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, 0x3);
        else
            <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, 0x3);

    // Check for coarse-grained Hyp traps
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        // Check for MRC and MCR disabled by SCTLR_EL2.TIDCP.
        if (<a href="shared_pseudocode.html#impl-shared.HaveFeatTIDCP1.0" title="function: boolean HaveFeatTIDCP1()">HaveFeatTIDCP1</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp;
                SCTLR_EL2.TIDCP == '1' &amp;&amp; trapped_encoding) then
            <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, 0x3);

        major = if nreg == 1 then CRn else CRm;
        // Check for MCR, MRC, MCRR, and MRRC disabled by HSTR_EL2&lt;CRn/CRm&gt;
        // and MRC and MCR disabled by HCR_EL2.TIDCP.
        if ((!<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; !(major IN {4,14}) &amp;&amp; HSTR_EL2&lt;major&gt; == '1') ||
                (HCR_EL2.TIDCP == '1' &amp;&amp; nreg == 1 &amp;&amp; trapped_encoding)) then
            if (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp;
                    boolean IMPLEMENTATION_DEFINED "UNDEF unallocated CP15 access at <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>") then
                UNDEFINED;
            <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, 0x3);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckFPAdvSIMDEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckFPAdvSIMDEnabled</h3>
      <p class="pseudocode">// AArch64.CheckFPAdvSIMDEnabled()
// ===============================

<a id="AArch64.CheckFPAdvSIMDEnabled.0"/>AArch64.CheckFPAdvSIMDEnabled()
    <a href="shared_pseudocode.html#AArch64.CheckFPEnabled.0" title="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</a>();
    // Check for illegal use of Advanced
    // SIMD in Streaming SVE Mode
    if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.IsFullA64Enabled.0" title="function: boolean IsFullA64Enabled()">IsFullA64Enabled</a>() then
        <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_Streaming" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_Streaming</a>, PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckFPAdvSIMDTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckFPAdvSIMDTrap</h3>
      <p class="pseudocode">// AArch64.CheckFPAdvSIMDTrap()
// ============================
// Check against CPTR_EL2 and CPTR_EL3.

<a id="AArch64.CheckFPAdvSIMDTrap.0"/>AArch64.CheckFPAdvSIMDTrap()
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; CPTR_EL3.TFP == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>() then
        UNDEFINED;

    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        // Check if access disabled in CPTR_EL2
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            boolean disabled;
            case CPTR_EL2.FPEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        else
            if CPTR_EL2.TFP == '1' then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        // Check if access disabled in CPTR_EL3
        if CPTR_EL3.TFP == '1' then
            if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
                UNDEFINED;
            else
                <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckFPEnabled</h3>
      <p class="pseudocode">// AArch64.CheckFPEnabled()
// ========================
// Check against CPACR[]

<a id="AArch64.CheckFPEnabled.0"/>AArch64.CheckFPEnabled()
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check if access disabled in CPACR_EL1
        boolean disabled;
        case CPACR_EL1.FPEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    <a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDTrap.0" title="function: AArch64.CheckFPAdvSIMDTrap()">AArch64.CheckFPAdvSIMDTrap</a>();               // Also check against CPTR_EL2 and CPTR_EL3</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckForERetTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckForERetTrap</h3>
      <p class="pseudocode">// AArch64.CheckForERetTrap()
// ==========================
// Check for trap on ERET, ERETAA, ERETAB instruction

<a id="AArch64.CheckForERetTrap.2"/>AArch64.CheckForERetTrap(boolean eret_with_pac, boolean pac_uses_key_a)

    route_to_el2 = FALSE;
    // Non-secure EL1 execution of ERET, ERETAA, ERETAB when either HCR_EL2.NV or HFGITR_EL2.ERET is set,
    // is trapped to EL2
    route_to_el2 = (PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                   ((<a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.NV == '1') ||
                   (<a href="shared_pseudocode.html#impl-shared.HaveFGTExt.0" title="function: boolean HaveFGTExt()">HaveFGTExt</a>() &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.FGTEn == '1') &amp;&amp;
                   HFGITR_EL2.ERET == '1')));
    if route_to_el2 then
        <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
        bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
        vect_offset = 0x0;
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_ERetTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_ERetTrap</a>);
        if !eret_with_pac then                             // ERET
            exception.syndrome&lt;1&gt; = '0';
            exception.syndrome&lt;0&gt; = '0';                   // RES0
        else
            exception.syndrome&lt;1&gt; = '1';
            if pac_uses_key_a then                         // ERETAA
                exception.syndrome&lt;0&gt; = '0';
            else    // ERETAB
                exception.syndrome&lt;0&gt; = '1';
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckForSMCUndefOrTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckForSMCUndefOrTrap</h3>
      <p class="pseudocode">// AArch64.CheckForSMCUndefOrTrap()
// ================================
// Check for UNDEFINED or trap on SMC instruction

<a id="AArch64.CheckForSMCUndefOrTrap.1"/>AArch64.CheckForSMCUndefOrTrap(bits(16) imm)
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then UNDEFINED;
    if (!(PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TSC == '1') &amp;&amp;
        <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.SMD == '1') then
        UNDEFINED;
    route_to_el2 = FALSE;
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
            if <a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.NV == '1' &amp;&amp; HCR_EL2.TSC == '1' then
                route_to_el2 = TRUE;
            else
                UNDEFINED;
        else
            UNDEFINED;
    else
        route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TSC == '1';
    if route_to_el2 then
        bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
        vect_offset = 0x0;
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>);
        exception.syndrome&lt;15:0&gt; = imm;
        exception.trappedsyscallinst = TRUE;
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckForSVCTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckForSVCTrap</h3>
      <p class="pseudocode">// AArch64.CheckForSVCTrap()
// =========================
// Check for trap on SVC instruction

<a id="AArch64.CheckForSVCTrap.1"/>AArch64.CheckForSVCTrap(bits(16) immediate)
    if <a href="shared_pseudocode.html#impl-shared.HaveFGTExt.0" title="function: boolean HaveFGTExt()">HaveFGTExt</a>() then
        route_to_el2 = FALSE;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            route_to_el2 = (!<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp;
                           <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HFGITR_EL2.SVC_EL0 == '1' &amp;&amp;
                           (HCR_EL2.&lt;E2H, TGE&gt; != '11' &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.FGTEn == '1')));

        elsif PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
            route_to_el2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HFGITR_EL2.SVC_EL1 == '1' &amp;&amp;
                           (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.FGTEn == '1'));

        if route_to_el2 then
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>);
            exception.syndrome&lt;15:0&gt; = immediate;
            exception.trappedsyscallinst = TRUE;
            bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
            vect_offset = 0x0;

            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckForWFxTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckForWFxTrap</h3>
      <p class="pseudocode">// AArch64.CheckForWFxTrap()
// =========================
// Check for trap on WFE or WFI instruction

<a id="AArch64.CheckForWFxTrap.2"/>AArch64.CheckForWFxTrap(bits(2) target_el, <a href="shared_pseudocode.html#WFxType" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el);

    boolean is_wfe = wfxtype IN {<a href="shared_pseudocode.html#WFxType_WFE" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</a>, <a href="shared_pseudocode.html#WFxType_WFET" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFET</a>};
    boolean trap;
    case target_el of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            trap = (if is_wfe then <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].nTWE else <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].nTWI) == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            trap = (if is_wfe then HCR_EL2.TWE else HCR_EL2.TWI) == '1';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            trap = (if is_wfe then SCR_EL3.TWE else SCR_EL3.TWI) == '1';

    if trap then
        <a href="shared_pseudocode.html#AArch64.WFxTrap.2" title="function: AArch64.WFxTrap(WFxType wfxtype, bits(2) target_el)">AArch64.WFxTrap</a>(wfxtype, target_el);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckIllegalState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckIllegalState</h3>
      <p class="pseudocode">// AArch64.CheckIllegalState()
// ===========================
// Check PSTATE.IL bit and generate Illegal Execution state exception if set.

<a id="AArch64.CheckIllegalState.0"/>AArch64.CheckIllegalState()
    if PSTATE.IL == '1' then
        route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

        bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
        vect_offset = 0x0;

        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>);

        if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
        elsif route_to_el2 then
            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.MonitorModeTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.MonitorModeTrap</h3>
      <p class="pseudocode">// AArch64.MonitorModeTrap()
// =========================
// Trapped use of Monitor mode features in a Secure EL1 AArch32 mode

<a id="AArch64.MonitorModeTrap.0"/>AArch64.MonitorModeTrap()
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);

    if <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.SystemAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.SystemAccessTrap</h3>
      <p class="pseudocode">// AArch64.SystemAccessTrap()
// ==========================
// Trapped access to AArch64 System register or system instruction.

<a id="AArch64.SystemAccessTrap.2"/>AArch64.SystemAccessTrap(bits(2) target_el, integer ec)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; target_el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#AArch64.SystemAccessTrapSyndrome.2" title="function: ExceptionRecord AArch64.SystemAccessTrapSyndrome(bits(32) instr_in, integer ec)">AArch64.SystemAccessTrapSyndrome</a>(<a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>(), ec);
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.SystemAccessTrapSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.SystemAccessTrapSyndrome</h3>
      <p class="pseudocode">// AArch64.SystemAccessTrapSyndrome()
// ==================================
// Returns the syndrome information for traps on AArch64 MSR/MRS instructions.

ExceptionRecord <a id="AArch64.SystemAccessTrapSyndrome.2"/>AArch64.SystemAccessTrapSyndrome(bits(32) instr_in, integer ec)
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
    bits(32) instr = instr_in;
    case ec of
        when 0x0                                                     // Trapped access due to unknown reason.
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
        when 0x7                                                     // Trapped access to SVE, Advance SIMD&amp;FP System register.
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
            exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
        when 0x18                                                    // Trapped access to System register or system instruction.
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SystemRegisterTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SystemRegisterTrap</a>);
            instr = <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>();
            exception.syndrome&lt;21:20&gt; = instr&lt;20:19&gt;;          // Op0
            exception.syndrome&lt;19:17&gt; = instr&lt;7:5&gt;;            // Op2
            exception.syndrome&lt;16:14&gt; = instr&lt;18:16&gt;;          // Op1
            exception.syndrome&lt;13:10&gt; = instr&lt;15:12&gt;;          // CRn
            exception.syndrome&lt;9:5&gt;   = instr&lt;4:0&gt;;            // Rt
            exception.syndrome&lt;4:1&gt;   = instr&lt;11:8&gt;;           // CRm
            exception.syndrome&lt;0&gt;     = instr&lt;21&gt;;             // Direction
        when 0x19                                                    // Trapped access to SVE System register
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SVEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SVEAccessTrap</a>);
        when 0x1D                                                    // Trapped access to SME System register
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SMEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SMEAccessTrap</a>);
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    return exception;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.UndefinedFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.UndefinedFault</h3>
      <p class="pseudocode">// AArch64.UndefinedFault()
// ========================

<a id="AArch64.UndefinedFault.0"/>AArch64.UndefinedFault()

    route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.WFxTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.WFxTrap</h3>
      <p class="pseudocode">// AArch64.WFxTrap()
// =================

<a id="AArch64.WFxTrap.2"/>AArch64.WFxTrap(<a href="shared_pseudocode.html#WFxType" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype, bits(2) target_el)
    assert <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>);
    exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();

    case wfxtype of
        when <a href="shared_pseudocode.html#WFxType_WFI" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFI</a>
            exception.syndrome&lt;1:0&gt; = '00';
        when <a href="shared_pseudocode.html#WFxType_WFE" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</a>
            exception.syndrome&lt;1:0&gt; = '01';
        when <a href="shared_pseudocode.html#WFxType_WFIT" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFIT</a>
            exception.syndrome&lt;1:0&gt; = '10';
            exception.syndrome&lt;2&gt;   = '1';   // Register field is valid
            exception.syndrome&lt;9:5&gt; = <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>()&lt;4:0&gt;;
        when <a href="shared_pseudocode.html#WFxType_WFET" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFET</a>
            exception.syndrome&lt;1:0&gt; = '11';
            exception.syndrome&lt;2&gt;   = '1';   // Register field is valid
            exception.syndrome&lt;9:5&gt; = <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>()&lt;4:0&gt;;

    if target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckFPAdvSIMDEnabled64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckFPAdvSIMDEnabled64</h3>
      <p class="pseudocode">// CheckFPAdvSIMDEnabled64()
// =========================
// AArch64 instruction wrapper

<a id="impl-aarch64.CheckFPAdvSIMDEnabled64.0"/>CheckFPAdvSIMDEnabled64()
    <a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDEnabled.0" title="function: AArch64.CheckFPAdvSIMDEnabled()">AArch64.CheckFPAdvSIMDEnabled</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckFPEnabled64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckFPEnabled64</h3>
      <p class="pseudocode">// CheckFPEnabled64()
// ==================
// AArch64 instruction wrapper

<a id="impl-aarch64.CheckFPEnabled64.0"/>CheckFPEnabled64()
    <a href="shared_pseudocode.html#AArch64.CheckFPEnabled.0" title="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckLDST64BEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckLDST64BEnabled</h3>
      <p class="pseudocode">// CheckLDST64BEnabled()
// =====================
// Checks for trap on ST64B and LD64B instructions

<a id="impl-aarch64.CheckLDST64BEnabled.0"/>CheckLDST64BEnabled()
    boolean trap = FALSE;
    bits(25) iss = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>('10', 25);  // 0x2
    bits(2) target_el;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        if !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            trap = SCTLR_EL1.EnALS == '0';
            target_el = if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
        else
            trap = SCTLR_EL2.EnALS == '0';
            target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    if (!trap &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        ((PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) || PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) then
        trap = !<a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.EnALS == '0';
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if trap then <a href="shared_pseudocode.html#impl-aarch64.LDST64BTrap.2" title="function: LDST64BTrap(bits(2) target_el, bits(25) iss)">LDST64BTrap</a>(target_el, iss);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckST64BV0Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckST64BV0Enabled</h3>
      <p class="pseudocode">// CheckST64BV0Enabled()
// =====================
// Checks for trap on ST64BV0 instruction

<a id="impl-aarch64.CheckST64BV0Enabled.0"/>CheckST64BV0Enabled()
    boolean trap = FALSE;
    bits(25) iss = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>('1', 25);  // 0x1
    bits(2) target_el;

    if (PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp;
        SCR_EL3.EnAS0 == '0' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>()) then
        UNDEFINED;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        if !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            trap = SCTLR_EL1.EnAS0 == '0';
            target_el = if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
        else
            trap = SCTLR_EL2.EnAS0 == '0';
            target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if (!trap &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        ((PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) || PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) then
        trap = !<a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.EnAS0 == '0';
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if !trap &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        trap = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EnAS0 == '0';
        target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    if trap then
        if target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
            UNDEFINED;
        else
            <a href="shared_pseudocode.html#impl-aarch64.LDST64BTrap.2" title="function: LDST64BTrap(bits(2) target_el, bits(25) iss)">LDST64BTrap</a>(target_el, iss);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckST64BVEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckST64BVEnabled</h3>
      <p class="pseudocode">// CheckST64BVEnabled()
// ====================
// Checks for trap on ST64BV instruction

<a id="impl-aarch64.CheckST64BVEnabled.0"/>CheckST64BVEnabled()
    boolean trap = FALSE;
    bits(25) iss = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(25);
    bits(2) target_el;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        if !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            trap = SCTLR_EL1.EnASR == '0';
            target_el = if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
        else
            trap = SCTLR_EL2.EnASR == '0';
            target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if (!trap &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        ((PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) || PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) then
        trap = !<a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.EnASR == '0';
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if trap then <a href="shared_pseudocode.html#impl-aarch64.LDST64BTrap.2" title="function: LDST64BTrap(bits(2) target_el, bits(25) iss)">LDST64BTrap</a>(target_el, iss);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.LDST64BTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/LDST64BTrap</h3>
      <p class="pseudocode">// LDST64BTrap()
// =============
// Trapped access to LD64B, ST64B, ST64BV and ST64BV0 instructions

<a id="impl-aarch64.LDST64BTrap.2"/>LDST64BTrap(bits(2) target_el, bits(25) iss)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_LDST64BTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_LDST64BTrap</a>);
    exception.syndrome = iss;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.WFETrapDelay"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/WFETrapDelay</h3>
      <p class="pseudocode">// WFETrapDelay()
// ==============
// Returns TRUE when delay in trap to WFE is enabled with value to amount of delay,
// FALSE otherwise.

(boolean, integer) <a id="impl-aarch64.WFETrapDelay.1"/>WFETrapDelay(bits(2) target_el)
    boolean delay_enabled;
    integer delay;
    case target_el of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            if !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
                delay_enabled = SCTLR_EL1.TWEDEn == '1';
                delay         = 1 &lt;&lt; (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SCTLR_EL1.TWEDEL) + 8);
            else
                delay_enabled = SCTLR_EL2.TWEDEn == '1';
                delay         = 1 &lt;&lt; (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SCTLR_EL2.TWEDEL) + 8);
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            assert <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
            delay_enabled = HCR_EL2.TWEDEn == '1';
            delay         = 1 &lt;&lt; (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(HCR_EL2.TWEDEL) + 8);
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            delay_enabled = SCR_EL3.TWEDEn == '1';
            delay         = 1 &lt;&lt; (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SCR_EL3.TWEDEL) + 8);

    return (delay_enabled, delay);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.WaitForEventUntilDelay"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/WaitForEventUntilDelay</h3>
      <p class="pseudocode">// Returns TRUE if WaitForEvent() returns before WFE trap delay expires,
// FALSE otherwise.
boolean <a id="impl-aarch64.WaitForEventUntilDelay.2"/>WaitForEventUntilDelay(boolean delay_enabled, integer delay);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.aborts.AArch64.FaultSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/aborts/AArch64.FaultSyndrome</h3>
      <p class="pseudocode">// AArch64.FaultSyndrome()
// =======================
// Creates an exception syndrome value for Abort and Watchpoint exceptions taken to
// an Exception level using AArch64.

(bits(25), bits(24)) <a id="AArch64.FaultSyndrome.2"/>AArch64.FaultSyndrome(boolean d_side, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    assert fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    bits(25) iss  = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(25);
    bits(24) iss2 = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24);

    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; fault.statuscode == <a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a> then
        <a href="shared_pseudocode.html#ErrorState" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState</a> errstate = <a href="shared_pseudocode.html#AArch64.PEErrorState.1" title="function: ErrorState AArch64.PEErrorState(FaultRecord fault)">AArch64.PEErrorState</a>(fault);
        iss&lt;12:11&gt; = <a href="shared_pseudocode.html#AArch64.EncodeSyncErrorSyndrome.1" title="function: bits(2) AArch64.EncodeSyncErrorSyndrome(ErrorState errorstate)">AArch64.EncodeSyncErrorSyndrome</a>(errstate);  // SET

    if d_side then
        if <a href="shared_pseudocode.html#impl-shared.HaveFeatLS64.0" title="function: boolean HaveFeatLS64()">HaveFeatLS64</a>() &amp;&amp; fault.access.ls64 then
            if (fault.statuscode IN {<a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>, <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>, <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>}) then
                (iss2, iss&lt;24:14&gt;) = <a href="shared_pseudocode.html#impl-aarch64.LS64InstructionSyndrome.0" title="function: (bits(24), bits(11)) LS64InstructionSyndrome()">LS64InstructionSyndrome</a>();
        elsif (<a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) &amp;&amp; !fault.s2fs1walk &amp;&amp;
               (!<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) ||
               (!<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; fault.access.acctype == <a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a> &amp;&amp;
               boolean IMPLEMENTATION_DEFINED "ISV on second stage translation table walk"))) then
            iss&lt;24:14&gt; = <a href="shared_pseudocode.html#impl-shared.LSInstructionSyndrome.0" title="function: bits(11) LSInstructionSyndrome()">LSInstructionSyndrome</a>();

        if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.access.acctype == <a href="shared_pseudocode.html#AccessType_NV2" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_NV2</a> then
            iss&lt;13&gt; = '1';   // Fault is generated by use of VNCR_EL2

        if <a href="shared_pseudocode.html#impl-shared.HaveFeatLS64.0" title="function: boolean HaveFeatLS64()">HaveFeatLS64</a>() &amp;&amp; fault.statuscode IN {<a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>, <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>,
                                                  <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>} then
            iss&lt;12:11&gt; = <a href="shared_pseudocode.html#impl-shared.GetLoadStoreType.0" title="function: bits(2) GetLoadStoreType()">GetLoadStoreType</a>();

        if fault.access.acctype IN {<a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>, <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_AT" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_AT</a>} then
            iss&lt;8&gt; = '1';

        if fault.access.acctype IN {<a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>, <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_AT" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_AT</a>} then
            iss&lt;6&gt; = '1';
        elsif fault.statuscode IN {<a href="shared_pseudocode.html#Fault_HWUpdateAccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_HWUpdateAccessFlag</a>, <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>} then
            iss&lt;6&gt; = bit UNKNOWN;
        elsif fault.access.atomicop &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then
            iss&lt;6&gt; = bit UNKNOWN;
        else
            iss&lt;6&gt; = if fault.write then '1' else '0';

        if fault.statuscode == <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a> then
            if iss&lt;24&gt; == '0' then
                iss&lt;21&gt; = if fault.toplevel then '1' else '0';
            iss2&lt;7&gt; = if fault.assuredonly then '1' else '0';
            iss2&lt;6&gt; = if fault.overlay then '1' else '0';
            iss2&lt;5&gt; = if fault.dirtybit then '1' else '0';
            iss2&lt;9&gt; = if fault.tagaccess then '1' else '0';

    else
        if fault.access.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> &amp;&amp; fault.statuscode == <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a> then
            iss&lt;21&gt; = if fault.toplevel then '1' else '0';
            iss2&lt;7&gt; = if fault.assuredonly then '1' else '0';
            iss2&lt;6&gt; = if fault.overlay then '1' else '0';

    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then iss&lt;9&gt; = fault.extflag;
    iss&lt;7&gt; = if fault.s2fs1walk then '1' else '0';
    iss&lt;5:0&gt; = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);

    return (iss, iss2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.aborts.EncodeGPCSC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/aborts/EncodeGPCSC</h3>
      <p class="pseudocode">// EncodeGPCSC()
// =============
// Function that gives the GPCSC code for types of GPT Fault

bits(6) <a id="impl-aarch64.EncodeGPCSC.1"/>EncodeGPCSC(<a href="shared_pseudocode.html#GPCFRecord" title="type GPCFRecord is ( GPCF gpf, integer level )">GPCFRecord</a> gpcf)
    assert gpcf.level IN {0,1};

    case gpcf.gpf of
        when <a href="shared_pseudocode.html#GPCF_AddressSize" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_AddressSize</a> return '00000':gpcf.level&lt;0&gt;;
        when <a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>        return '00010':gpcf.level&lt;0&gt;;
        when <a href="shared_pseudocode.html#GPCF_Fail" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Fail</a>        return '00110':gpcf.level&lt;0&gt;;
        when <a href="shared_pseudocode.html#GPCF_EABT" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_EABT</a>        return '01010':gpcf.level&lt;0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.aborts.LS64InstructionSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/aborts/LS64InstructionSyndrome</h3>
      <p class="pseudocode">// Returns the syndrome information and LST for a Data Abort by a
// ST64B, ST64BV, ST64BV0, or LD64B instruction. The syndrome information
// includes the ISS2, extended syndrome field.
(bits(24), bits(11)) <a id="impl-aarch64.LS64InstructionSyndrome.0"/>LS64InstructionSyndrome();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.cache.AArch64.DataMemZero"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/cache/AArch64.DataMemZero</h3>
      <p class="pseudocode">// AArch64.DataMemZero()
// =====================
// Write Zero to data memory.

<a id="AArch64.DataMemZero.4"/>AArch64.DataMemZero(bits(64) regval, bits(64) vaddress, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in, integer size)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;

    // If the instruction targets tags as a payload, confer with system register configuration
    // which may override this.
    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagaccess then
        accdesc.tagaccess = <a href="shared_pseudocode.html#AArch64.AllocationTagAccessIsEnabled.1" title="function: boolean AArch64.AllocationTagAccessIsEnabled(bits(2) el)">AArch64.AllocationTagAccessIsEnabled</a>(accdesc.el);

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccessDescriptor accdesc)">AArch64.AccessIsTagChecked</a>(vaddress, accdesc);

    boolean aligned = TRUE;
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(vaddress, accdesc, aligned, size);

    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        if <a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(memaddrdesc.fault) then
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(vaddress, memaddrdesc.fault);
        else
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(regval, memaddrdesc.fault);

    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then
        if accdesc.transactional &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.MemHasTransactionalAccess.1" title="function: boolean MemHasTransactionalAccess(MemoryAttributes memattrs)">MemHasTransactionalAccess</a>(memaddrdesc.memattrs) then
            <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(<a href="shared_pseudocode.html#TMFailure_IMP" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_IMP</a>, FALSE);

    for i = 0 to size-1
        if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
            bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(vaddress);
            if !<a href="shared_pseudocode.html#AArch64.CheckTag.3" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag) then
                if boolean IMPLEMENTATION_DEFINED "DC_ZVA tag fault reported with lowest faulting address" then
                    <a href="shared_pseudocode.html#AArch64.TagCheckFault.2" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccessDescriptor accdesc)">AArch64.TagCheckFault</a>(vaddress, accdesc);
                else
                    <a href="shared_pseudocode.html#AArch64.TagCheckFault.2" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccessDescriptor accdesc)">AArch64.TagCheckFault</a>(regval, accdesc);
        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, 1, accdesc, <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8));
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, 1, accdesc);

        memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.cache.AArch64.TagMemZero"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/cache/AArch64.TagMemZero</h3>
      <p class="pseudocode">// AArch64.TagMemZero()
// ====================
// Write Zero to tag memory.

<a id="AArch64.TagMemZero.4"/>AArch64.TagMemZero(bits(64) regval, bits(64) vaddress, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in, integer size)
    assert accdesc_in.tagaccess &amp;&amp; !accdesc_in.tagchecked;

    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;

    integer count = size &gt;&gt; <a href="shared_pseudocode.html#LOG2_TAG_GRANULE" title="constant integer LOG2_TAG_GRANULE = 4">LOG2_TAG_GRANULE</a>;
    bits(4) tag = <a href="shared_pseudocode.html#AArch64.AllocationTagFromAddress.1" title="function: bits(4) AArch64.AllocationTagFromAddress(bits(64) tagged_address)">AArch64.AllocationTagFromAddress</a>(vaddress);
    boolean aligned = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(vaddress, <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>);

    // Stores of allocation tags must be aligned
    if !aligned then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(vaddress, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        accdesc.tagaccess = <a href="shared_pseudocode.html#AArch64.AllocationTagAccessIsEnabled.1" title="function: boolean AArch64.AllocationTagAccessIsEnabled(bits(2) el)">AArch64.AllocationTagAccessIsEnabled</a>(accdesc.el);

    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(vaddress, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        if <a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(memaddrdesc.fault) then
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(vaddress, memaddrdesc.fault);
        else
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(regval, memaddrdesc.fault);

    if !accdesc.tagaccess || memaddrdesc.memattrs.tags != <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a> then
        return;

    for i = 0 to count-1
        memstatus = <a href="shared_pseudocode.html#impl-aarch64.PhysMemTagWrite.3" title="function: PhysMemRetStatus PhysMemTagWrite(AddressDescriptor desc, AccessDescriptor accdesc, bits (4) value)">PhysMemTagWrite</a>(memaddrdesc, accdesc, tag);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, 1, accdesc);

        memaddrdesc.paddress.address = memaddrdesc.paddress.address + <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.d128.IsD128Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/d128/IsD128Enabled</h3>
      <p class="pseudocode">// IsD128Enabled()
// ===============
// Returns true if 128-bit page descriptor is enabled

boolean <a id="impl-aarch64.IsD128Enabled.1"/>IsD128Enabled(bits(2) el)
    boolean d128enabled;
    if <a href="shared_pseudocode.html#impl-shared.Have128BitDescriptorExt.0" title="function: boolean Have128BitDescriptorExt()">Have128BitDescriptorExt</a>() then
        case el of
            when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
                if !<a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>) then
                    d128enabled = <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL1Enabled.0" title="function: boolean IsTCR2EL1Enabled()">IsTCR2EL1Enabled</a>() &amp;&amp; TCR2_EL1.D128 == '1';
                else
                    d128enabled = <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() &amp;&amp; TCR2_EL2.D128 == '1';
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
                d128enabled = <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL1Enabled.0" title="function: boolean IsTCR2EL1Enabled()">IsTCR2EL1Enabled</a>() &amp;&amp; TCR2_EL1.D128 == '1';
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
                d128enabled = <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() &amp;&amp; HCR_EL2.E2H == '1' &amp;&amp; TCR2_EL2.D128 == '1';
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
                d128enabled = TCR_EL3.D128 == '1';
    else
        d128enabled = FALSE;

    return d128enabled;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.exclusive.AArch64.ExclusiveMonitorsPass"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/exclusive/AArch64.ExclusiveMonitorsPass</h3>
      <p class="pseudocode">// AArch64.ExclusiveMonitorsPass()
// ===============================
// Return TRUE if the Exclusives monitors for the current PE include all of the addresses
// associated with the virtual address region of size bytes starting at address.
// The immediately following memory write must be to the same addresses.

boolean <a id="AArch64.ExclusiveMonitorsPass.2"/>AArch64.ExclusiveMonitorsPass(bits(64) address, integer size)

    // It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
    // before or after the check on the local Exclusives monitor. As a result a failure
    // of the local monitor can occur on some implementations even if the memory
    // access would give an memory abort.
    boolean acqrel = FALSE;
    boolean tagchecked = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescExLDST.3" title="function: AccessDescriptor CreateAccDescExLDST(MemOp memop, boolean acqrel, boolean tagchecked)">CreateAccDescExLDST</a>(<a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>, acqrel, tagchecked);
    boolean aligned = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, size);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#AArch64.UnalignedAccessFaults.3" title="function: boolean AArch64.UnalignedAccessFaults(AccessDescriptor accdesc, bits(64) address, integer size)">AArch64.UnalignedAccessFaults</a>(accdesc, address, size) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    if !<a href="shared_pseudocode.html#AArch64.IsExclusiveVA.3" title="function: boolean AArch64.IsExclusiveVA(bits(64) address, integer processorid, integer size)">AArch64.IsExclusiveVA</a>(address, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size) then
        return FALSE;

    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    passed = <a href="shared_pseudocode.html#impl-shared.IsExclusiveLocal.3" title="function: boolean IsExclusiveLocal(FullAddress paddress, integer processorid, integer size)">IsExclusiveLocal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>());

    if passed &amp;&amp; memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        passed = <a href="shared_pseudocode.html#impl-shared.IsExclusiveGlobal.3" title="function: boolean IsExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">IsExclusiveGlobal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    return passed;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.exclusive.AArch64.IsExclusiveVA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/exclusive/AArch64.IsExclusiveVA</h3>
      <p class="pseudocode">// An optional IMPLEMENTATION DEFINED test for an exclusive access to a virtual
// address region of size bytes starting at address.
//
// It is permitted (but not required) for this function to return FALSE and
// cause a store exclusive to fail if the virtual address region is not
// totally included within the region recorded by MarkExclusiveVA().
//
// It is always safe to return TRUE which will check the physical address only.
boolean <a id="AArch64.IsExclusiveVA.3"/>AArch64.IsExclusiveVA(bits(64) address, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.exclusive.AArch64.MarkExclusiveVA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/exclusive/AArch64.MarkExclusiveVA</h3>
      <p class="pseudocode">// Optionally record an exclusive access to the virtual address region of size bytes
// starting at address for processorid.
<a id="AArch64.MarkExclusiveVA.3"/>AArch64.MarkExclusiveVA(bits(64) address, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.exclusive.AArch64.SetExclusiveMonitors"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/exclusive/AArch64.SetExclusiveMonitors</h3>
      <p class="pseudocode">// AArch64.SetExclusiveMonitors()
// ==============================
// Sets the Exclusives monitors for the current PE to record the addresses associated
// with the virtual address region of size bytes starting at address.

<a id="AArch64.SetExclusiveMonitors.2"/>AArch64.SetExclusiveMonitors(bits(64) address, integer size)
    boolean acqrel = FALSE;
    boolean tagchecked = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescExLDST.3" title="function: AccessDescriptor CreateAccDescExLDST(MemOp memop, boolean acqrel, boolean tagchecked)">CreateAccDescExLDST</a>(<a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>, acqrel, tagchecked);
    boolean aligned = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, size);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#AArch64.UnalignedAccessFaults.3" title="function: boolean AArch64.UnalignedAccessFaults(AccessDescriptor accdesc, bits(64) address, integer size)">AArch64.UnalignedAccessFaults</a>(accdesc, address, size) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        return;

    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.MarkExclusiveGlobal.3" title="function: MarkExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveGlobal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a href="shared_pseudocode.html#impl-shared.MarkExclusiveLocal.3" title="function: MarkExclusiveLocal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveLocal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a href="shared_pseudocode.html#AArch64.MarkExclusiveVA.3" title="function: AArch64.MarkExclusiveVA(bits(64) address, integer processorid, integer size)">AArch64.MarkExclusiveVA</a>(address, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.fusedrstep.FPRSqrtStepFused"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/fusedrstep/FPRSqrtStepFused</h3>
      <p class="pseudocode">// FPRSqrtStepFused()
// ==================

bits(N) <a id="impl-aarch64.FPRSqrtStepFused.2"/>FPRSqrtStepFused(bits(N) op1_in, bits(N) op2)
    assert N IN {16, 32, 64};
    bits(N) result;
    bits(N) op1 = op1_in;
    boolean done;
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
    op1 = <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(op1);
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;                         // Generate no floating-point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';             // Flush denormal input and output to zero
    if altfp then fpcr.RMode = '00';                // Use RNE rounding mode

    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.6" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, fpexc);
    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPOnePointFive.2" title="function: bits(N) FPOnePointFive(bit sign, integer N)">FPOnePointFive</a>('0', N);
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign1 EOR sign2, N);
        else
            // Fully fused multiply-add and halve
            result_value = (3.0 + (value1 * value2)) / 2.0;
            if result_value == 0.0 then
                // Sign of exact zero result depends on rounding mode
                sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.5" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc, integer N)">FPRound</a>(result_value, fpcr, rounding, fpexc, N);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.fusedrstep.FPRecipStepFused"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/fusedrstep/FPRecipStepFused</h3>
      <p class="pseudocode">// FPRecipStepFused()
// ==================

bits(N) <a id="impl-aarch64.FPRecipStepFused.2"/>FPRecipStepFused(bits(N) op1_in, bits(N) op2)
    assert N IN {16, 32, 64};
    bits(N) op1 = op1_in;
    bits(N) result;
    boolean done;
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
    op1 = <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(op1);

    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;                         // Generate no floating-point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';             // Flush denormal input and output to zero
    if altfp then fpcr.RMode    = '00';             // Use RNE rounding mode

    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.6" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, fpexc);
    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    if !done then
        inf1  = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2  = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPTwo.2" title="function: bits(N) FPTwo(bit sign, integer N)">FPTwo</a>('0', N);
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign1 EOR sign2, N);
        else
            // Fully fused multiply-add
            result_value = 2.0 + (value1 * value2);
            if result_value == 0.0 then
                // Sign of exact zero result depends on rounding mode
                sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.5" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc, integer N)">FPRound</a>(result_value, fpcr, rounding, fpexc, N);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec.AArch64.S1AMECFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec/AArch64.S1AMECFault</h3>
      <p class="pseudocode">// AArch64.S1AMECFault()
// =====================
// Returns TRUE if a Translation fault should occur for Realm EL2 and Realm EL2&amp;0
// stage 1 translated addresses to Realm PA space.

boolean AArch64.S1AMECFault(S1TTWParams walkparams, <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> paspace, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                            bits(N) descriptor)
    assert N IN {64,128};
    bit descriptor_amec = if walkparams.d128 == '1' then descriptor&lt;103&gt; else descriptor&lt;63&gt;;

    return (walkparams.&lt;mecrl,amec&gt; == '10' &amp;&amp;
            regime IN {<a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>, <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>} &amp;&amp;
            paspace == <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> &amp;&amp;
            descriptor_amec == '1');</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec.AArch64.S1DisabledOutputMECID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec/AArch64.S1DisabledOutputMECID</h3>
      <p class="pseudocode">// AArch64.S1DisabledOutputMECID()
// ===============================
// Returns the output MECID when stage 1 address translation is disabled.

bits(16) AArch64.S1DisabledOutputMECID(S1TTWParams walkparams, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> paspace)
    if walkparams.mecrl == '0' then
        return <a href="shared_pseudocode.html#DEFAULT_MECID" title="constant bits(16) DEFAULT_MECID = Zeros(16)">DEFAULT_MECID</a>;

    if !(regime IN {<a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>, <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>, <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>}) then
        return <a href="shared_pseudocode.html#DEFAULT_MECID" title="constant bits(16) DEFAULT_MECID = Zeros(16)">DEFAULT_MECID</a>;

    if paspace != <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> then
        return <a href="shared_pseudocode.html#DEFAULT_MECID" title="constant bits(16) DEFAULT_MECID = Zeros(16)">DEFAULT_MECID</a>;

    if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> then
        return VMECID_P_EL2.MECID;
    else
        return MECID_P0_EL2.MECID;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec.AArch64.S1OutputMECID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec/AArch64.S1OutputMECID</h3>
      <p class="pseudocode">// AArch64.S1OutputMECID()
// =======================
// Returns the output MECID when stage 1 address translation is enabled.

bits(16) AArch64.S1OutputMECID(S1TTWParams walkparams, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#VARange" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> varange,
                               <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> paspace, bits(N) descriptor)
    assert N IN {64,128};

    if walkparams.mecrl == '0' then
        return <a href="shared_pseudocode.html#DEFAULT_MECID" title="constant bits(16) DEFAULT_MECID = Zeros(16)">DEFAULT_MECID</a>;

    if paspace != <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> then
        return <a href="shared_pseudocode.html#DEFAULT_MECID" title="constant bits(16) DEFAULT_MECID = Zeros(16)">DEFAULT_MECID</a>;

    bit descriptor_amec = if walkparams.d128 == '1' then descriptor&lt;103&gt; else descriptor&lt;63&gt;;
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>
            return MECID_RL_A_EL3.MECID;
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>
            if descriptor_amec == '0' then
                return MECID_P0_EL2.MECID;
            else
                return MECID_A0_EL2.MECID;
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>
            if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
                if descriptor_amec == '0' then
                    return MECID_P0_EL2.MECID;
                else
                    return MECID_A0_EL2.MECID;
            else
                if descriptor_amec == '0' then
                    return MECID_P1_EL2.MECID;
                else
                    return MECID_A1_EL2.MECID;
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>
            return VMECID_P_EL2.MECID;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec.AArch64.S2OutputMECID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec/AArch64.S2OutputMECID</h3>
      <p class="pseudocode">// AArch64.S2OutputMECID()
// =======================
// Returns the output MECID for stage 2 address translation.

bits(16) AArch64.S2OutputMECID(S2TTWParams walkparams, <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> paspace, bits(N) descriptor)
    assert N IN {64,128};

    if walkparams.mecrl == '0' then
        return <a href="shared_pseudocode.html#DEFAULT_MECID" title="constant bits(16) DEFAULT_MECID = Zeros(16)">DEFAULT_MECID</a>;

    if paspace != <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> then
        return <a href="shared_pseudocode.html#DEFAULT_MECID" title="constant bits(16) DEFAULT_MECID = Zeros(16)">DEFAULT_MECID</a>;

    bit descriptor_amec = if walkparams.d128 == '1' then descriptor&lt;103&gt; else descriptor&lt;63&gt;;
    if descriptor_amec == '0' then
        return VMECID_P_EL2.MECID;
    else
        return VMECID_A_EL2.MECID;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec.AArch64.TTWalkMECID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec/AArch64.TTWalkMECID</h3>
      <p class="pseudocode">// AArch64.TTWalkMECID()
// =====================
// Returns the associated MECID for the translation table walk of the given
// translation regime and Security state.

bits(16) <a id="AArch64.TTWalkMECID.3"/>AArch64.TTWalkMECID(bit mecrl, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    if mecrl == '0' then
        return <a href="shared_pseudocode.html#DEFAULT_MECID" title="constant bits(16) DEFAULT_MECID = Zeros(16)">DEFAULT_MECID</a>;

    if ss != <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> then
        return <a href="shared_pseudocode.html#DEFAULT_MECID" title="constant bits(16) DEFAULT_MECID = Zeros(16)">DEFAULT_MECID</a>;

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>
            return MECID_P0_EL2.MECID;
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>
            if TCR_EL2.A1 == '0' then
                return MECID_P1_EL2.MECID;
            else
                return MECID_P0_EL2.MECID;
        // This applies to stage 1 and stage 2 translation table walks for
        // Realm EL1&amp;0, but the stage 2 translation for a stage 1 walk
        // might later override the MECID according to AMEC configuration.
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>
            return VMECID_P_EL2.MECID;
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec.DEFAULT_MECID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec/DEFAULT_MECID</h3>
      <p class="pseudocode">constant bits(16) <a id="DEFAULT_MECID"/>DEFAULT_MECID = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.AccessIsTagChecked"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.AccessIsTagChecked</h3>
      <p class="pseudocode">// AArch64.AccessIsTagChecked()
// ============================
// TRUE if a given access is tag-checked, FALSE otherwise.

boolean <a id="AArch64.AccessIsTagChecked.2"/>AArch64.AccessIsTagChecked(bits(64) vaddr, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    assert accdesc.tagchecked;

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        return FALSE;

    boolean is_instr = FALSE;
    if (<a href="shared_pseudocode.html#impl-shared.EffectiveMTX.3" title="function: bit EffectiveMTX(bits(64) address, boolean is_instr, bits(2) el)">EffectiveMTX</a>(vaddr, is_instr, PSTATE.EL) == '0' &amp;&amp;
        <a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(vaddr, is_instr, PSTATE.EL) == '0') then
        return FALSE;

    if (<a href="shared_pseudocode.html#impl-shared.EffectiveTCMA.2" title="function: bit EffectiveTCMA(bits(64) address, bits(2) el)">EffectiveTCMA</a>(vaddr, PSTATE.EL) == '1' &amp;&amp;
            (vaddr&lt;59:55&gt; == '00000' || vaddr&lt;59:55&gt; == '11111')) then
        return FALSE;

    if !<a href="shared_pseudocode.html#AArch64.AllocationTagAccessIsEnabled.1" title="function: boolean AArch64.AllocationTagAccessIsEnabled(bits(2) el)">AArch64.AllocationTagAccessIsEnabled</a>(accdesc.el) then
        return FALSE;

    if PSTATE.TCO=='1' then
        return FALSE;

    if <a href="shared_pseudocode.html#impl-shared.HaveMTEStoreOnlyExt.0" title="function: boolean HaveMTEStoreOnlyExt()">HaveMTEStoreOnlyExt</a>() &amp;&amp; !accdesc.write &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.StoreOnlyTagCheckingEnabled.0" title="function: boolean StoreOnlyTagCheckingEnabled()">StoreOnlyTagCheckingEnabled</a>() then
        return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.AddressWithAllocationTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.AddressWithAllocationTag</h3>
      <p class="pseudocode">// AArch64.AddressWithAllocationTag()
// ==================================
// Generate a 64-bit value containing a Logical Address Tag from a 64-bit
// virtual address and an Allocation Tag.
// If the extension is disabled, treats the Allocation Tag as '0000'.

bits(64) <a id="AArch64.AddressWithAllocationTag.2"/>AArch64.AddressWithAllocationTag(bits(64) address, bits(4) allocation_tag)
    bits(64) result = address;
    bits(4) tag;
    if <a href="shared_pseudocode.html#AArch64.AllocationTagAccessIsEnabled.1" title="function: boolean AArch64.AllocationTagAccessIsEnabled(bits(2) el)">AArch64.AllocationTagAccessIsEnabled</a>(PSTATE.EL) then
        tag = allocation_tag;
    else
        tag = '0000';
    result&lt;59:56&gt; = tag;
    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.AllocationTagCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.AllocationTagCheck</h3>
      <p class="pseudocode">// AArch64.AllocationTagCheck()
// ============================
// Performs an Allocation Tag Check operation for a memory access and
// returns whether the check passed.

boolean <a id="AArch64.AllocationTagCheck.3"/>AArch64.AllocationTagCheck(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc,
                                   bits(4) ptag)
    if memaddrdesc.memattrs.tags == <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a> then
        (memstatus, readtag) = <a href="shared_pseudocode.html#impl-aarch64.PhysMemTagRead.2" title="function: (PhysMemRetStatus, bits(4)) PhysMemTagRead(AddressDescriptor desc, AccessDescriptor accdesc)">PhysMemTagRead</a>(memaddrdesc, accdesc);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, 1, accdesc);

        return ptag == readtag;
    else
        return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.AllocationTagFromAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.AllocationTagFromAddress</h3>
      <p class="pseudocode">// AArch64.AllocationTagFromAddress()
// ==================================
// Generate an Allocation Tag from a 64-bit value containing a Logical Address Tag.

bits(4) <a id="AArch64.AllocationTagFromAddress.1"/>AArch64.AllocationTagFromAddress(bits(64) tagged_address)
    return tagged_address&lt;59:56&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.CanonicalTagCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.CanonicalTagCheck</h3>
      <p class="pseudocode">// AArch64.CanonicalTagCheck()
// ===========================
// Performs a Canonical Tag Check operation for a memory access and
// returns whether the check passed.

boolean <a id="AArch64.CanonicalTagCheck.2"/>AArch64.CanonicalTagCheck(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc, bits(4) ptag)
    expected_tag = if memaddrdesc.vaddress&lt;55&gt; == '0' then '0000' else '1111';
    return ptag == expected_tag;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.CheckTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.CheckTag</h3>
      <p class="pseudocode">// AArch64.CheckTag()
// ==================
// Performs a Tag Check operation for a memory access and returns
// whether the check passed

boolean <a id="AArch64.CheckTag.3"/>AArch64.CheckTag(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, bits(4) ptag)
    if memaddrdesc.memattrs.tags == <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a> then
        return <a href="shared_pseudocode.html#AArch64.AllocationTagCheck.3" title="function: boolean AArch64.AllocationTagCheck(AddressDescriptor memaddrdesc, AccessDescriptor accdesc,&#13; bits(4) ptag)">AArch64.AllocationTagCheck</a>(memaddrdesc, accdesc, ptag);
    elsif memaddrdesc.memattrs.tags == <a href="shared_pseudocode.html#MemTag_CanonicallyTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_CanonicallyTagged</a> then
        return <a href="shared_pseudocode.html#AArch64.CanonicalTagCheck.2" title="function: boolean AArch64.CanonicalTagCheck(AddressDescriptor memaddrdesc, bits(4) ptag)">AArch64.CanonicalTagCheck</a>(memaddrdesc, ptag);
    else
        return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.MemSingle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.MemSingle</h3>
      <p class="pseudocode">// AArch64.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8) <a id="AArch64.MemSingle.read.4"/>AArch64.MemSingle[bits(64) address, integer size,
                               <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, boolean aligned]
    boolean ispair = FALSE;
    return <a href="shared_pseudocode.html#AArch64.MemSingle.read.5" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, size, accdesc, aligned, ispair];

// AArch64.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8) <a id="AArch64.MemSingle.read.5"/>AArch64.MemSingle[bits(64) address, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in,
                               boolean aligned, boolean ispair]
    assert size IN {1, 2, 4, 8, 16};
    bits(size*8) value;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;
    if <a href="shared_pseudocode.html#impl-shared.HaveLSE2Ext.0" title="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() then
        assert <a href="shared_pseudocode.html#impl-aarch64.AllInAlignedQuantity.3" title="function: boolean AllInAlignedQuantity(bits(64) address, integer size, integer alignment)">AllInAlignedQuantity</a>(address, size, 16);
    else
        assert <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, size);

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccessDescriptor accdesc)">AArch64.AccessIsTagChecked</a>(address, accdesc);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Memory array access
    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then
        if accdesc.transactional &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.MemHasTransactionalAccess.1" title="function: boolean MemHasTransactionalAccess(MemoryAttributes memattrs)">MemHasTransactionalAccess</a>(memaddrdesc.memattrs) then
            <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(<a href="shared_pseudocode.html#TMFailure_IMP" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_IMP</a>, FALSE);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
        if !<a href="shared_pseudocode.html#AArch64.CheckTag.3" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag) then
            <a href="shared_pseudocode.html#AArch64.TagCheckFault.2" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccessDescriptor accdesc)">AArch64.TagCheckFault</a>(address, accdesc);

    boolean atomic;
    if (memaddrdesc.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp;
            memaddrdesc.memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
            memaddrdesc.memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>) then
        atomic = TRUE;
    elsif (accdesc.exclusive || accdesc.atomicop ||
            accdesc.acqsc || accdesc.acqpc || accdesc.relsc) then
        if !aligned &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_MISALIGNEDATOMIC" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_MISALIGNEDATOMIC</a>) then
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));
        else
            atomic = TRUE;
    elsif aligned then
        atomic = !ispair;
    else
        atomic = boolean IMPLEMENTATION_DEFINED "Misaligned accesses within 16 byte aligned memory but not Normal Cacheable Writeback are Atomic";

    <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
    if atomic then
        (memstatus, value) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size, accdesc);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size, accdesc);
    elsif aligned &amp;&amp; ispair then
        assert size IN {8, 16};
        constant halfsize = size DIV 2;
        bits(halfsize * 8) lowhalf, highhalf;
        (memstatus, lowhalf) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, halfsize, accdesc);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, halfsize, accdesc);
        memaddrdesc.paddress.address = memaddrdesc.paddress.address + halfsize;
        (memstatus, highhalf) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, halfsize, accdesc);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, halfsize, accdesc);

        value = highhalf:lowhalf;
    else
        for i = 0 to size-1
            (memstatus, value&lt;8*i+7:8*i&gt;) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, 1, accdesc);
            if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
                <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, 1, accdesc);
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
    return value;

// AArch64.MemSingle[] - assignment (write) form
// =============================================

<a id="AArch64.MemSingle.write.4"/>AArch64.MemSingle[bits(64) address, integer size,
                  <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, boolean aligned] = bits(size*8) value
    boolean ispair = FALSE;
    <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, size, accdesc, aligned, ispair] = value;
    return;

// AArch64.MemSingle[] - assignment (write) form
// =============================================
// Perform an atomic, little-endian write of 'size' bytes.

<a id="AArch64.MemSingle.write.5"/>AArch64.MemSingle[bits(64) address, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in,
                  boolean aligned, boolean ispair] = bits(size*8) value
    assert size IN {1, 2, 4, 8, 16};
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;
    if <a href="shared_pseudocode.html#impl-shared.HaveLSE2Ext.0" title="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() then
        assert <a href="shared_pseudocode.html#impl-aarch64.AllInAlignedQuantity.3" title="function: boolean AllInAlignedQuantity(bits(64) address, integer size, integer alignment)">AllInAlignedQuantity</a>(address, size, 16);
    else
        assert <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, size);

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccessDescriptor accdesc)">AArch64.AccessIsTagChecked</a>(address, accdesc);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then
        if accdesc.transactional &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.MemHasTransactionalAccess.1" title="function: boolean MemHasTransactionalAccess(MemoryAttributes memattrs)">MemHasTransactionalAccess</a>(memaddrdesc.memattrs) then
            <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(<a href="shared_pseudocode.html#TMFailure_IMP" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_IMP</a>, FALSE);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
        if !<a href="shared_pseudocode.html#AArch64.CheckTag.3" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag) then
            <a href="shared_pseudocode.html#AArch64.TagCheckFault.2" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccessDescriptor accdesc)">AArch64.TagCheckFault</a>(address, accdesc);

    <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
    boolean atomic;
    if (memaddrdesc.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp;
            memaddrdesc.memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
            memaddrdesc.memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>) then
        atomic = TRUE;
    elsif (accdesc.exclusive || accdesc.atomicop ||
            accdesc.acqsc || accdesc.acqpc || accdesc.relsc) then
        if !aligned &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_MISALIGNEDATOMIC" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_MISALIGNEDATOMIC</a>) then
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));
        else
            atomic = TRUE;
    elsif aligned then
        atomic = !ispair;
    else
        atomic = boolean IMPLEMENTATION_DEFINED "Misaligned accesses within 16 byte aligned memory but not Normal Cacheable Writeback are Atomic";

    if atomic then
        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size, accdesc, value);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size, accdesc);
    elsif aligned &amp;&amp; ispair then
        assert size IN {8, 16};
        constant halfsize = size DIV 2;
        bits(halfsize*8) lowhalf, highhalf;
        &lt;highhalf, lowhalf&gt; = value;

        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, halfsize, accdesc, lowhalf);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, halfsize, accdesc);
        memaddrdesc.paddress.address = memaddrdesc.paddress.address + halfsize;
        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, halfsize, accdesc, highhalf);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, halfsize, accdesc);
    else
        for i = 0 to size-1
            memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, 1, accdesc, value&lt;8*i+7:8*i&gt;);
            if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
                <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, 1, accdesc);
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.MemTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.MemTag</h3>
      <p class="pseudocode">// AArch64.MemTag[] - non-assignment (read) form
// =============================================
// Load an Allocation Tag from memory.

bits(4) <a id="AArch64.MemTag.read.2"/>AArch64.MemTag[bits(64) address, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in]
    assert accdesc_in.tagaccess &amp;&amp; !accdesc_in.tagchecked;

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;
    bits(4) value;

    boolean aligned = TRUE;

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        accdesc.tagaccess = <a href="shared_pseudocode.html#AArch64.AllocationTagAccessIsEnabled.1" title="function: boolean AArch64.AllocationTagAccessIsEnabled(bits(2) el)">AArch64.AllocationTagAccessIsEnabled</a>(accdesc.el);

    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, accdesc, aligned, <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Return the granule tag if tagging is enabled...
    if accdesc.tagaccess &amp;&amp; memaddrdesc.memattrs.tags == <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a> then
        (memstatus, tag) = <a href="shared_pseudocode.html#impl-aarch64.PhysMemTagRead.2" title="function: (PhysMemRetStatus, bits(4)) PhysMemTagRead(AddressDescriptor desc, AccessDescriptor accdesc)">PhysMemTagRead</a>(memaddrdesc, accdesc);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, 1, accdesc);
        return tag;
    elsif (<a href="shared_pseudocode.html#impl-shared.HaveMTECanonicalTagCheckingExt.0" title="function: boolean HaveMTECanonicalTagCheckingExt()">HaveMTECanonicalTagCheckingExt</a>() &amp;&amp;
           accdesc.tagaccess &amp;&amp;
           memaddrdesc.memattrs.tags == <a href="shared_pseudocode.html#MemTag_CanonicallyTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_CanonicallyTagged</a>) then
        return if address&lt;55&gt; == '0' then '0000' else '1111';
    else
        // ...otherwise read tag as zero.
        return '0000';

// AArch64.MemTag[] - assignment (write) form
// ==========================================
// Store an Allocation Tag to memory.

<a id="AArch64.MemTag.write.2"/>AArch64.MemTag[bits(64) address, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in] = bits(4) value
    assert accdesc_in.tagaccess &amp;&amp; !accdesc_in.tagchecked;

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;

    boolean aligned = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>);

    // Stores of allocation tags must be aligned
    if !aligned then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        accdesc.tagaccess = <a href="shared_pseudocode.html#AArch64.AllocationTagAccessIsEnabled.1" title="function: boolean AArch64.AllocationTagAccessIsEnabled(bits(2) el)">AArch64.AllocationTagAccessIsEnabled</a>(accdesc.el);

    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, accdesc, aligned, <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Memory array access
    if accdesc.tagaccess &amp;&amp; memaddrdesc.memattrs.tags == <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a> then
        memstatus = <a href="shared_pseudocode.html#impl-aarch64.PhysMemTagWrite.3" title="function: PhysMemRetStatus PhysMemTagWrite(AddressDescriptor desc, AccessDescriptor accdesc, bits (4) value)">PhysMemTagWrite</a>(memaddrdesc, accdesc, value);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, 1, accdesc);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.PhysicalTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.PhysicalTag</h3>
      <p class="pseudocode">// AArch64.PhysicalTag()
// =====================
// Generate a Physical Tag from a Logical Tag in an address

bits(4) <a id="AArch64.PhysicalTag.1"/>AArch64.PhysicalTag(bits(64) vaddr)
    return vaddr&lt;59:56&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.UnalignedAccessFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.UnalignedAccessFaults</h3>
      <p class="pseudocode">// AArch64.UnalignedAccessFaults()
// ===============================
// Determine whether the unaligned access generates an Alignment fault

boolean <a id="AArch64.UnalignedAccessFaults.3"/>AArch64.UnalignedAccessFaults(<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, bits(64) address, integer size)
    if <a href="shared_pseudocode.html#impl-shared.AlignmentEnforced.0" title="function: boolean AlignmentEnforced()">AlignmentEnforced</a>() then
        return TRUE;
    elsif accdesc.rcw then
        return TRUE;
    elsif accdesc.ls64 then
        return TRUE;
    elsif accdesc.exclusive || accdesc.atomicop then
        return !<a href="shared_pseudocode.html#impl-shared.HaveLSE2Ext.0" title="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() || !<a href="shared_pseudocode.html#impl-aarch64.AllInAlignedQuantity.3" title="function: boolean AllInAlignedQuantity(bits(64) address, integer size, integer alignment)">AllInAlignedQuantity</a>(address, size, 16);
    elsif accdesc.acqsc || accdesc.acqpc || accdesc.relsc then
        return !<a href="shared_pseudocode.html#impl-shared.HaveLSE2Ext.0" title="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() || (<a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].nAA == '0' &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.AllInAlignedQuantity.3" title="function: boolean AllInAlignedQuantity(bits(64) address, integer size, integer alignment)">AllInAlignedQuantity</a>(address, size, 16));
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AddressSupportsLS64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AddressSupportsLS64</h3>
      <p class="pseudocode">// Returns TRUE if the 64-byte block following the given address supports the
// LD64B and ST64B instructions, and FALSE otherwise.
boolean <a id="impl-aarch64.AddressSupportsLS64.1"/>AddressSupportsLS64(bits(56) paddress);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AllInAlignedQuantity"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AllInAlignedQuantity</h3>
      <p class="pseudocode">// AllInAlignedQuantity()
// ======================
// Returns TRUE if all accessed bytes are within one aligned quantity, FALSE otherwise.

boolean <a id="impl-aarch64.AllInAlignedQuantity.3"/>AllInAlignedQuantity(bits(64) address, integer size, integer alignment)
    assert(size &lt;= alignment);
    return <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address+size-1, alignment) == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, alignment);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.CheckSPAlignment"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/CheckSPAlignment</h3>
      <p class="pseudocode">// CheckSPAlignment()
// ==================
// Check correct stack pointer alignment for AArch64 state.

<a id="impl-aarch64.CheckSPAlignment.0"/>CheckSPAlignment()
    bits(64) sp = <a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(64) SP[]">SP</a>[];
    boolean stack_align_check;
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        stack_align_check = (<a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SA0 != '0');
    else
        stack_align_check = (<a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SA != '0');

    if stack_align_check &amp;&amp; sp != <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(sp, 16) then
        <a href="shared_pseudocode.html#AArch64.SPAlignmentFault.0" title="function: AArch64.SPAlignmentFault()">AArch64.SPAlignmentFault</a>();

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.Mem"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/Mem</h3>
      <p class="pseudocode">// Mem[] - non-assignment (read) form
// ==================================
// Perform a read of 'size' bytes. The access byte order is reversed for a big-endian access.
// Instruction fetches would call AArch64.MemSingle directly.

bits(size*8) <a id="impl-aarch64.Mem.read.3"/>Mem[bits(64) address, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc]
    boolean ispair = FALSE;
    boolean highestAddressfirst = FALSE;
    return <a href="shared_pseudocode.html#impl-aarch64.Mem.read.5" title="accessor: bits(size*8) Mem[bits(64) address, integer size, AccessDescriptor accdesc,&#13; boolean ispair, boolean  highestAddressfirst]">Mem</a>[address, size, accdesc, ispair, highestAddressfirst];

bits(size*8) <a id="impl-aarch64.Mem.read.4"/>Mem[bits(64) address, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, boolean ispair]
    boolean highestAddressfirst = FALSE;
    return <a href="shared_pseudocode.html#impl-aarch64.Mem.read.5" title="accessor: bits(size*8) Mem[bits(64) address, integer size, AccessDescriptor accdesc,&#13; boolean ispair, boolean  highestAddressfirst]">Mem</a>[address, size, accdesc, ispair, highestAddressfirst];

bits(size*8) <a id="impl-aarch64.Mem.read.5"/>Mem[bits(64) address, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc,
                 boolean ispair, boolean  highestAddressfirst]
    assert size IN {1, 2, 4, 8, 16};
    constant halfsize = size DIV 2;
    bits(size * 8) value;
    bits(halfsize * 8) lowhalf, highhalf;

    // Check alignment on size of element accessed, not overall access size
    integer alignment = if ispair then halfsize else size;
    boolean aligned   = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, alignment);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#AArch64.UnalignedAccessFaults.3" title="function: boolean AArch64.UnalignedAccessFaults(AccessDescriptor accdesc, bits(64) address, integer size)">AArch64.UnalignedAccessFaults</a>(accdesc, address, size) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_ASIMD" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_ASIMD</a> &amp;&amp; size == 16 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, 8) then
        // If 128-bit SIMD&amp;FP ordered access are treated as a pair of
        // 64-bit single-copy atomic accesses, then these single copy atomic
        // access can be observed in any order.
        lowhalf = <a href="shared_pseudocode.html#AArch64.MemSingle.read.5" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, halfsize, accdesc, aligned, ispair];
        highhalf = <a href="shared_pseudocode.html#AArch64.MemSingle.read.5" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address+halfsize, halfsize, accdesc, aligned, ispair];
        value = highhalf:lowhalf;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveLSE2Ext.0" title="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.AllInAlignedQuantity.3" title="function: boolean AllInAlignedQuantity(bits(64) address, integer size, integer alignment)">AllInAlignedQuantity</a>(address, size, 16) then
        value = <a href="shared_pseudocode.html#AArch64.MemSingle.read.5" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, size, accdesc, aligned, ispair];
    elsif ispair &amp;&amp; aligned then
        if <a href="shared_pseudocode.html#impl-shared.HaveLRCPC3Ext.0" title="function: boolean HaveLRCPC3Ext()">HaveLRCPC3Ext</a>() &amp;&amp; highestAddressfirst then
            highhalf = <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned]">AArch64.MemSingle</a>[address+halfsize, halfsize, accdesc, aligned];
            lowhalf  = <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned]">AArch64.MemSingle</a>[address, halfsize, accdesc, aligned];
        else
            lowhalf  = <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned]">AArch64.MemSingle</a>[address, halfsize, accdesc, aligned];
            highhalf = <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned]">AArch64.MemSingle</a>[address+halfsize, halfsize, accdesc, aligned];
        value = highhalf:lowhalf;
    elsif aligned then
        value = <a href="shared_pseudocode.html#AArch64.MemSingle.read.5" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, size, accdesc, aligned, ispair];
    else
        assert size &gt; 1;
        if <a href="shared_pseudocode.html#impl-shared.HaveLRCPC3Ext.0" title="function: boolean HaveLRCPC3Ext()">HaveLRCPC3Ext</a>() &amp;&amp; ispair &amp;&amp; highestAddressfirst then
            // Performing memory accesses from one load or store instruction to Device memory that
            // crosses a boundary corresponding to the smallest translation granule size of the
            // implementation causes CONSTRAINED UNPREDICTABLE behavior.

            for i = 0 to halfsize-1
                // Individual byte access can be observed in any order
                highhalf&lt;8*i+7:8*i&gt; = <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned]">AArch64.MemSingle</a>[address+halfsize +i, 1, accdesc, aligned];
            for i = 0 to halfsize-1
                // Individual byte access can be observed in any order
                lowhalf&lt;8*i+7:8*i&gt; = <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned]">AArch64.MemSingle</a>[address + i, 1, accdesc, aligned];

            value = highhalf:lowhalf;

        else
            value&lt;7:0&gt; = <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned]">AArch64.MemSingle</a>[address, 1, accdesc, aligned];

            // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device
            // memory access will generate an Alignment Fault, as to get this far means the first
            // byte did not, so we must be changing to a new translation page.
            c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_DEVPAGE2</a>);
            assert c IN {<a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
            if c == <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

            for i = 1 to size-1
                value&lt;8*i+7:8*i&gt; = <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned]">AArch64.MemSingle</a>[address+i, 1, accdesc, aligned];

    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccessType acctype)">BigEndian</a>(accdesc.acctype) then
        value = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    return value;

// Mem[] - assignment (write) form
// ===============================
// Perform a write of 'size' bytes. The byte order is reversed for a big-endian access.

Mem[bits(64) address, integer size, AccessDescriptor accdesc] = bits(size*8) value_in
    boolean ispair = FALSE;
    boolean highestAddressfirst = FALSE;
    Mem[address, size, accdesc, ispair, highestAddressfirst] = value_in;

Mem[bits(64) address, integer size, AccessDescriptor accdesc,
        boolean ispair] = bits(size*8) value_in
    boolean highestAddressfirst = FALSE;
    Mem[address, size, accdesc, ispair, highestAddressfirst] = value_in;

Mem[bits(64) address, integer size, AccessDescriptor accdesc,
        boolean ispair, boolean highestAddressfirst] = bits(size*8) value_in
    constant halfsize = size DIV 2;
    bits(size*8) value = value_in;
    bits(halfsize*8) lowhalf, highhalf;

    // Check alignment on size of element accessed, not overall access size
    integer alignment = if ispair then halfsize else size;
    boolean aligned   = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, alignment);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#AArch64.UnalignedAccessFaults.3" title="function: boolean AArch64.UnalignedAccessFaults(AccessDescriptor accdesc, bits(64) address, integer size)">AArch64.UnalignedAccessFaults</a>(accdesc, address, size) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccessType acctype)">BigEndian</a>(accdesc.acctype) then
        value = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_ASIMD" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_ASIMD</a> &amp;&amp; size == 16 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, 8) then
        // 128-bit SIMD&amp;FP stores are treated as a pair of 64-bit single-copy atomic accesses
        // 64-bit aligned.
        &lt;highhalf, lowhalf&gt; = value;
        <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, halfsize, accdesc, aligned, ispair] = lowhalf;
        <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address+halfsize, halfsize, accdesc, aligned, ispair] = highhalf;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveLSE2Ext.0" title="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.AllInAlignedQuantity.3" title="function: boolean AllInAlignedQuantity(bits(64) address, integer size, integer alignment)">AllInAlignedQuantity</a>(address, size, 16) then
        <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, size, accdesc, aligned, ispair] = value;
    elsif ispair &amp;&amp; aligned then
        joinedpair = FALSE;
        &lt;highhalf, lowhalf&gt; = value;
        if <a href="shared_pseudocode.html#impl-shared.HaveLRCPC3Ext.0" title="function: boolean HaveLRCPC3Ext()">HaveLRCPC3Ext</a>() &amp;&amp; highestAddressfirst then
            <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address+halfsize, halfsize, accdesc, aligned, joinedpair] = highhalf;
            <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, halfsize, accdesc, aligned, joinedpair] = lowhalf;
        else
            <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, halfsize, accdesc, aligned, joinedpair] = lowhalf;
            <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address+halfsize, halfsize, accdesc, aligned, joinedpair] = highhalf;
    elsif aligned then
        <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, size, accdesc, aligned, ispair] = value;
    else
        assert size &gt; 1;
        if <a href="shared_pseudocode.html#impl-shared.HaveLRCPC3Ext.0" title="function: boolean HaveLRCPC3Ext()">HaveLRCPC3Ext</a>() &amp;&amp; ispair &amp;&amp; highestAddressfirst then
            // Performing memory accesses from one load or store instruction to Device memory that
            // crosses a boundary corresponding to the smallest translation granule size of the
            // implementation causes CONSTRAINED UNPREDICTABLE behavior.
            &lt;highhalf, lowhalf&gt; = value;
            for i = 0 to halfsize-1
                // Individual byte access can be observed in any order
                <a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned] = bits(size*8) value">AArch64.MemSingle</a>[address+halfsize+i, 1, accdesc, aligned] = highhalf&lt;8*i+7:8*i&gt;;
            for i = 0 to halfsize-1
                // Individual byte access can be observed in any order, but implies observability
                // of highhalf
                <a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned] = bits(size*8) value">AArch64.MemSingle</a>[address+i, 1, accdesc, aligned] = lowhalf&lt;8*i+7:8*i&gt;;
        else
            <a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned] = bits(size*8) value">AArch64.MemSingle</a>[address, 1, accdesc, aligned] = value&lt;7:0&gt;;

            // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device
            // memory access will generate an Alignment Fault, as to get this far means the first
            // byte did not, so we must be changing to a new translation page.

            c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_DEVPAGE2</a>);
            assert c IN {<a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
            if c == <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

            for i = 1 to size-1
                <a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size,&#13; AccessDescriptor accdesc, boolean aligned] = bits(size*8) value">AArch64.MemSingle</a>[address+i, 1, accdesc, aligned] = value&lt;8*i+7:8*i&gt;;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemAtomic"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemAtomic</h3>
      <p class="pseudocode">// MemAtomic()
// ===========
// Performs load and store memory operations for a given virtual address.

bits(size) <a id="impl-aarch64.MemAtomic.4"/>MemAtomic(bits(64) address, bits(size) cmpoperand, bits(size) operand,
                     <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in)
    assert accdesc_in.atomicop;

    constant integer bytes = size DIV 8;
    assert bytes IN {1, 2, 4, 8, 16};

    bits(size) newvalue;
    bits(size) oldvalue;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;
    boolean aligned = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, bytes);

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccessDescriptor accdesc)">AArch64.AccessIsTagChecked</a>(address, accdesc);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#AArch64.UnalignedAccessFaults.3" title="function: boolean AArch64.UnalignedAccessFaults(AccessDescriptor accdesc, bits(64) address, integer size)">AArch64.UnalignedAccessFaults</a>(accdesc, address, bytes) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    // MMU or MPU lookup
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    // For Store-only Tag checking, the tag check is performed on the store.
    if (<a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked &amp;&amp;
        (!<a href="shared_pseudocode.html#impl-shared.HaveMTEStoreOnlyExt.0" title="function: boolean HaveMTEStoreOnlyExt()">HaveMTEStoreOnlyExt</a>() || !<a href="shared_pseudocode.html#impl-aarch64.StoreOnlyTagCheckingEnabled.0" title="function: boolean StoreOnlyTagCheckingEnabled()">StoreOnlyTagCheckingEnabled</a>())) then
        bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
        if !<a href="shared_pseudocode.html#AArch64.CheckTag.3" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag) then
            <a href="shared_pseudocode.html#AArch64.TagCheckFault.2" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccessDescriptor accdesc)">AArch64.TagCheckFault</a>(address, accdesc);

    // All observers in the shareability domain observe the following load and store atomically.
    <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
    (memstatus, oldvalue) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, bytes, accdesc);

    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, bytes, accdesc);
    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccessType acctype)">BigEndian</a>(accdesc.acctype) then
        oldvalue = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(oldvalue);

    boolean cmpfail = FALSE;
    case accdesc.modop of
        when <a href="shared_pseudocode.html#MemAtomicOp_ADD" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_ADD</a>   newvalue = oldvalue + operand;
        when <a href="shared_pseudocode.html#MemAtomicOp_BIC" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_BIC</a>   newvalue = oldvalue AND NOT(operand);
        when <a href="shared_pseudocode.html#MemAtomicOp_EOR" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_EOR</a>   newvalue = oldvalue EOR operand;
        when <a href="shared_pseudocode.html#MemAtomicOp_ORR" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_ORR</a>   newvalue = oldvalue OR operand;
        when <a href="shared_pseudocode.html#MemAtomicOp_SMAX" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_SMAX</a>  newvalue = <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>(<a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(oldvalue), <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(operand))&lt;size-1:0&gt;;
        when <a href="shared_pseudocode.html#MemAtomicOp_SMIN" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_SMIN</a>  newvalue = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(<a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(oldvalue), <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(operand))&lt;size-1:0&gt;;
        when <a href="shared_pseudocode.html#MemAtomicOp_UMAX" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_UMAX</a>  newvalue = <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(oldvalue), <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand))&lt;size-1:0&gt;;
        when <a href="shared_pseudocode.html#MemAtomicOp_UMIN" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_UMIN</a>  newvalue = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(oldvalue), <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand))&lt;size-1:0&gt;;
        when <a href="shared_pseudocode.html#MemAtomicOp_SWP" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_SWP</a>   newvalue = operand;
        when <a href="shared_pseudocode.html#MemAtomicOp_CAS" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_CAS</a>   newvalue = operand; cmpfail = cmpoperand != oldvalue;

    if <a href="shared_pseudocode.html#impl-shared.HaveMTEStoreOnlyExt.0" title="function: boolean HaveMTEStoreOnlyExt()">HaveMTEStoreOnlyExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.StoreOnlyTagCheckingEnabled.0" title="function: boolean StoreOnlyTagCheckingEnabled()">StoreOnlyTagCheckingEnabled</a>() then
        // If the compare on a CAS fails, then it is CONSTRAINED UNPREDICTABLE whether the
        // Tag check is performed.
        if accdesc.tagchecked &amp;&amp; cmpfail then
            accdesc.tagchecked = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_STOREONLYTAGCHECKEDCAS" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_STOREONLYTAGCHECKEDCAS</a>);

        if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
            bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
            if !<a href="shared_pseudocode.html#AArch64.CheckTag.3" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag) then
                accdesc.read = FALSE; // Tag Check Fault on a write.
                <a href="shared_pseudocode.html#AArch64.TagCheckFault.2" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccessDescriptor accdesc)">AArch64.TagCheckFault</a>(address, accdesc);

    if !cmpfail then
        if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccessType acctype)">BigEndian</a>(accdesc.acctype) then
            newvalue = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(newvalue);
        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, bytes, accdesc, newvalue);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, bytes, accdesc);

    // Load operations return the old (pre-operation) value
    return oldvalue;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemAtomicRCW"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemAtomicRCW</h3>
      <p class="pseudocode">// MemAtomicRCW()
// ==============
// Perform a single-copy-atomic access with Read-Check-Write operation

(bits(4), bits(size)) <a id="impl-aarch64.MemAtomicRCW.4"/>MemAtomicRCW(bits(64) address, bits(size) cmpoperand, bits(size) operand,
                                   <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in)
    assert accdesc_in.atomicop;
    assert accdesc_in.rcw;

    constant integer bytes = size DIV 8;
    assert bytes IN {8, 16};

    bits(4) nzcv;
    bits(size) oldvalue;
    bits(size) newvalue;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;
    boolean aligned = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, bytes);

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccessDescriptor accdesc)">AArch64.AccessIsTagChecked</a>(address, accdesc);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#AArch64.UnalignedAccessFaults.3" title="function: boolean AArch64.UnalignedAccessFaults(AccessDescriptor accdesc, bits(64) address, integer size)">AArch64.UnalignedAccessFaults</a>(accdesc, address, bytes) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    // MMU or MPU lookup
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    // For Store-only Tag checking, the tag check is performed on the store.
    if (<a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked &amp;&amp;
        (!<a href="shared_pseudocode.html#impl-shared.HaveMTEStoreOnlyExt.0" title="function: boolean HaveMTEStoreOnlyExt()">HaveMTEStoreOnlyExt</a>() || !<a href="shared_pseudocode.html#impl-aarch64.StoreOnlyTagCheckingEnabled.0" title="function: boolean StoreOnlyTagCheckingEnabled()">StoreOnlyTagCheckingEnabled</a>())) then
        bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
        if !<a href="shared_pseudocode.html#AArch64.CheckTag.3" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag) then
            <a href="shared_pseudocode.html#AArch64.TagCheckFault.2" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccessDescriptor accdesc)">AArch64.TagCheckFault</a>(address, accdesc);

    // All observers in the shareability domain observe the following load and store atomically.
    <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
    (memstatus, oldvalue) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, bytes, accdesc);

    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, bytes, accdesc);

    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccessType acctype)">BigEndian</a>(accdesc.acctype) then
        oldvalue = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(oldvalue);

    boolean cmpfail = FALSE;
    case accdesc.modop of
        when <a href="shared_pseudocode.html#MemAtomicOp_BIC" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_BIC</a> newvalue = oldvalue AND NOT(operand);
        when <a href="shared_pseudocode.html#MemAtomicOp_ORR" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_ORR</a> newvalue = oldvalue OR operand;
        when <a href="shared_pseudocode.html#MemAtomicOp_SWP" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_SWP</a> newvalue = operand;
        when <a href="shared_pseudocode.html#MemAtomicOp_CAS" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_CAS</a> newvalue = operand; cmpfail = oldvalue != cmpoperand;

    if cmpfail then
        nzcv = '1010'; // N = 1 indicates compare failure
    else
        nzcv = <a href="shared_pseudocode.html#impl-aarch64.RCWCheck.3" title="function: bits(4) RCWCheck(bits(N) old, bits(N) new, boolean soft)">RCWCheck</a>(oldvalue, newvalue, accdesc.rcws);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTEStoreOnlyExt.0" title="function: boolean HaveMTEStoreOnlyExt()">HaveMTEStoreOnlyExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.StoreOnlyTagCheckingEnabled.0" title="function: boolean StoreOnlyTagCheckingEnabled()">StoreOnlyTagCheckingEnabled</a>() then
        // If the compare on a CAS fails, then it is CONSTRAINED UNPREDICTABLE whether the
        // Tag check is performed.
        if accdesc.tagchecked &amp;&amp; cmpfail then
            accdesc.tagchecked = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_STOREONLYTAGCHECKEDCAS" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_STOREONLYTAGCHECKEDCAS</a>);

        if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
            bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
            if !<a href="shared_pseudocode.html#AArch64.CheckTag.3" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag) then
                accdesc.read = FALSE; // Tag Check Fault on a write.
                <a href="shared_pseudocode.html#AArch64.TagCheckFault.2" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccessDescriptor accdesc)">AArch64.TagCheckFault</a>(address, accdesc);

    if nzcv == '0010' then
        if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccessType acctype)">BigEndian</a>(accdesc.acctype) then
            newvalue = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(newvalue);

        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, bytes, accdesc, newvalue);

        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, bytes, accdesc);

    return (nzcv, oldvalue);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemLoad64B"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemLoad64B</h3>
      <p class="pseudocode">// MemLoad64B()
// ============
// Performs an atomic 64-byte read from a given virtual address.

bits(512) <a id="impl-aarch64.MemLoad64B.2"/>MemLoad64B(bits(64) address, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in)
    bits(512) data;
    constant integer size = 64;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;
    boolean aligned = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, size);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#AArch64.UnalignedAccessFaults.3" title="function: boolean AArch64.UnalignedAccessFaults(AccessDescriptor accdesc, bits(64) address, integer size)">AArch64.UnalignedAccessFaults</a>(accdesc, address, size) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccessDescriptor accdesc)">AArch64.AccessIsTagChecked</a>(address, accdesc);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
        if !<a href="shared_pseudocode.html#AArch64.CheckTag.3" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag) then
            <a href="shared_pseudocode.html#AArch64.TagCheckFault.2" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccessDescriptor accdesc)">AArch64.TagCheckFault</a>(address, accdesc);

    if !<a href="shared_pseudocode.html#impl-aarch64.AddressSupportsLS64.1" title="function: boolean AddressSupportsLS64(bits(56) paddress)">AddressSupportsLS64</a>(memaddrdesc.paddress.address) then
        c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_LS64UNSUPPORTED" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_LS64UNSUPPORTED</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_LIMITED_ATOMICITY" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_LIMITED_ATOMICITY</a>, <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>};

        if c == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> then
            // Generate a stage 1 Data Abort reported using the DFSC code of 110101.
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.ExclusiveFault.1" title="function: FaultRecord ExclusiveFault(AccessDescriptor accdesc)">ExclusiveFault</a>(accdesc));
        else
            // Accesses are not single-copy atomic above the byte level.
            for i = 0 to size-1
                <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
                (memstatus, data&lt;8*i+7:8*i&gt;) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, 1, accdesc);
                if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
                    <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, 1, accdesc);

                memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
    else
        <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
        (memstatus, data) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size, accdesc);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size, accdesc);

    return data;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemStore64B"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemStore64B</h3>
      <p class="pseudocode">// MemStore64B()
// =============
// Performs an atomic 64-byte store to a given virtual address. Function does
// not return the status of the store.

<a id="impl-aarch64.MemStore64B.3"/>MemStore64B(bits(64) address, bits(512) value, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in)
    constant integer size = 64;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;
    boolean aligned = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, size);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#AArch64.UnalignedAccessFaults.3" title="function: boolean AArch64.UnalignedAccessFaults(AccessDescriptor accdesc, bits(64) address, integer size)">AArch64.UnalignedAccessFaults</a>(accdesc, address, size) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccessDescriptor accdesc)">AArch64.AccessIsTagChecked</a>(address, accdesc);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), 64);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
        if !<a href="shared_pseudocode.html#AArch64.CheckTag.3" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag) then
            <a href="shared_pseudocode.html#AArch64.TagCheckFault.2" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccessDescriptor accdesc)">AArch64.TagCheckFault</a>(address, accdesc);

    if !<a href="shared_pseudocode.html#impl-aarch64.AddressSupportsLS64.1" title="function: boolean AddressSupportsLS64(bits(56) paddress)">AddressSupportsLS64</a>(memaddrdesc.paddress.address) then
        c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_LS64UNSUPPORTED" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_LS64UNSUPPORTED</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_LIMITED_ATOMICITY" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_LIMITED_ATOMICITY</a>, <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>};

        if c == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> then
            // Generate a Data Abort reported using the DFSC code of 110101.
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.ExclusiveFault.1" title="function: FaultRecord ExclusiveFault(AccessDescriptor accdesc)">ExclusiveFault</a>(accdesc));
        else
            // Accesses are not single-copy atomic above the byte level.
            for i = 0 to size-1
                memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, 1, accdesc, value&lt;8*i+7:8*i&gt;);
                if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
                    <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, 1, accdesc);

                memaddrdesc.paddress.address = memaddrdesc.paddress.address+1;
    else
        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size, accdesc, value);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size, accdesc);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemStore64BWithRet"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemStore64BWithRet</h3>
      <p class="pseudocode">// MemStore64BWithRet()
// ====================
// Performs an atomic 64-byte store to a given virtual address returning
// the status value of the operation.

bits(64) <a id="impl-aarch64.MemStore64BWithRet.3"/>MemStore64BWithRet(bits(64) address, bits(512) value, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in)
    constant integer size = 64;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;
    boolean aligned = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, size);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#AArch64.UnalignedAccessFaults.3" title="function: boolean AArch64.UnalignedAccessFaults(AccessDescriptor accdesc, bits(64) address, integer size)">AArch64.UnalignedAccessFaults</a>(accdesc, address, size) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccessDescriptor accdesc)">AArch64.AccessIsTagChecked</a>(address, accdesc);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);
        return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>('1', 64);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), 64);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
        if !<a href="shared_pseudocode.html#AArch64.CheckTag.3" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag) then
            <a href="shared_pseudocode.html#AArch64.TagCheckFault.2" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccessDescriptor accdesc)">AArch64.TagCheckFault</a>(address, accdesc);
            return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>('1', 64);

    <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
    memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size, accdesc, value);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size, accdesc);

    return memstatus.store64bstatus;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemStore64BWithRetStatus"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemStore64BWithRetStatus</h3>
      <p class="pseudocode">// Generates the return status of memory write with ST64BV or ST64BV0
// instructions. The status indicates if the operation succeeded, failed,
// or was not supported at this memory location.
bits(64) <a id="impl-aarch64.MemStore64BWithRetStatus.0"/>MemStore64BWithRetStatus();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.NVMem"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/NVMem</h3>
      <p class="pseudocode">// NVMem[] - non-assignment form
// =============================
// This function is the load memory access for the transformed System register read access
// when Enhanced Nested Virtualization is enabled with HCR_EL2.NV2 = 1.
// The address for the load memory access is calculated using
// the formula SignExtend(VNCR_EL2.BADDR : Offset&lt;11:0&gt;, 64) where,
//  * VNCR_EL2.BADDR holds the base address of the memory location, and
//  * Offset is the unique offset value defined architecturally for each System register that
//    supports transformation of register access to memory access.

bits(64) <a id="impl-aarch64.NVMem.read.1"/>NVMem[integer offset]
    assert offset &gt; 0;
    bits(64) address = <a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(VNCR_EL2.BADDR:offset&lt;11:0&gt;, 64);
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescNV2.1" title="function: AccessDescriptor CreateAccDescNV2(MemOp memop)">CreateAccDescNV2</a>(<a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>);
    return <a href="shared_pseudocode.html#impl-aarch64.Mem.read.3" title="accessor: bits(size*8) Mem[bits(64) address, integer size, AccessDescriptor accdesc]">Mem</a>[address, 8, accdesc];

// NVMem[] - assignment form
// =========================
// This function is the store memory access for the transformed System register write access
// when Enhanced Nested Virtualization is enabled with HCR_EL2.NV2 = 1.
// The address for the store memory access is calculated using
// the formula SignExtend(VNCR_EL2.BADDR : Offset&lt;11:0&gt;, 64) where,
//  * VNCR_EL2.BADDR holds the base address of the memory location, and
//  * Offset is the unique offset value defined architecturally for each System register that
//    supports transformation of register access to memory access.

<a id="impl-aarch64.NVMem.write.1"/>NVMem[integer offset] = bits(64) value
    assert offset &gt; 0;
    bits(64) address = <a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(VNCR_EL2.BADDR:offset&lt;11:0&gt;, 64);
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescNV2.1" title="function: AccessDescriptor CreateAccDescNV2(MemOp memop)">CreateAccDescNV2</a>(<a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>);
    Mem[address, 8, accdesc] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.PhysMemTagRead"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/PhysMemTagRead</h3>
      <p class="pseudocode">// This is the hardware operation which perform a single-copy atomic,
// Allocation Tag granule aligned, memory access from the tag in PA space.
//
// The function address the array using desc.paddress which supplies:
// * A 52-bit physical address
// * A single NS bit to select between Secure and Non-secure parts of the array.
//
// The accdesc descriptor describes the access type: normal, exclusive, ordered, streaming,
// etc and other parameters required to access the physical memory or for setting syndrome
// register in the event of an External abort.
(PhysMemRetStatus, bits(4)) <a id="impl-aarch64.PhysMemTagRead.2"/>PhysMemTagRead(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> desc, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.PhysMemTagWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/PhysMemTagWrite</h3>
      <p class="pseudocode">// This is the hardware operation which perform a single-copy atomic,
// Allocation Tag granule aligned, memory access to the tag in PA space.
//
// The function address the array using desc.paddress which supplies:
// * A 52-bit physical address
// * A single NS bit to select between Secure and Non-secure parts of the array.
//
// The accdesc descriptor describes the access type: normal, exclusive, ordered, streaming,
// etc and other parameters required to access the physical memory or for setting syndrome
// register in the event of an External abort.
PhysMemRetStatus <a id="impl-aarch64.PhysMemTagWrite.3"/>PhysMemTagWrite(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> desc, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, bits (4) value);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.StoreOnlyTagCheckingEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/StoreOnlyTagCheckingEnabled</h3>
      <p class="pseudocode">// StoreOnlyTagCheckingEnabled()
// =============================
// Returns TRUE if loads executed at the current Exception level are Tag unchecked.

boolean <a id="impl-aarch64.StoreOnlyTagCheckingEnabled.0"/>StoreOnlyTagCheckingEnabled()
    assert <a href="shared_pseudocode.html#impl-shared.HaveMTEStoreOnlyExt.0" title="function: boolean HaveMTEStoreOnlyExt()">HaveMTEStoreOnlyExt</a>();
    bit tcso;

    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            if !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
                tcso = SCTLR_EL1.TCSO0;
            else
                tcso = SCTLR_EL2.TCSO0;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            tcso = SCTLR_EL1.TCSO;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            tcso = SCTLR_EL2.TCSO;
        otherwise
            tcso = SCTLR_EL3.TCSO;

    return tcso == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYFOptionA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYFOptionA</h3>
      <p class="pseudocode">// CPYFOptionA()
// =============
// Returns TRUE if the implementation uses Option A for the
// CPYF* instructions, and FALSE otherwise.

boolean <a id="impl-aarch64.CPYFOptionA.0"/>CPYFOptionA()
    return boolean IMPLEMENTATION_DEFINED "CPYF* instructions use Option A";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYOptionA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYOptionA</h3>
      <p class="pseudocode">// CPYOptionA()
// ============
// Returns TRUE if the implementation uses Option A for the
// CPY* instructions, and FALSE otherwise.

boolean <a id="impl-aarch64.CPYOptionA.0"/>CPYOptionA()
    return boolean IMPLEMENTATION_DEFINED "CPY* instructions use Option A";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYPostSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYPostSizeChoice</h3>
      <p class="pseudocode">// Returns the size of the copy that is performed by the CPYE* instructions for this
// implementation given the parameters of the destination, source and size of the copy.
// Postsize is encoded as -1*size for an option A implementation if cpysize is negative.
bits(64) <a id="impl-aarch64.CPYPostSizeChoice.3"/>CPYPostSizeChoice(bits(64) toaddress, bits(64) fromaddress, bits(64) cpysize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYPreSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYPreSizeChoice</h3>
      <p class="pseudocode">// Returns the size of the copy that is performed by the CPYP* instructions for this
// implementation given the parameters of the destination, source and size of the copy.
// Presize is encoded as -1*size for an option A implementation if cpysize is negative.
bits(64) <a id="impl-aarch64.CPYPreSizeChoice.3"/>CPYPreSizeChoice(bits(64) toaddress, bits(64) fromaddress, bits(64) cpysize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYSizeChoice</h3>
      <p class="pseudocode">// Returns the size of the block this performed for an iteration of the copy given the
// parameters of the destination, source and size of the copy.
integer <a id="impl-aarch64.CPYSizeChoice.3"/>CPYSizeChoice(bits(64) toaddress, bits(64) fromaddress, bits(64) cpysize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CheckMOPSEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CheckMOPSEnabled</h3>
      <p class="pseudocode">// CheckMOPSEnabled()
// ==================
// Check for EL0 and EL1 access to the CPY* and SET* instructions.

<a id="impl-aarch64.CheckMOPSEnabled.0"/>CheckMOPSEnabled()
    if (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0') &amp;&amp;
        (!<a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.MSCEn == '0')) then
        UNDEFINED;

    if (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; SCTLR_EL1.MSCEn == '0' &amp;&amp;
        (!<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() || HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0')) then
        UNDEFINED;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; SCTLR_EL2.MSCEn == '0' then
        UNDEFINED;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MOPSStage"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MOPSStage</h3>
      <p class="pseudocode">enumeration <a id="MOPSStage"/>MOPSStage { <a id="MOPSStage_Prologue"/>MOPSStage_Prologue, <a id="MOPSStage_Main"/>MOPSStage_Main, <a id="MOPSStage_Epilogue"/>MOPSStage_Epilogue };</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MaxBlockSizeCopiedBytes"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MaxBlockSizeCopiedBytes</h3>
      <p class="pseudocode">// MaxBlockSizeCopiedBytes()
// =========================
// Returns the maximum number of bytes that can used in a single block of the copy.

integer <a id="impl-aarch64.MaxBlockSizeCopiedBytes.0"/>MaxBlockSizeCopiedBytes()
    return integer IMPLEMENTATION_DEFINED "Maximum bytes used in a single block of a copy";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyDirectionChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyDirectionChoice</h3>
      <p class="pseudocode">// Returns true if in the non-overlapping case of a memcpy of size cpysize bytes
// from the source address fromaddress to destination address toaddress is done
// in the forward direction on this implementation.
boolean <a id="impl-aarch64.MemCpyDirectionChoice.3"/>MemCpyDirectionChoice(bits(64) fromaddress, bits(64) toaddress, bits(64) cpysize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyParametersIllformedE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyParametersIllformedE</h3>
      <p class="pseudocode">// Returns TRUE if the inputs are not well formed (in terms of their size and/or alignment)
// for a CPYE* instruction for this implementation given the parameters of the destination,
// source and size of the copy.
boolean <a id="impl-aarch64.MemCpyParametersIllformedE.3"/>MemCpyParametersIllformedE(bits(64) toaddress, bits(64) fromaddress,
                                   bits(64) cpysize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyParametersIllformedM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyParametersIllformedM</h3>
      <p class="pseudocode">// Returns TRUE if the inputs are not well formed (in terms of their size and/or alignment)
// for a CPYM* instruction for this implementation given the parameters of the destination,
// source and size of the copy.
boolean <a id="impl-aarch64.MemCpyParametersIllformedM.3"/>MemCpyParametersIllformedM(bits(64) toaddress, bits(64) fromaddress,
                                   bits(64) cpysize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyZeroSizeCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyZeroSizeCheck</h3>
      <p class="pseudocode">// Returns TRUE if the implementation option is checked on a copy of size zero remaining.
boolean <a id="impl-aarch64.MemCpyZeroSizeCheck.0"/>MemCpyZeroSizeCheck();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetParametersIllformedE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetParametersIllformedE</h3>
      <p class="pseudocode">// Returns TRUE if the inputs are not well formed (in terms of their size and/or
// alignment) for a SETE* or SETGE* instruction for this implementation given the
// parameters of the destination and size of the set.
boolean <a id="impl-aarch64.MemSetParametersIllformedE.3"/>MemSetParametersIllformedE(bits(64) toaddress, bits(64) setsize,
                                   boolean IsSETGE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetParametersIllformedM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetParametersIllformedM</h3>
      <p class="pseudocode">// Returns TRUE if the inputs are not well formed (in terms of their size and/or
// alignment) for a SETM* or SETGM* instruction for this implementation given the
// parameters of the destination and size of the copy.
boolean <a id="impl-aarch64.MemSetParametersIllformedM.3"/>MemSetParametersIllformedM(bits(64) toaddress, bits(64) setsize,
                                   boolean IsSETGM);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetZeroSizeCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetZeroSizeCheck</h3>
      <p class="pseudocode">// Returns TRUE if the implementation option is checked on a copy of size zero remaining.
boolean <a id="impl-aarch64.MemSetZeroSizeCheck.0"/>MemSetZeroSizeCheck();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MismatchedCpySetTargetEL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MismatchedCpySetTargetEL</h3>
      <p class="pseudocode">// MismatchedCpySetTargetEL()
// ==========================
// Return the target exception level for an Exception_MemCpyMemSet.

bits(2) <a id="impl-aarch64.MismatchedCpySetTargetEL.0"/>MismatchedCpySetTargetEL()
    bits(2) target_el;

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    elsif (PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        <a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() &amp;&amp; HCRX_EL2.MCE2 == '1') then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    return target_el;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MismatchedMemCpyException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MismatchedMemCpyException</h3>
      <p class="pseudocode">// MismatchedMemCpyException()
// ===========================
// Generates an exception for a CPY* instruction if the version
// is inconsistent with the state of the call.

<a id="impl-aarch64.MismatchedMemCpyException.7"/>MismatchedMemCpyException(boolean option_a, integer destreg, integer srcreg, integer sizereg,
                          boolean wrong_option, boolean from_epilogue, bits(4) options)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    integer vect_offset = 0x0;
    bits(2) target_el = <a href="shared_pseudocode.html#impl-aarch64.MismatchedCpySetTargetEL.0" title="function: bits(2) MismatchedCpySetTargetEL()">MismatchedCpySetTargetEL</a>();

    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_MemCpyMemSet" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MemCpyMemSet</a>);
    exception.syndrome&lt;24&gt;    = '0';
    exception.syndrome&lt;23&gt;    = '0';
    exception.syndrome&lt;22:19&gt; = options;
    exception.syndrome&lt;18&gt;    = if from_epilogue then '1' else '0';
    exception.syndrome&lt;17&gt;    = if wrong_option then '1' else '0';
    exception.syndrome&lt;16&gt;    = if option_a then '1' else '0';
    // exception.syndrome&lt;15&gt; is RES0
    exception.syndrome&lt;14:10&gt; = destreg&lt;4:0&gt;;
    exception.syndrome&lt;9:5&gt;   = srcreg&lt;4:0&gt;;
    exception.syndrome&lt;4:0&gt;   = sizereg&lt;4:0&gt;;

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MismatchedMemSetException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MismatchedMemSetException</h3>
      <p class="pseudocode">// MismatchedMemSetException()
// ===========================
// Generates an exception for a SET* instruction if the version
// is inconsistent with the state of the call.

<a id="impl-aarch64.MismatchedMemSetException.8"/>MismatchedMemSetException(boolean option_a, integer destreg, integer datareg, integer sizereg,
                          boolean wrong_option, boolean from_epilogue, bits(2) options,
                          boolean is_SETG)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    integer vect_offset = 0x0;
    bits(2) target_el = <a href="shared_pseudocode.html#impl-aarch64.MismatchedCpySetTargetEL.0" title="function: bits(2) MismatchedCpySetTargetEL()">MismatchedCpySetTargetEL</a>();

    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_MemCpyMemSet" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MemCpyMemSet</a>);
    exception.syndrome&lt;24&gt;    = '1';
    exception.syndrome&lt;23&gt;    = if is_SETG then '1' else '0';
    // exception.syndrome&lt;22:21&gt; is RES0
    exception.syndrome&lt;20:19&gt; = options;
    exception.syndrome&lt;18&gt;    = if from_epilogue then '1' else '0';
    exception.syndrome&lt;17&gt;    = if wrong_option then '1' else '0';
    exception.syndrome&lt;16&gt;    = if option_a then '1' else '0';
    // exception.syndrome&lt;15&gt; is RES0
    exception.syndrome&lt;14:10&gt; = destreg&lt;4:0&gt;;
    exception.syndrome&lt;9:5&gt;   = datareg&lt;4:0&gt;;
    exception.syndrome&lt;4:0&gt;   = sizereg&lt;4:0&gt;;

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETGOptionA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETGOptionA</h3>
      <p class="pseudocode">// SETGOptionA()
// =============
// Returns TRUE if the implementation uses Option A for the
// SETG* instructions, and FALSE otherwise.

boolean <a id="impl-aarch64.SETGOptionA.0"/>SETGOptionA()
    return boolean IMPLEMENTATION_DEFINED "SETG* instructions use Option A";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETOptionA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETOptionA</h3>
      <p class="pseudocode">// SETOptionA()
// ============
// Returns TRUE if the implementation uses Option A for the
// SET* instructions, and FALSE otherwise.

boolean <a id="impl-aarch64.SETOptionA.0"/>SETOptionA()
    return boolean IMPLEMENTATION_DEFINED "SET* instructions use Option A";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETPostSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETPostSizeChoice</h3>
      <p class="pseudocode">// Returns the size of the set that is performed by the SETE* or SETGE* instructions
// for this implementation, given the parameters of the destination and size of the set.
// Postsize is encoded as -1*size for an option A implementation if setsize is negative.
bits(64) <a id="impl-aarch64.SETPostSizeChoice.3"/>SETPostSizeChoice(bits(64) toaddress, bits(64) setsize, boolean IsSETGE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETPreSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETPreSizeChoice</h3>
      <p class="pseudocode">// Returns the size of the set that is performed by the SETP* or SETGP* instructions
// for this implementation, given the parameters of the destination and size of the set.
// Presize is encoded as -1*size for an option A implementation if setsize is negative.
bits(64) <a id="impl-aarch64.SETPreSizeChoice.3"/>SETPreSizeChoice(bits(64) toaddress, bits(64) setsize, boolean IsSETGP);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETSizeChoice</h3>
      <p class="pseudocode">// Returns the size of the block thisperformed for an iteration of the set given
// the parameters of the destination and size of the set. The size of the block
// is an integer multiple of AlignSize.
integer <a id="impl-aarch64.SETSizeChoice.3"/>SETSizeChoice(bits(64) toaddress, bits(64) setsize, integer AlignSize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpac.AddPAC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpac/AddPAC</h3>
      <p class="pseudocode">// AddPAC()
// ========
// Calculates the pointer authentication code for a 64-bit quantity and then
// inserts that into pointer authentication code field of that 64-bit quantity.

bits(64) <a id="impl-aarch64.AddPAC.4"/>AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)
    bits(64) PAC;
    bits(64) result;
    bits(64) ext_ptr;
    bits(64) extfield;
    bit selbit;
    boolean isgeneric = FALSE;
    boolean tbi = <a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(ptr, !data, PSTATE.EL) == '1';
    boolean mtx = <a href="shared_pseudocode.html#impl-shared.EffectiveMTX.3" title="function: bit EffectiveMTX(bits(64) address, boolean is_instr, bits(2) el)">EffectiveMTX</a>(ptr, !data, PSTATE.EL) == '1';
    integer top_bit = if tbi then 55 else 63;

    // If tagged pointers are in use for a regime with two TTBRs, use bit&lt;55&gt; of
    // the pointer to select between upper and lower ranges, and preserve this.
    // This handles the awkward case where there is apparently no correct choice between
    // the upper and lower address range - ie an addr of 1xxxxxxx0... with TBI0=0 and TBI1=1
    // and 0xxxxxxx1 with TBI1=0 and TBI0=1:
    if <a href="shared_pseudocode.html#impl-aarch64.PtrHasUpperAndLowerAddRanges.0" title="function: boolean PtrHasUpperAndLowerAddRanges()">PtrHasUpperAndLowerAddRanges</a>() then
        assert <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};
        if <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
            // EL1 translation regime registers
            if data then
                if TCR_EL1.TBI1 == '1' || TCR_EL1.TBI0 == '1' then
                    selbit = ptr&lt;55&gt;;
                else
                    selbit = ptr&lt;63&gt;;
            else
                if ((TCR_EL1.TBI1 == '1' &amp;&amp; TCR_EL1.TBID1 == '0') ||
                    (TCR_EL1.TBI0 == '1' &amp;&amp; TCR_EL1.TBID0 == '0')) then
                    selbit = ptr&lt;55&gt;;
                else
                    selbit = ptr&lt;63&gt;;
        else
            // EL2 translation regime registers
            if data then
                if TCR_EL2.TBI1 == '1' || TCR_EL2.TBI0 == '1' then
                    selbit = ptr&lt;55&gt;;
                else
                    selbit = ptr&lt;63&gt;;
            else
                if ((TCR_EL2.TBI1 == '1' &amp;&amp; TCR_EL2.TBID1 == '0') ||
                    (TCR_EL2.TBI0 == '1' &amp;&amp; TCR_EL2.TBID0 == '0')) then
                    selbit = ptr&lt;55&gt;;
                else
                    selbit = ptr&lt;63&gt;;
    else selbit = if tbi then ptr&lt;55&gt; else ptr&lt;63&gt;;

    if <a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC2.0" title="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.ConstPACField.0" title="function: boolean ConstPACField()">ConstPACField</a>() then selbit = ptr&lt;55&gt;;
    integer bottom_PAC_bit = <a href="shared_pseudocode.html#impl-aarch64.CalculateBottomPACBit.1" title="function: integer CalculateBottomPACBit(bit top_bit)">CalculateBottomPACBit</a>(selbit);

    // If the VA is 56 or 55 bits and Top Byte is Ignored,
    // there are no unused bits left to insert the PAC
    if tbi &amp;&amp; bottom_PAC_bit &gt;= 55 then
        return ptr;

    extfield = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(selbit, 64);

    // Compute the pointer authentication code for a ptr with good extension bits
    if tbi then
        ext_ptr = (ptr&lt;63:56&gt; :
                   extfield&lt;(56-bottom_PAC_bit)-1:0&gt; : ptr&lt;bottom_PAC_bit-1:0&gt;);
    elsif mtx then
        ext_ptr = (extfield&lt;63:60&gt; : ptr&lt;59:56&gt; :
                   extfield&lt;(56-bottom_PAC_bit)-1:0&gt; : ptr&lt;bottom_PAC_bit-1:0&gt;);
    else
        ext_ptr =  extfield&lt;(64-bottom_PAC_bit)-1:0&gt; : ptr&lt;bottom_PAC_bit-1:0&gt;;

    PAC = <a href="shared_pseudocode.html#impl-aarch64.ComputePAC.5" title="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1, boolean isgeneric)">ComputePAC</a>(ext_ptr, modifier, K&lt;127:64&gt;, K&lt;63:0&gt;, isgeneric);

    // Check if the ptr has good extension bits and corrupt the pointer authentication code if not
    bits(64) unusedbits_mask = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    unusedbits_mask&lt;54:bottom_PAC_bit&gt; = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>((54-bottom_PAC_bit)+1);
    if tbi then
        unusedbits_mask&lt;63:56&gt; = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(8);
    elsif mtx then
        unusedbits_mask&lt;63:60&gt; = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(4);
    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ptr AND unusedbits_mask) &amp;&amp; ((ptr AND unusedbits_mask) != unusedbits_mask) then
        if <a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC.0" title="function: boolean HaveEnhancedPAC()">HaveEnhancedPAC</a>() then
            PAC = 0x0000000000000000&lt;63:0&gt;;
        elsif !<a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC2.0" title="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() then
            PAC&lt;top_bit-1&gt; = NOT(PAC&lt;top_bit-1&gt;);

    // Preserve the determination between upper and lower address at bit&lt;55&gt; and insert PAC into
    // bits that are not used for the address or the tag(s).
    if !<a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC2.0" title="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() then
        if tbi then
            result = ptr&lt;63:56&gt;:selbit:PAC&lt;54:bottom_PAC_bit&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;
        else
            result = PAC&lt;63:56&gt;:selbit:PAC&lt;54:bottom_PAC_bit&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;
            // A compliant implementation of FEAT_MTE4 also implements FEAT_PAuth2
            assert !mtx;
    else
        if tbi then
            result = (ptr&lt;63:56&gt;                               : selbit :
                      (ptr&lt;54:bottom_PAC_bit&gt; EOR PAC&lt;54:bottom_PAC_bit&gt;) :
                      ptr&lt;bottom_PAC_bit-1:0&gt;);
        elsif mtx then
            result = ((ptr&lt;63:60&gt; EOR PAC&lt;63:60&gt;) : ptr&lt;59:56&gt; : selbit :
                      (ptr&lt;54:bottom_PAC_bit&gt; EOR PAC&lt;54:bottom_PAC_bit&gt;) :
                      ptr&lt;bottom_PAC_bit-1:0&gt;);
        else
            result = ((ptr&lt;63:56&gt; EOR PAC&lt;63:56&gt;)              : selbit :
                      (ptr&lt;54:bottom_PAC_bit&gt; EOR PAC&lt;54:bottom_PAC_bit&gt;) :
                      ptr&lt;bottom_PAC_bit-1:0&gt;);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacda.AddPACDA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacda/AddPACDA</h3>
      <p class="pseudocode">// AddPACDA()
// ==========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of x, y and the
// APDAKey_EL1.

bits(64) <a id="impl-aarch64.AddPACDA.2"/>AddPACDA(bits(64) x, bits(64) y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDAKey_EL1;

    APDAKey_EL1 = APDAKeyHi_EL1&lt;63:0&gt; : APDAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDA else SCTLR_EL2.EnDA;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnDA;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then
        return x;
    elsif TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>() then
        UNDEFINED;
    elsif TrapEL2 then
        <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
            UNDEFINED;
        else
            <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else
        return <a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</a>(x, y, APDAKey_EL1, TRUE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacdb.AddPACDB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacdb/AddPACDB</h3>
      <p class="pseudocode">// AddPACDB()
// ==========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of x, y and the
// APDBKey_EL1.

bits(64) <a id="impl-aarch64.AddPACDB.2"/>AddPACDB(bits(64) x, bits(64) y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDBKey_EL1;

    APDBKey_EL1 = APDBKeyHi_EL1&lt;63:0&gt; : APDBKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDB else SCTLR_EL2.EnDB;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnDB;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then
        return x;
    elsif TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>() then
        UNDEFINED;
    elsif TrapEL2 then
        <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
            UNDEFINED;
        else
            <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else
        return <a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</a>(x, y, APDBKey_EL1, TRUE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacga.AddPACGA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacga/AddPACGA</h3>
      <p class="pseudocode">// AddPACGA()
// ==========
// Returns a 64-bit value where the lower 32 bits are 0, and the upper 32 bits contain
// a 32-bit pointer authentication code which is derived using a cryptographic
// algorithm as a combination of x, y and the APGAKey_EL1.

bits(64) <a id="impl-aarch64.AddPACGA.2"/>AddPACGA(bits(64) x, bits(64) y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(128) APGAKey_EL1;
    boolean isgeneric = TRUE;

    APGAKey_EL1 = APGAKeyHi_EL1&lt;63:0&gt; : APGAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>() then
        UNDEFINED;
    elsif TrapEL2 then
        <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
            UNDEFINED;
        else
            <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else
        return <a href="shared_pseudocode.html#impl-aarch64.ComputePAC.5" title="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1, boolean isgeneric)">ComputePAC</a>(x, y, APGAKey_EL1&lt;127:64&gt;, APGAKey_EL1&lt;63:0&gt;, isgeneric)&lt;63:32&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacia.AddPACIA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacia/AddPACIA</h3>
      <p class="pseudocode">// AddPACIA()
// ==========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of x, y, and the
// APIAKey_EL1.

bits(64) <a id="impl-aarch64.AddPACIA.2"/>AddPACIA(bits(64) x, bits(64) y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIAKey_EL1;

    APIAKey_EL1 = APIAKeyHi_EL1&lt;63:0&gt;:APIAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIA else SCTLR_EL2.EnIA;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnIA;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then
        return x;
    elsif TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>() then
        UNDEFINED;
    elsif TrapEL2 then
        <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
            UNDEFINED;
        else
            <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else
        return <a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</a>(x, y, APIAKey_EL1, FALSE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacib.AddPACIB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacib/AddPACIB</h3>
      <p class="pseudocode">// AddPACIB()
// ==========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of x, y and the
// APIBKey_EL1.

bits(64) <a id="impl-aarch64.AddPACIB.2"/>AddPACIB(bits(64) x, bits(64) y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIBKey_EL1;

    APIBKey_EL1 = APIBKeyHi_EL1&lt;63:0&gt; : APIBKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIB else SCTLR_EL2.EnIB;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnIB;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then
        return x;
    elsif TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>() then
        UNDEFINED;
    elsif TrapEL2 then
        <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
            UNDEFINED;
        else
            <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else
        return <a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</a>(x, y, APIBKey_EL1, FALSE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.auth.AArch64.PACFailException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/auth/AArch64.PACFailException</h3>
      <p class="pseudocode">// AArch64.PACFailException()
// ==========================
// Generates a PAC Fail Exception

<a id="AArch64.PACFailException.1"/>AArch64.PACFailException(bits(2) syndrome)
    route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_PACFail" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACFail</a>);
    exception.syndrome&lt;1:0&gt;   = syndrome;
    exception.syndrome&lt;24:2&gt;  = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(23);                // RES0

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>) then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.auth.Auth"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/auth/Auth</h3>
      <p class="pseudocode">// Auth()
// ======
// Restores the upper bits of the address to be all zeros or all ones (based on the
// value of bit[55]) and computes and checks the pointer authentication code. If the
// check passes, then the restored address is returned. If the check fails, the
// second-top and third-top bits of the extension bits in the pointer authentication code
// field are corrupted to ensure that accessing the address will give a translation fault.

bits(64) <a id="impl-aarch64.Auth.6"/>Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,
              boolean is_combined)
    bits(64) PAC;
    bits(64) result;
    bits(64) original_ptr;
    bits(2) error_code;
    bits(64) extfield;
    boolean isgeneric = FALSE;

    // Reconstruct the extension field used of adding the PAC to the pointer
    boolean tbi = <a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(ptr, !data, PSTATE.EL) == '1';
    boolean mtx = <a href="shared_pseudocode.html#impl-shared.EffectiveMTX.3" title="function: bit EffectiveMTX(bits(64) address, boolean is_instr, bits(2) el)">EffectiveMTX</a>(ptr, !data, PSTATE.EL) == '1';
    integer bottom_PAC_bit = <a href="shared_pseudocode.html#impl-aarch64.CalculateBottomPACBit.1" title="function: integer CalculateBottomPACBit(bit top_bit)">CalculateBottomPACBit</a>(ptr&lt;55&gt;);
    extfield = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(ptr&lt;55&gt;, 64);

    // If the VA is 56 or 55 bits and Top Byte is Ignored,
    // there are no unused bits left for the PAC
    if tbi &amp;&amp; bottom_PAC_bit &gt;= 55 then
        return ptr;

    if tbi then
        original_ptr = (ptr&lt;63:56&gt; :
                        extfield&lt;(56-bottom_PAC_bit)-1:0&gt; : ptr&lt;bottom_PAC_bit-1:0&gt;);
    elsif mtx then
        original_ptr = (extfield&lt;63:60&gt; : ptr&lt;59:56&gt; :
                        extfield&lt;(56-bottom_PAC_bit)-1:0&gt; : ptr&lt;bottom_PAC_bit-1:0&gt;);
    else
        original_ptr =  extfield&lt;(64-bottom_PAC_bit)-1:0&gt; : ptr&lt;bottom_PAC_bit-1:0&gt;;

    PAC = <a href="shared_pseudocode.html#impl-aarch64.ComputePAC.5" title="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1, boolean isgeneric)">ComputePAC</a>(original_ptr, modifier, K&lt;127:64&gt;, K&lt;63:0&gt;, isgeneric);
    // Check pointer authentication code
    if tbi then
        if !<a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC2.0" title="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() then
            if PAC&lt;54:bottom_PAC_bit&gt; == ptr&lt;54:bottom_PAC_bit&gt; then
                result = original_ptr;
            else
                error_code = key_number:NOT(key_number);
                result = original_ptr&lt;63:55&gt;:error_code:original_ptr&lt;52:0&gt;;
        else
            result = ptr;
            result&lt;54:bottom_PAC_bit&gt; = result&lt;54:bottom_PAC_bit&gt; EOR PAC&lt;54:bottom_PAC_bit&gt;;
            if <a href="shared_pseudocode.html#impl-aarch64.HaveFPACCombined.0" title="function: boolean HaveFPACCombined()">HaveFPACCombined</a>() || (<a href="shared_pseudocode.html#impl-aarch64.HaveFPAC.0" title="function: boolean HaveFPAC()">HaveFPAC</a>() &amp;&amp; !is_combined) then
                if result&lt;54:bottom_PAC_bit&gt; != <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(result&lt;55&gt;, (55-bottom_PAC_bit)) then
                    error_code = (if data then '1' else '0'):key_number;
                    <a href="shared_pseudocode.html#AArch64.PACFailException.1" title="function: AArch64.PACFailException(bits(2) syndrome)">AArch64.PACFailException</a>(error_code);
    elsif mtx then
        assert <a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC2.0" title="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>();
        result = ptr;
        result&lt;54:bottom_PAC_bit&gt; = result&lt;54:bottom_PAC_bit&gt; EOR PAC&lt;54:bottom_PAC_bit&gt;;
        result&lt;63:60&gt; = result&lt;63:60&gt; EOR PAC&lt;63:60&gt;;
        if <a href="shared_pseudocode.html#impl-aarch64.HaveFPACCombined.0" title="function: boolean HaveFPACCombined()">HaveFPACCombined</a>() || (<a href="shared_pseudocode.html#impl-aarch64.HaveFPAC.0" title="function: boolean HaveFPAC()">HaveFPAC</a>() &amp;&amp; !is_combined) then
            if ((result&lt;54:bottom_PAC_bit&gt; != <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(result&lt;55&gt;, (55-bottom_PAC_bit))) ||
                (result&lt;63:60&gt; != <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(result&lt;55&gt;, 4))) then
                error_code = (if data then '1' else '0'):key_number;
                <a href="shared_pseudocode.html#AArch64.PACFailException.1" title="function: AArch64.PACFailException(bits(2) syndrome)">AArch64.PACFailException</a>(error_code);
    else
        if !<a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC2.0" title="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() then
            if PAC&lt;54:bottom_PAC_bit&gt; == ptr&lt;54:bottom_PAC_bit&gt; &amp;&amp; PAC&lt;63:56&gt; == ptr&lt;63:56&gt; then
                result = original_ptr;
            else
                error_code = key_number:NOT(key_number);
                result = original_ptr&lt;63&gt;:error_code:original_ptr&lt;60:0&gt;;
        else
            result = ptr;
            result&lt;54:bottom_PAC_bit&gt; = result&lt;54:bottom_PAC_bit&gt; EOR PAC&lt;54:bottom_PAC_bit&gt;;
            result&lt;63:56&gt; = result&lt;63:56&gt; EOR PAC&lt;63:56&gt;;
            if <a href="shared_pseudocode.html#impl-aarch64.HaveFPACCombined.0" title="function: boolean HaveFPACCombined()">HaveFPACCombined</a>() || (<a href="shared_pseudocode.html#impl-aarch64.HaveFPAC.0" title="function: boolean HaveFPAC()">HaveFPAC</a>() &amp;&amp; !is_combined) then
                if result&lt;63:bottom_PAC_bit&gt; != <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(result&lt;55&gt;, (64-bottom_PAC_bit)) then
                    error_code = (if data then '1' else '0'):key_number;
                    <a href="shared_pseudocode.html#AArch64.PACFailException.1" title="function: AArch64.PACFailException(bits(2) syndrome)">AArch64.PACFailException</a>(error_code);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authda.AuthDA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authda/AuthDA</h3>
      <p class="pseudocode">// AuthDA()
// ========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of x, using the same
// algorithm and key as AddPACDA().

bits(64) <a id="impl-aarch64.AuthDA.3"/>AuthDA(bits(64) x, bits(64) y, boolean is_combined)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDAKey_EL1;

    APDAKey_EL1 = APDAKeyHi_EL1&lt;63:0&gt; : APDAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDA else SCTLR_EL2.EnDA;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnDA;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then
        return x;
    elsif TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>() then
        UNDEFINED;
    elsif TrapEL2 then
        <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
            UNDEFINED;
        else
            <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else
        return <a href="shared_pseudocode.html#impl-aarch64.Auth.6" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</a>(x, y, APDAKey_EL1, TRUE, '0', is_combined);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authdb.AuthDB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authdb/AuthDB</h3>
      <p class="pseudocode">// AuthDB()
// ========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a
// pointer authentication code in the pointer authentication code field bits of x, using
// the same algorithm and key as AddPACDB().

bits(64) <a id="impl-aarch64.AuthDB.3"/>AuthDB(bits(64) x, bits(64) y, boolean is_combined)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDBKey_EL1;

    APDBKey_EL1 = APDBKeyHi_EL1&lt;63:0&gt; : APDBKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDB else SCTLR_EL2.EnDB;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnDB;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then
        return x;
    elsif TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>() then
        UNDEFINED;
    elsif TrapEL2 then
        <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
            UNDEFINED;
        else
            <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else
        return <a href="shared_pseudocode.html#impl-aarch64.Auth.6" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</a>(x, y, APDBKey_EL1, TRUE, '1', is_combined);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authia.AuthIA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authia/AuthIA</h3>
      <p class="pseudocode">// AuthIA()
// ========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of x, using the same
// algorithm and key as AddPACIA().

bits(64) <a id="impl-aarch64.AuthIA.3"/>AuthIA(bits(64) x, bits(64) y, boolean is_combined)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIAKey_EL1;

    APIAKey_EL1 = APIAKeyHi_EL1&lt;63:0&gt; : APIAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIA else SCTLR_EL2.EnIA;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnIA;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then
        return x;
    elsif TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>() then
        UNDEFINED;
    elsif TrapEL2 then
        <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
            UNDEFINED;
        else
            <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else
        return <a href="shared_pseudocode.html#impl-aarch64.Auth.6" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</a>(x, y, APIAKey_EL1, FALSE, '0', is_combined);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authib.AuthIB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authib/AuthIB</h3>
      <p class="pseudocode">// AuthIB()
// ========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of x, using the same
// algorithm and key as AddPACIB().

bits(64) <a id="impl-aarch64.AuthIB.3"/>AuthIB(bits(64) x, bits(64) y, boolean is_combined)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIBKey_EL1;

    APIBKey_EL1 = APIBKeyHi_EL1&lt;63:0&gt; : APIBKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIB else SCTLR_EL2.EnIB;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnIB;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then
        return x;
    elsif TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>() then
        UNDEFINED;
    elsif TrapEL2 then
        <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
            UNDEFINED;
        else
            <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else
        return <a href="shared_pseudocode.html#impl-aarch64.Auth.6" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</a>(x, y, APIBKey_EL1, FALSE, '1', is_combined);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.calcbottompacbit.AArch64.PACEffectiveTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/calcbottompacbit/AArch64.PACEffectiveTxSZ</h3>
      <p class="pseudocode">// AArch64.PACEffectiveTxSZ()
// ==========================
// Compute the effective value for TxSZ used to determine the placement of the PAC field

bits(6) AArch64.PACEffectiveTxSZ(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, S1TTWParams walkparams)
    constant integer s1maxtxsz = <a href="shared_pseudocode.html#AArch64.MaxTxSZ.1" title="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);
    constant integer s1mintxsz = <a href="shared_pseudocode.html#AArch64.S1MinTxSZ.4" title="function: integer AArch64.S1MinTxSZ(Regime regime, bit d128, bit ds, TGx tgx)">AArch64.S1MinTxSZ</a>(regime, walkparams.d128,
                                                   walkparams.ds, walkparams.tgx);

    if AArch64.S1TxSZFaults(regime, walkparams) then
        if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESTnSZ</a>) == <a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a> then
            if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; s1mintxsz then
                return s1mintxsz&lt;5:0&gt;;
            if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; s1maxtxsz then
                return s1maxtxsz&lt;5:0&gt;;
    elsif <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; s1mintxsz then
        return s1mintxsz&lt;5:0&gt;;
    elsif <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; s1maxtxsz then
        return s1maxtxsz&lt;5:0&gt;;

    return walkparams.txsz;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.calcbottompacbit.CalculateBottomPACBit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/calcbottompacbit/CalculateBottomPACBit</h3>
      <p class="pseudocode">// CalculateBottomPACBit()
// =======================

integer <a id="impl-aarch64.CalculateBottomPACBit.1"/>CalculateBottomPACBit(bit top_bit)
    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime;
    S1TTWParams walkparams;
    integer bottom_PAC_bit;

    regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.1" title="function: Regime TranslationRegime(bits(2) el)">TranslationRegime</a>(PSTATE.EL);
    ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    walkparams = AArch64.GetS1TTWParams(regime, ss, <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(top_bit, 64));
    bottom_PAC_bit = 64 - <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(AArch64.PACEffectiveTxSZ(regime, walkparams));

    return bottom_PAC_bit;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.ComputePAC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/ComputePAC</h3>
      <p class="pseudocode">// ComputePAC()
// ============

bits(64) <a id="impl-aarch64.ComputePAC.5"/>ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1, boolean isgeneric)
    if <a href="shared_pseudocode.html#impl-aarch64.UsePACIMP.1" title="function: boolean UsePACIMP(boolean isgeneric)">UsePACIMP</a>(isgeneric) then
        return <a href="shared_pseudocode.html#impl-aarch64.ComputePACIMPDEF.4" title="function: bits(64) ComputePACIMPDEF(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)">ComputePACIMPDEF</a>(data, modifier, key0, key1);
    if <a href="shared_pseudocode.html#impl-aarch64.UsePACQARMA3.1" title="function: boolean UsePACQARMA3(boolean isgeneric)">UsePACQARMA3</a>(isgeneric) then
        boolean isqarma3 = TRUE;
        return <a href="shared_pseudocode.html#impl-aarch64.ComputePACQARMA.5" title="function: bits(64) ComputePACQARMA(bits(64) data, bits(64) modifier, bits(64) key0,&#13; bits(64) key1, boolean isqarma3)">ComputePACQARMA</a>(data, modifier, key0, key1, isqarma3);
    if <a href="shared_pseudocode.html#impl-aarch64.UsePACQARMA5.1" title="function: boolean UsePACQARMA5(boolean isgeneric)">UsePACQARMA5</a>(isgeneric) then
        boolean isqarma3 = FALSE;
        return <a href="shared_pseudocode.html#impl-aarch64.ComputePACQARMA.5" title="function: bits(64) ComputePACQARMA(bits(64) data, bits(64) modifier, bits(64) key0,&#13; bits(64) key1, boolean isqarma3)">ComputePACQARMA</a>(data, modifier, key0, key1, isqarma3);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.ComputePACIMPDEF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/ComputePACIMPDEF</h3>
      <p class="pseudocode">// Compute IMPLEMENTATION DEFINED cryptographic algorithm to be used for PAC calculation.
bits(64) <a id="impl-aarch64.ComputePACIMPDEF.4"/>ComputePACIMPDEF(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.ComputePACQARMA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/ComputePACQARMA</h3>
      <p class="pseudocode">// ComputePACQARMA()
// =================
// Compute QARMA3 or QARMA5 cryptographic algorithm for PAC calculation

bits(64) <a id="impl-aarch64.ComputePACQARMA.5"/>ComputePACQARMA(bits(64) data, bits(64) modifier, bits(64) key0,
                         bits(64) key1, boolean isqarma3)
    bits(64)  workingval;
    bits(64)  runningmod;
    bits(64)  roundkey;
    bits(64)  modk0;
    constant bits(64) Alpha = 0xC0AC29B7C97C50DD&lt;63:0&gt;;

    integer iterations;
    RC[0] = 0x0000000000000000&lt;63:0&gt;;
    RC[1] = 0x13198A2E03707344&lt;63:0&gt;;
    RC[2] = 0xA4093822299F31D0&lt;63:0&gt;;

    if isqarma3 then
        iterations = 2;
    else // QARMA5
        iterations = 4;
        RC[3] = 0x082EFA98EC4E6C89&lt;63:0&gt;;
        RC[4] = 0x452821E638D01377&lt;63:0&gt;;

    modk0 = key0&lt;0&gt;:key0&lt;63:2&gt;:(key0&lt;63&gt; EOR key0&lt;1&gt;);
    runningmod = modifier;
    workingval = data EOR key0;

    for i = 0 to iterations
        roundkey = key1 EOR runningmod;
        workingval  = workingval EOR roundkey;
        workingval = workingval EOR RC[i];
        if i &gt; 0 then
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACCellShuffle.1" title="function: bits(64) PACCellShuffle(bits(64) indata)">PACCellShuffle</a>(workingval);
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
        if isqarma3 then
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACSub1.1" title="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</a>(workingval);
        else
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACSub.1" title="function: bits(64) PACSub(bits(64) Tinput)">PACSub</a>(workingval);
        runningmod = <a href="shared_pseudocode.html#impl-aarch64.TweakShuffle.1" title="function: bits(64) TweakShuffle(bits(64) indata)">TweakShuffle</a>(runningmod&lt;63:0&gt;);
    roundkey = modk0 EOR runningmod;
    workingval = workingval EOR roundkey;
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACCellShuffle.1" title="function: bits(64) PACCellShuffle(bits(64) indata)">PACCellShuffle</a>(workingval);
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
    if isqarma3 then
        workingval = <a href="shared_pseudocode.html#impl-aarch64.PACSub1.1" title="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</a>(workingval);
    else
        workingval = <a href="shared_pseudocode.html#impl-aarch64.PACSub.1" title="function: bits(64) PACSub(bits(64) Tinput)">PACSub</a>(workingval);
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACCellShuffle.1" title="function: bits(64) PACCellShuffle(bits(64) indata)">PACCellShuffle</a>(workingval);
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
    workingval = key1 EOR workingval;
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACCellInvShuffle.1" title="function: bits(64) PACCellInvShuffle(bits(64) indata)">PACCellInvShuffle</a>(workingval);
    if isqarma3 then
        workingval = <a href="shared_pseudocode.html#impl-aarch64.PACSub1.1" title="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</a>(workingval);
    else
        workingval = <a href="shared_pseudocode.html#impl-aarch64.PACInvSub.1" title="function: bits(64) PACInvSub(bits(64) Tinput)">PACInvSub</a>(workingval);
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACCellInvShuffle.1" title="function: bits(64) PACCellInvShuffle(bits(64) indata)">PACCellInvShuffle</a>(workingval);
    workingval = workingval EOR key0;
    workingval = workingval EOR runningmod;
    for i = 0 to iterations
        if isqarma3 then
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACSub1.1" title="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</a>(workingval);
        else
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACInvSub.1" title="function: bits(64) PACInvSub(bits(64) Tinput)">PACInvSub</a>(workingval);
        if i &lt; iterations then
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACCellInvShuffle.1" title="function: bits(64) PACCellInvShuffle(bits(64) indata)">PACCellInvShuffle</a>(workingval);
        runningmod = <a href="shared_pseudocode.html#impl-aarch64.TweakInvShuffle.1" title="function: bits(64) TweakInvShuffle(bits(64) indata)">TweakInvShuffle</a>(runningmod&lt;63:0&gt;);
        roundkey = key1 EOR runningmod;
        workingval = workingval EOR RC[iterations-i];
        workingval = workingval EOR roundkey;
        workingval = workingval EOR Alpha;
    workingval = workingval EOR modk0;

    return workingval;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACCellInvShuffle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACCellInvShuffle</h3>
      <p class="pseudocode">// PACCellInvShuffle()
// ===================

bits(64) <a id="impl-aarch64.PACCellInvShuffle.1"/>PACCellInvShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0&gt; = indata&lt;15:12&gt;;
    outdata&lt;7:4&gt; = indata&lt;27:24&gt;;
    outdata&lt;11:8&gt; = indata&lt;51:48&gt;;
    outdata&lt;15:12&gt; = indata&lt;39:36&gt;;
    outdata&lt;19:16&gt; = indata&lt;59:56&gt;;
    outdata&lt;23:20&gt; = indata&lt;47:44&gt;;
    outdata&lt;27:24&gt; = indata&lt;7:4&gt;;
    outdata&lt;31:28&gt; = indata&lt;19:16&gt;;
    outdata&lt;35:32&gt; = indata&lt;35:32&gt;;
    outdata&lt;39:36&gt; = indata&lt;55:52&gt;;
    outdata&lt;43:40&gt; = indata&lt;31:28&gt;;
    outdata&lt;47:44&gt; = indata&lt;11:8&gt;;
    outdata&lt;51:48&gt; = indata&lt;23:20&gt;;
    outdata&lt;55:52&gt; = indata&lt;3:0&gt;;
    outdata&lt;59:56&gt; = indata&lt;43:40&gt;;
    outdata&lt;63:60&gt; = indata&lt;63:60&gt;;
    return outdata;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACCellShuffle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACCellShuffle</h3>
      <p class="pseudocode">// PACCellShuffle()
// ================

bits(64) <a id="impl-aarch64.PACCellShuffle.1"/>PACCellShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0&gt; = indata&lt;55:52&gt;;
    outdata&lt;7:4&gt; = indata&lt;27:24&gt;;
    outdata&lt;11:8&gt; = indata&lt;47:44&gt;;
    outdata&lt;15:12&gt; = indata&lt;3:0&gt;;
    outdata&lt;19:16&gt; = indata&lt;31:28&gt;;
    outdata&lt;23:20&gt; = indata&lt;51:48&gt;;
    outdata&lt;27:24&gt; = indata&lt;7:4&gt;;
    outdata&lt;31:28&gt; = indata&lt;43:40&gt;;
    outdata&lt;35:32&gt; = indata&lt;35:32&gt;;
    outdata&lt;39:36&gt; = indata&lt;15:12&gt;;
    outdata&lt;43:40&gt; = indata&lt;59:56&gt;;
    outdata&lt;47:44&gt; = indata&lt;23:20&gt;;
    outdata&lt;51:48&gt; = indata&lt;11:8&gt;;
    outdata&lt;55:52&gt; = indata&lt;39:36&gt;;
    outdata&lt;59:56&gt; = indata&lt;19:16&gt;;
    outdata&lt;63:60&gt; = indata&lt;63:60&gt;;
    return outdata;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACInvSub"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACInvSub</h3>
      <p class="pseudocode">// PACInvSub()
// ===========

bits(64) <a id="impl-aarch64.PACInvSub.1"/>PACInvSub(bits(64) Tinput)
    // This is a 4-bit substitution from the PRINCE-family cipher
    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i&gt; of
            when '0000'  Toutput&lt;4*i+3:4*i&gt; = '0101';
            when '0001'  Toutput&lt;4*i+3:4*i&gt; = '1110';
            when '0010'  Toutput&lt;4*i+3:4*i&gt; = '1101';
            when '0011'  Toutput&lt;4*i+3:4*i&gt; = '1000';
            when '0100'  Toutput&lt;4*i+3:4*i&gt; = '1010';
            when '0101'  Toutput&lt;4*i+3:4*i&gt; = '1011';
            when '0110'  Toutput&lt;4*i+3:4*i&gt; = '0001';
            when '0111'  Toutput&lt;4*i+3:4*i&gt; = '1001';
            when '1000'  Toutput&lt;4*i+3:4*i&gt; = '0010';
            when '1001'  Toutput&lt;4*i+3:4*i&gt; = '0110';
            when '1010'  Toutput&lt;4*i+3:4*i&gt; = '1111';
            when '1011'  Toutput&lt;4*i+3:4*i&gt; = '0000';
            when '1100'  Toutput&lt;4*i+3:4*i&gt; = '0100';
            when '1101'  Toutput&lt;4*i+3:4*i&gt; = '1100';
            when '1110'  Toutput&lt;4*i+3:4*i&gt; = '0111';
            when '1111'  Toutput&lt;4*i+3:4*i&gt; = '0011';
    return Toutput;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACMult"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACMult</h3>
      <p class="pseudocode">// PACMult()
// =========

bits(64) <a id="impl-aarch64.PACMult.1"/>PACMult(bits(64) Sinput)
    bits(4)  t0;
    bits(4)  t1;
    bits(4)  t2;
    bits(4)  t3;
    bits(64) Soutput;

    for i = 0 to 3
        t0&lt;3:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+8)+3:4*(i+8)&gt;, 1) EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+4)+3:4*(i+4)&gt;, 2);
        t0&lt;3:0&gt; = t0&lt;3:0&gt; EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i)+3:4*(i)&gt;, 1);
        t1&lt;3:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+12)+3:4*(i+12)&gt;, 1) EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+4)+3:4*(i+4)&gt;, 1);
        t1&lt;3:0&gt; = t1&lt;3:0&gt; EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i)+3:4*(i)&gt;, 2);
        t2&lt;3:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+12)+3:4*(i+12)&gt;, 2) EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+8)+3:4*(i+8)&gt;, 1);
        t2&lt;3:0&gt; = t2&lt;3:0&gt; EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i)+3:4*(i)&gt;, 1);
        t3&lt;3:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+12)+3:4*(i+12)&gt;, 1) EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+8)+3:4*(i+8)&gt;, 2);
        t3&lt;3:0&gt; = t3&lt;3:0&gt; EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+4)+3:4*(i+4)&gt;, 1);
        Soutput&lt;4*i+3:4*i&gt; = t3&lt;3:0&gt;;
        Soutput&lt;4*(i+4)+3:4*(i+4)&gt; = t2&lt;3:0&gt;;
        Soutput&lt;4*(i+8)+3:4*(i+8)&gt; = t1&lt;3:0&gt;;
        Soutput&lt;4*(i+12)+3:4*(i+12)&gt; = t0&lt;3:0&gt;;
    return Soutput;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACSub"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACSub</h3>
      <p class="pseudocode">// PACSub()
// ========

bits(64) <a id="impl-aarch64.PACSub.1"/>PACSub(bits(64) Tinput)
    // This is a 4-bit substitution from the PRINCE-family cipher
    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i&gt; of
            when '0000'  Toutput&lt;4*i+3:4*i&gt; = '1011';
            when '0001'  Toutput&lt;4*i+3:4*i&gt; = '0110';
            when '0010'  Toutput&lt;4*i+3:4*i&gt; = '1000';
            when '0011'  Toutput&lt;4*i+3:4*i&gt; = '1111';
            when '0100'  Toutput&lt;4*i+3:4*i&gt; = '1100';
            when '0101'  Toutput&lt;4*i+3:4*i&gt; = '0000';
            when '0110'  Toutput&lt;4*i+3:4*i&gt; = '1001';
            when '0111'  Toutput&lt;4*i+3:4*i&gt; = '1110';
            when '1000'  Toutput&lt;4*i+3:4*i&gt; = '0011';
            when '1001'  Toutput&lt;4*i+3:4*i&gt; = '0111';
            when '1010'  Toutput&lt;4*i+3:4*i&gt; = '0100';
            when '1011'  Toutput&lt;4*i+3:4*i&gt; = '0101';
            when '1100'  Toutput&lt;4*i+3:4*i&gt; = '1101';
            when '1101'  Toutput&lt;4*i+3:4*i&gt; = '0010';
            when '1110'  Toutput&lt;4*i+3:4*i&gt; = '0001';
            when '1111'  Toutput&lt;4*i+3:4*i&gt; = '1010';
    return Toutput;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PacSub1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PacSub1</h3>
      <p class="pseudocode">// PacSub1()
// =========

bits(64) <a id="impl-aarch64.PACSub1.1"/>PACSub1(bits(64) Tinput)
    // This is a 4-bit substitution from Qarma sigma1
    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i&gt; of
            when '0000' Toutput&lt;4*i+3:4*i&gt; = '1010';
            when '0001' Toutput&lt;4*i+3:4*i&gt; = '1101';
            when '0010' Toutput&lt;4*i+3:4*i&gt; = '1110';
            when '0011' Toutput&lt;4*i+3:4*i&gt; = '0110';
            when '0100' Toutput&lt;4*i+3:4*i&gt; = '1111';
            when '0101' Toutput&lt;4*i+3:4*i&gt; = '0111';
            when '0110' Toutput&lt;4*i+3:4*i&gt; = '0011';
            when '0111' Toutput&lt;4*i+3:4*i&gt; = '0101';
            when '1000' Toutput&lt;4*i+3:4*i&gt; = '1001';
            when '1001' Toutput&lt;4*i+3:4*i&gt; = '1000';
            when '1010' Toutput&lt;4*i+3:4*i&gt; = '0000';
            when '1011' Toutput&lt;4*i+3:4*i&gt; = '1100';
            when '1100' Toutput&lt;4*i+3:4*i&gt; = '1011';
            when '1101' Toutput&lt;4*i+3:4*i&gt; = '0001';
            when '1110' Toutput&lt;4*i+3:4*i&gt; = '0010';
            when '1111' Toutput&lt;4*i+3:4*i&gt; = '0100';
    return Toutput;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.RC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/RC</h3>
      <p class="pseudocode">array bits(64) RC[0..4];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.RotCell"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/RotCell</h3>
      <p class="pseudocode">// RotCell()
// =========

bits(4) <a id="impl-aarch64.RotCell.2"/>RotCell(bits(4) incell, integer amount)
    bits(8) tmp;
    bits(4) outcell;

    // assert amount&gt;3 || amount&lt;1;
    tmp&lt;7:0&gt; = incell&lt;3:0&gt;:incell&lt;3:0&gt;;
    outcell = tmp&lt;7-amount:4-amount&gt;;
    return outcell;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.TweakCellInvRot"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/TweakCellInvRot</h3>
      <p class="pseudocode">// TweakCellInvRot()
// =================

bits(4) <a id="impl-aarch64.TweakCellInvRot.1"/>TweakCellInvRot(bits(4) incell)
    bits(4) outcell;
    outcell&lt;3&gt; = incell&lt;2&gt;;
    outcell&lt;2&gt; = incell&lt;1&gt;;
    outcell&lt;1&gt; = incell&lt;0&gt;;
    outcell&lt;0&gt; = incell&lt;0&gt; EOR incell&lt;3&gt;;
    return outcell;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.TweakCellRot"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/TweakCellRot</h3>
      <p class="pseudocode">// TweakCellRot()
// ==============

bits(4) <a id="impl-aarch64.TweakCellRot.1"/>TweakCellRot(bits(4) incell)
    bits(4) outcell;
    outcell&lt;3&gt; = incell&lt;0&gt; EOR incell&lt;1&gt;;
    outcell&lt;2&gt; = incell&lt;3&gt;;
    outcell&lt;1&gt; = incell&lt;2&gt;;
    outcell&lt;0&gt; = incell&lt;1&gt;;
    return outcell;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.TweakInvShuffle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/TweakInvShuffle</h3>
      <p class="pseudocode">// TweakInvShuffle()
// =================

bits(64) <a id="impl-aarch64.TweakInvShuffle.1"/>TweakInvShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;51:48&gt;);
    outdata&lt;7:4&gt; = indata&lt;55:52&gt;;
    outdata&lt;11:8&gt; = indata&lt;23:20&gt;;
    outdata&lt;15:12&gt; = indata&lt;27:24&gt;;
    outdata&lt;19:16&gt; = indata&lt;3:0&gt;;
    outdata&lt;23:20&gt; = indata&lt;7:4&gt;;
    outdata&lt;27:24&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;11:8&gt;);
    outdata&lt;31:28&gt; = indata&lt;15:12&gt;;
    outdata&lt;35:32&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;31:28&gt;);
    outdata&lt;39:36&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;63:60&gt;);
    outdata&lt;43:40&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;59:56&gt;);
    outdata&lt;47:44&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;19:16&gt;);
    outdata&lt;51:48&gt; = indata&lt;35:32&gt;;
    outdata&lt;55:52&gt; = indata&lt;39:36&gt;;
    outdata&lt;59:56&gt; = indata&lt;43:40&gt;;
    outdata&lt;63:60&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;47:44&gt;);
    return outdata;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.TweakShuffle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/TweakShuffle</h3>
      <p class="pseudocode">// TweakShuffle()
// ==============

bits(64) <a id="impl-aarch64.TweakShuffle.1"/>TweakShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0&gt; = indata&lt;19:16&gt;;
    outdata&lt;7:4&gt; = indata&lt;23:20&gt;;
    outdata&lt;11:8&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;27:24&gt;);
    outdata&lt;15:12&gt; = indata&lt;31:28&gt;;
    outdata&lt;19:16&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;47:44&gt;);
    outdata&lt;23:20&gt; = indata&lt;11:8&gt;;
    outdata&lt;27:24&gt; = indata&lt;15:12&gt;;
    outdata&lt;31:28&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;35:32&gt;);
    outdata&lt;35:32&gt; = indata&lt;51:48&gt;;
    outdata&lt;39:36&gt; = indata&lt;55:52&gt;;
    outdata&lt;43:40&gt; = indata&lt;59:56&gt;;
    outdata&lt;47:44&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;63:60&gt;);
    outdata&lt;51:48&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;3:0&gt;);
    outdata&lt;55:52&gt; = indata&lt;7:4&gt;;
    outdata&lt;59:56&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;43:40&gt;);
    outdata&lt;63:60&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;39:36&gt;);
    return outdata;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.UsePACIMP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/UsePACIMP</h3>
      <p class="pseudocode">// UsePACIMP()
// ===========
// Checks whether IMPLEMENTATION DEFINED cryptographic algorithm to be used for PAC
// calculation.

boolean <a id="impl-aarch64.UsePACIMP.1"/>UsePACIMP(boolean isgeneric)
    return if isgeneric then <a href="shared_pseudocode.html#impl-aarch64.HavePACIMPGeneric.0" title="function: boolean HavePACIMPGeneric()">HavePACIMPGeneric</a>() else <a href="shared_pseudocode.html#impl-aarch64.HavePACIMPAuth.0" title="function: boolean HavePACIMPAuth()">HavePACIMPAuth</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.UsePACQARMA3"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/UsePACQARMA3</h3>
      <p class="pseudocode">// UsePACQARMA3()
// ==============
// Checks whether QARMA3 cryptographic algorithm to be used for PAC calculation.

boolean <a id="impl-aarch64.UsePACQARMA3.1"/>UsePACQARMA3(boolean isgeneric)
    return if isgeneric then <a href="shared_pseudocode.html#impl-aarch64.HavePACQARMA3Generic.0" title="function: boolean HavePACQARMA3Generic()">HavePACQARMA3Generic</a>() else <a href="shared_pseudocode.html#impl-aarch64.HavePACQARMA3Auth.0" title="function: boolean HavePACQARMA3Auth()">HavePACQARMA3Auth</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.UsePACQARMA5"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/UsePACQARMA5</h3>
      <p class="pseudocode">// UsePACQARMA5()
// ==============
// Checks whether QARMA5 cryptographic algorithm to be used for PAC calculation.

boolean <a id="impl-aarch64.UsePACQARMA5.1"/>UsePACQARMA5(boolean isgeneric)
    return if isgeneric then <a href="shared_pseudocode.html#impl-aarch64.HavePACQARMA5Generic.0" title="function: boolean HavePACQARMA5Generic()">HavePACQARMA5Generic</a>() else <a href="shared_pseudocode.html#impl-aarch64.HavePACQARMA5Auth.0" title="function: boolean HavePACQARMA5Auth()">HavePACQARMA5Auth</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.ConstPACField"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/ConstPACField</h3>
      <p class="pseudocode">// ConstPACField()
// ===============
// Returns TRUE if bit&lt;55&gt; can be used to determine the size of the PAC field, FALSE otherwise.

boolean <a id="impl-aarch64.ConstPACField.0"/>ConstPACField()
    return IsFeatureImplemented(FEAT_CONSTPACFIELD);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HaveEnhancedPAC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HaveEnhancedPAC</h3>
      <p class="pseudocode">// HaveEnhancedPAC()
// =================
// Returns TRUE if support for EnhancedPAC is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveEnhancedPAC.0"/>HaveEnhancedPAC()
    return IsFeatureImplemented(FEAT_EPAC);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HaveEnhancedPAC2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HaveEnhancedPAC2</h3>
      <p class="pseudocode">// HaveEnhancedPAC2()
// ==================
// Returns TRUE if support for EnhancedPAC2 is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveEnhancedPAC2.0"/>HaveEnhancedPAC2()
    return IsFeatureImplemented(FEAT_PAuth2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HaveFPAC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HaveFPAC</h3>
      <p class="pseudocode">// HaveFPAC()
// ==========
// Returns TRUE if support for FPAC is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveFPAC.0"/>HaveFPAC()
    return IsFeatureImplemented(FEAT_FPAC);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HaveFPACCombined"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HaveFPACCombined</h3>
      <p class="pseudocode">// HaveFPACCombined()
// ==================
// Returns TRUE if support for FPACCombined is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveFPACCombined.0"/>HaveFPACCombined()
    return IsFeatureImplemented(FEAT_FPACCOMBINE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HavePACExt"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HavePACExt</h3>
      <p class="pseudocode">// HavePACExt()
// ============
// Returns TRUE if support for the PAC extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HavePACExt.0"/>HavePACExt()
    return IsFeatureImplemented(FEAT_PAuth);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HavePACIMPAuth"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HavePACIMPAuth</h3>
      <p class="pseudocode">// HavePACIMPAuth()
// ================
// Returns TRUE if support for PAC IMP Auth is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HavePACIMPAuth.0"/>HavePACIMPAuth()
    return IsFeatureImplemented(FEAT_PACIMP);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HavePACIMPGeneric"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HavePACIMPGeneric</h3>
      <p class="pseudocode">// HavePACIMPGeneric()
// ===================
// Returns TRUE if support for PAC IMP Generic is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HavePACIMPGeneric.0"/>HavePACIMPGeneric()
    return IsFeatureImplemented(FEAT_PACIMP);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HavePACQARMA3Auth"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HavePACQARMA3Auth</h3>
      <p class="pseudocode">// HavePACQARMA3Auth()
// ===================
// Returns TRUE if support for PAC QARMA3 Auth is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HavePACQARMA3Auth.0"/>HavePACQARMA3Auth()
    return IsFeatureImplemented(FEAT_PACQARMA3);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HavePACQARMA3Generic"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HavePACQARMA3Generic</h3>
      <p class="pseudocode">// HavePACQARMA3Generic()
// ======================
// Returns TRUE if support for PAC QARMA3 Generic is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HavePACQARMA3Generic.0"/>HavePACQARMA3Generic()
    return IsFeatureImplemented(FEAT_PACQARMA3);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HavePACQARMA5Auth"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HavePACQARMA5Auth</h3>
      <p class="pseudocode">// HavePACQARMA5Auth()
// ===================
// Returns TRUE if support for PAC QARMA5 Auth is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HavePACQARMA5Auth.0"/>HavePACQARMA5Auth()
    return IsFeatureImplemented(FEAT_PACQARMA5);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HavePACQARMA5Generic"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HavePACQARMA5Generic</h3>
      <p class="pseudocode">// HavePACQARMA5Generic()
// ======================
// Returns TRUE if support for PAC QARMA5 Generic is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HavePACQARMA5Generic.0"/>HavePACQARMA5Generic()
    return IsFeatureImplemented(FEAT_PACQARMA5);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.PtrHasUpperAndLowerAddRanges"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/PtrHasUpperAndLowerAddRanges</h3>
      <p class="pseudocode">// PtrHasUpperAndLowerAddRanges()
// ==============================
// Returns TRUE if the pointer has upper and lower address ranges, FALSE otherwise.

boolean <a id="impl-aarch64.PtrHasUpperAndLowerAddRanges.0"/>PtrHasUpperAndLowerAddRanges()
    regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.1" title="function: Regime TranslationRegime(bits(2) el)">TranslationRegime</a>(PSTATE.EL);
    return <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.strip.Strip"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/strip/Strip</h3>
      <p class="pseudocode">// Strip()
// =======
// Strip() returns a 64-bit value containing A, but replacing the pointer authentication
// code field bits with the extension of the address bits. This can apply to either
// instructions or data, where, as the use of tagged pointers is distinct, it might be
// handled differently.

bits(64) <a id="impl-aarch64.Strip.2"/>Strip(bits(64) A, boolean data)
    bits(64) original_ptr;
    bits(64) extfield;
    boolean tbi = <a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(A, !data, PSTATE.EL) == '1';
    boolean mtx = <a href="shared_pseudocode.html#impl-shared.EffectiveMTX.3" title="function: bit EffectiveMTX(bits(64) address, boolean is_instr, bits(2) el)">EffectiveMTX</a>(A, !data, PSTATE.EL) == '1';
    integer bottom_PAC_bit = <a href="shared_pseudocode.html#impl-aarch64.CalculateBottomPACBit.1" title="function: integer CalculateBottomPACBit(bit top_bit)">CalculateBottomPACBit</a>(A&lt;55&gt;);
    extfield = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(A&lt;55&gt;, 64);

    // If the VA is 56 or 55 bits and Top Byte is Ignored,
    // there are no unused bits left for the PAC
    if tbi &amp;&amp; bottom_PAC_bit &gt;= 55 then
        return A;

    if tbi then
        original_ptr = (A&lt;63:56&gt; :
                        extfield&lt;(56-bottom_PAC_bit)-1:0&gt; : A&lt;bottom_PAC_bit-1:0&gt;);
    elsif mtx then
        original_ptr = (extfield&lt;63:60&gt; : A&lt;59:56&gt; :
                        extfield&lt;(56-bottom_PAC_bit)-1:0&gt; : A&lt;bottom_PAC_bit-1:0&gt;);
    else
        original_ptr =  extfield&lt;(64-bottom_PAC_bit)-1:0&gt; : A&lt;bottom_PAC_bit-1:0&gt;;

    return original_ptr;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.trappacuse.TrapPACUse"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/trappacuse/TrapPACUse</h3>
      <p class="pseudocode">// TrapPACUse()
// ============
// Used for the trapping of the pointer authentication functions by higher exception
// levels.

<a id="impl-aarch64.TrapPACUse.1"/>TrapPACUse(bits(2) target_el)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; target_el !=  <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
    vect_offset = 0;
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACTrap</a>);
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64.ESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64.ESBOperation</h3>
      <p class="pseudocode">// AArch64.ESBOperation()
// ======================
// Perform the AArch64 ESB operation, either for ESB executed in AArch64 state, or for
// ESB in AArch32 state when SError interrupts are routed to an Exception level using
// AArch64

<a id="AArch64.ESBOperation.0"/>AArch64.ESBOperation()
    bits(2) target_el;
    boolean masked;

    (masked, target_el) = <a href="shared_pseudocode.html#AArch64.PhysicalSErrorTarget.0" title="function: (boolean, bits(2)) AArch64.PhysicalSErrorTarget()">AArch64.PhysicalSErrorTarget</a>();

    intdis = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</a>(target_el);
    masked = masked || intdis;

    // Check for a masked Physical SError pending that can be synchronized
    // by an Error synchronization event.
    if masked &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsSynchronizablePhysicalSErrorPending.0" title="function: boolean IsSynchronizablePhysicalSErrorPending()">IsSynchronizablePhysicalSErrorPending</a>() then
        // This function might be called for an interworking case, and INTdis is masking
        // the SError interrupt.
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()) then
            bits(32) syndrome = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);
            syndrome&lt;31&gt; = '1'; // A
            syndrome&lt;15:0&gt; = <a href="shared_pseudocode.html#AArch32.PhysicalSErrorSyndrome.0" title="function: bits(16) AArch32.PhysicalSErrorSyndrome()">AArch32.PhysicalSErrorSyndrome</a>();
            DISR = syndrome;
        else
            implicit_esb = FALSE;
            bits(64) syndrome = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
            syndrome&lt;31&gt; = '1'; // A
            syndrome&lt;24:0&gt; = <a href="shared_pseudocode.html#AArch64.PhysicalSErrorSyndrome.1" title="function: bits(25) AArch64.PhysicalSErrorSyndrome(boolean implicit_esb)">AArch64.PhysicalSErrorSyndrome</a>(implicit_esb);
            DISR_EL1 = syndrome;
        <a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();               // Set ISR_EL1.A to 0

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64.EncodeAsyncErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64.EncodeAsyncErrorSyndrome</h3>
      <p class="pseudocode">// AArch64.EncodeAsyncErrorSyndrome()
// ==================================
// Return the encoding for corresponding ErrorState.

bits(3) <a id="AArch64.EncodeAsyncErrorSyndrome.1"/>AArch64.EncodeAsyncErrorSyndrome(<a href="shared_pseudocode.html#ErrorState" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState</a> errorstate)
    case errorstate of
        when <a href="shared_pseudocode.html#ErrorState_UC" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UC</a>  return '000';
        when <a href="shared_pseudocode.html#ErrorState_UEU" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UEU</a> return '001';
        when <a href="shared_pseudocode.html#ErrorState_UEO" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UEO</a> return '010';
        when <a href="shared_pseudocode.html#ErrorState_UER" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UER</a> return '011';
        when <a href="shared_pseudocode.html#ErrorState_CE" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_CE</a>  return '110';
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64.EncodeSyncErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64.EncodeSyncErrorSyndrome</h3>
      <p class="pseudocode">// AArch64.EncodeSyncErrorSyndrome()
// =================================
// Return the encoding for corresponding ErrorState.

bits(2) <a id="AArch64.EncodeSyncErrorSyndrome.1"/>AArch64.EncodeSyncErrorSyndrome(<a href="shared_pseudocode.html#ErrorState" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState</a> errorstate)
    case errorstate of
        when <a href="shared_pseudocode.html#ErrorState_UC" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UC</a>  return '10';
        when <a href="shared_pseudocode.html#ErrorState_UEO" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UEO</a> return '11';
        when <a href="shared_pseudocode.html#ErrorState_UER" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UER</a> return '00';
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64.PhysicalSErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64.PhysicalSErrorSyndrome</h3>
      <p class="pseudocode">// AArch64.PhysicalSErrorSyndrome()
// ================================
// Generate SError syndrome.

bits(25) <a id="AArch64.PhysicalSErrorSyndrome.1"/>AArch64.PhysicalSErrorSyndrome(boolean implicit_esb)
    bits(25) syndrome = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(25);
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.GetPendingPhysicalSError.0" title="function: FaultRecord GetPendingPhysicalSError()">GetPendingPhysicalSError</a>();
    <a href="shared_pseudocode.html#ErrorState" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState</a> errorstate = <a href="shared_pseudocode.html#AArch64.PEErrorState.1" title="function: ErrorState AArch64.PEErrorState(FaultRecord fault)">AArch64.PEErrorState</a>(fault);
    if errorstate == <a href="shared_pseudocode.html#ErrorState_Uncategorized" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_Uncategorized</a> then
        syndrome = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(25);
    elsif errorstate == <a href="shared_pseudocode.html#ErrorState_IMPDEF" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_IMPDEF</a> then
        syndrome&lt;24&gt; = '1';                                             // IDS
        syndrome&lt;23:0&gt; = bits(24) IMPLEMENTATION_DEFINED "IMPDEF <a href="shared_pseudocode.html#ErrorState" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState</a>";
    else
        syndrome&lt;24&gt; = '0';                                             // IDS
        syndrome&lt;13&gt; = (if implicit_esb then '1' else '0');             // IESB
        syndrome&lt;12:10&gt; = <a href="shared_pseudocode.html#AArch64.EncodeAsyncErrorSyndrome.1" title="function: bits(3) AArch64.EncodeAsyncErrorSyndrome(ErrorState errorstate)">AArch64.EncodeAsyncErrorSyndrome</a>(errorstate); // AET
        syndrome&lt;5:0&gt; = '010001';                                       // DFSC
    return syndrome;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64.vESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64.vESBOperation</h3>
      <p class="pseudocode">// AArch64.vESBOperation()
// =======================
// Perform the AArch64 ESB operation for virtual SError interrupts, either for ESB
// executed in AArch64 state, or for ESB in AArch32 state with EL2 using AArch64 state

<a id="AArch64.vESBOperation.0"/>AArch64.vESBOperation()
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    // If physical SError interrupts are routed to EL2, and TGE is not set, then a virtual
    // SError interrupt might be pending
    vSEI_enabled = HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';
    vSEI_pending = vSEI_enabled &amp;&amp; HCR_EL2.VSE == '1';
    vintdis      = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    vmasked      = vintdis || PSTATE.A == '1';

    // Check for a masked virtual SError pending
    if vSEI_pending &amp;&amp; vmasked then
        // This function might be called for the interworking case, and INTdis is masking
        // the virtual SError interrupt.
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
            bits(32) target = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);
            target&lt;31&gt; = '1';              // A
            target&lt;15:14&gt; = VDFSR&lt;15:14&gt;;  // AET
            target&lt;12&gt;    = VDFSR&lt;12&gt;;     // ExT
            target&lt;9&gt;     = TTBCR.EAE;     // LPAE
            if TTBCR.EAE == '1' then       // Long-descriptor format
                target&lt;5:0&gt;    = '010001'; // STATUS
            else                           // Short-descriptor format
                target&lt;10,3:0&gt; = '10110';  // FS
            VDISR = target;
        else
            bits(64) target = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
            target&lt;31&gt; = '1';              // A
            target&lt;24:0&gt; = VSESR_EL2&lt;24:0&gt;;
            VDISR_EL2 = target;
        HCR_EL2.VSE = '0';                       // Clear pending virtual SError

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.rcw.ProtectionEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/rcw/ProtectionEnabled</h3>
      <p class="pseudocode">// ProtectionEnabled()
// ===================
// Returns TRUE if the ProtectedBit is
// enabled in the current Exception level.

boolean <a id="impl-aarch64.ProtectionEnabled.1"/>ProtectionEnabled(bits(2) el)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el);
    regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(el);
    assert(!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(regime));
    if (!<a href="shared_pseudocode.html#impl-aarch64.IsD128Enabled.1" title="function: boolean IsD128Enabled(bits(2) el)">IsD128Enabled</a>(el)) then
        case regime of
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
                return <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL1Enabled.0" title="function: boolean IsTCR2EL1Enabled()">IsTCR2EL1Enabled</a>() &amp;&amp; TCR2_EL1.PnCH == '1';
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
                return <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() &amp;&amp; TCR2_EL2.PnCH == '1';
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
                return TCR_EL3.PnCH == '1';
    else
        return TRUE;
    return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.rcw.RCW128_PROTECTED_BIT"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/rcw/RCW128_PROTECTED_BIT</h3>
      <p class="pseudocode">constant integer <a id="RCW128_PROTECTED_BIT"/>RCW128_PROTECTED_BIT = 114;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.rcw.RCW64_PROTECTED_BIT"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/rcw/RCW64_PROTECTED_BIT</h3>
      <p class="pseudocode">constant integer <a id="RCW64_PROTECTED_BIT"/>RCW64_PROTECTED_BIT = 52;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.rcw.RCWCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/rcw/RCWCheck</h3>
      <p class="pseudocode">// RCWCheck()
// ==========
// Returns nzcv based on : if the new value for RCW/RCWS instructions satisfy RCW and/or RCWS checks
// Z is set to 1 if RCW checks fail
// C is set to 0 if RCWS checks fail

bits(4) <a id="impl-aarch64.RCWCheck.3"/>RCWCheck(bits(N) old, bits(N) new, boolean soft)
    assert N IN {64,128};
    integer protectedbit = if N == 128 then <a href="shared_pseudocode.html#RCW128_PROTECTED_BIT" title="constant integer RCW128_PROTECTED_BIT = 114">RCW128_PROTECTED_BIT</a> else <a href="shared_pseudocode.html#RCW64_PROTECTED_BIT" title="constant integer RCW64_PROTECTED_BIT = 52">RCW64_PROTECTED_BIT</a>;
    boolean rcw_fail = FALSE;
    boolean rcws_fail = FALSE;
    boolean rcw_state_fail = FALSE;
    boolean rcws_state_fail = FALSE;
    boolean rcw_mask_fail = FALSE;
    boolean rcws_mask_fail = FALSE;

    //Effective RCWMask calculation
    bits(N) rcwmask = RCWMASK_EL1&lt;N-1:0&gt;;
    if N == 64 then
        rcwmask&lt;49:18&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(rcwmask&lt;17&gt;,32);
    else
        rcwmask&lt;55:17&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(rcwmask&lt;16&gt;,39);
        rcwmask&lt;126:125,120:119,108:101,90:56,1&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(48);

    //Effective RCWSMask calculation
    bits(N) rcwsoftmask = RCWSMASK_EL1&lt;N-1:0&gt;;
    if N == 64 then
        rcwsoftmask&lt;49:18&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(rcwsoftmask&lt;17&gt;,32);
        if(<a href="shared_pseudocode.html#impl-aarch64.ProtectionEnabled.1" title="function: boolean ProtectionEnabled(bits(2) el)">ProtectionEnabled</a>(PSTATE.EL)) then
            rcwsoftmask&lt;52&gt; = '0';
    else
        rcwsoftmask&lt;55:17&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(rcwsoftmask&lt;16&gt;,39);
        rcwsoftmask&lt;126:125,120:119,108:101,90:56,1&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(48);
        rcwsoftmask&lt;114&gt; = '0';

    //RCW Checks
    //State Check
    if (<a href="shared_pseudocode.html#impl-aarch64.ProtectionEnabled.1" title="function: boolean ProtectionEnabled(bits(2) el)">ProtectionEnabled</a>(PSTATE.EL)) then
        if old&lt;protectedbit&gt; == '1' then
            rcw_state_fail = new&lt;protectedbit,0&gt; != old&lt;protectedbit,0&gt;;
        elsif old&lt;protectedbit&gt; == '0' then
            rcw_state_fail = new&lt;protectedbit&gt; != old&lt;protectedbit&gt;;

    //Mask Check
    if (<a href="shared_pseudocode.html#impl-aarch64.ProtectionEnabled.1" title="function: boolean ProtectionEnabled(bits(2) el)">ProtectionEnabled</a>(PSTATE.EL)) then
        if old&lt;protectedbit,0&gt; == '11' then
            rcw_mask_fail = !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>((new EOR old) AND NOT(rcwmask));

    //RCWS Checks
    if soft then
        //State Check
        if old&lt;0&gt; == '1' then
            rcws_state_fail = new&lt;0&gt; != old&lt;0&gt;;
        elsif (!<a href="shared_pseudocode.html#impl-aarch64.ProtectionEnabled.1" title="function: boolean ProtectionEnabled(bits(2) el)">ProtectionEnabled</a>(PSTATE.EL) ||
              (<a href="shared_pseudocode.html#impl-aarch64.ProtectionEnabled.1" title="function: boolean ProtectionEnabled(bits(2) el)">ProtectionEnabled</a>(PSTATE.EL) &amp;&amp; old&lt;protectedbit&gt; == '0')) then
            rcws_state_fail = new&lt;0&gt; != old&lt;0&gt; ;
        //Mask Check
        if old&lt;0&gt; == '1' then
            rcws_mask_fail = !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>((new EOR old) AND NOT(rcwsoftmask));

    rcw_fail = rcw_state_fail  || rcw_mask_fail ;
    rcws_fail = rcws_state_fail || rcws_mask_fail;

    bit n = '0';
    bit z = if rcw_fail then '1' else '0';
    bit c = if rcws_fail then '0' else '1';
    bit v = '0';
    return &lt;n, z, c, v&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64.MaybeZeroRegisterUppers"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64.MaybeZeroRegisterUppers</h3>
      <p class="pseudocode">// AArch64.MaybeZeroRegisterUppers()
// =================================
// On taking an exception to  AArch64 from AArch32, it is CONSTRAINED UNPREDICTABLE whether the top
// 32 bits of registers visible at any lower Exception level using AArch32 are set to zero.

<a id="AArch64.MaybeZeroRegisterUppers.0"/>AArch64.MaybeZeroRegisterUppers()
    assert <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();         // Always called from AArch32 state before entering AArch64 state

    integer first;
    integer last;
    boolean include_R15;
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        first = 0;  last = 14;  include_R15 = FALSE;
    elsif PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        first = 0;  last = 30;  include_R15 = FALSE;
    else
        first = 0;  last = 30;  include_R15 = TRUE;

    for n = first to last
        if (n != 15 || include_R15) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ZEROUPPER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_ZEROUPPER</a>) then
            _R[n]&lt;63:32&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64.ResetGeneralRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64.ResetGeneralRegisters</h3>
      <p class="pseudocode">// AArch64.ResetGeneralRegisters()
// ===============================

<a id="AArch64.ResetGeneralRegisters.0"/>AArch64.ResetGeneralRegisters()

    for i = 0 to 30
        <a href="shared_pseudocode.html#impl-aarch64.X.write.2" title="accessor: X[integer n, integer width] = bits(width) value">X</a>[i, 64] = bits(64) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64.ResetSIMDFPRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64.ResetSIMDFPRegisters</h3>
      <p class="pseudocode">// AArch64.ResetSIMDFPRegisters()
// ==============================

<a id="AArch64.ResetSIMDFPRegisters.0"/>AArch64.ResetSIMDFPRegisters()

    for i = 0 to 31
        <a href="shared_pseudocode.html#impl-aarch64.V.write.2" title="accessor: V[integer n, integer width] = bits(width) value">V</a>[i, 128] = bits(128) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64.ResetSpecialRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64.ResetSpecialRegisters</h3>
      <p class="pseudocode">// AArch64.ResetSpecialRegisters()
// ===============================

<a id="AArch64.ResetSpecialRegisters.0"/>AArch64.ResetSpecialRegisters()

    // AArch64 special registers
    SP_EL0 = bits(64) UNKNOWN;
    SP_EL1 = bits(64) UNKNOWN;
    SPSR_EL1 = bits(64) UNKNOWN;
    ELR_EL1  = bits(64) UNKNOWN;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        SP_EL2 = bits(64) UNKNOWN;
        SPSR_EL2 = bits(64) UNKNOWN;
        ELR_EL2  = bits(64) UNKNOWN;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        SP_EL3 = bits(64) UNKNOWN;
        SPSR_EL3 = bits(64) UNKNOWN;
        ELR_EL3  = bits(64) UNKNOWN;

    // AArch32 special registers that are not architecturally mapped to AArch64 registers
    if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        SPSR_fiq&lt;31:0&gt; = bits(32) UNKNOWN;
        SPSR_irq&lt;31:0&gt; = bits(32) UNKNOWN;
        SPSR_abt&lt;31:0&gt; = bits(32) UNKNOWN;
        SPSR_und&lt;31:0&gt; = bits(32) UNKNOWN;

    // External debug special registers
    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(64) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64.ResetSystemRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64.ResetSystemRegisters</h3>
      <p class="pseudocode"><a id="AArch64.ResetSystemRegisters.1"/>AArch64.ResetSystemRegisters(boolean cold_reset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.PC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/PC</h3>
      <p class="pseudocode">// PC - non-assignment form
// ========================
// Read program counter.

bits(64) <a id="impl-aarch64.PC.read.0"/>PC[]
    return _PC;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SP</h3>
      <p class="pseudocode">// SP[] - assignment form
// ======================
// Write to stack pointer from a 64-bit value.

<a id="impl-aarch64.SP.write.0"/>SP[] = bits(64) value
    if PSTATE.SP == '0' then
        SP_EL0 = value;
    else
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  SP_EL0 = value;
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  SP_EL1 = value;
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  SP_EL2 = value;
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  SP_EL3 = value;
    return;

// SP[] - non-assignment form
// ==========================
// Read stack pointer with slice of 64 bits.

bits(64) <a id="impl-aarch64.SP.read.0"/>SP[]
    if PSTATE.SP == '0' then
        return SP_EL0;
    else
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  return SP_EL0;
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  return SP_EL1;
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  return SP_EL2;
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  return SP_EL3;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMCFGR_EL1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMCFGR_EL1</h3>
      <p class="pseudocode">// Read the current configuration of System Performance monitor for
// System PMU 's'.
bits(64) <a id="impl-aarch64.SPMCFGR_EL1.read.1"/>SPMCFGR_EL1[integer s];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMCGCR_EL1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMCGCR_EL1</h3>
      <p class="pseudocode">// Read the counter group configuration of System Performance monitor
// 's'.
bits(64) <a id="impl-aarch64.SPMCGCR_EL1.read.1"/>SPMCGCR_EL1[integer s];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMCNTENCLR_EL0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMCNTENCLR_EL0</h3>
      <p class="pseudocode">// Read the current mapping of disabled event counters for an 's'.
bits(64) <a id="impl-aarch64.SPMCNTENCLR_EL0.read.1"/>SPMCNTENCLR_EL0[integer s];

// Disable event counters for System PMU 's'.
<a id="impl-aarch64.SPMCNTENCLR_EL0.write.1"/>SPMCNTENCLR_EL0[integer s] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMCNTENSET_EL0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMCNTENSET_EL0</h3>
      <p class="pseudocode">// Read the current mapping for enabled event counters of System PMU 's'.
bits(64) <a id="impl-aarch64.SPMCNTENSET_EL0.read.1"/>SPMCNTENSET_EL0[integer s];

// Enable event counters of System PMU 's'.
<a id="impl-aarch64.SPMCNTENSET_EL0.write.1"/>SPMCNTENSET_EL0[integer s] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMCR_EL0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMCR_EL0</h3>
      <p class="pseudocode">// Read the control register for System PMU 's'.
bits(64) <a id="impl-aarch64.SPMCR_EL0.read.1"/>SPMCR_EL0[integer s];

// Write to the control register for System PMU 's'.
<a id="impl-aarch64.SPMCR_EL0.write.1"/>SPMCR_EL0[integer s] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMDEVARCH_EL1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMDEVARCH_EL1</h3>
      <p class="pseudocode">// Read the discovery information for System PMU 's'.
bits(64) <a id="impl-aarch64.SPMDEVARCH_EL1.read.1"/>SPMDEVARCH_EL1[integer s];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMEVCNTR_EL0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMEVCNTR_EL0</h3>
      <p class="pseudocode">// Read a System PMU Event Counter register for counter 'n' of a given
// System PMU 's'.
bits(64) <a id="impl-aarch64.SPMEVCNTR_EL0.read.2"/>SPMEVCNTR_EL0[integer s, integer n];

// Write to a System PMU Event Counter register for counter 'n' of a given
// System PMU 's'.
<a id="impl-aarch64.SPMEVCNTR_EL0.write.2"/>SPMEVCNTR_EL0[integer s, integer n] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMEVFILT2R_EL0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMEVFILT2R_EL0</h3>
      <p class="pseudocode">// Read the additional event selection controls for
// counter 'n' of a given System PMU 's'.
bits(64) <a id="impl-aarch64.SPMEVFILT2R_EL0.read.2"/>SPMEVFILT2R_EL0[integer s, integer n];

// Configure the additional event selection controls for
// counter 'n' of a given System PMU 's'.
<a id="impl-aarch64.SPMEVFILT2R_EL0.write.2"/>SPMEVFILT2R_EL0[integer s, integer n] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMEVFILTR_EL0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMEVFILTR_EL0</h3>
      <p class="pseudocode">// Read the additional event selection controls for
// counter 'n' of a given System PMU 's'.
bits(64) <a id="impl-aarch64.SPMEVFILTR_EL0.read.2"/>SPMEVFILTR_EL0[integer s, integer n];

// Configure the additional event selection controls for
// counter 'n' of a given System PMU 's'.
<a id="impl-aarch64.SPMEVFILTR_EL0.write.2"/>SPMEVFILTR_EL0[integer s, integer n] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMEVTYPER_EL0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMEVTYPER_EL0</h3>
      <p class="pseudocode">// Read the current mapping of event with event counter SPMEVCNTR_EL0
// for counter 'n' of a given System PMU 's'.
bits(64) <a id="impl-aarch64.SPMEVTYPER_EL0.read.2"/>SPMEVTYPER_EL0[integer s, integer n];

// Configure which event increments the event counter SPMEVCNTR_EL0, for
// counter 'n' of a given System PMU 's'.
<a id="impl-aarch64.SPMEVTYPER_EL0.write.2"/>SPMEVTYPER_EL0[integer s, integer n] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMIIDR_EL1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMIIDR_EL1</h3>
      <p class="pseudocode">// Read the discovery information for System PMU 's'.
bits(64) <a id="impl-aarch64.SPMIIDR_EL1.read.1"/>SPMIIDR_EL1[integer s];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMINTENCLR_EL1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMINTENCLR_EL1</h3>
      <p class="pseudocode">// Read the masking information for interrupt requests on overflows of
// implemented counters of System PMU 's'.
bits(64) <a id="impl-aarch64.SPMINTENCLR_EL1.read.1"/>SPMINTENCLR_EL1[integer s];

// Disable the generation of interrupt requests on overflows of
// implemented counters of System PMU 's'.
<a id="impl-aarch64.SPMINTENCLR_EL1.write.1"/>SPMINTENCLR_EL1[integer s] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMINTENSET_EL1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMINTENSET_EL1</h3>
      <p class="pseudocode">// Read the masking information for interrupt requests on overflows of
// implemented counters of System PMU 's'.
bits(64) <a id="impl-aarch64.SPMINTENSET_EL1.read.1"/>SPMINTENSET_EL1[integer s];

// Disable the generation of interrupt requests on overflows of
// implemented counters for System PMU 's'.
<a id="impl-aarch64.SPMINTENSET_EL1.write.1"/>SPMINTENSET_EL1[integer s] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMOVSCLR_EL0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMOVSCLR_EL0</h3>
      <p class="pseudocode">// Read the overflow bit clear status of implemented counters for System PMU 's'.
bits(64) <a id="impl-aarch64.SPMOVSCLR_EL0.read.1"/>SPMOVSCLR_EL0[integer s];

// Clear the overflow bit clear status of implemented counters for
// System PMU 's'.
<a id="impl-aarch64.SPMOVSCLR_EL0.write.1"/>SPMOVSCLR_EL0[integer s] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMOVSSET_EL0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMOVSSET_EL0</h3>
      <p class="pseudocode">// Read state of the overflow bit for the implemented event counters
// of System PMU 's'.
bits(64) <a id="impl-aarch64.SPMOVSSET_EL0.read.1"/>SPMOVSSET_EL0[integer s];

// Sets the state of the overflow bit for the implemented event counters
// of System PMU 's'.
<a id="impl-aarch64.SPMOVSSET_EL0.write.1"/>SPMOVSSET_EL0[integer s] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMROOTCR_EL3"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMROOTCR_EL3</h3>
      <p class="pseudocode">// Read the observability of Root and Realm events by System Performance
// Monitor for System PMU 's'.
bits(64) <a id="impl-aarch64.SPMROOTCR_EL3.read.1"/>SPMROOTCR_EL3[integer s];

// Configure the observability of Root and Realm events by System
// Performance Monitor for System PMU 's'.
<a id="impl-aarch64.SPMROOTCR_EL3.write.1"/>SPMROOTCR_EL3[integer s] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SPMSCR_EL1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SPMSCR_EL1</h3>
      <p class="pseudocode">// Read the observability of Secure events by System Performance Monitor
// for System PMU 's'.
bits(64) <a id="impl-aarch64.SPMSCR_EL1.read.1"/>SPMSCR_EL1[integer s];

// Configure the observability of secure events by System Performance
// Monitor for System PMU 's'.
<a id="impl-aarch64.SPMSCR_EL1.write.1"/>SPMSCR_EL1[integer s] = bits(64) value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.V"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/V</h3>
      <p class="pseudocode">// V[] - assignment form
// =====================
// Write to SIMD&amp;FP register with implicit extension from
// 8, 16, 32, 64 or 128 bits.

<a id="impl-aarch64.V.write.2"/>V[integer n, integer width] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64,128};
    integer vlen = if <a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)">IsSVEEnabled</a>(PSTATE.EL) then <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a> else 128;
    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_SVEZEROUPPER</a>) then
        _Z[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, <a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>);
    else
        _Z[n]&lt;vlen-1:0&gt; = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, vlen);

// V[] - non-assignment form
// =========================
// Read from SIMD&amp;FP register with implicit slice of 8, 16
// 32, 64 or 128 bits.

bits(width) <a id="impl-aarch64.V.read.2"/>V[integer n, integer width]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64,128};
    return _Z[n]&lt;width-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.Vpart"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/Vpart</h3>
      <p class="pseudocode">// Vpart[] - non-assignment form
// =============================
// Reads a 128-bit SIMD&amp;FP register in up to two parts:
//  part 0 returns the bottom 8, 16, 32 or 64 bits of a value held in the register;
//  part 1 returns the top half of the bottom 64 bits or the top half of the 128-bit
//  value held in the register.

bits(width) <a id="impl-aarch64.Vpart.read.3"/>Vpart[integer n, integer part, integer width]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert part IN {0, 1};
    if part == 0 then
        assert width &lt; 128;
        return <a href="shared_pseudocode.html#impl-aarch64.V.read.2" title="accessor: bits(width) V[integer n, integer width]">V</a>[n, width];
    else
        assert width IN {32,64};
        bits(128) vreg = <a href="shared_pseudocode.html#impl-aarch64.V.read.2" title="accessor: bits(width) V[integer n, integer width]">V</a>[n, 128];
        return vreg&lt;(width * 2)-1:width&gt;;

// Vpart[] - assignment form
// =========================
// Writes a 128-bit SIMD&amp;FP register in up to two parts:
//  part 0 zero extends a 8, 16, 32, or 64-bit value to fill the whole register;
//  part 1 inserts a 64-bit value into the top half of the register.

<a id="impl-aarch64.Vpart.write.3"/>Vpart[integer n, integer part, integer width] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert part IN {0, 1};
    if part == 0 then
        assert width &lt; 128;
        <a href="shared_pseudocode.html#impl-aarch64.V.write.2" title="accessor: V[integer n, integer width] = bits(width) value">V</a>[n, width] = value;
    else
        assert width == 64;
        bits(64) vreg = <a href="shared_pseudocode.html#impl-aarch64.V.read.2" title="accessor: bits(width) V[integer n, integer width]">V</a>[n, 64];
        <a href="shared_pseudocode.html#impl-aarch64.V.write.2" title="accessor: V[integer n, integer width] = bits(width) value">V</a>[n, 128] = value&lt;63:0&gt; : vreg;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.X"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/X</h3>
      <p class="pseudocode">// X[] - assignment form
// =====================
// Write to general-purpose register from either a 32-bit or a 64-bit value,
// where the size of the value is passed as an argument.

<a id="impl-aarch64.X.write.2"/>X[integer n, integer width] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {32,64};
    if n != 31 then
        _R[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, 64);
    return;

// X[] - non-assignment form
// =========================
// Read from general-purpose register with an explicit slice of 8, 16, 32 or 64 bits.

bits(width) <a id="impl-aarch64.X.read.2"/>X[integer n, integer width]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64};
    if n != 31 then
        return _R[n]&lt;width-1:0&gt;;
    else
        return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(width);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.CounterToPredicate"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/CounterToPredicate</h3>
      <p class="pseudocode">// CounterToPredicate()
// ====================

bits(width) <a id="impl-aarch64.CounterToPredicate.2"/>CounterToPredicate(bits(16) pred, integer width)
    integer count;
    integer esize;
    integer elements;
    constant integer VL = <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a>;
    constant integer PL = VL DIV 8;
    integer maxbit = <a href="shared_pseudocode.html#impl-shared.HighestSetBit.1" title="function: integer HighestSetBit(bits(N) x)">HighestSetBit</a>(<a href="shared_pseudocode.html#impl-aarch64.CeilPow2.1" title="function: integer CeilPow2(integer x)">CeilPow2</a>(PL * 4)&lt;15:0&gt;);
    assert maxbit &lt;= 14;
    bits(PL*4) result;
    boolean invert = pred&lt;15&gt; == '1';

    assert width == PL || width == PL*2 || width == PL*3 || width == PL*4;

    if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(pred&lt;3:0&gt;) then
        return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(width);

    case pred&lt;3:0&gt; of
        when 'xxx1'
            count = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pred&lt;maxbit:1&gt;);
            esize = 8;
        when 'xx10'
            count = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pred&lt;maxbit:2&gt;);
            esize = 16;
        when 'x100'
            count = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pred&lt;maxbit:3&gt;);
            esize = 32;
        when '1000'
            count = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pred&lt;maxbit:4&gt;);
            esize = 64;

    elements = (VL * 4) DIV esize;
    result = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(PL*4);
    for e = 0 to elements-1
        if !invert then
            <a href="shared_pseudocode.html#impl-aarch64.ElemP.write.3" title="accessor: ElemP[bits(N) &amp;pred, integer e, integer esize] = bit value">ElemP</a>[result, e, esize] = if e &lt; count then '1' else '0';
        else
            <a href="shared_pseudocode.html#impl-aarch64.ElemP.write.3" title="accessor: ElemP[bits(N) &amp;pred, integer e, integer esize] = bit value">ElemP</a>[result, e, esize] = if e &gt;= count then '1' else '0';

    return result&lt;width-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.EncodePredCount"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/EncodePredCount</h3>
      <p class="pseudocode">// EncodePredCount()
// =================

bits(width) <a id="impl-aarch64.EncodePredCount.5"/>EncodePredCount(integer esize, integer elements, integer count_in, boolean invert_in, integer width)
    integer count = count_in;
    boolean invert = invert_in;
    constant integer PL = <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a> DIV 8;
    assert width == PL;
    assert esize IN {8, 16, 32, 64};
    assert count &gt;=0 &amp;&amp; count &lt;= elements;
    bits(16) pred;

    if count == 0 then
        return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(width);

    if invert then
        count = elements - count;
    elsif count == elements then
        count = 0;
        invert = TRUE;

    bit inv = (if invert then '1' else '0');
    case esize of
        when 8  pred = inv : count&lt;13:0&gt; :    '1';
        when 16 pred = inv : count&lt;12:0&gt; :   '10';
        when 32 pred = inv : count&lt;11:0&gt; :  '100';
        when 64 pred = inv : count&lt;10:0&gt; : '1000';

    return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(pred, width);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.HaveSME"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/HaveSME</h3>
      <p class="pseudocode">// HaveSME()
// =========
// Returns TRUE if the SME extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSME.0"/>HaveSME()
    return IsFeatureImplemented(FEAT_SME);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.HaveSME2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/HaveSME2</h3>
      <p class="pseudocode">// HaveSME2()
// ==========
// Returns TRUE if the SME2 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSME2.0"/>HaveSME2()
    return IsFeatureImplemented(FEAT_SME2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.HaveSME2p1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/HaveSME2p1</h3>
      <p class="pseudocode">// HaveSME2p1()
// ============
// Returns TRUE if the SME2.1 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSME2p1.0"/>HaveSME2p1()
    return IsFeatureImplemented(FEAT_SME2p1);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.HaveSMEB16B16"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/HaveSMEB16B16</h3>
      <p class="pseudocode">// HaveSMEB16B16()
// ===============
// Returns TRUE if the SME2.1 non-widening BFloat16 instructions are implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSMEB16B16.0"/>HaveSMEB16B16()
    return IsFeatureImplemented(FEAT_B16B16);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.HaveSMEF16F16"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/HaveSMEF16F16</h3>
      <p class="pseudocode">// HaveSMEF16F16()
// ===============
// Returns TRUE if the SME2.1 half-precision instructions are implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSMEF16F16.0"/>HaveSMEF16F16()
    return IsFeatureImplemented(FEAT_SME_F16F16);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.HaveSMEF64F64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/HaveSMEF64F64</h3>
      <p class="pseudocode">// HaveSMEF64F64()
// ===============
// Returns TRUE if the SMEF64F64 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSMEF64F64.0"/>HaveSMEF64F64()
    return IsFeatureImplemented(FEAT_SME_F64F64);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.HaveSMEI16I64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/HaveSMEI16I64</h3>
      <p class="pseudocode">// HaveSMEI16I64()
// ===============
// Returns TRUE if the SMEI16I64 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSMEI16I64.0"/>HaveSMEI16I64()
    return IsFeatureImplemented(FEAT_SME_I16I64);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.Lookup"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/Lookup</h3>
      <p class="pseudocode">bits(512) _ZT0;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.PredCountTest"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/PredCountTest</h3>
      <p class="pseudocode">// PredCountTest()
// ===============

bits(4) <a id="impl-aarch64.PredCountTest.3"/>PredCountTest(integer elements, integer count, boolean invert)
    bit n, z, c, v;
    z = (if count == 0 then '1' else '0');              // none active
    if !invert then
        n = (if count != 0 then '1' else '0');          // first active
        c = (if count == elements then '0' else '1');   // NOT last active
    else
        n = (if count == elements then '1' else '0');   // first active
        c = (if count != 0 then '0' else '1');          // NOT last active
    v = '0';

    return n:z:c:v;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.System"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/System</h3>
      <p class="pseudocode">array bits(<a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>) _ZA[0..255];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAhslice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAhslice</h3>
      <p class="pseudocode">// ZAhslice[] - non-assignment form
// ================================

bits(width) <a id="impl-aarch64.ZAhslice.read.4"/>ZAhslice[integer tile, integer esize, integer slice, integer width]
    assert esize IN {8, 16, 32, 64, 128};
    integer tiles = esize DIV 8;
    assert tile &gt;= 0 &amp;&amp; tile &lt; tiles;
    integer slices = <a href="shared_pseudocode.html#impl-aarch64.CurrentSVL.read.none" title="accessor: integer CurrentSVL">CurrentSVL</a> DIV esize;
    assert slice &gt;= 0 &amp;&amp; slice &lt; slices;

    return <a href="shared_pseudocode.html#impl-aarch64.ZAvector.read.2" title="accessor: bits(width) ZAvector[integer index, integer width]">ZAvector</a>[tile + slice * tiles, width];

// ZAhslice[] - assignment form
// ============================

<a id="impl-aarch64.ZAhslice.write.4"/>ZAhslice[integer tile, integer esize, integer slice, integer width] = bits(width) value
    assert esize IN {8, 16, 32, 64, 128};
    integer tiles = esize DIV 8;
    assert tile &gt;= 0 &amp;&amp; tile &lt; tiles;
    integer slices = <a href="shared_pseudocode.html#impl-aarch64.CurrentSVL.read.none" title="accessor: integer CurrentSVL">CurrentSVL</a> DIV esize;
    assert slice &gt;= 0 &amp;&amp; slice &lt; slices;

    <a href="shared_pseudocode.html#impl-aarch64.ZAvector.write.2" title="accessor: ZAvector[integer index, integer width] = bits(width) value">ZAvector</a>[tile + slice * tiles, width] = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAslice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAslice</h3>
      <p class="pseudocode">// ZAslice[] - non-assignment form
// ===============================

bits(width) <a id="impl-aarch64.ZAslice.read.5"/>ZAslice[integer tile, integer esize, boolean vertical, integer slice, integer width]
    bits(width) result;

    if vertical then
        result = <a href="shared_pseudocode.html#impl-aarch64.ZAvslice.read.4" title="accessor: bits(width) ZAvslice[integer tile, integer esize, integer slice, integer width]">ZAvslice</a>[tile, esize, slice, width];
    else
        result = <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.read.4" title="accessor: bits(width) ZAhslice[integer tile, integer esize, integer slice, integer width]">ZAhslice</a>[tile, esize, slice, width];

    return result;

// ZAslice[] - assignment form
// ===========================

<a id="impl-aarch64.ZAslice.write.5"/>ZAslice[integer tile, integer esize, boolean vertical, integer slice, integer width] = bits(width) value
    if vertical then
        <a href="shared_pseudocode.html#impl-aarch64.ZAvslice.write.4" title="accessor: ZAvslice[integer tile, integer esize, integer slice, integer width] = bits(width) value">ZAvslice</a>[tile, esize, slice, width] = value;
    else
        <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.write.4" title="accessor: ZAhslice[integer tile, integer esize, integer slice, integer width] = bits(width) value">ZAhslice</a>[tile, esize, slice, width] = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAtile"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAtile</h3>
      <p class="pseudocode">// ZAtile[] - non-assignment form
// ==============================

bits(width) <a id="impl-aarch64.ZAtile.read.3"/>ZAtile[integer tile, integer esize, integer width]
    constant integer SVL = <a href="shared_pseudocode.html#impl-aarch64.CurrentSVL.read.none" title="accessor: integer CurrentSVL">CurrentSVL</a>;
    integer slices = SVL DIV esize;
    assert width == SVL * slices;
    bits(width) result;

    for slice = 0 to slices-1
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, slice, SVL] = <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.read.4" title="accessor: bits(width) ZAhslice[integer tile, integer esize, integer slice, integer width]">ZAhslice</a>[tile, esize, slice, SVL];

    return result;

// ZAtile[] - assignment form
// ==========================

<a id="impl-aarch64.ZAtile.write.3"/>ZAtile[integer tile, integer esize, integer width] = bits(width) value
    constant integer SVL = <a href="shared_pseudocode.html#impl-aarch64.CurrentSVL.read.none" title="accessor: integer CurrentSVL">CurrentSVL</a>;
    integer slices = SVL DIV esize;
    assert width == SVL * slices;

    for slice = 0 to slices-1
        <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.write.4" title="accessor: ZAhslice[integer tile, integer esize, integer slice, integer width] = bits(width) value">ZAhslice</a>[tile, esize, slice, SVL] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[value, slice, SVL];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAvector"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAvector</h3>
      <p class="pseudocode">// ZAvector[] - non-assignment form
// ================================

bits(width) <a id="impl-aarch64.ZAvector.read.2"/>ZAvector[integer index, integer width]
    assert width == <a href="shared_pseudocode.html#impl-aarch64.CurrentSVL.read.none" title="accessor: integer CurrentSVL">CurrentSVL</a>;
    assert index &gt;= 0 &amp;&amp; index &lt; (width DIV 8);

    return _ZA[index]&lt;width-1:0&gt;;

// ZAvector[] - assignment form
// ============================

<a id="impl-aarch64.ZAvector.write.2"/>ZAvector[integer index, integer width] = bits(width) value
    assert width == <a href="shared_pseudocode.html#impl-aarch64.CurrentSVL.read.none" title="accessor: integer CurrentSVL">CurrentSVL</a>;
    assert index &gt;= 0 &amp;&amp; index &lt; (width DIV 8);

    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SMEZEROUPPER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_SMEZEROUPPER</a>) then
        _ZA[index] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, <a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>);
    else
        _ZA[index]&lt;width-1:0&gt; = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAvslice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAvslice</h3>
      <p class="pseudocode">// ZAvslice[] - non-assignment form
// ================================

bits(width) <a id="impl-aarch64.ZAvslice.read.4"/>ZAvslice[integer tile, integer esize, integer slice, integer width]
    integer slices = <a href="shared_pseudocode.html#impl-aarch64.CurrentSVL.read.none" title="accessor: integer CurrentSVL">CurrentSVL</a> DIV esize;
    bits(width) result;

    for s = 0 to slices-1
        bits(width) hslice = <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.read.4" title="accessor: bits(width) ZAhslice[integer tile, integer esize, integer slice, integer width]">ZAhslice</a>[tile, esize, s, width];
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, s, esize] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[hslice, slice, esize];

    return result;

// ZAvslice[] - assignment form
// ============================

<a id="impl-aarch64.ZAvslice.write.4"/>ZAvslice[integer tile, integer esize, integer slice, integer width] = bits(width) value
    integer slices = <a href="shared_pseudocode.html#impl-aarch64.CurrentSVL.read.none" title="accessor: integer CurrentSVL">CurrentSVL</a> DIV esize;

    for s = 0 to slices-1
        bits(width) hslice = <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.read.4" title="accessor: bits(width) ZAhslice[integer tile, integer esize, integer slice, integer width]">ZAhslice</a>[tile, esize, s, width];
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[hslice, slice, esize] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[value, s, esize];
        <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.write.4" title="accessor: ZAhslice[integer tile, integer esize, integer slice, integer width] = bits(width) value">ZAhslice</a>[tile, esize, s, width] = hslice;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZT0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZT0</h3>
      <p class="pseudocode">// ZT0[] - non-assignment form
// ===========================

bits(width) <a id="impl-aarch64.ZT0.read.1"/>ZT0[integer width]
    assert width == 512;
    return _ZT0&lt;width-1:0&gt;;

// ZT0[] - assignment form
// =======================

<a id="impl-aarch64.ZT0.write.1"/>ZT0[integer width] = bits(width) value
    assert width == 512;
    _ZT0&lt;width-1:0&gt; = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.AArch32.IsFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/AArch32.IsFPEnabled</h3>
      <p class="pseudocode">// AArch32.IsFPEnabled()
// =====================
// Returns TRUE if access to the SIMD&amp;FP instructions or System registers are
// enabled at the target exception level in AArch32 state and FALSE otherwise.

boolean <a id="AArch32.IsFPEnabled.1"/>AArch32.IsFPEnabled(bits(2) el)
    if el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        return <a href="shared_pseudocode.html#AArch64.IsFPEnabled.1" title="function: boolean AArch64.IsFPEnabled(bits(2) el)">AArch64.IsFPEnabled</a>(el);

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
        // Check if access disabled in NSACR
        if NSACR.cp10 == '0' then return FALSE;

    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
        // Check if access disabled in CPACR
        boolean disabled;
        case CPACR.cp10 of
            when '00' disabled = TRUE;
            when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '10' disabled = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_RESCPACR" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESCPACR</a>);
            when '11' disabled = FALSE;
        if disabled then return FALSE;

    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            return <a href="shared_pseudocode.html#AArch64.IsFPEnabled.1" title="function: boolean AArch64.IsFPEnabled(bits(2) el)">AArch64.IsFPEnabled</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        if HCPTR.TCP10 == '1' then return FALSE;

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        // Check if access disabled in CPTR_EL3
        if CPTR_EL3.TFP == '1' then return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.AArch64.IsFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/AArch64.IsFPEnabled</h3>
      <p class="pseudocode">// AArch64.IsFPEnabled()
// =====================
// Returns TRUE if access to the SIMD&amp;FP instructions or System registers are
// enabled at the target exception level in AArch64 state and FALSE otherwise.

boolean <a id="AArch64.IsFPEnabled.1"/>AArch64.IsFPEnabled(bits(2) el)
    // Check if access disabled in CPACR_EL1
    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check SIMD&amp;FP at EL0/EL1
        boolean disabled;
        case CPACR_EL1.FPEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then return FALSE;

    // Check if access disabled in CPTR_EL2
    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            boolean disabled;
            case CPTR_EL2.FPEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then return FALSE;
        else
            if CPTR_EL2.TFP == '1' then return FALSE;

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CPTR_EL3.TFP == '1' then return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.AnyActiveElement"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/AnyActiveElement</h3>
      <p class="pseudocode">// AnyActiveElement()
// ==================
// Return TRUE if there is at least one active element in mask. Otherwise,
// return FALSE.

boolean <a id="impl-aarch64.AnyActiveElement.2"/>AnyActiveElement(bits(N) mask, integer esize)
    return <a href="shared_pseudocode.html#impl-aarch64.LastActiveElement.2" title="function: integer LastActiveElement(bits(N) mask, integer esize)">LastActiveElement</a>(mask, esize) &gt;= 0;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.BitDeposit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/BitDeposit</h3>
      <p class="pseudocode">// BitDeposit()
// ============
// Deposit the least significant bits from DATA into result positions
// selected by non-zero bits in MASK, setting other result bits to zero.

bits(N) <a id="impl-aarch64.BitDeposit.2"/>BitDeposit (bits(N) data, bits(N) mask)
    bits(N) res = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N);
    integer db = 0;
    for rb = 0 to N-1
        if mask&lt;rb&gt; == '1' then
            res&lt;rb&gt; = data&lt;db&gt;;
            db = db + 1;
    return res;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.BitExtract"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/BitExtract</h3>
      <p class="pseudocode">// BitExtract()
// ============
// Extract and pack DATA bits selected by the non-zero bits in MASK into
// the least significant result bits, setting other result bits to zero.

bits(N) <a id="impl-aarch64.BitExtract.2"/>BitExtract (bits(N) data, bits(N) mask)
    bits(N) res = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N);
    integer rb = 0;
    for db = 0 to N-1
        if mask&lt;db&gt; == '1' then
            res&lt;rb&gt; = data&lt;db&gt;;
            rb = rb + 1;
    return res;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.BitGroup"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/BitGroup</h3>
      <p class="pseudocode">// BitGroup()
// ==========
// Extract and pack DATA bits selected by the non-zero bits in MASK into
// the least significant result bits, and pack unselected bits into the
// most significant result bits.

bits(N) <a id="impl-aarch64.BitGroup.2"/>BitGroup (bits(N) data, bits(N) mask)
    bits(N) res;
    integer rb = 0;

    // compress masked bits to right
    for db = 0 to N-1
        if mask&lt;db&gt; == '1' then
            res&lt;rb&gt; = data&lt;db&gt;;
            rb = rb + 1;
    // compress unmasked bits to left
    for db = 0 to N-1
        if mask&lt;db&gt; == '0' then
            res&lt;rb&gt; = data&lt;db&gt;;
            rb = rb + 1;
    return res;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CeilPow2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CeilPow2</h3>
      <p class="pseudocode">// CeilPow2()
// ==========
// For a positive integer X, return the smallest power of 2 &gt;= X

integer <a id="impl-aarch64.CeilPow2.1"/>CeilPow2(integer x)
    if x == 0 then return 0;
    if x == 1 then return 2;
    return <a href="shared_pseudocode.html#impl-aarch64.FloorPow2.1" title="function: integer FloorPow2(integer x)">FloorPow2</a>(x - 1) * 2;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckNonStreamingSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckNonStreamingSVEEnabled</h3>
      <p class="pseudocode">// CheckNonStreamingSVEEnabled()
// =============================
// Checks for traps on SVE instructions that are not legal in streaming mode.

<a id="impl-aarch64.CheckNonStreamingSVEEnabled.0"/>CheckNonStreamingSVEEnabled()
    <a href="shared_pseudocode.html#impl-aarch64.CheckSVEEnabled.0" title="function: CheckSVEEnabled()">CheckSVEEnabled</a>();

    if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.IsFullA64Enabled.0" title="function: boolean IsFullA64Enabled()">IsFullA64Enabled</a>() then
        <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_Streaming" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_Streaming</a>, PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckNormalSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckNormalSVEEnabled</h3>
      <p class="pseudocode">// CheckNormalSVEEnabled()
// =======================
// Checks for traps on normal SVE instructions and instructions that
// access SVE System registers.

<a id="impl-aarch64.CheckNormalSVEEnabled.0"/>CheckNormalSVEEnabled()
    boolean disabled;

    if (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; (CPTR_EL3.EZ == '0' || CPTR_EL3.TFP == '1') &amp;&amp;
        <a href="shared_pseudocode.html#impl-shared.EL3SDDUndefPriority.0" title="function: boolean EL3SDDUndefPriority()">EL3SDDUndefPriority</a>()) then
        UNDEFINED;

    // Check if access disabled in CPACR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check SVE at EL0/EL1
        case CPACR_EL1.ZEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)">SVEAccessTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

        // Check SIMD&amp;FP at EL0/EL1
        case CPACR_EL1.FPEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    // Check if access disabled in CPTR_EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            // Check SVE at EL2
            case CPTR_EL2.ZEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)">SVEAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

            // Check SIMD&amp;FP at EL2
            case CPTR_EL2.FPEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        else
            if CPTR_EL2.TZ == '1' then <a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)">SVEAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
            if CPTR_EL2.TFP == '1' then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CPTR_EL3.EZ == '0' then
            if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
                UNDEFINED;
            else
                <a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)">SVEAccessTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);

        if CPTR_EL3.TFP == '1' then
            if <a href="shared_pseudocode.html#impl-shared.EL3SDDUndef.0" title="function: boolean EL3SDDUndef()">EL3SDDUndef</a>() then
                UNDEFINED;
            else
                <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSMEAccess"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSMEAccess</h3>
      <p class="pseudocode">// CheckSMEAccess()
// ================
// Check that access to SME System registers is enabled.

<a id="impl-aarch64.CheckSMEAccess.0"/>CheckSMEAccess()
    boolean disabled;
    // Check if access disabled in CPACR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check SME at EL0/EL1
        case CPACR_EL1.SMEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            // Check SME at EL2
            case CPTR_EL2.SMEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        else
            if CPTR_EL2.TSM == '1' then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CPTR_EL3.ESM == '0' then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSMEAndZAEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSMEAndZAEnabled</h3>
      <p class="pseudocode">// CheckSMEAndZAEnabled()
// ======================

<a id="impl-aarch64.CheckSMEAndZAEnabled.0"/>CheckSMEAndZAEnabled()
    <a href="shared_pseudocode.html#impl-aarch64.CheckSMEEnabled.0" title="function: CheckSMEEnabled()">CheckSMEEnabled</a>();

    if PSTATE.ZA == '0' then
        <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_InactiveZA" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_InactiveZA</a>, PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSMEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSMEEnabled</h3>
      <p class="pseudocode">// CheckSMEEnabled()
// =================

<a id="impl-aarch64.CheckSMEEnabled.0"/>CheckSMEEnabled()
    boolean disabled;
    // Check if access disabled in CPACR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check SME at EL0/EL1
        case CPACR_EL1.SMEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

        // Check SIMD&amp;FP at EL0/EL1
        case CPACR_EL1.FPEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            // Check SME at EL2
            case CPTR_EL2.SMEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

            // Check SIMD&amp;FP at EL2
            case CPTR_EL2.FPEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        else
            if CPTR_EL2.TSM == '1' then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
            if CPTR_EL2.TFP == '1' then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CPTR_EL3.ESM == '0' then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        if CPTR_EL3.TFP == '1' then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSMEZT0Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSMEZT0Enabled</h3>
      <p class="pseudocode">// CheckSMEZT0Enabled()
// ====================
// Checks for ZT0 enabled.

<a id="impl-aarch64.CheckSMEZT0Enabled.0"/>CheckSMEZT0Enabled()
    // Check if ZA and ZT0 are inactive in PSTATE
    if PSTATE.ZA == '0' then
        <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_InactiveZA" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_InactiveZA</a>, PSTATE.EL);

    // Check if EL0/EL1 accesses to ZT0 are disabled in SMCR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        if SMCR_EL1.EZT0 == '0' then
            <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_InaccessibleZT0" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_InaccessibleZT0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    // Check if EL0/EL1/EL2 accesses to ZT0 are disabled in SMCR_EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if SMCR_EL2.EZT0 == '0' then
            <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_InaccessibleZT0" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_InaccessibleZT0</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    // Check if all accesses to ZT0 are disabled in SMCR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if SMCR_EL3.EZT0 == '0' then
            <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_InaccessibleZT0" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_InaccessibleZT0</a>, <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSVEEnabled</h3>
      <p class="pseudocode">// CheckSVEEnabled()
// =================
// Checks for traps on SVE instructions and instructions that
// access SVE System registers.

<a id="impl-aarch64.CheckSVEEnabled.0"/>CheckSVEEnabled()
    if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; (PSTATE.SM == '1' || !<a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>()) then
        <a href="shared_pseudocode.html#impl-aarch64.CheckStreamingSVEEnabled.0" title="function: CheckStreamingSVEEnabled()">CheckStreamingSVEEnabled</a>();
    else
        <a href="shared_pseudocode.html#impl-aarch64.CheckNormalSVEEnabled.0" title="function: CheckNormalSVEEnabled()">CheckNormalSVEEnabled</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckStreamingSVEAndZAEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckStreamingSVEAndZAEnabled</h3>
      <p class="pseudocode">// CheckStreamingSVEAndZAEnabled()
// ===============================

<a id="impl-aarch64.CheckStreamingSVEAndZAEnabled.0"/>CheckStreamingSVEAndZAEnabled()
    <a href="shared_pseudocode.html#impl-aarch64.CheckStreamingSVEEnabled.0" title="function: CheckStreamingSVEEnabled()">CheckStreamingSVEEnabled</a>();

    if PSTATE.ZA == '0' then
        <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_InactiveZA" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_InactiveZA</a>, PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckStreamingSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckStreamingSVEEnabled</h3>
      <p class="pseudocode">// CheckStreamingSVEEnabled()
// ==========================

<a id="impl-aarch64.CheckStreamingSVEEnabled.0"/>CheckStreamingSVEEnabled()
    <a href="shared_pseudocode.html#impl-aarch64.CheckSMEEnabled.0" title="function: CheckSMEEnabled()">CheckSMEEnabled</a>();

    if PSTATE.SM == '0' then
        <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el_in)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_NotStreaming" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_NotStreaming</a>, PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CurrentSVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CurrentSVL</h3>
      <p class="pseudocode">// CurrentSVL - non-assignment form
// ================================
// Streaming SVL

integer <a id="impl-aarch64.CurrentSVL.read.none"/>CurrentSVL
    integer vl;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) then
        vl = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SMCR_EL1.LEN);

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) then
        vl = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SMCR_EL2.LEN);
    elsif PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        vl = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(vl, <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SMCR_EL2.LEN));

    if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        vl = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SMCR_EL3.LEN);
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        vl = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(vl, <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SMCR_EL3.LEN));

    vl = (vl + 1) * 128;
    vl = <a href="shared_pseudocode.html#impl-aarch64.ImplementedSMEVectorLength.1" title="function: integer ImplementedSMEVectorLength(integer nbits_in)">ImplementedSMEVectorLength</a>(vl);

    return vl;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CurrentVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CurrentVL</h3>
      <p class="pseudocode">// CurrentVL - non-assignment form
// ===============================

integer <a id="impl-aarch64.CurrentVL.read.none"/>CurrentVL
    return if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' then <a href="shared_pseudocode.html#impl-aarch64.CurrentSVL.read.none" title="accessor: integer CurrentSVL">CurrentSVL</a> else <a href="shared_pseudocode.html#impl-aarch64.NVL.read.none" title="accessor: integer NVL">NVL</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.DecodePredCount"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/DecodePredCount</h3>
      <p class="pseudocode">// DecodePredCount()
// =================

integer <a id="impl-aarch64.DecodePredCount.2"/>DecodePredCount(bits(5) pattern, integer esize)
    integer elements = <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a> DIV esize;
    integer numElem;
    case pattern of
        when '00000' numElem = <a href="shared_pseudocode.html#impl-aarch64.FloorPow2.1" title="function: integer FloorPow2(integer x)">FloorPow2</a>(elements);
        when '00001' numElem = if elements &gt;= 1 then 1 else 0;
        when '00010' numElem = if elements &gt;= 2 then 2 else 0;
        when '00011' numElem = if elements &gt;= 3 then 3 else 0;
        when '00100' numElem = if elements &gt;= 4 then 4 else 0;
        when '00101' numElem = if elements &gt;= 5 then 5 else 0;
        when '00110' numElem = if elements &gt;= 6 then 6 else 0;
        when '00111' numElem = if elements &gt;= 7 then 7 else 0;
        when '01000' numElem = if elements &gt;= 8 then 8 else 0;
        when '01001' numElem = if elements &gt;= 16 then 16 else 0;
        when '01010' numElem = if elements &gt;= 32 then 32 else 0;
        when '01011' numElem = if elements &gt;= 64 then 64 else 0;
        when '01100' numElem = if elements &gt;= 128 then 128 else 0;
        when '01101' numElem = if elements &gt;= 256 then 256 else 0;
        when '11101' numElem = elements - (elements MOD 4);
        when '11110' numElem = elements - (elements MOD 3);
        when '11111' numElem = elements;
        otherwise    numElem = 0;
    return numElem;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ElemFFR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ElemFFR</h3>
      <p class="pseudocode">// ElemFFR[] - non-assignment form
// ===============================

bit <a id="impl-aarch64.ElemFFR.read.2"/>ElemFFR[integer e, integer esize]
    return <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[_FFR, e, esize];

// ElemFFR[] - assignment form
// ===========================

<a id="impl-aarch64.ElemFFR.write.2"/>ElemFFR[integer e, integer esize] = bit value
    integer psize = esize DIV 8;
    integer n = e * psize;
    assert n &gt;= 0 &amp;&amp; (n + psize) &lt;= <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a> DIV 8;
    _FFR&lt;n+psize-1:n&gt; = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, psize);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ElemP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ElemP</h3>
      <p class="pseudocode">// ElemP[] - non-assignment form
// =============================

bit <a id="impl-aarch64.ElemP.read.3"/>ElemP[bits(N) pred, integer e, integer esize]
    assert esize IN {8, 16, 32, 64, 128};
    integer n = e * (esize DIV 8);
    assert n &gt;= 0 &amp;&amp; n &lt; N;
    return pred&lt;n&gt;;

// ElemP[] - assignment form
// =========================

<a id="impl-aarch64.ElemP.write.3"/>ElemP[bits(N) &amp;pred, integer e, integer esize] = bit value
    assert esize IN {8, 16, 32, 64, 128};
    integer psize = esize DIV 8;
    integer n = e * psize;
    assert n &gt;= 0 &amp;&amp; (n + psize) &lt;= N;
    pred&lt;n+psize-1:n&gt; = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, psize);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FFR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FFR</h3>
      <p class="pseudocode">// FFR[] - non-assignment form
// ===========================

bits(width) <a id="impl-aarch64.FFR.read.1"/>FFR[integer width]
    assert width == <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a> DIV 8;
    return _FFR&lt;width-1:0&gt;;

// FFR[] - assignment form
// =======================

<a id="impl-aarch64.FFR.write.1"/>FFR[integer width] = bits(width) value
    assert width == <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a> DIV 8;
    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_SVEZEROUPPER</a>) then
        _FFR = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, <a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>);
    else
        _FFR&lt;width-1:0&gt; = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPCompareNE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPCompareNE</h3>
      <p class="pseudocode">// FPCompareNE()
// =============

boolean <a id="impl-aarch64.FPCompareNE.3"/>FPCompareNE(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    boolean result;
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);
    op1_nan = type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    op2_nan = type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};

    if op1_nan || op2_nan then
        result = TRUE;
        if type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 != value2);
        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPCompareUN"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPCompareUN</h3>
      <p class="pseudocode">// FPCompareUN()
// =============

boolean <a id="impl-aarch64.FPCompareUN.3"/>FPCompareUN(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    if type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    result = type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    if !result then
        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPConvertSVE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPConvertSVE</h3>
      <p class="pseudocode">// FPConvertSVE()
// ==============

bits(M) <a id="impl-aarch64.FPConvertSVE.4"/>FPConvertSVE(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, integer M)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.AHP = '0';
    return <a href="shared_pseudocode.html#impl-shared.FPConvert.4" title="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding, integer M)">FPConvert</a>(op, fpcr, rounding, M);

// FPConvertSVE()
// ==============

bits(M) <a id="impl-aarch64.FPConvertSVE.3"/>FPConvertSVE(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, integer M)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.AHP = '0';
    return <a href="shared_pseudocode.html#impl-shared.FPConvert.4" title="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding, integer M)">FPConvert</a>(op, fpcr, <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr), M);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPExpA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPExpA</h3>
      <p class="pseudocode">// FPExpA()
// ========

bits(N) <a id="impl-aarch64.FPExpA.1"/>FPExpA(bits(N) op)
    assert N IN {16,32,64};
    bits(N) result;
    bits(N) coeff;
    integer idx = if N == 16 then <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(op&lt;4:0&gt;) else <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(op&lt;5:0&gt;);
    coeff = <a href="shared_pseudocode.html#impl-aarch64.FPExpCoefficient.read.2" title="accessor: bits(N) FPExpCoefficient[integer index, integer N]">FPExpCoefficient</a>[idx, N];
    if N == 16 then
        result&lt;15:0&gt; = '0':op&lt;9:5&gt;:coeff&lt;9:0&gt;;
    elsif N == 32 then
        result&lt;31:0&gt; = '0':op&lt;13:6&gt;:coeff&lt;22:0&gt;;
    else // N == 64
        result&lt;63:0&gt; = '0':op&lt;16:6&gt;:coeff&lt;51:0&gt;;

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPExpCoefficient"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPExpCoefficient</h3>
      <p class="pseudocode">// FPExpCoefficient()
// ==================

bits(N) <a id="impl-aarch64.FPExpCoefficient.read.2"/>FPExpCoefficient[integer index, integer N]
    assert N IN {16,32,64};
    integer result;

    if N == 16 then
        case index of
            when  0 result = 0x0000;
            when  1 result = 0x0016;
            when  2 result = 0x002d;
            when  3 result = 0x0045;
            when  4 result = 0x005d;
            when  5 result = 0x0075;
            when  6 result = 0x008e;
            when  7 result = 0x00a8;
            when  8 result = 0x00c2;
            when  9 result = 0x00dc;
            when 10 result = 0x00f8;
            when 11 result = 0x0114;
            when 12 result = 0x0130;
            when 13 result = 0x014d;
            when 14 result = 0x016b;
            when 15 result = 0x0189;
            when 16 result = 0x01a8;
            when 17 result = 0x01c8;
            when 18 result = 0x01e8;
            when 19 result = 0x0209;
            when 20 result = 0x022b;
            when 21 result = 0x024e;
            when 22 result = 0x0271;
            when 23 result = 0x0295;
            when 24 result = 0x02ba;
            when 25 result = 0x02e0;
            when 26 result = 0x0306;
            when 27 result = 0x032e;
            when 28 result = 0x0356;
            when 29 result = 0x037f;
            when 30 result = 0x03a9;
            when 31 result = 0x03d4;

    elsif N == 32 then
        case index of
            when  0 result = 0x000000;
            when  1 result = 0x0164d2;
            when  2 result = 0x02cd87;
            when  3 result = 0x043a29;
            when  4 result = 0x05aac3;
            when  5 result = 0x071f62;
            when  6 result = 0x08980f;
            when  7 result = 0x0a14d5;
            when  8 result = 0x0b95c2;
            when  9 result = 0x0d1adf;
            when 10 result = 0x0ea43a;
            when 11 result = 0x1031dc;
            when 12 result = 0x11c3d3;
            when 13 result = 0x135a2b;
            when 14 result = 0x14f4f0;
            when 15 result = 0x16942d;
            when 16 result = 0x1837f0;
            when 17 result = 0x19e046;
            when 18 result = 0x1b8d3a;
            when 19 result = 0x1d3eda;
            when 20 result = 0x1ef532;
            when 21 result = 0x20b051;
            when 22 result = 0x227043;
            when 23 result = 0x243516;
            when 24 result = 0x25fed7;
            when 25 result = 0x27cd94;
            when 26 result = 0x29a15b;
            when 27 result = 0x2b7a3a;
            when 28 result = 0x2d583f;
            when 29 result = 0x2f3b79;
            when 30 result = 0x3123f6;
            when 31 result = 0x3311c4;
            when 32 result = 0x3504f3;
            when 33 result = 0x36fd92;
            when 34 result = 0x38fbaf;
            when 35 result = 0x3aff5b;
            when 36 result = 0x3d08a4;
            when 37 result = 0x3f179a;
            when 38 result = 0x412c4d;
            when 39 result = 0x4346cd;
            when 40 result = 0x45672a;
            when 41 result = 0x478d75;
            when 42 result = 0x49b9be;
            when 43 result = 0x4bec15;
            when 44 result = 0x4e248c;
            when 45 result = 0x506334;
            when 46 result = 0x52a81e;
            when 47 result = 0x54f35b;
            when 48 result = 0x5744fd;
            when 49 result = 0x599d16;
            when 50 result = 0x5bfbb8;
            when 51 result = 0x5e60f5;
            when 52 result = 0x60ccdf;
            when 53 result = 0x633f89;
            when 54 result = 0x65b907;
            when 55 result = 0x68396a;
            when 56 result = 0x6ac0c7;
            when 57 result = 0x6d4f30;
            when 58 result = 0x6fe4ba;
            when 59 result = 0x728177;
            when 60 result = 0x75257d;
            when 61 result = 0x77d0df;
            when 62 result = 0x7a83b3;
            when 63 result = 0x7d3e0c;

    else // N == 64
        case index of
            when  0 result = 0x0000000000000;
            when  1 result = 0x02C9A3E778061;
            when  2 result = 0x059B0D3158574;
            when  3 result = 0x0874518759BC8;
            when  4 result = 0x0B5586CF9890F;
            when  5 result = 0x0E3EC32D3D1A2;
            when  6 result = 0x11301D0125B51;
            when  7 result = 0x1429AAEA92DE0;
            when  8 result = 0x172B83C7D517B;
            when  9 result = 0x1A35BEB6FCB75;
            when 10 result = 0x1D4873168B9AA;
            when 11 result = 0x2063B88628CD6;
            when 12 result = 0x2387A6E756238;
            when 13 result = 0x26B4565E27CDD;
            when 14 result = 0x29E9DF51FDEE1;
            when 15 result = 0x2D285A6E4030B;
            when 16 result = 0x306FE0A31B715;
            when 17 result = 0x33C08B26416FF;
            when 18 result = 0x371A7373AA9CB;
            when 19 result = 0x3A7DB34E59FF7;
            when 20 result = 0x3DEA64C123422;
            when 21 result = 0x4160A21F72E2A;
            when 22 result = 0x44E086061892D;
            when 23 result = 0x486A2B5C13CD0;
            when 24 result = 0x4BFDAD5362A27;
            when 25 result = 0x4F9B2769D2CA7;
            when 26 result = 0x5342B569D4F82;
            when 27 result = 0x56F4736B527DA;
            when 28 result = 0x5AB07DD485429;
            when 29 result = 0x5E76F15AD2148;
            when 30 result = 0x6247EB03A5585;
            when 31 result = 0x6623882552225;
            when 32 result = 0x6A09E667F3BCD;
            when 33 result = 0x6DFB23C651A2F;
            when 34 result = 0x71F75E8EC5F74;
            when 35 result = 0x75FEB564267C9;
            when 36 result = 0x7A11473EB0187;
            when 37 result = 0x7E2F336CF4E62;
            when 38 result = 0x82589994CCE13;
            when 39 result = 0x868D99B4492ED;
            when 40 result = 0x8ACE5422AA0DB;
            when 41 result = 0x8F1AE99157736;
            when 42 result = 0x93737B0CDC5E5;
            when 43 result = 0x97D829FDE4E50;
            when 44 result = 0x9C49182A3F090;
            when 45 result = 0xA0C667B5DE565;
            when 46 result = 0xA5503B23E255D;
            when 47 result = 0xA9E6B5579FDBF;
            when 48 result = 0xAE89F995AD3AD;
            when 49 result = 0xB33A2B84F15FB;
            when 50 result = 0xB7F76F2FB5E47;
            when 51 result = 0xBCC1E904BC1D2;
            when 52 result = 0xC199BDD85529C;
            when 53 result = 0xC67F12E57D14B;
            when 54 result = 0xCB720DCEF9069;
            when 55 result = 0xD072D4A07897C;
            when 56 result = 0xD5818DCFBA487;
            when 57 result = 0xDA9E603DB3285;
            when 58 result = 0xDFC97337B9B5F;
            when 59 result = 0xE502EE78B3FF6;
            when 60 result = 0xEA4AFA2A490DA;
            when 61 result = 0xEFA1BEE615A27;
            when 62 result = 0xF50765B6E4540;
            when 63 result = 0xFA7C1819E90D8;

    return result&lt;N-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPLogB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPLogB</h3>
      <p class="pseudocode">// FPLogB()
// ========

bits(N) <a id="impl-aarch64.FPLogB.2"/>FPLogB(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    integer result;
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op, fpcr);

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        result = -(2^(N-1));            // MinInt, 100..00
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = 2^(N-1) - 1;           // MaxInt, 011..11
    else
        // FPUnpack has already scaled a subnormal input
        value = <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value);
        result = 0;
        while value &lt; 1.0 do
            value = value * 2.0;
            result = result - 1;
        while value &gt;= 2.0 do
            value = value / 2.0;
            result = result + 1;

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorm.3" title="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(fptype, N, fpcr);

    return result&lt;N-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPMinNormal"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPMinNormal</h3>
      <p class="pseudocode">// FPMinNormal()
// =============

bits(N) <a id="impl-aarch64.FPMinNormal.2"/>FPMinNormal(bit sign, integer N)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(E-1):'1';
    frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
    return sign : exp : frac;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPOne"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPOne</h3>
      <p class="pseudocode">// FPOne()
// =======

bits(N) <a id="impl-aarch64.FPOne.2"/>FPOne(bit sign, integer N)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp = '0':<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(E-1);
    frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
    return sign : exp : frac;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPPointFive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPPointFive</h3>
      <p class="pseudocode">// FPPointFive()
// =============

bits(N) <a id="impl-aarch64.FPPointFive.2"/>FPPointFive(bit sign, integer N)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp = '0':<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(E-2):'0';
    frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
    return sign : exp : frac;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPScale"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPScale</h3>
      <p class="pseudocode">// FPScale()
// =========

bits(N) <a id="impl-aarch64.FPScale.3"/>FPScale(bits (N) op, integer scale, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    bits(N) result;
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op, fpcr);

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr)">FPProcessNaN</a>(fptype, op, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, N);
    else
        result = <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, integer N)">FPRound</a>(value * (2.0^scale), fpcr, N);
        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorm.3" title="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(fptype, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPTrigMAdd"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPTrigMAdd</h3>
      <p class="pseudocode">// FPTrigMAdd()
// ============

bits(N) <a id="impl-aarch64.FPTrigMAdd.4"/>FPTrigMAdd(integer x_in, bits(N) op1, bits(N) op2_in, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    bits(N) coeff;
    bits(N) op2 = op2_in;
    integer x = x_in;
    assert x &gt;= 0;
    assert x &lt; 8;

    if op2&lt;N-1&gt; == '1' then
        x = x + 8;

    coeff    = <a href="shared_pseudocode.html#impl-aarch64.FPTrigMAddCoefficient.read.2" title="accessor: bits(N) FPTrigMAddCoefficient[integer index, integer N]">FPTrigMAddCoefficient</a>[x, N];
    op2      = <a href="shared_pseudocode.html#impl-shared.FPAbs.1" title="function: bits(N) FPAbs(bits(N) op)">FPAbs</a>(op2);
    result   = <a href="shared_pseudocode.html#impl-shared.FPMulAdd.4" title="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMulAdd</a>(coeff, op1, op2, fpcr);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPTrigMAddCoefficient"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPTrigMAddCoefficient</h3>
      <p class="pseudocode">// FPTrigMAddCoefficient()
// =======================

bits(N) <a id="impl-aarch64.FPTrigMAddCoefficient.read.2"/>FPTrigMAddCoefficient[integer index, integer N]
    assert N IN {16,32,64};
    integer result;

    if N == 16 then
        case index of
            when  0 result = 0x3c00;
            when  1 result = 0xb155;
            when  2 result = 0x2030;
            when  3 result = 0x0000;
            when  4 result = 0x0000;
            when  5 result = 0x0000;
            when  6 result = 0x0000;
            when  7 result = 0x0000;
            when  8 result = 0x3c00;
            when  9 result = 0xb800;
            when 10 result = 0x293a;
            when 11 result = 0x0000;
            when 12 result = 0x0000;
            when 13 result = 0x0000;
            when 14 result = 0x0000;
            when 15 result = 0x0000;
    elsif N == 32 then
        case index of
            when  0 result = 0x3f800000;
            when  1 result = 0xbe2aaaab;
            when  2 result = 0x3c088886;
            when  3 result = 0xb95008b9;
            when  4 result = 0x36369d6d;
            when  5 result = 0x00000000;
            when  6 result = 0x00000000;
            when  7 result = 0x00000000;
            when  8 result = 0x3f800000;
            when  9 result = 0xbf000000;
            when 10 result = 0x3d2aaaa6;
            when 11 result = 0xbab60705;
            when 12 result = 0x37cd37cc;
            when 13 result = 0x00000000;
            when 14 result = 0x00000000;
            when 15 result = 0x00000000;
    else // N == 64
        case index of
            when  0 result = 0x3ff0000000000000;
            when  1 result = 0xbfc5555555555543;
            when  2 result = 0x3f8111111110f30c;
            when  3 result = 0xbf2a01a019b92fc6;
            when  4 result = 0x3ec71de351f3d22b;
            when  5 result = 0xbe5ae5e2b60f7b91;
            when  6 result = 0x3de5d8408868552f;
            when  7 result = 0x0000000000000000;
            when  8 result = 0x3ff0000000000000;
            when  9 result = 0xbfe0000000000000;
            when 10 result = 0x3fa5555555555536;
            when 11 result = 0xbf56c16c16c13a0b;
            when 12 result = 0x3efa01a019b1e8d8;
            when 13 result = 0xbe927e4f7282f468;
            when 14 result = 0x3e21ee96d2641b13;
            when 15 result = 0xbda8f76380fbb401;

    return result&lt;N-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPTrigSMul"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPTrigSMul</h3>
      <p class="pseudocode">// FPTrigSMul()
// ============

bits(N) <a id="impl-aarch64.FPTrigSMul.3"/>FPTrigSMul(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    result = <a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</a>(op1, op1, fpcr);
    fpexc = FALSE;
    (fptype, sign, value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(result, fpcr, fpexc);

    if !(fptype IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>}) then
        result&lt;N-1&gt; = op2&lt;0&gt;;

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPTrigSSel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPTrigSSel</h3>
      <p class="pseudocode">// FPTrigSSel()
// ============

bits(N) <a id="impl-aarch64.FPTrigSSel.2"/>FPTrigSSel(bits(N) op1, bits(N) op2)
    assert N IN {16,32,64};
    bits(N) result;

    if op2&lt;0&gt; == '1' then
        result = <a href="shared_pseudocode.html#impl-aarch64.FPOne.2" title="function: bits(N) FPOne(bit sign, integer N)">FPOne</a>(op2&lt;1&gt;, N);
    elsif op2&lt;1&gt; == '1' then
        result = <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(op1);
    else
        result = op1;

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FirstActive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FirstActive</h3>
      <p class="pseudocode">// FirstActive()
// =============

bit <a id="impl-aarch64.FirstActive.3"/>FirstActive(bits(N) mask, bits(N) x, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = 0 to elements-1
        if <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[mask, e, esize] == '1' then return <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[x, e, esize];
    return '0';</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FloorPow2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FloorPow2</h3>
      <p class="pseudocode">// FloorPow2()
// ===========
// For a positive integer X, return the largest power of 2 &lt;= X

integer <a id="impl-aarch64.FloorPow2.1"/>FloorPow2(integer x)
    assert x &gt;= 0;
    integer n = 1;
    if x == 0 then return 0;
    while x &gt;= 2^n do
        n = n + 1;
    return 2^(n - 1);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSMEFullA64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSMEFullA64</h3>
      <p class="pseudocode">// HaveSMEFullA64()
// ================
// Returns TRUE if the SME FA64 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSMEFullA64.0"/>HaveSMEFullA64()
    return IsFeatureImplemented(FEAT_SME_FA64);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE</h3>
      <p class="pseudocode">// HaveSVE()
// =========

boolean <a id="impl-aarch64.HaveSVE.0"/>HaveSVE()
    return IsFeatureImplemented(FEAT_SVE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2</h3>
      <p class="pseudocode">// HaveSVE2()
// ==========
// Returns TRUE if the SVE2 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2.0"/>HaveSVE2()
    return IsFeatureImplemented(FEAT_SVE2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2AES"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2AES</h3>
      <p class="pseudocode">// HaveSVE2AES()
// =============
// Returns TRUE if the SVE2 AES extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2AES.0"/>HaveSVE2AES()
    return IsFeatureImplemented(FEAT_SVE_AES);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2BitPerm"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2BitPerm</h3>
      <p class="pseudocode">// HaveSVE2BitPerm()
// =================
// Returns TRUE if the SVE2 Bit Permissions extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2BitPerm.0"/>HaveSVE2BitPerm()
    return IsFeatureImplemented(FEAT_SVE_BitPerm);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2GF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2GF</h3>
      <p class="pseudocode">// HaveSVE2GF()
// ============
// Returns TRUE if the SVE2 GF extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2GF.0"/>HaveSVE2GF()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSVE2.0" title="function: boolean HaveSVE2()">HaveSVE2</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE2GF extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2PMULL128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2PMULL128</h3>
      <p class="pseudocode">// HaveSVE2PMULL128()
// ==================
// Returns TRUE if the SVE2 128 bit PMULL extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2PMULL128.0"/>HaveSVE2PMULL128()
    return IsFeatureImplemented(FEAT_SVE_PMULL128);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2SHA256"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2SHA256</h3>
      <p class="pseudocode">// HaveSVE2SHA256()
// ================
// Returns TRUE if the SVE2 SHA256 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2SHA256.0"/>HaveSVE2SHA256()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSVE2.0" title="function: boolean HaveSVE2()">HaveSVE2</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE2 SHA256 extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2SHA3"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2SHA3</h3>
      <p class="pseudocode">// HaveSVE2SHA3()
// ==============
// Returns TRUE if the SVE2 SHA3 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2SHA3.0"/>HaveSVE2SHA3()
    return IsFeatureImplemented(FEAT_SVE_SHA3);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2SHA512"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2SHA512</h3>
      <p class="pseudocode">// HaveSVE2SHA512()
// ================
// Returns TRUE if the SVE2 SHA512 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2SHA512.0"/>HaveSVE2SHA512()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSVE2.0" title="function: boolean HaveSVE2()">HaveSVE2</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE2 SHA512 extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2SM3"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2SM3</h3>
      <p class="pseudocode">// HaveSVE2SM3()
// =============
// Returns TRUE if the SVE2 SM3 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2SM3.0"/>HaveSVE2SM3()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSVE2.0" title="function: boolean HaveSVE2()">HaveSVE2</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE2 SM3 extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2SM4"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2SM4</h3>
      <p class="pseudocode">// HaveSVE2SM4()
// =============
// Returns TRUE if the SVE2 SM4 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2SM4.0"/>HaveSVE2SM4()
    return IsFeatureImplemented(FEAT_SVE_SM4);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2p1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2p1</h3>
      <p class="pseudocode">// HaveSVE2p1()
// ============
// Returns TRUE if the SVE2.1 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2p1.0"/>HaveSVE2p1()
    return IsFeatureImplemented(FEAT_SVE2p1);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVEB16B16"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVEB16B16</h3>
      <p class="pseudocode">// HaveSVEB16B16()
// ===============
// Returns TRUE if the SVE2.1 non-widening BFloat16 instructions are implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVEB16B16.0"/>HaveSVEB16B16()
    return IsFeatureImplemented(FEAT_B16B16);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVEFP32MatMulExt"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVEFP32MatMulExt</h3>
      <p class="pseudocode">// HaveSVEFP32MatMulExt()
// ======================
// Returns TRUE if single-precision floating-point matrix multiply instruction support implemented and FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVEFP32MatMulExt.0"/>HaveSVEFP32MatMulExt()
    return IsFeatureImplemented(FEAT_F32MM);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVEFP64MatMulExt"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVEFP64MatMulExt</h3>
      <p class="pseudocode">// HaveSVEFP64MatMulExt()
// ======================
// Returns TRUE if double-precision floating-point matrix multiply instruction support implemented and FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVEFP64MatMulExt.0"/>HaveSVEFP64MatMulExt()
    return IsFeatureImplemented(FEAT_F64MM);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ImplementedSMEVectorLength"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ImplementedSMEVectorLength</h3>
      <p class="pseudocode">// ImplementedSMEVectorLength()
// ============================
// Reduce SVE/SME vector length to a supported value (power of two)

integer <a id="impl-aarch64.ImplementedSMEVectorLength.1"/>ImplementedSMEVectorLength(integer nbits_in)
    integer maxbits = <a href="shared_pseudocode.html#impl-aarch64.MaxImplementedSVL.0" title="function: integer MaxImplementedSVL()">MaxImplementedSVL</a>();
    assert 128 &lt;= maxbits &amp;&amp; maxbits &lt;= 2048 &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsPow2.1" title="function: boolean IsPow2(integer x)">IsPow2</a>(maxbits);
    integer nbits = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(nbits_in, maxbits);
    assert 128 &lt;= nbits &amp;&amp; nbits &lt;= 2048 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(nbits, 128) == nbits;

    // Search for a supported power-of-two VL less than or equal to nbits
    while nbits &gt; 128 do
        if <a href="shared_pseudocode.html#impl-aarch64.IsPow2.1" title="function: boolean IsPow2(integer x)">IsPow2</a>(nbits) &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.SupportedPowerTwoSVL.1" title="function: boolean SupportedPowerTwoSVL(integer nbits)">SupportedPowerTwoSVL</a>(nbits) then return nbits;
        nbits = nbits - 128;

    // Return the smallest supported power-of-two VL
    nbits = 128;
    while nbits &lt; maxbits do
        if <a href="shared_pseudocode.html#impl-aarch64.SupportedPowerTwoSVL.1" title="function: boolean SupportedPowerTwoSVL(integer nbits)">SupportedPowerTwoSVL</a>(nbits) then return nbits;
        nbits = nbits * 2;

    // The only option is maxbits
    return maxbits;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ImplementedSVEVectorLength"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ImplementedSVEVectorLength</h3>
      <p class="pseudocode">// ImplementedSVEVectorLength()
// ============================
// Reduce SVE vector length to a supported value (power of two)

integer <a id="impl-aarch64.ImplementedSVEVectorLength.1"/>ImplementedSVEVectorLength(integer nbits_in)
    integer maxbits = <a href="shared_pseudocode.html#impl-aarch64.MaxImplementedVL.0" title="function: integer MaxImplementedVL()">MaxImplementedVL</a>();
    assert 128 &lt;= maxbits &amp;&amp; maxbits &lt;= 2048 &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsPow2.1" title="function: boolean IsPow2(integer x)">IsPow2</a>(maxbits);
    integer nbits = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(nbits_in, maxbits);
    assert 128 &lt;= nbits &amp;&amp; nbits &lt;= 2048 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(nbits, 128) == nbits;

    while nbits &gt; 128 do
        if <a href="shared_pseudocode.html#impl-aarch64.IsPow2.1" title="function: boolean IsPow2(integer x)">IsPow2</a>(nbits) then return nbits;
        nbits = nbits - 128;
    return nbits;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.InStreamingMode"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/InStreamingMode</h3>
      <p class="pseudocode">// InStreamingMode()
// =================

boolean <a id="impl-aarch64.InStreamingMode.0"/>InStreamingMode()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsEven"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsEven</h3>
      <p class="pseudocode">// IsEven()
// ========

boolean <a id="impl-aarch64.IsEven.1"/>IsEven(integer val)
    return val MOD 2 == 0;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsFPEnabled</h3>
      <p class="pseudocode">// IsFPEnabled()
// =============
// Returns TRUE if accesses to the Advanced SIMD and floating-point
// registers are enabled at the target exception level in the current
// execution state and FALSE otherwise.

boolean <a id="impl-aarch64.IsFPEnabled.1"/>IsFPEnabled(bits(2) el)
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el) then
        return <a href="shared_pseudocode.html#AArch32.IsFPEnabled.1" title="function: boolean AArch32.IsFPEnabled(bits(2) el)">AArch32.IsFPEnabled</a>(el);
    else
        return <a href="shared_pseudocode.html#AArch64.IsFPEnabled.1" title="function: boolean AArch64.IsFPEnabled(bits(2) el)">AArch64.IsFPEnabled</a>(el);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsFullA64Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsFullA64Enabled</h3>
      <p class="pseudocode">// IsFullA64Enabled()
// ==================
// Returns TRUE is full A64 is enabled in Streaming mode and FALSE othersise.

boolean <a id="impl-aarch64.IsFullA64Enabled.0"/>IsFullA64Enabled()
    if !<a href="shared_pseudocode.html#impl-aarch64.HaveSMEFullA64.0" title="function: boolean HaveSMEFullA64()">HaveSMEFullA64</a>() then return FALSE;

    // Check if full SVE disabled in SMCR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check full SVE at EL0/EL1
        if SMCR_EL1.FA64 == '0' then return FALSE;

    // Check if full SVE disabled in SMCR_EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if SMCR_EL2.FA64 == '0' then return FALSE;

    // Check if full SVE disabled in SMCR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if SMCR_EL3.FA64 == '0' then return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsNormalSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsNormalSVEEnabled</h3>
      <p class="pseudocode">// IsNormalSVEEnabled()
// ====================
// Returns TRUE if access to normal SVE is enabled at the target
// exception level and FALSE otherwise.

boolean <a id="impl-aarch64.IsNormalSVEEnabled.1"/>IsNormalSVEEnabled(bits(2) el)
    boolean disabled;
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el) then
        return FALSE;

    // Check if access disabled in CPACR_EL1
    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check SVE at EL0/EL1
        case CPACR_EL1.ZEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then return FALSE;

    // Check if access disabled in CPTR_EL2
    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            case CPTR_EL2.ZEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then return FALSE;
        else
            if CPTR_EL2.TZ == '1' then return FALSE;

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CPTR_EL3.EZ == '0' then return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsOdd"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsOdd</h3>
      <p class="pseudocode">// IsOdd()
// =======

boolean <a id="impl-aarch64.IsOdd.1"/>IsOdd(integer val)
    return val MOD 2 == 1;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsPow2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsPow2</h3>
      <p class="pseudocode">// IsPow2()
// ========
// Return TRUE if positive integer X is a power of 2. Otherwise,
// return FALSE.

boolean <a id="impl-aarch64.IsPow2.1"/>IsPow2(integer x)
    if x &lt;= 0 then return FALSE;
    return <a href="shared_pseudocode.html#impl-aarch64.FloorPow2.1" title="function: integer FloorPow2(integer x)">FloorPow2</a>(x) == <a href="shared_pseudocode.html#impl-aarch64.CeilPow2.1" title="function: integer CeilPow2(integer x)">CeilPow2</a>(x);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsSVEEnabled</h3>
      <p class="pseudocode">// IsSVEEnabled()
// ==============
// Returns TRUE if access to SVE instructions and System registers is
// enabled at the target exception level and FALSE otherwise.

boolean <a id="impl-aarch64.IsSVEEnabled.1"/>IsSVEEnabled(bits(2) el)
    if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' then
        return <a href="shared_pseudocode.html#impl-aarch64.IsStreamingSVEEnabled.1" title="function: boolean IsStreamingSVEEnabled(bits(2) el)">IsStreamingSVEEnabled</a>(el);
    elsif <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() then
        return <a href="shared_pseudocode.html#impl-aarch64.IsNormalSVEEnabled.1" title="function: boolean IsNormalSVEEnabled(bits(2) el)">IsNormalSVEEnabled</a>(el);
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsStreamingSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsStreamingSVEEnabled</h3>
      <p class="pseudocode">// IsStreamingSVEEnabled()
// =======================
// Returns TRUE if access to streaming SVE is enabled at the
// target exception level and FALSE otherwise.

boolean <a id="impl-aarch64.IsStreamingSVEEnabled.1"/>IsStreamingSVEEnabled(bits(2) el)
    boolean disabled;
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el) then
        return FALSE;

    // Check if access disabled in CPACR_EL1
    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check SME at EL0/EL1
        case CPACR_EL1.SMEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then return FALSE;

    // Check if access disabled in CPTR_EL2
    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            case CPTR_EL2.SMEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then return FALSE;
        else
            if CPTR_EL2.TSM == '1' then return FALSE;

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CPTR_EL3.ESM == '0' then return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.LastActive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/LastActive</h3>
      <p class="pseudocode">// LastActive()
// ============

bit <a id="impl-aarch64.LastActive.3"/>LastActive(bits(N) mask, bits(N) x, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = elements-1 downto 0
        if <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[mask, e, esize] == '1' then return <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[x, e, esize];
    return '0';</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.LastActiveElement"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/LastActiveElement</h3>
      <p class="pseudocode">// LastActiveElement()
// ===================

integer <a id="impl-aarch64.LastActiveElement.2"/>LastActiveElement(bits(N) mask, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = elements-1 downto 0
        if <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[mask, e, esize] == '1' then return e;
    return -1;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MaxImplementedSVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MaxImplementedSVL</h3>
      <p class="pseudocode">// MaxImplementedSVL()
// ===================

integer <a id="impl-aarch64.MaxImplementedSVL.0"/>MaxImplementedSVL()
    return integer IMPLEMENTATION_DEFINED "Max implemented SVL";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MaxImplementedVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MaxImplementedVL</h3>
      <p class="pseudocode">// MaxImplementedVL()
// ==================

integer <a id="impl-aarch64.MaxImplementedVL.0"/>MaxImplementedVL()
    return integer IMPLEMENTATION_DEFINED "Max implemented VL";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MaybeZeroSVEUppers"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MaybeZeroSVEUppers</h3>
      <p class="pseudocode">// MaybeZeroSVEUppers()
// ====================

<a id="impl-aarch64.MaybeZeroSVEUppers.1"/>MaybeZeroSVEUppers(bits(2) target_el)
    boolean lower_enabled;

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) || !<a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)">IsSVEEnabled</a>(target_el) then
        return;

    if target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
            lower_enabled = <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        else
            lower_enabled = <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    elsif target_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        assert !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        if HCR_EL2.TGE == '0' then
            lower_enabled = <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
        else
            lower_enabled = <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>);
    else
        assert target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
        lower_enabled = <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>);

    if lower_enabled then
        integer vl = if <a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)">IsSVEEnabled</a>(PSTATE.EL) then <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a> else 128;
        integer pl = vl DIV 8;
        for n = 0 to 31
            if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_SVEZEROUPPER</a>) then
                _Z[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(_Z[n]&lt;vl-1:0&gt;, <a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>);
        for n = 0 to 15
            if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_SVEZEROUPPER</a>) then
                _P[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(_P[n]&lt;pl-1:0&gt;, <a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>);
        if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_SVEZEROUPPER</a>) then
            _FFR = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(_FFR&lt;pl-1:0&gt;, <a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>);
        if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.ZA == '1' then
            constant integer accessiblevecs = <a href="shared_pseudocode.html#impl-aarch64.CurrentSVL.read.none" title="accessor: integer CurrentSVL">CurrentSVL</a> DIV 8;
            constant integer allvecs = <a href="shared_pseudocode.html#impl-aarch64.MaxImplementedSVL.0" title="function: integer MaxImplementedSVL()">MaxImplementedSVL</a>() DIV 8;
            constant integer SVL = <a href="shared_pseudocode.html#impl-aarch64.CurrentSVL.read.none" title="accessor: integer CurrentSVL">CurrentSVL</a>;

            for n = 0 to accessiblevecs - 1
                if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SMEZEROUPPER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_SMEZEROUPPER</a>) then
                    _ZA[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(_ZA[n]&lt;SVL-1:0&gt;, <a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>);
            for n = accessiblevecs to allvecs - 1
                if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SMEZEROUPPER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_SMEZEROUPPER</a>) then
                    _ZA[n] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(<a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MemNF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MemNF</h3>
      <p class="pseudocode">// MemNF[] - non-assignment form
// =============================

(bits(8*size), boolean) <a id="impl-aarch64.MemNF.read.3"/>MemNF[bits(64) address, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc]
    assert size IN {1, 2, 4, 8, 16};
    bits(8*size) value;
    boolean bad;

    boolean aligned = <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(address, size);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#impl-shared.AlignmentEnforced.0" title="function: boolean AlignmentEnforced()">AlignmentEnforced</a>() then
        return (bits(8*size) UNKNOWN, TRUE);

    boolean atomic = aligned || size == 1;

    if !atomic then
        (value&lt;7:0&gt;, bad) = <a href="shared_pseudocode.html#impl-aarch64.MemSingleNF.read.4" title="accessor: (bits(8*size), boolean) MemSingleNF[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned]">MemSingleNF</a>[address, 1, accdesc, aligned];

        if bad then
            return (bits(8*size) UNKNOWN, TRUE);

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        if !aligned then
            c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_DEVPAGE2</a>);
            assert c IN {<a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
            if c == <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

        for i = 1 to size-1
            (value&lt;8*i+7:8*i&gt;, bad) = <a href="shared_pseudocode.html#impl-aarch64.MemSingleNF.read.4" title="accessor: (bits(8*size), boolean) MemSingleNF[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned]">MemSingleNF</a>[address+i, 1, accdesc, aligned];

            if bad then
                return (bits(8*size) UNKNOWN, TRUE);
    else
        (value, bad) = <a href="shared_pseudocode.html#impl-aarch64.MemSingleNF.read.4" title="accessor: (bits(8*size), boolean) MemSingleNF[bits(64) address, integer size, AccessDescriptor accdesc_in,&#13; boolean aligned]">MemSingleNF</a>[address, size, accdesc, aligned];
        if bad then
            return (bits(8*size) UNKNOWN, TRUE);

    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccessType acctype)">BigEndian</a>(accdesc.acctype) then
        value = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    return (value, FALSE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MemSingleNF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MemSingleNF</h3>
      <p class="pseudocode">// MemSingleNF[] - non-assignment form
// ===================================

(bits(8*size), boolean) <a id="impl-aarch64.MemSingleNF.read.4"/>MemSingleNF[bits(64) address, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in,
                                    boolean aligned]
    assert accdesc_in.acctype == <a href="shared_pseudocode.html#AccessType_SVE" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_SVE</a>;
    assert accdesc_in.nonfault || (accdesc_in.firstfault &amp;&amp; !accdesc_in.first);

    bits(8*size) value;
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = accdesc_in;
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.NoFault.1" title="function: FaultRecord NoFault(AccessDescriptor accdesc)">NoFault</a>(accdesc);

    // Implementation may suppress NF load for any reason
    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_NONFAULT" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_NONFAULT</a>) then
        return (bits(8*size) UNKNOWN, TRUE);

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccessDescriptor accdesc)">AArch64.AccessIsTagChecked</a>(address, accdesc);

    // MMU or MPU
    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, accdesc, aligned, size);

    // Non-fault load from Device memory must not be performed externally
    if memaddrdesc.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return (bits(8*size) UNKNOWN, TRUE);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        return (bits(8*size) UNKNOWN, TRUE);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; accdesc.tagchecked then
        bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
        if !<a href="shared_pseudocode.html#AArch64.CheckTag.3" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag) then
            return (bits(8*size) UNKNOWN, TRUE);

    (memstatus, value) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size, accdesc);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        boolean iswrite = FALSE;
        if <a href="shared_pseudocode.html#impl-shared.IsExternalAbortTakenSynchronously.5" title="function: boolean IsExternalAbortTakenSynchronously(PhysMemRetStatus memstatus,&#13; boolean iswrite,&#13; AddressDescriptor desc,&#13; integer size,&#13; AccessDescriptor accdesc)">IsExternalAbortTakenSynchronously</a>(memstatus, iswrite, memaddrdesc, size, accdesc) then
            return (bits(8*size) UNKNOWN, TRUE);
        fault.merrorstate = memstatus.merrorstate;
        fault.extflag    = memstatus.extflag;
        fault.statuscode = memstatus.statuscode;
        <a href="shared_pseudocode.html#impl-shared.PendSErrorInterrupt.1" title="function: PendSErrorInterrupt(FaultRecord fault)">PendSErrorInterrupt</a>(fault);

    return (value, FALSE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.NVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/NVL</h3>
      <p class="pseudocode">// NVL - non-assignment form
// =========================
// Normal VL

integer <a id="impl-aarch64.NVL.read.none"/>NVL
    integer vl;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) then
        vl = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ZCR_EL1.LEN);

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) then
        vl = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ZCR_EL2.LEN);
    elsif PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        vl = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(vl, <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ZCR_EL2.LEN));

    if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        vl = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ZCR_EL3.LEN);
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        vl = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(vl, <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ZCR_EL3.LEN));

    vl = (vl + 1) * 128;
    vl = <a href="shared_pseudocode.html#impl-aarch64.ImplementedSVEVectorLength.1" title="function: integer ImplementedSVEVectorLength(integer nbits_in)">ImplementedSVEVectorLength</a>(vl);

    return vl;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.NoneActive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/NoneActive</h3>
      <p class="pseudocode">// NoneActive()
// ============

bit <a id="impl-aarch64.NoneActive.3"/>NoneActive(bits(N) mask, bits(N) x, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = 0 to elements-1
        if <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[mask, e, esize] == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[x, e, esize] == '1' then return '0';
    return '1';</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.P"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/P</h3>
      <p class="pseudocode">// P[] - non-assignment form
// =========================

bits(width) <a id="impl-aarch64.P.read.2"/>P[integer n, integer width]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width == <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a> DIV 8;
    return _P[n]&lt;width-1:0&gt;;

// P[] - assignment form
// =====================

<a id="impl-aarch64.P.write.2"/>P[integer n, integer width] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width == <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a> DIV 8;
    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_SVEZEROUPPER</a>) then
        _P[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, <a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>);
    else
        _P[n]&lt;width-1:0&gt; = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.PredTest"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/PredTest</h3>
      <p class="pseudocode">// PredTest()
// ==========

bits(4) <a id="impl-aarch64.PredTest.3"/>PredTest(bits(N) mask, bits(N) result, integer esize)
    bit n = <a href="shared_pseudocode.html#impl-aarch64.FirstActive.3" title="function: bit FirstActive(bits(N) mask, bits(N) x, integer esize)">FirstActive</a>(mask, result, esize);
    bit z = <a href="shared_pseudocode.html#impl-aarch64.NoneActive.3" title="function: bit NoneActive(bits(N) mask, bits(N) x, integer esize)">NoneActive</a>(mask, result, esize);
    bit c = NOT <a href="shared_pseudocode.html#impl-aarch64.LastActive.3" title="function: bit LastActive(bits(N) mask, bits(N) x, integer esize)">LastActive</a>(mask, result, esize);
    bit v = '0';
    return n:z:c:v;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ReducePredicated"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ReducePredicated</h3>
      <p class="pseudocode">// ReducePredicated()
// ==================

bits(esize) <a id="impl-aarch64.ReducePredicated.4"/>ReducePredicated(<a href="shared_pseudocode.html#ReduceOp" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp</a> op, bits(N) input, bits(M) mask, bits(esize) identity)
    assert(N == M * 8);
    integer p2bits = <a href="shared_pseudocode.html#impl-aarch64.CeilPow2.1" title="function: integer CeilPow2(integer x)">CeilPow2</a>(N);
    bits(p2bits) operand;
    integer elements = p2bits DIV esize;

    for e = 0 to elements-1
        if e * esize &lt; N &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[mask, e, esize] == '1' then
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[operand, e, esize] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[input, e, esize];
        else
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[operand, e, esize] = identity;

    return <a href="shared_pseudocode.html#impl-aarch64.Reduce.3" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize)">Reduce</a>(op, operand, esize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ResetSMEState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ResetSMEState</h3>
      <p class="pseudocode">// ResetSMEState()
// ===============

<a id="impl-aarch64.ResetSMEState.0"/>ResetSMEState()
    integer vectors = <a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a> DIV 8;
    for n = 0 to vectors - 1
        _ZA[n] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(<a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>);
    _ZT0 = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(<a href="shared_pseudocode.html#ZT0_LEN" title="constant integer ZT0_LEN = 512">ZT0_LEN</a>);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ResetSVEState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ResetSVEState</h3>
      <p class="pseudocode">// ResetSVEState()
// ===============

<a id="impl-aarch64.ResetSVEState.0"/>ResetSVEState()
    for n = 0 to 31
        _Z[n] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(<a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>);
    for n = 0 to 15
        _P[n] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(<a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>);
    _FFR = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(<a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>);
    FPSR = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(0x0800009f&lt;31:0&gt;, 64);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.Reverse"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/Reverse</h3>
      <p class="pseudocode">// Reverse()
// =========
// Reverse subwords of M bits in an N-bit word

bits(N) <a id="impl-aarch64.Reverse.2"/>Reverse(bits(N) word, integer M)
    bits(N) result;
    integer sw = N DIV M;
    assert N == sw * M;
    for s = 0 to sw-1
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, (sw - 1) - s, M] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[word, s, M];
    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SMEAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SMEAccessTrap</h3>
      <p class="pseudocode">// SMEAccessTrap()
// ===============
// Trapped access to SME registers due to CPACR_EL1, CPTR_EL2, or CPTR_EL3.

<a id="impl-aarch64.SMEAccessTrap.2"/>SMEAccessTrap(<a href="shared_pseudocode.html#SMEExceptionType" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType</a> etype, bits(2) target_el_in)
    bits(2) target_el = target_el_in;
    assert <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);
    if target_el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    boolean route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SMEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SMEAccessTrap</a>);
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    case etype of
        when <a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_AccessTrap</a>
            exception.syndrome&lt;2:0&gt; = '000';
        when <a href="shared_pseudocode.html#SMEExceptionType_Streaming" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_Streaming</a>
            exception.syndrome&lt;2:0&gt; = '001';
        when <a href="shared_pseudocode.html#SMEExceptionType_NotStreaming" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_NotStreaming</a>
            exception.syndrome&lt;2:0&gt; = '010';
        when <a href="shared_pseudocode.html#SMEExceptionType_InactiveZA" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_InactiveZA</a>
            exception.syndrome&lt;2:0&gt; = '011';
        when <a href="shared_pseudocode.html#SMEExceptionType_InaccessibleZT0" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, SMEExceptionType_InaccessibleZT0, }">SMEExceptionType_InaccessibleZT0</a>
            exception.syndrome&lt;2:0&gt; = '100';

    if route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SMEExceptionType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SMEExceptionType</h3>
      <p class="pseudocode">enumeration <a id="SMEExceptionType"/>SMEExceptionType {
    <a id="SMEExceptionType_AccessTrap"/>SMEExceptionType_AccessTrap,        // SME functionality trapped or disabled
    <a id="SMEExceptionType_Streaming"/>SMEExceptionType_Streaming,         // Illegal instruction in Streaming SVE mode
    <a id="SMEExceptionType_NotStreaming"/>SMEExceptionType_NotStreaming,      // Illegal instruction not in Streaming SVE mode
    <a id="SMEExceptionType_InactiveZA"/>SMEExceptionType_InactiveZA,        // Illegal instruction when ZA is inactive
    <a id="SMEExceptionType_InaccessibleZT0"/>SMEExceptionType_InaccessibleZT0,   // Access to ZT0 is disabled
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SVEAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SVEAccessTrap</h3>
      <p class="pseudocode">// SVEAccessTrap()
// ===============
// Trapped access to SVE registers due to CPACR_EL1, CPTR_EL2, or CPTR_EL3.

<a id="impl-aarch64.SVEAccessTrap.1"/>SVEAccessTrap(bits(2) target_el)
    assert <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &amp;&amp; target_el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el);
    route_to_el2 = target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SVEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SVEAccessTrap</a>);
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    if route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SVECmp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SVECmp</h3>
      <p class="pseudocode">enumeration <a id="SVECmp"/>SVECmp { <a id="Cmp_EQ"/>Cmp_EQ, <a id="Cmp_NE"/>Cmp_NE, <a id="Cmp_GE"/>Cmp_GE, <a id="Cmp_GT"/>Cmp_GT, <a id="Cmp_LT"/>Cmp_LT, <a id="Cmp_LE"/>Cmp_LE, <a id="Cmp_UN"/>Cmp_UN };</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SVEMoveMaskPreferred"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SVEMoveMaskPreferred</h3>
      <p class="pseudocode">// SVEMoveMaskPreferred()
// ======================
// Return FALSE if a bitmask immediate encoding would generate an immediate
// value that could also be represented by a single DUP instruction.
// Used as a condition for the preferred MOV&lt;-DUPM alias.

boolean <a id="impl-aarch64.SVEMoveMaskPreferred.1"/>SVEMoveMaskPreferred(bits(13) imm13)
    bits(64) imm;
    (imm, -) = <a href="shared_pseudocode.html#impl-aarch64.DecodeBitMasks.5" title="function: (bits(M), bits(M)) DecodeBitMasks(bit immN, bits(6) imms, bits(6) immr,&#13; boolean immediate, integer M)">DecodeBitMasks</a>(imm13&lt;12&gt;, imm13&lt;5:0&gt;, imm13&lt;11:6&gt;, TRUE, 64);

    // Check for 8 bit immediates
    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(imm&lt;7:0&gt;) then
        // Check for 'ffffffffffffffxy' or '00000000000000xy'
        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(imm&lt;63:7&gt;) || <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(imm&lt;63:7&gt;) then
            return FALSE;

        // Check for 'ffffffxyffffffxy' or '000000xy000000xy'
        if imm&lt;63:32&gt; == imm&lt;31:0&gt; &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(imm&lt;31:7&gt;) || <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(imm&lt;31:7&gt;)) then
            return FALSE;

        // Check for 'ffxyffxyffxyffxy' or '00xy00xy00xy00xy'
        if imm&lt;63:32&gt; == imm&lt;31:0&gt; &amp;&amp; imm&lt;31:16&gt; == imm&lt;15:0&gt; &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(imm&lt;15:7&gt;) || <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(imm&lt;15:7&gt;)) then
            return FALSE;

        // Check for 'xyxyxyxyxyxyxyxy'
        if imm&lt;63:32&gt; == imm&lt;31:0&gt; &amp;&amp; imm&lt;31:16&gt; == imm&lt;15:0&gt; &amp;&amp; (imm&lt;15:8&gt; == imm&lt;7:0&gt;) then
            return FALSE;

    // Check for 16 bit immediates
    else
        // Check for 'ffffffffffffxy00' or '000000000000xy00'
        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(imm&lt;63:15&gt;) || <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(imm&lt;63:15&gt;) then
            return FALSE;

        // Check for 'ffffxy00ffffxy00' or '0000xy000000xy00'
        if imm&lt;63:32&gt; == imm&lt;31:0&gt; &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(imm&lt;31:7&gt;) || <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(imm&lt;31:7&gt;)) then
            return FALSE;

        // Check for 'xy00xy00xy00xy00'
        if imm&lt;63:32&gt; == imm&lt;31:0&gt; &amp;&amp; imm&lt;31:16&gt; == imm&lt;15:0&gt; then
            return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SetPSTATE_SM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SetPSTATE_SM</h3>
      <p class="pseudocode">// SetPSTATE_SM()
// ==============

<a id="impl-aarch64.SetPSTATE_SM.1"/>SetPSTATE_SM(bit value)
    if PSTATE.SM != value then
        <a href="shared_pseudocode.html#impl-aarch64.ResetSVEState.0" title="function: ResetSVEState()">ResetSVEState</a>();
        PSTATE.SM = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SetPSTATE_SVCR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SetPSTATE_SVCR</h3>
      <p class="pseudocode">// SetPSTATE_SVCR
// ==============

<a id="impl-aarch64.SetPSTATE_SVCR.1"/>SetPSTATE_SVCR(bits(32) svcr)
    <a href="shared_pseudocode.html#impl-aarch64.SetPSTATE_SM.1" title="function: SetPSTATE_SM(bit value)">SetPSTATE_SM</a>(svcr&lt;0&gt;);
    <a href="shared_pseudocode.html#impl-aarch64.SetPSTATE_ZA.1" title="function: SetPSTATE_ZA(bit value)">SetPSTATE_ZA</a>(svcr&lt;1&gt;);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SetPSTATE_ZA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SetPSTATE_ZA</h3>
      <p class="pseudocode">// SetPSTATE_ZA()
// ==============

<a id="impl-aarch64.SetPSTATE_ZA.1"/>SetPSTATE_ZA(bit value)
    if PSTATE.ZA != value then
        <a href="shared_pseudocode.html#impl-aarch64.ResetSMEState.0" title="function: ResetSMEState()">ResetSMEState</a>();
        PSTATE.ZA = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ShiftSat"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ShiftSat</h3>
      <p class="pseudocode">// ShiftSat()
// ==========

integer <a id="impl-aarch64.ShiftSat.2"/>ShiftSat(integer shift, integer esize)
    if shift &gt; esize+1 then return esize+1;
    elsif shift &lt; -(esize+1) then return -(esize+1);
    return shift;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SupportedPowerTwoSVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SupportedPowerTwoSVL</h3>
      <p class="pseudocode">// Return an IMPLEMENTATION DEFINED specific value
// returns TRUE if SVL is supported and is a power of two, FALSE otherwise
boolean <a id="impl-aarch64.SupportedPowerTwoSVL.1"/>SupportedPowerTwoSVL(integer nbits);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.System"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/System</h3>
      <p class="pseudocode">constant integer <a id="MAX_VL"/>MAX_VL = 2048;
constant integer <a id="MAX_PL"/>MAX_PL = 256;
constant integer <a id="ZT0_LEN"/>ZT0_LEN =  512;
array bits(<a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>) _Z[0..31];
array bits(<a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>) _P[0..15];
bits(<a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>) _FFR;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.Z"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/Z</h3>
      <p class="pseudocode">// Z[] - non-assignment form
// =========================

bits(width) <a id="impl-aarch64.Z.read.2"/>Z[integer n, integer width]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width == <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a>;
    return _Z[n]&lt;width-1:0&gt;;

// Z[] - assignment form
// =====================

<a id="impl-aarch64.Z.write.2"/>Z[integer n, integer width] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width == <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a>;
    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_SVEZEROUPPER</a>) then
        _Z[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, <a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>);
    else
        _Z[n]&lt;width-1:0&gt; = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.CNTKCTL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/CNTKCTL</h3>
      <p class="pseudocode">// CNTKCTL[] - non-assignment form
// ===============================

CNTKCTLType <a id="impl-aarch64.CNTKCTL.read.0"/>CNTKCTL[]
    bits(64) r;
    if <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        r = CNTHCTL_EL2;
        return r;
    r = CNTKCTL_EL1;
    return r;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.CNTKCTLType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/CNTKCTLType</h3>
      <p class="pseudocode">type <a id="CNTKCTLType"/>CNTKCTLType;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.CPACR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/CPACR</h3>
      <p class="pseudocode">// CPACR[] - non-assignment form
// =============================

CPACRType <a id="impl-aarch64.CPACR.read.0"/>CPACR[]
    bits(64) r;
    if <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        r = CPTR_EL2;
        return r;
    r = CPACR_EL1;
    return r;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.CPACRType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/CPACRType</h3>
      <p class="pseudocode">type <a id="CPACRType"/>CPACRType;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.ELR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/ELR</h3>
      <p class="pseudocode">// ELR[] - non-assignment form
// ===========================

bits(64) <a id="impl-aarch64.ELR.read.1"/>ELR[bits(2) el]
    bits(64) r;
    case el of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  r = ELR_EL1;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  r = ELR_EL2;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  r = ELR_EL3;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return r;

// ELR[] - non-assignment form
// ===========================

bits(64) <a id="impl-aarch64.ELR.read.0"/>ELR[]
    assert PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    return <a href="shared_pseudocode.html#impl-aarch64.ELR.read.1" title="accessor: bits(64) ELR[bits(2) el]">ELR</a>[PSTATE.EL];

// ELR[] - assignment form
// =======================

<a id="impl-aarch64.ELR.write.1"/>ELR[bits(2) el] = bits(64) value
    bits(64) r = value;
    case el of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  ELR_EL1 = r;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  ELR_EL2 = r;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  ELR_EL3 = r;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return;

// ELR[] - assignment form
// =======================

<a id="impl-aarch64.ELR.write.0"/>ELR[] = bits(64) value
    assert PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    <a href="shared_pseudocode.html#impl-aarch64.ELR.write.1" title="accessor: ELR[bits(2) el] = bits(64) value">ELR</a>[PSTATE.EL] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.ESR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/ESR</h3>
      <p class="pseudocode">// ESR[] - non-assignment form
// ===========================

ESRType <a id="impl-aarch64.ESR.read.1"/>ESR[bits(2) regime]
    bits(64) r;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  r = ESR_EL1;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  r = ESR_EL2;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  r = ESR_EL3;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return r;

// ESR[] - non-assignment form
// ===========================

ESRType <a id="impl-aarch64.ESR.read.0"/>ESR[]
    return <a href="shared_pseudocode.html#impl-aarch64.ESR.read.1" title="accessor: ESRType ESR[bits(2) regime]">ESR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];

// ESR[] - assignment form
// =======================

<a id="impl-aarch64.ESR.write.1"/>ESR[bits(2) regime] = <a href="shared_pseudocode.html#ESRType" title="type ESRType">ESRType</a> value
    bits(64) r = value;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  ESR_EL1 = r;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  ESR_EL2 = r;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  ESR_EL3 = r;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return;

// ESR[] - assignment form
// =======================

<a id="impl-aarch64.ESR.write.0"/>ESR[] = <a href="shared_pseudocode.html#ESRType" title="type ESRType">ESRType</a> value
    <a href="shared_pseudocode.html#impl-aarch64.ESR.write.1" title="accessor: ESR[bits(2) regime] = ESRType value">ESR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()] = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.ESRType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/ESRType</h3>
      <p class="pseudocode">type <a id="ESRType"/>ESRType;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.FAR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/FAR</h3>
      <p class="pseudocode">// FAR[] - non-assignment form
// ===========================

bits(64) <a id="impl-aarch64.FAR.read.1"/>FAR[bits(2) regime]
    bits(64) r;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  r = FAR_EL1;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  r = FAR_EL2;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  r = FAR_EL3;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return r;

// FAR[] - non-assignment form
// ===========================

bits(64) <a id="impl-aarch64.FAR.read.0"/>FAR[]
    return <a href="shared_pseudocode.html#impl-aarch64.FAR.read.1" title="accessor: bits(64) FAR[bits(2) regime]">FAR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];

// FAR[] - assignment form
// =======================

<a id="impl-aarch64.FAR.write.1"/>FAR[bits(2) regime] = bits(64) value
    bits(64) r = value;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  FAR_EL1 = r;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  FAR_EL2 = r;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  FAR_EL3 = r;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return;

// FAR[] - assignment form
// =======================

<a id="impl-aarch64.FAR.write.0"/>FAR[] = bits(64) value
    <a href="shared_pseudocode.html#impl-aarch64.FAR.write.1" title="accessor: FAR[bits(2) regime] = bits(64) value">FAR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.SCTLR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/SCTLR</h3>
      <p class="pseudocode">// SCTLR[] - non-assignment form
// =============================

SCTLRType <a id="impl-aarch64.SCTLR.read.1"/>SCTLR[bits(2) regime]
    bits(64) r;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  r = SCTLR_EL1;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  r = SCTLR_EL2;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  r = SCTLR_EL3;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return r;

// SCTLR[] - non-assignment form
// =============================

SCTLRType <a id="impl-aarch64.SCTLR.read.0"/>SCTLR[]
    return <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.1" title="accessor: SCTLRType SCTLR[bits(2) regime]">SCTLR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.SCTLRType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/SCTLRType</h3>
      <p class="pseudocode">type <a id="SCTLRType"/>SCTLRType;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.VBAR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/VBAR</h3>
      <p class="pseudocode">// VBAR[] - non-assignment form
// ============================

bits(64) <a id="impl-aarch64.VBAR.read.1"/>VBAR[bits(2) regime]
    bits(64) r;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  r = VBAR_EL1;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  r = VBAR_EL2;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  r = VBAR_EL3;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return r;

// VBAR[] - non-assignment form
// ============================

bits(64) <a id="impl-aarch64.VBAR.read.0"/>VBAR[]
    return <a href="shared_pseudocode.html#impl-aarch64.VBAR.read.1" title="accessor: bits(64) VBAR[bits(2) regime]">VBAR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.AllocationTagAccessIsEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.AllocationTagAccessIsEnabled</h3>
      <p class="pseudocode">// AArch64.AllocationTagAccessIsEnabled()
// ======================================
// Check whether access to Allocation Tags is enabled.

boolean <a id="AArch64.AllocationTagAccessIsEnabled.1"/>AArch64.AllocationTagAccessIsEnabled(bits(2) el)
    if SCR_EL3.ATA == '0' &amp;&amp; el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} then
        return FALSE;
    if HCR_EL2.ATA == '0' &amp;&amp; el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; != '11' then
        return FALSE;

    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.1" title="function: Regime TranslationRegime(bits(2) el)">TranslationRegime</a>(el);
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return SCTLR_EL3.ATA == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return SCTLR_EL2.ATA == '1';
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return if el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then SCTLR_EL2.ATA0 == '1' else SCTLR_EL2.ATA == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return if el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then SCTLR_EL1.ATA0 == '1' else SCTLR_EL1.ATA == '1';
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.CheckSystemAccess"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.CheckSystemAccess</h3>
      <p class="pseudocode">// AArch64.CheckSystemAccess()
// ===========================

<a id="AArch64.CheckSystemAccess.7"/>AArch64.CheckSystemAccess(bits(2) op0, bits(3) op1, bits(4) crn,
                          bits(4) crm, bits(3) op2, bits(5) rt, bit read)
    if (TSTATE.depth &gt; 0 &amp;&amp;
          !<a href="shared_pseudocode.html#impl-aarch64.CheckTransactionalSystemAccess.6" title="function: boolean CheckTransactionalSystemAccess(bits(2) op0, bits(3) op1, bits(4) crn, bits(4) crm, bits(3) op2, bit read)">CheckTransactionalSystemAccess</a>(op0, op1, crn, crm, op2, read)) then
        <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(<a href="shared_pseudocode.html#TMFailure_ERR" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_ERR</a>, FALSE);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ChooseNonExcludedTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ChooseNonExcludedTag</h3>
      <p class="pseudocode">// AArch64.ChooseNonExcludedTag()
// ==============================
// Return a tag derived from the start and the offset values, excluding
// any tags in the given mask.

bits(4) <a id="AArch64.ChooseNonExcludedTag.3"/>AArch64.ChooseNonExcludedTag(bits(4) tag_in, bits(4) offset_in, bits(16) exclude)
    bits(4) tag = tag_in;
    bits(4) offset = offset_in;

    if <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exclude) then
        return '0000';

    if offset == '0000' then
        while exclude&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tag)&gt; == '1' do
            tag = tag + '0001';

    while offset != '0000' do
        offset = offset - '0001';
        tag = tag + '0001';
        while exclude&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tag)&gt; == '1' do
            tag = tag + '0001';

    return tag;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ExecutingBROrBLROrRetInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ExecutingBROrBLROrRetInstr</h3>
      <p class="pseudocode">// AArch64.ExecutingBROrBLROrRetInstr()
// ====================================
// Returns TRUE if current instruction is a BR, BLR, RET, B[L]RA[B][Z], or RETA[B].

boolean <a id="AArch64.ExecutingBROrBLROrRetInstr.0"/>AArch64.ExecutingBROrBLROrRetInstr()
    if !<a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then return FALSE;

    instr = <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>();
    if instr&lt;31:25&gt; == '1101011' &amp;&amp; instr&lt;20:16&gt; == '11111' then
        opc = instr&lt;24:21&gt;;
        return opc != '0101';
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ExecutingBTIInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ExecutingBTIInstr</h3>
      <p class="pseudocode">// AArch64.ExecutingBTIInstr()
// ===========================
// Returns TRUE if current instruction is a BTI.

boolean <a id="AArch64.ExecutingBTIInstr.0"/>AArch64.ExecutingBTIInstr()
    if !<a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then return FALSE;

    instr = <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>();
    if instr&lt;31:22&gt; == '1101010100' &amp;&amp; instr&lt;21:12&gt; == '0000110010' &amp;&amp; instr&lt;4:0&gt; == '11111' then
        CRm  = instr&lt;11:8&gt;;
        op2  = instr&lt;7:5&gt;;
        return (CRm == '0100' &amp;&amp; op2&lt;0&gt; == '0');
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ExecutingERETInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ExecutingERETInstr</h3>
      <p class="pseudocode">// AArch64.ExecutingERETInstr()
// ============================
// Returns TRUE if current instruction is ERET.

boolean <a id="AArch64.ExecutingERETInstr.0"/>AArch64.ExecutingERETInstr()
    instr = <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>();
    return instr&lt;31:12&gt; == '11010110100111110000';</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ImpDefSysInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ImpDefSysInstr</h3>
      <p class="pseudocode">// Execute an implementation-defined system instruction with write (source operand).
<a id="AArch64.ImpDefSysInstr.6"/>AArch64.ImpDefSysInstr(integer el, bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2, integer t);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ImpDefSysInstr128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ImpDefSysInstr128</h3>
      <p class="pseudocode">// Execute an implementation-defined system instruction with write (128-bit source operand).
<a id="AArch64.ImpDefSysInstr128.7"/>AArch64.ImpDefSysInstr128(integer el, bits(3) op1, bits(4) CRn,
                          bits(4) CRm, bits(3) op2,
                          integer t, integer t2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ImpDefSysInstrWithResult"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ImpDefSysInstrWithResult</h3>
      <p class="pseudocode">// Execute an implementation-defined system instruction with read (result operand).
<a id="AArch64.ImpDefSysInstrWithResult.5"/>AArch64.ImpDefSysInstrWithResult(integer el, bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ImpDefSysRegRead"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ImpDefSysRegRead</h3>
      <p class="pseudocode">// Read from an implementation-defined System register and write the contents of the register to X[t].
<a id="AArch64.ImpDefSysRegRead.6"/>AArch64.ImpDefSysRegRead(bits(2) op0, bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2, integer t);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ImpDefSysRegRead128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ImpDefSysRegRead128</h3>
      <p class="pseudocode">// Read from an 128-bit implementation-defined System register
// and write the contents of the register to X[t], X[t+1].
<a id="AArch64.ImpDefSysRegRead128.7"/>AArch64.ImpDefSysRegRead128(bits(2) op0, bits(3) op1, bits(4) CRn,
                            bits(4) CRm, bits(3) op2,
                            integer t, integer t2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ImpDefSysRegWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ImpDefSysRegWrite</h3>
      <p class="pseudocode">// Write to an implementation-defined System register.
<a id="AArch64.ImpDefSysRegWrite.6"/>AArch64.ImpDefSysRegWrite(bits(2) op0, bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2, integer t);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ImpDefSysRegWrite128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ImpDefSysRegWrite128</h3>
      <p class="pseudocode">// Write the contents of X[t], X[t+1] to an 128-bit implementation-defined System register.
<a id="AArch64.ImpDefSysRegWrite128.7"/>AArch64.ImpDefSysRegWrite128(bits(2) op0, bits(3) op1, bits(4) CRn,
                             bits(4) CRm, bits(3) op2,
                             integer t, integer t2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.NextRandomTagBit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.NextRandomTagBit</h3>
      <p class="pseudocode">// AArch64.NextRandomTagBit()
// ==========================
// Generate a random bit suitable for generating a random Allocation Tag.

bit <a id="AArch64.NextRandomTagBit.0"/>AArch64.NextRandomTagBit()
    assert GCR_EL1.RRND == '0';
    bits(16) lfsr = RGSR_EL1.SEED&lt;15:0&gt;;
    bit top = lfsr&lt;5&gt; EOR lfsr&lt;3&gt; EOR lfsr&lt;2&gt; EOR lfsr&lt;0&gt;;
    RGSR_EL1.SEED&lt;15:0&gt; = top:lfsr&lt;15:1&gt;;
    return top;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.RandomTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.RandomTag</h3>
      <p class="pseudocode">// AArch64.RandomTag()
// ===================
// Generate a random Allocation Tag.

bits(4) <a id="AArch64.RandomTag.0"/>AArch64.RandomTag()
    bits(4) tag;
    for i = 0 to 3
        tag&lt;i&gt; = <a href="shared_pseudocode.html#AArch64.NextRandomTagBit.0" title="function: bit AArch64.NextRandomTagBit()">AArch64.NextRandomTagBit</a>();
    return tag;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.SysInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.SysInstr</h3>
      <p class="pseudocode">// Execute a system instruction with write (source operand).
<a id="AArch64.SysInstr.6"/>AArch64.SysInstr(integer op0, integer op1, integer crn, integer crm, integer op2, integer t);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.SysInstrWithResult"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.SysInstrWithResult</h3>
      <p class="pseudocode">// Execute a system instruction with read (result operand).
// Writes the result of the instruction to X[t].
<a id="AArch64.SysInstrWithResult.6"/>AArch64.SysInstrWithResult(integer op0, integer op1, integer crn, integer crm, integer op2, integer t);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.SysRegRead"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.SysRegRead</h3>
      <p class="pseudocode">// Read from a System register and write the contents of the register to X[t].
<a id="AArch64.SysRegRead.6"/>AArch64.SysRegRead(integer op0, integer op1, integer crn, integer crm, integer op2, integer t);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.SysRegWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.SysRegWrite</h3>
      <p class="pseudocode">// Write to a System register.
<a id="AArch64.SysRegWrite.6"/>AArch64.SysRegWrite(integer op0, integer op1, integer crn, integer crm, integer op2, integer t);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeCompatible"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeCompatible</h3>
      <p class="pseudocode">boolean BTypeCompatible;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeCompatible_BTI"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeCompatible_BTI</h3>
      <p class="pseudocode">// BTypeCompatible_BTI
// ===================
// This function determines whether a given hint encoding is compatible with the current value of
// PSTATE.BTYPE. A value of TRUE here indicates a valid Branch Target Identification instruction.

boolean <a id="impl-aarch64.BTypeCompatible_BTI.1"/>BTypeCompatible_BTI(bits(2) hintcode)
    case hintcode of
        when '00'
            return FALSE;
        when '01'
            return PSTATE.BTYPE != '11';
        when '10'
            return PSTATE.BTYPE != '10';
        when '11'
            return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeCompatible_PACIXSP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeCompatible_PACIXSP</h3>
      <p class="pseudocode">// BTypeCompatible_PACIXSP()
// =========================
// Returns TRUE if PACIASP, PACIBSP instruction is implicit compatible with PSTATE.BTYPE,
// FALSE otherwise.

boolean <a id="impl-aarch64.BTypeCompatible_PACIXSP.0"/>BTypeCompatible_PACIXSP()
    if PSTATE.BTYPE IN {'01', '10'} then
        return TRUE;
    elsif PSTATE.BTYPE == '11' then
        index = if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then 35 else 36;
        return <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[]&lt;index&gt; == '0';
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeNext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeNext</h3>
      <p class="pseudocode">bits(2) BTypeNext;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.ChooseRandomNonExcludedTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/ChooseRandomNonExcludedTag</h3>
      <p class="pseudocode">// The ChooseRandomNonExcludedTag function is used when GCR_EL1.RRND == '1' to generate random
// Allocation Tags.
//
// The resulting Allocation Tag is selected from the set [0,15], excluding any Allocation Tag where
// exclude[tag_value] == 1. If 'exclude' is all Ones, the returned Allocation Tag is '0000'.
//
// This function is permitted to generate a non-deterministic selection from the set of non-excluded
// Allocation Tags. A reasonable implementation is described by the Pseudocode used when
// GCR_EL1.RRND is 0, but with a non-deterministic implementation of NextRandomTagBit(). Implementations
// may choose to behave the same as GCR_EL1.RRND=0.
//
// This function can read RGSR_EL1 and/or write RGSR_EL1 to an IMPLEMENTATION DEFINED value.
// If it is not capable of writing RGSR_EL1.SEED[15:0] to zero from a previous non-zero
// RGSR_EL1.SEED value, it is IMPLEMENTATION DEFINED whether the randomness is significantly
// impacted if RGSR_EL1.SEED[15:0] is set to zero.
bits(4) <a id="impl-aarch64.ChooseRandomNonExcludedTag.1"/>ChooseRandomNonExcludedTag(bits(16) exclude_in);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.InGuardedPage"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/InGuardedPage</h3>
      <p class="pseudocode">boolean InGuardedPage;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsHCRXEL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsHCRXEL2Enabled</h3>
      <p class="pseudocode">// IsHCRXEL2Enabled()
// ==================
// Returns TRUE if access to HCRX_EL2 register is enabled, and FALSE otherwise.
// Indirect read of HCRX_EL2 returns 0 when access is not enabled.

boolean <a id="impl-aarch64.IsHCRXEL2Enabled.0"/>IsHCRXEL2Enabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveFeatHCX.0" title="function: boolean HaveFeatHCX()">HaveFeatHCX</a>() then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.HXEn == '0' then
        return FALSE;

    return <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsSCTLR2EL1Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsSCTLR2EL1Enabled</h3>
      <p class="pseudocode">// IsSCTLR2EL1Enabled()
// ====================
// Returns TRUE if access to SCTLR2_EL1 register is enabled, and FALSE otherwise.
// Indirect read of SCTLR2_EL1 returns 0 when access is not enabled.

boolean <a id="impl-aarch64.IsSCTLR2EL1Enabled.0"/>IsSCTLR2EL1Enabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveFeatSCTLR2.0" title="function: boolean HaveFeatSCTLR2()">HaveFeatSCTLR2</a>() then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.SCTLR2En == '0' then
        return FALSE;
    elsif (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; (!<a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.SCTLR2En == '0')) then
        return FALSE;
    else
        return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsSCTLR2EL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsSCTLR2EL2Enabled</h3>
      <p class="pseudocode">// IsSCTLR2EL2Enabled()
// ====================
// Returns TRUE if access to SCTLR2_EL2 register is enabled, and FALSE otherwise.
// Indirect read of SCTLR2_EL2 returns 0 when access is not enabled.

boolean <a id="impl-aarch64.IsSCTLR2EL2Enabled.0"/>IsSCTLR2EL2Enabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveFeatSCTLR2.0" title="function: boolean HaveFeatSCTLR2()">HaveFeatSCTLR2</a>() then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.SCTLR2En == '0' then
        return FALSE;

    return <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsTCR2EL1Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsTCR2EL1Enabled</h3>
      <p class="pseudocode">// IsTCR2EL1Enabled()
// ==================
// Returns TRUE if access to TCR2_EL1 register is enabled, and FALSE otherwise.
// Indirect read of TCR2_EL1 returns 0 when access is not enabled.

boolean <a id="impl-aarch64.IsTCR2EL1Enabled.0"/>IsTCR2EL1Enabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveFeatTCR2.0" title="function: boolean HaveFeatTCR2()">HaveFeatTCR2</a>() then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.TCR2En == '0' then
        return FALSE;
    elsif (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; (!<a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.TCR2En == '0')) then
        return FALSE;
    else
        return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsTCR2EL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsTCR2EL2Enabled</h3>
      <p class="pseudocode">// IsTCR2EL2Enabled()
// ==================
// Returns TRUE if access to TCR2_EL2 register is enabled, and FALSE otherwise.
// Indirect read of TCR2_EL2 returns 0 when access is not enabled.

boolean <a id="impl-aarch64.IsTCR2EL2Enabled.0"/>IsTCR2EL2Enabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveFeatTCR2.0" title="function: boolean HaveFeatTCR2()">HaveFeatTCR2</a>() then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.TCR2En == '0' then
        return FALSE;

    return <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.SetBTypeCompatible"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/SetBTypeCompatible</h3>
      <p class="pseudocode">// SetBTypeCompatible()
// ====================
// Sets the value of BTypeCompatible global variable used by BTI

<a id="impl-aarch64.SetBTypeCompatible.1"/>SetBTypeCompatible(boolean x)
    BTypeCompatible = x;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.SetBTypeNext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/SetBTypeNext</h3>
      <p class="pseudocode">// SetBTypeNext()
// ==============
// Set the value of BTypeNext global variable used by BTI

<a id="impl-aarch64.SetBTypeNext.1"/>SetBTypeNext(bits(2) x)
    BTypeNext = x;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.SetInGuardedPage"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/SetInGuardedPage</h3>
      <p class="pseudocode">// SetInGuardedPage()
// ==================
// Global state updated to denote if memory access is from a guarded page.

<a id="impl-aarch64.SetInGuardedPage.1"/>SetInGuardedPage(boolean guardedpage)
    InGuardedPage = guardedpage;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system128.AArch64.SysInstr128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system128/AArch64.SysInstr128</h3>
      <p class="pseudocode">// Execute a system instruction with write (2 64-bit source operands).
<a id="AArch64.SysInstr128.7"/>AArch64.SysInstr128(integer op0, integer op1, integer crn, integer crm,
                    integer op2, integer t, integer t2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system128.AArch64.SysRegRead128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system128/AArch64.SysRegRead128</h3>
      <p class="pseudocode">// Read from a 128-bit System register and write the contents of the register to X[t] and X[t2].
<a id="AArch64.SysRegRead128.7"/>AArch64.SysRegRead128(integer op0, integer op1, integer crn, integer crm,
                      integer op2, integer t, integer t2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system128.AArch64.SysRegWrite128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system128/AArch64.SysRegWrite128</h3>
      <p class="pseudocode">// Read the contents of X[t] and X[t2] and write the contents to a 128-bit System register.
<a id="AArch64.SysRegWrite128.7"/>AArch64.SysRegWrite128(integer op0, integer op1, integer crn, integer crm,
                       integer op2, integer t, integer t2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.CheckTMEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/CheckTMEEnabled</h3>
      <p class="pseudocode">// CheckTMEEnabled()
// =================
// Returns TRUE if access to TME instruction is enabled, FALSE otherwise.

<a id="impl-aarch64.CheckTMEEnabled.0"/>CheckTMEEnabled()
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if SCR_EL3.TME == '0' then UNDEFINED;
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if HCR_EL2.TME == '0' then UNDEFINED;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.CheckTransactionalSystemAccess"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/CheckTransactionalSystemAccess</h3>
      <p class="pseudocode">// CheckTransactionalSystemAccess()
// ================================
// Returns TRUE if an AArch64 MSR, MRS, or SYS instruction is permitted in
// Transactional state, based on the opcode's encoding, and FALSE otherwise.

boolean <a id="impl-aarch64.CheckTransactionalSystemAccess.6"/>CheckTransactionalSystemAccess(bits(2) op0, bits(3) op1, bits(4) crn, bits(4) crm, bits(3) op2, bit read)
    case read:op0:op1:crn:crm:op2 of
        when '0 00 011 0100 xxxx 11x' return TRUE;      // MSR (imm): DAIFSet, DAIFClr
        when '0 01 011 0111 0100 001' return TRUE;      // DC ZVA
        when '0 11 011 0100 0010 00x' return TRUE;      // MSR: NZCV, DAIF
        when '0 11 011 0100 0100 00x' return TRUE;      // MSR: FPCR, FPSR
        when '0 11 000 0100 0110 000' return TRUE;      // MSR: ICC_PMR_EL1
        when '0 11 011 1001 1100 100' return TRUE;      // MRS: PMSWINC_EL0
        when '1 11 xxx 0xxx xxxx xxx' return TRUE;      // MRS: op1=3, CRn=0..7
        when '1 11 xxx 100x xxxx xxx' return TRUE;      // MRS: op1=3, CRn=8..9
        when '1 11 xxx 1010 xxxx xxx' return TRUE;      // MRS: op1=3, CRn=10
        when '1 11 000 1100 1x00 010' return TRUE;      // MRS: op1=3, CRn=12 - ICC_HPPIRx_EL1
        when '1 11 000 1100 1011 011' return TRUE;      // MRS: op1=3, CRn=12 - ICC_RPR_EL1
        when '1 11 xxx 1101 xxxx xxx' return TRUE;      // MRS: op1=3, CRn=13
        when '1 11 xxx 1110 xxxx xxx' return TRUE;      // MRS: op1=3, CRn=14
        when '0 01 011 0111 0011 111' return TRUE;      // CPP RCTX
        when '0 01 011 0111 0011 10x' return TRUE;      // CFP RCTX, DVP RCTX
        when 'x 11 xxx 1x11 xxxx xxx' return boolean IMPLEMENTATION_DEFINED; // MRS: op1=3, CRn=11,15
        otherwise return FALSE;                         // all other SYS, SYSL, MRS, MSR</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.CommitTransactionalWrites"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/CommitTransactionalWrites</h3>
      <p class="pseudocode">// Makes all transactional writes to memory observable by other PEs and reset
// the transactional read and write sets.
<a id="impl-aarch64.CommitTransactionalWrites.0"/>CommitTransactionalWrites();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.DiscardTransactionalWrites"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/DiscardTransactionalWrites</h3>
      <p class="pseudocode">// Discards all transactional writes to memory and reset the transactional
// read and write sets.
<a id="impl-aarch64.DiscardTransactionalWrites.0"/>DiscardTransactionalWrites();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.FailTransaction"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/FailTransaction</h3>
      <p class="pseudocode">// FailTransaction()
// =================

<a id="impl-aarch64.FailTransaction.2"/>FailTransaction(<a href="shared_pseudocode.html#TMFailure" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure</a> cause, boolean retry)
    <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.4" title="function: FailTransaction(TMFailure cause, boolean retry, boolean interrupt, bits(15) reason)">FailTransaction</a>(cause, retry, FALSE, <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(15));
    return;

// FailTransaction()
// =================
// Exits Transactional state and discards transactional updates to registers
// and memory.

<a id="impl-aarch64.FailTransaction.4"/>FailTransaction(<a href="shared_pseudocode.html#TMFailure" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure</a> cause, boolean retry, boolean interrupt, bits(15) reason)
    assert !retry || !interrupt;

    if <a href="shared_pseudocode.html#impl-shared.HaveBRBExt.0" title="function: boolean HaveBRBExt()">HaveBRBExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(PSTATE.EL) then BRBFCR_EL1.LASTFAILED = '1';

    <a href="shared_pseudocode.html#impl-aarch64.DiscardTransactionalWrites.0" title="function: DiscardTransactionalWrites()">DiscardTransactionalWrites</a>();
    // For trivial implementation no transaction checkpoint was taken
    if cause != <a href="shared_pseudocode.html#TMFailure_TRIVIAL" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_TRIVIAL</a> then
        <a href="shared_pseudocode.html#impl-aarch64.RestoreTransactionCheckpoint.0" title="function: RestoreTransactionCheckpoint()">RestoreTransactionCheckpoint</a>();
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>());

    bits(64) result = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

    result&lt;23&gt; = if interrupt then '1' else '0';
    result&lt;15&gt; = if retry &amp;&amp; !interrupt then '1' else '0';
    case cause of
        when <a href="shared_pseudocode.html#TMFailure_TRIVIAL" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_TRIVIAL</a> result&lt;24&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>     result&lt;22&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_NEST" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_NEST</a>    result&lt;21&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_SIZE" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_SIZE</a>    result&lt;20&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_ERR" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_ERR</a>     result&lt;19&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_IMP" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_IMP</a>     result&lt;18&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_MEM" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_MEM</a>     result&lt;17&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_CNCL" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_CNCL</a>    result&lt;16&gt; = '1'; result&lt;14:0&gt; = reason;

    TSTATE.depth = 0;
    <a href="shared_pseudocode.html#impl-aarch64.X.write.2" title="accessor: X[integer n, integer width] = bits(width) value">X</a>[TSTATE.Rt, 64] = result;
    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(TSTATE.nPC, <a href="shared_pseudocode.html#BranchType_TMFAIL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_TMFAIL</a>, branch_conditional);
    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.MemHasTransactionalAccess"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/MemHasTransactionalAccess</h3>
      <p class="pseudocode">// MemHasTransactionalAccess()
// ===========================
// Function checks if transactional accesses are not supported for an address
// range or memory type.

boolean <a id="impl-aarch64.MemHasTransactionalAccess.1"/>MemHasTransactionalAccess(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs)
    if ((memattrs.shareability == <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a> ||
            memattrs.shareability == <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>) &amp;&amp;
            memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp;
            memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
            memattrs.inner.hints == <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a> &amp;&amp;
            memattrs.inner.transient == FALSE &amp;&amp;
            memattrs.outer.hints == <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a> &amp;&amp;
            memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
            memattrs.outer.transient == FALSE) then
        return TRUE;
    else
        return boolean IMPLEMENTATION_DEFINED "Memory Region does not support Transactional access";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.RestoreTransactionCheckpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/RestoreTransactionCheckpoint</h3>
      <p class="pseudocode">// RestoreTransactionCheckpoint()
// ==============================
// Restores part of the PE registers from the transaction checkpoint.

<a id="impl-aarch64.RestoreTransactionCheckpoint.0"/>RestoreTransactionCheckpoint()
    <a href="shared_pseudocode.html#impl-aarch64.SP.write.0" title="accessor: SP[] = bits(64) value">SP</a>[]             = TSTATE.SP;
    ICC_PMR_EL1      = TSTATE.ICC_PMR_EL1;
    PSTATE.&lt;N,Z,C,V&gt; = TSTATE.nzcv;
    PSTATE.&lt;D,A,I,F&gt; = TSTATE.&lt;D,A,I,F&gt;;

    for n = 0 to 30
        <a href="shared_pseudocode.html#impl-aarch64.X.write.2" title="accessor: X[integer n, integer width] = bits(width) value">X</a>[n, 64] = TSTATE.X[n];

    constant integer VL = <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a>;
    constant integer PL = VL DIV 8;
    if <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(PSTATE.EL) then
        if <a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)">IsSVEEnabled</a>(PSTATE.EL) then
            for n = 0 to 31
                <a href="shared_pseudocode.html#impl-aarch64.Z.write.2" title="accessor: Z[integer n, integer width] = bits(width) value">Z</a>[n, VL] = TSTATE.Z[n]&lt;VL-1:0&gt;;
            for n = 0 to 15
                <a href="shared_pseudocode.html#impl-aarch64.P.write.2" title="accessor: P[integer n, integer width] = bits(width) value">P</a>[n, PL] = TSTATE.P[n]&lt;PL-1:0&gt;;
            <a href="shared_pseudocode.html#impl-aarch64.FFR.write.1" title="accessor: FFR[integer width] = bits(width) value">FFR</a>[PL] = TSTATE.FFR&lt;PL-1:0&gt;;
        else
            for n = 0 to 31
                <a href="shared_pseudocode.html#impl-aarch64.V.write.2" title="accessor: V[integer n, integer width] = bits(width) value">V</a>[n, 128] = TSTATE.Z[n]&lt;127:0&gt;;
        FPCR = TSTATE.FPCR;
        FPSR = TSTATE.FPSR;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.StartTrackingTransactionalReadsWrites"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/StartTrackingTransactionalReadsWrites</h3>
      <p class="pseudocode">// Starts tracking transactional reads and writes to memory.
<a id="impl-aarch64.StartTrackingTransactionalReadsWrites.0"/>StartTrackingTransactionalReadsWrites();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.TMFailure"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/TMFailure</h3>
      <p class="pseudocode">enumeration <a id="TMFailure"/>TMFailure {
    <a id="TMFailure_CNCL"/>TMFailure_CNCL,    // Executed a TCANCEL instruction
    <a id="TMFailure_DBG"/>TMFailure_DBG,     // A debug event was generated
    <a id="TMFailure_ERR"/>TMFailure_ERR,     // A non-permissible operation was attempted
    <a id="TMFailure_NEST"/>TMFailure_NEST,    // The maximum transactional nesting level was exceeded
    <a id="TMFailure_SIZE"/>TMFailure_SIZE,    // The transactional read or write set limit was exceeded
    <a id="TMFailure_MEM"/>TMFailure_MEM,     // A transactional conflict occurred
    <a id="TMFailure_TRIVIAL"/>TMFailure_TRIVIAL, // Only a TRIVIAL version of TM is available
    <a id="TMFailure_IMP"/>TMFailure_IMP      // Any other failure cause
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.TMState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/TMState</h3>
      <p class="pseudocode">type TMState is (
    integer       depth,              // Transaction nesting depth
    integer       Rt,                 // TSTART destination register
    bits(64)      nPC,                // Fallback instruction address
    array[0..30] of bits(64)     X,   // General purpose registers
    array[0..31] of bits(<a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>) Z,   // Vector registers
    array[0..15] of bits(<a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>) P,   // Predicate registers
    bits(<a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>)  FFR,                // First Fault Register
    bits(64)      SP,                 // Stack Pointer at current EL
    bits(64)      FPCR,               // Floating-point Control Register
    bits(64)      FPSR,               // Floating-point Status Register
    bits(64)      ICC_PMR_EL1,        // Interrupt Controller Interrupt Priority Mask Register
    bits(4)       nzcv,               // Condition flags
    bits(1)       D,                  // Debug mask bit
    bits(1)       A,                  // SError interrupt mask bit
    bits(1)       I,                  // IRQ mask bit
    bits(1)       F                   // FIQ mask bit
)</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.TSTATE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/TSTATE</h3>
      <p class="pseudocode">TMState TSTATE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.TakeTransactionCheckpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/TakeTransactionCheckpoint</h3>
      <p class="pseudocode">// TakeTransactionCheckpoint()
// ===========================
// Captures part of the PE registers into the transaction checkpoint.

<a id="impl-aarch64.TakeTransactionCheckpoint.0"/>TakeTransactionCheckpoint()
    TSTATE.SP             = <a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(64) SP[]">SP</a>[];
    TSTATE.ICC_PMR_EL1    = ICC_PMR_EL1;
    TSTATE.nzcv           = PSTATE.&lt;N,Z,C,V&gt;;
    TSTATE.&lt;D,A,I,F&gt;      = PSTATE.&lt;D,A,I,F&gt;;

    for n = 0 to 30
        TSTATE.X[n] = <a href="shared_pseudocode.html#impl-aarch64.X.read.2" title="accessor: bits(width) X[integer n, integer width]">X</a>[n, 64];

    constant integer VL = <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a>;
    constant integer PL = VL DIV 8;
    if <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(PSTATE.EL) then
        if <a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)">IsSVEEnabled</a>(PSTATE.EL) then
            for n = 0 to 31
                TSTATE.Z[n]&lt;VL-1:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.Z.read.2" title="accessor: bits(width) Z[integer n, integer width]">Z</a>[n, VL];
            for n = 0 to 15
                TSTATE.P[n]&lt;PL-1:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.P.read.2" title="accessor: bits(width) P[integer n, integer width]">P</a>[n, PL];
            TSTATE.FFR&lt;PL-1:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.FFR.read.1" title="accessor: bits(width) FFR[integer width]">FFR</a>[PL];
        else
            for n = 0 to 31
                TSTATE.Z[n]&lt;127:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.V.read.2" title="accessor: bits(width) V[integer n, integer width]">V</a>[n, 128];
        TSTATE.FPCR = FPCR;
        TSTATE.FPSR = FPSR;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.TransactionStartTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/TransactionStartTrap</h3>
      <p class="pseudocode">// TransactionStartTrap()
// ======================
// Traps the execution of TSTART instruction.

<a id="impl-aarch64.TransactionStartTrap.1"/>TransactionStartTrap(integer dreg)
    bits(2) targetEL;
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_TSTARTAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_TSTARTAccessTrap</a>);
    exception.syndrome&lt;9:5&gt; = dreg&lt;4:0&gt;;

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        targetEL = PSTATE.EL;
    elsif <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        targetEL = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        targetEL = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(targetEL, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.branch.eret.AArch64.ExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/branch/eret/AArch64.ExceptionReturn</h3>
      <p class="pseudocode">// AArch64.ExceptionReturn()
// =========================

<a id="AArch64.ExceptionReturn.2"/>AArch64.ExceptionReturn(bits(64) new_pc_in, bits(64) spsr)
    bits(64) new_pc = new_pc_in;
    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then
        <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(<a href="shared_pseudocode.html#TMFailure_ERR" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_ERR</a>, FALSE);

    if <a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()">HaveIESB</a>() then
        sync_errors = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].IESB == '1';
        if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then
            sync_errors = sync_errors || (SCR_EL3.&lt;EA,NMEA&gt; == '11' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        if sync_errors then
            <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()">SynchronizeErrors</a>();
            iesb_req = TRUE;
            <a href="shared_pseudocode.html#impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" title="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)">TakeUnmaskedPhysicalSErrorInterrupts</a>(iesb_req);
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();

    // Attempts to change to an illegal state will invoke the Illegal Execution state mechanism
    bits(2) source_el = PSTATE.EL;
    boolean illegal_psr_state = <a href="shared_pseudocode.html#impl-shared.IllegalExceptionReturn.1" title="function: boolean IllegalExceptionReturn(bits(N) spsr)">IllegalExceptionReturn</a>(spsr);
    <a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.2" title="function: SetPSTATEFromPSR(bits(N) spsr_in, boolean illegal_psr_state)">SetPSTATEFromPSR</a>(spsr, illegal_psr_state);
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>());
    <a href="shared_pseudocode.html#impl-shared.SendEventLocal.0" title="function: SendEventLocal()">SendEventLocal</a>();

    if illegal_psr_state &amp;&amp; spsr&lt;4&gt; == '1' then
        // If the exception return is illegal, PC[63:32,1:0] are UNKNOWN
        new_pc&lt;63:32&gt; = bits(32) UNKNOWN;
        new_pc&lt;1:0&gt; = bits(2) UNKNOWN;
    elsif <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then                // Return to AArch32
        // ELR_ELx[1:0] or ELR_ELx[0] are treated as being 0, depending on the
        // target instruction set state
        if PSTATE.T == '1' then
            new_pc&lt;0&gt; = '0';                 // T32
        else
            new_pc&lt;1:0&gt; = '00';              // A32
    else                                     // Return to AArch64
        // ELR_ELx[63:56] might include a tag
        new_pc = <a href="shared_pseudocode.html#AArch64.BranchAddr.2" title="function: bits(64) AArch64.BranchAddr(bits(64) vaddress, bits(2) el)">AArch64.BranchAddr</a>(new_pc, PSTATE.EL);

    if <a href="shared_pseudocode.html#impl-shared.HaveBRBExt.0" title="function: boolean HaveBRBExt()">HaveBRBExt</a>() then
        <a href="shared_pseudocode.html#impl-aarch64.BRBEExceptionReturn.2" title="function: BRBEExceptionReturn(bits(64) target_address_in, bits(2) source_el)">BRBEExceptionReturn</a>(new_pc, source_el);

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' then <a href="shared_pseudocode.html#impl-aarch64.ResetSVEState.0" title="function: ResetSVEState()">ResetSVEState</a>();

        // 32 most significant bits are ignored.
        boolean branch_conditional = FALSE;
        <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(new_pc&lt;31:0&gt;, <a href="shared_pseudocode.html#BranchType_ERET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_ERET</a>, branch_conditional);
    else
        <a href="shared_pseudocode.html#impl-shared.BranchToAddr.2" title="function: BranchToAddr(bits(N) target, BranchType branch_type)">BranchToAddr</a>(new_pc, <a href="shared_pseudocode.html#BranchType_ERET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_ERET</a>);

    <a href="shared_pseudocode.html#impl-shared.CheckExceptionCatch.1" title="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(FALSE);              // Check for debug event on exception return</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.countop.CountOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/countop/CountOp</h3>
      <p class="pseudocode">enumeration <a id="CountOp"/>CountOp     {<a id="CountOp_CLZ"/>CountOp_CLZ, <a id="CountOp_CLS"/>CountOp_CLS, <a id="CountOp_CNT"/>CountOp_CNT};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.extendreg.DecodeRegExtend"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/extendreg/DecodeRegExtend</h3>
      <p class="pseudocode">// DecodeRegExtend()
// =================
// Decode a register extension option

ExtendType <a id="impl-aarch64.DecodeRegExtend.1"/>DecodeRegExtend(bits(3) op)
    case op of
        when '000' return <a href="shared_pseudocode.html#ExtendType_UXTB" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTB</a>;
        when '001' return <a href="shared_pseudocode.html#ExtendType_UXTH" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTH</a>;
        when '010' return <a href="shared_pseudocode.html#ExtendType_UXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTW</a>;
        when '011' return <a href="shared_pseudocode.html#ExtendType_UXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTX</a>;
        when '100' return <a href="shared_pseudocode.html#ExtendType_SXTB" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTB</a>;
        when '101' return <a href="shared_pseudocode.html#ExtendType_SXTH" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTH</a>;
        when '110' return <a href="shared_pseudocode.html#ExtendType_SXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTW</a>;
        when '111' return <a href="shared_pseudocode.html#ExtendType_SXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTX</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.extendreg.ExtendReg"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/extendreg/ExtendReg</h3>
      <p class="pseudocode">// ExtendReg()
// ===========
// Perform a register extension and shift

bits(N) <a id="impl-aarch64.ExtendReg.4"/>ExtendReg(integer reg, <a href="shared_pseudocode.html#ExtendType" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType</a> exttype, integer shift, integer N)
    assert shift &gt;= 0 &amp;&amp; shift &lt;= 4;
    bits(N) val = <a href="shared_pseudocode.html#impl-aarch64.X.read.2" title="accessor: bits(width) X[integer n, integer width]">X</a>[reg, N];
    boolean unsigned;
    integer len;

    case exttype of
        when <a href="shared_pseudocode.html#ExtendType_SXTB" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTB</a> unsigned = FALSE; len = 8;
        when <a href="shared_pseudocode.html#ExtendType_SXTH" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTH</a> unsigned = FALSE; len = 16;
        when <a href="shared_pseudocode.html#ExtendType_SXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTW</a> unsigned = FALSE; len = 32;
        when <a href="shared_pseudocode.html#ExtendType_SXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTX</a> unsigned = FALSE; len = 64;
        when <a href="shared_pseudocode.html#ExtendType_UXTB" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTB</a> unsigned = TRUE;  len = 8;
        when <a href="shared_pseudocode.html#ExtendType_UXTH" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTH</a> unsigned = TRUE;  len = 16;
        when <a href="shared_pseudocode.html#ExtendType_UXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTW</a> unsigned = TRUE;  len = 32;
        when <a href="shared_pseudocode.html#ExtendType_UXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTX</a> unsigned = TRUE;  len = 64;

    // Note the extended width of the intermediate value and
    // that sign extension occurs from bit &lt;len+shift-1&gt;, not
    // from bit &lt;len-1&gt;. This is equivalent to the instruction
    //   [SU]BFIZ Rtmp, Rreg, #shift, #len
    // It may also be seen as a sign/zero extend followed by a shift:
    //   LSL(Extend(val&lt;len-1:0&gt;, N, unsigned), shift);

    len = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(len, N - shift);
    return <a href="shared_pseudocode.html#impl-shared.Extend.3" title="function: bits(N) Extend(bits(M) x, integer N, boolean unsigned)">Extend</a>(val&lt;len-1:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(shift), N, unsigned);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.extendreg.ExtendType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/extendreg/ExtendType</h3>
      <p class="pseudocode">enumeration <a id="ExtendType"/>ExtendType  {<a id="ExtendType_SXTB"/>ExtendType_SXTB, <a id="ExtendType_SXTH"/>ExtendType_SXTH, <a id="ExtendType_SXTW"/>ExtendType_SXTW, <a id="ExtendType_SXTX"/>ExtendType_SXTX,
                         <a id="ExtendType_UXTB"/>ExtendType_UXTB, <a id="ExtendType_UXTH"/>ExtendType_UXTH, <a id="ExtendType_UXTW"/>ExtendType_UXTW, <a id="ExtendType_UXTX"/>ExtendType_UXTX};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.float.arithmetic.max-min.fpmaxminop.FPMaxMinOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/float/arithmetic/max-min/fpmaxminop/FPMaxMinOp</h3>
      <p class="pseudocode">enumeration <a id="FPMaxMinOp"/>FPMaxMinOp  {<a id="FPMaxMinOp_MAX"/>FPMaxMinOp_MAX, <a id="FPMaxMinOp_MIN"/>FPMaxMinOp_MIN,
                         <a id="FPMaxMinOp_MAXNUM"/>FPMaxMinOp_MAXNUM, <a id="FPMaxMinOp_MINNUM"/>FPMaxMinOp_MINNUM};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.float.arithmetic.unary.fpunaryop.FPUnaryOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/float/arithmetic/unary/fpunaryop/FPUnaryOp</h3>
      <p class="pseudocode">enumeration <a id="FPUnaryOp"/>FPUnaryOp   {<a id="FPUnaryOp_ABS"/>FPUnaryOp_ABS, <a id="FPUnaryOp_MOV"/>FPUnaryOp_MOV,
                         <a id="FPUnaryOp_NEG"/>FPUnaryOp_NEG, <a id="FPUnaryOp_SQRT"/>FPUnaryOp_SQRT};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.float.convert.fpconvop.FPConvOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/float/convert/fpconvop/FPConvOp</h3>
      <p class="pseudocode">enumeration <a id="FPConvOp"/>FPConvOp    {<a id="FPConvOp_CVT_FtoI"/>FPConvOp_CVT_FtoI, <a id="FPConvOp_CVT_ItoF"/>FPConvOp_CVT_ItoF,
                         <a id="FPConvOp_MOV_FtoI"/>FPConvOp_MOV_FtoI, <a id="FPConvOp_MOV_ItoF"/>FPConvOp_MOV_ItoF
                         , <a id="FPConvOp_CVT_FtoI_JS"/>FPConvOp_CVT_FtoI_JS
};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.bitfield.bfxpreferred.BFXPreferred"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/bitfield/bfxpreferred/BFXPreferred</h3>
      <p class="pseudocode">// BFXPreferred()
// ==============
//
// Return TRUE if UBFX or SBFX is the preferred disassembly of a
// UBFM or SBFM bitfield instruction. Must exclude more specific
// aliases UBFIZ, SBFIZ, UXT[BH], SXT[BHW], LSL, LSR and ASR.

boolean <a id="impl-aarch64.BFXPreferred.4"/>BFXPreferred(bit sf, bit uns, bits(6) imms, bits(6) immr)

    // must not match UBFIZ/SBFIX alias
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imms) &lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(immr) then
        return FALSE;

    // must not match LSR/ASR/LSL alias (imms == 31 or 63)
    if imms == sf:'11111' then
        return FALSE;

    // must not match UXTx/SXTx alias
    if immr == '000000' then
        // must not match 32-bit UXT[BH] or SXT[BH]
        if sf == '0' &amp;&amp; imms IN {'000111', '001111'} then
            return FALSE;
        // must not match 64-bit SXT[BHW]
        if sf:uns == '10' &amp;&amp; imms IN {'000111', '001111', '011111'} then
            return FALSE;

    // must be UBFX/SBFX alias
    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.bitmasks.AltDecodeBitMasks"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/bitmasks/AltDecodeBitMasks</h3>
      <p class="pseudocode">// AltDecodeBitMasks()
// ===================
// Alternative but logically equivalent implementation of DecodeBitMasks() that
// uses simpler primitives to compute tmask and wmask.

(bits(M), bits(M)) <a id="impl-aarch64.AltDecodeBitMasks.5"/>AltDecodeBitMasks(bit immN, bits(6) imms, bits(6) immr,
                                     boolean immediate, integer M)
    bits(64) tmask, wmask;
    bits(6) tmask_and, wmask_and;
    bits(6) tmask_or, wmask_or;
    bits(6) levels;

    // Compute log2 of element size
    // 2^len must be in range [2, M]
    len = <a href="shared_pseudocode.html#impl-shared.HighestSetBit.1" title="function: integer HighestSetBit(bits(N) x)">HighestSetBit</a>(immN:NOT(imms));
    if len &lt; 1 then UNDEFINED;
    assert M &gt;= (1 &lt;&lt; len);

    // Determine s, r and s - r parameters
    levels = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(len), 6);

    // For logical immediates an all-ones value of s is reserved
    // since it would generate a useless all-ones result (many times)
    if immediate &amp;&amp; (imms AND levels) == levels then
        UNDEFINED;

    s = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imms AND levels);
    r = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(immr AND levels);
    diff = s - r;    // 6-bit subtract with borrow

    // Compute "top mask"
    tmask_and = diff&lt;5:0&gt; OR NOT(levels);
    tmask_or  = diff&lt;5:0&gt; AND levels;

    tmask = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(64);
    tmask = ((tmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;0&gt;, 1) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(1), 32))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(1) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;0&gt;, 1), 32));
    // optimization of first step:
    // tmask = Replicate(tmask_and&lt;0&gt; : '1', 32);
    tmask = ((tmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;1&gt;, 2) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(2), 16))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(2) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;1&gt;, 2), 16));
    tmask = ((tmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;2&gt;, 4) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(4), 8))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(4) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;2&gt;, 4), 8));
    tmask = ((tmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;3&gt;, 8) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(8), 4))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;3&gt;, 8), 4));
    tmask = ((tmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;4&gt;, 16) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(16), 2))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;4&gt;, 16), 2));
    tmask = ((tmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;5&gt;, 32) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(32), 1))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;5&gt;, 32), 1));

    // Compute "wraparound mask"
    wmask_and = immr OR NOT(levels);
    wmask_or  = immr AND levels;

    wmask = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    wmask = ((wmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(1) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;0&gt;, 1), 32))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;0&gt;, 1) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(1), 32));
    // optimization of first step:
    // wmask = Replicate(wmask_or&lt;0&gt; : '0', 32);
    wmask = ((wmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(2) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;1&gt;, 2), 16))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;1&gt;, 2) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(2), 16));
    wmask = ((wmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(4) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;2&gt;, 4), 8))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;2&gt;, 4) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(4), 8));
    wmask = ((wmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(8) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;3&gt;, 8), 4))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;3&gt;, 8) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8), 4));
    wmask = ((wmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(16) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;4&gt;, 16), 2))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;4&gt;, 16) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16), 2));
    wmask = ((wmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(32) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;5&gt;, 32), 1))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;5&gt;, 32) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32), 1));

    if diff&lt;6&gt; != '0' then // borrow from s - r
        wmask = wmask AND tmask;
    else
        wmask = wmask OR tmask;

    return (wmask&lt;M-1:0&gt;, tmask&lt;M-1:0&gt;);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.bitmasks.DecodeBitMasks"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/bitmasks/DecodeBitMasks</h3>
      <p class="pseudocode">// DecodeBitMasks()
// ================
// Decode AArch64 bitfield and logical immediate masks which use a similar encoding structure

(bits(M), bits(M)) <a id="impl-aarch64.DecodeBitMasks.5"/>DecodeBitMasks(bit immN, bits(6) imms, bits(6) immr,
                                  boolean immediate, integer M)
    bits(M) tmask, wmask;
    bits(6) levels;

    // Compute log2 of element size
    // 2^len must be in range [2, M]
    len = <a href="shared_pseudocode.html#impl-shared.HighestSetBit.1" title="function: integer HighestSetBit(bits(N) x)">HighestSetBit</a>(immN:NOT(imms));
    if len &lt; 1 then UNDEFINED;
    assert M &gt;= (1 &lt;&lt; len);

    // Determine s, r and s - r parameters
    levels = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(len), 6);

    // For logical immediates an all-ones value of s is reserved
    // since it would generate a useless all-ones result (many times)
    if immediate &amp;&amp; (imms AND levels) == levels then
        UNDEFINED;

    s = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imms AND levels);
    r = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(immr AND levels);
    diff = s - r;    // 6-bit subtract with borrow

    esize = 1 &lt;&lt; len;
    d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(diff&lt;len-1:0&gt;);
    welem = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(s + 1), esize);
    telem = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(d + 1), esize);
    wmask = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(welem, r), M DIV esize);
    tmask = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(telem, M DIV esize);
    return (wmask, tmask);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.ins-ext.insert.movewide.movewideop.MoveWideOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/ins-ext/insert/movewide/movewideop/MoveWideOp</h3>
      <p class="pseudocode">enumeration <a id="MoveWideOp"/>MoveWideOp  {<a id="MoveWideOp_N"/>MoveWideOp_N, <a id="MoveWideOp_Z"/>MoveWideOp_Z, <a id="MoveWideOp_K"/>MoveWideOp_K};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.logical.movwpreferred.MoveWidePreferred"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/logical/movwpreferred/MoveWidePreferred</h3>
      <p class="pseudocode">// MoveWidePreferred()
// ===================
//
// Return TRUE if a bitmask immediate encoding would generate an immediate
// value that could also be represented by a single MOVZ or MOVN instruction.
// Used as a condition for the preferred MOV&lt;-ORR alias.

boolean <a id="impl-aarch64.MoveWidePreferred.4"/>MoveWidePreferred(bit sf, bit immN, bits(6) imms, bits(6) immr)
    integer s = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imms);
    integer r = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(immr);
    integer width = if sf == '1' then 64 else 32;

    // element size must equal total immediate size
    if sf == '1' &amp;&amp; !((immN:imms) IN {'1xxxxxx'}) then
        return FALSE;
    if sf == '0' &amp;&amp; !((immN:imms) IN {'00xxxxx'}) then
        return FALSE;

    // for MOVZ must contain no more than 16 ones
    if s &lt; 16 then
        // ones must not span halfword boundary when rotated
        return (-r MOD 16) &lt;= (15 - s);

    // for MOVN must contain no more than 16 zeros
    if s &gt;= width - 15 then
        // zeros must not span halfword boundary when rotated
        return (r MOD 16) &lt;= (s - (width - 15));

    return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.shiftreg.DecodeShift"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/shiftreg/DecodeShift</h3>
      <p class="pseudocode">// DecodeShift()
// =============
// Decode shift encodings

ShiftType <a id="impl-aarch64.DecodeShift.1"/>DecodeShift(bits(2) op)
    case op of
        when '00'  return <a href="shared_pseudocode.html#ShiftType_LSL" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSL</a>;
        when '01'  return <a href="shared_pseudocode.html#ShiftType_LSR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSR</a>;
        when '10'  return <a href="shared_pseudocode.html#ShiftType_ASR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ASR</a>;
        when '11'  return <a href="shared_pseudocode.html#ShiftType_ROR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ROR</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.shiftreg.ShiftReg"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/shiftreg/ShiftReg</h3>
      <p class="pseudocode">// ShiftReg()
// ==========
// Perform shift of a register operand

bits(N) <a id="impl-aarch64.ShiftReg.4"/>ShiftReg(integer reg, <a href="shared_pseudocode.html#ShiftType" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType</a> shiftype, integer amount, integer N)
    bits(N) result = <a href="shared_pseudocode.html#impl-aarch64.X.read.2" title="accessor: bits(width) X[integer n, integer width]">X</a>[reg, N];
    case shiftype of
        when <a href="shared_pseudocode.html#ShiftType_LSL" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSL</a> result = <a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(result, amount);
        when <a href="shared_pseudocode.html#ShiftType_LSR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSR</a> result = <a href="shared_pseudocode.html#impl-shared.LSR.2" title="function: bits(N) LSR(bits(N) x, integer shift)">LSR</a>(result, amount);
        when <a href="shared_pseudocode.html#ShiftType_ASR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ASR</a> result = <a href="shared_pseudocode.html#impl-shared.ASR.2" title="function: bits(N) ASR(bits(N) x, integer shift)">ASR</a>(result, amount);
        when <a href="shared_pseudocode.html#ShiftType_ROR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ROR</a> result = <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(result, amount);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.shiftreg.ShiftType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/shiftreg/ShiftType</h3>
      <p class="pseudocode">enumeration <a id="ShiftType"/>ShiftType   {<a id="ShiftType_LSL"/>ShiftType_LSL, <a id="ShiftType_LSR"/>ShiftType_LSR, <a id="ShiftType_ASR"/>ShiftType_ASR, <a id="ShiftType_ROR"/>ShiftType_ROR};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.logicalop.LogicalOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/logicalop/LogicalOp</h3>
      <p class="pseudocode">enumeration <a id="LogicalOp"/>LogicalOp   {<a id="LogicalOp_AND"/>LogicalOp_AND, <a id="LogicalOp_EOR"/>LogicalOp_EOR, <a id="LogicalOp_ORR"/>LogicalOp_ORR};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.memory.prefetch.Prefetch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/memory/prefetch/Prefetch</h3>
      <p class="pseudocode">// Prefetch()
// ==========

// Decode and execute the prefetch hint on ADDRESS specified by PRFOP

<a id="impl-aarch64.Prefetch.2"/>Prefetch(bits(64) address, bits(5) prfop)
    <a href="shared_pseudocode.html#PrefetchHint" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">PrefetchHint</a> hint;
    integer target;
    boolean stream;

    case prfop&lt;4:3&gt; of
        when '00' hint = <a href="shared_pseudocode.html#Prefetch_READ" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">Prefetch_READ</a>;         // PLD: prefetch for load
        when '01' hint = <a href="shared_pseudocode.html#Prefetch_EXEC" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">Prefetch_EXEC</a>;         // PLI: preload instructions
        when '10' hint = <a href="shared_pseudocode.html#Prefetch_WRITE" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">Prefetch_WRITE</a>;        // PST: prepare for store
        when '11' return;                       // unallocated hint
    target = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(prfop&lt;2:1&gt;);                  // target cache level
    stream = (prfop&lt;0&gt; != '0');                 // streaming (non-temporal)
    <a href="shared_pseudocode.html#impl-shared.Hint_Prefetch.4" title="function: Hint_Prefetch(bits(64) address, PrefetchHint hint, integer target, boolean stream)">Hint_Prefetch</a>(address, hint, target, stream);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.barriers.barrierop.MemBarrierOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/barriers/barrierop/MemBarrierOp</h3>
      <p class="pseudocode">enumeration <a id="MemBarrierOp"/>MemBarrierOp   {  <a id="MemBarrierOp_DSB"/>MemBarrierOp_DSB         // Data Synchronization Barrier
                            , <a id="MemBarrierOp_DMB"/>MemBarrierOp_DMB         // Data Memory Barrier
                            , <a id="MemBarrierOp_ISB"/>MemBarrierOp_ISB         // Instruction Synchronization Barrier
                            , <a id="MemBarrierOp_SSBB"/>MemBarrierOp_SSBB        // Speculative Synchronization Barrier to VA
                            , <a id="MemBarrierOp_PSSBB"/>MemBarrierOp_PSSBB       // Speculative Synchronization Barrier to PA
                            , <a id="MemBarrierOp_SB"/>MemBarrierOp_SB          // Speculation Barrier
                           };</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.hints.syshintop.SystemHintOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/hints/syshintop/SystemHintOp</h3>
      <p class="pseudocode">enumeration <a id="SystemHintOp"/>SystemHintOp {
    <a id="SystemHintOp_NOP"/>SystemHintOp_NOP,
    <a id="SystemHintOp_YIELD"/>SystemHintOp_YIELD,
    <a id="SystemHintOp_WFE"/>SystemHintOp_WFE,
    <a id="SystemHintOp_WFI"/>SystemHintOp_WFI,
    <a id="SystemHintOp_SEV"/>SystemHintOp_SEV,
    <a id="SystemHintOp_SEVL"/>SystemHintOp_SEVL,
    <a id="SystemHintOp_DGH"/>SystemHintOp_DGH,
    <a id="SystemHintOp_ESB"/>SystemHintOp_ESB,
    <a id="SystemHintOp_PSB"/>SystemHintOp_PSB,
    <a id="SystemHintOp_TSB"/>SystemHintOp_TSB,
    <a id="SystemHintOp_BTI"/>SystemHintOp_BTI,
    <a id="SystemHintOp_WFET"/>SystemHintOp_WFET,
    <a id="SystemHintOp_WFIT"/>SystemHintOp_WFIT,
    <a id="SystemHintOp_CLRBHB"/>SystemHintOp_CLRBHB,
    <a id="SystemHintOp_CSDB"/>SystemHintOp_CSDB
};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.register.cpsr.pstatefield.PSTATEField"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/register/cpsr/pstatefield/PSTATEField</h3>
      <p class="pseudocode">enumeration <a id="PSTATEField"/>PSTATEField {<a id="PSTATEField_DAIFSet"/>PSTATEField_DAIFSet, <a id="PSTATEField_DAIFClr"/>PSTATEField_DAIFClr,
                         <a id="PSTATEField_PAN"/>PSTATEField_PAN, // Armv8.1
                         <a id="PSTATEField_UAO"/>PSTATEField_UAO, // Armv8.2
                         <a id="PSTATEField_DIT"/>PSTATEField_DIT, // Armv8.4
                         <a id="PSTATEField_SSBS"/>PSTATEField_SSBS,
                         <a id="PSTATEField_TCO"/>PSTATEField_TCO, // Armv8.5
                         <a id="PSTATEField_SVCRSM"/>PSTATEField_SVCRSM,
                         <a id="PSTATEField_SVCRZA"/>PSTATEField_SVCRZA,
                         <a id="PSTATEField_SVCRSMZA"/>PSTATEField_SVCRSMZA,
                         <a id="PSTATEField_ALLINT"/>PSTATEField_ALLINT,
                         <a id="PSTATEField_PM"/>PSTATEField_PM,
                         <a id="PSTATEField_SP"/>PSTATEField_SP
                         };</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.at.AArch64.AT"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/at/AArch64.AT</h3>
      <p class="pseudocode">// AArch64.AT()
// ============
// Perform address translation as per AT instructions.

<a id="AArch64.AT.4"/>AArch64.AT(bits(64) address, <a href="shared_pseudocode.html#TranslationStage" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage</a> stage_in, bits(2) el_in, <a href="shared_pseudocode.html#ATAccess" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess</a> ataccess)
    <a href="shared_pseudocode.html#TranslationStage" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage</a> stage = stage_in;
    bits(2) el = el_in;
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; SCR_EL3.&lt;NSE,NS&gt; == '10' &amp;&amp; el != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then UNDEFINED;
    // For stage 1 translation, when HCR_EL2.{E2H, TGE} is {1,1} and requested EL is EL1,
    // the EL2&amp;0 translation regime is used.
    if HCR_EL2.&lt;E2H, TGE&gt; == '11' &amp;&amp; el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; stage == <a href="shared_pseudocode.html#TranslationStage_1" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a> then
        el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; stage == <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        stage = <a href="shared_pseudocode.html#TranslationStage_1" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a>;

    boolean write = ataccess IN {<a href="shared_pseudocode.html#ATAccess_WritePAN" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_WritePAN</a>, <a href="shared_pseudocode.html#ATAccess_Write" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Write</a>};
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(el);
    boolean pan = ataccess IN {<a href="shared_pseudocode.html#ATAccess_ReadPAN" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_ReadPAN</a>, <a href="shared_pseudocode.html#ATAccess_WritePAN" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_WritePAN</a>};
    accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescAT.4" title="function: AccessDescriptor CreateAccDescAT(SecurityState ss, bits(2) el, boolean write, boolean pan)">CreateAccDescAT</a>(ss, el, write, pan);
    aligned = TRUE;

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.NoFault.1" title="function: FaultRecord NoFault(AccessDescriptor accdesc)">NoFault</a>(accdesc);
    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime;
    if stage == <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> then
        regime = <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    else
        regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.1" title="function: Regime TranslationRegime(bits(2) el)">TranslationRegime</a>(el);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> addrdesc;
    if (el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) || (el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el)) then
        if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> || TTBCR.EAE == '1' then
            (fault, addrdesc) = <a href="shared_pseudocode.html#AArch32.S1TranslateLD.5" title="function: (FaultRecord, AddressDescriptor) AArch32.S1TranslateLD(FaultRecord fault_in, Regime regime,&#13; bits(32) va, boolean aligned,&#13; AccessDescriptor accdesc)">AArch32.S1TranslateLD</a>(fault, regime, address&lt;31:0&gt;, aligned,
                                                      accdesc);
        else
            (fault, addrdesc, -) = <a href="shared_pseudocode.html#AArch32.S1TranslateSD.5" title="function: (FaultRecord, AddressDescriptor, SDFType) AArch32.S1TranslateSD(FaultRecord fault_in, Regime regime,&#13; bits(32) va, boolean aligned,&#13; AccessDescriptor accdesc)">AArch32.S1TranslateSD</a>(fault, regime, address&lt;31:0&gt;, aligned,
                                                         accdesc);
    else
        (fault, addrdesc) = <a href="shared_pseudocode.html#AArch64.S1Translate.5" title="function: (FaultRecord, AddressDescriptor) AArch64.S1Translate(FaultRecord fault_in, Regime regime,&#13; bits(64) va, boolean aligned,&#13; AccessDescriptor accdesc)">AArch64.S1Translate</a>(fault, regime, address, aligned, accdesc);

    if stage == <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        boolean s1aarch64;
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
            addrdesc.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64);
            (fault, addrdesc) = <a href="shared_pseudocode.html#AArch32.S2Translate.4" title="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean aligned, AccessDescriptor accdesc)">AArch32.S2Translate</a>(fault, addrdesc, aligned, accdesc);
        elsif regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
            s1aarch64 = TRUE;
            (fault, addrdesc) = <a href="shared_pseudocode.html#AArch64.S2Translate.5" title="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean s1aarch64, boolean aligned,&#13; AccessDescriptor accdesc)">AArch64.S2Translate</a>(fault, addrdesc, s1aarch64, aligned, accdesc);

    is_ATS1Ex = stage != <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a>;
    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        addrdesc = <a href="shared_pseudocode.html#impl-shared.CreateFaultyAddressDescriptor.2" title="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(address, fault);
        // Take an exception on:
        // * A Synchronous External abort occurs on translation table walk
        // * A stage 2 fault occurs on a stage 1 walk
        // * A GPC Exception (FEAT_RME)
        // * A GPF from ATS1E{1,0}* when executed from EL1 and HCR_EL2.GPF == '1' (FEAT_RME)
        if (<a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) ||
                (PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; fault.s2fs1walk) ||
                (<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> &amp;&amp; (
                    <a href="shared_pseudocode.html#impl-shared.ReportAsGPCException.1" title="function: boolean ReportAsGPCException(FaultRecord fault)">ReportAsGPCException</a>(fault) ||
                    (HCR_EL2.GPF == '1' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; el IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>} &amp;&amp; is_ATS1Ex)
                ))) then
            PAR_EL1 = bits(128) UNKNOWN;
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, addrdesc.fault);

    <a href="shared_pseudocode.html#AArch64.EncodePAR.3" title="function: AArch64.EncodePAR(Regime regime, boolean is_ATS1Ex, AddressDescriptor addrdesc)">AArch64.EncodePAR</a>(regime, is_ATS1Ex, addrdesc);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.at.AArch64.EncodePAR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/at/AArch64.EncodePAR</h3>
      <p class="pseudocode">// AArch64.EncodePAR()
// ===================
// Encode PAR register with result of translation.

<a id="AArch64.EncodePAR.3"/>AArch64.EncodePAR(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, boolean is_ATS1Ex, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> addrdesc)
    PAR_EL1 = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(128);
    paspace = addrdesc.paddress.paspace;

    if !<a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(addrdesc) then
        PAR_EL1.F = '0';
        if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
            if regime == <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a> then
                case paspace of
                    when <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>     PAR_EL1.&lt;NSE,NS&gt; = '00';
                    when <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>  PAR_EL1.&lt;NSE,NS&gt; = '01';
                    when <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>       PAR_EL1.&lt;NSE,NS&gt; = '10';
                    when <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>      PAR_EL1.&lt;NSE,NS&gt; = '11';

            elsif <a href="shared_pseudocode.html#impl-shared.SecurityStateForRegime.1" title="function: SecurityState SecurityStateForRegime(Regime regime)">SecurityStateForRegime</a>(regime) == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>  then
                PAR_EL1.NSE = bit UNKNOWN;
                PAR_EL1.NS = if paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then '0' else '1';

            elsif <a href="shared_pseudocode.html#impl-shared.SecurityStateForRegime.1" title="function: SecurityState SecurityStateForRegime(Regime regime)">SecurityStateForRegime</a>(regime) == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> then
                if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; is_ATS1Ex then
                    PAR_EL1.NSE = bit UNKNOWN;
                    PAR_EL1.NS  = bit UNKNOWN;
                else
                    PAR_EL1.NSE = bit UNKNOWN;
                    PAR_EL1.NS  = if paspace == <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> then '0' else '1';

            else
                PAR_EL1.NSE = bit UNKNOWN;
                PAR_EL1.NS  = bit UNKNOWN;
        else
            PAR_EL1&lt;11&gt; = '1'; // RES1
            if <a href="shared_pseudocode.html#impl-shared.SecurityStateForRegime.1" title="function: SecurityState SecurityStateForRegime(Regime regime)">SecurityStateForRegime</a>(regime) == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
                PAR_EL1.NS = if paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then '0' else '1';
            else
                PAR_EL1.NS = bit UNKNOWN;
        PAR_EL1.SH   = ReportedPARShareability(<a href="shared_pseudocode.html#impl-shared.PAREncodeShareability.1" title="function: bits(2) PAREncodeShareability(MemoryAttributes memattrs)">PAREncodeShareability</a>(addrdesc.memattrs));
        if <a href="shared_pseudocode.html#AArch64.IsVMSAv9_128.2" title="function: boolean AArch64.IsVMSAv9_128(Regime regime, boolean is_ATS1Ex)">AArch64.IsVMSAv9_128</a>(regime, is_ATS1Ex) then
            PAR_EL1.D128 = '1';
            PAR_EL1&lt;119:76&gt; = addrdesc.paddress.address&lt;55:12&gt;;
        else
            PAR_EL1.D128 = '0';
            PAR_EL1&lt;55:12&gt; = addrdesc.paddress.address&lt;55:12&gt;;
        PAR_EL1.ATTR = ReportedPARAttrs(<a href="shared_pseudocode.html#impl-shared.EncodePARAttrs.1" title="function: bits(8) EncodePARAttrs(MemoryAttributes memattrs)">EncodePARAttrs</a>(addrdesc.memattrs));
        PAR_EL1&lt;10&gt; = bit IMPLEMENTATION_DEFINED "Non-Faulting PAR";
    else
        PAR_EL1.F   = '1';
        PAR_EL1.DirtyBit    = if addrdesc.fault.dirtybit then '1' else '0';
        PAR_EL1.Overlay     = if addrdesc.fault.overlay then '1' else '0';
        PAR_EL1.TopLevel    = if addrdesc.fault.toplevel then '1' else '0';
        PAR_EL1.AssuredOnly = if addrdesc.fault.assuredonly then '1' else '0';
        PAR_EL1.FST = <a href="shared_pseudocode.html#AArch64.PARFaultStatus.1" title="function: bits(6) AArch64.PARFaultStatus(FaultRecord fault)">AArch64.PARFaultStatus</a>(addrdesc.fault);
        PAR_EL1.PTW = if addrdesc.fault.s2fs1walk then '1' else '0';
        PAR_EL1.S   = if addrdesc.fault.secondstage then '1' else '0';
        PAR_EL1&lt;11&gt; = '1'; // RES1
        PAR_EL1&lt;63:48&gt; = bits(16) IMPLEMENTATION_DEFINED "Faulting PAR";
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.at.AArch64.IsVMSAv9_128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/at/AArch64.IsVMSAv9_128</h3>
      <p class="pseudocode">// AArch64.IsVMSAv9_128()
// ======================
// Check if the Translation Regime uses VMSAv9-128.

boolean <a id="AArch64.IsVMSAv9_128.2"/>AArch64.IsVMSAv9_128(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, boolean is_ATS1Ex)
    boolean is_VMSAv9_128;
    // Regime_EL2 does not support VMSAv9-128
    if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> || !<a href="shared_pseudocode.html#impl-shared.Have128BitDescriptorExt.0" title="function: boolean Have128BitDescriptorExt()">Have128BitDescriptorExt</a>() then
        is_VMSAv9_128 = FALSE;
    else
        is_VMSAv9_128 = FALSE;
        case regime of
            when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>
                is_VMSAv9_128 = TCR_EL3.D128 == '1';
            when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>
                is_VMSAv9_128 = TCR2_EL2.D128 == '1';
            when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>
                if (is_ATS1Ex || (HCR_EL2.&lt;VM,DC&gt; == '00')) then
                    is_VMSAv9_128 = TCR2_EL1.D128 == '1';
                else
                    is_VMSAv9_128 = VTCR_EL2.D128 == '1';

    return is_VMSAv9_128;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.at.AArch64.PARFaultStatus"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/at/AArch64.PARFaultStatus</h3>
      <p class="pseudocode">// AArch64.PARFaultStatus()
// ========================
// Fault status field decoding of 64-bit PAR.

bits(6) <a id="AArch64.PARFaultStatus.1"/>AArch64.PARFaultStatus(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    bits(6) fst;

    if fault.statuscode == <a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a> then
        // Report Domain fault
        assert fault.level IN {1,2};
        fst&lt;1:0&gt; = if fault.level == 1 then '01' else '10';
        fst&lt;5:2&gt; = '1111';
    else
        fst = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);
    return fst;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.at.GetPAR_EL1_D128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/at/GetPAR_EL1_D128</h3>
      <p class="pseudocode">// GetPAR_EL1_D128()
// =================
// Query the PAR_EL1.D128 field

bit <a id="impl-aarch64.GetPAR_EL1_D128.0"/>GetPAR_EL1_D128()
    bit D128;

    D128 = PAR_EL1.D128;
    return D128;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.at.GetPAR_EL1_F"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/at/GetPAR_EL1_F</h3>
      <p class="pseudocode">// GetPAR_EL1_F()
// ==============
// Query the PAR_EL1.F field.

bit <a id="impl-aarch64.GetPAR_EL1_F.0"/>GetPAR_EL1_F()
    bit F;

    F = PAR_EL1.F;
    return F;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.dc.AArch64.DC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/dc/AArch64.DC</h3>
      <p class="pseudocode">// AArch64.DC()
// ============
// Perform Data Cache Operation.

<a id="AArch64.DC.4"/>AArch64.DC(bits(64) regval, <a href="shared_pseudocode.html#CacheType" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype, <a href="shared_pseudocode.html#CacheOp" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp</a> cacheop, <a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope_in)
    <a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope = opscope_in;
    <a href="shared_pseudocode.html#CacheRecord" title="type CacheRecord is ( AccessType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache;

    cache.acctype   = <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>;
    cache.cachetype = cachetype;
    cache.cacheop   = cacheop;
    cache.opscope   = opscope;

    if opscope == <a href="shared_pseudocode.html#CacheOpScope_SetWay" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_SetWay</a> then
        ss = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
        cache.cpas = <a href="shared_pseudocode.html#impl-shared.CPASAtSecurityState.1" title="function: CachePASpace CPASAtSecurityState(SecurityState ss)">CPASAtSecurityState</a>(ss);
        cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        (cache.set, cache.way, cache.level) = <a href="shared_pseudocode.html#impl-shared.DecodeSW.2" title="function: (integer, integer, integer) DecodeSW(bits(64) regval, CacheType cachetype)">DecodeSW</a>(regval, cachetype);
        if (cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
          (HCR_EL2.SWIO == '1' || HCR_EL2.&lt;DC,VM&gt; != '00')) then
            cache.cacheop = <a href="shared_pseudocode.html#CacheOp_CleanInvalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a>;

        <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
        return;

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
            cache.is_vmid_valid = TRUE;
            cache.vmid          = <a href="shared_pseudocode.html#impl-aarch64.VMID.read.0" title="accessor: bits(16) VMID[]">VMID</a>[];
        else
            cache.is_vmid_valid = FALSE;
    else
        cache.is_vmid_valid = FALSE;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        cache.is_asid_valid = TRUE;
        cache.asid          = <a href="shared_pseudocode.html#impl-shared.ASID.read.0" title="accessor: bits(16) ASID[]">ASID</a>[];
    else
        cache.is_asid_valid = FALSE;

    if opscope == <a href="shared_pseudocode.html#CacheOpScope_PoDP" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoDP</a> &amp;&amp; boolean IMPLEMENTATION_DEFINED "Memory system does not supports PoDP" then
        opscope = <a href="shared_pseudocode.html#CacheOpScope_PoP" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoP</a>;
    if opscope == <a href="shared_pseudocode.html#CacheOpScope_PoP" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoP</a> &amp;&amp; boolean IMPLEMENTATION_DEFINED "Memory system does not supports PoP" then
        opscope = <a href="shared_pseudocode.html#CacheOpScope_PoC" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a>;
    need_translate = <a href="shared_pseudocode.html#impl-shared.DCInstNeedsTranslation.1" title="function: boolean DCInstNeedsTranslation(CacheOpScope opscope)">DCInstNeedsTranslation</a>(opscope);
    vaddress = regval;

    size = 0;        // by default no watchpoint address
    if cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> then
        size = integer IMPLEMENTATION_DEFINED "Data Cache Invalidate Watchpoint Size";
        assert size &gt;= 4*(2^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(CTR_EL0.DminLine))) &amp;&amp; size &lt;= 2048;
        assert <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size&lt;32:0&gt; AND (size-1)&lt;32:0&gt;) == 0; // size is power of 2
        vaddress = <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(regval, size);

    cache.translated = need_translate;
    cache.vaddress   = vaddress;

    if need_translate then
        boolean aligned = TRUE;
        <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescDC.1" title="function: AccessDescriptor CreateAccDescDC(CacheRecord cache)">CreateAccDescDC</a>(cache);
        <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(vaddress, accdesc, aligned, size);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(regval, memaddrdesc.fault);

        cache.paddress = memaddrdesc.paddress;
        cache.cpas = <a href="shared_pseudocode.html#impl-shared.CPASAtPAS.1" title="function: CachePASpace CPASAtPAS(PASpace pas)">CPASAtPAS</a>(memaddrdesc.paddress.paspace);
        if opscope IN {<a href="shared_pseudocode.html#CacheOpScope_PoC" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a>, <a href="shared_pseudocode.html#CacheOpScope_PoP" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoP</a>, <a href="shared_pseudocode.html#CacheOpScope_PoDP" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoDP</a>} then
            cache.shareability = memaddrdesc.memattrs.shareability;
        else
            cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
    else
        cache.shareability = <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> UNKNOWN;
        cache.paddress     = <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> UNKNOWN;

    if (cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
            HCR_EL2.&lt;DC,VM&gt; != '00') then
        cache.cacheop = <a href="shared_pseudocode.html#CacheOp_CleanInvalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a>;

    <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.dc.AArch64.MemZero"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/dc/AArch64.MemZero</h3>
      <p class="pseudocode">// AArch64.MemZero()
// =================

<a id="AArch64.MemZero.2"/>AArch64.MemZero(bits(64) regval, <a href="shared_pseudocode.html#CacheType" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype)
    integer size = 4*(2^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DCZID_EL0.BS)));
    assert size &lt;= <a href="shared_pseudocode.html#MAX_ZERO_BLOCK_SIZE" title="constant integer MAX_ZERO_BLOCK_SIZE = 2048">MAX_ZERO_BLOCK_SIZE</a>;
    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        assert size &gt;= <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>;

    bits(64) vaddress = <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(regval, size);

    boolean tagaccess = cachetype IN {<a href="shared_pseudocode.html#CacheType_Tag" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Tag</a>, <a href="shared_pseudocode.html#CacheType_Data_Tag" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data_Tag</a>};
    boolean tagchecked = cachetype == <a href="shared_pseudocode.html#CacheType_Data" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data</a>;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescDCZero.2" title="function: AccessDescriptor CreateAccDescDCZero(boolean tagaccess, boolean tagchecked)">CreateAccDescDCZero</a>(tagaccess, tagchecked);

    if cachetype IN {<a href="shared_pseudocode.html#CacheType_Tag" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Tag</a>, <a href="shared_pseudocode.html#CacheType_Data_Tag" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data_Tag</a>} then
        <a href="shared_pseudocode.html#AArch64.TagMemZero.4" title="function: AArch64.TagMemZero(bits(64) regval, bits(64) vaddress, AccessDescriptor accdesc_in, integer size)">AArch64.TagMemZero</a>(regval, vaddress, accdesc, size);

    if cachetype IN {<a href="shared_pseudocode.html#CacheType_Data" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data</a>, <a href="shared_pseudocode.html#CacheType_Data_Tag" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data_Tag</a>} then
        <a href="shared_pseudocode.html#AArch64.DataMemZero.4" title="function: AArch64.DataMemZero(bits(64) regval, bits(64) vaddress, AccessDescriptor accdesc_in, integer size)">AArch64.DataMemZero</a>(regval, vaddress, accdesc, size);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.dc.MemZero"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/dc/MemZero</h3>
      <p class="pseudocode">constant integer <a id="MAX_ZERO_BLOCK_SIZE"/>MAX_ZERO_BLOCK_SIZE = 2048;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.ic.AArch64.IC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/ic/AArch64.IC</h3>
      <p class="pseudocode">// AArch64.IC()
// ============
// Perform Instruction Cache Operation.

<a id="AArch64.IC.1"/>AArch64.IC(<a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    regval = bits(64) UNKNOWN;
    <a href="shared_pseudocode.html#AArch64.IC.2" title="function: AArch64.IC(bits(64) regval, CacheOpScope opscope)">AArch64.IC</a>(regval, opscope);

// AArch64.IC()
// ============
// Perform Instruction Cache Operation.

<a id="AArch64.IC.2"/>AArch64.IC(bits(64) regval, <a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    <a href="shared_pseudocode.html#CacheRecord" title="type CacheRecord is ( AccessType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache;

    cache.acctype   = <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>;
    cache.cachetype = <a href="shared_pseudocode.html#CacheType_Instruction" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Instruction</a>;
    cache.cacheop   = <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a>;
    cache.opscope   = opscope;

    if opscope IN {<a href="shared_pseudocode.html#CacheOpScope_ALLU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</a>, <a href="shared_pseudocode.html#CacheOpScope_ALLUIS" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</a>} then
        ss = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
        cache.cpas = <a href="shared_pseudocode.html#impl-shared.CPASAtSecurityState.1" title="function: CachePASpace CPASAtSecurityState(SecurityState ss)">CPASAtSecurityState</a>(ss);
        if (opscope == <a href="shared_pseudocode.html#CacheOpScope_ALLUIS" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</a> || (opscope == <a href="shared_pseudocode.html#CacheOpScope_ALLU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.FB == '1')) then
            cache.shareability = <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
        else
            cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        cache.regval = regval;
        <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    else
        assert opscope == <a href="shared_pseudocode.html#CacheOpScope_PoU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoU</a>;

        if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
                cache.is_vmid_valid = TRUE;
                cache.vmid          = <a href="shared_pseudocode.html#impl-aarch64.VMID.read.0" title="accessor: bits(16) VMID[]">VMID</a>[];
            else
                cache.is_vmid_valid = FALSE;
        else
            cache.is_vmid_valid = FALSE;

        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            cache.is_asid_valid = TRUE;
            cache.asid          = <a href="shared_pseudocode.html#impl-shared.ASID.read.0" title="accessor: bits(16) ASID[]">ASID</a>[];
        else
            cache.is_asid_valid = FALSE;

        bits(64) vaddress = regval;
        boolean need_translate = <a href="shared_pseudocode.html#impl-shared.ICInstNeedsTranslation.1" title="function: boolean ICInstNeedsTranslation(CacheOpScope opscope)">ICInstNeedsTranslation</a>(opscope);

        cache.vaddress     = regval;
        cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        cache.translated   = need_translate;

        if !need_translate then
            cache.paddress = <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> UNKNOWN;
            <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
            return;

        <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescIC.1" title="function: AccessDescriptor CreateAccDescIC(CacheRecord cache)">CreateAccDescIC</a>(cache);
        boolean aligned = TRUE;
        integer size = 0;
        <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.4" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccessDescriptor accdesc,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(vaddress, accdesc, aligned, size);

        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(regval, memaddrdesc.fault);

        cache.cpas     = <a href="shared_pseudocode.html#impl-shared.CPASAtPAS.1" title="function: CachePASpace CPASAtPAS(PASpace pas)">CPASAtPAS</a>(memaddrdesc.paddress.paspace);
        cache.paddress = memaddrdesc.paddress;
        <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.predictionrestrict.AArch64.RestrictPrediction"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/predictionrestrict/AArch64.RestrictPrediction</h3>
      <p class="pseudocode">// AArch64.RestrictPrediction()
// ============================
// Clear all predictions in the context.

<a id="AArch64.RestrictPrediction.2"/>AArch64.RestrictPrediction(bits(64) val, <a href="shared_pseudocode.html#RestrictType" title="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch,&#13; RestrictType_Other }">RestrictType</a> restriction)

    <a href="shared_pseudocode.html#ExecutionCntxt" title="type ExecutionCntxt is ( boolean is_vmid_valid, boolean all_vmid, bits(16) vmid, boolean is_asid_valid, boolean all_asid, bits(16) asid, bits(2) target_el, SecurityState security, RestrictType restriction )">ExecutionCntxt</a> c;
    target_el    = val&lt;25:24&gt;;

    // If the target EL is not implemented or the instruction is executed at an
    // EL lower than the specified level, the instruction is treated as a NOP.
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) || <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();

    bit ns  = val&lt;26&gt;;
    bit nse = val&lt;27&gt;;
    ss = <a href="shared_pseudocode.html#impl-shared.TargetSecurityState.2" title="function: SecurityState TargetSecurityState(bit NS, bit NSE)">TargetSecurityState</a>(ns, nse);
    if ss == <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a> &amp;&amp; target_el != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();

    c.security  = ss;
    c.target_el = target_el;

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = FALSE;
            c.vmid          = <a href="shared_pseudocode.html#impl-aarch64.VMID.read.0" title="accessor: bits(16) VMID[]">VMID</a>[];

        elsif target_el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = val&lt;48&gt; == '1';
            c.vmid          = val&lt;47:32&gt;;           // Only valid if  val&lt;48&gt; == '0';
        else
            c.is_vmid_valid = FALSE;
    else
        c.is_vmid_valid = FALSE;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = FALSE;
        c.asid          = <a href="shared_pseudocode.html#impl-shared.ASID.read.0" title="accessor: bits(16) ASID[]">ASID</a>[];

    elsif target_el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = val&lt;16&gt; == '1';
        c.asid          = val&lt;15:0&gt;;                  // Only valid if  val&lt;16&gt; == '0';

    else
        c.is_asid_valid = FALSE;

    c.restriction = restriction;
    <a href="shared_pseudocode.html#impl-shared.RESTRICT_PREDICTIONS.1" title="function: RESTRICT_PREDICTIONS(ExecutionCntxt c)">RESTRICT_PREDICTIONS</a>(c);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.sysop.SysOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/sysop/SysOp</h3>
      <p class="pseudocode">// SysOp()
// =======

SystemOp <a id="impl-aarch64.SysOp.4"/>SysOp(bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2)
    case op1:CRn:CRm:op2 of
        when '000 0111 1000 000' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S1E1R
        when '000 0111 1000 001' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S1E1W
        when '000 0111 1000 010' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S1E0R
        when '000 0111 1000 011' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S1E0W
        when '000 0111 1001 000' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S1E1RP
        when '000 0111 1001 001' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S1E1WP
        when '100 0111 1000 000' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S1E2R
        when '100 0111 1000 001' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S1E2W
        when '100 0111 1000 100' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S12E1R
        when '100 0111 1000 101' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S12E1W
        when '100 0111 1000 110' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S12E0R
        when '100 0111 1000 111' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S12E0W
        when '110 0111 1000 000' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S1E3R
        when '110 0111 1000 001' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;    // S1E3W
        when '001 0111 0010 100' return <a href="shared_pseudocode.html#Sys_BRB" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_BRB</a>;   // IALL
        when '001 0111 0010 101' return <a href="shared_pseudocode.html#Sys_BRB" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_BRB</a>;   // INJ
        when '000 0111 0110 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // IVAC
        when '000 0111 0110 010' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // ISW
        when '000 0111 0110 011' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // IGVAC
        when '000 0111 0110 100' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // IGSW
        when '000 0111 0110 101' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // IGDVAC
        when '000 0111 0110 110' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // IGDSW
        when '000 0111 1010 010' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CSW
        when '000 0111 1010 100' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CGSW
        when '000 0111 1010 110' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CGDSW
        when '000 0111 1110 010' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CISW
        when '000 0111 1110 100' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CIGSW
        when '000 0111 1110 110' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CIGDSW
        when '011 0111 0100 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // ZVA
        when '011 0111 0100 011' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // GVA
        when '011 0111 0100 100' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // GZVA
        when '011 0111 1010 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CVAC
        when '011 0111 1010 011' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CGVAC
        when '011 0111 1010 101' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CGDVAC
        when '011 0111 1011 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CVAU
        when '011 0111 1100 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CVAP
        when '011 0111 1100 011' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CGVAP
        when '011 0111 1100 101' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CGDVAP
        when '011 0111 1101 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CVADP
        when '011 0111 1101 011' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CGVADP
        when '011 0111 1101 101' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CGDVADP
        when '011 0111 1110 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CIVAC
        when '011 0111 1110 011' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CIGVAC
        when '011 0111 1110 101' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CIGDVAC
        when '100 0111 1110 000' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CIPAE
        when '100 0111 1110 111' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CIGDPAE
        when '110 0111 1110 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CIPAPA
        when '110 0111 1110 101' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;    // CIGDPAPA
        when '000 0111 0001 000' return <a href="shared_pseudocode.html#Sys_IC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_IC</a>;    // IALLUIS
        when '000 0111 0101 000' return <a href="shared_pseudocode.html#Sys_IC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_IC</a>;    // IALLU
        when '011 0111 0101 001' return <a href="shared_pseudocode.html#Sys_IC" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_IC</a>;    // IVAU
        when '000 1000 0001 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VMALLE1OS
        when '000 1000 0001 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE1OS
        when '000 1000 0001 010' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ASIDE1OS
        when '000 1000 0001 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAAE1OS
        when '000 1000 0001 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE1OS
        when '000 1000 0001 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAALE1OS
        when '000 1000 0010 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE1IS
        when '000 1000 0010 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAAE1IS
        when '000 1000 0010 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE1IS
        when '000 1000 0010 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAALE1IS
        when '000 1000 0011 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VMALLE1IS
        when '000 1000 0011 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE1IS
        when '000 1000 0011 010' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ASIDE1IS
        when '000 1000 0011 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAAE1IS
        when '000 1000 0011 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE1IS
        when '000 1000 0011 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAALE1IS
        when '000 1000 0101 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE1OS
        when '000 1000 0101 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAAE1OS
        when '000 1000 0101 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE1OS
        when '000 1000 0101 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAALE1OS
        when '000 1000 0110 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE1
        when '000 1000 0110 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAAE1
        when '000 1000 0110 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE1
        when '000 1000 0110 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAALE1
        when '000 1000 0111 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VMALLE1
        when '000 1000 0111 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE1
        when '000 1000 0111 010' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ASIDE1
        when '000 1000 0111 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAAE1
        when '000 1000 0111 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE1
        when '000 1000 0111 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAALE1
        when '000 1001 0001 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VMALLE1OSNXS
        when '000 1001 0001 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE1OSNXS
        when '000 1001 0001 010' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ASIDE1OSNXS
        when '000 1001 0001 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAAE1OSNXS
        when '000 1001 0001 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE1OSNXS
        when '000 1001 0001 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAALE1OSNXS
        when '000 1001 0010 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE1ISNXS
        when '000 1001 0010 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAAE1ISNXS
        when '000 1001 0010 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE1ISNXS
        when '000 1001 0010 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAALE1ISNXS
        when '000 1001 0011 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VMALLE1ISNXS
        when '000 1001 0011 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE1ISNXS
        when '000 1001 0011 010' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ASIDE1ISNXS
        when '000 1001 0011 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAAE1ISNXS
        when '000 1001 0011 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE1ISNXS
        when '000 1001 0011 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAALE1ISNXS
        when '000 1001 0101 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE1OSNXS
        when '000 1001 0101 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAAE1OSNXS
        when '000 1001 0101 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE1OSNXS
        when '000 1001 0101 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAALE1OSNXS
        when '000 1001 0110 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE1NXS
        when '000 1001 0110 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAAE1NXS
        when '000 1001 0110 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE1NXS
        when '000 1001 0110 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAALE1NXS
        when '000 1001 0111 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VMALLE1NXS
        when '000 1001 0111 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE1NXS
        when '000 1001 0111 010' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ASIDE1NXS
        when '000 1001 0111 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAAE1NXS
        when '000 1001 0111 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE1NXS
        when '000 1001 0111 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAALE1NXS
        when '100 1000 0000 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // IPAS2E1IS
        when '100 1000 0000 010' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RIPAS2E1IS
        when '100 1000 0000 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // IPAS2LE1IS
        when '100 1000 0000 110' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RIPAS2LE1IS
        when '100 1000 0001 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE2OS
        when '100 1000 0001 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE2OS
        when '100 1000 0001 100' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE1OS
        when '100 1000 0001 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE2OS
        when '100 1000 0001 110' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VMALLS12E1OS
        when '100 1000 0010 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE2IS
        when '100 1000 0010 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE2IS
        when '100 1000 0011 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE2IS
        when '100 1000 0011 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE2IS
        when '100 1000 0011 100' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE1IS
        when '100 1000 0011 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE2IS
        when '100 1000 0011 110' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VMALLS12E1IS
        when '100 1000 0100 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // IPAS2E1OS
        when '100 1000 0100 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // IPAS2E1
        when '100 1000 0100 010' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RIPAS2E1
        when '100 1000 0100 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RIPAS2E1OS
        when '100 1000 0100 100' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // IPAS2LE1OS
        when '100 1000 0100 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // IPAS2LE1
        when '100 1000 0100 110' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RIPAS2LE1
        when '100 1000 0100 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RIPAS2LE1OS
        when '100 1000 0101 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE2OS
        when '100 1000 0101 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE2OS
        when '100 1000 0110 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE2
        when '100 1000 0110 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE2
        when '100 1000 0111 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE2
        when '100 1000 0111 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE2
        when '100 1000 0111 100' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE1
        when '100 1000 0111 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE2
        when '100 1000 0111 110' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VMALLS12E1
        when '100 1001 0000 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // IPAS2E1ISNXS
        when '100 1001 0000 010' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RIPAS2E1ISNXS
        when '100 1001 0000 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // IPAS2LE1ISNXS
        when '100 1001 0000 110' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RIPAS2LE1ISNXS
        when '100 1001 0001 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE2OSNXS
        when '100 1001 0001 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE2OSNXS
        when '100 1001 0001 100' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE1OSNXS
        when '100 1001 0001 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE2OSNXS
        when '100 1001 0001 110' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VMALLS12E1OSNXS
        when '100 1001 0010 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE2ISNXS
        when '100 1001 0010 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE2ISNXS
        when '100 1001 0011 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE2ISNXS
        when '100 1001 0011 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE2ISNXS
        when '100 1001 0011 100' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE1ISNXS
        when '100 1001 0011 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE2ISNXS
        when '100 1001 0011 110' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VMALLS12E1ISNXS
        when '100 1001 0100 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // IPAS2E1OSNXS
        when '100 1001 0100 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // IPAS2E1NXS
        when '100 1001 0100 010' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RIPAS2E1NXS
        when '100 1001 0100 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RIPAS2E1OSNXS
        when '100 1001 0100 100' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // IPAS2LE1OSNXS
        when '100 1001 0100 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // IPAS2LE1NXS
        when '100 1001 0100 110' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RIPAS2LE1NXS
        when '100 1001 0100 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RIPAS2LE1OSNXS
        when '100 1001 0101 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE2OSNXS
        when '100 1001 0101 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE2OSNXS
        when '100 1001 0110 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE2NXS
        when '100 1001 0110 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE2NXS
        when '100 1001 0111 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE2NXS
        when '100 1001 0111 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE2NXS
        when '100 1001 0111 100' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE1NXS
        when '100 1001 0111 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE2NXS
        when '100 1001 0111 110' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VMALLS12E1NXS
        when '110 1000 0001 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE3OS
        when '110 1000 0001 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE3OS
        when '110 1000 0001 100' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // PAALLOS
        when '110 1000 0001 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE3OS
        when '110 1000 0010 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE3IS
        when '110 1000 0010 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE3IS
        when '110 1000 0011 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE3IS
        when '110 1000 0011 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE3IS
        when '110 1000 0011 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE3IS
        when '110 1000 0100 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RPAOS
        when '110 1000 0100 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RPALOS
        when '110 1000 0101 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE3OS
        when '110 1000 0101 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE3OS
        when '110 1000 0110 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE3
        when '110 1000 0110 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE3
        when '110 1000 0111 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE3
        when '110 1000 0111 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE3
        when '110 1000 0111 100' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // PAALL
        when '110 1000 0111 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE3
        when '110 1001 0001 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE3OSNXS
        when '110 1001 0001 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE3OSNXS
        when '110 1001 0001 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE3OSNXS
        when '110 1001 0010 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE3ISNXS
        when '110 1001 0010 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE3ISNXS
        when '110 1001 0011 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE3ISNXS
        when '110 1001 0011 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE3ISNXS
        when '110 1001 0011 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE3ISNXS
        when '110 1001 0101 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE3OSNXS
        when '110 1001 0101 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE3OSNXS
        when '110 1001 0110 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVAE3NXS
        when '110 1001 0110 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // RVALE3NXS
        when '110 1001 0111 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // ALLE3NXS
        when '110 1001 0111 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VAE3NXS
        when '110 1001 0111 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>;  // VALE3NXS
        otherwise                return <a href="shared_pseudocode.html#Sys_SYS" title="enumeration SystemOp {Sys_AT, Sys_BRB, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_SYS</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.sysop.SystemOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/sysop/SystemOp</h3>
      <p class="pseudocode">enumeration <a id="SystemOp"/>SystemOp {<a id="Sys_AT"/>Sys_AT, <a id="Sys_BRB"/>Sys_BRB, <a id="Sys_DC"/>Sys_DC, <a id="Sys_IC"/>Sys_IC, <a id="Sys_TLBI"/>Sys_TLBI, <a id="Sys_SYS"/>Sys_SYS};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.DTLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.DTLBI_ALL</h3>
      <p class="pseudocode">// AArch32.DTLBI_ALL()
// ===================
// Invalidate all data TLB entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.

<a id="AArch32.DTLBI_ALL.4"/>AArch32.DTLBI_ALL(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_DALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_DALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.DTLBI_ASID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.DTLBI_ASID</h3>
      <p class="pseudocode">// AArch32.DTLBI_ASID()
// ====================
// Invalidate all data TLB stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Rt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated shareability domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch32.DTLBI_ASID.6"/>AArch32.DTLBI_ASID(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability,
                   <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_DASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_DASID</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.DTLBI_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.DTLBI_VA</h3>
      <p class="pseudocode">// AArch32.DTLBI_VA()
// ==================
// Invalidate by VA all stage 1 data TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch32.DTLBI_VA.7"/>AArch32.DTLBI_VA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level,  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_DVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_DVA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32) : Rt&lt;31:12&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12);

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.ITLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.ITLBI_ALL</h3>
      <p class="pseudocode">// AArch32.ITLBI_ALL()
// ===================
// Invalidate all instruction TLB entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.

<a id="AArch32.ITLBI_ALL.4"/>AArch32.ITLBI_ALL(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_IALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.ITLBI_ASID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.ITLBI_ASID</h3>
      <p class="pseudocode">// AArch32.ITLBI_ASID()
// ====================
// Invalidate all instruction TLB stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Rt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated shareability domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch32.ITLBI_ASID.6"/>AArch32.ITLBI_ASID(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability,
                   <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_IASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IASID</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.ITLBI_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.ITLBI_VA</h3>
      <p class="pseudocode">// AArch32.ITLBI_VA()
// ==================
// Invalidate by VA all stage 1 instruction TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch32.ITLBI_VA.7"/>AArch32.ITLBI_VA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level,  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_IVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IVA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32) : Rt&lt;31:12&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12);

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_ALL</h3>
      <p class="pseudocode">// AArch32.TLBI_ALL()
// ==================
// Invalidate all entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.

<a id="AArch32.TLBI_ALL.4"/>AArch32.TLBI_ALL(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_ALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_ALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_ASID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_ASID</h3>
      <p class="pseudocode">// AArch32.TLBI_ASID()
// ===================
// Invalidate all stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Rt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated shareability domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch32.TLBI_ASID.6"/>AArch32.TLBI_ASID(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability,
                  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_ASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_ASID</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_IPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_IPAS2</h3>
      <p class="pseudocode">// AArch32.TLBI_IPAS2()
// ====================
// Invalidate by IPA all stage 2 only TLB entries in the indicated shareability
// domain matching the indicated VMID in the indicated regime with the indicated security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// IPA and related parameters of the are derived from Rt.

<a id="AArch32.TLBI_IPAS2.7"/>AArch32.TLBI_IPAS2(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                   <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};
    assert security == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_IPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IPAS2</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.address      = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24) : Rt&lt;27:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12);
    r.ipaspace     = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_VA</h3>
      <p class="pseudocode">// AArch32.TLBI_VA()
// =================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch32.TLBI_VA.7"/>AArch32.TLBI_VA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level,  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32) : Rt&lt;31:12&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12);

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_VAA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_VAA</h3>
      <p class="pseudocode">// AArch32.TLBI_VAA()
// ==================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID (where regime supports VMID) and all ASID in the indicated regime
// with the indicated security state.
// VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch32.TLBI_VAA.7"/>AArch32.TLBI_VAA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr,  bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VAA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.address      = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32) : Rt&lt;31:12&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12);

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_VMALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_VMALL</h3>
      <p class="pseudocode">// AArch32.TLBI_VMALL()
// ====================
// Invalidate all stage 1 entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability
// domain that match the indicated VMID (where applicable).
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// Note: stage 2 only entries are not in the scope of this operation.

<a id="AArch32.TLBI_VMALL.5"/>AArch32.TLBI_VMALL(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                   <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VMALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VMALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_VMALLS12"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_VMALLS12</h3>
      <p class="pseudocode">// AArch32.TLBI_VMALLS12()
// =======================
// Invalidate all stage 1 and stage 2 entries for the indicated translation
// regime with the indicated security state for all TLBs within the indicated
// shareability domain that match the indicated VMID.

<a id="AArch32.TLBI_VMALLS12.5"/>AArch32.TLBI_VMALLS12(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                      <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VMALLS12" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VMALLS12</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBIP_IPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBIP_IPAS2</h3>
      <p class="pseudocode">// AArch64.TLBIP_IPAS2()
// =====================
// Invalidate by IPA all stage 2 only TLB entries in the indicated shareability
// domain matching the indicated VMID in the indicated regime with the indicated security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// IPA and related parameters of the are derived from Xt.

<a id="AArch64.TLBIP_IPAS2.7"/>AArch64.TLBIP_IPAS2(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                    <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(128) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_IPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IPAS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.ttl          = Xt&lt;47:44&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(Xt&lt;107:64&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12), 64);
    r.d64          = r.ttl IN {'00xx'};
    r.d128         = TRUE;

    case security of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            r.ipaspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
            r.ipaspace = if Xt&lt;63&gt; == '1' then <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> else <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
            r.ipaspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
        otherwise
            // Root security state does not have stage 2 translation
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBIP_RIPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBIP_RIPAS2</h3>
      <p class="pseudocode">// AArch64.TLBIP_RIPAS2()
// ======================
// Range invalidate by IPA all stage 2 only TLB entries in the indicated
// shareability domain matching the indicated VMID in the indicated regime with the indicated
// security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// The range of IPA and related parameters of the are derived from Xt.

<a id="AArch64.TLBIP_RIPAS2.7"/>AArch64.TLBIP_RIPAS2(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                     <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(128) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_RIPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RIPAS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.ttl&lt;1:0&gt;     = Xt&lt;38:37&gt;;
    r.d64          = r.ttl&lt;1:0&gt; == '00';
    r.d128         = TRUE;

    bits(2) tg        = Xt&lt;47:46&gt;;
    integer scale     = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;45:44&gt;);
    integer num       = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;43:39&gt;);
    integer baseaddr  = <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(Xt&lt;36:0&gt;);

    boolean valid;

    (valid, r.tg, r.address, r.end_address) = <a href="shared_pseudocode.html#impl-aarch64.TLBIPRange.2" title="function: (boolean, bits(2), bits(64), bits(64)) TLBIPRange(Regime regime, bits(128) Xt)">TLBIPRange</a>(regime, Xt);

    if !valid then return;

    case security of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            r.ipaspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
            r.ipaspace = if Xt&lt;63&gt; == '1' then <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> else <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
            r.ipaspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
        otherwise
            // Root security state does not have stage 2 translation
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBIP_RVA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBIP_RVA</h3>
      <p class="pseudocode">// AArch64.TLBIP_RVA()
// ===================
// Range invalidate by VA range all stage 1 TLB entries in the indicated
// shareability domain matching the indicated VMID and ASID (where regime
// supports VMID, ASID) in the indicated regime with the indicated security state.
// ASID, and range related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch64.TLBIP_RVA.7"/>AArch64.TLBIP_RVA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                  <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(128)  Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_RVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RVA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = Xt&lt;63:48&gt;;
    r.ttl&lt;1:0&gt;     = Xt&lt;38:37&gt;;
    r.d64          = r.ttl&lt;1:0&gt; == '00';
    r.d128         = TRUE;

    boolean valid;

    (valid, r.tg, r.address, r.end_address) = <a href="shared_pseudocode.html#impl-aarch64.TLBIPRange.2" title="function: (boolean, bits(2), bits(64), bits(64)) TLBIPRange(Regime regime, bits(128) Xt)">TLBIPRange</a>(regime, Xt);

    if !valid then return;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBIP_RVAA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBIP_RVAA</h3>
      <p class="pseudocode">// AArch64.TLBIP_RVAA()
// ====================
// Range invalidate by VA range all stage 1 TLB entries in the indicated
// shareability domain matching the indicated VMID (where regimesupports VMID)
// and all ASID in the indicated regime with the indicated security state.
// VA range related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch64.TLBIP_RVAA.7"/>AArch64.TLBIP_RVAA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a>  regime, bits(16) vmid,
                   <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(128) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_RVAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RVAA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.ttl&lt;1:0&gt;     = Xt&lt;38:37&gt;;
    r.d64          = r.ttl&lt;1:0&gt; == '00';
    r.d128         = TRUE;

    bits(2) tg        = Xt&lt;47:46&gt;;
    integer scale     = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;45:44&gt;);
    integer num       = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;43:39&gt;);
    integer baseaddr  = <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(Xt&lt;36:0&gt;);

    boolean valid;

    (valid, r.tg, r.address, r.end_address) = <a href="shared_pseudocode.html#impl-aarch64.TLBIPRange.2" title="function: (boolean, bits(2), bits(64), bits(64)) TLBIPRange(Regime regime, bits(128) Xt)">TLBIPRange</a>(regime, Xt);

    if !valid then return;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBIP_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBIP_VA</h3>
      <p class="pseudocode">// AArch64.TLBIP_VA()
// ==================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch64.TLBIP_VA.7"/>AArch64.TLBIP_VA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level,  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(128) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = Xt&lt;63:48&gt;;
    r.ttl          = Xt&lt;47:44&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(Xt&lt;107:64&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12), 64);
    r.d64          = r.ttl IN {'00xx'};
    r.d128         = TRUE;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBIP_VAA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBIP_VAA</h3>
      <p class="pseudocode">// AArch64.TLBIP_VAA()
// ===================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID (where regime supports VMID) and all ASID in the indicated regime
// with the indicated security state.
// VA and related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch64.TLBIP_VAA.7"/>AArch64.TLBIP_VAA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                  <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr,  bits(128) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VAA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.ttl          = Xt&lt;47:44&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(Xt&lt;107:64&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12), 64);
    r.d64          = r.ttl IN {'00xx'};
    r.d128         = TRUE;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_ALL</h3>
      <p class="pseudocode">// AArch64.TLBI_ALL()
// ==================
// Invalidate all entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.

<a id="AArch64.TLBI_ALL.4"/>AArch64.TLBI_ALL(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_ALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_ALL</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_ASID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_ASID</h3>
      <p class="pseudocode">// AArch64.TLBI_ASID()
// ===================
// Invalidate all stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Xt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated shareability domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch64.TLBI_ASID.6"/>AArch64.TLBI_ASID(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability,
                  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_ASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_ASID</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = Xt&lt;63:48&gt;;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_IPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_IPAS2</h3>
      <p class="pseudocode">// AArch64.TLBI_IPAS2()
// ====================
// Invalidate by IPA all stage 2 only TLB entries in the indicated shareability
// domain matching the indicated VMID in the indicated regime with the indicated security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// IPA and related parameters of the are derived from Xt.

<a id="AArch64.TLBI_IPAS2.7"/>AArch64.TLBI_IPAS2(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                   <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_IPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IPAS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.ttl          = Xt&lt;47:44&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(Xt&lt;39:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12), 64);
    r.d64          = TRUE;
    r.d128         = r.ttl IN {'00xx'};

    case security of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            r.ipaspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
            r.ipaspace = if Xt&lt;63&gt; == '1' then <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> else <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
            r.ipaspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
        otherwise
            // Root security state does not have stage 2 translation
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_PAALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_PAALL</h3>
      <p class="pseudocode">// AArch64.TLBI_PAALL()
// ====================
// TLB Invalidate ALL GPT Information.
// Invalidates cached copies of GPT entries from TLBs in the indicated
// Shareabilty domain.
// The invalidation applies to all TLB entries containing GPT information.

<a id="AArch64.TLBI_PAALL.1"/>AArch64.TLBI_PAALL(<a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability)
    assert <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;

    // r.security and r.regime do not apply for TLBI by PA operations
    r.op    = <a href="shared_pseudocode.html#TLBIOp_PAALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_PAALL</a>;
    r.level = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.attr  = <a href="shared_pseudocode.html#TLBI_AllAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBI_AllAttr</a>;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_RIPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_RIPAS2</h3>
      <p class="pseudocode">// AArch64.TLBI_RIPAS2()
// =====================
// Range invalidate by IPA all stage 2 only TLB entries in the indicated
// shareability domain matching the indicated VMID in the indicated regime with the indicated
// security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// The range of IPA and related parameters of the are derived from Xt.

<a id="AArch64.TLBI_RIPAS2.7"/>AArch64.TLBI_RIPAS2(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                    <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_RIPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RIPAS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.ttl&lt;1:0&gt;     = Xt&lt;38:37&gt;;
    r.d64          = TRUE;
    r.d128         = r.ttl&lt;1:0&gt; == '00';

    bits(2) tg        = Xt&lt;47:46&gt;;
    integer scale     = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;45:44&gt;);
    integer num       = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;43:39&gt;);
    integer baseaddr  = <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(Xt&lt;36:0&gt;);

    boolean valid;

    (valid, r.tg, r.address, r.end_address) = <a href="shared_pseudocode.html#impl-aarch64.TLBIRange.2" title="function: (boolean, bits(2), bits(64), bits(64)) TLBIRange(Regime regime, bits(64) Xt)">TLBIRange</a>(regime, Xt);

    if !valid then return;

    case security of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            r.ipaspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
            r.ipaspace = if Xt&lt;63&gt; == '1' then <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> else <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
            r.ipaspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
        otherwise
            // Root security state does not have stage 2 translation
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_RPA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_RPA</h3>
      <p class="pseudocode">// AArch64.TLBI_RPA()
// ==================
// TLB Range Invalidate GPT Information by PA.
// Invalidates cached copies of GPT entries from TLBs in the indicated
// Shareabilty domain.
// The invalidation applies to TLB entries containing GPT information relating
// to the indicated physical address range.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries containing GPT information
//                      from all levels of the GPT walk
//     TLBILevel_Last : this applies to TLB entries containing GPT information
//                      from the last level of the GPT walk

<a id="AArch64.TLBI_RPA.3"/>AArch64.TLBI_RPA(<a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, bits(64) Xt, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability)
    assert <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    integer range_bits;
    integer p;

    // r.security and r.regime do not apply for TLBI by PA operations
    r.op    = <a href="shared_pseudocode.html#TLBIOp_RPA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RPA</a>;
    r.level = level;
    r.attr  = <a href="shared_pseudocode.html#TLBI_AllAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBI_AllAttr</a>;

    // SIZE field
    case Xt&lt;47:44&gt; of
        when '0000' range_bits = 12; // 4KB
        when '0001' range_bits = 14; // 16KB
        when '0010' range_bits = 16; // 64KB
        when '0011' range_bits = 21; // 2MB
        when '0100' range_bits = 25; // 32MB
        when '0101' range_bits = 29; // 512MB
        when '0110' range_bits = 30; // 1GB
        when '0111' range_bits = 34; // 16GB
        when '1000' range_bits = 36; // 64GB
        when '1001' range_bits = 39; // 512GB
        otherwise   range_bits = 0;  // Reserved encoding

    // If SIZE selects a range smaller than PGS, then PGS is used instead
    case <a href="shared_pseudocode.html#impl-shared.DecodePGS.1" title="function: PGSe DecodePGS(bits(2) pgs)">DecodePGS</a>(GPCCR_EL3.PGS) of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  p = 12;
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> p = 14;
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> p = 16;

    if range_bits &lt; p then
        range_bits = p;

    bits(52) BaseADDR = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(52);
    case GPCCR_EL3.PGS of
        when '00' BaseADDR&lt;51:12&gt; = Xt&lt;39:0&gt;;   // 4KB
        when '10' BaseADDR&lt;51:14&gt; = Xt&lt;39:2&gt;;   // 16KB
        when '01' BaseADDR&lt;51:16&gt; = Xt&lt;39:4&gt;;   // 64KB

    // The calculation here automatically aligns BaseADDR to the size of
    // the region specififed in SIZE. However, the architecture does not
    // require this alignment and if BaseADDR is not aligned to the region
    // specified by SIZE then no entries are required to be invalidated.
    bits(52) start_addr = BaseADDR AND NOT <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(range_bits), 52);
    bits(52) end_addr   = start_addr + <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(range_bits), 52);

    // PASpace is not considered in TLBI by PA operations
    r.address     = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(start_addr, 64);
    r.end_address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(end_addr, 64);

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_RVA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_RVA</h3>
      <p class="pseudocode">// AArch64.TLBI_RVA()
// ==================
// Range invalidate by VA range all stage 1 TLB entries in the indicated
// shareability domain matching the indicated VMID and ASID (where regime
// supports VMID, ASID) in the indicated regime with the indicated security state.
// ASID, and range related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch64.TLBI_RVA.7"/>AArch64.TLBI_RVA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(64)  Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_RVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RVA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = Xt&lt;63:48&gt;;
    r.ttl&lt;1:0&gt;     = Xt&lt;38:37&gt;;
    r.d64          = TRUE;
    r.d128         = r.ttl&lt;1:0&gt; == '00';

    boolean valid;

    (valid, r.tg, r.address, r.end_address) = <a href="shared_pseudocode.html#impl-aarch64.TLBIRange.2" title="function: (boolean, bits(2), bits(64), bits(64)) TLBIRange(Regime regime, bits(64) Xt)">TLBIRange</a>(regime, Xt);

    if !valid then return;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_RVAA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_RVAA</h3>
      <p class="pseudocode">// AArch64.TLBI_RVAA()
// ===================
// Range invalidate by VA range all stage 1 TLB entries in the indicated
// shareability domain matching the indicated VMID (where regimesupports VMID)
// and all ASID in the indicated regime with the indicated security state.
// VA range related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch64.TLBI_RVAA.7"/>AArch64.TLBI_RVAA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a>  regime, bits(16) vmid,
                  <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_RVAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RVAA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.ttl&lt;1:0&gt;     = Xt&lt;38:37&gt;;
    r.d64          = TRUE;
    r.d128         = r.ttl&lt;1:0&gt; == '00';

    bits(2) tg        = Xt&lt;47:46&gt;;
    integer scale     = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;45:44&gt;);
    integer num       = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;43:39&gt;);
    integer baseaddr  = <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(Xt&lt;36:0&gt;);

    boolean valid;

    (valid, r.tg, r.address, r.end_address) = <a href="shared_pseudocode.html#impl-aarch64.TLBIRange.2" title="function: (boolean, bits(2), bits(64), bits(64)) TLBIRange(Regime regime, bits(64) Xt)">TLBIRange</a>(regime, Xt);

    if !valid then return;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_VA</h3>
      <p class="pseudocode">// AArch64.TLBI_VA()
// =================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch64.TLBI_VA.7"/>AArch64.TLBI_VA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level,  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = Xt&lt;63:48&gt;;
    r.ttl          = Xt&lt;47:44&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(Xt&lt;43:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12), 64);
    r.d64          = TRUE;
    r.d128         = r.ttl IN {'00xx'};

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_VAA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_VAA</h3>
      <p class="pseudocode">// AArch64.TLBI_VAA()
// ==================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID (where regime supports VMID) and all ASID in the indicated regime
// with the indicated security state.
// VA and related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

<a id="AArch64.TLBI_VAA.7"/>AArch64.TLBI_VAA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr,  bits(64) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VAA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.ttl          = Xt&lt;47:44&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(Xt&lt;43:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12), 64);
    r.d64          = TRUE;
    r.d128         = r.ttl IN {'00xx'};

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_VMALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_VMALL</h3>
      <p class="pseudocode">// AArch64.TLBI_VMALL()
// ====================
// Invalidate all stage 1 entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability
// domain that match the indicated VMID (where applicable).
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// Note: stage 2 only entries are not in the scope of this operation.

<a id="AArch64.TLBI_VMALL.5"/>AArch64.TLBI_VMALL(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                   <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VMALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VMALL</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_VMALLS12"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_VMALLS12</h3>
      <p class="pseudocode">// AArch64.TLBI_VMALLS12()
// =======================
// Invalidate all stage 1 and stage 2 entries for the indicated translation
// regime with the indicated security state for all TLBs within the indicated
// shareability domain that match the indicated VMID.

<a id="AArch64.TLBI_VMALLS12.5"/>AArch64.TLBI_VMALLS12(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                      <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VMALLS12" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VMALLS12</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.ASID_NONE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/ASID_NONE</h3>
      <p class="pseudocode">constant bits(16) <a id="ASID_NONE"/>ASID_NONE = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.Broadcast"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/Broadcast</h3>
      <p class="pseudocode">// Broadcast()
// ===========
// IMPLEMENTATION DEFINED function to broadcast TLBI operation within the indicated shareability
// domain.

<a id="impl-aarch64.Broadcast.2"/>Broadcast(<a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r)
    IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.DecodeTLBITG"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/DecodeTLBITG</h3>
      <p class="pseudocode">// DecodeTLBITG()
// ==============
// Decode translation granule size in TLBI range instructions

TGx <a id="impl-aarch64.DecodeTLBITG.1"/>DecodeTLBITG(bits(2) tg)
    case tg of
        when '01'   return <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
        when '10'   return <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;
        when '11'   return <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.GPTTLBIMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/GPTTLBIMatch</h3>
      <p class="pseudocode">// GPTTLBIMatch()
// ==============
// Determine whether the GPT TLB entry lies within the scope of inavlidation

boolean <a id="impl-aarch64.GPTTLBIMatch.2"/>GPTTLBIMatch(<a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> tlbi, <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> entry)
    assert tlbi.op IN {<a href="shared_pseudocode.html#TLBIOp_RPA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RPA</a>, <a href="shared_pseudocode.html#TLBIOp_PAALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_PAALL</a>};

    boolean match;
    case tlbi.op of
        when <a href="shared_pseudocode.html#TLBIOp_RPA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RPA</a>
            match = (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.address&lt;55:entry.size&gt;)     &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.pa&lt;55:entry.size&gt;) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.end_address&lt;55:entry.size&gt;) &gt;  <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.pa&lt;55:entry.size&gt;));
        when <a href="shared_pseudocode.html#TLBIOp_PAALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_PAALL</a>
            match = TRUE;

    return match;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.HasLargeAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/HasLargeAddress</h3>
      <p class="pseudocode">// HasLargeAddress()
// =================
// Returns TRUE if the regime is configured for 52 bit addresses, FALSE otherwise.

boolean <a id="impl-aarch64.HasLargeAddress.1"/>HasLargeAddress(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    if !<a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        return FALSE;
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>
            return TCR_EL3&lt;32&gt; == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>
            return TCR_EL2&lt;32&gt; == '1';
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>
            return TCR_EL2&lt;59&gt; == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>
            return TCR_EL1&lt;59&gt; == '1';
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.ResTLBIRTTL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/ResTLBIRTTL</h3>
      <p class="pseudocode">// ResTLBIRTTL()
// =============
// Determine whether the TTL field in TLBI instructions that do apply
// to a range of addresses contains a reserved value

boolean <a id="impl-aarch64.ResTLBIRTTL.2"/>ResTLBIRTTL(bits(2) tg, bits(2) ttl)
    case ttl of
        when '00' return TRUE;
        when '01' return <a href="shared_pseudocode.html#impl-aarch64.DecodeTLBITG.1" title="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tg) == <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>();
        otherwise return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.ResTLBITTL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/ResTLBITTL</h3>
      <p class="pseudocode">// ResTLBITTL()
// ============
// Determine whether the TTL field in TLBI instructions that do not apply
// to a range of addresses contains a reserved value

boolean <a id="impl-aarch64.ResTLBITTL.1"/>ResTLBITTL(bits(4) ttl)
    case ttl of
        when '00xx' return TRUE;
        when '0100' return !<a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>();
        when '1000' return TRUE;
        when '1001' return !<a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>();
        when '1100' return TRUE;
        otherwise   return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBI"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBI</h3>
      <p class="pseudocode">// TLBI()
// ======
// Invalidates TLB entries for which TLBIMatch() returns TRUE.

<a id="impl-aarch64.TLBI.1"/>TLBI(<a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> r)
    IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBILevel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBILevel</h3>
      <p class="pseudocode">enumeration <a id="TLBILevel"/>TLBILevel {
    <a id="TLBILevel_Any"/>TLBILevel_Any,        // this applies to TLB entries at all levels
    <a id="TLBILevel_Last"/>TLBILevel_Last        // this applies to TLB entries at last level only
};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBIMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBIMatch</h3>
      <p class="pseudocode">// TLBIMatch()
// ===========
// Determine whether the TLB entry lies within the scope of inavlidation

boolean <a id="impl-aarch64.TLBIMatch.2"/>TLBIMatch(<a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, boolean d64, boolean d128, bits(4) ttl, bits(2) tg )">TLBIRecord</a> tlbi, <a href="shared_pseudocode.html#TLBRecord" title="type TLBRecord is ( TLBContext context, TTWState walkstate, integer blocksize, integer contigsize, bits(128) s1descriptor, bits(128) s2descriptor )">TLBRecord</a> entry)
    boolean match;
    case tlbi.op of
        when <a href="shared_pseudocode.html#TLBIOp_DALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_DALL</a>, <a href="shared_pseudocode.html#TLBIOp_IALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IALL</a>
            match = (tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime);
        when <a href="shared_pseudocode.html#TLBIOp_DASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_DASID</a>, <a href="shared_pseudocode.html#TLBIOp_IASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IASID</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (<a href="shared_pseudocode.html#impl-shared.UseASID.1" title="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) &amp;&amp; entry.context.nG == '1' &amp;&amp;
                        tlbi.asid  == entry.context.asid));
        when <a href="shared_pseudocode.html#TLBIOp_DVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_DVA</a>, <a href="shared_pseudocode.html#TLBIOp_IVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IVA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseASID.1" title="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) || tlbi.asid == entry.context.asid ||
                        entry.context.nG == '0') &amp;&amp;
                     tlbi.address&lt;55:entry.blocksize&gt; == entry.context.ia&lt;55:entry.blocksize&gt; &amp;&amp;
                     (tlbi.level == <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a> || !entry.walkstate.istable));
        when <a href="shared_pseudocode.html#TLBIOp_ALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_ALL</a>
            relax_regime = (tlbi.from_aarch64 &amp;&amp;
                            tlbi.regime IN {<a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>, <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>} &amp;&amp;
                            entry.context.regime IN {<a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>, <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>});
            match = (tlbi.security == entry.context.ss &amp;&amp;
                     (tlbi.regime  == entry.context.regime || relax_regime));
        when <a href="shared_pseudocode.html#TLBIOp_ASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_ASID</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (<a href="shared_pseudocode.html#impl-shared.UseASID.1" title="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) &amp;&amp; entry.context.nG == '1' &amp;&amp;
                        tlbi.asid  == entry.context.asid));
        when <a href="shared_pseudocode.html#TLBIOp_IPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IPAS2</a>, <a href="shared_pseudocode.html#TLBIPOp_IPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIPOp_IPAS2</a>
            match = (!entry.context.includes_s1 &amp;&amp; entry.context.includes_s2 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     tlbi.ipaspace == entry.context.ipaspace &amp;&amp;
                     tlbi.address&lt;55:entry.blocksize&gt; == entry.context.ia&lt;55:entry.blocksize&gt; &amp;&amp;
                     (!tlbi.from_aarch64 || <a href="shared_pseudocode.html#impl-aarch64.ResTLBITTL.1" title="function: boolean ResTLBITTL(bits(4) ttl)">ResTLBITTL</a>(tlbi.ttl) || (
                         <a href="shared_pseudocode.html#impl-aarch64.DecodeTLBITG.1" title="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tlbi.ttl&lt;3:2&gt;) == entry.context.tg &amp;&amp;
                         <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.ttl&lt;1:0&gt;) == entry.walkstate.level)
                     ) &amp;&amp;
                     ((tlbi.d128  &amp;&amp; entry.context.isd128) ||
                      (tlbi.d64  &amp;&amp; !entry.context.isd128) ||
                      (tlbi.d64 &amp;&amp; tlbi.d128)) &amp;&amp;
                     (tlbi.level == <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a> || !entry.walkstate.istable));
        when <a href="shared_pseudocode.html#TLBIOp_VAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VAA</a>, <a href="shared_pseudocode.html#TLBIPOp_VAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIPOp_VAA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     tlbi.address&lt;55:entry.blocksize&gt; == entry.context.ia&lt;55:entry.blocksize&gt; &amp;&amp;
                     (!tlbi.from_aarch64 || <a href="shared_pseudocode.html#impl-aarch64.ResTLBITTL.1" title="function: boolean ResTLBITTL(bits(4) ttl)">ResTLBITTL</a>(tlbi.ttl) || (
                         <a href="shared_pseudocode.html#impl-aarch64.DecodeTLBITG.1" title="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tlbi.ttl&lt;3:2&gt;) == entry.context.tg &amp;&amp;
                         <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.ttl&lt;1:0&gt;) == entry.walkstate.level)
                     ) &amp;&amp;
                     ((tlbi.d128  &amp;&amp; entry.context.isd128) ||
                      (tlbi.d64  &amp;&amp; !entry.context.isd128) ||
                      (tlbi.d64 &amp;&amp; tlbi.d128)) &amp;&amp;
                     (tlbi.level == <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a> || !entry.walkstate.istable));
        when <a href="shared_pseudocode.html#TLBIOp_VA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VA</a>, <a href="shared_pseudocode.html#TLBIPOp_VA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIPOp_VA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseASID.1" title="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) || tlbi.asid == entry.context.asid ||
                        entry.context.nG == '0') &amp;&amp;
                     tlbi.address&lt;55:entry.blocksize&gt; == entry.context.ia&lt;55:entry.blocksize&gt; &amp;&amp;
                     (!tlbi.from_aarch64 || <a href="shared_pseudocode.html#impl-aarch64.ResTLBITTL.1" title="function: boolean ResTLBITTL(bits(4) ttl)">ResTLBITTL</a>(tlbi.ttl) || (
                         <a href="shared_pseudocode.html#impl-aarch64.DecodeTLBITG.1" title="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tlbi.ttl&lt;3:2&gt;) == entry.context.tg &amp;&amp;
                         <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.ttl&lt;1:0&gt;) == entry.walkstate.level)
                     ) &amp;&amp;
                     ((tlbi.d128  &amp;&amp; entry.context.isd128) ||
                      (tlbi.d64  &amp;&amp; !entry.context.isd128) ||
                      (tlbi.d64 &amp;&amp; tlbi.d128)) &amp;&amp;
                     (tlbi.level == <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel_Any</a> || !entry.walkstate.istable));
        when <a href="shared_pseudocode.html#TLBIOp_VMALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VMALL</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid));
        when <a href="shared_pseudocode.html#TLBIOp_VMALLS12" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VMALLS12</a>
            match = (tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid));
        when <a href="shared_pseudocode.html#TLBIOp_RIPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RIPAS2</a>, <a href="shared_pseudocode.html#TLBIPOp_RIPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIPOp_RIPAS2</a>
            match = (!entry.context.includes_s1 &amp;&amp; entry.context.includes_s2 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     tlbi.ipaspace == entry.context.ipaspace &amp;&amp;
                     (tlbi.tg != '00' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.DecodeTLBITG.1" title="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tlbi.tg) == entry.context.tg) &amp;&amp;
                     (!tlbi.from_aarch64 || <a href="shared_pseudocode.html#impl-aarch64.ResTLBIRTTL.2" title="function: boolean ResTLBIRTTL(bits(2) tg, bits(2) ttl)">ResTLBIRTTL</a>(tlbi.tg, tlbi.ttl&lt;1:0&gt;) ||
                        <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.ttl&lt;1:0&gt;) == entry.walkstate.level) &amp;&amp;
                     ((tlbi.d128  &amp;&amp; entry.context.isd128) ||
                      (tlbi.d64  &amp;&amp; !entry.context.isd128) ||
                      (tlbi.d64 &amp;&amp; tlbi.d128)) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.address)     &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.end_address) &gt;  <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia));
        when <a href="shared_pseudocode.html#TLBIOp_RVAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RVAA</a>, <a href="shared_pseudocode.html#TLBIPOp_RVAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIPOp_RVAA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (tlbi.tg != '00' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.DecodeTLBITG.1" title="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tlbi.tg) == entry.context.tg) &amp;&amp;
                     (!tlbi.from_aarch64 || <a href="shared_pseudocode.html#impl-aarch64.ResTLBIRTTL.2" title="function: boolean ResTLBIRTTL(bits(2) tg, bits(2) ttl)">ResTLBIRTTL</a>(tlbi.tg, tlbi.ttl&lt;1:0&gt;) ||
                        <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.ttl&lt;1:0&gt;) == entry.walkstate.level) &amp;&amp;
                     ((tlbi.d128  &amp;&amp; entry.context.isd128) ||
                      (tlbi.d64  &amp;&amp; !entry.context.isd128) ||
                      (tlbi.d64 &amp;&amp; tlbi.d128)) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.address)     &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.end_address) &gt;  <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia));
        when <a href="shared_pseudocode.html#TLBIOp_RVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RVA</a>, <a href="shared_pseudocode.html#TLBIPOp_RVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIPOp_RVA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseASID.1" title="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) || tlbi.asid == entry.context.asid ||
                        entry.context.nG == '0') &amp;&amp;
                     (tlbi.tg != '00' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.DecodeTLBITG.1" title="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tlbi.tg) == entry.context.tg) &amp;&amp;
                     (!tlbi.from_aarch64 || <a href="shared_pseudocode.html#impl-aarch64.ResTLBIRTTL.2" title="function: boolean ResTLBIRTTL(bits(2) tg, bits(2) ttl)">ResTLBIRTTL</a>(tlbi.tg, tlbi.ttl&lt;1:0&gt;) ||
                        <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.ttl&lt;1:0&gt;) == entry.walkstate.level) &amp;&amp;
                     ((tlbi.d128  &amp;&amp; entry.context.isd128) ||
                      (tlbi.d64  &amp;&amp; !entry.context.isd128) ||
                      (tlbi.d64 &amp;&amp; tlbi.d128)) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.address)     &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.end_address) &gt;  <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia));
        when <a href="shared_pseudocode.html#TLBIOp_RPA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RPA</a>
            match = (entry.context.includes_gpt &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.address)     &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.walkstate.baseaddress.address) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.end_address) &gt;  <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.walkstate.baseaddress.address));
        when <a href="shared_pseudocode.html#TLBIOp_PAALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_PAALL</a>
            match = entry.context.includes_gpt;

    if tlbi.attr == <a href="shared_pseudocode.html#TLBI_ExcludeXS" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBI_ExcludeXS</a> &amp;&amp; entry.context.xs == '1' then
        match = FALSE;

    return match;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBIMemAttr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBIMemAttr</h3>
      <p class="pseudocode">enumeration <a id="TLBIMemAttr"/>TLBIMemAttr {
    <a id="TLBI_AllAttr"/>TLBI_AllAttr,         // All TLB entries within the scope of the invalidation
    <a id="TLBI_ExcludeXS"/>TLBI_ExcludeXS        // Only TLB entries with XS=0 within the scope of the invalidation
};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBIOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBIOp</h3>
      <p class="pseudocode">enumeration <a id="TLBIOp"/>TLBIOp {
    <a id="TLBIOp_DALL"/>TLBIOp_DALL,          // AArch32 Data TLBI operations - deprecated
    <a id="TLBIOp_DASID"/>TLBIOp_DASID,
    <a id="TLBIOp_DVA"/>TLBIOp_DVA,
    <a id="TLBIOp_IALL"/>TLBIOp_IALL,          // AArch32 Instruction TLBI operations - deprecated
    <a id="TLBIOp_IASID"/>TLBIOp_IASID,
    <a id="TLBIOp_IVA"/>TLBIOp_IVA,
    <a id="TLBIOp_ALL"/>TLBIOp_ALL,
    <a id="TLBIOp_ASID"/>TLBIOp_ASID,
    <a id="TLBIOp_IPAS2"/>TLBIOp_IPAS2,
    <a id="TLBIPOp_IPAS2"/>TLBIPOp_IPAS2,
    <a id="TLBIOp_VAA"/>TLBIOp_VAA,
    <a id="TLBIOp_VA"/>TLBIOp_VA,
    <a id="TLBIPOp_VAA"/>TLBIPOp_VAA,
    <a id="TLBIPOp_VA"/>TLBIPOp_VA,
    <a id="TLBIOp_VMALL"/>TLBIOp_VMALL,
    <a id="TLBIOp_VMALLS12"/>TLBIOp_VMALLS12,
    <a id="TLBIOp_RIPAS2"/>TLBIOp_RIPAS2,
    <a id="TLBIPOp_RIPAS2"/>TLBIPOp_RIPAS2,
    <a id="TLBIOp_RVAA"/>TLBIOp_RVAA,
    <a id="TLBIOp_RVA"/>TLBIOp_RVA,
    <a id="TLBIPOp_RVAA"/>TLBIPOp_RVAA,
    <a id="TLBIPOp_RVA"/>TLBIPOp_RVA,
    <a id="TLBIOp_RPA"/>TLBIOp_RPA,
    <a id="TLBIOp_PAALL"/>TLBIOp_PAALL,
};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBIPRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBIPRange</h3>
      <p class="pseudocode">// TLBIPRange()
// ============
// Extract the input address range information from encoded Xt.

(boolean, bits(2), bits(64), bits(64)) <a id="impl-aarch64.TLBIPRange.2"/>TLBIPRange(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(128) Xt)
    boolean  valid = TRUE;
    bits(64) start = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    bits(64) end   = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

    bits(2) tg        = Xt&lt;47:46&gt;;
    integer scale     = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;45:44&gt;);
    integer num       = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;43:39&gt;);
    integer tg_bits;

    if tg == '00' then
        return (FALSE, tg, start, end);

    case tg of
        when '01' // 4KB
            tg_bits = 12;
            start&lt;55:12&gt; = Xt&lt;107:64&gt;;
            start&lt;63:56&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;107&gt;, 8);
        when '10' // 16KB
            tg_bits = 14;
            start&lt;55:14&gt; = Xt&lt;107:66&gt;;
            start&lt;63:56&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;107&gt;, 8);
        when '11' // 64KB
            tg_bits = 16;
            start&lt;55:16&gt; = Xt&lt;107:68&gt;;
            start&lt;63:56&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;107&gt;, 8);
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    integer range = (num+1) &lt;&lt; (5*scale + 1 + tg_bits);
    end   = start + range&lt;63:0&gt;;

    if end&lt;55&gt; != start&lt;55&gt; then
        // overflow, saturate it
        end = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(start&lt;55&gt;, 64-55) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(55);

    return (valid, tg, start, end);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBIRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBIRange</h3>
      <p class="pseudocode">// TLBIRange()
// ===========
// Extract the input address range information from encoded Xt.

(boolean, bits(2), bits(64), bits(64)) <a id="impl-aarch64.TLBIRange.2"/>TLBIRange(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(64) Xt)
    boolean  valid = TRUE;
    bits(64) start = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    bits(64) end   = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

    bits(2) tg        = Xt&lt;47:46&gt;;
    integer scale     = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;45:44&gt;);
    integer num       = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;43:39&gt;);
    integer tg_bits;

    if tg == '00' then
        return (FALSE, tg, start, end);

    case tg of
        when '01' // 4KB
            tg_bits = 12;
            if <a href="shared_pseudocode.html#impl-aarch64.HasLargeAddress.1" title="function: boolean HasLargeAddress(Regime regime)">HasLargeAddress</a>(regime) then
                start&lt;52:16&gt; = Xt&lt;36:0&gt;;
                start&lt;63:53&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 11);
            else
                start&lt;48:12&gt; = Xt&lt;36:0&gt;;
                start&lt;63:49&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 15);
        when '10' // 16KB
            tg_bits = 14;
            if <a href="shared_pseudocode.html#impl-aarch64.HasLargeAddress.1" title="function: boolean HasLargeAddress(Regime regime)">HasLargeAddress</a>(regime) then
                start&lt;52:16&gt; = Xt&lt;36:0&gt;;
                start&lt;63:53&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 11);
            else
                start&lt;50:14&gt; = Xt&lt;36:0&gt;;
                start&lt;63:51&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 13);
        when '11' // 64KB
            tg_bits = 16;
            start&lt;52:16&gt; = Xt&lt;36:0&gt;;
            start&lt;63:53&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 11);
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    integer range = (num+1) &lt;&lt; (5*scale + 1 + tg_bits);
    end   = start + range&lt;63:0&gt;;

    if end&lt;52&gt; != start&lt;52&gt; then
        // overflow, saturate it
        end = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(start&lt;52&gt;, 64-52) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(52);

    return (valid, tg, start, end);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBIRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBIRecord</h3>
      <p class="pseudocode">type <a id="TLBIRecord"/>TLBIRecord is (
    <a href="shared_pseudocode.html#TLBIOp" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIPOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIPOp_VAA,&#13; TLBIPOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIPOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIPOp_RVAA,&#13; TLBIPOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp</a>          op,
    boolean         from_aarch64, // originated as an AArch64 operation
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a>   security,
    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a>          regime,
    bits(16)        vmid,
    bits(16)        asid,
    <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any, TLBILevel_Last }">TLBILevel</a>       level,
    <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr, TLBI_ExcludeXS }">TLBIMemAttr</a>     attr,
    <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a>         ipaspace,     // For operations that take IPA as input address
    bits(64)        address,      // input address, for range operations, start address
    bits(64)        end_address,  // for range operations, end address
    boolean         d64,          // For operations that evict VMSAv8-64 based TLB entries
    boolean         d128,         // For operations that evict VMSAv9-128 based TLB entries
    bits(4)         ttl,          // translation table walk level holding the leaf entry
                                  // for the address being invalidated
                                  // For Non-Range Invalidations:
                                  //   When the ttl is
                                  //     '00xx'    : this applies to all TLB entries
                                  //     Otherwise : TLBIP instructions invalidates D128 TLB
                                  //                 entries only
                                  //                 TLBI instructions invalidates D64 TLB
                                  //                 entries only
                                  // For Range Invalidations:
                                  //   When the ttl is
                                  //     '00'      : this applies to all TLB entries
                                  //     Otherwise : TLBIP instructions invalidates D128 TLB
                                  //                 entries only
                                  //                 TLBI instructions invalidates D64 TLB
                                  //                 entries only
    bits(2)         tg            // for range operations, translation granule
)</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.VMID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/VMID</h3>
      <p class="pseudocode">// VMID[]
// ======
// Effective VMID.

bits(16) <a id="impl-aarch64.VMID.read.0"/>VMID[]
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            if <a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()">Have16bitVMID</a>() &amp;&amp; VTCR_EL2.VS == '1' then
                return VTTBR_EL2.VMID;
            else
                return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0&gt;, 16);
        else
            return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR.VMID, 16);
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() then
        return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    else
        return <a href="shared_pseudocode.html#VMID_NONE" title="constant bits(16) VMID_NONE = Zeros(16)">VMID_NONE</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.VMID_NONE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/VMID_NONE</h3>
      <p class="pseudocode">constant bits(16) <a id="VMID_NONE"/>VMID_NONE = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops_128.sysop_128.SysOp128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops_128/sysop_128/SysOp128</h3>
      <p class="pseudocode">// SysOp128()
// ==========

SystemOp <a id="impl-aarch64.SysOp128.4"/>SysOp128(bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2)
    case op1:CRn:CRm:op2 of
        when '000 1000 0001 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE1OS
        when '000 1000 0001 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAAE1OS
        when '000 1000 0001 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE1OS
        when '000 1000 0001 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAALE1OS
        when '000 1000 0011 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE1IS
        when '000 1000 0011 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAAE1IS
        when '000 1000 0011 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE1IS
        when '000 1000 0011 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAALE1IS
        when '000 1000 0111 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE1
        when '000 1000 0111 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAAE1
        when '000 1000 0111 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE1
        when '000 1000 0111 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAALE1
        when '000 1001 0001 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE1OSNXS
        when '000 1001 0001 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAAE1OSNXS
        when '000 1001 0001 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE1OSNXS
        when '000 1001 0001 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAALE1OSNXS
        when '000 1001 0011 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE1ISNXS
        when '000 1001 0011 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAAE1ISNXS
        when '000 1001 0011 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE1ISNXS
        when '000 1001 0011 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAALE1ISNXS
        when '000 1001 0111 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE1NXS
        when '000 1001 0111 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAAE1NXS
        when '000 1001 0111 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE1NXS
        when '000 1001 0111 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAALE1NXS
        when '100 1000 0001 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE2OS
        when '100 1000 0001 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE2OS
        when '100 1000 0011 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE2IS
        when '100 1000 0011 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE2IS
        when '100 1000 0111 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE2
        when '100 1000 0111 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE2
        when '100 1001 0001 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE2OSNXS
        when '100 1001 0001 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE2OSNXS
        when '100 1001 0011 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE2ISNXS
        when '100 1001 0011 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE2ISNXS
        when '100 1001 0111 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE2NXS
        when '100 1001 0111 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE2NXS
        when '110 1000 0001 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE3OS
        when '110 1000 0001 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE3OS
        when '110 1000 0011 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE3IS
        when '110 1000 0011 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE3IS
        when '110 1000 0111 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE3
        when '110 1000 0111 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE3
        when '110 1001 0001 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE3OSNXS
        when '110 1001 0001 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE3OSNXS
        when '110 1001 0011 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE3ISNXS
        when '110 1001 0011 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE3ISNXS
        when '110 1001 0111 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VAE3NXS
        when '110 1001 0111 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // VALE3NXS
        when '100 1000 0000 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // IPAS2E1IS
        when '100 1000 0000 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // IPAS2LE1IS
        when '100 1000 0100 000' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // IPAS2E1OS
        when '100 1000 0100 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // IPAS2E1
        when '100 1000 0100 100' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // IPAS2LE1OS
        when '100 1000 0100 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // IPAS2LE1
        when '100 1001 0000 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // IPAS2E1ISNXS
        when '100 1001 0000 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // IPAS2LE1ISNXS
        when '100 1001 0100 000' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // IPAS2E1OSNXS
        when '100 1001 0100 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // IPAS2E1NXS
        when '100 1001 0100 100' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // IPAS2LE1OSNXS
        when '100 1001 0100 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // IPAS2LE1NXS
        when '000 1000 0010 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE1IS
        when '000 1000 0010 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAAE1IS
        when '000 1000 0010 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE1IS
        when '000 1000 0010 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAALE1IS
        when '000 1000 0101 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE1OS
        when '000 1000 0101 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAAE1OS
        when '000 1000 0101 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE1OS
        when '000 1000 0101 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAALE1OS
        when '000 1000 0110 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE1
        when '000 1000 0110 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAAE1
        when '000 1000 0110 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE1
        when '000 1000 0110 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAALE1
        when '000 1001 0010 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE1ISNXS
        when '000 1001 0010 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAAE1ISNXS
        when '000 1001 0010 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE1ISNXS
        when '000 1001 0010 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAALE1ISNXS
        when '000 1001 0101 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE1OSNXS
        when '000 1001 0101 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAAE1OSNXS
        when '000 1001 0101 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE1OSNXS
        when '000 1001 0101 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAALE1OSNXS
        when '000 1001 0110 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE1NXS
        when '000 1001 0110 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAAE1NXS
        when '000 1001 0110 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE1NXS
        when '000 1001 0110 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAALE1NXS
        when '100 1000 0010 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE2IS
        when '100 1000 0010 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE2IS
        when '100 1000 0101 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE2OS
        when '100 1000 0101 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE2OS
        when '100 1000 0110 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE2
        when '100 1000 0110 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE2
        when '100 1001 0010 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE2ISNXS
        when '100 1001 0010 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE2ISNXS
        when '100 1001 0101 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE2OSNXS
        when '100 1001 0101 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE2OSNXS
        when '100 1001 0110 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE2NXS
        when '100 1001 0110 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE2NXS
        when '110 1000 0010 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE3IS
        when '110 1000 0010 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE3IS
        when '110 1000 0101 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE3OS
        when '110 1000 0101 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE3OS
        when '110 1000 0110 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE3
        when '110 1000 0110 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE3
        when '110 1001 0010 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE3ISNXS
        when '110 1001 0010 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE3ISNXS
        when '110 1001 0101 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE3OSNXS
        when '110 1001 0101 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE3OSNXS
        when '110 1001 0110 001' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVAE3NXS
        when '110 1001 0110 101' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RVALE3NXS
        when '100 1000 0000 010' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RIPAS2E1IS
        when '100 1000 0000 110' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RIPAS2LE1IS
        when '100 1000 0100 010' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RIPAS2E1
        when '100 1000 0100 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RIPAS2E1OS
        when '100 1000 0100 110' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RIPAS2LE1
        when '100 1000 0100 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RIPAS2LE1OS
        when '100 1001 0000 010' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RIPAS2E1ISNXS
        when '100 1001 0000 110' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RIPAS2LE1ISNXS
        when '100 1001 0100 010' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RIPAS2E1NXS
        when '100 1001 0100 011' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RIPAS2E1OSNXS
        when '100 1001 0100 110' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RIPAS2LE1NXS
        when '100 1001 0100 111' return <a href="shared_pseudocode.html#Sys_TLBIP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_TLBIP</a>;  // RIPAS2LE1OSNXS
        otherwise                return <a href="shared_pseudocode.html#Sys_SYSP" title="enumeration SystemOp128 {Sys_TLBIP, Sys_SYSP}">Sys_SYSP</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops_128.sysop_128.SystemOp128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops_128/sysop_128/SystemOp128</h3>
      <p class="pseudocode">enumeration <a id="SystemOp128"/>SystemOp128 {<a id="Sys_TLBIP"/>Sys_TLBIP, <a id="Sys_SYSP"/>Sys_SYSP};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.vector.arithmetic.binary.uniform.logical.bsl-eor.vbitop.VBitOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor/vbitop/VBitOp</h3>
      <p class="pseudocode">enumeration <a id="VBitOp"/>VBitOp      {<a id="VBitOp_VBIF"/>VBitOp_VBIF, <a id="VBitOp_VBIT"/>VBitOp_VBIT, <a id="VBitOp_VBSL"/>VBitOp_VBSL, <a id="VBitOp_VEOR"/>VBitOp_VEOR};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.vector.arithmetic.unary.cmp.compareop.CompareOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/vector/arithmetic/unary/cmp/compareop/CompareOp</h3>
      <p class="pseudocode">enumeration <a id="CompareOp"/>CompareOp   {<a id="CompareOp_GT"/>CompareOp_GT, <a id="CompareOp_GE"/>CompareOp_GE, <a id="CompareOp_EQ"/>CompareOp_EQ,
                         <a id="CompareOp_LE"/>CompareOp_LE, <a id="CompareOp_LT"/>CompareOp_LT};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.vector.logical.immediateop.ImmediateOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/vector/logical/immediateop/ImmediateOp</h3>
      <p class="pseudocode">enumeration <a id="ImmediateOp"/>ImmediateOp {<a id="ImmediateOp_MOVI"/>ImmediateOp_MOVI, <a id="ImmediateOp_MVNI"/>ImmediateOp_MVNI,
                         <a id="ImmediateOp_ORR"/>ImmediateOp_ORR, <a id="ImmediateOp_BIC"/>ImmediateOp_BIC};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.vector.reduce.reduceop.Reduce"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/vector/reduce/reduceop/Reduce</h3>
      <p class="pseudocode">// Reduce()
// ========

bits(esize) <a id="impl-aarch64.Reduce.3"/>Reduce(<a href="shared_pseudocode.html#ReduceOp" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp</a> op, bits(N) input, integer esize)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; FPCR.AH == '1';
    return <a href="shared_pseudocode.html#impl-aarch64.Reduce.4" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize, boolean altfp)">Reduce</a>(op, input, esize, altfp);

// Reduce()
// ========
// Perform the operation 'op' on pairs of elements from the input vector,
// reducing the vector to a scalar result. The 'altfp' argument controls
// alternative floating-point behavior.

bits(esize) <a id="impl-aarch64.Reduce.4"/>Reduce(<a href="shared_pseudocode.html#ReduceOp" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp</a> op, bits(N) input, integer esize, boolean altfp)
    integer half;
    bits(esize) hi;
    bits(esize) lo;
    bits(esize) result;

    if N == esize then
        return input&lt;esize-1:0&gt;;

    half = N DIV 2;
    hi = <a href="shared_pseudocode.html#impl-aarch64.Reduce.4" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize, boolean altfp)">Reduce</a>(op, input&lt;N-1:half&gt;, esize, altfp);
    lo = <a href="shared_pseudocode.html#impl-aarch64.Reduce.4" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize, boolean altfp)">Reduce</a>(op, input&lt;half-1:0&gt;, esize, altfp);

    case op of
        when <a href="shared_pseudocode.html#ReduceOp_FMINNUM" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMINNUM</a>
            result = <a href="shared_pseudocode.html#impl-shared.FPMinNum.3" title="function: bits(N) FPMinNum(bits(N) op1_in, bits(N) op2_in, FPCRType fpcr)">FPMinNum</a>(lo, hi, FPCR[]);
        when <a href="shared_pseudocode.html#ReduceOp_FMAXNUM" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMAXNUM</a>
            result = <a href="shared_pseudocode.html#impl-shared.FPMaxNum.3" title="function: bits(N) FPMaxNum(bits(N) op1_in, bits(N) op2_in, FPCRType fpcr)">FPMaxNum</a>(lo, hi, FPCR[]);
        when <a href="shared_pseudocode.html#ReduceOp_FMIN" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMIN</a>
            result = <a href="shared_pseudocode.html#impl-shared.FPMin.4" title="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMin</a>(lo, hi, FPCR[], altfp);
        when <a href="shared_pseudocode.html#ReduceOp_FMAX" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMAX</a>
            result = <a href="shared_pseudocode.html#impl-shared.FPMax.4" title="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMax</a>(lo, hi, FPCR[], altfp);
        when <a href="shared_pseudocode.html#ReduceOp_FADD" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FADD</a>
            result = <a href="shared_pseudocode.html#impl-shared.FPAdd.3" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPAdd</a>(lo, hi, FPCR[]);
        when <a href="shared_pseudocode.html#ReduceOp_ADD" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_ADD</a>
            result = lo + hi;

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.vector.reduce.reduceop.ReduceOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/vector/reduce/reduceop/ReduceOp</h3>
      <p class="pseudocode">enumeration <a id="ReduceOp"/>ReduceOp {<a id="ReduceOp_FMINNUM"/>ReduceOp_FMINNUM, <a id="ReduceOp_FMAXNUM"/>ReduceOp_FMAXNUM,
                      <a id="ReduceOp_FMIN"/>ReduceOp_FMIN, <a id="ReduceOp_FMAX"/>ReduceOp_FMAX,
                      <a id="ReduceOp_FADD"/>ReduceOp_FADD, <a id="ReduceOp_ADD"/>ReduceOp_ADD};</p>
    </div>
    <div class="ps"><a id="aarch64.translation.attrs.AArch64.MAIRAttr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/attrs/AArch64.MAIRAttr</h3>
      <p class="pseudocode">// AArch64.MAIRAttr()
// ==================
// Retrieve the memory attribute encoding indexed in the given MAIR

bits(8) AArch64.MAIRAttr(integer index, MAIRType mair2, MAIRType mair)
    bit_index = 8 * index;
    assert (index &lt; 8 || (<a href="shared_pseudocode.html#impl-shared.HaveAIEExt.0" title="function: boolean HaveAIEExt()">HaveAIEExt</a>() &amp;&amp; (index &lt; 16)));
    if (index &gt; 7) then
        bit_index = bit_index - 64;                      // Read from LSB at MAIR2
        return mair2&lt;bit_index+7:bit_index&gt;;
    else
        return mair&lt;bit_index+7:bit_index&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.debug.AArch64.CheckBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/debug/AArch64.CheckBreakpoint</h3>
      <p class="pseudocode">// AArch64.CheckBreakpoint()
// =========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch64
// translation regime, when either debug exceptions are enabled, or halting debug is enabled
// and halting is allowed.

FaultRecord <a id="AArch64.CheckBreakpoint.4"/>AArch64.CheckBreakpoint(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, bits(64) vaddress,
                                    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, integer size)
    assert !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert (<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; size IN {2,4}) || size == 4;

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;

    for i = 0 to <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1
        if <a href="shared_pseudocode.html#AArch64.BreakpointMatch.4" title="function: boolean AArch64.BreakpointMatch(integer n, bits(64) vaddress, AccessDescriptor accdesc,&#13; integer size)">AArch64.BreakpointMatch</a>(i, vaddress, accdesc, size) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;

    if fault.statuscode == <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() then
        reason = <a href="shared_pseudocode.html#DebugHalt_Breakpoint" title="constant bits(6) DebugHalt_Breakpoint = '000111'">DebugHalt_Breakpoint</a>;
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(reason);

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.debug.AArch64.CheckDebug"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/debug/AArch64.CheckDebug</h3>
      <p class="pseudocode">// AArch64.CheckDebug()
// ====================
// Called on each access to check for a debug exception or entry to Debug state.

FaultRecord <a id="AArch64.CheckDebug.3"/>AArch64.CheckDebug(bits(64) vaddress, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, integer size)

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.NoFault.1" title="function: FaultRecord NoFault(AccessDescriptor accdesc)">NoFault</a>(accdesc);
    boolean generate_exception;

    boolean d_side = (<a href="shared_pseudocode.html#impl-shared.IsDataAccess.1" title="function: boolean IsDataAccess(AccessType acctype)">IsDataAccess</a>(accdesc.acctype) || accdesc.acctype == <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>);
    boolean i_side = (accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a>);
    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_NV2" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_NV2</a> then
        mask = '0';
        ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
        generate_exception = <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from_el, SecurityState from_state, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, ss, mask) &amp;&amp; MDSCR_EL1.MDE == '1';
    else
        generate_exception = <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()">AArch64.GenerateDebugExceptions</a>() &amp;&amp; MDSCR_EL1.MDE == '1';
    halt = <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>();

    if generate_exception || halt then
        if d_side then
            fault = <a href="shared_pseudocode.html#AArch64.CheckWatchpoint.4" title="function: FaultRecord AArch64.CheckWatchpoint(FaultRecord fault_in, bits(64) vaddress,&#13; AccessDescriptor accdesc, integer size)">AArch64.CheckWatchpoint</a>(fault, vaddress, accdesc, size);
        elsif i_side then
            fault = <a href="shared_pseudocode.html#AArch64.CheckBreakpoint.4" title="function: FaultRecord AArch64.CheckBreakpoint(FaultRecord fault_in, bits(64) vaddress,&#13; AccessDescriptor accdesc, integer size)">AArch64.CheckBreakpoint</a>(fault, vaddress, accdesc, size);

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.debug.AArch64.CheckWatchpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/debug/AArch64.CheckWatchpoint</h3>
      <p class="pseudocode">// AArch64.CheckWatchpoint()
// =========================
// Called before accessing the memory location of "size" bytes at "address",
// when either debug exceptions are enabled for the access, or halting debug
// is enabled and halting is allowed.

FaultRecord <a id="AArch64.CheckWatchpoint.4"/>AArch64.CheckWatchpoint(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, bits(64) vaddress,
                                    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, integer size)
    assert !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;

    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a> then
        if accdesc.cacheop != <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> then
            return fault;
    elsif !<a href="shared_pseudocode.html#impl-shared.IsDataAccess.1" title="function: boolean IsDataAccess(AccessType acctype)">IsDataAccess</a>(accdesc.acctype) then
        return fault;

    for i = 0 to <a href="shared_pseudocode.html#impl-shared.NumWatchpointsImplemented.0" title="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>() - 1
        if <a href="shared_pseudocode.html#AArch64.WatchpointMatch.4" title="function: boolean AArch64.WatchpointMatch(integer n, bits(64) vaddress, integer size,&#13; AccessDescriptor accdesc)">AArch64.WatchpointMatch</a>(i, vaddress, size, accdesc) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;
            if DBGWCR_EL1[i].LSC&lt;0&gt; == '1' &amp;&amp; accdesc.read then
                fault.write = FALSE;
            elsif DBGWCR_EL1[i].LSC&lt;1&gt; == '1' &amp;&amp; accdesc.write then
                fault.write = TRUE;

    if (fault.statuscode == <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() &amp;&amp;
            !accdesc.nonfault &amp;&amp; !(accdesc.firstfault &amp;&amp; !accdesc.first)) then
        reason = <a href="shared_pseudocode.html#DebugHalt_Watchpoint" title="constant bits(6) DebugHalt_Watchpoint = '101011'">DebugHalt_Watchpoint</a>;
        EDWAR = vaddress;
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(reason);

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.IASize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.IASize</h3>
      <p class="pseudocode">// AArch64.IASize()
// ================
// Retrieve the number of bits containing the input address

integer <a id="AArch64.IASize.1"/>AArch64.IASize(bits(6) txsz)
    return 64 - <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(txsz);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.LeafBase"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.LeafBase</h3>
      <p class="pseudocode">// AArch64.LeafBase()
// ==================
// Extract the address embedded in a block and page descriptor pointing to the
// base of a memory block

bits(56) <a id="AArch64.LeafBase.5"/>AArch64.LeafBase(bits(N) descriptor, bit d128, bit ds,
                               <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    bits(56) leafbase = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(56);

    granulebits  = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(tgx);
    descsizelog2 = if d128 == '1' then 4 else 3;
    stride      = granulebits - descsizelog2;
    leafsize    = granulebits + stride * (<a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - level);

    leafbase&lt;47:0&gt; = descriptor&lt;47:leafsize&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(leafsize);

    if <a href="shared_pseudocode.html#impl-shared.Have56BitPAExt.0" title="function: boolean Have56BitPAExt()">Have56BitPAExt</a>() &amp;&amp; d128 == '1' then
        leafbase&lt;55:48&gt; = descriptor&lt;55:48&gt;;
        return leafbase;
    if <a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> then
        leafbase&lt;51:48&gt; = descriptor&lt;15:12&gt;;
    elsif ds == '1' then
        leafbase&lt;51:48&gt; = descriptor&lt;9:8&gt;:descriptor&lt;49:48&gt;;

    return leafbase;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.NextTableBase"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.NextTableBase</h3>
      <p class="pseudocode">// AArch64.NextTableBase()
// =======================
// Extract the address embedded in a table descriptor pointing to the base of
// the next level table of descriptors

bits(56) <a id="AArch64.NextTableBase.4"/>AArch64.NextTableBase(bits(N) descriptor, bit d128, bit ds, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    bits(56) tablebase = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(56);

    case tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  tablebase&lt;47:12&gt; = descriptor&lt;47:12&gt;;
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> tablebase&lt;47:14&gt; = descriptor&lt;47:14&gt;;
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> tablebase&lt;47:16&gt; = descriptor&lt;47:16&gt;;

    if <a href="shared_pseudocode.html#impl-shared.Have56BitPAExt.0" title="function: boolean Have56BitPAExt()">Have56BitPAExt</a>() &amp;&amp; d128 == '1' then
        tablebase&lt;55:48&gt; = descriptor&lt;55:48&gt;;
        return tablebase;
    if <a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> then
        tablebase&lt;51:48&gt; = descriptor&lt;15:12&gt;;
        return tablebase;
    if ds == '1' then
        tablebase&lt;51:48&gt; = descriptor&lt;9:8&gt;:descriptor&lt;49:48&gt;;
        return tablebase;
    return tablebase;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.PhysicalAddressSize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.PhysicalAddressSize</h3>
      <p class="pseudocode">// AArch64.PhysicalAddressSize()
// =============================
// Retrieve the number of bits bounding the physical address

integer <a id="AArch64.PhysicalAddressSize.3"/>AArch64.PhysicalAddressSize(bit d128, bits(3) encoded_ps, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    integer ps;
    integer max_ps;

    case encoded_ps of
        when '000'  ps = 32;
        when '001'  ps = 36;
        when '010'  ps = 40;
        when '011'  ps = 42;
        when '100'  ps = 44;
        when '101'  ps = 48;
        when '110'  ps = 52;
        when '111'  ps = 56;
    if !<a href="shared_pseudocode.html#impl-shared.Have56BitPAExt.0" title="function: boolean Have56BitPAExt()">Have56BitPAExt</a>() || d128 == '0' then
        if tgx != <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
            max_ps = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(48, <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>());
        elsif !<a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() then
            max_ps = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(48, <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>());
        else
            max_ps = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(52, <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>());
    else
        max_ps = <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>();

    return <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(ps, max_ps);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.S1SLTTEntryAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.S1SLTTEntryAddress</h3>
      <p class="pseudocode">// AArch64.S1SLTTEntryAddress()
// ============================
// Compute the first stage 1 translation table descriptor address within the
// table pointed to by the base at the start level

<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> AArch64.S1SLTTEntryAddress(integer level, S1TTWParams walkparams,
                                       bits(64) ia, <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> tablebase)
    // Input Address size
    iasize       = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);
    granulebits  = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    descsizelog2 = if walkparams.d128 == '1' then 4 else 3;
    stride       = granulebits - descsizelog2;
    levels       = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - level;

    bits(56) index;
    lsb   = levels*stride + granulebits;
    msb   = iasize - 1;
    index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ia&lt;msb:lsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(descsizelog2), 56);

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> descaddress;
    descaddress.address = tablebase.address OR index;
    descaddress.paspace = tablebase.paspace;

    return descaddress;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.S1StartLevel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.S1StartLevel</h3>
      <p class="pseudocode">// AArch64.S1StartLevel()
// ======================
// Compute the initial lookup level when performing a stage 1 translation
// table walk

integer AArch64.S1StartLevel(S1TTWParams walkparams)
    // Input Address size
    iasize       = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);
    granulebits  = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    descsizelog2 = if walkparams.d128 == '1' then 4 else 3;
    stride       = granulebits - descsizelog2;
    s1startlevel = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - (((iasize-1) - granulebits) DIV stride);
    if walkparams.d128 == '1' then
        s1startlevel = s1startlevel + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.skl);
    return s1startlevel;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.S2SLTTEntryAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.S2SLTTEntryAddress</h3>
      <p class="pseudocode">// AArch64.S2SLTTEntryAddress()
// ============================
// Compute the first stage 2 translation table descriptor address within the
// table pointed to by the base at the start level

<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> AArch64.S2SLTTEntryAddress(S2TTWParams walkparams, bits(56) ipa,
                                       <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> tablebase)
    startlevel   = AArch64.S2StartLevel(walkparams);
    iasize       = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);
    granulebits  = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    descsizelog2 = if walkparams.d128 == '1' then 4 else 3;
    stride       = granulebits - descsizelog2;
    levels       = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;

    bits(56) index;
    integer lsb;
    integer msb;
    lsb   = levels*stride + granulebits;
    msb   = iasize - 1;
    index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa&lt;msb:lsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(descsizelog2), 56);

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> descaddress;
    descaddress.address = tablebase.address OR index;
    descaddress.paspace = tablebase.paspace;

    return descaddress;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.S2StartLevel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.S2StartLevel</h3>
      <p class="pseudocode">// AArch64.S2StartLevel()
// ======================
// Determine the initial lookup level when performing a stage 2 translation
// table walk

integer AArch64.S2StartLevel(S2TTWParams walkparams)
    if walkparams.d128 == '1' then
        iasize       = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);
        granulebits  = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
        descsizelog2 = 4;
        stride       = granulebits - descsizelog2;
        s2startlevel = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - (((iasize-1) - granulebits) DIV stride);
        s2startlevel = s2startlevel + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.skl);

        return s2startlevel;

    case walkparams.tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>
            case walkparams.sl2:walkparams.sl0 of
                when '000' return 2;
                when '001' return 1;
                when '010' return 0;
                when '011' return 3;
                when '100' return -1;
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>
            case walkparams.sl0 of
                when '00' return 3;
                when '01' return 2;
                when '10' return 1;
                when '11' return 0;
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>
            case walkparams.sl0 of
                when '00' return 3;
                when '01' return 2;
                when '10' return 1;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.TTBaseAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.TTBaseAddress</h3>
      <p class="pseudocode">// AArch64.TTBaseAddress()
// =======================
// Retrieve the PA/IPA pointing to the base of the initial translation table

bits(56) <a id="AArch64.TTBaseAddress.7"/>AArch64.TTBaseAddress(bits(64) ttb, bits(6) txsz, bits(3) ps,
                                   bit d128, bit ds, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer startlevel)
    bits(56) tablebase = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(56);

    // Input Address size
    iasize      = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(txsz);
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(tgx);
    descsizelog2 = if d128 == '1' then 4 else 3;
    stride      = granulebits - descsizelog2;
    levels      = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;

    // Base address is aligned to size of the initial translation table in bytes
    tsize = (iasize - (levels*stride + granulebits)) + descsizelog2;

    if <a href="shared_pseudocode.html#impl-shared.Have56BitPAExt.0" title="function: boolean Have56BitPAExt()">Have56BitPAExt</a>() &amp;&amp;  d128 == '1' then
        tsize = <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>(tsize, 5);
        tablebase&lt;55:5&gt; = ttb&lt;50:0&gt;;
    elsif (<a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; ps == '110') || (ds == '1') then
        tsize = <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>(tsize, 6);
        tablebase&lt;51:6&gt; = ttb&lt;4:1&gt;:ttb&lt;46:5&gt;;
    else
        tablebase&lt;47:1&gt; = ttb&lt;46:0&gt;;
    tablebase = <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(tablebase, 1 &lt;&lt; tsize);
    return tablebase;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.TTEntryAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.TTEntryAddress</h3>
      <p class="pseudocode">// AArch64.TTEntryAddress()
// ========================
// Compute translation table descriptor address within the table pointed to by
// the table base

FullAddress <a id="AArch64.TTEntryAddress.7"/>AArch64.TTEntryAddress(integer level, bit d128, bits(2) skl, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, bits(6) txsz,
                                   bits(64) ia, <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> tablebase)
    // Input Address size
    iasize      = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(txsz);
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(tgx);
    descsizelog2 = if d128 == '1' then 4 else 3;
    stride      = granulebits - descsizelog2;
    levels      = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - level;

    bits(56) index;
    integer lsb;
    integer msb;

    lsb   = levels*stride + granulebits;
    if d128 == '1' then
        msb   = lsb + stride*(1 + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(skl)) - 1;
    else
        msb   = lsb + stride - 1;
    index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ia&lt;msb:lsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(descsizelog2), 56);

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> descaddress;
    descaddress.address = tablebase.address OR index;
    descaddress.paspace = tablebase.paspace;

    return descaddress;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.AddrTop"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.AddrTop</h3>
      <p class="pseudocode">// AArch64.AddrTop()
// =================
// Get the top bit position of the virtual address.
// Bits above are not accounted as part of the translation process.

integer <a id="AArch64.AddrTop.3"/>AArch64.AddrTop(bit tbid, <a href="shared_pseudocode.html#AccessType" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType</a> acctype, bit tbi)
    if tbid == '1' &amp;&amp; acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        return 63;

    if tbi == '1' then
        return 55;
    else
        return 63;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.ContiguousBitFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.ContiguousBitFaults</h3>
      <p class="pseudocode">// AArch64.ContiguousBitFaults()
// =============================
// If contiguous bit is set, returns whether the translation size exceeds the
// input address size and if the implementation generates a fault

boolean <a id="AArch64.ContiguousBitFaults.4"/>AArch64.ContiguousBitFaults(bit d128, bits(6) txsz, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    // Input Address size
    iasize = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(txsz);
    // Translation size
    tsize  = <a href="shared_pseudocode.html#impl-shared.TranslationSize.3" title="function: integer TranslationSize(bit d128, TGx tgx, integer level)">TranslationSize</a>(d128, tgx, level) + <a href="shared_pseudocode.html#impl-shared.ContiguousSize.3" title="function: integer ContiguousSize(bit d128, TGx tgx, integer level)">ContiguousSize</a>(d128, tgx, level);

    return (tsize &gt; iasize &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Translation fault on misprogrammed contiguous bit");</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.IPAIsOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.IPAIsOutOfRange</h3>
      <p class="pseudocode">// AArch64.IPAIsOutOfRange()
// =========================
// Check bits not resolved by translation are ZERO

boolean AArch64.IPAIsOutOfRange(bits(56) ipa, S2TTWParams walkparams)
    //Input Address size
    iasize = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);

    if iasize &lt; 56 then
        return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ipa&lt;55:iasize&gt;);
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.OAOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.OAOutOfRange</h3>
      <p class="pseudocode">// AArch64.OAOutOfRange()
// ======================
// Returns whether output address is expressed in the configured size number of bits

boolean <a id="AArch64.OAOutOfRange.5"/>AArch64.OAOutOfRange(<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate, bit d128, bits(3) ps,
                             <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, bits(64) ia)
    // Output Address size
    oasize  = <a href="shared_pseudocode.html#AArch64.PhysicalAddressSize.3" title="function: integer AArch64.PhysicalAddressSize(bit d128, bits(3) encoded_ps, TGx tgx)">AArch64.PhysicalAddressSize</a>(d128, ps, tgx);

    if oasize &lt; 56 then
        if walkstate.istable then
            baseaddress = walkstate.baseaddress.address;
            return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(baseaddress&lt;55:oasize&gt;);
        else
            // Output address
            oa = <a href="shared_pseudocode.html#impl-shared.StageOA.4" title="function: FullAddress StageOA(bits(64) ia, bit d128, TGx tgx, TTWState walkstate)">StageOA</a>(ia, d128, tgx, walkstate);
            return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(oa.address&lt;55:oasize&gt;);
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S1CheckPermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S1CheckPermissions</h3>
      <p class="pseudocode">// AArch64.S1CheckPermissions()
// ============================
// Checks whether stage 1 access violates permissions of target memory
// and returns a fault record

<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> AArch64.S1CheckPermissions(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate,
                                       S1TTWParams walkparams, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions = walkstate.permissions;
    <a href="shared_pseudocode.html#S1AccessControls" title="type S1AccessControls is ( bit r, bit w, bit x, bit gcs, boolean overlay, bit or, bit ow, bit ox, bit wxn )">S1AccessControls</a> s1perms;

    s1perms = AArch64.S1ComputePermissions(regime, walkstate, walkparams, accdesc);

    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        if s1perms.overlay &amp;&amp; s1perms.ox == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.overlay    = TRUE;
        elsif (walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp;
                <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_INSTRDEVICE</a>) == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        elsif s1perms.x == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a> then
        if accdesc.cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> then
            if s1perms.overlay &amp;&amp; s1perms.ow == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.overlay    = TRUE;
            elsif s1perms.w == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        // DC from privileged context which clean cannot generate a Permission fault
        elsif accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            if s1perms.overlay &amp;&amp; s1perms.or == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.overlay    = TRUE;
            elsif (walkparams.cmow == '1' &amp;&amp;
                    accdesc.opscope == <a href="shared_pseudocode.html#CacheOpScope_PoC" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a> &amp;&amp;
                    accdesc.cacheop == <a href="shared_pseudocode.html#CacheOp_CleanInvalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a> &amp;&amp;
                    s1perms.overlay &amp;&amp; s1perms.ow == '0') then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.overlay    = TRUE;
            elsif s1perms.r == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            elsif (walkparams.cmow == '1' &amp;&amp;
                    accdesc.opscope == <a href="shared_pseudocode.html#CacheOpScope_PoC" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a> &amp;&amp;
                    accdesc.cacheop == <a href="shared_pseudocode.html#CacheOp_CleanInvalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a> &amp;&amp;
                    s1perms.w == '0') then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a> then
        // IC from privileged context cannot generate Permission fault
        if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            if (s1perms.overlay &amp;&amp; s1perms.or == '0' &amp;&amp;
                  boolean IMPLEMENTATION_DEFINED "Permission fault on <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> IC_IVAU execution") then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.overlay    = TRUE;
            elsif walkparams.cmow == '1' &amp;&amp; s1perms.overlay &amp;&amp; s1perms.ow == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.overlay    = TRUE;
            elsif (s1perms.r == '0' &amp;&amp;
                  boolean IMPLEMENTATION_DEFINED "Permission fault on <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> IC_IVAU execution") then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            elsif walkparams.cmow == '1' &amp;&amp; s1perms.w == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
    elsif accdesc.read &amp;&amp; s1perms.overlay &amp;&amp; s1perms.or == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        fault.overlay    = TRUE;
        fault.write      = FALSE;
    elsif accdesc.write &amp;&amp; s1perms.overlay &amp;&amp; s1perms.ow == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        fault.overlay    = TRUE;
        fault.write      = TRUE;
    elsif accdesc.read &amp;&amp; s1perms.r == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        fault.write      = FALSE;
    elsif accdesc.write &amp;&amp; s1perms.w == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        fault.write      = TRUE;
    elsif (accdesc.write &amp;&amp; !(walkparams.&lt;ha,hd&gt; == '11') &amp;&amp; walkparams.pie == '1' &amp;&amp;
            permissions.ndirty == '1') then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        fault.dirtybit   = TRUE;
        fault.write      = TRUE;

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S1ComputePermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S1ComputePermissions</h3>
      <p class="pseudocode">// AArch64.S1ComputePermissions()
// ==============================
// Computes the overall stage 1 permissions

<a href="shared_pseudocode.html#S1AccessControls" title="type S1AccessControls is ( bit r, bit w, bit x, bit gcs, boolean overlay, bit or, bit ow, bit ox, bit wxn )">S1AccessControls</a> AArch64.S1ComputePermissions(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate,
                                              S1TTWParams walkparams, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions = walkstate.permissions;
    <a href="shared_pseudocode.html#S1AccessControls" title="type S1AccessControls is ( bit r, bit w, bit x, bit gcs, boolean overlay, bit or, bit ow, bit ox, bit wxn )">S1AccessControls</a> s1perms;

    if walkparams.pie == '1' then
        s1perms = AArch64.S1IndirectBasePermissions(regime, walkstate, walkparams, accdesc);
    else
        s1perms = AArch64.S1DirectBasePermissions(regime, walkstate, walkparams, accdesc);

    if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#AArch64.S1E0POEnabled.2" title="function: boolean AArch64.S1E0POEnabled(Regime regime, bit nv1)">AArch64.S1E0POEnabled</a>(regime, walkparams.nv1) then
        s1perms.overlay = FALSE;
    elsif accdesc.el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#AArch64.S1POEnabled.1" title="function: boolean AArch64.S1POEnabled(Regime regime)">AArch64.S1POEnabled</a>(regime) then
        s1perms.overlay = FALSE;

    if s1perms.overlay then
        s1overlay_perms = <a href="shared_pseudocode.html#AArch64.S1OverlayPermissions.3" title="function: S1AccessControls AArch64.S1OverlayPermissions(Regime regime, TTWState walkstate,&#13; AccessDescriptor accdesc)">AArch64.S1OverlayPermissions</a>(regime, walkstate, accdesc);
        s1perms.or = s1overlay_perms.or;
        s1perms.ow = s1overlay_perms.ow;
        s1perms.ox = s1overlay_perms.ox;

    // If wxn is set, overlay execute permissions is set to 0
    if s1perms.overlay &amp;&amp; s1perms.wxn == '1' &amp;&amp; s1perms.ox == '1' then
        s1perms.ow = '0';
    elsif s1perms.wxn == '1' then
        s1perms.x = '0';

    return s1perms;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S1DirectBasePermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S1DirectBasePermissions</h3>
      <p class="pseudocode">// AArch64.S1DirectBasePermissions()
// =================================
// Computes the stage 1 direct base permissions

<a href="shared_pseudocode.html#S1AccessControls" title="type S1AccessControls is ( bit r, bit w, bit x, bit gcs, boolean overlay, bit or, bit ow, bit ox, bit wxn )">S1AccessControls</a> AArch64.S1DirectBasePermissions(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate,
                                                 S1TTWParams walkparams, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    bit  r,  w,  x;
    bit pr, pw, px;
    bit ur, uw, ux;
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions = walkstate.permissions;
    <a href="shared_pseudocode.html#S1AccessControls" title="type S1AccessControls is ( bit r, bit w, bit x, bit gcs, boolean overlay, bit or, bit ow, bit ox, bit wxn )">S1AccessControls</a> s1perms;

    if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        // Apply leaf permissions
        case permissions.ap&lt;2:1&gt; of
            when '00' (pr,pw,ur,uw) = ('1','1','0','0'); // Privileged access
            when '01' (pr,pw,ur,uw) = ('1','1','1','1'); // No effect
            when '10' (pr,pw,ur,uw) = ('1','0','0','0'); // Read-only, privileged access
            when '11' (pr,pw,ur,uw) = ('1','0','1','0'); // Read-only

        // Apply hierarchical permissions
        case permissions.ap_table of
            when '00' (pr,pw,ur,uw) = ( pr, pw, ur, uw); // No effect
            when '01' (pr,pw,ur,uw) = ( pr, pw,'0','0'); // Privileged access
            when '10' (pr,pw,ur,uw) = ( pr,'0', ur,'0'); // Read-only
            when '11' (pr,pw,ur,uw) = ( pr,'0','0','0'); // Read-only, privileged access

        // Locations writable by unprivileged cannot be executed by privileged
        px = NOT(permissions.pxn OR permissions.pxn_table OR uw);
        ux = NOT(permissions.uxn OR permissions.uxn_table);

        if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; accdesc.pan &amp;&amp; !(regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; walkparams.nv1 == '1') then
            bit pan;
            if (boolean IMPLEMENTATION_DEFINED "SCR_EL3.SIF affects EPAN" &amp;&amp;
                    accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp;
                    walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> &amp;&amp;
                    walkparams.sif == '1') then
                ux = '0';

            if (boolean IMPLEMENTATION_DEFINED "Realm <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>&amp;0 regime affects EPAN" &amp;&amp;
                    accdesc.ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> &amp;&amp; regime == <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> &amp;&amp;
                    walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>) then
                ux = '0';

            pan = PSTATE.PAN AND (ur OR uw OR (walkparams.epan AND ux));
            pr = pr AND NOT(pan);
            pw = pw AND NOT(pan);

    else
        // Apply leaf permissions
        case permissions.ap&lt;2&gt; of
            when '0' (pr,pw) = ('1','1'); // No effect
            when '1' (pr,pw) = ('1','0'); // Read-only

        // Apply hierarchical permissions
        case permissions.ap_table&lt;1&gt; of
            when '0' (pr,pw) = ( pr, pw); // No effect
            when '1' (pr,pw) = ( pr,'0'); // Read-only

        px = NOT(permissions.xn OR permissions.xn_table);

    (r,w,x) = if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then (ur,uw,ux) else (pr,pw,px);

    // Compute WXN value
    wxn = walkparams.wxn AND w AND x;

    // Prevent execution from Non-secure space by PE in secure state if SIF is set
    if accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
        x = x AND NOT(walkparams.sif);
    // Prevent execution from non-Root space by Root
    if accdesc.ss == <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a> &amp;&amp; walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a> then
        x = '0';
    // Prevent execution from non-Realm space by Realm EL2 and Realm EL2&amp;0
    if (accdesc.ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> &amp;&amp; regime IN {<a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>, <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>} &amp;&amp;
            walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>) then
        x = '0';

    s1perms.r   = r;
    s1perms.w   = w;
    s1perms.x   = x;
    s1perms.gcs = '0';
    s1perms.wxn = wxn;
    s1perms.overlay = TRUE;

    return s1perms;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S1HasAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S1HasAlignmentFault</h3>
      <p class="pseudocode">// AArch64.S1HasAlignmentFault()
// =============================
// Returns whether stage 1 output fails alignment requirement on data accesses
// to Device memory

boolean <a id="AArch64.S1HasAlignmentFault.4"/>AArch64.S1HasAlignmentFault(<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, boolean aligned,
                                    bit ntlsmd, <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs)
    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        return FALSE;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() &amp;&amp; accdesc.tagaccess &amp;&amp; accdesc.write then
        return (memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp;
                <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVICETAGSTORE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_DEVICETAGSTORE</a>) == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>);
    elsif accdesc.a32lsmd &amp;&amp; ntlsmd == '0' then
        return memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp;  memattrs.device != <a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</a>;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#AccessType_DCZero" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DCZero</a> then
        return memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
    else
        return memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp; !aligned;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S1IndirectBasePermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S1IndirectBasePermissions</h3>
      <p class="pseudocode">// AArch64.S1IndirectBasePermissions()
// ===================================
// Computes the stage 1 indirect base permissions

<a href="shared_pseudocode.html#S1AccessControls" title="type S1AccessControls is ( bit r, bit w, bit x, bit gcs, boolean overlay, bit or, bit ow, bit ox, bit wxn )">S1AccessControls</a> AArch64.S1IndirectBasePermissions(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate,
                                                   S1TTWParams walkparams,
                                                   <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)

    bit  r,  w,  x,  gcs,  wxn,   overlay;
    bit pr, pw, px, pgcs, pwxn, p_overlay;
    bit ur, uw, ux, ugcs, uwxn, u_overlay;
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions = walkstate.permissions;
    <a href="shared_pseudocode.html#S1AccessControls" title="type S1AccessControls is ( bit r, bit w, bit x, bit gcs, boolean overlay, bit or, bit ow, bit ox, bit wxn )">S1AccessControls</a> s1perms;

    // Apply privileged indirect permissions
    case permissions.ppi of
        when '0000' (pr,pw,px,pgcs) = ('0','0','0','0'); // No access
        when '0001' (pr,pw,px,pgcs) = ('1','0','0','0'); // Privileged read
        when '0010' (pr,pw,px,pgcs) = ('0','0','1','0'); // Privileged execute
        when '0011' (pr,pw,px,pgcs) = ('1','0','1','0'); // Privileged read and execute
        when '0100' (pr,pw,px,pgcs) = ('0','0','0','0'); // Reserved
        when '0101' (pr,pw,px,pgcs) = ('1','1','0','0'); // Privileged read and write
        when '0110' (pr,pw,px,pgcs) = ('1','1','1','0'); // Privileged read, write and execute
        when '0111' (pr,pw,px,pgcs) = ('1','1','1','0'); // Privileged read, write and execute
        when '1000' (pr,pw,px,pgcs) = ('1','0','0','0'); // Privileged read
        when '1001' (pr,pw,px,pgcs) = ('1','0','0','1'); // Privileged read and gcs
        when '1010' (pr,pw,px,pgcs) = ('1','0','1','0'); // Privileged read and execute
        when '1011' (pr,pw,px,pgcs) = ('0','0','0','0'); // Reserved
        when '1100' (pr,pw,px,pgcs) = ('1','1','0','0'); // Privileged read and write
        when '1101' (pr,pw,px,pgcs) = ('0','0','0','0'); // Reserved
        when '1110' (pr,pw,px,pgcs) = ('1','1','1','0'); // Privileged read, write and execute
        when '1111' (pr,pw,px,pgcs) = ('0','0','0','0'); // Reserved

    p_overlay = NOT(permissions.ppi[3]);
    pwxn = if permissions.ppi == '0110' then '1' else '0';

    if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        // Apply unprivileged indirect permissions
        case permissions.upi of
            when '0000' (ur,uw,ux,ugcs) = ('0','0','0','0'); // No access
            when '0001' (ur,uw,ux,ugcs) = ('1','0','0','0'); // Unprivileged read
            when '0010' (ur,uw,ux,ugcs) = ('0','0','1','0'); // Unprivileged execute
            when '0011' (ur,uw,ux,ugcs) = ('1','0','1','0'); // Unprivileged read and execute
            when '0100' (ur,uw,ux,ugcs) = ('0','0','0','0'); // Reserved
            when '0101' (ur,uw,ux,ugcs) = ('1','1','0','0'); // Unprivileged read and write
            when '0110' (ur,uw,ux,ugcs) = ('1','1','1','0'); // Unprivileged read, write and execute
            when '0111' (ur,uw,ux,ugcs) = ('1','1','1','0'); // Unprivileged read, write and execute
            when '1000' (ur,uw,ux,ugcs) = ('1','0','0','0'); // Unprivileged read
            when '1001' (ur,uw,ux,ugcs) = ('1','0','0','1'); // Unprivileged read and gcs
            when '1010' (ur,uw,ux,ugcs) = ('1','0','1','0'); // Unprivileged read and execute
            when '1011' (ur,uw,ux,ugcs) = ('0','0','0','0'); // Reserved
            when '1100' (ur,uw,ux,ugcs) = ('1','1','0','0'); // Unprivileged read and write
            when '1101' (ur,uw,ux,ugcs) = ('0','0','0','0'); // Reserved
            when '1110' (ur,uw,ux,ugcs) = ('1','1','1','0'); // Unprivileged read,write and execute
            when '1111' (ur,uw,ux,ugcs) = ('0','0','0','0'); // Reserved

        u_overlay = NOT(permissions.upi[3]);
        uwxn = if permissions.upi == '0110' then '1' else '0';

        // If the decoded permissions has either px or pgcs along with either uw or ugcs,
        // then all effective Stage 1 Base Permissions are set to 0
        if ((px == '1' || pgcs == '1') &amp;&amp; (uw == '1' || ugcs == '1')) then
            (pr,pw,px,pgcs) = ('0','0','0','0');
            (ur,uw,ux,ugcs) = ('0','0','0','0');

        if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; accdesc.pan &amp;&amp; !(regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; walkparams.nv1 == '1') then
            if PSTATE.PAN == '1' &amp;&amp; (permissions.upi != '0000') then
                (pr,pw) = ('0','0');

    if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        (r,w,x,gcs,wxn,overlay) = (ur,uw,ux,ugcs,uwxn,u_overlay);
    else
        (r,w,x,gcs,wxn,overlay) = (pr,pw,px,pgcs,pwxn,p_overlay);

    // Prevent execution from Non-secure space by PE in secure state if SIF is set
    if accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
        x = x AND NOT(walkparams.sif);
        gcs = '0';
    // Prevent execution from non-Root space by Root
    if accdesc.ss == <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a> &amp;&amp; walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a> then
        x = '0';
        gcs = '0';
    // Prevent execution from non-Realm space by Realm EL2 and Realm EL2&amp;0
    if (accdesc.ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> &amp;&amp; regime IN {<a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>, <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>} &amp;&amp;
        walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>) then
        x = '0';
        gcs = '0';

    s1perms.r       = r;
    s1perms.w       = w;
    s1perms.x       = x;
    s1perms.gcs     = gcs;
    s1perms.wxn     = wxn;
    s1perms.overlay = overlay == '1';

    return s1perms;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S1OverlayPermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S1OverlayPermissions</h3>
      <p class="pseudocode">// AArch64.S1OverlayPermissions()
// ==============================
// Computes the stage 1 overlay permissions

S1AccessControls <a id="AArch64.S1OverlayPermissions.3"/>AArch64.S1OverlayPermissions(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate,
                                              <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)

    bit  r,  w,  x;
    bit pr, pw, px;
    bit ur, uw, ux;
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions = walkstate.permissions;
    <a href="shared_pseudocode.html#S1AccessControls" title="type S1AccessControls is ( bit r, bit w, bit x, bit gcs, boolean overlay, bit or, bit ow, bit ox, bit wxn )">S1AccessControls</a> s1overlay_perms;

    S1PORType por = AArch64.S1POR(regime);
    integer bit_index = 4 * <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(permissions.po_index);
    bits(4) ppo = por&lt;bit_index+3:bit_index&gt;;

    // Apply privileged overlay permissions
    case ppo of
        when '0000' (pr,pw,px) = ('0','0','0'); // No access
        when '0001' (pr,pw,px) = ('1','0','0'); // Privileged read
        when '0010' (pr,pw,px) = ('0','0','1'); // Privileged execute
        when '0011' (pr,pw,px) = ('1','0','1'); // Privileged read and execute
        when '0100' (pr,pw,px) = ('0','1','0'); // Privileged write
        when '0101' (pr,pw,px) = ('1','1','0'); // Privileged read and write
        when '0110' (pr,pw,px) = ('0','1','1'); // Privileged write and execute
        when '0111' (pr,pw,px) = ('1','1','1'); // Privileged read, write and execute
        when '1xxx' (pr,pw,px) = ('0','0','0'); // Reserved

    if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        bits(4) upo = POR_EL0&lt;bit_index+3:bit_index&gt;;

        // Apply unprivileged overlay permissions
        case upo of
            when '0000' (ur,uw,ux) = ('0','0','0'); // No access
            when '0001' (ur,uw,ux) = ('1','0','0'); // Unprivileged read
            when '0010' (ur,uw,ux) = ('0','0','1'); // Unprivileged execute
            when '0011' (ur,uw,ux) = ('1','0','1'); // Unprivileged read and execute
            when '0100' (ur,uw,ux) = ('0','1','0'); // Unprivileged write
            when '0101' (ur,uw,ux) = ('1','1','0'); // Unprivileged read and write
            when '0110' (ur,uw,ux) = ('0','1','1'); // Unprivileged write and execute
            when '0111' (ur,uw,ux) = ('1','1','1'); // Unprivileged read, write and execute
            when '1xxx' (ur,uw,ux) = ('0','0','0'); // Reserved

    (r,w,x) = if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then (ur,uw,ux) else (pr,pw,px);

    s1overlay_perms.or = r;
    s1overlay_perms.ow = w;
    s1overlay_perms.ox = x;

    return s1overlay_perms;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S1TxSZFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S1TxSZFaults</h3>
      <p class="pseudocode">// AArch64.S1TxSZFaults()
// ======================
// Detect whether configuration of stage 1 TxSZ field generates a fault

boolean AArch64.S1TxSZFaults(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, S1TTWParams walkparams)
    mintxsz = <a href="shared_pseudocode.html#AArch64.S1MinTxSZ.4" title="function: integer AArch64.S1MinTxSZ(Regime regime, bit d128, bit ds, TGx tgx)">AArch64.S1MinTxSZ</a>(regime, walkparams.d128, walkparams.ds, walkparams.tgx);
    maxtxsz = <a href="shared_pseudocode.html#AArch64.MaxTxSZ.1" title="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; mintxsz then
        return (<a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()">Have52BitVAExt</a>() ||
                boolean IMPLEMENTATION_DEFINED "<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on TxSZ value below minimum");
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; maxtxsz then
        return boolean IMPLEMENTATION_DEFINED "<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on TxSZ value above maximum";

    return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2CheckPermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2CheckPermissions</h3>
      <p class="pseudocode">// AArch64.S2CheckPermissions()
// ============================
// Verifies memory access with available permissions.

(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a>, boolean) AArch64.S2CheckPermissions(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate,
                                                  S2TTWParams walkparams, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> ipa,
                                                  <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    <a href="shared_pseudocode.html#MemType" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a> memtype = walkstate.memattrs.memtype;
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions = walkstate.permissions;
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;
    <a href="shared_pseudocode.html#S2AccessControls" title="type S2AccessControls is ( bit r, bit w, bit x, bit r_rcw, bit w_rcw, bit r_mmu, bit w_mmu, bit toplevel0, bit toplevel1, boolean overlay, bit or, bit ow, bit ox, bit or_rcw, bit ow_rcw, bit or_mmu, bit ow_mmu, )">S2AccessControls</a> s2perms = AArch64.S2ComputePermissions(permissions, walkparams, accdesc);

    bit  r,  w;
    bit or, ow;

    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a> then
        r = s2perms.r_mmu;
        w = s2perms.w_mmu;
        or = s2perms.or_mmu;
        ow = s2perms.ow_mmu;
    elsif accdesc.rcw then
        r = s2perms.r_rcw;
        w = s2perms.w_rcw;
        or = s2perms.or_rcw;
        ow = s2perms.ow_rcw;
    else
        r = s2perms.r;
        w = s2perms.w;
        or = s2perms.or;
        ow = s2perms.ow;

    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a> then
        if (accdesc.toplevel &amp;&amp; accdesc.varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> &amp;&amp;
               ((walkparams.tl0 == '1' &amp;&amp; s2perms.toplevel0 == '0') ||
               (walkparams.tl1 == '1' &amp;&amp; s2perms.&lt;toplevel1,toplevel0&gt; == '10'))) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.toplevel   = TRUE;
        elsif (accdesc.toplevel &amp;&amp; accdesc.varange == <a href="shared_pseudocode.html#VARange_UPPER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a> &amp;&amp;
               ((walkparams.tl1 == '1' &amp;&amp; s2perms.toplevel1 == '0') ||
               (walkparams.tl0 == '1' &amp;&amp; s2perms.&lt;toplevel1,toplevel0&gt; == '01'))) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.toplevel   = TRUE;
        elsif walkparams.ptw == '1' &amp;&amp; memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        elsif s2perms.overlay &amp;&amp; or == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.overlay    = TRUE;
        elsif accdesc.write &amp;&amp; s2perms.overlay &amp;&amp; ow == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.overlay    = TRUE;
        // Prevent translation table walks in Non-secure space by Realm state
        elsif accdesc.ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> &amp;&amp; walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        elsif r == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        elsif accdesc.write &amp;&amp; w == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        elsif (accdesc.write &amp;&amp; !(walkparams.&lt;ha,hd&gt; == '11') &amp;&amp; walkparams.s2pie == '1' &amp;&amp;
                permissions.s2dirty == '0') then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.dirtybit   = TRUE;
            fault.write      = TRUE;
    // Stage 2 Permission fault due to AssuredOnly check
    elsif walkstate.s2assuredonly == '1' &amp;&amp; !ipa.s1assured then
        fault.statuscode  = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        fault.assuredonly = TRUE;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        if s2perms.overlay &amp;&amp; s2perms.ox == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.overlay    = TRUE;
        elsif (memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp;
                <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_INSTRDEVICE</a>) == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

        // Prevent execution from Non-secure space by Realm state
        elsif accdesc.ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> &amp;&amp; walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        elsif s2perms.x == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

    elsif accdesc.acctype == <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a> then
        if accdesc.cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> then
            if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; s2perms.overlay &amp;&amp; ow == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.overlay    = TRUE;
            if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; w == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        elsif !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; s2perms.overlay &amp;&amp; or == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.overlay    = TRUE;
        elsif (walkparams.cmow == '1' &amp;&amp;
                accdesc.opscope == <a href="shared_pseudocode.html#CacheOpScope_PoC" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a> &amp;&amp;
                accdesc.cacheop == <a href="shared_pseudocode.html#CacheOp_CleanInvalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a> &amp;&amp;
                s2perms.overlay &amp;&amp; ow == '0') then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.overlay    = TRUE;
        elsif !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; r == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        elsif (walkparams.cmow == '1' &amp;&amp;
                accdesc.opscope == <a href="shared_pseudocode.html#CacheOpScope_PoC" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a> &amp;&amp;
                accdesc.cacheop == <a href="shared_pseudocode.html#CacheOp_CleanInvalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a> &amp;&amp;
                w == '0') then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

    elsif accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a> then
        if (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; s2perms.overlay &amp;&amp; or == '0' &amp;&amp;
                boolean IMPLEMENTATION_DEFINED "Permission fault on <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> IC_IVAU execution") then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.overlay    = TRUE;
        elsif walkparams.cmow == '1' &amp;&amp; s2perms.overlay &amp;&amp; ow == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.overlay    = TRUE;
        elsif (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp;  r == '0' &amp;&amp;
                boolean IMPLEMENTATION_DEFINED "Permission fault on <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> IC_IVAU execution") then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        elsif walkparams.cmow == '1' &amp;&amp; w == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

    elsif accdesc.read &amp;&amp; s2perms.overlay &amp;&amp; or == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        fault.overlay    = TRUE;
        fault.write      = FALSE;
    elsif accdesc.write &amp;&amp; s2perms.overlay &amp;&amp; ow == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        fault.overlay    = TRUE;
        fault.write      = TRUE;
    elsif accdesc.read &amp;&amp; r == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        fault.write      = FALSE;
    elsif accdesc.write &amp;&amp; w == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        fault.write      = TRUE;
    elsif ((accdesc.tagaccess || accdesc.tagchecked) &amp;&amp;
            ipa.memattrs.tags == <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a> &amp;&amp;
            permissions.s2tag_na == '1') then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        fault.tagaccess  = TRUE;
        fault.write      = accdesc.tagaccess &amp;&amp; accdesc.write;
    elsif (accdesc.write &amp;&amp; !(walkparams.&lt;ha,hd&gt; == '11') &amp;&amp; walkparams.s2pie == '1' &amp;&amp;
            permissions.s2dirty == '0') then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
        fault.dirtybit   = TRUE;
        fault.write      = TRUE;

    // MRO* allows only RCW and MMU writes
    boolean mro;
    if s2perms.overlay then
        mro = (s2perms.&lt;w,w_rcw,w_mmu&gt; AND s2perms.&lt;ow,ow_rcw,ow_mmu&gt;) == '011';
    else
        mro = s2perms.&lt;w,w_rcw,w_mmu&gt; == '011';

    return (fault, mro);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2ComputePermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2ComputePermissions</h3>
      <p class="pseudocode">// AArch64.S2ComputePermissions()
// ==============================
// Compute the overall stage 2 permissions.

<a href="shared_pseudocode.html#S2AccessControls" title="type S2AccessControls is ( bit r, bit w, bit x, bit r_rcw, bit w_rcw, bit r_mmu, bit w_mmu, bit toplevel0, bit toplevel1, boolean overlay, bit or, bit ow, bit ox, bit or_rcw, bit ow_rcw, bit or_mmu, bit ow_mmu, )">S2AccessControls</a> AArch64.S2ComputePermissions(<a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions, S2TTWParams walkparams,
                                              <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)

    <a href="shared_pseudocode.html#S2AccessControls" title="type S2AccessControls is ( bit r, bit w, bit x, bit r_rcw, bit w_rcw, bit r_mmu, bit w_mmu, bit toplevel0, bit toplevel1, boolean overlay, bit or, bit ow, bit ox, bit or_rcw, bit ow_rcw, bit or_mmu, bit ow_mmu, )">S2AccessControls</a> s2perms;

    if walkparams.s2pie == '1' then
        s2perms = <a href="shared_pseudocode.html#AArch64.S2IndirectBasePermissions.2" title="function: S2AccessControls AArch64.S2IndirectBasePermissions(Permissions permissions,&#13; AccessDescriptor accdesc)">AArch64.S2IndirectBasePermissions</a>(permissions, accdesc);
        s2perms.overlay = <a href="shared_pseudocode.html#impl-shared.HaveS2POExt.0" title="function: boolean HaveS2POExt()">HaveS2POExt</a>() &amp;&amp; VTCR_EL2.S2POE == '1';
        if s2perms.overlay then
            s2overlay_perms = <a href="shared_pseudocode.html#AArch64.S2OverlayPermissions.2" title="function: S2AccessControls AArch64.S2OverlayPermissions(Permissions permissions, AccessDescriptor accdesc)">AArch64.S2OverlayPermissions</a>(permissions, accdesc);
            s2perms.or          = s2overlay_perms.or;
            s2perms.ow          = s2overlay_perms.ow;
            s2perms.ox          = s2overlay_perms.ox;
            s2perms.or_rcw      = s2overlay_perms.or_rcw;
            s2perms.ow_rcw      = s2overlay_perms.ow_rcw;
            s2perms.or_mmu      = s2overlay_perms.or_mmu;
            s2perms.ow_mmu      = s2overlay_perms.ow_mmu;

            s2perms.toplevel0   = s2perms.toplevel0 OR s2overlay_perms.toplevel0;
            s2perms.toplevel1   = s2perms.toplevel1 OR s2overlay_perms.toplevel1;
    else
        s2perms = <a href="shared_pseudocode.html#AArch64.S2DirectBasePermissions.2" title="function: S2AccessControls AArch64.S2DirectBasePermissions(Permissions permissions,&#13; AccessDescriptor accdesc)">AArch64.S2DirectBasePermissions</a>(permissions, accdesc);

    return s2perms;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2DirectBasePermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2DirectBasePermissions</h3>
      <p class="pseudocode">// AArch64.S2DirectBasePermissions()
// =================================
// Computes the stage 2 direct base permissions.

S2AccessControls <a id="AArch64.S2DirectBasePermissions.2"/>AArch64.S2DirectBasePermissions(<a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions,
                                                 <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    <a href="shared_pseudocode.html#S2AccessControls" title="type S2AccessControls is ( bit r, bit w, bit x, bit r_rcw, bit w_rcw, bit r_mmu, bit w_mmu, bit toplevel0, bit toplevel1, boolean overlay, bit or, bit ow, bit ox, bit or_rcw, bit ow_rcw, bit or_mmu, bit ow_mmu, )">S2AccessControls</a> s2perms;
    r = permissions.s2ap&lt;0&gt;;
    w = permissions.s2ap&lt;1&gt;;
    bit px, ux;
    case (permissions.s2xn:permissions.s2xnx) of
        when '00' (px,ux) = ('1','1');
        when '01' (px,ux) = ('0','1');
        when '10' (px,ux) = ('0','0');
        when '11' (px,ux) = ('1','0');

    x = if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then ux else px;
    s2perms.r = r;
    s2perms.w = w;
    s2perms.x = x;
    s2perms.r_rcw = r;
    s2perms.w_rcw = w;
    s2perms.r_mmu = r;
    s2perms.w_mmu = w;

    return s2perms;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2HasAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2HasAlignmentFault</h3>
      <p class="pseudocode">// AArch64.S2HasAlignmentFault()
// =============================
// Returns whether stage 2 output fails alignment requirement on data accesses
// to Device memory

boolean <a id="AArch64.S2HasAlignmentFault.3"/>AArch64.S2HasAlignmentFault(<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, boolean aligned,
                                    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs)
    if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        return FALSE;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() &amp;&amp; accdesc.tagaccess &amp;&amp; accdesc.write then
        return (memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp;
                <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVICETAGSTORE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_DEVICETAGSTORE</a>) == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>);
    elsif accdesc.acctype == <a href="shared_pseudocode.html#AccessType_DCZero" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DCZero</a> then
        return memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
    else
        return memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp; !aligned;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2InconsistentSL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2InconsistentSL</h3>
      <p class="pseudocode">// AArch64.S2InconsistentSL()
// ==========================
// Detect inconsistent configuration of stage 2 TxSZ and SL fields

boolean AArch64.S2InconsistentSL(S2TTWParams walkparams)
    startlevel   = AArch64.S2StartLevel(walkparams);
    levels       = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;
    granulebits  = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    descsizelog2 = 3;
    stride       = granulebits - descsizelog2;

    // Input address size must at least be large enough to be resolved from the start level
    sl_min_iasize = (
        levels * stride // Bits resolved by table walk, except initial level
        + granulebits   // Bits directly mapped to output address
        + 1);           // At least 1 more bit to be decoded by initial level

    // Can accomodate 1 more stride in the level + concatenation of up to 2^4 tables
    sl_max_iasize = sl_min_iasize + (stride-1) + 4;
    // Configured Input Address size
    iasize        = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);

    return iasize &lt; sl_min_iasize || iasize &gt; sl_max_iasize;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2IndirectBasePermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2IndirectBasePermissions</h3>
      <p class="pseudocode">// AArch64.S2IndirectBasePermissions()
// ===================================
// Computes the stage 2 indirect base permissions.

S2AccessControls <a id="AArch64.S2IndirectBasePermissions.2"/>AArch64.S2IndirectBasePermissions(<a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions,
                                                   <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    bit r, w;
    bit r_rcw, w_rcw;
    bit r_mmu, w_mmu;
    bit px, ux;
    bit toplevel0, toplevel1;
    <a href="shared_pseudocode.html#S2AccessControls" title="type S2AccessControls is ( bit r, bit w, bit x, bit r_rcw, bit w_rcw, bit r_mmu, bit w_mmu, bit toplevel0, bit toplevel1, boolean overlay, bit or, bit ow, bit ox, bit or_rcw, bit ow_rcw, bit or_mmu, bit ow_mmu, )">S2AccessControls</a> s2perms;

    bits(4) s2pi = permissions.s2pi;
    case s2pi of
        when '0000' (r,w,px,ux,w_rcw,w_mmu) = ('0','0','0','0','0','0');  // No Access
        when '0001' (r,w,px,ux,w_rcw,w_mmu) = ('0','0','0','0','0','0');  // Reserved
        when '0010' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO
        when '0011' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO-TL1
        when '0100' (r,w,px,ux,w_rcw,w_mmu) = ('0','1','0','0','0','0');  // Write Only
        when '0101' (r,w,px,ux,w_rcw,w_mmu) = ('0','0','0','0','0','0');  // Reserved
        when '0110' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO-TL0
        when '0111' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO-TL01
        when '1000' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','0','0');  // Read Only
        when '1001' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','1','0','0');  // Read, Unpriv Execute
        when '1010' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','1','0','0','0');  // Read, Priv Execute
        when '1011' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','1','1','0','0');  // Read, All Execute
        when '1100' (r,w,px,ux,w_rcw,w_mmu) = ('1','1','0','0','1','1');  // RW
        when '1101' (r,w,px,ux,w_rcw,w_mmu) = ('1','1','0','1','1','1');  // RW, Unpriv Execute
        when '1110' (r,w,px,ux,w_rcw,w_mmu) = ('1','1','1','0','1','1');  // RW, Priv Execute
        when '1111' (r,w,px,ux,w_rcw,w_mmu) = ('1','1','1','1','1','1');  // RW, All Execute

    x = if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then ux else px;

    // RCW and MMU read permissions.
    (r_rcw, r_mmu) = (r, r);

    // Stage 2 Top Level Permission Attributes.
    case s2pi of
        when '0110' (toplevel0,toplevel1) = ('1','0');
        when '0011' (toplevel0,toplevel1) = ('0','1');
        when '0111' (toplevel0,toplevel1) = ('1','1');
        otherwise   (toplevel0,toplevel1) = ('0','0');

    s2perms.r = r;
    s2perms.w = w;
    s2perms.x = x;
    s2perms.r_rcw = r_rcw;
    s2perms.r_mmu = r_mmu;
    s2perms.w_rcw = w_rcw;
    s2perms.w_mmu = w_mmu;
    s2perms.toplevel0 = toplevel0;
    s2perms.toplevel1 = toplevel1;

    return s2perms;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2InvalidSL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2InvalidSL</h3>
      <p class="pseudocode">// AArch64.S2InvalidSL()
// =====================
// Detect invalid configuration of SL field

boolean AArch64.S2InvalidSL(S2TTWParams walkparams)
    case walkparams.tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>
            case walkparams.sl2:walkparams.sl0 of
                when '1x1' return TRUE;
                when '11x' return TRUE;
                when '010' return <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>() &lt; 44;
                when '011' return !<a href="shared_pseudocode.html#impl-shared.HaveSmallTranslationTableExt.0" title="function: boolean HaveSmallTranslationTableExt()">HaveSmallTranslationTableExt</a>();
                otherwise  return FALSE;
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>
            case walkparams.sl0 of
                when '11' return walkparams.ds == '0';
                when '10' return <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>() &lt; 42;
                otherwise  return FALSE;
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>
            case walkparams.sl0 of
                when '11'  return TRUE;
                when '10'  return <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>() &lt; 44;
                otherwise  return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2OverlayPermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2OverlayPermissions</h3>
      <p class="pseudocode">// AArch64.S2OverlayPermissions()
// ==============================
// Computes the stage 2 overlay permissions.

S2AccessControls <a id="AArch64.S2OverlayPermissions.2"/>AArch64.S2OverlayPermissions(<a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    bit r, w;
    bit r_rcw, w_rcw;
    bit r_mmu, w_mmu;
    bit px, ux;
    bit toplevel0, toplevel1;
    <a href="shared_pseudocode.html#S2AccessControls" title="type S2AccessControls is ( bit r, bit w, bit x, bit r_rcw, bit w_rcw, bit r_mmu, bit w_mmu, bit toplevel0, bit toplevel1, boolean overlay, bit or, bit ow, bit ox, bit or_rcw, bit ow_rcw, bit or_mmu, bit ow_mmu, )">S2AccessControls</a> s2overlay_perms;

    integer index = 4 * <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(permissions.s2po_index);
    bits(4) s2po = S2POR_EL1[index+3 : index];
    case s2po of
        when '0000' (r,w,px,ux,w_rcw,w_mmu) = ('0','0','0','0','0','0');  // No Access
        when '0001' (r,w,px,ux,w_rcw,w_mmu) = ('0','0','0','0','0','0');  // Reserved
        when '0010' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO
        when '0011' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO-TL1
        when '0100' (r,w,px,ux,w_rcw,w_mmu) = ('0','1','0','0','0','0');  // Write Only
        when '0101' (r,w,px,ux,w_rcw,w_mmu) = ('0','0','0','0','0','0');  // Reserved
        when '0110' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO-TL0
        when '0111' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO-TL01
        when '1000' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','0','0');  // Read Only
        when '1001' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','1','0','0');  // Read, Unpriv Execute
        when '1010' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','1','0','0','0');  // Read, Priv Execute
        when '1011' (r,w,px,ux,w_rcw,w_mmu) = ('1','0','1','1','0','0');  // Read, All Execute
        when '1100' (r,w,px,ux,w_rcw,w_mmu) = ('1','1','0','0','1','1');  // RW
        when '1101' (r,w,px,ux,w_rcw,w_mmu) = ('1','1','0','1','1','1');  // RW, Unpriv Execute
        when '1110' (r,w,px,ux,w_rcw,w_mmu) = ('1','1','1','0','1','1');  // RW, Priv Execute
        when '1111' (r,w,px,ux,w_rcw,w_mmu) = ('1','1','1','1','1','1');  // RW, All Execute

    x = if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then ux else px;

    // RCW and MMU read permissions.
    (r_rcw, r_mmu) = (r, r);

    // Stage 2 Top Level Permission Attributes.
    case s2po of
        when '0110' (toplevel0,toplevel1) = ('1','0');
        when '0011' (toplevel0,toplevel1) = ('0','1');
        when '0111' (toplevel0,toplevel1) = ('1','1');
        otherwise   (toplevel0,toplevel1) = ('0','0');

    s2overlay_perms.or = r;
    s2overlay_perms.ow = w;
    s2overlay_perms.ox = x;
    s2overlay_perms.or_rcw = r_rcw;
    s2overlay_perms.ow_rcw = w_rcw;
    s2overlay_perms.or_mmu = r_mmu;
    s2overlay_perms.ow_mmu = w_mmu;
    s2overlay_perms.toplevel0 = toplevel0;
    s2overlay_perms.toplevel1 = toplevel1;

    return s2overlay_perms;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2TxSZFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2TxSZFaults</h3>
      <p class="pseudocode">// AArch64.S2TxSZFaults()
// ======================
// Detect whether configuration of stage 2 TxSZ field generates a fault

boolean AArch64.S2TxSZFaults(S2TTWParams walkparams, boolean s1aarch64)
    mintxsz = <a href="shared_pseudocode.html#AArch64.S2MinTxSZ.4" title="function: integer AArch64.S2MinTxSZ(bit d128, bit ds, TGx tgx, boolean s1aarch64)">AArch64.S2MinTxSZ</a>(walkparams.d128, walkparams.ds, walkparams.tgx, s1aarch64);
    maxtxsz = <a href="shared_pseudocode.html#AArch64.MaxTxSZ.1" title="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; mintxsz then
        return (<a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() ||
                boolean IMPLEMENTATION_DEFINED "<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on TxSZ value below minimum");
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; maxtxsz then
        return boolean IMPLEMENTATION_DEFINED "<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on TxSZ value above maximum";

    return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.VAIsOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.VAIsOutOfRange</h3>
      <p class="pseudocode">// AArch64.VAIsOutOfRange()
// ========================
// Check bits not resolved by translation are identical and of accepted value

boolean AArch64.VAIsOutOfRange(bits(64) va_in, <a href="shared_pseudocode.html#AccessType" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType</a> acctype,
                               <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, S1TTWParams walkparams)
    bits(64) va = va_in;

    addrtop = <a href="shared_pseudocode.html#AArch64.AddrTop.3" title="function: integer AArch64.AddrTop(bit tbid, AccessType acctype, bit tbi)">AArch64.AddrTop</a>(walkparams.tbid, acctype, walkparams.tbi);

    // If the VA has a Logical Address Tag then the bits holding the Logical Address Tag are
    // ignored when checking if the address is out of range.
    if walkparams.mtx == '1' then
        va&lt;59:56&gt; = if <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va) == <a href="shared_pseudocode.html#VARange_UPPER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a> then '1111' else '0000';

    // Input Address size
    iasize  = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);

    // The min value of TxSZ can be 8, with LVA3 implemented.
    // If TxSZ is set to 8 iasize becomes 64 - 8 = 56
    // If tbi is also set, addrtop becomes 55
    // Then the return statements check va&lt;56:55&gt;
    // The check here is to guard against this corner case.
    if addrtop &lt; iasize then
        return FALSE;

    if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        if <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va) == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;addrtop:iasize&gt;);
        else
            return !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(va&lt;addrtop:iasize&gt;);
    else
        return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;addrtop:iasize&gt;);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_memattr.AArch64.S2ApplyFWBMemAttrs"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_memattr/AArch64.S2ApplyFWBMemAttrs</h3>
      <p class="pseudocode">// AArch64.S2ApplyFWBMemAttrs()
// ============================
// Apply stage 2 forced Write-Back on stage 1 memory attributes.

MemoryAttributes <a id="AArch64.S2ApplyFWBMemAttrs.3"/>AArch64.S2ApplyFWBMemAttrs(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> s1_memattrs,
                                            bits(4) s2_attr, bits(2) s2_sh)
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs;

    if s2_attr&lt;2&gt; == '0' then          // S2 Device, S1 any
        s2_device = <a href="shared_pseudocode.html#impl-shared.DecodeDevice.1" title="function: DeviceType DecodeDevice(bits(2) device)">DecodeDevice</a>(s2_attr&lt;1:0&gt;);
        memattrs.memtype = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
        if s1_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            memattrs.device = <a href="shared_pseudocode.html#impl-shared.S2CombineS1Device.2" title="function: DeviceType S2CombineS1Device(DeviceType s1_device, DeviceType s2_device)">S2CombineS1Device</a>(s1_memattrs.device, s2_device);
        else
            memattrs.device = s2_device;

    elsif s2_attr&lt;1:0&gt; == '11' then    // S2 attr = S1 attr
        memattrs = s1_memattrs;

    elsif s2_attr&lt;1:0&gt; == '10' then    // Force writeback
        memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.inner.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
        memattrs.outer.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;

        if (s1_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp;
                s1_memattrs.inner.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>) then
            memattrs.inner.hints     = s1_memattrs.inner.hints;
            memattrs.inner.transient = s1_memattrs.inner.transient;
        else
            memattrs.inner.hints     = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.inner.transient = FALSE;

        if (s1_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp;
                s1_memattrs.outer.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>) then
            memattrs.outer.hints     = s1_memattrs.outer.hints;
            memattrs.outer.transient = s1_memattrs.outer.transient;
        else
            memattrs.outer.hints     = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.outer.transient = FALSE;

    else                               // Non-cacheable unless S1 is device
        if s1_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            memattrs = s1_memattrs;
        else
            <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> cacheability_attr;
            cacheability_attr.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;

            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner   = cacheability_attr;
            memattrs.outer   = cacheability_attr;

    s2_shareability = <a href="shared_pseudocode.html#impl-shared.DecodeShareability.1" title="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(s2_sh);
    memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.S2CombineS1Shareability.2" title="function: Shareability S2CombineS1Shareability(Shareability s1_shareability,&#13; Shareability s2_shareability)">S2CombineS1Shareability</a>(s1_memattrs.shareability, s2_shareability);
    memattrs.tags         = <a href="shared_pseudocode.html#impl-shared.S2MemTagType.2" title="function: MemTagType S2MemTagType(MemoryAttributes s2_memattrs, MemTagType s1_tagtype)">S2MemTagType</a>(memattrs, s1_memattrs.tags);
    memattrs.notagaccess  = (s2_attr&lt;3:1&gt; == '111' &amp;&amp; memattrs.tags == <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a>);

    memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);
    return memattrs;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64.GetS1TLBContext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64.GetS1TLBContext</h3>
      <p class="pseudocode">// AArch64.GetS1TLBContext()
// =========================
// Gather translation context for accesses with VA to match against TLB entries

TLBContext <a id="AArch64.GetS1TLBContext.4"/>AArch64.GetS1TLBContext(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> tlbcontext;

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  tlbcontext = <a href="shared_pseudocode.html#AArch64.TLBContextEL3.3" title="function: TLBContext AArch64.TLBContextEL3(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL3</a>(ss, va, tg);
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  tlbcontext = <a href="shared_pseudocode.html#AArch64.TLBContextEL2.3" title="function: TLBContext AArch64.TLBContextEL2(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL2</a>(ss, va, tg);
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> tlbcontext = <a href="shared_pseudocode.html#AArch64.TLBContextEL20.3" title="function: TLBContext AArch64.TLBContextEL20(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL20</a>(ss, va, tg);
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> tlbcontext = <a href="shared_pseudocode.html#AArch64.TLBContextEL10.3" title="function: TLBContext AArch64.TLBContextEL10(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL10</a>(ss, va, tg);

    tlbcontext.includes_s1  = TRUE;
    // The following may be amended for EL1&amp;0 Regime if caching of stage 2 is successful
    tlbcontext.includes_s2  = FALSE;
    // The following may be amended if Granule Protection Check passes
    tlbcontext.includes_gpt = FALSE;
    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64.GetS2TLBContext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64.GetS2TLBContext</h3>
      <p class="pseudocode">// AArch64.GetS2TLBContext()
// =========================
// Gather translation context for accesses with IPA to match against TLB entries

TLBContext <a id="AArch64.GetS2TLBContext.3"/>AArch64.GetS2TLBContext(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> ipa, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    assert <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss       = ss;
    tlbcontext.regime   = <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    tlbcontext.ipaspace = ipa.paspace;
    tlbcontext.vmid     = <a href="shared_pseudocode.html#impl-aarch64.VMID.read.0" title="accessor: bits(16) VMID[]">VMID</a>[];
    tlbcontext.tg       = tg;
    tlbcontext.ia       = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.address, 64);
    if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then
        tlbcontext.cnp = if ipa.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then VSTTBR_EL2.CnP else VTTBR_EL2.CnP;
    else
        tlbcontext.cnp = '0';

    tlbcontext.includes_s1  = FALSE;
    tlbcontext.includes_s2  = TRUE;
    // This amy be amended if Granule Protection Check passes
    tlbcontext.includes_gpt = FALSE;
    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64.TLBContextEL10"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64.TLBContextEL10</h3>
      <p class="pseudocode">// AArch64.TLBContextEL10()
// ========================
// Gather translation context for accesses under EL10 regime to match against TLB entries

TLBContext <a id="AArch64.TLBContextEL10.3"/>AArch64.TLBContextEL10(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    tlbcontext.vmid   = <a href="shared_pseudocode.html#impl-aarch64.VMID.read.0" title="accessor: bits(16) VMID[]">VMID</a>[];
    tlbcontext.asid   = if TCR_EL1.A1 == '0' then TTBR0_EL1.ASID else TTBR1_EL1.ASID;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;

    if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then
        if <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va) == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            tlbcontext.cnp = TTBR0_EL1.CnP;
        else
            tlbcontext.cnp = TTBR1_EL1.CnP;
    else
        tlbcontext.cnp = '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64.TLBContextEL2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64.TLBContextEL2</h3>
      <p class="pseudocode">// AArch64.TLBContextEL2()
// =======================
// Gather translation context for accesses under EL2 regime to match against TLB entries

TLBContext <a id="AArch64.TLBContextEL2.3"/>AArch64.TLBContextEL2(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;
    tlbcontext.cnp    = if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then TTBR0_EL2.CnP else '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64.TLBContextEL20"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64.TLBContextEL20</h3>
      <p class="pseudocode">// AArch64.TLBContextEL20()
// ========================
// Gather translation context for accesses under EL20 regime to match against TLB entries

TLBContext <a id="AArch64.TLBContextEL20.3"/>AArch64.TLBContextEL20(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>;
    tlbcontext.asid   = if TCR_EL2.A1 == '0' then TTBR0_EL2.ASID else TTBR1_EL2.ASID;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;

    if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then
        if <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va) == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            tlbcontext.cnp = TTBR0_EL2.CnP;
        else
            tlbcontext.cnp = TTBR1_EL2.CnP;
    else
        tlbcontext.cnp = '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64.TLBContextEL3"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64.TLBContextEL3</h3>
      <p class="pseudocode">// AArch64.TLBContextEL3()
// =======================
// Gather translation context for accesses under EL3 regime to match against TLB entries

TLBContext <a id="AArch64.TLBContextEL3.3"/>AArch64.TLBContextEL3(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;
    tlbcontext.cnp    = if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then TTBR0_EL3.CnP else '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.FullTranslate"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.FullTranslate</h3>
      <p class="pseudocode">// AArch64.FullTranslate()
// =======================
// Address translation as specified by VMSA
// Alignment check NOT due to memory type is expected to be done before translation

AddressDescriptor <a id="AArch64.FullTranslate.3"/>AArch64.FullTranslate(bits(64) va, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, boolean aligned)
    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.1" title="function: Regime TranslationRegime(bits(2) el)">TranslationRegime</a>(accdesc.el);
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.NoFault.1" title="function: FaultRecord NoFault(AccessDescriptor accdesc)">NoFault</a>(accdesc);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> ipa;
    (fault, ipa) = <a href="shared_pseudocode.html#AArch64.S1Translate.5" title="function: (FaultRecord, AddressDescriptor) AArch64.S1Translate(FaultRecord fault_in, Regime regime,&#13; bits(64) va, boolean aligned,&#13; AccessDescriptor accdesc)">AArch64.S1Translate</a>(fault, regime, va, aligned, accdesc);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return <a href="shared_pseudocode.html#impl-shared.CreateFaultyAddressDescriptor.2" title="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(va, fault);

    assert (accdesc.ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>) IMPLIES <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        s1aarch64 = TRUE;
        <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> pa;
        (fault, pa) = <a href="shared_pseudocode.html#AArch64.S2Translate.5" title="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean s1aarch64, boolean aligned,&#13; AccessDescriptor accdesc)">AArch64.S2Translate</a>(fault, ipa, s1aarch64, aligned, accdesc);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return <a href="shared_pseudocode.html#impl-shared.CreateFaultyAddressDescriptor.2" title="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(va, fault);
        else
            return pa;
    else
        return ipa;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.MemSwapTableDesc"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.MemSwapTableDesc</h3>
      <p class="pseudocode">// AArch64.MemSwapTableDesc()
// ==========================
// Perform HW update of table descriptor as an atomic operation

(FaultRecord, bits(N)) <a id="AArch64.MemSwapTableDesc.6"/>AArch64.MemSwapTableDesc(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, bits(N) prev_desc,
                                                bits(N) new_desc, bit ee,
                                                <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a>  descaccess,
                                                <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> descpaddr)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;
    boolean iswrite;

    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(descpaddr, descaccess);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnWalk</a>;
            fault.paddress   = descpaddr.paddress;
            fault.gpcfs2walk = fault.secondstage;
            return (fault, bits(N) UNKNOWN);

    // All observers in the shareability domain observe the
    // following memory read and write accesses atomically.
    bits(N) mem_desc;
    <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
    (memstatus, mem_desc) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(descpaddr, N DIV 8, descaccess);

    if ee == '1' then
        mem_desc = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(mem_desc);

    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        iswrite = FALSE;
        fault = <a href="shared_pseudocode.html#impl-shared.HandleExternalTTWAbort.6" title="function: FaultRecord HandleExternalTTWAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc,&#13; AccessDescriptor accdesc, integer size,&#13; FaultRecord input_fault)">HandleExternalTTWAbort</a>(memstatus, iswrite, descpaddr, descaccess, N DIV 8, fault);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(fault.statuscode) then
            return (fault, bits(N) UNKNOWN);

    if mem_desc == prev_desc  then
        ordered_new_desc = if ee == '1' then <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(new_desc) else new_desc;
        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(descpaddr, N DIV 8, descaccess, ordered_new_desc);

        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            iswrite = TRUE;
            fault = <a href="shared_pseudocode.html#impl-shared.HandleExternalTTWAbort.6" title="function: FaultRecord HandleExternalTTWAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc,&#13; AccessDescriptor accdesc, integer size,&#13; FaultRecord input_fault)">HandleExternalTTWAbort</a>(memstatus, iswrite, descpaddr, descaccess, N DIV 8,
                                           fault);

            if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(fault.statuscode) then
                return (fault, bits(N) UNKNOWN);

        // Reflect what is now in memory (in little endian format)
        mem_desc = new_desc;

    return (fault, mem_desc);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.S1DisabledOutput"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.S1DisabledOutput</h3>
      <p class="pseudocode">// AArch64.S1DisabledOutput()
// ==========================
// Map the VA to IPA/PA and assign default memory attributes

(FaultRecord, AddressDescriptor) <a id="AArch64.S1DisabledOutput.5"/>AArch64.S1DisabledOutput(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                          bits(64) va_in, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc,
                                                          boolean aligned)

    bits(64) va = va_in;
    walkparams = AArch64.GetS1TTWParams(regime, accdesc.ss, va);
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;

    // No memory page is guarded when stage 1 address translation is disabled
    <a href="shared_pseudocode.html#impl-aarch64.SetInGuardedPage.1" title="function: SetInGuardedPage(boolean guardedpage)">SetInGuardedPage</a>(FALSE);

    // Output Address
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> oa;
    oa.address = va&lt;55:0&gt;;
    case accdesc.ss of
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    oa.paspace = <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> oa.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>      oa.paspace = <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     oa.paspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs;
    if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; walkparams.dc == '1' then
        <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> default_cacheability;
        default_cacheability.attrs     = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
        default_cacheability.hints     = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
        default_cacheability.transient = FALSE;

        memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.outer        = default_cacheability;
        memattrs.inner        = default_cacheability;
        memattrs.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        if walkparams.dct == '1' then
            memattrs.tags     = <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a>;
        elsif walkparams.mtx == '1' then
            memattrs.tags     = <a href="shared_pseudocode.html#MemTag_CanonicallyTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_CanonicallyTagged</a>;
            if walkparams.tbi == '0' then
                // For the purpose of the checks in this function, the MTE tag bits are ignored.
                va&lt;59:56&gt;     = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(va&lt;55&gt;, 4);
        else
            memattrs.tags     = <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;
        memattrs.xs           = '0';
    elsif accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> i_cache_attr;
        if <a href="shared_pseudocode.html#AArch64.S1ICacheEnabled.1" title="function: boolean AArch64.S1ICacheEnabled(Regime regime)">AArch64.S1ICacheEnabled</a>(regime) then
            i_cache_attr.attrs     = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            i_cache_attr.hints     = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            i_cache_attr.transient = FALSE;
        else
            i_cache_attr.attrs     = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;

        memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.outer        = i_cache_attr;
        memattrs.inner        = i_cache_attr;
        memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        if walkparams.mtx == '1' then
            memattrs.tags     = <a href="shared_pseudocode.html#MemTag_CanonicallyTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_CanonicallyTagged</a>;
        else
            memattrs.tags     = <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;
        memattrs.xs           = '1';
    else
        memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
        memattrs.device       = <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
        memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        if walkparams.mtx == '1' then
            memattrs.tags = <a href="shared_pseudocode.html#MemTag_CanonicallyTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_CanonicallyTagged</a>;
            if walkparams.tbi == '0' then
                // For the purpose of the checks in this function, the MTE tag bits are ignored.
                if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
                    va&lt;59:56&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(va&lt;55&gt;, 4);
                else
                    va&lt;59:56&gt; = '0000';
        else
            memattrs.tags = <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;
        memattrs.xs           = '1';
    memattrs.notagaccess = FALSE;

    fault.level = 0;
    addrtop     = <a href="shared_pseudocode.html#AArch64.AddrTop.3" title="function: integer AArch64.AddrTop(bit tbid, AccessType acctype, bit tbi)">AArch64.AddrTop</a>(walkparams.tbid, accdesc.acctype, walkparams.tbi);

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;addrtop:<a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>()&gt;) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
    elsif <a href="shared_pseudocode.html#AArch64.S1HasAlignmentFault.4" title="function: boolean AArch64.S1HasAlignmentFault(AccessDescriptor accdesc, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch64.S1HasAlignmentFault</a>(accdesc, aligned, walkparams.ntlsmd, memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);
    else
        ipa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(va_in, oa, memattrs);
        ipa.mecid = AArch64.S1DisabledOutputMECID(walkparams, regime, ipa.paddress.paspace);
        return (fault, ipa);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.S1Translate"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.S1Translate</h3>
      <p class="pseudocode">// AArch64.S1Translate()
// =====================
// Translate VA to IPA/PA depending on the regime

(FaultRecord, AddressDescriptor) <a id="AArch64.S1Translate.5"/>AArch64.S1Translate(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                     bits(64) va, boolean aligned,
                                                     <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;
    // Prepare fault fields in case a fault is detected
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    if !<a href="shared_pseudocode.html#AArch64.S1Enabled.2" title="function: boolean AArch64.S1Enabled(Regime regime, AccessType acctype)">AArch64.S1Enabled</a>(regime, accdesc.acctype) then
        return <a href="shared_pseudocode.html#AArch64.S1DisabledOutput.5" title="function: (FaultRecord, AddressDescriptor) AArch64.S1DisabledOutput(FaultRecord fault_in, Regime regime,&#13; bits(64) va_in, AccessDescriptor accdesc,&#13; boolean aligned)">AArch64.S1DisabledOutput</a>(fault, regime, va, accdesc, aligned);

    walkparams = AArch64.GetS1TTWParams(regime, accdesc.ss, va);

    constant integer s1mintxsz = <a href="shared_pseudocode.html#AArch64.S1MinTxSZ.4" title="function: integer AArch64.S1MinTxSZ(Regime regime, bit d128, bit ds, TGx tgx)">AArch64.S1MinTxSZ</a>(regime, walkparams.d128,
                                                   walkparams.ds, walkparams.tgx);
    constant integer s1maxtxsz = <a href="shared_pseudocode.html#AArch64.MaxTxSZ.1" title="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);
    if AArch64.S1TxSZFaults(regime, walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);
    elsif <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; s1mintxsz then
        walkparams.txsz = s1mintxsz&lt;5:0&gt;;
    elsif <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; s1maxtxsz then
        walkparams.txsz = s1maxtxsz&lt;5:0&gt;;

    if AArch64.VAIsOutOfRange(va, accdesc.acctype, regime, walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; walkparams.e0pd == '1' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; walkparams.nfd == '1' &amp;&amp; accdesc.transactional then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    if accdesc.el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; walkparams.nfd == '1' &amp;&amp; (
            (accdesc.nonfault &amp;&amp; accdesc.contiguous) ||
            (accdesc.firstfault &amp;&amp; !accdesc.first &amp;&amp; !accdesc.contiguous)) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> descipaddr;
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    bits(128) descriptor;
    bits(128) new_desc;
    bits(128) mem_desc;
    repeat
        if walkparams.d128 == '1' then
            (fault, descipaddr, walkstate, descriptor) = AArch64.S1Walk(fault, walkparams, va,
                                                                        regime, accdesc, 128);
        else
            (fault, descipaddr, walkstate, descriptor&lt;63:0&gt;) = AArch64.S1Walk(fault, walkparams,
                                                                              va, regime, accdesc,
                                                                              64);
            descriptor&lt;127:64&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

        if accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
            // Flag the fetched instruction is from a guarded page
            <a href="shared_pseudocode.html#impl-aarch64.SetInGuardedPage.1" title="function: SetInGuardedPage(boolean guardedpage)">SetInGuardedPage</a>(walkstate.guardedpage == '1');

        if <a href="shared_pseudocode.html#AArch64.S1HasAlignmentFault.4" title="function: boolean AArch64.S1HasAlignmentFault(AccessDescriptor accdesc, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch64.S1HasAlignmentFault</a>(accdesc, aligned, walkparams.ntlsmd,
                                       walkstate.memattrs) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;

        if fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            fault = AArch64.S1CheckPermissions(fault, regime, walkstate, walkparams, accdesc);

        new_desc = descriptor;
        if walkparams.ha == '1' &amp;&amp; <a href="shared_pseudocode.html#AArch64.SettingAccessFlagPermitted.1" title="function: boolean AArch64.SettingAccessFlagPermitted(FaultRecord fault)">AArch64.SettingAccessFlagPermitted</a>(fault) then
            // Set descriptor AF bit
            new_desc&lt;10&gt; = '1';

        // If HW update of dirty bit is enabled, the walk state permissions
        // will already reflect a configuration permitting writes.
        // The update of the descriptor occurs only if the descriptor bits in
        // memory do not reflect that and the access instigates a write.

        if (<a href="shared_pseudocode.html#AArch64.SettingDirtyStatePermitted.1" title="function: boolean AArch64.SettingDirtyStatePermitted(FaultRecord fault)">AArch64.SettingDirtyStatePermitted</a>(fault) &amp;&amp;
                walkparams.ha  == '1' &amp;&amp;
                walkparams.hd  == '1' &amp;&amp;
                (walkparams.pie == '1' || descriptor&lt;51&gt; == '1') &amp;&amp;
                accdesc.write &amp;&amp;
                !(accdesc.acctype IN {<a href="shared_pseudocode.html#AccessType_AT" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_AT</a>, <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>})) then
            // Clear descriptor AP[2]/nDirty bit permitting stage 1 writes
            new_desc&lt;7&gt; = '0';

        // Either the access flag was clear or AP[2]/nDirty is set
        if new_desc != descriptor then
            <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> descpaddr;
            descaccess = <a href="shared_pseudocode.html#impl-shared.CreateAccDescTTEUpdate.1" title="function: AccessDescriptor CreateAccDescTTEUpdate(AccessDescriptor accdesc_in)">CreateAccDescTTEUpdate</a>(accdesc);
            if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
                <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> s2fault;
                s1aarch64 = TRUE;
                s2aligned = TRUE;
                (s2fault, descpaddr) = <a href="shared_pseudocode.html#AArch64.S2Translate.5" title="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean s1aarch64, boolean aligned,&#13; AccessDescriptor accdesc)">AArch64.S2Translate</a>(fault, descipaddr, s1aarch64, s2aligned,
                                                           descaccess);

                if s2fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                    return (s2fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

            else
                descpaddr = descipaddr;
            if walkparams.d128 == '1' then
                (fault, mem_desc) = <a href="shared_pseudocode.html#AArch64.MemSwapTableDesc.6" title="function: (FaultRecord, bits(N)) AArch64.MemSwapTableDesc(FaultRecord fault_in, bits(N) prev_desc,&#13; bits(N) new_desc, bit ee,&#13; AccessDescriptor  descaccess,&#13; AddressDescriptor descpaddr)">AArch64.MemSwapTableDesc</a>(fault, descriptor, new_desc,
                                                             walkparams.ee, descaccess, descpaddr);
            else
                (fault, mem_desc&lt;63:0&gt;) = <a href="shared_pseudocode.html#AArch64.MemSwapTableDesc.6" title="function: (FaultRecord, bits(N)) AArch64.MemSwapTableDesc(FaultRecord fault_in, bits(N) prev_desc,&#13; bits(N) new_desc, bit ee,&#13; AccessDescriptor  descaccess,&#13; AddressDescriptor descpaddr)">AArch64.MemSwapTableDesc</a>(fault, descriptor&lt;63:0&gt;,
                                                                   new_desc&lt;63:0&gt;, walkparams.ee,
                                                                   descaccess, descpaddr);
                mem_desc&lt;127:64&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

    until new_desc == descriptor || mem_desc == new_desc;

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    // Output Address
    oa = <a href="shared_pseudocode.html#impl-shared.StageOA.4" title="function: FullAddress StageOA(bits(64) ia, bit d128, TGx tgx, TTWState walkstate)">StageOA</a>(va, walkparams.d128, walkparams.tgx, walkstate);
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs;
    if (accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> &amp;&amp;
        (walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || !<a href="shared_pseudocode.html#AArch64.S1ICacheEnabled.1" title="function: boolean AArch64.S1ICacheEnabled(Regime regime)">AArch64.S1ICacheEnabled</a>(regime))) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;
    elsif (accdesc.acctype != <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> &amp;&amp; !<a href="shared_pseudocode.html#AArch64.S1DCacheEnabled.1" title="function: boolean AArch64.S1DCacheEnabled(Regime regime)">AArch64.S1DCacheEnabled</a>(regime) &amp;&amp;
             walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;

        // The effect of SCTLR_ELx.C when '0' is Constrained UNPREDICTABLE
        // on the Tagged attribute
        if (<a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; walkstate.memattrs.tags == <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a> &amp;&amp;
            !<a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_S1CTAGGED" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_S1CTAGGED</a>)) then
            memattrs.tags = <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;
    else
        memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.VM == '1' &amp;&amp;
            !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        memattrs.shareability = walkstate.memattrs.shareability;
    else
        memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);

    if accdesc.ls64 &amp;&amp; memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> then
        if memattrs.inner.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> || memattrs.outer.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>;
            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    ipa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(va, oa, memattrs);
    ipa.s1assured = walkstate.s1assured;
    varange   = <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va);
    ipa.mecid = AArch64.S1OutputMECID(walkparams, regime, varange, ipa.paddress.paspace,
                                      descriptor);
    return (fault, ipa);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.S2Translate"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.S2Translate</h3>
      <p class="pseudocode">// AArch64.S2Translate()
// =====================
// Translate stage 1 IPA to PA and combine memory attributes

(FaultRecord, AddressDescriptor) <a id="AArch64.S2Translate.5"/>AArch64.S2Translate(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> ipa,
                                                     boolean s1aarch64, boolean aligned,
                                                     <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)

    walkparams = AArch64.GetS2TTWParams(accdesc.ss, ipa.paddress.paspace, s1aarch64);
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;
    boolean s2fs1mro;

    // Prepare fault fields in case a fault is detected
    fault.statuscode  = <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>; // Ignore any faults from stage 1
    fault.secondstage = TRUE;
    fault.s2fs1walk   = accdesc.acctype == <a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a>;
    fault.ipaddress   = ipa.paddress;

    if walkparams.vm != '1' then
        // Stage 2 translation is disabled
        return (fault, ipa);

    constant integer s2mintxsz = <a href="shared_pseudocode.html#AArch64.S2MinTxSZ.4" title="function: integer AArch64.S2MinTxSZ(bit d128, bit ds, TGx tgx, boolean s1aarch64)">AArch64.S2MinTxSZ</a>(walkparams.d128, walkparams.ds,
                                                   walkparams.tgx, s1aarch64);
    constant integer s2maxtxsz = <a href="shared_pseudocode.html#AArch64.MaxTxSZ.1" title="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);
    if AArch64.S2TxSZFaults(walkparams, s1aarch64) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);
    elsif <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; s2mintxsz then
        walkparams.txsz = s2mintxsz&lt;5:0&gt;;
    elsif <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; s2maxtxsz then
        walkparams.txsz = s2maxtxsz&lt;5:0&gt;;

    if (walkparams.d128 == '0' &amp;&amp;
        (AArch64.S2InvalidSL(walkparams) || AArch64.S2InconsistentSL(walkparams))) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    if AArch64.IPAIsOutOfRange(ipa.paddress.address, walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> descpaddr;
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    bits(128) descriptor;
    bits(128) new_desc;
    bits(128) mem_desc;
    repeat
        if walkparams.d128 == '1' then
            (fault, descpaddr, walkstate, descriptor) = AArch64.S2Walk(fault, ipa, walkparams,
                                                                       accdesc, 128);
        else
            (fault, descpaddr, walkstate, descriptor&lt;63:0&gt;) = AArch64.S2Walk(fault, ipa,
                                                                             walkparams, accdesc,
                                                                             64);
            descriptor&lt;127:64&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

        if <a href="shared_pseudocode.html#AArch64.S2HasAlignmentFault.3" title="function: boolean AArch64.S2HasAlignmentFault(AccessDescriptor accdesc, boolean aligned,&#13; MemoryAttributes memattrs)">AArch64.S2HasAlignmentFault</a>(accdesc, aligned, walkstate.memattrs) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;

        if fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            (fault, s2fs1mro) = AArch64.S2CheckPermissions(fault, walkstate, walkparams, ipa,
                                                           accdesc);

        new_desc = descriptor;
        if walkparams.ha == '1' &amp;&amp; <a href="shared_pseudocode.html#AArch64.SettingAccessFlagPermitted.1" title="function: boolean AArch64.SettingAccessFlagPermitted(FaultRecord fault)">AArch64.SettingAccessFlagPermitted</a>(fault) then
            // Set descriptor AF bit
            new_desc&lt;10&gt; = '1';

        // If HW update of dirty bit is enabled, the walk state permissions
        // will already reflect a configuration permitting writes.
        // The update of the descriptor occurs only if the descriptor bits in
        // memory do not reflect that and the access instigates a write.

        if (<a href="shared_pseudocode.html#AArch64.SettingDirtyStatePermitted.1" title="function: boolean AArch64.SettingDirtyStatePermitted(FaultRecord fault)">AArch64.SettingDirtyStatePermitted</a>(fault) &amp;&amp;
                walkparams.ha  == '1' &amp;&amp;
                walkparams.hd  == '1' &amp;&amp;
                (walkparams.s2pie == '1' || descriptor&lt;51&gt; == '1') &amp;&amp;
                accdesc.write &amp;&amp;
                !(accdesc.acctype IN {<a href="shared_pseudocode.html#AccessType_AT" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_AT</a>, <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>, <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>})) then
            // Set descriptor S2AP[1]/Dirty bit permitting stage 2 writes
            new_desc&lt;7&gt; = '1';

        // Either the access flag was clear or S2AP[1]/Dirty is clear
        if new_desc != descriptor then
            <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> descaccess = <a href="shared_pseudocode.html#impl-shared.CreateAccDescTTEUpdate.1" title="function: AccessDescriptor CreateAccDescTTEUpdate(AccessDescriptor accdesc_in)">CreateAccDescTTEUpdate</a>(accdesc);
            if walkparams.d128 == '1' then
                (fault, mem_desc) = <a href="shared_pseudocode.html#AArch64.MemSwapTableDesc.6" title="function: (FaultRecord, bits(N)) AArch64.MemSwapTableDesc(FaultRecord fault_in, bits(N) prev_desc,&#13; bits(N) new_desc, bit ee,&#13; AccessDescriptor  descaccess,&#13; AddressDescriptor descpaddr)">AArch64.MemSwapTableDesc</a>(fault, descriptor, new_desc,
                                                             walkparams.ee, descaccess,
                                                             descpaddr);
            else
                (fault, mem_desc&lt;63:0&gt;) = <a href="shared_pseudocode.html#AArch64.MemSwapTableDesc.6" title="function: (FaultRecord, bits(N)) AArch64.MemSwapTableDesc(FaultRecord fault_in, bits(N) prev_desc,&#13; bits(N) new_desc, bit ee,&#13; AccessDescriptor  descaccess,&#13; AddressDescriptor descpaddr)">AArch64.MemSwapTableDesc</a>(fault, descriptor&lt;63:0&gt;,
                                                                   new_desc&lt;63:0&gt;, walkparams.ee,
                                                                   descaccess, descpaddr);
                mem_desc&lt;127:64&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

    until new_desc == descriptor || mem_desc == new_desc;

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    ipa_64 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address, 64);
    // Output Address
    oa = <a href="shared_pseudocode.html#impl-shared.StageOA.4" title="function: FullAddress StageOA(bits(64) ia, bit d128, TGx tgx, TTWState walkstate)">StageOA</a>(ipa_64, walkparams.d128, walkparams.tgx, walkstate);
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> s2_memattrs;
    if ((accdesc.acctype == <a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a> &amp;&amp;
            walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp; walkparams.ptw == '0') ||
        (accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || HCR_EL2.ID == '1')) ||
        (accdesc.acctype != <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp; HCR_EL2.CD == '1')) then
        // Treat memory attributes as Normal Non-Cacheable
        s2_memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        s2_memattrs.xs = walkstate.memattrs.xs;
    else
        s2_memattrs = walkstate.memattrs;

    if accdesc.ls64 &amp;&amp; s2_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> then
        if s2_memattrs.inner.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> || s2_memattrs.outer.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>;
            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs;
    if walkparams.fwb == '0' then
        memattrs = <a href="shared_pseudocode.html#impl-shared.S2CombineS1MemAttrs.2" title="function: MemoryAttributes S2CombineS1MemAttrs(MemoryAttributes s1_memattrs,&#13; MemoryAttributes s2_memattrs)">S2CombineS1MemAttrs</a>(ipa.memattrs, s2_memattrs);
    else
        memattrs = s2_memattrs;

    pa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(ipa.vaddress, oa, memattrs);
    pa.s2fs1mro = s2fs1mro;
    pa.mecid = AArch64.S2OutputMECID(walkparams, pa.paddress.paspace, descriptor);
    return (fault, pa);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.SettingAccessFlagPermitted"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.SettingAccessFlagPermitted</h3>
      <p class="pseudocode">// AArch64.SettingAccessFlagPermitted()
// ====================================
// Determine whether the access flag could be set by HW given the fault status

boolean <a id="AArch64.SettingAccessFlagPermitted.1"/>AArch64.SettingAccessFlagPermitted(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    if fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return TRUE;
    elsif fault.statuscode IN {<a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>, <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>} then
        return <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_AFUPDATE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_AFUPDATE</a>);
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.SettingDirtyStatePermitted"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.SettingDirtyStatePermitted</h3>
      <p class="pseudocode">// AArch64.SettingDirtyStatePermitted()
// ====================================
// Determine whether the dirty state could be set by HW given the fault status

boolean <a id="AArch64.SettingDirtyStatePermitted.1"/>AArch64.SettingDirtyStatePermitted(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    if fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return TRUE;
    elsif fault.statuscode == <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a> then
        return <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_DBUPDATE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_DBUPDATE</a>);
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.TranslateAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.TranslateAddress</h3>
      <p class="pseudocode">// AArch64.TranslateAddress()
// ==========================
// Main entry point for translating an address

AddressDescriptor <a id="AArch64.TranslateAddress.4"/>AArch64.TranslateAddress(bits(64) va, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc,
                                           boolean aligned, integer size)
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> result = <a href="shared_pseudocode.html#AArch64.FullTranslate.3" title="function: AddressDescriptor AArch64.FullTranslate(bits(64) va, AccessDescriptor accdesc, boolean aligned)">AArch64.FullTranslate</a>(va, accdesc, aligned);

    if !<a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(result) &amp;&amp; accdesc.acctype != <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        result.fault = <a href="shared_pseudocode.html#AArch64.CheckDebug.3" title="function: FaultRecord AArch64.CheckDebug(bits(64) vaddress, AccessDescriptor accdesc, integer size)">AArch64.CheckDebug</a>(va, accdesc, size);

    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(result) &amp;&amp; (
            accdesc.acctype != <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a> ||
            boolean IMPLEMENTATION_DEFINED "GPC <a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on DC operations") then
        result.fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(result, accdesc);

        if result.fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
            result.fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>;
            result.fault.paddress   = result.paddress;

    if !<a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(result) &amp;&amp; accdesc.acctype == <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a> then
        result.fault = <a href="shared_pseudocode.html#AArch64.CheckDebug.3" title="function: FaultRecord AArch64.CheckDebug(bits(64) vaddress, AccessDescriptor accdesc, integer size)">AArch64.CheckDebug</a>(va, accdesc, size);

    // Update virtual address for abort functions
    result.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.BlockDescSupported"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.BlockDescSupported</h3>
      <p class="pseudocode">// AArch64.BlockDescSupported()
// ============================
// Determine whether a block descriptor is valid for the given granule size
// and level

boolean <a id="AArch64.BlockDescSupported.4"/>AArch64.BlockDescSupported(bit d128, bit ds, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    case tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  return ((level == 0 &amp;&amp; (ds == '1' || d128 == '1')) ||
                               level == 1 ||
                               level == 2);
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> return ((level == 1 &amp;&amp; (ds == '1' || d128 == '1')) ||
                               level == 2);
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> return ((level == 1 &amp;&amp; (d128 == '1' || <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>() &gt;= 52)) ||
                               level == 2);
    return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.BlocknTFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.BlocknTFaults</h3>
      <p class="pseudocode">// AArch64.BlocknTFaults()
// =======================
// Identify whether the nT bit in a block descriptor is effectively set
// causing a translation fault

boolean <a id="AArch64.BlocknTFaults.2"/>AArch64.BlocknTFaults(bit d128, bits(N) descriptor)
    bit nT;
    if !<a href="shared_pseudocode.html#impl-shared.HaveBlockBBM.0" title="function: boolean HaveBlockBBM()">HaveBlockBBM</a>() then
        return FALSE;
    nT = if d128 == '1' then descriptor&lt;6&gt; else descriptor&lt;16&gt;;
    bbm_level = <a href="shared_pseudocode.html#AArch64.BlockBBMSupportLevel.0" title="function: integer AArch64.BlockBBMSupportLevel()">AArch64.BlockBBMSupportLevel</a>();
    nT_faults = boolean IMPLEMENTATION_DEFINED "BBM level 1 or 2 support nT bit causes Translation <a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a>";

    return bbm_level IN {1, 2} &amp;&amp; nT == '1' &amp;&amp; nT_faults;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.ContiguousBit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.ContiguousBit</h3>
      <p class="pseudocode">// AArch64.ContiguousBit()
// =======================
// Get the value of the contiguous bit

bit <a id="AArch64.ContiguousBit.4"/>AArch64.ContiguousBit(<a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, bit d128, integer level, bits(N) descriptor)
    if d128 == '1' then
        return descriptor&lt;111&gt;;
    // When using TGx 64KB and FEAT_LPA is implememted,
    // the Contiguous bit is RES0 for Block descriptors at level 1

    if tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; level == 1 then
        return '0'; // RES0

    // When the effective value of TCR_ELx.DS is '1',
    // the Contiguous bit is RES0 for all the following:
    //      * For TGx 4KB, Block descriptors at level 0
    //      * For TGx 16KB, Block descriptors at level 1

    if tgx == <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> &amp;&amp; level == 1 then
        return '0'; // RES0

    if tgx == <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  &amp;&amp; level == 0 then
        return '0'; // RES0

    return descriptor&lt;52&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.DecodeDescriptorType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.DecodeDescriptorType</h3>
      <p class="pseudocode">// AArch64.DecodeDescriptorType()
// ==============================
// Determine whether the descriptor is a page, block or table

DescriptorType <a id="AArch64.DecodeDescriptorType.5"/>AArch64.DecodeDescriptorType(bits(N) descriptor, bit d128, bit ds,
                                            <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    if descriptor&lt;0&gt; == '0' then
        return <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>;
    elsif d128 == '1' then
        bits(2) skl = descriptor&lt;110:109&gt;;
        if tgx IN {<a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>, <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(skl) == 3 then
            return <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>;

        integer effective_level = level + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(skl);
        if effective_level &gt; <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
            return <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>;
        elsif effective_level == <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
            return <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>;
        else
            return <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>;
    else
        if descriptor&lt;1&gt; == '1' then
            if level == <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
                return <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>;
            else
                return <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>;
        elsif descriptor&lt;1&gt; == '0' then
            if <a href="shared_pseudocode.html#AArch64.BlockDescSupported.4" title="function: boolean AArch64.BlockDescSupported(bit d128, bit ds, TGx tgx, integer level)">AArch64.BlockDescSupported</a>(d128, ds, tgx, level) then
                return <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>;
            else
                return <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.S1ApplyOutputPerms"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.S1ApplyOutputPerms</h3>
      <p class="pseudocode">// AArch64.S1ApplyOutputPerms()
// ============================
// Apply output permissions encoded in stage 1 page/block descriptors

<a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> AArch64.S1ApplyOutputPerms(<a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions_in, bits(N) descriptor,
                                       <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, S1TTWParams walkparams)
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions = permissions_in;

    bits (4) pi_index;
    if walkparams.pie == '1' then
        if walkparams.d128 == '1' then
            pi_index = descriptor&lt;118:115&gt;;
        else
            pi_index = descriptor&lt;54:53&gt;:descriptor&lt;51&gt;:descriptor&lt;6&gt;;
        bit_index          = 4 * <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pi_index);
        permissions.ppi    = walkparams.pir&lt;bit_index+3:bit_index&gt;;
        permissions.upi    = walkparams.pire0&lt;bit_index+3:bit_index&gt;;
        permissions.ndirty = descriptor&lt;7&gt;;
    else
        if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; walkparams.nv1 == '1' then
            permissions.ap&lt;2:1&gt; = descriptor&lt;7&gt;:'0';
            permissions.pxn     = descriptor&lt;54&gt;;
        elsif <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
            permissions.ap&lt;2:1&gt; = descriptor&lt;7:6&gt;;
            permissions.uxn     = descriptor&lt;54&gt;;
            permissions.pxn     = descriptor&lt;53&gt;;
        else
            permissions.ap&lt;2:1&gt; = descriptor&lt;7&gt;:'1';
            permissions.xn      = descriptor&lt;54&gt;;
        // Descriptors marked with DBM set have the effective value of AP[2] cleared.
        // This implies no Permission faults caused by lack of write permissions are
        // reported, and the Dirty bit can be set.
        if walkparams.ha == '1' &amp;&amp; walkparams.hd == '1' &amp;&amp; descriptor&lt;51&gt; == '1' then
            permissions.ap&lt;2&gt; = '0';

    boolean poe   = <a href="shared_pseudocode.html#AArch64.S1POEnabled.1" title="function: boolean AArch64.S1POEnabled(Regime regime)">AArch64.S1POEnabled</a>(regime);
    boolean e0poe = <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) &amp;&amp; <a href="shared_pseudocode.html#AArch64.S1E0POEnabled.2" title="function: boolean AArch64.S1E0POEnabled(Regime regime, bit nv1)">AArch64.S1E0POEnabled</a>(regime, walkparams.nv1);

    if poe || e0poe then
        if walkparams.d128 == '1' then
            permissions.po_index = descriptor&lt;124:121&gt;;
        else
            permissions.po_index = '0':descriptor&lt;62:60&gt;;

    return permissions;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.S1ApplyTablePerms"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.S1ApplyTablePerms</h3>
      <p class="pseudocode">// AArch64.S1ApplyTablePerms()
// ===========================
// Apply hierarchical permissions encoded in stage 1 table descriptors

<a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> AArch64.S1ApplyTablePerms(<a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions_in, bits(N) descriptor,
                                      <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, S1TTWParams walkparams)
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions = permissions_in;
    bits(2) ap_table;
    bit pxn_table;
    bit uxn_table;
    bit xn_table;
    if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; walkparams.nv1 == '1' then
        if walkparams.d128 == '1' then
            ap_table  = descriptor&lt;126&gt;:'0';
            pxn_table = descriptor&lt;124&gt;;
        else
            ap_table  = descriptor&lt;62&gt;:'0';
            pxn_table = descriptor&lt;60&gt;;
        permissions.ap_table  = permissions.ap_table  OR ap_table;
        permissions.pxn_table = permissions.pxn_table OR pxn_table;

    elsif <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        if walkparams.d128 == '1' then
            ap_table  = descriptor&lt;126:125&gt;;
            uxn_table = descriptor&lt;124&gt;;
            pxn_table = descriptor&lt;123&gt;;
        else
            ap_table  = descriptor&lt;62:61&gt;;
            uxn_table = descriptor&lt;60&gt;;
            pxn_table = descriptor&lt;59&gt;;
        permissions.ap_table  = permissions.ap_table  OR ap_table;
        permissions.uxn_table = permissions.uxn_table OR uxn_table;
        permissions.pxn_table = permissions.pxn_table OR pxn_table;
    else
        if walkparams.d128 == '1' then
            ap_table = descriptor&lt;126&gt;:'0';
            xn_table = descriptor&lt;124&gt;;
        else
            ap_table = descriptor&lt;62&gt;:'0';
            xn_table = descriptor&lt;60&gt;;
        permissions.ap_table = permissions.ap_table OR ap_table;
        permissions.xn_table = permissions.xn_table OR xn_table;

    return permissions;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.S2ApplyOutputPerms"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.S2ApplyOutputPerms</h3>
      <p class="pseudocode">// AArch64.S2ApplyOutputPerms()
// ============================
// Apply output permissions encoded in stage 2 page/block descriptors

<a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> AArch64.S2ApplyOutputPerms(bits(N) descriptor, S2TTWParams walkparams)
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions;
    bits(4) s2pi_index;
    if walkparams.s2pie == '1' then
        if walkparams.d128 == '1' then
            s2pi_index = descriptor&lt;118:115&gt;;
        else
            s2pi_index = descriptor&lt;54:53,51,6&gt;;
        bit_index = 4 * <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(s2pi_index);
        permissions.s2pi = walkparams.s2pir&lt;bit_index+3 : bit_index&gt;;
        permissions.s2dirty = descriptor&lt;7&gt;;
    else
        permissions.s2ap = descriptor&lt;7:6&gt;;
        if walkparams.d128 == '1' then
            permissions.s2xn = descriptor&lt;118&gt;;
        else
            permissions.s2xn = descriptor&lt;54&gt;;

        if <a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()">HaveExtendedExecuteNeverExt</a>() then
            if walkparams.d128 == '1' then
                permissions.s2xnx = descriptor&lt;117&gt;;
            else
                permissions.s2xnx = descriptor&lt;53&gt;;
        else
            permissions.s2xnx = '0';

        // Descriptors marked with DBM set have the effective value of S2AP[1] set.
        // This implies no Permission faults caused by lack of write permissions are
        // reported, and the Dirty bit can be set.
        bit desc_dbm;
        if walkparams.d128 == '1' then
            desc_dbm = descriptor&lt;115&gt;;
        else
            desc_dbm = descriptor&lt;51&gt;;
        if walkparams.ha == '1' &amp;&amp; walkparams.hd == '1' &amp;&amp; desc_dbm == '1' then
            permissions.s2ap&lt;1&gt; = '1';
    if walkparams.s2pie == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveS2POExt.0" title="function: boolean HaveS2POExt()">HaveS2POExt</a>() &amp;&amp; VTCR_EL2.S2POE == '1' then
        if walkparams.d128 == '1' then
            permissions.s2po_index = descriptor&lt;124:121&gt;;
        else
            permissions.s2po_index = descriptor&lt;62:59&gt;;
    return permissions;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S1InitialTTWState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S1InitialTTWState</h3>
      <p class="pseudocode">// AArch64.S1InitialTTWState()
// ===========================
// Set properties of first access to translation tables in stage 1

<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> AArch64.S1InitialTTWState(S1TTWParams walkparams, bits(64) va, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                   <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    walkstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> tablebase;
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a> permissions;
    bits(64)    ttb;

    startlevel  = AArch64.S1StartLevel(walkparams);
    ttb         = <a href="shared_pseudocode.html#AArch64.S1TTB.2" title="function: bits(64) AArch64.S1TTB(Regime regime, bits(64) va)">AArch64.S1TTB</a>(regime, va);
    case ss of
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    tablebase.paspace = <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> tablebase.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>      tablebase.paspace = <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     tablebase.paspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;

    tablebase.address = <a href="shared_pseudocode.html#AArch64.TTBaseAddress.7" title="function: bits(56) AArch64.TTBaseAddress(bits(64) ttb, bits(6) txsz, bits(3) ps,&#13; bit d128, bit ds, TGx tgx, integer startlevel)">AArch64.TTBaseAddress</a>(ttb, walkparams.txsz,
                                              walkparams.ps, walkparams.d128,
                                              walkparams.ds,
                                              walkparams.tgx, startlevel);

    permissions.ap_table = '00';
    if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        permissions.uxn_table = '0';
        permissions.pxn_table = '0';
    else
        permissions.xn_table  = '0';

    walkstate.baseaddress = tablebase;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    // In regimes that support global and non-global translations, translation
    // table entries from lookup levels other than the final level of lookup
    // are treated as being non-global
    walkstate.nG          = if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then '1' else '0';
    walkstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);
    walkstate.permissions = permissions;
    if (walkparams.d128 == '1' || walkparams.pnch == '1') then
        walkstate.s1assured = TRUE;
    else
        walkstate.s1assured = FALSE;
    walkstate.disch = walkparams.disch;

    return walkstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S1NextWalkStateLeaf"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S1NextWalkStateLeaf</h3>
      <p class="pseudocode">// AArch64.S1NextWalkStateLeaf()
// =============================
// Decode stage 1 page or block descriptor as output to this stage of translation

<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> AArch64.S1NextWalkStateLeaf(<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> currentstate, boolean s2fs1mro, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                     <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, S1TTWParams walkparams, bits(N) descriptor)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    nextstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> baseaddress;
    baseaddress.address = <a href="shared_pseudocode.html#AArch64.LeafBase.5" title="function: bits(56) AArch64.LeafBase(bits(N) descriptor, bit d128, bit ds,&#13; TGx tgx, integer level)">AArch64.LeafBase</a>(descriptor, walkparams.d128,
                                               walkparams.ds,
                                               walkparams.tgx, currentstate.level);

    if currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
        // Determine PA space of the block from NS bit
        bit ns;
        ns = if walkparams.d128 == '1' then descriptor&lt;127&gt; else descriptor&lt;5&gt;;
        baseaddress.paspace = if ns == '0' then <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> else <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    elsif currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a> then
        // Determine PA space of the block from NSE and NS bits
        bit nse;
        bit ns;
        &lt;nse,ns&gt; = if walkparams.d128 == '1' then descriptor&lt;11,127&gt; else descriptor&lt;11,5&gt;;
        case &lt;nse,ns&gt; of
            when '00' baseaddress.paspace = <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
            when '01' baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
            when '10' baseaddress.paspace = <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>;
            when '11' baseaddress.paspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
    elsif (currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> &amp;&amp;
            regime IN {<a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>, <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>}) then
        // Realm EL2 and EL2&amp;0 regimes have a stage 1 NS bit
        bit ns;
        ns = if walkparams.d128 == '1' then descriptor&lt;127&gt; else descriptor&lt;5&gt;;
        baseaddress.paspace = if ns == '0' then <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> else <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    elsif currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> then
        // Realm EL1&amp;0 regime does not have a stage 1 NS bit
        baseaddress.paspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
    else
        baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    nextstate.istable     = FALSE;
    nextstate.level       = currentstate.level;
    nextstate.baseaddress = baseaddress;

    bits(4) attrindx;
    if walkparams.aie == '1' then
        if walkparams.d128 == '1' then
            attrindx = descriptor&lt;5:2&gt;;
        else
            attrindx = descriptor&lt;59,4:2&gt;;
    else
        attrindx = '0':descriptor&lt;4:2&gt;;

    bits(2) sh;
    if walkparams.d128 == '1' then
        sh = descriptor&lt;9:8&gt;;
    elsif walkparams.ds == '1' then
        sh = walkparams.sh;
    else
        sh = descriptor&lt;9:8&gt;;
    attr = AArch64.MAIRAttr(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(attrindx), walkparams.mair2, walkparams.mair);
    s1aarch64 = TRUE;

    nextstate.memattrs    = S1DecodeMemAttrs(attr, sh, s1aarch64, walkparams);
    nextstate.permissions = AArch64.S1ApplyOutputPerms(currentstate.permissions,
                                                       descriptor, regime, walkparams);
    bit protected;
    if walkparams.d128 == '1' then
        protected = descriptor&lt;114&gt;;
    else
        protected = if walkparams.pnch == '1' then descriptor&lt;52&gt; else '0';
    if (currentstate.s1assured &amp;&amp; s2fs1mro &amp;&amp; protected == '1') then
        nextstate.s1assured = TRUE;
    else
        nextstate.s1assured = FALSE;

    if walkparams.pnch == '1' || currentstate.disch == '1' then
        nextstate.contiguous = '0';
    else
        nextstate.contiguous = <a href="shared_pseudocode.html#AArch64.ContiguousBit.4" title="function: bit AArch64.ContiguousBit(TGx tgx, bit d128, integer level, bits(N) descriptor)">AArch64.ContiguousBit</a>(walkparams.tgx, walkparams.d128,
                                                     currentstate.level, descriptor);
    if !<a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        nextstate.nG = '0';
    elsif ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
        // In Secure state, a translation must be treated as non-global,
        // regardless of the value of the nG bit,
        // if NSTable is set to 1 at any level of the translation table walk
        nextstate.nG = '1';
    else
        nextstate.nG = descriptor&lt;11&gt;;

    if walkparams.d128 == '1' then
        nextstate.guardedpage = descriptor&lt;113&gt;;
    else
        nextstate.guardedpage = descriptor&lt;50&gt;;

    return nextstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S1NextWalkStateTable"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S1NextWalkStateTable</h3>
      <p class="pseudocode">// AArch64.S1NextWalkStateTable()
// ==============================
// Decode stage 1 table descriptor to transition to the next level

<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> AArch64.S1NextWalkStateTable(<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> currentstate, boolean s2fs1mro, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                      S1TTWParams walkparams, bits(N) descriptor)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    nextstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> tablebase;

    tablebase.address = <a href="shared_pseudocode.html#AArch64.NextTableBase.4" title="function: bits(56) AArch64.NextTableBase(bits(N) descriptor, bit d128, bit ds, TGx tgx)">AArch64.NextTableBase</a>(descriptor, walkparams.d128,
                                              walkparams.ds,
                                              walkparams.tgx);
    if currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
        // Determine PA space of the next table from NSTable bit
        bit nstable;
        nstable = if walkparams.d128 == '1' then descriptor&lt;127&gt; else descriptor&lt;63&gt;;
        tablebase.paspace = if nstable == '0' then <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> else <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    else
        // Otherwise bit 63 is RES0 and there is no NSTable bit
        tablebase.paspace = currentstate.baseaddress.paspace;

    nextstate.istable     = TRUE;
    nextstate.nG          = currentstate.nG;
    if walkparams.d128 == '1' then
        skl = descriptor&lt;110:109&gt;;
        nextstate.level   = currentstate.level + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(skl) + 1;
    else
        nextstate.level   = currentstate.level + 1;
    nextstate.baseaddress = tablebase;
    nextstate.memattrs    = currentstate.memattrs;
    if walkparams.hpd == '0' &amp;&amp; walkparams.pie == '0' then
        nextstate.permissions = AArch64.S1ApplyTablePerms(currentstate.permissions, descriptor,
                                                          regime, walkparams);
    else
        nextstate.permissions = currentstate.permissions;
    bit protected;
    if walkparams.d128 == '1' then
        protected = descriptor&lt;114&gt;;
    else
        protected = if walkparams.pnch == '1' then descriptor&lt;52&gt; else '0';
    if (currentstate.s1assured &amp;&amp; s2fs1mro &amp;&amp; protected == '1') then
        nextstate.s1assured = TRUE;
    else
        nextstate.s1assured = FALSE;
    nextstate.disch = if walkparams.d128 == '1' then descriptor&lt;112&gt; else '0';

    return nextstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S1Walk"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S1Walk</h3>
      <p class="pseudocode">// AArch64.S1Walk()
// ================
// Traverse stage 1 translation tables obtaining the final descriptor
// as well as the address leading to that descriptor

(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a>, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a>, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>, bits(N)) AArch64.S1Walk(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in,
                                                                   S1TTWParams walkparams,
                                                                   bits(64) va, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                                   <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc,
                                                                   integer N)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;

    if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) &amp;&amp; <a href="shared_pseudocode.html#AArch64.S1EPD.2" title="function: bit AArch64.S1EPD(Regime regime, bits(64) va)">AArch64.S1EPD</a>(regime, va) == '1' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN,
                bits(N) UNKNOWN);

    walkstate = AArch64.S1InitialTTWState(walkparams, va, regime, accdesc.ss);
    constant integer startlevel = walkstate.level;

    // Detect Address Size Fault by TTB
    if <a href="shared_pseudocode.html#AArch64.OAOutOfRange.5" title="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bit d128, bits(3) ps,&#13; TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.d128,
                            walkparams.ps, walkparams.tgx, va) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN,
                bits(N) UNKNOWN);

    bits(N) descriptor;
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> walkaddress;
    bits(2) skl = '00';
    walkaddress.vaddress = va;
    walkaddress.mecid = <a href="shared_pseudocode.html#AArch64.TTWalkMECID.3" title="function: bits(16) AArch64.TTWalkMECID(bit mecrl, Regime regime, SecurityState ss)">AArch64.TTWalkMECID</a>(walkparams.mecrl, regime, accdesc.ss);

    if !<a href="shared_pseudocode.html#AArch64.S1DCacheEnabled.1" title="function: boolean AArch64.S1DCacheEnabled(Regime regime)">AArch64.S1DCacheEnabled</a>(regime) then
        walkaddress.memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.VM == '1' &amp;&amp;
            !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        walkaddress.memattrs.shareability = walkstate.memattrs.shareability;
    else
        walkaddress.memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

    boolean s2fs1mro = FALSE;

    <a href="shared_pseudocode.html#DescriptorType" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType</a> desctype;
    repeat
        fault.level = walkstate.level;
        <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> descaddress;
        if walkstate.level == startlevel then
            descaddress = AArch64.S1SLTTEntryAddress(walkstate.level, walkparams, va,
                                                     walkstate.baseaddress);
        else
            skl = if walkparams.d128 == '1' then descriptor&lt;110:109&gt; else '00';
            descaddress = <a href="shared_pseudocode.html#AArch64.TTEntryAddress.7" title="function: FullAddress AArch64.TTEntryAddress(integer level, bit d128, bits(2) skl, TGx tgx, bits(6) txsz,&#13; bits(64) ia, FullAddress tablebase)">AArch64.TTEntryAddress</a>(walkstate.level, walkparams.d128, skl,
                                                 walkparams.tgx, walkparams.txsz, va,
                                                 walkstate.baseaddress);
        walkaddress.paddress = descaddress;

        boolean toplevel = walkstate.level == startlevel;
        <a href="shared_pseudocode.html#VARange" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> varange  = <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va);
        <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> walkaccess = <a href="shared_pseudocode.html#impl-shared.CreateAccDescS1TTW.3" title="function: AccessDescriptor CreateAccDescS1TTW(boolean toplevel, VARange varange, AccessDescriptor accdesc_in)">CreateAccDescS1TTW</a>(toplevel, varange, accdesc);
        <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> s2fault;
        <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> s2walkaddress;
        if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
            s1aarch64 = TRUE;
            aligned   = TRUE;
            (s2fault, s2walkaddress) = <a href="shared_pseudocode.html#AArch64.S2Translate.5" title="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean s1aarch64, boolean aligned,&#13; AccessDescriptor accdesc)">AArch64.S2Translate</a>(fault, walkaddress, s1aarch64, aligned,
                                                           walkaccess);

            if s2fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                return (s2fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN,
                        bits(N) UNKNOWN);

            s2fs1mro = s2walkaddress.s2fs1mro;
            (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.5" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; AccessDescriptor walkaccess, FaultRecord fault_in,&#13; integer N)">FetchDescriptor</a>(walkparams.ee, s2walkaddress, walkaccess,
                                                  fault, N);
        else
            (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.5" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; AccessDescriptor walkaccess, FaultRecord fault_in,&#13; integer N)">FetchDescriptor</a>(walkparams.ee, walkaddress, walkaccess,
                                                  fault, N);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN,
                    bits(N) UNKNOWN);

        bits(N) new_descriptor;
        repeat
            new_descriptor = descriptor;
            desctype = <a href="shared_pseudocode.html#AArch64.DecodeDescriptorType.5" title="function: DescriptorType AArch64.DecodeDescriptorType(bits(N) descriptor, bit d128, bit ds,&#13; TGx tgx, integer level)">AArch64.DecodeDescriptorType</a>(descriptor, walkparams.d128, walkparams.ds,
                                                    walkparams.tgx, walkstate.level);
            case desctype of
                when <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>
                    walkstate = AArch64.S1NextWalkStateTable(walkstate, s2fs1mro,
                                                             regime, walkparams, descriptor);
                    // Detect Address Size Fault by table descriptor

                    if <a href="shared_pseudocode.html#AArch64.OAOutOfRange.5" title="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bit d128, bits(3) ps,&#13; TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.d128,
                                            walkparams.ps, walkparams.tgx, va) then
                        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
                        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN,
                                bits(N) UNKNOWN);

                    if walkparams.haft == '1' then
                        new_descriptor&lt;10&gt; = '1';

                    if walkparams.d128 == '1' then
                        skl = descriptor&lt;110:109&gt;;
                        if skl != '00' &amp;&amp; <a href="shared_pseudocode.html#AArch64.BlocknTFaults.2" title="function: boolean AArch64.BlocknTFaults(bit d128, bits(N) descriptor)">AArch64.BlocknTFaults</a>(walkparams.d128, descriptor) then
                            fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN,
                                    bits(N) UNKNOWN);
                when <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>
                    walkstate = AArch64.S1NextWalkStateLeaf(walkstate, s2fs1mro,
                                                            regime, accdesc.ss, walkparams, descriptor);
                when <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>
                    fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                    return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN,
                            bits(N) UNKNOWN);
                otherwise
                    <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

            if new_descriptor != descriptor then
                <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> descpaddr;
                <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> descaccess = <a href="shared_pseudocode.html#impl-shared.CreateAccDescTTEUpdate.1" title="function: AccessDescriptor CreateAccDescTTEUpdate(AccessDescriptor accdesc_in)">CreateAccDescTTEUpdate</a>(accdesc);
                if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
                    s1aarch64 = TRUE;
                    aligned   = TRUE;
                    (s2fault, descpaddr) = <a href="shared_pseudocode.html#AArch64.S2Translate.5" title="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean s1aarch64, boolean aligned,&#13; AccessDescriptor accdesc)">AArch64.S2Translate</a>(fault, walkaddress,
                                                               s1aarch64, aligned,
                                                               descaccess);
                else
                    descpaddr = walkaddress;

                (fault, descriptor) = <a href="shared_pseudocode.html#AArch64.MemSwapTableDesc.6" title="function: (FaultRecord, bits(N)) AArch64.MemSwapTableDesc(FaultRecord fault_in, bits(N) prev_desc,&#13; bits(N) new_desc, bit ee,&#13; AccessDescriptor  descaccess,&#13; AddressDescriptor descpaddr)">AArch64.MemSwapTableDesc</a>(fault, descriptor, new_descriptor,
                                                               walkparams.ee, descaccess,
                                                               descpaddr);
                if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                    return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN,
                            <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(N) UNKNOWN);
        until new_descriptor == descriptor;
    until desctype == <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>;

    if (walkstate.contiguous == '1' &amp;&amp;
        <a href="shared_pseudocode.html#AArch64.ContiguousBitFaults.4" title="function: boolean AArch64.ContiguousBitFaults(bit d128, bits(6) txsz, TGx tgx, integer level)">AArch64.ContiguousBitFaults</a>(walkparams.d128, walkparams.txsz, walkparams.tgx,
                                    walkstate.level)) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    elsif (desctype == <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a> &amp;&amp; walkstate.level &lt; <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> &amp;&amp;
          <a href="shared_pseudocode.html#AArch64.BlocknTFaults.2" title="function: boolean AArch64.BlocknTFaults(bit d128, bits(N) descriptor)">AArch64.BlocknTFaults</a>(walkparams.d128, descriptor)) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    elsif AArch64.S1AMECFault(walkparams, walkaddress.paddress.paspace, regime, descriptor) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    // Detect Address Size Fault by final output
    elsif <a href="shared_pseudocode.html#AArch64.OAOutOfRange.5" title="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bit d128, bits(3) ps,&#13; TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.d128,
                               walkparams.ps, walkparams.tgx, va) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
    // Check descriptor AF bit
    elsif (descriptor&lt;10&gt; == '0' &amp;&amp; walkparams.ha == '0' &amp;&amp;
            !(accdesc.acctype IN {<a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>, <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>} &amp;&amp;
            !boolean IMPLEMENTATION_DEFINED "Generate access flag fault on IC/DC operations")) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(N) UNKNOWN);

    return (fault, walkaddress, walkstate, descriptor);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S2InitialTTWState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S2InitialTTWState</h3>
      <p class="pseudocode">// AArch64.S2InitialTTWState()
// ===========================
// Set properties of first access to translation tables in stage 2

<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> AArch64.S2InitialTTWState(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, S2TTWParams walkparams)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    walkstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> tablebase;
    bits(64)    ttb;

    ttb               = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.BADDR, 64);
    startlevel        = AArch64.S2StartLevel(walkparams);
    case ss of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> tablebase.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     tablebase.paspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
    tablebase.address = <a href="shared_pseudocode.html#AArch64.TTBaseAddress.7" title="function: bits(56) AArch64.TTBaseAddress(bits(64) ttb, bits(6) txsz, bits(3) ps,&#13; bit d128, bit ds, TGx tgx, integer startlevel)">AArch64.TTBaseAddress</a>(ttb, walkparams.txsz,
                                              walkparams.ps, walkparams.d128,
                                              walkparams.ds,
                                              walkparams.tgx, startlevel);

    walkstate.baseaddress = tablebase;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    walkstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);

    return walkstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S2NextWalkStateLeaf"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S2NextWalkStateLeaf</h3>
      <p class="pseudocode">// AArch64.S2NextWalkStateLeaf()
// =============================
// Decode stage 2 page or block descriptor as output to this stage of translation

<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> AArch64.S2NextWalkStateLeaf(<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> currentstate, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                     S2TTWParams walkparams, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> ipa,
                                     bits(N) descriptor)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    nextstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> baseaddress;

    if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        baseaddress.paspace = AArch64.SS2OutputPASpace(walkparams, ipa.paddress.paspace);
    elsif ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> then
        bit ns;
        ns = if walkparams.d128 == '1' then descriptor&lt;127&gt; else descriptor&lt;55&gt;;
        baseaddress.paspace = if ns == '1' then <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> else <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
    else
        baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    baseaddress.address   = <a href="shared_pseudocode.html#AArch64.LeafBase.5" title="function: bits(56) AArch64.LeafBase(bits(N) descriptor, bit d128, bit ds,&#13; TGx tgx, integer level)">AArch64.LeafBase</a>(descriptor, walkparams.d128,
                                               walkparams.ds,
                                               walkparams.tgx, currentstate.level);

    nextstate.istable     = FALSE;
    nextstate.level       = currentstate.level;
    nextstate.baseaddress = baseaddress;
    nextstate.permissions = AArch64.S2ApplyOutputPerms(descriptor, walkparams);

    s2_attr = descriptor&lt;5:2&gt;;
    s2_sh   = if walkparams.ds == '1' then walkparams.sh else descriptor&lt;9:8&gt;;
    s2_fnxs = descriptor&lt;11&gt;;
    if walkparams.fwb == '1' then
        nextstate.memattrs = <a href="shared_pseudocode.html#AArch64.S2ApplyFWBMemAttrs.3" title="function: MemoryAttributes AArch64.S2ApplyFWBMemAttrs(MemoryAttributes s1_memattrs,&#13; bits(4) s2_attr, bits(2) s2_sh)">AArch64.S2ApplyFWBMemAttrs</a>(ipa.memattrs, s2_attr, s2_sh);
        if s2_attr&lt;1:0&gt; == '10' then    // Force writeback
            nextstate.memattrs.xs = '0';
        else
            nextstate.memattrs.xs = if s2_fnxs == '1' then '0' else ipa.memattrs.xs;
        if s2_attr&lt;3:1&gt; == '111' then
            nextstate.permissions.s2tag_na = '1';
        else
            nextstate.permissions.s2tag_na = '0';
    else
        s2aarch64 = TRUE;
        nextstate.memattrs = <a href="shared_pseudocode.html#impl-shared.S2DecodeMemAttrs.3" title="function: MemoryAttributes S2DecodeMemAttrs(bits(4) attr, bits(2) sh, boolean s2aarch64)">S2DecodeMemAttrs</a>(s2_attr, s2_sh, s2aarch64);
        nextstate.memattrs.xs = if s2_fnxs == '1' then '0' else ipa.memattrs.xs;
        if s2_attr == '0100' then
            nextstate.permissions.s2tag_na = '1';
        else
            nextstate.permissions.s2tag_na = '0';
    nextstate.contiguous = <a href="shared_pseudocode.html#AArch64.ContiguousBit.4" title="function: bit AArch64.ContiguousBit(TGx tgx, bit d128, integer level, bits(N) descriptor)">AArch64.ContiguousBit</a>(walkparams.tgx, walkparams.d128,
                                                 currentstate.level, descriptor);
    if walkparams.d128 == '1' then
        nextstate.s2assuredonly = descriptor&lt;114&gt;;
    else
        nextstate.s2assuredonly = if walkparams.assuredonly == '1' then descriptor&lt;58&gt; else '0';

    return nextstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S2NextWalkStateTable"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S2NextWalkStateTable</h3>
      <p class="pseudocode">// AArch64.S2NextWalkStateTable()
// ==============================
// Decode stage 2 table descriptor to transition to the next level

<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> AArch64.S2NextWalkStateTable(<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> currentstate, S2TTWParams walkparams,
                                      bits(N) descriptor)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    nextstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> tablebase;

    tablebase.address = <a href="shared_pseudocode.html#AArch64.NextTableBase.4" title="function: bits(56) AArch64.NextTableBase(bits(N) descriptor, bit d128, bit ds, TGx tgx)">AArch64.NextTableBase</a>(descriptor, walkparams.d128,
                                              walkparams.ds,
                                              walkparams.tgx);
    tablebase.paspace = currentstate.baseaddress.paspace;

    nextstate.istable     = TRUE;
    if walkparams.d128 == '1' then
        skl = descriptor&lt;110:109&gt;;
        nextstate.level   = currentstate.level + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(skl) + 1;
    else
        nextstate.level   = currentstate.level + 1;
    nextstate.baseaddress = tablebase;
    nextstate.memattrs    = currentstate.memattrs;

    return nextstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S2Walk"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S2Walk</h3>
      <p class="pseudocode">// AArch64.S2Walk()
// ================
// Traverse stage 2 translation tables obtaining the final descriptor
// as well as the address leading to that descriptor

(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a>, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a>, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>, bits(N)) AArch64.S2Walk(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in,
                                                                   <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> ipa,
                                                                   S2TTWParams walkparams,
                                                                   <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc,
                                                                   integer N)

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;
    ipa_64 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address, 64);

    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    if accdesc.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        walkstate = AArch64.SS2InitialTTWState(walkparams, ipa.paddress.paspace);
    else
        walkstate = AArch64.S2InitialTTWState(accdesc.ss, walkparams);

    constant integer startlevel = walkstate.level;

    // Detect Address Size Fault by TTB
    if <a href="shared_pseudocode.html#AArch64.OAOutOfRange.5" title="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bit d128, bits(3) ps,&#13; TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.d128, walkparams.ps, walkparams.tgx,
                            ipa_64) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(N) UNKNOWN);

    bits(N) descriptor;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> walkaccess = <a href="shared_pseudocode.html#impl-shared.CreateAccDescS2TTW.1" title="function: AccessDescriptor CreateAccDescS2TTW(AccessDescriptor accdesc_in)">CreateAccDescS2TTW</a>(accdesc);
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> walkaddress;
    bits(2) skl = '00';

    walkaddress.vaddress = ipa.vaddress;
    walkaddress.mecid = <a href="shared_pseudocode.html#AArch64.TTWalkMECID.3" title="function: bits(16) AArch64.TTWalkMECID(bit mecrl, Regime regime, SecurityState ss)">AArch64.TTWalkMECID</a>(walkparams.mecrl, <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>, accdesc.ss);

    if HCR_EL2.CD == '1' then
        walkaddress.memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;

    walkaddress.memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

    <a href="shared_pseudocode.html#DescriptorType" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType</a> desctype;
    repeat
        fault.level = walkstate.level;

        <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> descaddress;
        if walkstate.level == startlevel then
            // Initial lookup might index into concatenated tables
            descaddress = AArch64.S2SLTTEntryAddress(walkparams, ipa.paddress.address,
                                                     walkstate.baseaddress);
        else
            skl = if walkparams.d128 == '1' then descriptor&lt;110:109&gt; else '00';
            ipa_64 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address, 64);
            descaddress = <a href="shared_pseudocode.html#AArch64.TTEntryAddress.7" title="function: FullAddress AArch64.TTEntryAddress(integer level, bit d128, bits(2) skl, TGx tgx, bits(6) txsz,&#13; bits(64) ia, FullAddress tablebase)">AArch64.TTEntryAddress</a>(walkstate.level, walkparams.d128, skl,
                                                 walkparams.tgx, walkparams.txsz, ipa_64,
                                                 walkstate.baseaddress);

        walkaddress.paddress = descaddress;
        (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.5" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; AccessDescriptor walkaccess, FaultRecord fault_in,&#13; integer N)">FetchDescriptor</a>(walkparams.ee, walkaddress, walkaccess, fault, N);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(N) UNKNOWN);

        bits(N) new_descriptor;
        repeat
            new_descriptor = descriptor;
            desctype = <a href="shared_pseudocode.html#AArch64.DecodeDescriptorType.5" title="function: DescriptorType AArch64.DecodeDescriptorType(bits(N) descriptor, bit d128, bit ds,&#13; TGx tgx, integer level)">AArch64.DecodeDescriptorType</a>(descriptor, walkparams.d128, walkparams.ds,
                                                    walkparams.tgx, walkstate.level);
            case desctype of
                when <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>
                    walkstate = AArch64.S2NextWalkStateTable(walkstate, walkparams, descriptor);

                    // Detect Address Size Fault by table descriptor
                    if <a href="shared_pseudocode.html#AArch64.OAOutOfRange.5" title="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bit d128, bits(3) ps,&#13; TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.d128,
                                            walkparams.ps, walkparams.tgx, ipa_64) then
                        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
                        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN,
                                <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(N) UNKNOWN);

                    if walkparams.haft == '1' then
                        new_descriptor&lt;10&gt; = '1';

                    if walkparams.d128 == '1' then
                        skl = descriptor&lt;110:109&gt;;
                        if skl != '00' &amp;&amp; <a href="shared_pseudocode.html#AArch64.BlocknTFaults.2" title="function: boolean AArch64.BlocknTFaults(bit d128, bits(N) descriptor)">AArch64.BlocknTFaults</a>(walkparams.d128, descriptor) then
                            fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN,
                                    bits(N) UNKNOWN);

                when <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>
                    walkstate = AArch64.S2NextWalkStateLeaf(walkstate, accdesc.ss, walkparams, ipa,
                                                            descriptor);
                when <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>
                    fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                    return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(N) UNKNOWN);

                otherwise
                    <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

            if new_descriptor != descriptor then
                <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> descaccess = <a href="shared_pseudocode.html#impl-shared.CreateAccDescTTEUpdate.1" title="function: AccessDescriptor CreateAccDescTTEUpdate(AccessDescriptor accdesc_in)">CreateAccDescTTEUpdate</a>(accdesc);
                (fault, descriptor) = <a href="shared_pseudocode.html#AArch64.MemSwapTableDesc.6" title="function: (FaultRecord, bits(N)) AArch64.MemSwapTableDesc(FaultRecord fault_in, bits(N) prev_desc,&#13; bits(N) new_desc, bit ee,&#13; AccessDescriptor  descaccess,&#13; AddressDescriptor descpaddr)">AArch64.MemSwapTableDesc</a>(fault, descriptor, new_descriptor,
                                                               walkparams.ee, descaccess,
                                                               walkaddress);
                if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                    return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(N) UNKNOWN);
        until new_descriptor == descriptor;
    until desctype == <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a>;

    if (walkstate.contiguous == '1' &amp;&amp;
        <a href="shared_pseudocode.html#AArch64.ContiguousBitFaults.4" title="function: boolean AArch64.ContiguousBitFaults(bit d128, bits(6) txsz, TGx tgx, integer level)">AArch64.ContiguousBitFaults</a>(walkparams.d128, walkparams.txsz, walkparams.tgx,
                                    walkstate.level)) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    elsif (desctype == <a href="shared_pseudocode.html#DescriptorType_Leaf" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Leaf,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Leaf</a> &amp;&amp; walkstate.level &lt; <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> &amp;&amp;
          <a href="shared_pseudocode.html#AArch64.BlocknTFaults.2" title="function: boolean AArch64.BlocknTFaults(bit d128, bits(N) descriptor)">AArch64.BlocknTFaults</a>(walkparams.d128, descriptor)) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    // Detect Address Size Fault by final output
    elsif <a href="shared_pseudocode.html#AArch64.OAOutOfRange.5" title="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bit d128, bits(3) ps,&#13; TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.d128, walkparams.ps, walkparams.tgx,
                               ipa_64) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
    // Check descriptor AF bit
    elsif (descriptor&lt;10&gt; == '0' &amp;&amp; walkparams.ha == '0' &amp;&amp;
            !(accdesc.acctype IN {<a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>, <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>} &amp;&amp;
            !boolean IMPLEMENTATION_DEFINED "Generate access flag fault on IC/DC operations")) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;

    return (fault, walkaddress, walkstate, descriptor);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.SS2InitialTTWState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.SS2InitialTTWState</h3>
      <p class="pseudocode">// AArch64.SS2InitialTTWState()
// ============================
// Set properties of first access to translation tables in Secure stage 2

<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> AArch64.SS2InitialTTWState(S2TTWParams walkparams, <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> ipaspace)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    walkstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> tablebase;
    bits(64)    ttb;

    if ipaspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
        ttb = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VSTTBR_EL2.BADDR, 64);
    else
        ttb = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.BADDR, 64);

    if ipaspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
        if walkparams.sw == '0' then
            tablebase.paspace = <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        else
            tablebase.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    else
        if walkparams.nsw == '0' then
            tablebase.paspace = <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        else
            tablebase.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    startlevel        = AArch64.S2StartLevel(walkparams);
    tablebase.address = <a href="shared_pseudocode.html#AArch64.TTBaseAddress.7" title="function: bits(56) AArch64.TTBaseAddress(bits(64) ttb, bits(6) txsz, bits(3) ps,&#13; bit d128, bit ds, TGx tgx, integer startlevel)">AArch64.TTBaseAddress</a>(ttb, walkparams.txsz,
                                              walkparams.ps, walkparams.d128,
                                              walkparams.ds,
                                              walkparams.tgx, startlevel);

    walkstate.baseaddress = tablebase;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    walkstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);

    return walkstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.SS2OutputPASpace"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.SS2OutputPASpace</h3>
      <p class="pseudocode">// AArch64.SS2OutputPASpace()
// ==========================
// Assign PA Space to output of Secure stage 2 translation

<a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> AArch64.SS2OutputPASpace(S2TTWParams walkparams, <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> ipaspace)
    if ipaspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
        if walkparams.&lt;sw,sa&gt; == '00' then
            return <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        else
            return <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    else
        if walkparams.&lt;sw,sa,nsw,nsa&gt; == '0000' then
            return <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        else
            return <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.BBMSupportLevel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.BBMSupportLevel</h3>
      <p class="pseudocode">// AArch64.BBMSupportLevel()
// =========================
// Returns the level of FEAT_BBM supported

integer <a id="AArch64.BlockBBMSupportLevel.0"/>AArch64.BlockBBMSupportLevel()
    if !<a href="shared_pseudocode.html#impl-shared.HaveBlockBBM.0" title="function: boolean HaveBlockBBM()">HaveBlockBBM</a>() then
        return integer UNKNOWN;
    else
        return integer IMPLEMENTATION_DEFINED "Block BBM support level";</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.GetS1TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.GetS1TTWParams</h3>
      <p class="pseudocode">// AArch64.GetS1TTWParams()
// ========================
// Returns stage 1 translation table walk parameters from respective controlling
// System registers.

S1TTWParams AArch64.GetS1TTWParams(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va)
    S1TTWParams walkparams;

    varange = <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va);

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  walkparams = AArch64.S1TTWParamsEL3();
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  walkparams = AArch64.S1TTWParamsEL2(ss);
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> walkparams = AArch64.S1TTWParamsEL20(ss, varange);
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> walkparams = AArch64.S1TTWParamsEL10(varange);

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.GetS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.GetS2TTWParams</h3>
      <p class="pseudocode">// AArch64.GetS2TTWParams()
// ========================
// Gather walk parameters for stage 2 translation

S2TTWParams AArch64.GetS2TTWParams(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> ipaspace, boolean s1aarch64)
    S2TTWParams walkparams;

    if ss == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
        walkparams = AArch64.NSS2TTWParams(s1aarch64);
    elsif <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        walkparams = AArch64.SS2TTWParams(ipaspace, s1aarch64);
    elsif ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> then
        walkparams = AArch64.RLS2TTWParams(s1aarch64);
    else
        <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.GetVARange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.GetVARange</h3>
      <p class="pseudocode">// AArch64.GetVARange()
// ====================
// Determines if the VA that is to be translated lies in LOWER or UPPER address range.

VARange <a id="AArch64.GetVARange.1"/>AArch64.GetVARange(bits(64) va)
    if va&lt;55&gt; == '0' then
        return <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    else
        return <a href="shared_pseudocode.html#VARange_UPPER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.HaveS1TG"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.HaveS1TG</h3>
      <p class="pseudocode">// AArch64.HaveS1TG()
// ==================
// Determine whether the given translation granule is supported for stage 1

boolean <a id="AArch64.HaveS1TG.1"/>AArch64.HaveS1TG(<a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    case tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  return boolean IMPLEMENTATION_DEFINED "Has 4K Translation Granule";
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> return boolean IMPLEMENTATION_DEFINED "Has 16K Translation Granule";
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> return boolean IMPLEMENTATION_DEFINED "Has 64K Translation Granule";</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.HaveS2TG"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.HaveS2TG</h3>
      <p class="pseudocode">// AArch64.HaveS2TG()
// ==================
// Determine whether the given translation granule is supported for stage 2

boolean <a id="AArch64.HaveS2TG.1"/>AArch64.HaveS2TG(<a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    if <a href="shared_pseudocode.html#impl-shared.HaveGTGExt.0" title="function: boolean HaveGTGExt()">HaveGTGExt</a>() then
        case tgx of
            when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  return boolean IMPLEMENTATION_DEFINED "Has Stage 2 4K Translation Granule";
            when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> return boolean IMPLEMENTATION_DEFINED "Has Stage 2 16K Translation Granule";
            when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> return boolean IMPLEMENTATION_DEFINED "Has Stage 2 64K Translation Granule";
    else
        return <a href="shared_pseudocode.html#AArch64.HaveS1TG.1" title="function: boolean AArch64.HaveS1TG(TGx tgx)">AArch64.HaveS1TG</a>(tgx);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.MaxTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.MaxTxSZ</h3>
      <p class="pseudocode">// AArch64.MaxTxSZ()
// =================
// Retrieve the maximum value of TxSZ indicating minimum input address size for both
// stages of translation

integer <a id="AArch64.MaxTxSZ.1"/>AArch64.MaxTxSZ(<a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    if <a href="shared_pseudocode.html#impl-shared.HaveSmallTranslationTableExt.0" title="function: boolean HaveSmallTranslationTableExt()">HaveSmallTranslationTableExt</a>() then
        case tgx of
            when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>   return 48;
            when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>  return 48;
            when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>  return 47;

    return 39;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.NSS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.NSS2TTWParams</h3>
      <p class="pseudocode">// AArch64.NSS2TTWParams()
// =======================
// Gather walk parameters specific for Non-secure stage 2 translation

S2TTWParams AArch64.NSS2TTWParams(boolean s1aarch64)
    S2TTWParams walkparams;

    walkparams.vm   = HCR_EL2.VM OR HCR_EL2.DC;
    walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.S2DecodeTG0.1" title="function: TGx AArch64.S2DecodeTG0(bits(2) tg0_in)">AArch64.S2DecodeTG0</a>(VTCR_EL2.TG0);
    walkparams.txsz = VTCR_EL2.T0SZ;
    walkparams.ps   = VTCR_EL2.PS;
    walkparams.irgn = VTCR_EL2.IRGN0;
    walkparams.orgn = VTCR_EL2.ORGN0;
    walkparams.sh   = VTCR_EL2.SH0;
    walkparams.ee   = SCTLR_EL2.EE;
    walkparams.d128 = if <a href="shared_pseudocode.html#impl-shared.Have128BitDescriptorExt.0" title="function: boolean Have128BitDescriptorExt()">Have128BitDescriptorExt</a>() then VTCR_EL2.D128 else '0';
    if walkparams.d128 == '1' then
        walkparams.skl = VTTBR_EL2.SKL;
    else
        walkparams.sl0 = VTCR_EL2.SL0;

    walkparams.ptw = if HCR_EL2.TGE == '0'         then HCR_EL2.PTW else '0';
    walkparams.fwb = if <a href="shared_pseudocode.html#impl-shared.HaveStage2MemAttrControl.0" title="function: boolean HaveStage2MemAttrControl()">HaveStage2MemAttrControl</a>() then HCR_EL2.FWB else '0';
    walkparams.ha  = if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>()  then VTCR_EL2.HA else '0';
    walkparams.hd  = if <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>()  then VTCR_EL2.HD else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = VTCR_EL2.DS;
    else
        walkparams.ds = '0';
    if walkparams.tgx == <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.sl2 = VTCR_EL2.SL2 AND VTCR_EL2.DS;
    else
        walkparams.sl2 = '0';
    walkparams.cmow = if <a href="shared_pseudocode.html#impl-shared.HaveFeatCMOW.0" title="function: boolean HaveFeatCMOW()">HaveFeatCMOW</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() then HCRX_EL2.CMOW else '0';
    if walkparams.d128 == '1' then
        walkparams.s2pie = '1';
    else
        walkparams.s2pie = if <a href="shared_pseudocode.html#impl-shared.HaveS2PIExt.0" title="function: boolean HaveS2PIExt()">HaveS2PIExt</a>() then VTCR_EL2.S2PIE else '0';
    walkparams.s2pir = if <a href="shared_pseudocode.html#impl-shared.HaveS2PIExt.0" title="function: boolean HaveS2PIExt()">HaveS2PIExt</a>() then S2PIR_EL2 else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    if <a href="shared_pseudocode.html#impl-shared.HaveTHExt.0" title="function: boolean HaveTHExt()">HaveTHExt</a>() &amp;&amp; walkparams.d128 != '1' then
        walkparams.assuredonly = VTCR_EL2.AssuredOnly;
    else
        walkparams.assuredonly = '0';
    walkparams.tl0   = if <a href="shared_pseudocode.html#impl-shared.HaveTHExt.0" title="function: boolean HaveTHExt()">HaveTHExt</a>() then VTCR_EL2.TL0 else '0';
    walkparams.tl1   = if <a href="shared_pseudocode.html#impl-shared.HaveTHExt.0" title="function: boolean HaveTHExt()">HaveTHExt</a>() then VTCR_EL2.TL1 else '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateForTableExt.0" title="function: boolean HaveAccessFlagUpdateForTableExt()">HaveAccessFlagUpdateForTableExt</a>() &amp;&amp; walkparams.ha == '1' then
        walkparams.haft = VTCR_EL2.HAFT;
    else
        walkparams.haft = '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.PAMax"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.PAMax</h3>
      <p class="pseudocode">// AArch64.PAMax()
// ===============
// Returns the IMPLEMENTATION DEFINED maximum number of bits capable of representing
// physical address for this processor

integer <a id="AArch64.PAMax.0"/>AArch64.PAMax()
    return integer IMPLEMENTATION_DEFINED "Maximum Physical Address Size";</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.RLS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.RLS2TTWParams</h3>
      <p class="pseudocode">// AArch64.RLS2TTWParams()
// =======================
// Gather walk parameters specific for Realm stage 2 translation

S2TTWParams AArch64.RLS2TTWParams(boolean s1aarch64)
    // Realm stage 2 walk parameters are similar to Non-secure
    S2TTWParams walkparams = AArch64.NSS2TTWParams(s1aarch64);
    walkparams.mecrl = if <a href="shared_pseudocode.html#impl-shared.HaveFeatMEC.0" title="function: boolean HaveFeatMEC()">HaveFeatMEC</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsSCTLR2EL2Enabled.0" title="function: boolean IsSCTLR2EL2Enabled()">IsSCTLR2EL2Enabled</a>() then SCTLR2_EL2.MECRL else '0';
    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1DCacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1DCacheEnabled</h3>
      <p class="pseudocode">// AArch64.S1DCacheEnabled()
// =========================
// Determine cacheability of stage 1 data accesses

boolean <a id="AArch64.S1DCacheEnabled.1"/>AArch64.S1DCacheEnabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return SCTLR_EL3.C == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return SCTLR_EL2.C == '1';
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return SCTLR_EL2.C == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return SCTLR_EL1.C == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1DecodeTG0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1DecodeTG0</h3>
      <p class="pseudocode">// AArch64.S1DecodeTG0()
// =====================
// Decode stage 1 granule size configuration bits TG0

TGx <a id="AArch64.S1DecodeTG0.1"/>AArch64.S1DecodeTG0(bits(2) tg0_in)
    bits(2) tg0 = tg0_in;
    <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx;

    if tg0 == '11' then
        tg0 = bits(2) IMPLEMENTATION_DEFINED "TG0 encoded granule size";

    case tg0 of
        when '00'   tgx = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
        when '01'   tgx = <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;
        when '10'   tgx = <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;

    if !<a href="shared_pseudocode.html#AArch64.HaveS1TG.1" title="function: boolean AArch64.HaveS1TG(TGx tgx)">AArch64.HaveS1TG</a>(tgx) then
        case bits(2) IMPLEMENTATION_DEFINED "TG0 encoded granule size" of
            when '00'   tgx = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
            when '01'   tgx = <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;
            when '10'   tgx = <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;

    return tgx;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1DecodeTG1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1DecodeTG1</h3>
      <p class="pseudocode">// AArch64.S1DecodeTG1()
// =====================
// Decode stage 1 granule size configuration bits TG1

TGx <a id="AArch64.S1DecodeTG1.1"/>AArch64.S1DecodeTG1(bits(2) tg1_in)
    bits(2) tg1 = tg1_in;
    <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx;

    if tg1 == '00' then
        tg1 = bits(2) IMPLEMENTATION_DEFINED "TG1 encoded granule size";

    case tg1 of
        when '10'   tgx = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
        when '11'   tgx = <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;
        when '01'   tgx = <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;

    if !<a href="shared_pseudocode.html#AArch64.HaveS1TG.1" title="function: boolean AArch64.HaveS1TG(TGx tgx)">AArch64.HaveS1TG</a>(tgx) then
        case bits(2) IMPLEMENTATION_DEFINED "TG1 encoded granule size" of
            when '10'   tgx = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
            when '11'   tgx = <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;
            when '01'   tgx = <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;

    return tgx;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1E0POEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1E0POEnabled</h3>
      <p class="pseudocode">// AArch64.S1E0POEnabled()
// =======================
// Determine whether stage 1 unprivileged permission overlay is enabled

boolean <a id="AArch64.S1E0POEnabled.2"/>AArch64.S1E0POEnabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bit nv1)
    assert <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime);

    if !<a href="shared_pseudocode.html#impl-shared.HaveS1POExt.0" title="function: boolean HaveS1POExt()">HaveS1POExt</a>() then
        return FALSE;

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() &amp;&amp; TCR2_EL2.E0POE == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL1Enabled.0" title="function: boolean IsTCR2EL1Enabled()">IsTCR2EL1Enabled</a>() &amp;&amp; nv1 == '0' &amp;&amp; TCR2_EL1.E0POE == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1EPD"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1EPD</h3>
      <p class="pseudocode">// AArch64.S1EPD()
// ===============
// Determine whether stage 1 translation table walk is allowed for the VA range

bit <a id="AArch64.S1EPD.2"/>AArch64.S1EPD(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(64) va)
    assert <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime);
    varange = <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va);

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then TCR_EL2.EPD0 else TCR_EL2.EPD1;
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then TCR_EL1.EPD0 else TCR_EL1.EPD1;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1Enabled</h3>
      <p class="pseudocode">// AArch64.S1Enabled()
// ===================
// Determine if stage 1 is enabled for the access type for this translation regime

boolean <a id="AArch64.S1Enabled.2"/>AArch64.S1Enabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#AccessType" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType</a> acctype)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return SCTLR_EL3.M == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return SCTLR_EL2.M == '1';
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return SCTLR_EL2.M == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return (!<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() || HCR_EL2.&lt;DC,TGE&gt; == '00') &amp;&amp; SCTLR_EL1.M == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1ICacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1ICacheEnabled</h3>
      <p class="pseudocode">// AArch64.S1ICacheEnabled()
// =========================
// Determine cacheability of stage 1 instruction fetches

boolean <a id="AArch64.S1ICacheEnabled.1"/>AArch64.S1ICacheEnabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return SCTLR_EL3.I == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return SCTLR_EL2.I == '1';
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return SCTLR_EL2.I == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return SCTLR_EL1.I == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1MinTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1MinTxSZ</h3>
      <p class="pseudocode">// AArch64.S1MinTxSZ()
// ===================
// Retrieve the minimum value of TxSZ indicating maximum input address size for stage 1

integer <a id="AArch64.S1MinTxSZ.4"/>AArch64.S1MinTxSZ(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bit d128, bit ds, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    if <a href="shared_pseudocode.html#impl-shared.Have56BitVAExt.0" title="function: boolean Have56BitVAExt()">Have56BitVAExt</a>() &amp;&amp; d128 == '1' then
        if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
            return 9;
        else
            return 8;
    if (<a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()">Have52BitVAExt</a>() &amp;&amp; tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>) || ds == '1' then
        return 12;

    return 16;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1POEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1POEnabled</h3>
      <p class="pseudocode">// AArch64.S1POEnabled()
// =====================
// Determine whether stage 1 privileged permission overlay is enabled

boolean <a id="AArch64.S1POEnabled.1"/>AArch64.S1POEnabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    if !<a href="shared_pseudocode.html#impl-shared.HaveS1POExt.0" title="function: boolean HaveS1POExt()">HaveS1POExt</a>() then
        return FALSE;

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return TCR_EL3.POE == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() &amp;&amp; TCR2_EL2.POE == '1';
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() &amp;&amp; TCR2_EL2.POE == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL1Enabled.0" title="function: boolean IsTCR2EL1Enabled()">IsTCR2EL1Enabled</a>() &amp;&amp; TCR2_EL1.POE == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1POR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1POR</h3>
      <p class="pseudocode">// AArch64.S1POR()
// ===============
// Identify stage 1 permissions overlay register for the acting translation regime

S1PORType AArch64.S1POR(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return POR_EL3;
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return POR_EL2;
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return POR_EL2;
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return POR_EL1;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1TTB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1TTB</h3>
      <p class="pseudocode">// AArch64.S1TTB()
// ===============
// Identify stage 1 table base register's BADDR for the acting translation regime

bits(64) <a id="AArch64.S1TTB.2"/>AArch64.S1TTB(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(64) va)
    varange = <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va);

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(TTBR0_EL3.BADDR, 64);
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(TTBR0_EL2.BADDR, 64);
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>
            if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
                return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(TTBR0_EL2.BADDR, 64);
            else
                return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(TTBR1_EL2.BADDR, 64);
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>
            if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
                return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(TTBR0_EL1.BADDR, 64);
            else
                return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(TTBR1_EL1.BADDR, 64);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1TTWParamsEL10"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1TTWParamsEL10</h3>
      <p class="pseudocode">// AArch64.S1TTWParamsEL10()
// =========================
// Gather stage 1 translation table walk parameters for EL1&amp;0 regime
// (with EL2 enabled or disabled)

S1TTWParams AArch64.S1TTWParamsEL10(<a href="shared_pseudocode.html#VARange" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> varange)
    S1TTWParams walkparams;

    if <a href="shared_pseudocode.html#impl-shared.Have128BitDescriptorExt.0" title="function: boolean Have128BitDescriptorExt()">Have128BitDescriptorExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL1Enabled.0" title="function: boolean IsTCR2EL1Enabled()">IsTCR2EL1Enabled</a>() then
        walkparams.d128 = TCR2_EL1.D128;
    else
        walkparams.d128 = '0';
    if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
        walkparams.tgx   = <a href="shared_pseudocode.html#AArch64.S1DecodeTG0.1" title="function: TGx AArch64.S1DecodeTG0(bits(2) tg0_in)">AArch64.S1DecodeTG0</a>(TCR_EL1.TG0);
        walkparams.txsz  = TCR_EL1.T0SZ;
        walkparams.irgn  = TCR_EL1.IRGN0;
        walkparams.orgn  = TCR_EL1.ORGN0;
        walkparams.sh    = TCR_EL1.SH0;
        walkparams.tbi   = TCR_EL1.TBI0;

        walkparams.nfd   = if <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() || <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then TCR_EL1.NFD0  else '0';
        walkparams.tbid  = if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()           then TCR_EL1.TBID0 else '0';
        walkparams.e0pd  = if <a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()">HaveE0PDExt</a>()          then TCR_EL1.E0PD0 else '0';
        walkparams.hpd   = if <a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()   then TCR_EL1.HPD0  else '0';
        walkparams.mtx   = if <a href="shared_pseudocode.html#impl-shared.HaveMTE4Ext.0" title="function: boolean HaveMTE4Ext()">HaveMTE4Ext</a>() then TCR_EL1.MTX0 else '0';
        walkparams.skl   = if walkparams.d128 == '1' then TTBR0_EL1.SKL else '00';
        walkparams.disch = if walkparams.d128 == '1' then TCR2_EL1.DisCH0 else '0';
    else
        walkparams.tgx   = <a href="shared_pseudocode.html#AArch64.S1DecodeTG1.1" title="function: TGx AArch64.S1DecodeTG1(bits(2) tg1_in)">AArch64.S1DecodeTG1</a>(TCR_EL1.TG1);
        walkparams.txsz  = TCR_EL1.T1SZ;
        walkparams.irgn  = TCR_EL1.IRGN1;
        walkparams.orgn  = TCR_EL1.ORGN1;
        walkparams.sh    = TCR_EL1.SH1;
        walkparams.tbi   = TCR_EL1.TBI1;

        walkparams.nfd   = if <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() || <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then TCR_EL1.NFD1  else '0';
        walkparams.tbid  = if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()           then TCR_EL1.TBID1 else '0';
        walkparams.e0pd  = if <a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()">HaveE0PDExt</a>()          then TCR_EL1.E0PD1 else '0';
        walkparams.hpd   = if <a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()   then TCR_EL1.HPD1  else '0';
        walkparams.mtx   = if <a href="shared_pseudocode.html#impl-shared.HaveMTE4Ext.0" title="function: boolean HaveMTE4Ext()">HaveMTE4Ext</a>()          then TCR_EL1.MTX1 else '0';
        walkparams.skl   = if walkparams.d128 == '1' then TTBR1_EL1.SKL else '00';
        walkparams.disch = if walkparams.d128 == '1' then TCR2_EL1.DisCH1 else '0';

    walkparams.mair = MAIR_EL1;
    if <a href="shared_pseudocode.html#impl-shared.HaveAIEExt.0" title="function: boolean HaveAIEExt()">HaveAIEExt</a>() then
        walkparams.mair2 = MAIR2_EL1;
    walkparams.aie  = if <a href="shared_pseudocode.html#impl-shared.HaveAIEExt.0" title="function: boolean HaveAIEExt()">HaveAIEExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL1Enabled.0" title="function: boolean IsTCR2EL1Enabled()">IsTCR2EL1Enabled</a>() then TCR2_EL1.AIE else '0';
    walkparams.wxn  = SCTLR_EL1.WXN;
    walkparams.ps   = TCR_EL1.IPS;
    walkparams.ee   = SCTLR_EL1.EE;
    walkparams.sif  = SCR_EL3.SIF;

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        walkparams.dc  = HCR_EL2.DC;
        walkparams.dct = if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then HCR_EL2.DCT else '0';

    if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        walkparams.ntlsmd = SCTLR_EL1.nTLSMD;
    else
        walkparams.ntlsmd = '1';

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if HCR_EL2.&lt;NV,NV1&gt; == '01' then
            case <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_NVNV1" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_NVNV1</a>) of
                when <a href="shared_pseudocode.html#Constraint_NVNV1_00" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_00</a> walkparams.nv1 = '0';
                when <a href="shared_pseudocode.html#Constraint_NVNV1_01" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_01</a> walkparams.nv1 = '1';
                when <a href="shared_pseudocode.html#Constraint_NVNV1_11" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_11</a> walkparams.nv1 = '1';
        else
            walkparams.nv1 = HCR_EL2.NV1;
    else
        walkparams.nv1 = '0';

    walkparams.cmow = if <a href="shared_pseudocode.html#impl-shared.HaveFeatCMOW.0" title="function: boolean HaveFeatCMOW()">HaveFeatCMOW</a>()            then SCTLR_EL1.CMOW else '0';
    walkparams.ha   = if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>() then TCR_EL1.HA else '0';
    walkparams.hd   = if <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>() then TCR_EL1.HD else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = TCR_EL1.DS;
    else
        walkparams.ds = '0';
    if walkparams.d128 == '1' then
        walkparams.pie = '1';
    else
        walkparams.pie = if <a href="shared_pseudocode.html#impl-shared.HaveS1PIExt.0" title="function: boolean HaveS1PIExt()">HaveS1PIExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL1Enabled.0" title="function: boolean IsTCR2EL1Enabled()">IsTCR2EL1Enabled</a>() then TCR2_EL1.PIE else '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveS1PIExt.0" title="function: boolean HaveS1PIExt()">HaveS1PIExt</a>() then
        walkparams.pir = PIR_EL1;
        if walkparams.nv1 != '1'then
            walkparams.pire0 = PIRE0_EL1;
    if <a href="shared_pseudocode.html#impl-shared.HavePAN3Ext.0" title="function: boolean HavePAN3Ext()">HavePAN3Ext</a>() then
        walkparams.epan = if walkparams.pie == '0' then SCTLR_EL1.EPAN else '1';
    else
        walkparams.epan = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveTHExt.0" title="function: boolean HaveTHExt()">HaveTHExt</a>() &amp;&amp; walkparams.d128 == '0' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL1Enabled.0" title="function: boolean IsTCR2EL1Enabled()">IsTCR2EL1Enabled</a>() then
        walkparams.pnch = TCR2_EL1.PnCH;
    else
        walkparams.pnch = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateForTableExt.0" title="function: boolean HaveAccessFlagUpdateForTableExt()">HaveAccessFlagUpdateForTableExt</a>() &amp;&amp; walkparams.ha == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL1Enabled.0" title="function: boolean IsTCR2EL1Enabled()">IsTCR2EL1Enabled</a>() then
        walkparams.haft = TCR2_EL1.HAFT;
    else
        walkparams.haft = '0';
    walkparams.mecrl = if <a href="shared_pseudocode.html#impl-shared.HaveFeatMEC.0" title="function: boolean HaveFeatMEC()">HaveFeatMEC</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsSCTLR2EL2Enabled.0" title="function: boolean IsSCTLR2EL2Enabled()">IsSCTLR2EL2Enabled</a>() then SCTLR2_EL2.MECRL else '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1TTWParamsEL2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1TTWParamsEL2</h3>
      <p class="pseudocode">// AArch64.S1TTWParamsEL2()
// ========================
// Gather stage 1 translation table walk parameters for EL2 regime

S1TTWParams AArch64.S1TTWParamsEL2(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    S1TTWParams walkparams;

    walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.S1DecodeTG0.1" title="function: TGx AArch64.S1DecodeTG0(bits(2) tg0_in)">AArch64.S1DecodeTG0</a>(TCR_EL2.TG0);
    walkparams.txsz = TCR_EL2.T0SZ;
    walkparams.ps   = TCR_EL2.PS;
    walkparams.irgn = TCR_EL2.IRGN0;
    walkparams.orgn = TCR_EL2.ORGN0;
    walkparams.sh   = TCR_EL2.SH0;
    walkparams.tbi  = TCR_EL2.TBI;
    walkparams.mair = MAIR_EL2;
    if <a href="shared_pseudocode.html#impl-shared.HaveAIEExt.0" title="function: boolean HaveAIEExt()">HaveAIEExt</a>() then
        walkparams.mair2 = MAIR2_EL2;
    walkparams.aie  = if <a href="shared_pseudocode.html#impl-shared.HaveAIEExt.0" title="function: boolean HaveAIEExt()">HaveAIEExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() then TCR2_EL2.AIE else '0';
    walkparams.wxn  = SCTLR_EL2.WXN;
    walkparams.ee   = SCTLR_EL2.EE;
    walkparams.sif  = SCR_EL3.SIF;

    walkparams.tbid = if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()              then TCR_EL2.TBID else '0';
    walkparams.hpd  = if <a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()      then TCR_EL2.HPD  else '0';
    walkparams.ha   = if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>() then TCR_EL2.HA   else '0';
    walkparams.hd   = if <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>() then TCR_EL2.HD   else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = TCR_EL2.DS;
    else
        walkparams.ds = '0';
    walkparams.pie = if <a href="shared_pseudocode.html#impl-shared.HaveS1PIExt.0" title="function: boolean HaveS1PIExt()">HaveS1PIExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() then TCR2_EL2.PIE else '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveS1PIExt.0" title="function: boolean HaveS1PIExt()">HaveS1PIExt</a>() then
        walkparams.pir = PIR_EL2;
    walkparams.mtx  = if <a href="shared_pseudocode.html#impl-shared.HaveMTE4Ext.0" title="function: boolean HaveMTE4Ext()">HaveMTE4Ext</a>()             then TCR_EL2.MTX else '0';
    walkparams.pnch = if <a href="shared_pseudocode.html#impl-shared.HaveTHExt.0" title="function: boolean HaveTHExt()">HaveTHExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() then TCR2_EL2.PnCH else '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateForTableExt.0" title="function: boolean HaveAccessFlagUpdateForTableExt()">HaveAccessFlagUpdateForTableExt</a>() &amp;&amp; walkparams.ha == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() then
        walkparams.haft = TCR2_EL2.HAFT;
    else
        walkparams.haft = '0';
    walkparams.mecrl = if <a href="shared_pseudocode.html#impl-shared.HaveFeatMEC.0" title="function: boolean HaveFeatMEC()">HaveFeatMEC</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsSCTLR2EL2Enabled.0" title="function: boolean IsSCTLR2EL2Enabled()">IsSCTLR2EL2Enabled</a>() then SCTLR2_EL2.MECRL else '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveFeatMEC.0" title="function: boolean HaveFeatMEC()">HaveFeatMEC</a>() &amp;&amp; ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() then
        walkparams.amec = TCR2_EL2.AMEC0;
    else
        walkparams.amec = '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1TTWParamsEL20"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1TTWParamsEL20</h3>
      <p class="pseudocode">// AArch64.S1TTWParamsEL20()
// =========================
// Gather stage 1 translation table walk parameters for EL2&amp;0 regime

S1TTWParams AArch64.S1TTWParamsEL20(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a href="shared_pseudocode.html#VARange" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> varange)
    S1TTWParams walkparams;

    if <a href="shared_pseudocode.html#impl-shared.Have128BitDescriptorExt.0" title="function: boolean Have128BitDescriptorExt()">Have128BitDescriptorExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() then
        walkparams.d128 = TCR2_EL2.D128;
    else
        walkparams.d128 = '0';
    if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
        walkparams.tgx   = <a href="shared_pseudocode.html#AArch64.S1DecodeTG0.1" title="function: TGx AArch64.S1DecodeTG0(bits(2) tg0_in)">AArch64.S1DecodeTG0</a>(TCR_EL2.TG0);
        walkparams.txsz  = TCR_EL2.T0SZ;
        walkparams.irgn  = TCR_EL2.IRGN0;
        walkparams.orgn  = TCR_EL2.ORGN0;
        walkparams.sh    = TCR_EL2.SH0;
        walkparams.tbi   = TCR_EL2.TBI0;

        walkparams.nfd   = if <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() || <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then TCR_EL2.NFD0  else '0';
        walkparams.tbid  = if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()           then TCR_EL2.TBID0 else '0';
        walkparams.e0pd  = if <a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()">HaveE0PDExt</a>()          then TCR_EL2.E0PD0 else '0';
        walkparams.hpd   = if <a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()   then TCR_EL2.HPD0  else '0';
        walkparams.mtx   = if <a href="shared_pseudocode.html#impl-shared.HaveMTE4Ext.0" title="function: boolean HaveMTE4Ext()">HaveMTE4Ext</a>()          then TCR_EL2.MTX0 else '0';
        walkparams.skl   = if walkparams.d128 == '1' then TTBR0_EL2.SKL else '00';
        walkparams.disch = if walkparams.d128 == '1' then TCR2_EL2.DisCH0 else '0';
    else
        walkparams.tgx   = <a href="shared_pseudocode.html#AArch64.S1DecodeTG1.1" title="function: TGx AArch64.S1DecodeTG1(bits(2) tg1_in)">AArch64.S1DecodeTG1</a>(TCR_EL2.TG1);
        walkparams.txsz  = TCR_EL2.T1SZ;
        walkparams.irgn  = TCR_EL2.IRGN1;
        walkparams.orgn  = TCR_EL2.ORGN1;
        walkparams.sh    = TCR_EL2.SH1;
        walkparams.tbi   = TCR_EL2.TBI1;

        walkparams.nfd   = if <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() || <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then TCR_EL2.NFD1  else '0';
        walkparams.tbid  = if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()           then TCR_EL2.TBID1 else '0';
        walkparams.e0pd  = if <a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()">HaveE0PDExt</a>()          then TCR_EL2.E0PD1 else '0';
        walkparams.hpd   = if <a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()   then TCR_EL2.HPD1  else '0';
        walkparams.mtx   = if <a href="shared_pseudocode.html#impl-shared.HaveMTE4Ext.0" title="function: boolean HaveMTE4Ext()">HaveMTE4Ext</a>()          then TCR_EL2.MTX1 else '0';
        walkparams.skl   = if walkparams.d128 == '1' then TTBR1_EL2.SKL else '00';
        walkparams.disch = if walkparams.d128 == '1' then TCR2_EL2.DisCH1 else '0';
    walkparams.mair = MAIR_EL2;
    if <a href="shared_pseudocode.html#impl-shared.HaveAIEExt.0" title="function: boolean HaveAIEExt()">HaveAIEExt</a>() then
        walkparams.mair2 = MAIR2_EL2;
    walkparams.aie  = if <a href="shared_pseudocode.html#impl-shared.HaveAIEExt.0" title="function: boolean HaveAIEExt()">HaveAIEExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() then TCR2_EL2.AIE else '0';
    walkparams.wxn  = SCTLR_EL2.WXN;
    walkparams.ps   = TCR_EL2.IPS;
    walkparams.ee   = SCTLR_EL2.EE;
    walkparams.sif  = SCR_EL3.SIF;

    if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        walkparams.ntlsmd = SCTLR_EL2.nTLSMD;
    else
        walkparams.ntlsmd = '1';

    walkparams.cmow = if <a href="shared_pseudocode.html#impl-shared.HaveFeatCMOW.0" title="function: boolean HaveFeatCMOW()">HaveFeatCMOW</a>()            then SCTLR_EL2.CMOW else '0';
    walkparams.ha   = if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>() then TCR_EL2.HA else '0';
    walkparams.hd   = if <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>() then TCR_EL2.HD else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = TCR_EL2.DS;
    else
        walkparams.ds = '0';
    if walkparams.d128 == '1' then
        walkparams.pie = '1';
    else
        walkparams.pie = if <a href="shared_pseudocode.html#impl-shared.HaveS1PIExt.0" title="function: boolean HaveS1PIExt()">HaveS1PIExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() then TCR2_EL2.PIE else '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveS1PIExt.0" title="function: boolean HaveS1PIExt()">HaveS1PIExt</a>() then
        walkparams.pir   = PIR_EL2;
        walkparams.pire0 = PIRE0_EL2;
    if <a href="shared_pseudocode.html#impl-shared.HavePAN3Ext.0" title="function: boolean HavePAN3Ext()">HavePAN3Ext</a>() then
        walkparams.epan = if walkparams.pie == '0' then SCTLR_EL2.EPAN else '1';
    else
        walkparams.epan = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveTHExt.0" title="function: boolean HaveTHExt()">HaveTHExt</a>() &amp;&amp; walkparams.d128 == '0' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() then
        walkparams.pnch = TCR2_EL2.PnCH;
    else
        walkparams.pnch = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateForTableExt.0" title="function: boolean HaveAccessFlagUpdateForTableExt()">HaveAccessFlagUpdateForTableExt</a>() &amp;&amp; walkparams.ha == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() then
        walkparams.haft = TCR2_EL2.HAFT;
    else
        walkparams.haft = '0';
    walkparams.mecrl = if <a href="shared_pseudocode.html#impl-shared.HaveFeatMEC.0" title="function: boolean HaveFeatMEC()">HaveFeatMEC</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsSCTLR2EL2Enabled.0" title="function: boolean IsSCTLR2EL2Enabled()">IsSCTLR2EL2Enabled</a>() then SCTLR2_EL2.MECRL else '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveFeatMEC.0" title="function: boolean HaveFeatMEC()">HaveFeatMEC</a>() &amp;&amp; ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsTCR2EL2Enabled.0" title="function: boolean IsTCR2EL2Enabled()">IsTCR2EL2Enabled</a>() then
        walkparams.amec = if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then TCR2_EL2.AMEC0 else TCR2_EL2.AMEC1;
    else
        walkparams.amec = '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1TTWParamsEL3"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1TTWParamsEL3</h3>
      <p class="pseudocode">// AArch64.S1TTWParamsEL3()
// ========================
// Gather stage 1 translation table walk parameters for EL3 regime

S1TTWParams AArch64.S1TTWParamsEL3()
    S1TTWParams walkparams;

    walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.S1DecodeTG0.1" title="function: TGx AArch64.S1DecodeTG0(bits(2) tg0_in)">AArch64.S1DecodeTG0</a>(TCR_EL3.TG0);
    walkparams.txsz = TCR_EL3.T0SZ;
    walkparams.ps   = TCR_EL3.PS;
    walkparams.irgn = TCR_EL3.IRGN0;
    walkparams.orgn = TCR_EL3.ORGN0;
    walkparams.sh   = TCR_EL3.SH0;
    walkparams.tbi  = TCR_EL3.TBI;
    walkparams.mair = MAIR_EL3;
    if <a href="shared_pseudocode.html#impl-shared.HaveAIEExt.0" title="function: boolean HaveAIEExt()">HaveAIEExt</a>() then
        walkparams.mair2 = MAIR2_EL3;
    walkparams.aie  = if <a href="shared_pseudocode.html#impl-shared.HaveAIEExt.0" title="function: boolean HaveAIEExt()">HaveAIEExt</a>() then TCR_EL3.AIE else '0';
    walkparams.wxn  = SCTLR_EL3.WXN;
    walkparams.ee   = SCTLR_EL3.EE;
    walkparams.sif  = SCR_EL3.SIF;

    walkparams.tbid = if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()              then TCR_EL3.TBID else '0';
    walkparams.hpd  = if <a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()      then TCR_EL3.HPD  else '0';
    walkparams.ha   = if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>() then TCR_EL3.HA   else '0';
    walkparams.hd   = if <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>() then TCR_EL3.HD   else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = TCR_EL3.DS;
    else
        walkparams.ds = '0';
    walkparams.d128  = if <a href="shared_pseudocode.html#impl-shared.Have128BitDescriptorExt.0" title="function: boolean Have128BitDescriptorExt()">Have128BitDescriptorExt</a>() then TCR_EL3.D128 else '0';
    walkparams.skl   = if walkparams.d128 == '1' then TTBR0_EL3.SKL else '00';
    walkparams.disch = if walkparams.d128 == '1' then TCR_EL3.DisCH0 else '0';
    if walkparams.d128 == '1' then
        walkparams.pie = '1';
    else
        walkparams.pie = if <a href="shared_pseudocode.html#impl-shared.HaveS1PIExt.0" title="function: boolean HaveS1PIExt()">HaveS1PIExt</a>() then TCR_EL3.PIE else '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveS1PIExt.0" title="function: boolean HaveS1PIExt()">HaveS1PIExt</a>() then
        walkparams.pir = PIR_EL3;
    walkparams.mtx  = if <a href="shared_pseudocode.html#impl-shared.HaveMTE4Ext.0" title="function: boolean HaveMTE4Ext()">HaveMTE4Ext</a>()             then TCR_EL3.MTX else '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveTHExt.0" title="function: boolean HaveTHExt()">HaveTHExt</a>() &amp;&amp; walkparams.d128 == '1' then
        walkparams.pnch = TCR_EL3.PnCH;
    else
        walkparams.pnch = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateForTableExt.0" title="function: boolean HaveAccessFlagUpdateForTableExt()">HaveAccessFlagUpdateForTableExt</a>() &amp;&amp; walkparams.ha == '1' then
        walkparams.haft = TCR_EL3.HAFT;
    else
        walkparams.haft = '0';
    walkparams.mecrl = if <a href="shared_pseudocode.html#impl-shared.HaveFeatMEC.0" title="function: boolean HaveFeatMEC()">HaveFeatMEC</a>() then SCTLR2_EL3.MECRL else '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S2DecodeTG0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S2DecodeTG0</h3>
      <p class="pseudocode">// AArch64.S2DecodeTG0()
// =====================
// Decode stage 2 granule size configuration bits TG0

TGx <a id="AArch64.S2DecodeTG0.1"/>AArch64.S2DecodeTG0(bits(2) tg0_in)
    bits(2) tg0 = tg0_in;
    <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx;

    if tg0 == '11' then
        tg0 = bits(2) IMPLEMENTATION_DEFINED "TG0 encoded granule size";

    case tg0 of
        when '00'   tgx = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
        when '01'   tgx = <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;
        when '10'   tgx = <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;

    if !<a href="shared_pseudocode.html#AArch64.HaveS2TG.1" title="function: boolean AArch64.HaveS2TG(TGx tgx)">AArch64.HaveS2TG</a>(tgx) then
        case bits(2) IMPLEMENTATION_DEFINED "TG0 encoded granule size" of
            when '00'   tgx = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
            when '01'   tgx = <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;
            when '10'   tgx = <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;

    return tgx;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S2MinTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S2MinTxSZ</h3>
      <p class="pseudocode">// AArch64.S2MinTxSZ()
// ===================
// Retrieve the minimum value of TxSZ indicating maximum input address size for stage 2

integer <a id="AArch64.S2MinTxSZ.4"/>AArch64.S2MinTxSZ(bit d128, bit ds, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, boolean s1aarch64)
    ips = <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>();

    if d128 == '0' then
        if <a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx != <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; ds == '0' then
            ips = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(48, <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>());
        else
            ips = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(52, <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>());
    min_txsz = 64 - ips;
    if !s1aarch64 then
        // EL1 is AArch32
        min_txsz = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(min_txsz, 24);

    return min_txsz;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.SS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.SS2TTWParams</h3>
      <p class="pseudocode">// AArch64.SS2TTWParams()
// ======================
// Gather walk parameters specific for secure stage 2 translation

S2TTWParams AArch64.SS2TTWParams(<a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> ipaspace, boolean s1aarch64)
    S2TTWParams walkparams;

    walkparams.d128 = if <a href="shared_pseudocode.html#impl-shared.Have128BitDescriptorExt.0" title="function: boolean Have128BitDescriptorExt()">Have128BitDescriptorExt</a>() then VTCR_EL2.D128 else '0';
    if ipaspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
        walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.S2DecodeTG0.1" title="function: TGx AArch64.S2DecodeTG0(bits(2) tg0_in)">AArch64.S2DecodeTG0</a>(VSTCR_EL2.TG0);
        walkparams.txsz = VSTCR_EL2.T0SZ;
        if walkparams.d128 == '1' then
            walkparams.skl = VSTTBR_EL2.SKL;
        else
            walkparams.sl0 = VSTCR_EL2.SL0;
        if walkparams.tgx == <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
            walkparams.sl2 = VSTCR_EL2.SL2 AND VTCR_EL2.DS;
        else
            walkparams.sl2 = '0';
    elsif ipaspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
        walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.S2DecodeTG0.1" title="function: TGx AArch64.S2DecodeTG0(bits(2) tg0_in)">AArch64.S2DecodeTG0</a>(VTCR_EL2.TG0);
        walkparams.txsz = VTCR_EL2.T0SZ;
        if walkparams.d128 == '1' then
            walkparams.skl = VTTBR_EL2.SKL;
        else
            walkparams.sl0 = VTCR_EL2.SL0;
        if walkparams.tgx == <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
            walkparams.sl2 = VTCR_EL2.SL2 AND VTCR_EL2.DS;
        else
            walkparams.sl2 = '0';
    else
        <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    walkparams.sw   = VSTCR_EL2.SW;
    walkparams.nsw  = VTCR_EL2.NSW;
    walkparams.sa   = VSTCR_EL2.SA;
    walkparams.nsa  = VTCR_EL2.NSA;
    walkparams.vm   = HCR_EL2.VM OR HCR_EL2.DC;
    walkparams.ps   = VTCR_EL2.PS;
    walkparams.irgn = VTCR_EL2.IRGN0;
    walkparams.orgn = VTCR_EL2.ORGN0;
    walkparams.sh   = VTCR_EL2.SH0;
    walkparams.ee   = SCTLR_EL2.EE;

    walkparams.ptw = if HCR_EL2.TGE == '0'         then HCR_EL2.PTW else '0';
    walkparams.fwb = if <a href="shared_pseudocode.html#impl-shared.HaveStage2MemAttrControl.0" title="function: boolean HaveStage2MemAttrControl()">HaveStage2MemAttrControl</a>() then HCR_EL2.FWB else '0';
    walkparams.ha  = if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>()  then VTCR_EL2.HA else '0';
    walkparams.hd  = if <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>()  then VTCR_EL2.HD else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = VTCR_EL2.DS;
    else
        walkparams.ds = '0';
    walkparams.cmow = if <a href="shared_pseudocode.html#impl-shared.HaveFeatCMOW.0" title="function: boolean HaveFeatCMOW()">HaveFeatCMOW</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() then HCRX_EL2.CMOW else '0';
    if walkparams.d128 == '1' then
        walkparams.s2pie = '1';
    else
        walkparams.s2pie = if <a href="shared_pseudocode.html#impl-shared.HaveS2PIExt.0" title="function: boolean HaveS2PIExt()">HaveS2PIExt</a>() then VTCR_EL2.S2PIE else '0';
    walkparams.s2pir = if <a href="shared_pseudocode.html#impl-shared.HaveS2PIExt.0" title="function: boolean HaveS2PIExt()">HaveS2PIExt</a>() then S2PIR_EL2 else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    if <a href="shared_pseudocode.html#impl-shared.HaveTHExt.0" title="function: boolean HaveTHExt()">HaveTHExt</a>() &amp;&amp; walkparams.d128 != '1' then
        walkparams.assuredonly = VTCR_EL2.AssuredOnly;
    else
        walkparams.assuredonly = '0';
    walkparams.tl0   = if <a href="shared_pseudocode.html#impl-shared.HaveTHExt.0" title="function: boolean HaveTHExt()">HaveTHExt</a>() then VTCR_EL2.TL0 else '0';
    walkparams.tl1   = if <a href="shared_pseudocode.html#impl-shared.HaveTHExt.0" title="function: boolean HaveTHExt()">HaveTHExt</a>() then VTCR_EL2.TL1 else '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateForTableExt.0" title="function: boolean HaveAccessFlagUpdateForTableExt()">HaveAccessFlagUpdateForTableExt</a>() &amp;&amp; walkparams.ha == '1' then
        walkparams.haft = VTCR_EL2.HAFT;
    else
        walkparams.haft = '0';
    walkparams.mecrl = '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.VAMax"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.VAMax</h3>
      <p class="pseudocode">// AArch64.VAMax()
// ===============
// Returns the IMPLEMENTATION DEFINED maximum number of bits capable of representing
// the virtual address for this processor

integer <a id="AArch64.VAMax.0"/>AArch64.VAMax()
    return integer IMPLEMENTATION_DEFINED "Maximum Virtual Address Size";</p>
    </div>
    <div class="ps"><a id="shared.debug.ClearStickyErrors.ClearStickyErrors"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/ClearStickyErrors/ClearStickyErrors</h3>
      <p class="pseudocode">// ClearStickyErrors()
// ===================

<a id="impl-shared.ClearStickyErrors.0"/>ClearStickyErrors()
    EDSCR.TXU = '0';            // Clear TX underrun flag
    EDSCR.RXO = '0';            // Clear RX overrun flag

    if <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then            // in Debug state
        EDSCR.ITO = '0';        // Clear ITR overrun flag

    // If halted and the ITR is not empty then it is UNPREDICTABLE whether the EDSCR.ERR is cleared.
    // The UNPREDICTABLE behavior also affects the instructions in flight, but this is not described
    // in the pseudocode.
    if <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.ITE == '0' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_CLEARERRITEZERO" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_CLEARERRITEZERO</a>) then
        return;
    EDSCR.ERR = '0';            // Clear cumulative error flag

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.DebugTarget.DebugTarget"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/DebugTarget/DebugTarget</h3>
      <p class="pseudocode">// DebugTarget()
// =============
// Returns the debug exception target Exception level

bits(2) <a id="impl-shared.DebugTarget.0"/>DebugTarget()
    ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    return <a href="shared_pseudocode.html#impl-shared.DebugTargetFrom.1" title="function: bits(2) DebugTargetFrom(SecurityState from_state)">DebugTargetFrom</a>(ss);</p>
    </div>
    <div class="ps"><a id="shared.debug.DebugTarget.DebugTargetFrom"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/DebugTarget/DebugTargetFrom</h3>
      <p class="pseudocode">// DebugTargetFrom()
// =================

bits(2) <a id="impl-shared.DebugTargetFrom.1"/>DebugTargetFrom(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> from_state)
    boolean route_to_el2;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (from_state != <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> ||
        (<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.EEL2 == '1'))) then
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            route_to_el2 = (HDCR.TDE == '1' || HCR.TGE == '1');
        else
            route_to_el2 = (MDCR_EL2.TDE == '1' || HCR_EL2.TGE == '1');
    else
        route_to_el2 = FALSE;

    bits(2) target;
    if route_to_el2 then
        target = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() &amp;&amp; from_state == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        target = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    else
        target = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    return target;</p>
    </div>
    <div class="ps"><a id="shared.debug.DoubleLockStatus.DoubleLockStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/DoubleLockStatus/DoubleLockStatus</h3>
      <p class="pseudocode">// DoubleLockStatus()
// ==================
// Returns the state of the OS Double Lock.
//    FALSE if OSDLR_EL1.DLK == 0 or DBGPRCR_EL1.CORENPDRQ == 1 or the PE is in Debug state.
//    TRUE if OSDLR_EL1.DLK == 1 and DBGPRCR_EL1.CORENPDRQ == 0 and the PE is in Non-debug state.

boolean <a id="impl-shared.DoubleLockStatus.0"/>DoubleLockStatus()
    if !<a href="shared_pseudocode.html#impl-shared.HaveDoubleLock.0" title="function: boolean HaveDoubleLock()">HaveDoubleLock</a>() then
        return FALSE;
    elsif <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        return DBGOSDLR.DLK == '1' &amp;&amp; DBGPRCR.CORENPDRQ == '0' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();
    else
        return OSDLR_EL1.DLK == '1' &amp;&amp; DBGPRCR_EL1.CORENPDRQ == '0' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.OSLockStatus.OSLockStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/OSLockStatus/OSLockStatus</h3>
      <p class="pseudocode">// OSLockStatus()
// ==============
// Returns the state of the OS Lock.

boolean <a id="impl-shared.OSLockStatus.0"/>OSLockStatus()
    return (if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then DBGOSLSR.OSLK else OSLSR_EL1.OSLK) == '1';</p>
    </div>
    <div class="ps"><a id="shared.debug.SoftwareLockStatus.Component"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/SoftwareLockStatus/Component</h3>
      <p class="pseudocode">enumeration <a id="Component"/>Component {
        <a id="Component_PMU"/>Component_PMU,
        <a id="Component_Debug"/>Component_Debug,
        <a id="Component_CTI"/>Component_CTI
};</p>
    </div>
    <div class="ps"><a id="shared.debug.SoftwareLockStatus.GetAccessComponent"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/SoftwareLockStatus/GetAccessComponent</h3>
      <p class="pseudocode">// Returns the accessed component.
Component <a id="impl-shared.GetAccessComponent.0"/>GetAccessComponent();</p>
    </div>
    <div class="ps"><a id="shared.debug.SoftwareLockStatus.SoftwareLockStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/SoftwareLockStatus/SoftwareLockStatus</h3>
      <p class="pseudocode">// SoftwareLockStatus()
// ====================
// Returns the state of the Software Lock.

boolean <a id="impl-shared.SoftwareLockStatus.0"/>SoftwareLockStatus()
    <a href="shared_pseudocode.html#Component" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component</a> component = <a href="shared_pseudocode.html#impl-shared.GetAccessComponent.0" title="function: Component GetAccessComponent()">GetAccessComponent</a>();
    if !<a href="shared_pseudocode.html#impl-shared.HaveSoftwareLock.1" title="function: boolean HaveSoftwareLock(Component component)">HaveSoftwareLock</a>(component) then
        return FALSE;
    case component of
        when <a href="shared_pseudocode.html#Component_Debug" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_Debug</a>
            return EDLSR.SLK == '1';
        when <a href="shared_pseudocode.html#Component_PMU" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_PMU</a>
            return PMLSR.SLK == '1';
        when <a href="shared_pseudocode.html#Component_CTI" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_CTI</a>
            return CTILSR.SLK == '1';
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.AccessState"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/AccessState</h3>
      <p class="pseudocode">// Returns the Security state of the access.
SecurityState <a id="impl-shared.AccessState.0"/>AccessState();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.AllowExternalDebugAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/AllowExternalDebugAccess</h3>
      <p class="pseudocode">// AllowExternalDebugAccess()
// ==========================
// Returns TRUE if an external debug interface access to the External debug registers
// is allowed, FALSE otherwise.

boolean <a id="impl-shared.AllowExternalDebugAccess.0"/>AllowExternalDebugAccess()
    // The access may also be subject to OS Lock, power-down, etc.
    return <a href="shared_pseudocode.html#impl-shared.AllowExternalDebugAccess.1" title="function: boolean AllowExternalDebugAccess(SecurityState access_state)">AllowExternalDebugAccess</a>(<a href="shared_pseudocode.html#impl-shared.AccessState.0" title="function: SecurityState AccessState()">AccessState</a>());

// AllowExternalDebugAccess()
// ==========================
// Returns TRUE if an external debug interface access to the External debug registers
// is allowed for the given Security state, FALSE otherwise.

boolean <a id="impl-shared.AllowExternalDebugAccess.1"/>AllowExternalDebugAccess(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> access_state)
    // The access may also be subject to OS Lock, power-down, etc.
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        case MDCR_EL3.&lt;EDADE,EDAD&gt; of
            when '00' return TRUE;
            when '01' return access_state IN {<a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>, <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>};
            when '10' return access_state IN {<a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>, <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>};
            when '11' return access_state == <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>;

    if <a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()">HaveSecureExtDebugView</a>() then
        if access_state == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then return TRUE;
    else
        if !<a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() then return FALSE;
        if <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>() then return TRUE;

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        EDAD_bit = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.EDAD else MDCR_EL3.EDAD;
        return EDAD_bit == '0';
    else
        return <a href="shared_pseudocode.html#impl-shared.NonSecureOnlyImplementation.0" title="function: boolean NonSecureOnlyImplementation()">NonSecureOnlyImplementation</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.AllowExternalPMUAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/AllowExternalPMUAccess</h3>
      <p class="pseudocode">// AllowExternalPMUAccess()
// ========================
// Returns TRUE if an external debug interface access to the PMU registers is
// allowed, FALSE otherwise.

boolean <a id="impl-shared.AllowExternalPMUAccess.0"/>AllowExternalPMUAccess()
    // The access may also be subject to OS Lock, power-down, etc.
    return <a href="shared_pseudocode.html#impl-shared.AllowExternalPMUAccess.1" title="function: boolean AllowExternalPMUAccess(SecurityState access_state)">AllowExternalPMUAccess</a>(<a href="shared_pseudocode.html#impl-shared.AccessState.0" title="function: SecurityState AccessState()">AccessState</a>());

// AllowExternalPMUAccess()
// ========================
// Returns TRUE if an external debug interface access to the PMU registers is
// allowed for the given Security state, FALSE otherwise.

boolean <a id="impl-shared.AllowExternalPMUAccess.1"/>AllowExternalPMUAccess(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> access_state)
    // The access may also be subject to OS Lock, power-down, etc.
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        case MDCR_EL3.&lt;EPMADE,EPMAD&gt; of
            when '00' return TRUE;
            when '01' return access_state IN {<a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>, <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>};
            when '10' return access_state IN {<a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>, <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>};
            when '11' return access_state == <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>;

    if <a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()">HaveSecureExtDebugView</a>() then
        if access_state == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then return TRUE;
    else
        if !<a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() then return FALSE;
        if <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>() then return TRUE;

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        EPMAD_bit = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.EPMAD else MDCR_EL3.EPMAD;
        return EPMAD_bit == '0';
    else
        return <a href="shared_pseudocode.html#impl-shared.NonSecureOnlyImplementation.0" title="function: boolean NonSecureOnlyImplementation()">NonSecureOnlyImplementation</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.AllowExternalTraceAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/AllowExternalTraceAccess</h3>
      <p class="pseudocode">// AllowExternalTraceAccess()
// ==========================
// Returns TRUE if an external Trace access to the Trace registers is allowed, FALSE otherwise.

boolean <a id="impl-shared.AllowExternalTraceAccess.0"/>AllowExternalTraceAccess()
    if !<a href="shared_pseudocode.html#impl-shared.HaveTraceBufferExtension.0" title="function: boolean HaveTraceBufferExtension()">HaveTraceBufferExtension</a>() then
        return TRUE;
    else
        return <a href="shared_pseudocode.html#impl-shared.AllowExternalTraceAccess.1" title="function: boolean AllowExternalTraceAccess(SecurityState access_state)">AllowExternalTraceAccess</a>(<a href="shared_pseudocode.html#impl-shared.AccessState.0" title="function: SecurityState AccessState()">AccessState</a>());

// AllowExternalTraceAccess()
// ==========================
// Returns TRUE if an external Trace access to the Trace registers is allowed for the
// given Security state, FALSE otherwise.

boolean <a id="impl-shared.AllowExternalTraceAccess.1"/>AllowExternalTraceAccess(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> access_state)
    // The access may also be subject to OS lock, power-down, etc.
    if !<a href="shared_pseudocode.html#impl-shared.HaveTraceBufferExtension.0" title="function: boolean HaveTraceBufferExtension()">HaveTraceBufferExtension</a>() then return TRUE;
    assert <a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()">HaveSecureExtDebugView</a>();
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        case MDCR_EL3.&lt;ETADE,ETAD&gt; of
            when '00' return TRUE;
            when '01' return access_state IN {<a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>, <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>};
            when '10' return access_state IN {<a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>, <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>};
            when '11' return access_state == <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>;

    if access_state == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then return TRUE;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        // External Trace access is not supported for EL3 using AArch32
        assert !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        return MDCR_EL3.ETAD == '0';
    else
        return <a href="shared_pseudocode.html#impl-shared.NonSecureOnlyImplementation.0" title="function: boolean NonSecureOnlyImplementation()">NonSecureOnlyImplementation</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.Debug_authentication"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/Debug_authentication</h3>
      <p class="pseudocode">signal DBGEN;
signal NIDEN;
signal SPIDEN;
signal SPNIDEN;
signal RLPIDEN;
signal RTPIDEN;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalInvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalInvasiveDebugEnabled()
// ==============================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the DBGEN signal.

boolean <a id="impl-shared.ExternalInvasiveDebugEnabled.0"/>ExternalInvasiveDebugEnabled()
    return DBGEN == HIGH;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalNoninvasiveDebugAllowed"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalNoninvasiveDebugAllowed</h3>
      <p class="pseudocode">// ExternalNoninvasiveDebugAllowed()
// =================================
// Returns TRUE if Trace and PC Sample-based Profiling are allowed

boolean <a id="impl-shared.ExternalNoninvasiveDebugAllowed.0"/>ExternalNoninvasiveDebugAllowed()
    return <a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugAllowed.1" title="function: boolean ExternalNoninvasiveDebugAllowed(bits(2) el)">ExternalNoninvasiveDebugAllowed</a>(PSTATE.EL);

// ExternalNoninvasiveDebugAllowed()
// =================================

boolean <a id="impl-shared.ExternalNoninvasiveDebugAllowed.1"/>ExternalNoninvasiveDebugAllowed(bits(2) el)
    if !<a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()">ExternalNoninvasiveDebugEnabled</a>() then return FALSE;
    ss = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(el);

    if ((<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) &amp;&amp; el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp;
        ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; SDER.SUNIDEN == '1') then
        return TRUE;

    case ss of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> return TRUE;
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    return <a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     return <a href="shared_pseudocode.html#impl-shared.ExternalRealmNoninvasiveDebugEnabled.0" title="function: boolean ExternalRealmNoninvasiveDebugEnabled()">ExternalRealmNoninvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>      return <a href="shared_pseudocode.html#impl-shared.ExternalRootNoninvasiveDebugEnabled.0" title="function: boolean ExternalRootNoninvasiveDebugEnabled()">ExternalRootNoninvasiveDebugEnabled</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalNoninvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalNoninvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalNoninvasiveDebugEnabled()
// =================================
// This function returns TRUE if the FEAT_Debugv8p4 is implemented.
// Otherwise, this function is IMPLEMENTATION DEFINED, and, in the
// recommended interface, ExternalNoninvasiveDebugEnabled returns
// the state of the (DBGEN OR NIDEN) signal.

boolean <a id="impl-shared.ExternalNoninvasiveDebugEnabled.0"/>ExternalNoninvasiveDebugEnabled()
    return !<a href="shared_pseudocode.html#impl-shared.HaveNoninvasiveDebugAuth.0" title="function: boolean HaveNoninvasiveDebugAuth()">HaveNoninvasiveDebugAuth</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() || NIDEN == HIGH;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalRealmInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalRealmInvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalRealmInvasiveDebugEnabled()
// ===================================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the
// (DBGEN AND RLPIDEN) signal.

boolean <a id="impl-shared.ExternalRealmInvasiveDebugEnabled.0"/>ExternalRealmInvasiveDebugEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then return FALSE;
    return <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() &amp;&amp; RLPIDEN == HIGH;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalRealmNoninvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalRealmNoninvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalRealmNoninvasiveDebugEnabled()
// ======================================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the
// (DBGEN AND RLPIDEN) signal.

boolean <a id="impl-shared.ExternalRealmNoninvasiveDebugEnabled.0"/>ExternalRealmNoninvasiveDebugEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then return FALSE;
    return <a href="shared_pseudocode.html#impl-shared.ExternalRealmInvasiveDebugEnabled.0" title="function: boolean ExternalRealmInvasiveDebugEnabled()">ExternalRealmInvasiveDebugEnabled</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalRootInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalRootInvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalRootInvasiveDebugEnabled()
// ==================================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the
// (DBGEN AND RLPIDEN AND SPIDEN AND RTPIDEN) signal.

boolean <a id="impl-shared.ExternalRootInvasiveDebugEnabled.0"/>ExternalRootInvasiveDebugEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then return FALSE;
    return (<a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() &amp;&amp;
            <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>() &amp;&amp;
            <a href="shared_pseudocode.html#impl-shared.ExternalRealmInvasiveDebugEnabled.0" title="function: boolean ExternalRealmInvasiveDebugEnabled()">ExternalRealmInvasiveDebugEnabled</a>() &amp;&amp;
            RTPIDEN == HIGH);</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalRootNoninvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalRootNoninvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalRootNoninvasiveDebugEnabled()
// =====================================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the
// (DBGEN AND RLPIDEN AND SPIDEN AND RTPIDEN) signal.

boolean <a id="impl-shared.ExternalRootNoninvasiveDebugEnabled.0"/>ExternalRootNoninvasiveDebugEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then return FALSE;
    return <a href="shared_pseudocode.html#impl-shared.ExternalRootInvasiveDebugEnabled.0" title="function: boolean ExternalRootInvasiveDebugEnabled()">ExternalRootInvasiveDebugEnabled</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalSecureInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalSecureInvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalSecureInvasiveDebugEnabled()
// ====================================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the (DBGEN AND SPIDEN) signal.
// CoreSight allows asserting SPIDEN without also asserting DBGEN, but this is not recommended.

boolean <a id="impl-shared.ExternalSecureInvasiveDebugEnabled.0"/>ExternalSecureInvasiveDebugEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.SecureOnlyImplementation.0" title="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</a>() then return FALSE;
    return <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() &amp;&amp; SPIDEN == HIGH;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalSecureNoninvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalSecureNoninvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalSecureNoninvasiveDebugEnabled()
// =======================================
// This function returns the value of ExternalSecureInvasiveDebugEnabled() when FEAT_Debugv8p4
// is implemented. Otherwise, the definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the (DBGEN OR NIDEN) AND
// (SPIDEN OR SPNIDEN) signal.

boolean <a id="impl-shared.ExternalSecureNoninvasiveDebugEnabled.0"/>ExternalSecureNoninvasiveDebugEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.SecureOnlyImplementation.0" title="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</a>() then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveNoninvasiveDebugAuth.0" title="function: boolean HaveNoninvasiveDebugAuth()">HaveNoninvasiveDebugAuth</a>() then
        return <a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()">ExternalNoninvasiveDebugEnabled</a>() &amp;&amp; (SPIDEN == HIGH || SPNIDEN == HIGH);
    else
        return <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.IsAccessSecure"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/IsAccessSecure</h3>
      <p class="pseudocode">// Returns TRUE when an access is Secure
boolean <a id="impl-shared.IsAccessSecure.0"/>IsAccessSecure();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.IsCorePowered"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/IsCorePowered</h3>
      <p class="pseudocode">// Returns TRUE if the Core power domain is powered on, FALSE otherwise.
boolean <a id="impl-shared.IsCorePowered.0"/>IsCorePowered();</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.CheckValidStateMatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/CheckValidStateMatch</h3>
      <p class="pseudocode">// CheckValidStateMatch()
// ======================
// Checks for an invalid state match that will generate Constrained
// Unpredictable behavior, otherwise returns Constraint_NONE.

(Constraint, bits(2), bit, bit, bits(2)) <a id="impl-shared.CheckValidStateMatch.5"/>CheckValidStateMatch(bits(2) ssc_in, bit ssce_in, bit hmc_in,
                                                              bits(2) pxc_in, boolean isbreakpnt)
    if !<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then assert ssce_in == '0';
    boolean reserved = FALSE;
    bits(2) ssc = ssc_in;
    bit ssce    = ssce_in;
    bit hmc     = hmc_in;
    bits(2) pxc = pxc_in;

    // Values that are not allocated in any architecture version
    case hmc:ssce:ssc:pxc of
        when '0 0 11 10' reserved = TRUE;
        when '1 0 00 x0' reserved = TRUE;
        when '1 0 01 10' reserved = TRUE;
        when '1 0 1x 10' reserved = TRUE;
        when 'x 1 xx xx' reserved = ssc != '01' || (hmc:pxc) IN {'000','110'};
        otherwise        reserved = FALSE;

    // Match 'Usr/Sys/Svc' valid only for AArch32 breakpoints
    if (!isbreakpnt || !<a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) &amp;&amp; hmc:pxc == '000' &amp;&amp; ssc != '11' then
        reserved = TRUE;

    // Both EL3 and EL2 are not implemented
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (hmc != '0' || ssc != '00') then
        reserved = TRUE;

    // EL3 is not implemented
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; ssc IN {'01','10'} &amp;&amp; hmc:ssc:pxc != '10100' then
        reserved = TRUE;

    // EL3 using AArch64 only
    if (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>()) &amp;&amp; hmc:ssc:pxc == '11000' then
        reserved = TRUE;

    // EL2 is not implemented
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; hmc:ssc:pxc == '11100' then
        reserved = TRUE;

    // Secure EL2 is not implemented
    if !<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; (hmc:ssc:pxc)  IN {'01100','10100','x11x1'} then
        reserved = TRUE;

    if reserved then
        // If parameters are set to a reserved type, behaves as either disabled or a defined type
        <a href="shared_pseudocode.html#Constraint" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
        (c, &lt;hmc,ssc,ssce,pxc&gt;) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESBPWPCTRL" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESBPWPCTRL</a>, 6);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then
            return (c, bits(2) UNKNOWN, bit UNKNOWN, bit UNKNOWN, bits(2) UNKNOWN);
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    return (<a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, ssc, ssce, hmc, pxc);</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.ContextMatchingBreakpointRange"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/ContextMatchingBreakpointRange</h3>
      <p class="pseudocode">// ContextMatchingBreakpointRange()
// ================================
// Returns two numbers indicating the index of the first and last context-aware breakpoint.

(integer, integer) <a id="impl-shared.ContextMatchingBreakpointRange.0"/>ContextMatchingBreakpointRange()
    integer b = <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>();
    integer c = <a href="shared_pseudocode.html#impl-shared.NumContextAwareBreakpointsImplemented.0" title="function: integer NumContextAwareBreakpointsImplemented()">NumContextAwareBreakpointsImplemented</a>();

    if b &lt;= 16 then
        return (b - c, b - 1);
    elsif c &lt;= 16 then
        return (16 - c, 15);
    else
        return (0, c - 1);</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.IsContextMatchingBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/IsContextMatchingBreakpoint</h3>
      <p class="pseudocode">// IsContextMatchingBreakpoint()
// =============================
// Returns TRUE if DBGBCR_EL1[n] is a context-aware breakpoint.

boolean <a id="impl-shared.IsContextMatchingBreakpoint.1"/>IsContextMatchingBreakpoint(integer n)
    (lower, upper) = <a href="shared_pseudocode.html#impl-shared.ContextMatchingBreakpointRange.0" title="function: (integer, integer) ContextMatchingBreakpointRange()">ContextMatchingBreakpointRange</a>();
    return n &gt;= lower &amp;&amp; n &lt;= upper;</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.NumBreakpointsImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/NumBreakpointsImplemented</h3>
      <p class="pseudocode">// NumBreakpointsImplemented()
// ===========================
// Returns the number of breakpoints implemented. This is indicated to software by
// DBGDIDR.BRPs in AArch32 state, and ID_AA64DFR0_EL1.BRPs in AArch64 state.

integer <a id="impl-shared.NumBreakpointsImplemented.0"/>NumBreakpointsImplemented()
    return integer IMPLEMENTATION_DEFINED "Number of breakpoints";</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.NumContextAwareBreakpointsImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/NumContextAwareBreakpointsImplemented</h3>
      <p class="pseudocode">// NumContextAwareBreakpointsImplemented()
// =======================================
// Returns the number of context-aware breakpoints implemented. This is indicated to software by
// DBGDIDR.CTX_CMPs in AArch32 state, and ID_AA64DFR0_EL1.CTX_CMPs in AArch64 state.

integer <a id="impl-shared.NumContextAwareBreakpointsImplemented.0"/>NumContextAwareBreakpointsImplemented()
    return integer IMPLEMENTATION_DEFINED "Number of context-aware breakpoints";</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.NumWatchpointsImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/NumWatchpointsImplemented</h3>
      <p class="pseudocode">// NumWatchpointsImplemented()
// ===========================
// Returns the number of watchpoints implemented. This is indicated to software by
// DBGDIDR.WRPs in AArch32 state, and ID_AA64DFR0_EL1.WRPs in AArch64 state.

integer <a id="impl-shared.NumWatchpointsImplemented.0"/>NumWatchpointsImplemented()
    return integer IMPLEMENTATION_DEFINED "Number of watchpoints";</p>
    </div>
    <div class="ps"><a id="shared.debug.cti.CTI_SetEventLevel"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/cti/CTI_SetEventLevel</h3>
      <p class="pseudocode">// Set a Cross Trigger multi-cycle input event trigger to the specified level.
CTI_SetEventLevel(<a href="shared_pseudocode.html#CrossTriggerIn" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn</a> id, signal level);</p>
    </div>
    <div class="ps"><a id="shared.debug.cti.CTI_SignalEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/cti/CTI_SignalEvent</h3>
      <p class="pseudocode">// Signal a discrete event on a Cross Trigger input event trigger.
<a id="impl-shared.CTI_SignalEvent.1"/>CTI_SignalEvent(<a href="shared_pseudocode.html#CrossTriggerIn" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn</a> id);</p>
    </div>
    <div class="ps"><a id="shared.debug.cti.CrossTrigger"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/cti/CrossTrigger</h3>
      <p class="pseudocode">enumeration <a id="CrossTriggerOut"/>CrossTriggerOut {<a id="CrossTriggerOut_DebugRequest"/>CrossTriggerOut_DebugRequest, <a id="CrossTriggerOut_RestartRequest"/>CrossTriggerOut_RestartRequest,
                             <a id="CrossTriggerOut_IRQ"/>CrossTriggerOut_IRQ,          <a id="CrossTriggerOut_RSVD3"/>CrossTriggerOut_RSVD3,
                             <a id="CrossTriggerOut_TraceExtIn0"/>CrossTriggerOut_TraceExtIn0,  <a id="CrossTriggerOut_TraceExtIn1"/>CrossTriggerOut_TraceExtIn1,
                             <a id="CrossTriggerOut_TraceExtIn2"/>CrossTriggerOut_TraceExtIn2,  <a id="CrossTriggerOut_TraceExtIn3"/>CrossTriggerOut_TraceExtIn3};

enumeration <a id="CrossTriggerIn"/>CrossTriggerIn  {<a id="CrossTriggerIn_CrossHalt"/>CrossTriggerIn_CrossHalt,     <a id="CrossTriggerIn_PMUOverflow"/>CrossTriggerIn_PMUOverflow,
                             <a id="CrossTriggerIn_RSVD2"/>CrossTriggerIn_RSVD2,         <a id="CrossTriggerIn_RSVD3"/>CrossTriggerIn_RSVD3,
                             <a id="CrossTriggerIn_TraceExtOut0"/>CrossTriggerIn_TraceExtOut0,  <a id="CrossTriggerIn_TraceExtOut1"/>CrossTriggerIn_TraceExtOut1,
                             <a id="CrossTriggerIn_TraceExtOut2"/>CrossTriggerIn_TraceExtOut2,  <a id="CrossTriggerIn_TraceExtOut3"/>CrossTriggerIn_TraceExtOut3};</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.CheckForDCCInterrupts"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/CheckForDCCInterrupts</h3>
      <p class="pseudocode">// CheckForDCCInterrupts()
// =======================

<a id="impl-shared.CheckForDCCInterrupts.0"/>CheckForDCCInterrupts()
    commrx = (EDSCR.RXfull == '1');
    commtx = (EDSCR.TXfull == '0');

    // COMMRX and COMMTX support is optional and not recommended for new designs.
    // SetInterruptRequestLevel(InterruptID_COMMRX, if commrx then HIGH else LOW);
    // SetInterruptRequestLevel(InterruptID_COMMTX, if commtx then HIGH else LOW);

    // The value to be driven onto the common COMMIRQ signal.
    boolean commirq;
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        commirq = ((commrx &amp;&amp; DBGDCCINT.RX == '1') ||
                   (commtx &amp;&amp; DBGDCCINT.TX == '1'));
    else
        commirq = ((commrx &amp;&amp; MDCCINT_EL1.RX == '1') ||
                   (commtx &amp;&amp; MDCCINT_EL1.TX == '1'));
    SetInterruptRequestLevel(<a href="shared_pseudocode.html#InterruptID_COMMIRQ" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_COMMIRQ</a>, if commirq then HIGH else LOW);

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.DBGDTRRX_EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/DBGDTRRX_EL0</h3>
      <p class="pseudocode">// DBGDTRRX_EL0[] (external write)
// ===============================
// Called on writes to debug register 0x08C.

<a id="impl-shared.DBGDTRRX_EL0.write.1"/>DBGDTRRX_EL0[boolean memory_mapped] = bits(32) value

    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return;

    if EDSCR.ERR == '1' then return;                    // Error flag set: ignore write

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write

    if EDSCR.RXfull == '1' || (<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.MA == '1' &amp;&amp; EDSCR.ITE == '0') then
        EDSCR.RXO = '1';  EDSCR.ERR = '1';              // Overrun condition: ignore write
        return;

    EDSCR.RXfull = '1';
    DTRRX = value;

    if <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.MA == '1' then
        EDSCR.ITE = '0';                            // See comments in EDITR[] (external write)
        if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(0xD5330501&lt;31:0&gt;);               // A64 "MRS X1,DBGDTRRX_EL0"
            <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(0xB8004401&lt;31:0&gt;);               // A64 "STR W1,[X0],#4"
            <a href="shared_pseudocode.html#impl-aarch64.X.write.2" title="accessor: X[integer n, integer width] = bits(width) value">X</a>[1, 64] = bits(64) UNKNOWN;
        else
            <a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(0xEE10&lt;15:0&gt; /*hw1*/, 0x1E15&lt;15:0&gt; /*hw2*/);  // T32 "MRS R1,DBGDTRRXint"
            <a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(0xF840&lt;15:0&gt; /*hw1*/, 0x1B04&lt;15:0&gt; /*hw2*/);  // T32 "STR R1,[R0],#4"
            <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[1] = bits(32) UNKNOWN;
        // If the store aborts, the Data Abort exception is taken and EDSCR.ERR is set to 1
        if EDSCR.ERR == '1' then
            EDSCR.RXfull = bit UNKNOWN;
            DBGDTRRX_EL0 = bits(64) UNKNOWN;
        else
            // "MRS X1,DBGDTRRX_EL0" calls DBGDTR_EL0[] (read) which clears RXfull.
            assert EDSCR.RXfull == '0';

        EDSCR.ITE = '1';                                // See comments in EDITR[] (external write)
    return;

// DBGDTRRX_EL0[] (external read)
// ==============================

bits(32) <a id="impl-shared.DBGDTRRX_EL0.read.1"/>DBGDTRRX_EL0[boolean memory_mapped]
    return DTRRX;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.DBGDTRTX_EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/DBGDTRTX_EL0</h3>
      <p class="pseudocode">// DBGDTRTX_EL0[] (external read)
// ==============================
// Called on reads of debug register 0x080.

bits(32) <a id="impl-shared.DBGDTRTX_EL0.read.1"/>DBGDTRTX_EL0[boolean memory_mapped]

    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return bits(32) UNKNOWN;

    underrun = EDSCR.TXfull == '0' || (<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.MA == '1' &amp;&amp; EDSCR.ITE == '0');
    value = if underrun then bits(32) UNKNOWN else DTRTX;

    if EDSCR.ERR == '1' then return value;              // Error flag set: no side-effects

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then           // Software lock locked: no side-effects
        return value;

    if underrun then
        EDSCR.TXU = '1';  EDSCR.ERR = '1';              // Underrun condition: block side-effects
        return value;                                   // Return UNKNOWN

    EDSCR.TXfull = '0';
    if <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.MA == '1' then
        EDSCR.ITE = '0';                                // See comments in EDITR[] (external write)

        if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(0xB8404401&lt;31:0&gt;);               // A64 "LDR W1,[X0],#4"
        else
            <a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(0xF850&lt;15:0&gt; /*hw1*/, 0x1B04&lt;15:0&gt; /*hw2*/);      // T32 "LDR R1,[R0],#4"
        // If the load aborts, the Data Abort exception is taken and EDSCR.ERR is set to 1
        if EDSCR.ERR == '1' then
            EDSCR.TXfull = bit UNKNOWN;
            DBGDTRTX_EL0 = bits(64) UNKNOWN;
        else
            if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
                <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(0xD5130501&lt;31:0&gt;);           // A64 "MSR DBGDTRTX_EL0,X1"
            else
                <a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(0xEE00&lt;15:0&gt; /*hw1*/, 0x1E15&lt;15:0&gt; /*hw2*/);  // T32 "MSR DBGDTRTXint,R1"
            // "MSR DBGDTRTX_EL0,X1" calls DBGDTR_EL0[] (write) which sets TXfull.
            assert EDSCR.TXfull == '1';
        if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a href="shared_pseudocode.html#impl-aarch64.X.write.2" title="accessor: X[integer n, integer width] = bits(width) value">X</a>[1, 64] = bits(64) UNKNOWN;
        else
            <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[1] = bits(32) UNKNOWN;
        EDSCR.ITE = '1';                                // See comments in EDITR[] (external write)

    return value;

// DBGDTRTX_EL0[] (external write)
// ===============================

<a id="impl-shared.DBGDTRTX_EL0.write.1"/>DBGDTRTX_EL0[boolean memory_mapped] = bits(32) value
    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write
    DTRTX = value;
    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.DBGDTR_EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/DBGDTR_EL0</h3>
      <p class="pseudocode">// DBGDTR_EL0[] (write)
// ====================
// System register writes to DBGDTR_EL0, DBGDTRTX_EL0 (AArch64) and DBGDTRTXint (AArch32)

DBGDTR_EL0[] = bits(N) value_in
    bits(N) value = value_in;
    // For MSR DBGDTRTX_EL0,&lt;Rt&gt;  N=32, value=X[t]&lt;31:0&gt;, X[t]&lt;63:32&gt; is ignored
    // For MSR DBGDTR_EL0,&lt;Xt&gt;    N=64, value=X[t]&lt;63:0&gt;
    assert N IN {32,64};
    if EDSCR.TXfull == '1' then
        value = bits(N) UNKNOWN;
    // On a 64-bit write, implement a half-duplex channel
    if N == 64 then DTRRX = value&lt;63:32&gt;;
    DTRTX = value&lt;31:0&gt;;        // 32-bit or 64-bit write
    EDSCR.TXfull = '1';
    return;

// DBGDTR_EL0[] (read)
// ===================
// System register reads of DBGDTR_EL0, DBGDTRRX_EL0 (AArch64) and DBGDTRRXint (AArch32)

bits(N) <a id="impl-shared.DBGDTR_EL0.read.0"/>DBGDTR_EL0[]
    // For MRS &lt;Rt&gt;,DBGDTRTX_EL0  N=32, X[t]=Zeros(32):result
    // For MRS &lt;Xt&gt;,DBGDTR_EL0    N=64, X[t]=result
    assert N IN {32,64};
    bits(N) result;
    if EDSCR.RXfull == '0' then
        result = bits(N) UNKNOWN;
    else
        // On a 64-bit read, implement a half-duplex channel
        // NOTE: the word order is reversed on reads with regards to writes
        if N == 64 then result&lt;63:32&gt; = DTRTX;
        result&lt;31:0&gt; = DTRRX;
    EDSCR.RXfull = '0';
    return result;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.DTR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/DTR</h3>
      <p class="pseudocode">bits(32) DTRRX;
bits(32) DTRTX;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.EDITR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/EDITR</h3>
      <p class="pseudocode">// EDITR[] (external write)
// ========================
// Called on writes to debug register 0x084.

<a id="impl-shared.EDITR.write.1"/>EDITR[boolean memory_mapped] = bits(32) value
    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return;

    if EDSCR.ERR == '1' then return;                    // Error flag set: ignore write

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write

    if !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then return;                           // Non-debug state: ignore write

    if EDSCR.ITE == '0' || EDSCR.MA == '1' then
        EDSCR.ITO = '1';  EDSCR.ERR = '1';              // Overrun condition: block write
        return;

    // ITE indicates whether the processor is ready to accept another instruction; the processor
    // may support multiple outstanding instructions. Unlike the "InstrCompl" flag in [v7A] there
    // is no indication that the pipeline is empty (all instructions have completed). In this
    // pseudocode, the assumption is that only one instruction can be executed at a time,
    // meaning ITE acts like "InstrCompl".
    EDSCR.ITE = '0';

    if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(value);
    else
        <a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(value&lt;15:0&gt;/*hw1*/, value&lt;31:16&gt; /*hw2*/);

    EDSCR.ITE = '1';

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DCPSInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DCPSInstruction</h3>
      <p class="pseudocode">// DCPSInstruction()
// =================
// Operation of the DCPS instruction in Debug state

<a id="impl-shared.DCPSInstruction.1"/>DCPSInstruction(bits(2) target_el)

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();

    bits(2) handle_el;
    case target_el of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>()) then
                handle_el = PSTATE.EL;
            elsif <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
                UNDEFINED;
            else
                handle_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
                UNDEFINED;
            elsif PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
                handle_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
            elsif !<a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
                UNDEFINED;
            else
                handle_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            if EDSCR.SDD == '1' || !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
                UNDEFINED;
            else
                handle_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    from_secure = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(handle_el) then
        if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
        assert <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();                  // Cannot move from AArch64 to AArch32
        case handle_el of
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
                <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>);
                if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; SCTLR.SPAN == '0' then
                    PSTATE.PAN = '1';
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
                <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>);
                if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() then
                    if !from_secure then
                        PSTATE.PAN = '0';
                    elsif SCTLR.SPAN == '0' then
                        PSTATE.PAN = '1';
        if handle_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            ELR_hyp = bits(32) UNKNOWN;  HSR = bits(32) UNKNOWN;
        else
            <a href="shared_pseudocode.html#impl-aarch32.LR.write.none" title="accessor: LR = bits(32) value">LR</a> = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(32) UNKNOWN;
        PSTATE.E = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].EE;
        DLR = bits(32) UNKNOWN;  DSPSR = bits(32) UNKNOWN;

    else                                        // Targeting AArch64
        from_32 = <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
        if from_32 then <a href="shared_pseudocode.html#AArch64.MaybeZeroRegisterUppers.0" title="function: AArch64.MaybeZeroRegisterUppers()">AArch64.MaybeZeroRegisterUppers</a>();
        if from_32 &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' then
            <a href="shared_pseudocode.html#impl-aarch64.ResetSVEState.0" title="function: ResetSVEState()">ResetSVEState</a>();
        else
            <a href="shared_pseudocode.html#impl-aarch64.MaybeZeroSVEUppers.1" title="function: MaybeZeroSVEUppers(bits(2) target_el)">MaybeZeroSVEUppers</a>(target_el);
        PSTATE.nRW = '0';  PSTATE.SP = '1';  PSTATE.EL = handle_el;
        if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; ((handle_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; SCTLR_EL1.SPAN == '0') ||
                            (handle_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; HCR_EL2.E2H == '1' &amp;&amp;
                             HCR_EL2.TGE == '1' &amp;&amp; SCTLR_EL2.SPAN == '0')) then
            PSTATE.PAN = '1';
        <a href="shared_pseudocode.html#impl-aarch64.ELR.write.0" title="accessor: ELR[] = bits(64) value">ELR</a>[] = bits(64) UNKNOWN;  <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(64) UNKNOWN;  <a href="shared_pseudocode.html#impl-aarch64.ESR.write.0" title="accessor: ESR[] = ESRType value">ESR</a>[] = bits(64) UNKNOWN;
        DLR_EL0 = bits(64) UNKNOWN;  DSPSR_EL0 = bits(64) UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = '0';
        if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = '1';

    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR PE state flags
    sync_errors = <a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()">HaveIESB</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].IESB == '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    // SCTLR[].IESB might be ignored in Debug state.
    if !<a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_IESBinDebug</a>) then
        sync_errors = FALSE;
    if sync_errors then
        <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()">SynchronizeErrors</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DRPSInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DRPSInstruction</h3>
      <p class="pseudocode">// DRPSInstruction()
// =================
// Operation of the A64 DRPS and T32 ERET instructions in Debug state

<a id="impl-shared.DRPSInstruction.0"/>DRPSInstruction()

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();

    sync_errors = <a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()">HaveIESB</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].IESB == '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    // SCTLR[].IESB might be ignored in Debug state.
    if !<a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_IESBinDebug</a>) then
        sync_errors = FALSE;
    if sync_errors then
        <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()">SynchronizeErrors</a>();

    <a href="shared_pseudocode.html#impl-shared.DebugRestorePSR.0" title="function: DebugRestorePSR()">DebugRestorePSR</a>();

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DebugHalt"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DebugHalt</h3>
      <p class="pseudocode">constant bits(6) <a id="DebugHalt_Breakpoint"/>DebugHalt_Breakpoint      = '000111';
constant bits(6) <a id="DebugHalt_EDBGRQ"/>DebugHalt_EDBGRQ          = '010011';
constant bits(6) <a id="DebugHalt_Step_Normal"/>DebugHalt_Step_Normal     = '011011';
constant bits(6) <a id="DebugHalt_Step_Exclusive"/>DebugHalt_Step_Exclusive  = '011111';
constant bits(6) <a id="DebugHalt_OSUnlockCatch"/>DebugHalt_OSUnlockCatch   = '100011';
constant bits(6) <a id="DebugHalt_ResetCatch"/>DebugHalt_ResetCatch      = '100111';
constant bits(6) <a id="DebugHalt_Watchpoint"/>DebugHalt_Watchpoint      = '101011';
constant bits(6) <a id="DebugHalt_HaltInstruction"/>DebugHalt_HaltInstruction = '101111';
constant bits(6) <a id="DebugHalt_SoftwareAccess"/>DebugHalt_SoftwareAccess  = '110011';
constant bits(6) <a id="DebugHalt_ExceptionCatch"/>DebugHalt_ExceptionCatch  = '110111';
constant bits(6) <a id="DebugHalt_Step_NoSyndrome"/>DebugHalt_Step_NoSyndrome = '111011';</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DebugRestorePSR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DebugRestorePSR</h3>
      <p class="pseudocode">// DebugRestorePSR()
// =================

<a id="impl-shared.DebugRestorePSR.0"/>DebugRestorePSR()
    // PSTATE.{N,Z,C,V,Q,GE,SS,D,A,I,F} are not observable and ignored in Debug state, so
    // behave as if UNKNOWN.
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        bits(32) spsr = <a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(N) SPSR[]">SPSR</a>[];
        <a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr);
        PSTATE.&lt;N,Z,C,V,Q,GE,SS,A,I,F&gt; = bits(13) UNKNOWN;
        //  In AArch32, all instructions are T32 and unconditional.
        PSTATE.IT = '00000000';  PSTATE.T = '1';        // PSTATE.J is RES0
        DLR = bits(32) UNKNOWN;  DSPSR = bits(32) UNKNOWN;
    else
        bits(64) spsr = <a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(N) SPSR[]">SPSR</a>[];
        <a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr);
        PSTATE.&lt;N,Z,C,V,SS,D,A,I,F&gt; = bits(9) UNKNOWN;
        DLR_EL0 = bits(64) UNKNOWN;  DSPSR_EL0 = bits(64) UNKNOWN;
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                                // Update EDSCR PE state flags</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DisableITRAndResumeInstructionPrefetch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DisableITRAndResumeInstructionPrefetch</h3>
      <p class="pseudocode"><a id="impl-shared.DisableITRAndResumeInstructionPrefetch.0"/>DisableITRAndResumeInstructionPrefetch();</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.ExecuteA64"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/ExecuteA64</h3>
      <p class="pseudocode">// Execute an A64 instruction in Debug state.
<a id="impl-shared.ExecuteA64.1"/>ExecuteA64(bits(32) instr);</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.ExecuteT32"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/ExecuteT32</h3>
      <p class="pseudocode">// Execute a T32 instruction in Debug state.
<a id="impl-shared.ExecuteT32.2"/>ExecuteT32(bits(16) hw1, bits(16) hw2);</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.ExitDebugState"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/ExitDebugState</h3>
      <p class="pseudocode">// ExitDebugState()
// ================

<a id="impl-shared.ExitDebugState.0"/>ExitDebugState()
    assert <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();

    // Although EDSCR.STATUS signals that the PE is restarting, debuggers must use EDPRSR.SDR to
    // detect that the PE has restarted.
    EDSCR.STATUS = '000001';                           // Signal restarting
    // Clear any pending Halting debug events
    if <a href="shared_pseudocode.html#impl-shared.Havev8p8Debug.0" title="function: boolean Havev8p8Debug()">Havev8p8Debug</a>() then
        EDESR&lt;3:0&gt; = '0000';
    else
        EDESR&lt;2:0&gt; = '000';

    bits(64) new_pc;
    bits(64) spsr;

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        new_pc = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DLR, 64);
        if <a href="shared_pseudocode.html#impl-shared.Havev8p9Debug.0" title="function: boolean Havev8p9Debug()">Havev8p9Debug</a>() then
            spsr = DSPSR2 : DSPSR;
        else
            spsr = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DSPSR, 64);
    else
        new_pc = DLR_EL0;
        spsr = DSPSR_EL0;

    boolean illegal_psr_state = <a href="shared_pseudocode.html#impl-shared.IllegalExceptionReturn.1" title="function: boolean IllegalExceptionReturn(bits(N) spsr)">IllegalExceptionReturn</a>(spsr);
    // If this is an illegal return, SetPSTATEFromPSR() will set PSTATE.IL.
    <a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr);                            // Can update privileged bits, even at EL0

    boolean branch_conditional = FALSE;
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_RESTARTALIGNPC" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESTARTALIGNPC</a>) then new_pc&lt;0&gt; = '0';
        // AArch32 branch
        <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(new_pc&lt;31:0&gt;, <a href="shared_pseudocode.html#BranchType_DBGEXIT" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DBGEXIT</a>, branch_conditional);
    else
        // If targeting AArch32 then PC[63:32,1:0] might be set to UNKNOWN.
        if illegal_psr_state &amp;&amp; spsr&lt;4&gt; == '1' then
            new_pc&lt;63:32&gt; = bits(32) UNKNOWN;
            new_pc&lt;1:0&gt; = bits(2) UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveBRBExt.0" title="function: boolean HaveBRBExt()">HaveBRBExt</a>() then
            <a href="shared_pseudocode.html#impl-aarch64.BRBEDebugStateExit.1" title="function: BRBEDebugStateExit(bits(64) target_address)">BRBEDebugStateExit</a>(new_pc);
        // A type of branch that is never predicted
        <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(new_pc, <a href="shared_pseudocode.html#BranchType_DBGEXIT" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DBGEXIT</a>, branch_conditional);

    (EDSCR.STATUS,EDPRSR.SDR) = ('000010','1');        // Atomically signal restarted
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                               // Stop signalling PE state
    <a href="shared_pseudocode.html#impl-shared.DisableITRAndResumeInstructionPrefetch.0" title="function: DisableITRAndResumeInstructionPrefetch()">DisableITRAndResumeInstructionPrefetch</a>();

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.Halt"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/Halt</h3>
      <p class="pseudocode">// Halt()
// ======

<a id="impl-shared.Halt.1"/>Halt(bits(6) reason)
    boolean is_async = FALSE;
    <a href="shared_pseudocode.html#impl-shared.Halt.2" title="function: Halt(bits(6) reason, boolean is_async)">Halt</a>(reason, is_async);

// Halt()
// ======

<a id="impl-shared.Halt.2"/>Halt(bits(6) reason, boolean is_async)

    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then
        <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(<a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>, FALSE);

    <a href="shared_pseudocode.html#impl-shared.CTI_SignalEvent.1" title="function: CTI_SignalEvent(CrossTriggerIn id)">CTI_SignalEvent</a>(<a href="shared_pseudocode.html#CrossTriggerIn_CrossHalt" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_CrossHalt</a>);  // Trigger other cores to halt

    bits(64) preferred_restart_address = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    bits(64) spsr = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.2" title="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState, integer N)">GetPSRFromPSTATE</a>(<a href="shared_pseudocode.html#DebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">DebugState</a>, 64);

    if (<a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() &amp;&amp; !is_async &amp;&amp; !(reason IN {<a href="shared_pseudocode.html#DebugHalt_Step_Normal" title="constant bits(6) DebugHalt_Step_Normal = '011011'">DebugHalt_Step_Normal</a>, <a href="shared_pseudocode.html#DebugHalt_Step_Exclusive" title="constant bits(6) DebugHalt_Step_Exclusive = '011111'">DebugHalt_Step_Exclusive</a>,
        <a href="shared_pseudocode.html#DebugHalt_Step_NoSyndrome" title="constant bits(6) DebugHalt_Step_NoSyndrome = '111011'">DebugHalt_Step_NoSyndrome</a>, <a href="shared_pseudocode.html#DebugHalt_Breakpoint" title="constant bits(6) DebugHalt_Breakpoint = '000111'">DebugHalt_Breakpoint</a>, <a href="shared_pseudocode.html#DebugHalt_HaltInstruction" title="constant bits(6) DebugHalt_HaltInstruction = '101111'">DebugHalt_HaltInstruction</a>}) &amp;&amp;
        <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ZEROBTYPE" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_ZEROBTYPE</a>)) then
        spsr&lt;11:10&gt; = '00';

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        DLR = preferred_restart_address&lt;31:0&gt;;
        DSPSR = spsr&lt;31:0&gt;;
        if <a href="shared_pseudocode.html#impl-shared.Havev8p9Debug.0" title="function: boolean Havev8p9Debug()">Havev8p9Debug</a>() then
            DSPSR2 = spsr&lt;63:32&gt;;
    else
        DLR_EL0 = preferred_restart_address;
        DSPSR_EL0 = spsr;

    EDSCR.ITE = '1';
    EDSCR.ITO = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        EDSCR.SDD = if <a href="shared_pseudocode.html#impl-shared.ExternalRootInvasiveDebugEnabled.0" title="function: boolean ExternalRootInvasiveDebugEnabled()">ExternalRootInvasiveDebugEnabled</a>() then '0' else '1';
    elsif <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        EDSCR.SDD = '0';                        // If entered in Secure state, allow debug
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        EDSCR.SDD = if <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>() then '0' else '1';
    else
        EDSCR.SDD = '1';                        // Otherwise EDSCR.SDD is RES1
    EDSCR.MA = '0';

    // In Debug state:
    // * PSTATE.{SS,SSBS,D,A,I,F} are not observable and ignored so behave-as-if UNKNOWN.
    // * PSTATE.{N,Z,C,V,Q,GE,E,M,nRW,EL,SP,DIT} are also not observable, but since these
    //     are not changed on exception entry, this function also leaves them unchanged.
    // * PSTATE.{IT,T} are ignored.
    // * PSTATE.IL is ignored and behave-as-if 0.
    // * PSTATE.BTYPE is ignored and behave-as-if 0.
    // * PSTATE.TCO is set 1.
    // * PSTATE.{UAO,PAN} are observable and not changed on entry into Debug state.
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        PSTATE.&lt;IT,SS,SSBS,A,I,F,T&gt; = bits(14) UNKNOWN;
    else
        PSTATE.&lt;SS,SSBS,D,A,I,F&gt;    = bits(6)  UNKNOWN;
        PSTATE.TCO = '1';
        PSTATE.BTYPE = '00';
    PSTATE.IL = '0';
    <a href="shared_pseudocode.html#impl-shared.StopInstructionPrefetchAndEnableITR.0" title="function: StopInstructionPrefetchAndEnableITR()">StopInstructionPrefetchAndEnableITR</a>();
    EDSCR.STATUS = reason;                      // Signal entered Debug state
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR PE state flags.
    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.HaltOnBreakpointOrWatchpoint"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/HaltOnBreakpointOrWatchpoint</h3>
      <p class="pseudocode">// HaltOnBreakpointOrWatchpoint()
// ==============================
// Returns TRUE if the Breakpoint and Watchpoint debug events should be considered for Debug
// state entry, FALSE if they should be considered for a debug exception.

boolean <a id="impl-shared.HaltOnBreakpointOrWatchpoint.0"/>HaltOnBreakpointOrWatchpoint()
    return <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDSCR.HDE == '1' &amp;&amp; OSLSR_EL1.OSLK == '0';</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.Halted"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/Halted</h3>
      <p class="pseudocode">// Halted()
// ========

boolean <a id="impl-shared.Halted.0"/>Halted()
    return !(EDSCR.STATUS IN {'000001', '000010'});                     // Halted</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.HaltingAllowed"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/HaltingAllowed</h3>
      <p class="pseudocode">// HaltingAllowed()
// ================
// Returns TRUE if halting is currently allowed, FALSE if halting is prohibited.

boolean <a id="impl-shared.HaltingAllowed.0"/>HaltingAllowed()
    if <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() || <a href="shared_pseudocode.html#impl-shared.DoubleLockStatus.0" title="function: boolean DoubleLockStatus()">DoubleLockStatus</a>() then
        return FALSE;
    ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    case ss of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> return <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    return <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>      return <a href="shared_pseudocode.html#impl-shared.ExternalRootInvasiveDebugEnabled.0" title="function: boolean ExternalRootInvasiveDebugEnabled()">ExternalRootInvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     return <a href="shared_pseudocode.html#impl-shared.ExternalRealmInvasiveDebugEnabled.0" title="function: boolean ExternalRealmInvasiveDebugEnabled()">ExternalRealmInvasiveDebugEnabled</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.Restarting"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/Restarting</h3>
      <p class="pseudocode">// Restarting()
// ============

boolean <a id="impl-shared.Restarting.0"/>Restarting()
    return EDSCR.STATUS == '000001';                                    // Restarting</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.StopInstructionPrefetchAndEnableITR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/StopInstructionPrefetchAndEnableITR</h3>
      <p class="pseudocode"><a id="impl-shared.StopInstructionPrefetchAndEnableITR.0"/>StopInstructionPrefetchAndEnableITR();</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.UpdateEDSCRFields"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/UpdateEDSCRFields</h3>
      <p class="pseudocode">// UpdateEDSCRFields()
// ===================
// Update EDSCR PE state fields

<a id="impl-shared.UpdateEDSCRFields.0"/>UpdateEDSCRFields()

    if !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then
        EDSCR.EL = '00';
        if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
            EDSCR.&lt;NSE,NS&gt; = bits(2) UNKNOWN;
        else
            EDSCR.NS = bit UNKNOWN;

        EDSCR.RW = '1111';
    else
        EDSCR.EL = PSTATE.EL;
        ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
        if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
            case ss of
                when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    EDSCR.&lt;NSE,NS&gt; = '00';
                when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> EDSCR.&lt;NSE,NS&gt; = '01';
                when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>      EDSCR.&lt;NSE,NS&gt; = '10';
                when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     EDSCR.&lt;NSE,NS&gt; = '11';
        else
            EDSCR.NS = if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then '0' else '1';

        bits(4) RW;
        RW&lt;1&gt; = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then '0' else '1';
        if PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            RW&lt;0&gt; = RW&lt;1&gt;;
        else
            RW&lt;0&gt; = if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then '0' else '1';
        if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) || (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].NS == '0' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) then
            RW&lt;2&gt; = RW&lt;1&gt;;
        else
            RW&lt;2&gt; = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then '0' else '1';
        if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            RW&lt;3&gt; = RW&lt;2&gt;;
        else
            RW&lt;3&gt; = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then '0' else '1';

        // The least-significant bits of EDSCR.RW are UNKNOWN if any higher EL is using AArch32.
        if RW&lt;3&gt; == '0' then RW&lt;2:0&gt; = bits(3) UNKNOWN;
        elsif RW&lt;2&gt; == '0' then RW&lt;1:0&gt; = bits(2) UNKNOWN;
        elsif RW&lt;1&gt; == '0' then RW&lt;0&gt; = bit UNKNOWN;
        EDSCR.RW = RW;
    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckExceptionCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckExceptionCatch</h3>
      <p class="pseudocode">// CheckExceptionCatch()
// =====================
// Check whether an Exception Catch debug event is set on the current Exception level

<a id="impl-shared.CheckExceptionCatch.1"/>CheckExceptionCatch(boolean exception_entry)
    // Called after an exception entry or exit, that is, such that the Security state
    // and PSTATE.EL are correct for the exception target. When FEAT_Debugv8p2
    // is not implemented, this function might also be called at any time.
    ss = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
    integer base;

    case ss of
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    base = 0;
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> base = 4;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     base = 16;
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>      base = 0;
    if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() then
        boolean halt;
        if <a href="shared_pseudocode.html#impl-shared.HaveExtendedECDebugEvents.0" title="function: boolean HaveExtendedECDebugEvents()">HaveExtendedECDebugEvents</a>() then
            exception_exit = !exception_entry;
            increment = if ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> then 4 else 8;
            ctrl = EDECCR&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) + base + increment&gt;:EDECCR&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) + base&gt;;
            case ctrl of
                when '00'  halt = FALSE;
                when '01'  halt = TRUE;
                when '10'  halt = (exception_exit == TRUE);
                when '11'  halt = (exception_entry == TRUE);
        else
            halt = (EDECCR&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) + base&gt; == '1');

        if halt then
            if <a href="shared_pseudocode.html#impl-shared.Havev8p8Debug.0" title="function: boolean Havev8p8Debug()">Havev8p8Debug</a>() &amp;&amp; exception_entry then
                EDESR.EC = '1';
            else
                <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_ExceptionCatch" title="constant bits(6) DebugHalt_ExceptionCatch = '110111'">DebugHalt_ExceptionCatch</a>);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckHaltingStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckHaltingStep</h3>
      <p class="pseudocode">// CheckHaltingStep()
// ==================
// Check whether EDESR.SS has been set by Halting Step

<a id="impl-shared.CheckHaltingStep.1"/>CheckHaltingStep(boolean is_async)
    if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDESR.SS == '1' then
        // The STATUS code depends on how we arrived at the state where EDESR.SS == 1.
        if <a href="shared_pseudocode.html#impl-shared.HaltingStep_DidNotStep.0" title="function: boolean HaltingStep_DidNotStep()">HaltingStep_DidNotStep</a>() then
            <a href="shared_pseudocode.html#impl-shared.Halt.2" title="function: Halt(bits(6) reason, boolean is_async)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_Step_NoSyndrome" title="constant bits(6) DebugHalt_Step_NoSyndrome = '111011'">DebugHalt_Step_NoSyndrome</a>, is_async);
        elsif <a href="shared_pseudocode.html#impl-shared.HaltingStep_SteppedEX.0" title="function: boolean HaltingStep_SteppedEX()">HaltingStep_SteppedEX</a>() then
            <a href="shared_pseudocode.html#impl-shared.Halt.2" title="function: Halt(bits(6) reason, boolean is_async)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_Step_Exclusive" title="constant bits(6) DebugHalt_Step_Exclusive = '011111'">DebugHalt_Step_Exclusive</a>, is_async);
        else
            <a href="shared_pseudocode.html#impl-shared.Halt.2" title="function: Halt(bits(6) reason, boolean is_async)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_Step_Normal" title="constant bits(6) DebugHalt_Step_Normal = '011011'">DebugHalt_Step_Normal</a>, is_async);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckOSUnlockCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckOSUnlockCatch</h3>
      <p class="pseudocode">// CheckOSUnlockCatch()
// ====================
// Called on unlocking the OS Lock to pend an OS Unlock Catch debug event

<a id="impl-shared.CheckOSUnlockCatch.0"/>CheckOSUnlockCatch()
    if ((<a href="shared_pseudocode.html#impl-shared.HaveDoPD.0" title="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; CTIDEVCTL.OSUCE == '1') ||
        (!<a href="shared_pseudocode.html#impl-shared.HaveDoPD.0" title="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; EDECR.OSUCE == '1')) then
        if !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then EDESR.OSUC = '1';</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckPendingExceptionCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckPendingExceptionCatch</h3>
      <p class="pseudocode">// CheckPendingExceptionCatch()
// ============================
// Check whether EDESR.EC has been set by an Exception Catch debug event.

<a id="impl-shared.CheckPendingExceptionCatch.1"/>CheckPendingExceptionCatch(boolean is_async)
    if <a href="shared_pseudocode.html#impl-shared.Havev8p8Debug.0" title="function: boolean Havev8p8Debug()">Havev8p8Debug</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDESR.EC == '1' then
        <a href="shared_pseudocode.html#impl-shared.Halt.2" title="function: Halt(bits(6) reason, boolean is_async)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_ExceptionCatch" title="constant bits(6) DebugHalt_ExceptionCatch = '110111'">DebugHalt_ExceptionCatch</a>, is_async);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckPendingOSUnlockCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckPendingOSUnlockCatch</h3>
      <p class="pseudocode">// CheckPendingOSUnlockCatch()
// ===========================
// Check whether EDESR.OSUC has been set by an OS Unlock Catch debug event

<a id="impl-shared.CheckPendingOSUnlockCatch.0"/>CheckPendingOSUnlockCatch()
    if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDESR.OSUC == '1' then
        boolean is_async = TRUE;
        <a href="shared_pseudocode.html#impl-shared.Halt.2" title="function: Halt(bits(6) reason, boolean is_async)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_OSUnlockCatch" title="constant bits(6) DebugHalt_OSUnlockCatch = '100011'">DebugHalt_OSUnlockCatch</a>, is_async);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckPendingResetCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckPendingResetCatch</h3>
      <p class="pseudocode">// CheckPendingResetCatch()
// ========================
// Check whether EDESR.RC has been set by a Reset Catch debug event

<a id="impl-shared.CheckPendingResetCatch.0"/>CheckPendingResetCatch()
    if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDESR.RC == '1' then
        boolean is_async = TRUE;
        <a href="shared_pseudocode.html#impl-shared.Halt.2" title="function: Halt(bits(6) reason, boolean is_async)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_ResetCatch" title="constant bits(6) DebugHalt_ResetCatch = '100111'">DebugHalt_ResetCatch</a>, is_async);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckResetCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckResetCatch</h3>
      <p class="pseudocode">// CheckResetCatch()
// =================
// Called after reset

<a id="impl-shared.CheckResetCatch.0"/>CheckResetCatch()
    if (<a href="shared_pseudocode.html#impl-shared.HaveDoPD.0" title="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; CTIDEVCTL.RCE == '1') || (!<a href="shared_pseudocode.html#impl-shared.HaveDoPD.0" title="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; EDECR.RCE == '1') then
        EDESR.RC = '1';
        // If halting is allowed then halt immediately
        if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() then <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_ResetCatch" title="constant bits(6) DebugHalt_ResetCatch = '100111'">DebugHalt_ResetCatch</a>);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckSoftwareAccessToDebugRegisters"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckSoftwareAccessToDebugRegisters</h3>
      <p class="pseudocode">// CheckSoftwareAccessToDebugRegisters()
// =====================================
// Check for access to Breakpoint and Watchpoint registers.

<a id="impl-shared.CheckSoftwareAccessToDebugRegisters.0"/>CheckSoftwareAccessToDebugRegisters()
    os_lock = (if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then DBGOSLSR.OSLK else OSLSR_EL1.OSLK);
    if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDSCR.TDA == '1' &amp;&amp; os_lock == '0' then
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_SoftwareAccess" title="constant bits(6) DebugHalt_SoftwareAccess = '110011'">DebugHalt_SoftwareAccess</a>);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckTRBEHalt"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckTRBEHalt</h3>
      <p class="pseudocode">// CheckTRBEHalt()
// ===============

<a id="impl-shared.CheckTRBEHalt.0"/>CheckTRBEHalt()
    if !<a href="shared_pseudocode.html#impl-shared.Havev8p9Debug.0" title="function: boolean Havev8p9Debug()">Havev8p9Debug</a>() || !<a href="shared_pseudocode.html#impl-shared.HaveFeatTRBEExt.0" title="function: boolean HaveFeatTRBEExt()">HaveFeatTRBEExt</a>() then
        return;

    if (<a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.TraceBufferEnabled.0" title="function: boolean TraceBufferEnabled()">TraceBufferEnabled</a>() &amp;&amp;
        TRBSR_EL1.IRQ == '1' &amp;&amp; EDECR.TRBE == '1') then
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_EDBGRQ" title="constant bits(6) DebugHalt_EDBGRQ = '010011'">DebugHalt_EDBGRQ</a>);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.ExternalDebugRequest"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/ExternalDebugRequest</h3>
      <p class="pseudocode">// ExternalDebugRequest()
// ======================

<a id="impl-shared.ExternalDebugRequest.0"/>ExternalDebugRequest()
    if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() then
        boolean is_async = TRUE;
        <a href="shared_pseudocode.html#impl-shared.Halt.2" title="function: Halt(bits(6) reason, boolean is_async)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_EDBGRQ" title="constant bits(6) DebugHalt_EDBGRQ = '010011'">DebugHalt_EDBGRQ</a>, is_async);
    // Otherwise the CTI continues to assert the debug request until it is taken.</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.HaltingStep_DidNotStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/HaltingStep_DidNotStep</h3>
      <p class="pseudocode">// Returns TRUE if the previously executed instruction was executed in the inactive state, that is,
// if it was not itself stepped.
boolean <a id="impl-shared.HaltingStep_DidNotStep.0"/>HaltingStep_DidNotStep();</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.HaltingStep_SteppedEX"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/HaltingStep_SteppedEX</h3>
      <p class="pseudocode">// Returns TRUE if the previously executed instruction was a Load-Exclusive class instruction
// executed in the active-not-pending state.
boolean <a id="impl-shared.HaltingStep_SteppedEX.0"/>HaltingStep_SteppedEX();</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.RunHaltingStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/RunHaltingStep</h3>
      <p class="pseudocode">// RunHaltingStep()
// ================

<a id="impl-shared.RunHaltingStep.4"/>RunHaltingStep(boolean exception_generated, bits(2) exception_target, boolean syscall,
               boolean reset)
    // "exception_generated" is TRUE if the previous instruction generated a synchronous exception
    // or was cancelled by an asynchronous exception.
    //
    // if "exception_generated" is TRUE then "exception_target" is the target of the exception, and
    // "syscall" is TRUE if the exception is a synchronous exception where the preferred return
    // address is the instruction following that which generated the exception.
    //
    // "reset" is TRUE if exiting reset state into the highest EL.

    if reset then assert !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();             // Cannot come out of reset halted
    active = EDECR.SS == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();

    if active &amp;&amp; reset then                     // Coming out of reset with EDECR.SS set
        EDESR.SS = '1';
    elsif active &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() then
        boolean advance;
        if exception_generated &amp;&amp; exception_target == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            advance = syscall || <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>();
        else
            advance = TRUE;
        if advance then EDESR.SS = '1';

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.interrupts.ExternalDebugInterruptsDisabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/interrupts/ExternalDebugInterruptsDisabled</h3>
      <p class="pseudocode">// ExternalDebugInterruptsDisabled()
// =================================
// Determine whether EDSCR disables interrupts routed to 'target'.

boolean <a id="impl-shared.ExternalDebugInterruptsDisabled.1"/>ExternalDebugInterruptsDisabled(bits(2) target)
    boolean int_dis;
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(target);
    if <a href="shared_pseudocode.html#impl-shared.Havev8p4Debug.0" title="function: boolean Havev8p4Debug()">Havev8p4Debug</a>() then
        if EDSCR.INTdis[0] == '1' then
            case ss of
                when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> int_dis = <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>();
                when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    int_dis = <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>();
                when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     int_dis = <a href="shared_pseudocode.html#impl-shared.ExternalRealmInvasiveDebugEnabled.0" title="function: boolean ExternalRealmInvasiveDebugEnabled()">ExternalRealmInvasiveDebugEnabled</a>();
                when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>      int_dis = <a href="shared_pseudocode.html#impl-shared.ExternalRootInvasiveDebugEnabled.0" title="function: boolean ExternalRootInvasiveDebugEnabled()">ExternalRootInvasiveDebugEnabled</a>();
        else
            int_dis = FALSE;
    else
        case target of
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
                int_dis = (EDSCR.INTdis == '11' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>());
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
                int_dis = (EDSCR.INTdis IN {'1x'} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>());
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
                if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
                    int_dis = (EDSCR.INTdis IN {'1x'} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>());
                else
                    int_dis = (EDSCR.INTdis != '00' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>());
    return int_dis;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.CYCLE_COUNTER_ID"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/CYCLE_COUNTER_ID</h3>
      <p class="pseudocode">constant integer <a id="CYCLE_COUNTER_ID"/>CYCLE_COUNTER_ID = 31;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.CheckForPMUOverflow"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/CheckForPMUOverflow</h3>
      <p class="pseudocode">// CheckForPMUOverflow()
// =====================
// Signal Performance Monitors overflow IRQ and CTI overflow events.
// Called before each instruction is executed.

<a id="impl-shared.CheckForPMUOverflow.0"/>CheckForPMUOverflow()
    boolean check_cnten  = FALSE;
    boolean check_e      = TRUE;
    boolean check_inten  = TRUE;
    boolean include_lo   = TRUE;
    boolean include_hi   = TRUE;
    boolean exclude_cyc  = FALSE;
    boolean exclude_sync = FALSE;

    boolean pmuirq = <a href="shared_pseudocode.html#impl-shared.PMUOverflowCondition.7" title="function: boolean PMUOverflowCondition(boolean check_e, boolean check_cnten,&#13; boolean check_inten,&#13; boolean include_hi, boolean include_lo,&#13; boolean exclude_cyc, boolean exclude_sync)">PMUOverflowCondition</a>(check_e, check_cnten, check_inten,
                                          include_hi, include_lo,
                                          exclude_cyc, exclude_sync);

    SetInterruptRequestLevel(<a href="shared_pseudocode.html#InterruptID_PMUIRQ" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_PMUIRQ</a>,  if pmuirq then HIGH else LOW);
    CTI_SetEventLevel(<a href="shared_pseudocode.html#CrossTriggerIn_PMUOverflow" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_PMUOverflow</a>, if pmuirq then HIGH else LOW);

    // The request remains set until the condition is cleared.
    // For example, an interrupt handler or cross-triggered event handler clears
    // the overflow status flag by writing to PMOVSCLR_EL0.

    if <a href="shared_pseudocode.html#impl-aarch64.ShouldBRBEFreeze.0" title="function: boolean ShouldBRBEFreeze()">ShouldBRBEFreeze</a>() then
        <a href="shared_pseudocode.html#impl-aarch64.BRBEFreeze.0" title="function: BRBEFreeze()">BRBEFreeze</a>();

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.GetNumEventCounters"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/GetNumEventCounters</h3>
      <p class="pseudocode">// GetNumEventCounters()
// =====================
// Returns the number of event counters implemented. This is indicated to software at the
// highest Exception level by PMCR.N in AArch32 state, and PMCR_EL0.N in AArch64 state.

integer <a id="impl-shared.GetNumEventCounters.0"/>GetNumEventCounters()
    return integer IMPLEMENTATION_DEFINED "Number of event counters";</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.HasElapsed64Cycles"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/HasElapsed64Cycles</h3>
      <p class="pseudocode">// Returns TRUE if 64 cycles have elapsed between the last count, and FALSE otherwise.
boolean <a id="impl-shared.HasElapsed64Cycles.0"/>HasElapsed64Cycles();</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.HiLoPMUOverflow"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/HiLoPMUOverflow</h3>
      <p class="pseudocode">// HiLoPMUOverflow()
// =================

boolean <a id="impl-shared.HiLoPMUOverflow.1"/>HiLoPMUOverflow(boolean resvd_for_el2)
    boolean check_cnten  = FALSE;
    boolean check_e      = FALSE;
    boolean check_inten  = FALSE;
    boolean include_lo   = !resvd_for_el2;
    boolean include_hi   = resvd_for_el2;
    boolean exclude_cyc  = FALSE;
    boolean exclude_sync = FALSE;

    boolean overflow = <a href="shared_pseudocode.html#impl-shared.PMUOverflowCondition.7" title="function: boolean PMUOverflowCondition(boolean check_e, boolean check_cnten,&#13; boolean check_inten,&#13; boolean include_hi, boolean include_lo,&#13; boolean exclude_cyc, boolean exclude_sync)">PMUOverflowCondition</a>(check_e, check_cnten, check_inten,
                                            include_hi, include_lo,
                                            exclude_cyc, exclude_sync);
    return overflow;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.INSTRUCTION_COUNTER_ID"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/INSTRUCTION_COUNTER_ID</h3>
      <p class="pseudocode">constant integer <a id="INSTRUCTION_COUNTER_ID"/>INSTRUCTION_COUNTER_ID = 32;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.IncrementInstructionCounter"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/IncrementInstructionCounter</h3>
      <p class="pseudocode">// IncrementInstructionCounter()
// =============================
// Increment the instruction counter and possibly set overflow bits.

<a id="impl-shared.IncrementInstructionCounter.1"/>IncrementInstructionCounter(integer increment)
    if <a href="shared_pseudocode.html#AArch64.CountPMUEvents.1" title="function: boolean AArch64.CountPMUEvents(integer idx)">AArch64.CountPMUEvents</a>(<a href="shared_pseudocode.html#INSTRUCTION_COUNTER_ID" title="constant integer INSTRUCTION_COUNTER_ID = 32">INSTRUCTION_COUNTER_ID</a>) then
        integer old_value = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMICNTR_EL0);
        integer new_value = old_value + increment;
        PMICNTR_EL0       = new_value&lt;63:0&gt;;

        // The effective value of PMCR_EL0.LP is '1' for the instruction counter
        if old_value&lt;64&gt; != new_value&lt;64&gt; then
            PMOVSSET_EL0.F0 = '1';
            PMOVSCLR_EL0.F0 = '1';</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUCountValue"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUCountValue</h3>
      <p class="pseudocode">// PMUCountValue()
// ===============
// Implements the PMU threshold function, if implemented.
// Returns the value to increment event counter 'n' by, if the event it is
// configured to count yields the value 'v' on this cycle.

integer <a id="impl-shared.PMUCountValue.2"/>PMUCountValue(integer n, integer v)
    if !<a href="shared_pseudocode.html#impl-shared.HavePMUv3TH.0" title="function: boolean HavePMUv3TH()">HavePMUv3TH</a>() then
        return v;

    integer T = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMEVTYPER_EL0[n].TH);

    case PMEVTYPER_EL0[n].TC of
        when '000' return (if v != T then v else 0);    // Disabled or not-equal
        when '001' return (if v != T then 1 else 0);    // Not-equal, count
        when '010' return (if v == T then v else 0);    // Equals
        when '011' return (if v == T then 1 else 0);    // Equals, count
        when '100' return (if v &gt;= T then v else 0);    // Greater-than-or-equal
        when '101' return (if v &gt;= T then 1 else 0);    // Greater-than-or-equal, count
        when '110' return (if v &lt;  T then v else 0);    // Less-than
        when '111' return (if v &lt;  T then 1 else 0);    // Less-than, count</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUCounterMask"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUCounterMask</h3>
      <p class="pseudocode">// PMUCounterMask()
// ================
// Return bitmask of accessible PMU counters.

bits(64) <a id="impl-shared.PMUCounterMask.0"/>PMUCounterMask()
    integer n;
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        n = <a href="shared_pseudocode.html#AArch32.GetNumEventCountersAccessible.0" title="function: integer AArch32.GetNumEventCountersAccessible()">AArch32.GetNumEventCountersAccessible</a>();
    else
        n = <a href="shared_pseudocode.html#AArch64.GetNumEventCountersAccessible.0" title="function: integer AArch64.GetNumEventCountersAccessible()">AArch64.GetNumEventCountersAccessible</a>();

    mask = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(n), 64);
    mask&lt;<a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>&gt; = '1';
    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3ICNTR.0" title="function: boolean HavePMUv3ICNTR()">HavePMUv3ICNTR</a>() then mask&lt;<a href="shared_pseudocode.html#INSTRUCTION_COUNTER_ID" title="constant integer INSTRUCTION_COUNTER_ID = 32">INSTRUCTION_COUNTER_ID</a>&gt; = '1';
    return mask;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUEvent</h3>
      <p class="pseudocode">// PMUEvent()
// ==========
// Generate a PMU event. By default, increment by 1.

<a id="impl-shared.PMUEvent.1"/>PMUEvent(bits(16) event)
    <a href="shared_pseudocode.html#impl-shared.PMUEvent.2" title="function: PMUEvent(bits(16) event, integer increment)">PMUEvent</a>(event, 1);

// PMUEvent()
// ==========
// Accumulate a PMU Event.

<a id="impl-shared.PMUEvent.2"/>PMUEvent(bits(16) event, integer increment)
    integer counters = <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            <a href="shared_pseudocode.html#impl-shared.PMUEvent.3" title="function: PMUEvent(bits(16) event, integer increment, integer idx)">PMUEvent</a>(event, increment, idx);

    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3ICNTR.0" title="function: boolean HavePMUv3ICNTR()">HavePMUv3ICNTR</a>() &amp;&amp; event == PMU_EVENT_INST_RETIRED then
        <a href="shared_pseudocode.html#impl-shared.IncrementInstructionCounter.1" title="function: IncrementInstructionCounter(integer increment)">IncrementInstructionCounter</a>(increment);

// PMUEvent()
// ==========
// Accumulate a PMU Event for a specific event counter.

<a id="impl-shared.PMUEvent.3"/>PMUEvent(bits(16) event, integer increment, integer idx)
    if !<a href="shared_pseudocode.html#impl-shared.HavePMUv3.0" title="function: boolean HavePMUv3()">HavePMUv3</a>() then
        return;

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        if PMEVTYPER[idx].evtCount == event then
            PMUEventAccumulator[idx] = PMUEventAccumulator[idx] + increment;
    else
        if PMEVTYPER_EL0[idx].evtCount == event then
            PMUEventAccumulator[idx] = PMUEventAccumulator[idx] + increment;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUOverflowCondition"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUOverflowCondition</h3>
      <p class="pseudocode">// PMUOverflowCondition()
// ======================
// Checks for PMU overflow under certain parameter conditions
// If 'check_e' is TRUE, then check the applicable one of PMCR_EL0.E and MDCR_EL2.HPME.
// If 'check_cnten' is TRUE, then check the applicable PMCNTENCLR_EL0 bit.
// If 'check_cnten' is TRUE, then check the applicable PMINTENCLR_EL1 bit.
// If 'include_lo' is TRUE, then check counters in the set [0..(HPMN-1)], CCNTR
//     and ICNTR, unless excluded by other flags.
// If 'include_hi' is TRUE, then check counters in the set [HPMN..(N-1)].
// If 'exclude_cyc' is TRUE, then CCNTR is NOT checked.
// If 'exclude_sync' is TRUE, then counters in synchronous mode are NOT checked.

boolean <a id="impl-shared.PMUOverflowCondition.7"/>PMUOverflowCondition(boolean check_e, boolean check_cnten,
                             boolean check_inten,
                             boolean include_hi, boolean include_lo,
                             boolean exclude_cyc, boolean exclude_sync)
    integer counters = <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>();

    bits(64) ovsf;

    if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        ovsf = PMOVSCLR_EL0;

        // Remove unimplemented counters - these fields are RES0
        ovsf&lt;63:33&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(31);

        if !<a href="shared_pseudocode.html#impl-shared.HavePMUv3ICNTR.0" title="function: boolean HavePMUv3ICNTR()">HavePMUv3ICNTR</a>() then
            ovsf&lt;<a href="shared_pseudocode.html#INSTRUCTION_COUNTER_ID" title="constant integer INSTRUCTION_COUNTER_ID = 32">INSTRUCTION_COUNTER_ID</a>&gt; = '0';
    else
        ovsf = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(PMOVSR, 64);

    if counters &lt; 31 then
        ovsf&lt;30:counters&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(31-counters);

    for idx = 0 to counters - 1
        boolean is_hyp;
        bit E;

        if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
            is_hyp = <a href="shared_pseudocode.html#AArch64.PMUCounterIsHyp.1" title="function: boolean AArch64.PMUCounterIsHyp(integer n)">AArch64.PMUCounterIsHyp</a>(idx);
            E = (if is_hyp then MDCR_EL2.HPME else PMCR_EL0.E);
        else
            is_hyp = <a href="shared_pseudocode.html#AArch32.PMUCounterIsHyp.1" title="function: boolean AArch32.PMUCounterIsHyp(integer n)">AArch32.PMUCounterIsHyp</a>(idx);
            E = (if is_hyp then HDCR.HPME else PMCR.E);

        if check_e then
            ovsf&lt;idx&gt; = ovsf&lt;idx&gt; AND E;

        if (!is_hyp &amp;&amp; !include_lo) || (is_hyp &amp;&amp; !include_hi) then
            ovsf&lt;idx&gt; = '0';

    // Cycle counter
    if exclude_cyc || !include_lo then
        ovsf&lt;<a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>&gt; = '0';

    if check_e then
        ovsf&lt;<a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>&gt; = ovsf&lt;<a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>&gt; AND PMCR_EL0.E;

    // Instruction counter
    if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HavePMUv3ICNTR.0" title="function: boolean HavePMUv3ICNTR()">HavePMUv3ICNTR</a>() then
        if !include_lo then
            ovsf&lt;<a href="shared_pseudocode.html#INSTRUCTION_COUNTER_ID" title="constant integer INSTRUCTION_COUNTER_ID = 32">INSTRUCTION_COUNTER_ID</a>&gt; = '0';
        if check_e then
            ovsf&lt;<a href="shared_pseudocode.html#INSTRUCTION_COUNTER_ID" title="constant integer INSTRUCTION_COUNTER_ID = 32">INSTRUCTION_COUNTER_ID</a>&gt; = ovsf&lt;<a href="shared_pseudocode.html#INSTRUCTION_COUNTER_ID" title="constant integer INSTRUCTION_COUNTER_ID = 32">INSTRUCTION_COUNTER_ID</a>&gt; AND PMCR_EL0.E;

    if check_cnten then
        bits(64) cnten = if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then PMCNTENCLR_EL0 else <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(PMCNTENCLR, 64);
        ovsf = ovsf AND cnten;

    if check_inten then
        bits(64) inten = if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then PMINTENCLR_EL1 else <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(PMINTENCLR, 64);
        ovsf = ovsf AND inten;

    return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ovsf);</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.integer"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/integer</h3>
      <p class="pseudocode">array integer PMUEventAccumulator[0..30];   // Accumulates PMU events for a cycle</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.CreatePCSample"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/CreatePCSample</h3>
      <p class="pseudocode">// CreatePCSample()
// ================

<a id="impl-shared.CreatePCSample.0"/>CreatePCSample()
    // In a simple sequential execution of the program, CreatePCSample is executed each time the PE
    // executes an instruction that can be sampled. An implementation is not constrained such that
    // reads of EDPCSRlo return the current values of PC, etc.

    pc_sample.valid = <a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugAllowed.0" title="function: boolean ExternalNoninvasiveDebugAllowed()">ExternalNoninvasiveDebugAllowed</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();
    pc_sample.pc = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
    pc_sample.el = PSTATE.EL;
    pc_sample.rw = if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then '0' else '1';
    pc_sample.ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    pc_sample.contextidr = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then CONTEXTIDR else CONTEXTIDR_EL1&lt;31:0&gt;;
    pc_sample.has_el2 = PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    if pc_sample.has_el2 then
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            pc_sample.vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR.VMID, 16);
        elsif !<a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()">Have16bitVMID</a>() || VTCR_EL2.VS == '0' then
            pc_sample.vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0&gt;, 16);
        else
            pc_sample.vmid = VTTBR_EL2.VMID;
        if (<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a href="shared_pseudocode.html#impl-shared.HaveV82Debug.0" title="function: boolean HaveV82Debug()">HaveV82Debug</a>()) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            pc_sample.contextidr_el2 = CONTEXTIDR_EL2&lt;31:0&gt;;
        else
            pc_sample.contextidr_el2 = bits(32) UNKNOWN;
        pc_sample.el0h = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.EDPCSRlo"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/EDPCSRlo</h3>
      <p class="pseudocode">// EDPCSRlo[] (read)
// =================

bits(32) <a id="impl-shared.EDPCSRlo.read.1"/>EDPCSRlo[boolean memory_mapped]

    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return bits(32) UNKNOWN;

    // The Software lock is OPTIONAL.
    update = !memory_mapped || EDLSR.SLK == '0';        // Software locked: no side-effects

    bits(32) sample;
    if pc_sample.valid then
        sample = pc_sample.pc&lt;31:0&gt;;
        if update then
            if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; EDSCR.SC2 == '1' then
                EDPCSRhi.PC = (if pc_sample.rw == '0' then <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24) else pc_sample.pc&lt;55:32&gt;);
                EDPCSRhi.EL = pc_sample.el;
                EDPCSRhi.NS = (if pc_sample.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then '0' else '1');
            else
                EDPCSRhi = (if pc_sample.rw == '0' then <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32) else pc_sample.pc&lt;63:32&gt;);
            EDCIDSR = pc_sample.contextidr;
            if (<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a href="shared_pseudocode.html#impl-shared.HaveV82Debug.0" title="function: boolean HaveV82Debug()">HaveV82Debug</a>()) &amp;&amp; EDSCR.SC2 == '1' then
                EDVIDSR = (if pc_sample.has_el2 then pc_sample.contextidr_el2
                           else bits(32) UNKNOWN);
            else
                EDVIDSR.VMID = (if pc_sample.has_el2 &amp;&amp; pc_sample.el IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>,<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>}
                                then pc_sample.vmid else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16));
                EDVIDSR.NS = (if pc_sample.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then '0' else '1');
                EDVIDSR.E2 = (if pc_sample.el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then '1' else '0');
                EDVIDSR.E3 = (if pc_sample.el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then '1' else '0') AND pc_sample.rw;
                // The conditions for setting HV are not specified if PCSRhi is zero.
                // An example implementation may be "pc_sample.rw".
                EDVIDSR.HV = (if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(EDPCSRhi) then '1' else bit IMPLEMENTATION_DEFINED "0 or 1");
    else
        sample = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(32);
        if update then
            EDPCSRhi = bits(32) UNKNOWN;
            EDCIDSR = bits(32) UNKNOWN;
            EDVIDSR = bits(32) UNKNOWN;

    return sample;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.PCSample"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/PCSample</h3>
      <p class="pseudocode">type <a id="PCSample"/>PCSample is (
    boolean valid,
    bits(64) pc,
    bits(2) el,
    bit rw,
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,
    boolean has_el2,
    bits(32) contextidr,
    bits(32) contextidr_el2,
    boolean el0h,
    bits(16) vmid
)

<a href="shared_pseudocode.html#PCSample" title="type PCSample is ( boolean valid, bits(64) pc, bits(2) el, bit rw, SecurityState ss, boolean has_el2, bits(32) contextidr, bits(32) contextidr_el2, boolean el0h, bits(16) vmid )">PCSample</a> pc_sample;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.PMPCSR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/PMPCSR</h3>
      <p class="pseudocode">// PMPCSR[] (read)
// ===============

bits(32) <a id="impl-shared.PMPCSR.read.1"/>PMPCSR[boolean memory_mapped]
    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return bits(32) UNKNOWN;

    // The Software lock is OPTIONAL.
    update = !memory_mapped || PMLSR.SLK == '0';        // Software locked: no side-effects

    bits(32) sample;
    if pc_sample.valid then
        sample = pc_sample.pc&lt;31:0&gt;;
        if update then
            PMPCSR&lt;55:32&gt; = (if pc_sample.rw == '0' then <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24) else pc_sample.pc&lt;55:32&gt;);
            PMPCSR.EL = pc_sample.el;
            if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
                case pc_sample.ss of
                    when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
                        PMPCSR.NSE = '0'; PMPCSR.NS = '0';
                    when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
                        PMPCSR.NSE = '0'; PMPCSR.NS = '1';
                    when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>
                        PMPCSR.NSE = '1'; PMPCSR.NS = '0';
                    when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
                        PMPCSR.NSE = '1'; PMPCSR.NS = '1';
            else
                PMPCSR.NS = (if pc_sample.ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then '0' else '1');

            PMCID1SR = pc_sample.contextidr;
            PMCID2SR = if pc_sample.has_el2 then pc_sample.contextidr_el2 else bits(32) UNKNOWN;

            PMVIDSR.VMID = (if pc_sample.has_el2 &amp;&amp; pc_sample.el IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>,<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>} &amp;&amp; !pc_sample.el0h
                            then pc_sample.vmid else bits(16) UNKNOWN);
    else
        sample = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(32);
        if update then
            PMPCSR&lt;55:32&gt;  = bits(24) UNKNOWN;
            PMPCSR.EL = bits(2) UNKNOWN;
            PMPCSR.NS = bit UNKNOWN;

            PMCID1SR = bits(32) UNKNOWN;
            PMCID2SR = bits(32) UNKNOWN;

            PMVIDSR.VMID = bits(16) UNKNOWN;

    return sample;</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.CheckSoftwareStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/CheckSoftwareStep</h3>
      <p class="pseudocode">// CheckSoftwareStep()
// ===================
// Take a Software Step exception if in the active-pending state

<a id="impl-shared.CheckSoftwareStep.0"/>CheckSoftwareStep()

    // Other self-hosted debug functions will call AArch32.GenerateDebugExceptions() if called from
    // AArch32 state. However, because Software Step is only active when the debug target Exception
    // level is using AArch64, CheckSoftwareStep only calls AArch64.GenerateDebugExceptions().
    step_enabled = !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.DebugTarget.0" title="function: bits(2) DebugTarget()">DebugTarget</a>()) &amp;&amp; <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()">AArch64.GenerateDebugExceptions</a>() &amp;&amp; MDSCR_EL1.SS == '1';
    if step_enabled &amp;&amp; PSTATE.SS == '0' then
        <a href="shared_pseudocode.html#AArch64.SoftwareStepException.0" title="function: AArch64.SoftwareStepException()">AArch64.SoftwareStepException</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.DebugExceptionReturnSS"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/DebugExceptionReturnSS</h3>
      <p class="pseudocode">// DebugExceptionReturnSS()
// ========================
// Returns value to write to PSTATE.SS on an exception return or Debug state exit.

bit <a id="impl-shared.DebugExceptionReturnSS.1"/>DebugExceptionReturnSS(bits(N) spsr)
    assert <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() || <a href="shared_pseudocode.html#impl-shared.Restarting.0" title="function: boolean Restarting()">Restarting</a>() ||  PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;

    boolean enabled_at_source;
    if <a href="shared_pseudocode.html#impl-shared.Restarting.0" title="function: boolean Restarting()">Restarting</a>() then
        enabled_at_source = FALSE;
    elsif <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        enabled_at_source = <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()">AArch32.GenerateDebugExceptions</a>();
    else
        enabled_at_source = <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()">AArch64.GenerateDebugExceptions</a>();

    boolean valid;
    bits(2) dest_el;
    if <a href="shared_pseudocode.html#impl-shared.IllegalExceptionReturn.1" title="function: boolean IllegalExceptionReturn(bits(N) spsr)">IllegalExceptionReturn</a>(spsr) then
        dest_el = PSTATE.EL;
    else
        (valid, dest_el) = <a href="shared_pseudocode.html#impl-shared.ELFromSPSR.1" title="function: (boolean,bits(2)) ELFromSPSR(bits(N) spsr)">ELFromSPSR</a>(spsr);  assert valid;

    dest_ss = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(dest_el);
    bit mask;
    boolean enabled_at_dest;
    dest_using_32 = (if dest_el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then spsr&lt;4&gt; == '1' else <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(dest_el));
    if dest_using_32 then
        enabled_at_dest = <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptionsFrom.2" title="function: boolean AArch32.GenerateDebugExceptionsFrom(bits(2) from_el, SecurityState from_state)">AArch32.GenerateDebugExceptionsFrom</a>(dest_el, dest_ss);
    else
        mask = spsr&lt;9&gt;;
        enabled_at_dest = <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from_el, SecurityState from_state, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(dest_el, dest_ss, mask);

    ELd = <a href="shared_pseudocode.html#impl-shared.DebugTargetFrom.1" title="function: bits(2) DebugTargetFrom(SecurityState from_state)">DebugTargetFrom</a>(dest_ss);
    bit SS_bit;
    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(ELd) &amp;&amp; MDSCR_EL1.SS == '1' &amp;&amp; !enabled_at_source &amp;&amp; enabled_at_dest then
        SS_bit = spsr&lt;21&gt;;
    else
        SS_bit = '0';

    return SS_bit;</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.SSAdvance"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/SSAdvance</h3>
      <p class="pseudocode">// SSAdvance()
// ===========
// Advance the Software Step state machine.

<a id="impl-shared.SSAdvance.0"/>SSAdvance()

    // A simpler implementation of this function just clears PSTATE.SS to zero regardless of the
    // current Software Step state machine. However, this check is made to illustrate that the
    // processor only needs to consider advancing the state machine from the active-not-pending
    // state.
    target = <a href="shared_pseudocode.html#impl-shared.DebugTarget.0" title="function: bits(2) DebugTarget()">DebugTarget</a>();
    step_enabled = !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target) &amp;&amp; MDSCR_EL1.SS == '1';
    active_not_pending = step_enabled &amp;&amp; PSTATE.SS == '1';

    if active_not_pending then PSTATE.SS = '0';

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.SoftwareStep_DidNotStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/SoftwareStep_DidNotStep</h3>
      <p class="pseudocode">// Returns TRUE if the previously executed instruction was executed in the
// inactive state, that is, if it was not itself stepped.
// Might return TRUE or FALSE if the previously executed instruction was an ISB
// or ERET executed in the active-not-pending state, or if another exception
// was taken before the Software Step exception.  Returns FALSE otherwise,
// indicating that the previously executed instruction was executed in the
// active-not-pending state, that is, the instruction was stepped.
boolean <a id="impl-shared.SoftwareStep_DidNotStep.0"/>SoftwareStep_DidNotStep();</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.SoftwareStep_SteppedEX"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/SoftwareStep_SteppedEX</h3>
      <p class="pseudocode">// Returns a value that describes the previously executed instruction. The
// result is valid only if SoftwareStep_DidNotStep() returns FALSE.
// Might return TRUE or FALSE if the instruction was an AArch32 LDREX or LDAEX
// that failed its condition code test.  Otherwise returns TRUE if the
// instruction was a Load-Exclusive class instruction, and FALSE if the
// instruction was not a Load-Exclusive class instruction.
boolean <a id="impl-shared.SoftwareStep_SteppedEX.0"/>SoftwareStep_SteppedEX();</p>
    </div>
    <div class="ps"><a id="shared.exceptions.exceptions.ConditionSyndrome"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/exceptions/ConditionSyndrome</h3>
      <p class="pseudocode">// ConditionSyndrome()
// ===================
// Return CV and COND fields of instruction syndrome

bits(5) <a id="impl-shared.ConditionSyndrome.0"/>ConditionSyndrome()

    bits(5) syndrome;

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        cond = <a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>();
        if PSTATE.T == '0' then             // A32
            syndrome&lt;4&gt; = '1';
            // A conditional A32 instruction that is known to pass its condition code check
            // can be presented either with COND set to 0xE, the value for unconditional, or
            // the COND value held in the instruction.
            if <a href="shared_pseudocode.html#impl-shared.ConditionHolds.1" title="function: boolean ConditionHolds(bits(4) cond)">ConditionHolds</a>(cond) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ESRCONDPASS" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_ESRCONDPASS</a>) then
                syndrome&lt;3:0&gt; = '1110';
            else
                syndrome&lt;3:0&gt; = cond;
        else                                // T32
            // When a T32 instruction is trapped, it is IMPLEMENTATION DEFINED whether:
            //  * CV set to 0 and COND is set to an UNKNOWN value
            //  * CV set to 1 and COND is set to the condition code for the condition that
            //    applied to the instruction.
            if boolean IMPLEMENTATION_DEFINED "Condition valid for trapped T32" then
                syndrome&lt;4&gt; = '1';
                syndrome&lt;3:0&gt; = cond;
            else
                syndrome&lt;4&gt; = '0';
                syndrome&lt;3:0&gt; = bits(4) UNKNOWN;
    else
        syndrome&lt;4&gt; = '1';
        syndrome&lt;3:0&gt; = '1110';

    return syndrome;</p>
    </div>
    <div class="ps"><a id="shared.exceptions.exceptions.Exception"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/exceptions/Exception</h3>
      <p class="pseudocode">enumeration <a id="Exception"/>Exception {<a id="Exception_Uncategorized"/>Exception_Uncategorized,       // Uncategorized or unknown reason
                       <a id="Exception_WFxTrap"/>Exception_WFxTrap,             // Trapped WFI or WFE instruction
                       <a id="Exception_CP15RTTrap"/>Exception_CP15RTTrap,          // Trapped AArch32 MCR or MRC access, coproc=0b1111
                       <a id="Exception_CP15RRTTrap"/>Exception_CP15RRTTrap,         // Trapped AArch32 MCRR or MRRC access, coproc=0b1111
                       <a id="Exception_CP14RTTrap"/>Exception_CP14RTTrap,          // Trapped AArch32 MCR or MRC access, coproc=0b1110
                       <a id="Exception_CP14DTTrap"/>Exception_CP14DTTrap,          // Trapped AArch32 LDC or STC access, coproc=0b1110
                       <a id="Exception_CP14RRTTrap"/>Exception_CP14RRTTrap,         // Trapped AArch32 MRRC access, coproc=0b1110
                       <a id="Exception_AdvSIMDFPAccessTrap"/>Exception_AdvSIMDFPAccessTrap, // HCPTR-trapped access to SIMD or FP
                       <a id="Exception_FPIDTrap"/>Exception_FPIDTrap,            // Trapped access to SIMD or FP ID register
                       <a id="Exception_LDST64BTrap"/>Exception_LDST64BTrap,         // Trapped access to ST64BV, ST64BV0, ST64B and LD64B
                       // Trapped BXJ instruction not supported in Armv8
                       <a id="Exception_PACTrap"/>Exception_PACTrap,             // Trapped invalid PAC use
                       <a id="Exception_IllegalState"/>Exception_IllegalState,        // Illegal Execution state
                       <a id="Exception_SupervisorCall"/>Exception_SupervisorCall,      // Supervisor Call
                       <a id="Exception_HypervisorCall"/>Exception_HypervisorCall,      // Hypervisor Call
                       <a id="Exception_MonitorCall"/>Exception_MonitorCall,         // Monitor Call or Trapped SMC instruction
                       <a id="Exception_SystemRegisterTrap"/>Exception_SystemRegisterTrap,  // Trapped MRS or MSR System register access
                       <a id="Exception_ERetTrap"/>Exception_ERetTrap,            // Trapped invalid ERET use
                       <a id="Exception_InstructionAbort"/>Exception_InstructionAbort,    // Instruction Abort or Prefetch Abort
                       <a id="Exception_PCAlignment"/>Exception_PCAlignment,         // PC alignment fault
                       <a id="Exception_DataAbort"/>Exception_DataAbort,           // Data Abort
                       <a id="Exception_NV2DataAbort"/>Exception_NV2DataAbort,        // Data abort at EL1 reported as being from EL2
                       <a id="Exception_PACFail"/>Exception_PACFail,             // PAC Authentication failure
                       <a id="Exception_SPAlignment"/>Exception_SPAlignment,         // SP alignment fault
                       <a id="Exception_FPTrappedException"/>Exception_FPTrappedException,  // IEEE trapped FP exception
                       <a id="Exception_SError"/>Exception_SError,              // SError interrupt
                       <a id="Exception_Breakpoint"/>Exception_Breakpoint,          // (Hardware) Breakpoint
                       <a id="Exception_SoftwareStep"/>Exception_SoftwareStep,        // Software Step
                       <a id="Exception_Watchpoint"/>Exception_Watchpoint,          // Watchpoint
                       <a id="Exception_NV2Watchpoint"/>Exception_NV2Watchpoint,       // Watchpoint at EL1 reported as being from EL2
                       <a id="Exception_SoftwareBreakpoint"/>Exception_SoftwareBreakpoint,  // Software Breakpoint Instruction
                       <a id="Exception_VectorCatch"/>Exception_VectorCatch,         // AArch32 Vector Catch
                       <a id="Exception_IRQ"/>Exception_IRQ,                 // IRQ interrupt
                       <a id="Exception_SVEAccessTrap"/>Exception_SVEAccessTrap,       // HCPTR trapped access to SVE
                       <a id="Exception_SMEAccessTrap"/>Exception_SMEAccessTrap,       // HCPTR trapped access to SME
                       <a id="Exception_TSTARTAccessTrap"/>Exception_TSTARTAccessTrap,    // Trapped TSTART access
                       <a id="Exception_GPC"/>Exception_GPC,                 // Granule protection check
                       <a id="Exception_BranchTarget"/>Exception_BranchTarget,        // Branch Target Identification
                       <a id="Exception_MemCpyMemSet"/>Exception_MemCpyMemSet,        // Exception from a CPY* or SET* instruction
                       <a id="Exception_FIQ"/>Exception_FIQ};                // FIQ interrupt</p>
    </div>
    <div class="ps"><a id="shared.exceptions.exceptions.ExceptionRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/exceptions/ExceptionRecord</h3>
      <p class="pseudocode">type <a id="ExceptionRecord"/>ExceptionRecord is (
    <a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a>   exceptype,           // Exception class
    bits(25)    syndrome,            // Syndrome record
    bits(24)    syndrome2,           // Syndrome record
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> paddress,            // Physical fault address
    bits(64)    vaddress,            // Virtual fault address
    boolean     ipavalid,            // Validity of Intermediate Physical fault address
    bit         NS,                  // Intermediate Physical fault address space
    bits(56)    ipaddress,           // Intermediate Physical fault address
    boolean     trappedsyscallinst)  // Trapped SVC or SMC instruction</p>
    </div>
    <div class="ps"><a id="shared.exceptions.exceptions.ExceptionSyndrome"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/exceptions/ExceptionSyndrome</h3>
      <p class="pseudocode">// ExceptionSyndrome()
// ===================
// Return a blank exception syndrome record for an exception of the given type.

ExceptionRecord <a id="impl-shared.ExceptionSyndrome.1"/>ExceptionSyndrome(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype)

    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(24) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(56) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> r;

    r.exceptype = exceptype;

    // Initialize all other fields
    r.syndrome  = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(25);
    r.syndrome2 = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24);
    r.vaddress  = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    r.ipavalid  = FALSE;
    r.NS        = '0';
    r.ipaddress = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(56);
    r.paddress.paspace = <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> UNKNOWN;
    r.paddress.address = bits(56) UNKNOWN;
    r.trappedsyscallinst = FALSE;
    return r;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.EncodeLDFSC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/EncodeLDFSC</h3>
      <p class="pseudocode">// EncodeLDFSC()
// =============
// Function that gives the Long-descriptor FSC code for types of Fault

bits(6) <a id="impl-shared.EncodeLDFSC.2"/>EncodeLDFSC(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode, integer level)
    bits(6) result;

    // 128-bit descriptors will start from level -2 for 4KB to resolve bits IA[55:51]
    if level == -2 then
        assert <a href="shared_pseudocode.html#impl-shared.Have56BitPAExt.0" title="function: boolean Have56BitPAExt()">Have56BitPAExt</a>();
        case statuscode of
            when <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>          result = '101100';
            when <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>          result = '101010';
            when <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>   result = '010010';
            when <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>     result = '011010'; assert !<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>();
            when <a href="shared_pseudocode.html#Fault_GPCFOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnWalk</a>           result = '100010';
            otherwise                       <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
        return result;

    if level == -1 then
        assert <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>();
        case statuscode of
            when <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>          result = '101001';
            when <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>          result = '101011';
            when <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>   result = '010011';
            when <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>     result = '011011'; assert !<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>();
            when <a href="shared_pseudocode.html#Fault_GPCFOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnWalk</a>           result = '100011';
            otherwise                       <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

        return result;
    case statuscode of
        when <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>         result = '0000':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>          result = '0010':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>          result = '0011':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>         result = '0001':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>        result = '010000';
        when <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>  result = '0101':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>          result = '011000';
        when <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>    result = '0111':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>         result = '011001';
        when <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>       result = '010001'; assert <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
        when <a href="shared_pseudocode.html#Fault_TagCheck" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_TagCheck</a>            result = '010001'; assert <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>();
        when <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>           result = '100001';
        when <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>               result = '100010';
        when <a href="shared_pseudocode.html#Fault_GPCFOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnWalk</a>          result = '1001':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>        result = '101000';
        when <a href="shared_pseudocode.html#Fault_TLBConflict" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_TLBConflict</a>         result = '110000';
        when <a href="shared_pseudocode.html#Fault_HWUpdateAccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_HWUpdateAccessFlag</a>  result = '110001';
        when <a href="shared_pseudocode.html#Fault_Lockdown" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Lockdown</a>            result = '110100';  // IMPLEMENTATION DEFINED
        when <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>           result = '110101';  // IMPLEMENTATION DEFINED
        otherwise                      <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IPAValid"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IPAValid</h3>
      <p class="pseudocode">// IPAValid()
// ==========
// Return TRUE if the IPA is reported for the abort

boolean <a id="impl-shared.IPAValid.1"/>IPAValid(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    assert fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
        return fault.secondstage;
    elsif fault.s2fs1walk then
        return fault.statuscode IN {
            <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>,
            <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>,
            <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>,
            <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>
        };
    elsif fault.secondstage then
        return fault.statuscode IN {
            <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>,
            <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>,
            <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>
        };
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsAsyncAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsAsyncAbort</h3>
      <p class="pseudocode">// IsAsyncAbort()
// ==============
// Returns TRUE if the abort currently being processed is an asynchronous abort, and FALSE
// otherwise.

boolean <a id="impl-shared.IsAsyncAbort.1"/>IsAsyncAbort(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode)
    assert statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return (statuscode IN {<a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>, <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>});

// IsAsyncAbort()
// ==============

boolean <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    return <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault.statuscode);</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsDebugException"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsDebugException</h3>
      <p class="pseudocode">// IsDebugException()
// ==================

boolean <a id="impl-shared.IsDebugException.1"/>IsDebugException(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    assert fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    return fault.statuscode == <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsExternalAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsExternalAbort</h3>
      <p class="pseudocode">// IsExternalAbort()
// =================
// Returns TRUE if the abort currently being processed is an External abort and FALSE otherwise.

boolean <a id="impl-shared.IsExternalAbort.1"/>IsExternalAbort(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode)
    assert statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return (statuscode IN {
        <a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>,
        <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>,
        <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>,
        <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>,
        <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>,
        <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>
    });

// IsExternalAbort()
// =================

boolean <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    return <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault.statuscode) || fault.gpcf.gpf == <a href="shared_pseudocode.html#GPCF_EABT" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_EABT</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsExternalSyncAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsExternalSyncAbort</h3>
      <p class="pseudocode">// IsExternalSyncAbort()
// =====================
// Returns TRUE if the abort currently being processed is an external
// synchronous abort and FALSE otherwise.

boolean <a id="impl-shared.IsExternalSyncAbort.1"/>IsExternalSyncAbort(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode)
    assert statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return (statuscode IN {
        <a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>,
        <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>,
        <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>,
        <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>
    });

// IsExternalSyncAbort()
// =====================

boolean <a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    return <a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault.statuscode) || fault.gpcf.gpf == <a href="shared_pseudocode.html#GPCF_EABT" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_EABT</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsFault"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsFault</h3>
      <p class="pseudocode">// IsFault()
// =========
// Return TRUE if a fault is associated with an address descriptor

boolean <a id="impl-shared.IsFault.1"/>IsFault(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> addrdesc)
    return addrdesc.fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

// IsFault()
// =========
// Return TRUE if a fault is associated with a memory access.

boolean <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> fault)
    return fault != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

// IsFault()
// =========
// Return TRUE if a fault is associated with status returned by memory.

boolean <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> retstatus)
    return retstatus.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsSErrorInterrupt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsSErrorInterrupt</h3>
      <p class="pseudocode">// IsSErrorInterrupt()
// ===================
// Returns TRUE if the abort currently being processed is an SError interrupt, and FALSE
// otherwise.

boolean <a id="impl-shared.IsSErrorInterrupt.1"/>IsSErrorInterrupt(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode)
    assert statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return (statuscode IN {<a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>, <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>});

// IsSErrorInterrupt()
// ===================

boolean <a href="shared_pseudocode.html#impl-shared.IsSErrorInterrupt.1" title="function: boolean IsSErrorInterrupt(Fault statuscode)">IsSErrorInterrupt</a>(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    return <a href="shared_pseudocode.html#impl-shared.IsSErrorInterrupt.1" title="function: boolean IsSErrorInterrupt(Fault statuscode)">IsSErrorInterrupt</a>(fault.statuscode);</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsSecondStage"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsSecondStage</h3>
      <p class="pseudocode">// IsSecondStage()
// ===============

boolean <a id="impl-shared.IsSecondStage.1"/>IsSecondStage(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    assert fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return fault.secondstage;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.LSInstructionSyndrome"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/LSInstructionSyndrome</h3>
      <p class="pseudocode">// Returns the extended syndrome information for a second stage fault.
//  &lt;10&gt;  - Syndrome valid bit. The syndrome is valid only for certain types of access instruction.
//  &lt;9:8&gt; - Access size.
//  &lt;7&gt;   - Sign extended (for loads).
//  &lt;6:2&gt; - Transfer register.
//  &lt;1&gt;   - Transfer register is 64-bit.
//  &lt;0&gt;   - Instruction has acquire/release semantics.
bits(11) <a id="impl-shared.LSInstructionSyndrome.0"/>LSInstructionSyndrome();</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.ReportAsGPCException"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/ReportAsGPCException</h3>
      <p class="pseudocode">// ReportAsGPCException()
// ======================
// Determine whether the given GPCF is reported as a Granule Protection Check Exception
// rather than a Data or Instruction Abort

boolean <a id="impl-shared.ReportAsGPCException.1"/>ReportAsGPCException(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    assert <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>();
    assert fault.statuscode IN {<a href="shared_pseudocode.html#Fault_GPCFOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnWalk</a>, <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>};
    assert fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a>;

    case fault.gpcf.gpf of
        when <a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>        return TRUE;
        when <a href="shared_pseudocode.html#GPCF_AddressSize" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_AddressSize</a> return TRUE;
        when <a href="shared_pseudocode.html#GPCF_EABT" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_EABT</a>        return TRUE;
        when <a href="shared_pseudocode.html#GPCF_Fail" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Fail</a>        return SCR_EL3.GPF == '1' &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CACHE_OP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CACHE_OP</h3>
      <p class="pseudocode">// CACHE_OP()
// ==========
// Performs Cache maintenance operations as per CacheRecord.

<a id="impl-shared.CACHE_OP.1"/>CACHE_OP(<a href="shared_pseudocode.html#CacheRecord" title="type CacheRecord is ( AccessType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache)
    IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CPASAtPAS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CPASAtPAS</h3>
      <p class="pseudocode">// CPASAtPAS()
// ===========
// Get cache PA space for given PA space.

CachePASpace <a id="impl-shared.CPASAtPAS.1"/>CPASAtPAS(<a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> pas)
    case pas of
        when <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>
            return <a href="shared_pseudocode.html#CPAS_NonSecure" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any,  CPAS_RealmNonSecure,  CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure,  CPAS_Secure&#13; }">CPAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>
            return <a href="shared_pseudocode.html#CPAS_Secure" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any,  CPAS_RealmNonSecure,  CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure,  CPAS_Secure&#13; }">CPAS_Secure</a>;
        when <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>
            return <a href="shared_pseudocode.html#CPAS_Root" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any,  CPAS_RealmNonSecure,  CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure,  CPAS_Secure&#13; }">CPAS_Root</a>;
        when <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>
            return <a href="shared_pseudocode.html#CPAS_Realm" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any,  CPAS_RealmNonSecure,  CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure,  CPAS_Secure&#13; }">CPAS_Realm</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CPASAtSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CPASAtSecurityState</h3>
      <p class="pseudocode">// CPASAtSecurityState()
// =====================
// Get cache PA space for given security state.

CachePASpace <a id="impl-shared.CPASAtSecurityState.1"/>CPASAtSecurityState(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    case ss of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            return <a href="shared_pseudocode.html#CPAS_NonSecure" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any,  CPAS_RealmNonSecure,  CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure,  CPAS_Secure&#13; }">CPAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
            return <a href="shared_pseudocode.html#CPAS_SecureNonSecure" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any,  CPAS_RealmNonSecure,  CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure,  CPAS_Secure&#13; }">CPAS_SecureNonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>
            return <a href="shared_pseudocode.html#CPAS_Any" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any,  CPAS_RealmNonSecure,  CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure,  CPAS_Secure&#13; }">CPAS_Any</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
            return <a href="shared_pseudocode.html#CPAS_RealmNonSecure" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any,  CPAS_RealmNonSecure,  CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure,  CPAS_Secure&#13; }">CPAS_RealmNonSecure</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CacheRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CacheRecord</h3>
      <p class="pseudocode">type <a id="CacheRecord"/>CacheRecord is (
    <a href="shared_pseudocode.html#AccessType" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType</a>       acctype,           // Access type
    <a href="shared_pseudocode.html#CacheOp" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp</a>          cacheop,           // Cache operation
    <a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a>     opscope,           // Cache operation type
    <a href="shared_pseudocode.html#CacheType" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a>        cachetype,         // Cache type
    bits(64)         regval,
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a>      paddress,
    bits(64)         vaddress,          // For VA operations
    integer          set,               // For SW operations
    integer          way,               // For SW operations
    integer          level,             // For SW operations
    <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a>     shareability,
    boolean          translated,
    boolean          is_vmid_valid,     // is vmid valid for current context
    bits(16)         vmid,
    boolean          is_asid_valid,     // is asid valid for current context
    bits(16)         asid,
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a>    security,
    // For cache operations to full cache or by set/way
    // For operations by address, PA space in paddress
    <a href="shared_pseudocode.html#CachePASpace" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any,  CPAS_RealmNonSecure,  CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure,  CPAS_Secure&#13; }">CachePASpace</a>     cpas
)</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.DCInstNeedsTranslation"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/DCInstNeedsTranslation</h3>
      <p class="pseudocode">// DCInstNeedsTranslation()
// ========================
// Check whether Data Cache operation needs translation.

boolean <a id="impl-shared.DCInstNeedsTranslation.1"/>DCInstNeedsTranslation(<a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    if CLIDR_EL1.LoC == '000' then
        return !boolean IMPLEMENTATION_DEFINED "No fault generated for DC operations if PoC is before any level of cache";

    if CLIDR_EL1.LoUU == '000' &amp;&amp; opscope == <a href="shared_pseudocode.html#CacheOpScope_PoU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoU</a> then
        return !boolean IMPLEMENTATION_DEFINED "No fault generated for DC operations if PoU is before any level of cache";

    return TRUE;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.DecodeSW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/DecodeSW</h3>
      <p class="pseudocode">// DecodeSW()
// ==========
// Decode input value into set, way and level for SW instructions.

(integer, integer, integer) <a id="impl-shared.DecodeSW.2"/>DecodeSW(bits(64) regval, <a href="shared_pseudocode.html#CacheType" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype)
    level = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(regval[3:1]);
    (set, way, linesize) = <a href="shared_pseudocode.html#impl-shared.GetCacheInfo.2" title="function: (integer, integer, integer) GetCacheInfo(integer level, CacheType cachetype)">GetCacheInfo</a>(level, cachetype);
    return (set, way, level);</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.GetCacheInfo"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/GetCacheInfo</h3>
      <p class="pseudocode">// Returns numsets, assosciativity &amp; linesize.
(integer, integer, integer) <a id="impl-shared.GetCacheInfo.2"/>GetCacheInfo(integer level, <a href="shared_pseudocode.html#CacheType" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype);</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.ICInstNeedsTranslation"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/ICInstNeedsTranslation</h3>
      <p class="pseudocode">// ICInstNeedsTranslation()
// ========================
// Check whether Instruction Cache operation needs translation.

boolean <a id="impl-shared.ICInstNeedsTranslation.1"/>ICInstNeedsTranslation(<a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    return boolean IMPLEMENTATION_DEFINED "Instruction Cache needs translation";</p>
    </div>
    <div class="ps"><a id="shared.functions.common.ASR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/ASR</h3>
      <p class="pseudocode">// ASR()
// =====

bits(N) <a id="impl-shared.ASR.2"/>ASR(bits(N) x, integer shift)
    assert shift &gt;= 0;
    bits(N) result;
    if shift == 0 then
        result = x;
    else
        (result, -) = <a href="shared_pseudocode.html#impl-shared.ASR_C.2" title="function: (bits(N), bit) ASR_C(bits(N) x, integer shift)">ASR_C</a>(x, shift);
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.ASR_C"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/ASR_C</h3>
      <p class="pseudocode">// ASR_C()
// =======

(bits(N), bit) <a id="impl-shared.ASR_C.2"/>ASR_C(bits(N) x, integer shift)
    assert shift &gt; 0 &amp;&amp; shift &lt; 256;
    extended_x = <a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(x, shift+N);
    result = extended_x&lt;shift+N-1:shift&gt;;
    carry_out = extended_x&lt;shift-1&gt;;
    return (result, carry_out);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Abs"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Abs</h3>
      <p class="pseudocode">// Abs()
// =====

integer <a id="impl-shared.Abs.1"/>Abs(integer x)
    return if x &gt;= 0 then x else -x;

// Abs()
// =====

real <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(real x)
    return if x &gt;= 0.0 then x else -x;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Align"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Align</h3>
      <p class="pseudocode">// Align()
// =======

integer <a id="impl-shared.Align.2"/>Align(integer x, integer y)
    return y * (x DIV y);

// Align()
// =======

bits(N) <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(bits(N) x, integer y)
    return <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(x), y)&lt;N-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.BitCount"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/BitCount</h3>
      <p class="pseudocode">// BitCount()
// ==========

integer <a id="impl-shared.BitCount.1"/>BitCount(bits(N) x)
    integer result = 0;
    for i = 0 to N-1
        if x&lt;i&gt; == '1' then
            result = result + 1;
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.CountLeadingSignBits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/CountLeadingSignBits</h3>
      <p class="pseudocode">// CountLeadingSignBits()
// ======================

integer <a id="impl-shared.CountLeadingSignBits.1"/>CountLeadingSignBits(bits(N) x)
    return <a href="shared_pseudocode.html#impl-shared.CountLeadingZeroBits.1" title="function: integer CountLeadingZeroBits(bits(N) x)">CountLeadingZeroBits</a>(x&lt;N-1:1&gt; EOR x&lt;N-2:0&gt;);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.CountLeadingZeroBits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/CountLeadingZeroBits</h3>
      <p class="pseudocode">// CountLeadingZeroBits()
// ======================

integer <a id="impl-shared.CountLeadingZeroBits.1"/>CountLeadingZeroBits(bits(N) x)
    return N - (<a href="shared_pseudocode.html#impl-shared.HighestSetBit.1" title="function: integer HighestSetBit(bits(N) x)">HighestSetBit</a>(x) + 1);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Elem"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Elem</h3>
      <p class="pseudocode">// Elem[] - non-assignment form
// ============================

bits(size) <a id="impl-shared.Elem.read.3"/>Elem[bits(N) vector, integer e, integer size]
    assert e &gt;= 0 &amp;&amp; (e+1)*size &lt;= N;
    return vector&lt;e*size+size-1 : e*size&gt;;

// Elem[] - assignment form
// ========================

<a id="impl-shared.Elem.write.3"/>Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value
    assert e &gt;= 0 &amp;&amp; (e+1)*size &lt;= N;
    vector&lt;(e+1)*size-1:e*size&gt; = value;
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Extend"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Extend</h3>
      <p class="pseudocode">// Extend()
// ========

bits(N) <a id="impl-shared.Extend.3"/>Extend(bits(M) x, integer N, boolean unsigned)
    return if unsigned then <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(x, N) else <a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(x, N);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.HighestSetBit"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/HighestSetBit</h3>
      <p class="pseudocode">// HighestSetBit()
// ===============

integer <a id="impl-shared.HighestSetBit.1"/>HighestSetBit(bits(N) x)
    for i = N-1 downto 0
        if x&lt;i&gt; == '1' then return i;
    return -1;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Int"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Int</h3>
      <p class="pseudocode">// Int()
// =====

integer <a id="impl-shared.Int.2"/>Int(bits(N) x, boolean unsigned)
    result = if unsigned then <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(x) else <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(x);
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.IsAligned"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/IsAligned</h3>
      <p class="pseudocode">// IsAligned()
// ===========

boolean <a id="impl-shared.IsAligned.2"/>IsAligned(integer x, integer y)
    return x == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(x, y);

// IsAligned()
// ===========

boolean <a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(integer x, integer y)">IsAligned</a>(bits(N) x, integer y)
    return x == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(x, y);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.IsOnes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/IsOnes</h3>
      <p class="pseudocode">// IsOnes()
// ========

boolean <a id="impl-shared.IsOnes.1"/>IsOnes(bits(N) x)
    return x == <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(N);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.IsZero"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/IsZero</h3>
      <p class="pseudocode">// IsZero()
// ========

boolean <a id="impl-shared.IsZero.1"/>IsZero(bits(N) x)
    return x == <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.IsZeroBit"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/IsZeroBit</h3>
      <p class="pseudocode">// IsZeroBit()
// ===========

bit <a id="impl-shared.IsZeroBit.1"/>IsZeroBit(bits(N) x)
    return if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(x) then '1' else '0';</p>
    </div>
    <div class="ps"><a id="shared.functions.common.LSL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/LSL</h3>
      <p class="pseudocode">// LSL()
// =====

bits(N) <a id="impl-shared.LSL.2"/>LSL(bits(N) x, integer shift)
    assert shift &gt;= 0;
    bits(N) result;
    if shift == 0 then
        result = x;
    else
        (result, -) = <a href="shared_pseudocode.html#impl-shared.LSL_C.2" title="function: (bits(N), bit) LSL_C(bits(N) x, integer shift)">LSL_C</a>(x, shift);
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.LSL_C"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/LSL_C</h3>
      <p class="pseudocode">// LSL_C()
// =======

(bits(N), bit) <a id="impl-shared.LSL_C.2"/>LSL_C(bits(N) x, integer shift)
    assert shift &gt; 0 &amp;&amp; shift &lt; 256;
    extended_x = x : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(shift);
    result = extended_x&lt;N-1:0&gt;;
    carry_out = extended_x&lt;N&gt;;
    return (result, carry_out);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.LSR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/LSR</h3>
      <p class="pseudocode">// LSR()
// =====

bits(N) <a id="impl-shared.LSR.2"/>LSR(bits(N) x, integer shift)
    assert shift &gt;= 0;
    bits(N) result;
    if shift == 0 then
        result = x;
    else
        (result, -) = <a href="shared_pseudocode.html#impl-shared.LSR_C.2" title="function: (bits(N), bit) LSR_C(bits(N) x, integer shift)">LSR_C</a>(x, shift);
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.LSR_C"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/LSR_C</h3>
      <p class="pseudocode">// LSR_C()
// =======

(bits(N), bit) <a id="impl-shared.LSR_C.2"/>LSR_C(bits(N) x, integer shift)
    assert shift &gt; 0 &amp;&amp; shift &lt; 256;
    extended_x = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(x, shift+N);
    result = extended_x&lt;shift+N-1:shift&gt;;
    carry_out = extended_x&lt;shift-1&gt;;
    return (result, carry_out);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.LowestSetBit"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/LowestSetBit</h3>
      <p class="pseudocode">// LowestSetBit()
// ==============

integer <a id="impl-shared.LowestSetBit.1"/>LowestSetBit(bits(N) x)
    for i = 0 to N-1
        if x&lt;i&gt; == '1' then return i;
    return N;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Max"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Max</h3>
      <p class="pseudocode">// Max()
// =====

integer <a id="impl-shared.Max.2"/>Max(integer a, integer b)
    return if a &gt;= b then a else b;

// Max()
// =====

real <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>(real a, real b)
    return if a &gt;= b then a else b;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Min"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Min</h3>
      <p class="pseudocode">// Min()
// =====

integer <a id="impl-shared.Min.2"/>Min(integer a, integer b)
    return if a &lt;= b then a else b;

// Min()
// =====

real <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(real a, real b)
    return if a &lt;= b then a else b;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Ones"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Ones</h3>
      <p class="pseudocode">// Ones()
// ======

bits(N) <a id="impl-shared.Ones.1"/>Ones(integer N)
    return <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>('1',N);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.ROR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/ROR</h3>
      <p class="pseudocode">// ROR()
// =====

bits(N) <a id="impl-shared.ROR.2"/>ROR(bits(N) x, integer shift)
    assert shift &gt;= 0;
    bits(N) result;
    if shift == 0 then
        result = x;
    else
        (result, -) = <a href="shared_pseudocode.html#impl-shared.ROR_C.2" title="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)">ROR_C</a>(x, shift);
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.ROR_C"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/ROR_C</h3>
      <p class="pseudocode">// ROR_C()
// =======

(bits(N), bit) <a id="impl-shared.ROR_C.2"/>ROR_C(bits(N) x, integer shift)
    assert shift != 0 &amp;&amp; shift &lt; 256;
    m = shift MOD N;
    result = <a href="shared_pseudocode.html#impl-shared.LSR.2" title="function: bits(N) LSR(bits(N) x, integer shift)">LSR</a>(x,m) OR <a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(x,N-m);
    carry_out = result&lt;N-1&gt;;
    return (result, carry_out);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Replicate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Replicate</h3>
      <p class="pseudocode">bits(M*N) <a id="impl-shared.Replicate.2"/>Replicate(bits(M) x, integer N);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.RoundDown"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/RoundDown</h3>
      <p class="pseudocode">integer <a id="impl-shared.RoundDown.1"/>RoundDown(real x);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.RoundTowardsZero"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/RoundTowardsZero</h3>
      <p class="pseudocode">// RoundTowardsZero()
// ==================

integer <a id="impl-shared.RoundTowardsZero.1"/>RoundTowardsZero(real x)
    return if x == 0.0 then 0 else if x &gt;= 0.0 then <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(x) else <a href="shared_pseudocode.html#impl-shared.RoundUp.1" title="function: integer RoundUp(real x)">RoundUp</a>(x);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.RoundUp"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/RoundUp</h3>
      <p class="pseudocode">integer <a id="impl-shared.RoundUp.1"/>RoundUp(real x);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.SInt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/SInt</h3>
      <p class="pseudocode">// SInt()
// ======

integer <a id="impl-shared.SInt.1"/>SInt(bits(N) x)
    result = 0;
    for i = 0 to N-1
        if x&lt;i&gt; == '1' then result = result + 2^i;
    if x&lt;N-1&gt; == '1' then result = result - 2^N;
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.SignExtend"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/SignExtend</h3>
      <p class="pseudocode">// SignExtend()
// ============

bits(N) <a id="impl-shared.SignExtend.2"/>SignExtend(bits(M) x, integer N)
    assert N &gt;= M;
    return <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(x&lt;M-1&gt;, N-M) : x;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Split64to32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Split64to32</h3>
      <p class="pseudocode">// Split64to32()
// =============

(bits(32), bits(32)) <a id="impl-shared.Split64to32.1"/>Split64to32(bits(64) value)
    return (value&lt;63:32&gt;, value&lt;31:0&gt;);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.UInt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/UInt</h3>
      <p class="pseudocode">// UInt()
// ======

integer <a id="impl-shared.UInt.1"/>UInt(bits(N) x)
    result = 0;
    for i = 0 to N-1
        if x&lt;i&gt; == '1' then result = result + 2^i;
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.ZeroExtend"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/ZeroExtend</h3>
      <p class="pseudocode">// ZeroExtend()
// ============

bits(N) <a id="impl-shared.ZeroExtend.2"/>ZeroExtend(bits(M) x, integer N)
    assert N &gt;= M;
    return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N-M) : x;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Zeros"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Zeros</h3>
      <p class="pseudocode">// Zeros()
// =======

bits(N) <a id="impl-shared.Zeros.1"/>Zeros(integer N)
    return <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>('0',N);</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.AArch32.CheckTimerConditions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/AArch32.CheckTimerConditions</h3>
      <p class="pseudocode">// AArch32.CheckTimerConditions()
// ==============================
// Checking timer conditions for all A32 timer registers

<a id="AArch32.CheckTimerConditions.0"/>AArch32.CheckTimerConditions()
    boolean status;
    bits(64) offset;
    offset = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    assert !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>();

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CNTP_CTL_S.ENABLE == '1' then
            status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTP_CVAL_S,
                                         CNTP_CTL_S.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTPS" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTPS</a>);
            CNTP_CTL_S.ISTATUS = if status then '1' else '0';

        if CNTP_CTL_NS.ENABLE == '1' then
            status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTP_CVAL_NS,
                                         CNTP_CTL_NS.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTP" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTP</a>);
            CNTP_CTL_NS.ISTATUS = if status then '1' else '0';
    else
        if CNTP_CTL.ENABLE == '1' then
            status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTP_CVAL,
                                         CNTP_CTL.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTP" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTP</a>);
            CNTP_CTL.ISTATUS = if status then '1' else '0';

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; CNTHP_CTL.ENABLE == '1' then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTHP_CVAL,
                                     CNTHP_CTL.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTHP" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHP</a>);
        CNTHP_CTL.ISTATUS = if status then '1' else '0';

    if CNTV_CTL_EL0.ENABLE == '1' then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(CNTVOFF_EL2, CNTV_CVAL_EL0,
                                     CNTV_CTL_EL0.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTV" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTV</a>);
        CNTV_CTL_EL0.ISTATUS = if status then '1' else '0';

    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.AArch64.CheckTimerConditions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/AArch64.CheckTimerConditions</h3>
      <p class="pseudocode">// AArch64.CheckTimerConditions()
// ==============================
// Checking timer conditions for all A64 timer registers

<a id="AArch64.CheckTimerConditions.0"/>AArch64.CheckTimerConditions()
    boolean status;
    bits(64) offset;
    bit imask;
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    boolean ecv = FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() then
        ecv = CNTHCTL_EL2.ECV == '1' &amp;&amp; SCR_EL3.ECVEn == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    if ecv then
        offset = CNTPOFF_EL2;
    else
        offset = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    if CNTP_CTL_EL0.ENABLE == '1' then
        imask = CNTP_CTL_EL0.IMASK;
        if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; ss IN {<a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>, <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>} &amp;&amp; CNTHCTL_EL2.CNTPMASK == '1' then
            imask = '1';
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTP_CVAL_EL0,
                                     imask, <a href="shared_pseudocode.html#InterruptID_CNTP" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTP</a>);
        CNTP_CTL_EL0.ISTATUS = if status then '1' else '0';
    if ((<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>())) &amp;&amp;
       CNTHP_CTL_EL2.ENABLE == '1') then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64), CNTHP_CVAL_EL2,
                                     CNTHP_CTL_EL2.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTHP" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHP</a>);
        CNTHP_CTL_EL2.ISTATUS = if status then '1' else '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; CNTHPS_CTL_EL2.ENABLE == '1' then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64), CNTHPS_CVAL_EL2,
                                     CNTHPS_CTL_EL2.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTHPS" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHPS</a>);
        CNTHPS_CTL_EL2.ISTATUS = if status then '1' else '0';

    if CNTPS_CTL_EL1.ENABLE == '1' then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTPS_CVAL_EL1,
                                     CNTPS_CTL_EL1.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTPS" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTPS</a>);
        CNTPS_CTL_EL1.ISTATUS = if status then '1' else '0';

    if CNTV_CTL_EL0.ENABLE == '1' then
        imask = CNTV_CTL_EL0.IMASK;
        if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; ss IN {<a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>, <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>} &amp;&amp; CNTHCTL_EL2.CNTVMASK == '1' then
            imask = '1';
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(CNTVOFF_EL2, CNTV_CVAL_EL0,
                                     imask, <a href="shared_pseudocode.html#InterruptID_CNTV" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTV</a>);
        CNTV_CTL_EL0.ISTATUS = if status then '1' else '0';

    if ((<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || !<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>())) &amp;&amp;
        CNTHV_CTL_EL2.ENABLE == '1') then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64), CNTHV_CVAL_EL2,
                                     CNTHV_CTL_EL2.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTHV" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHV</a>);
        CNTHV_CTL_EL2.ISTATUS = if status then '1' else '0';

    if ((<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>()) &amp;&amp;
        CNTHVS_CTL_EL2.ENABLE == '1') then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64), CNTHVS_CVAL_EL2,
                                     CNTHVS_CTL_EL2.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTHVS" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHVS</a>);
        CNTHVS_CTL_EL2.ISTATUS = if status then '1' else '0';
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.GenericCounterTick"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/GenericCounterTick</h3>
      <p class="pseudocode">// GenericCounterTick()
// ====================
// Increments PhysicalCount value for every clock tick.

<a id="impl-shared.GenericCounterTick.0"/>GenericCounterTick()
    bits(64) prev_physical_count;
    if CNTCR.EN == '0' then
        if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
            <a href="shared_pseudocode.html#AArch32.CheckTimerConditions.0" title="function: AArch32.CheckTimerConditions()">AArch32.CheckTimerConditions</a>();
        else
            <a href="shared_pseudocode.html#AArch64.CheckTimerConditions.0" title="function: AArch64.CheckTimerConditions()">AArch64.CheckTimerConditions</a>();
        return;
    prev_physical_count = <a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>();
    if <a href="shared_pseudocode.html#impl-shared.HaveCNTSCExt.0" title="function: boolean HaveCNTSCExt()">HaveCNTSCExt</a>() &amp;&amp; CNTCR.SCEN == '1' then
        PhysicalCount = PhysicalCount + <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(CNTSCR, 88);
    else
        PhysicalCount&lt;87:24&gt; = PhysicalCount&lt;87:24&gt; + 1;
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        <a href="shared_pseudocode.html#AArch32.CheckTimerConditions.0" title="function: AArch32.CheckTimerConditions()">AArch32.CheckTimerConditions</a>();
    else
        <a href="shared_pseudocode.html#AArch64.CheckTimerConditions.0" title="function: AArch64.CheckTimerConditions()">AArch64.CheckTimerConditions</a>();
    <a href="shared_pseudocode.html#impl-shared.TestEventCNTP.2" title="function: TestEventCNTP(bits(64) prev_physical_count, bits(64) current_physical_count)">TestEventCNTP</a>(prev_physical_count, <a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>());
    <a href="shared_pseudocode.html#impl-shared.TestEventCNTV.2" title="function: TestEventCNTV(bits(64) prev_physical_count, bits(64) current_physical_count)">TestEventCNTV</a>(prev_physical_count, <a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>());
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.IsTimerConditionMet"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/IsTimerConditionMet</h3>
      <p class="pseudocode">// IsTimerConditionMet()
// =====================

boolean <a id="impl-shared.IsTimerConditionMet.4"/>IsTimerConditionMet(bits(64) offset, bits(64) compare_value,
                            bits(1) imask, <a href="shared_pseudocode.html#InterruptID" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID</a> intid)
    boolean conditon_met;
    signal level;
    condition_met = (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>() - offset) -
                                        <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(compare_value)) &gt;= 0;
    level = if condition_met &amp;&amp; imask == '0' then HIGH else LOW;
    SetInterruptRequestLevel(intid, level);
    return condition_met;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.PhysicalCount"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/PhysicalCount</h3>
      <p class="pseudocode">bits(88) PhysicalCount;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.SetEventRegister"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/SetEventRegister</h3>
      <p class="pseudocode">// SetEventRegister()
// ==================
// Sets the Event Register of this PE

<a id="impl-shared.SetEventRegister.0"/>SetEventRegister()
    EventRegister = '1';
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.TestEventCNTP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/TestEventCNTP</h3>
      <p class="pseudocode">// TestEventCNTP()
// ===============
// Generate Event stream from the physical counter

<a id="impl-shared.TestEventCNTP.2"/>TestEventCNTP(bits(64) prev_physical_count, bits(64) current_physical_count)
    bits(64) offset;
    bits(1) samplebit, previousbit;
    if CNTHCTL_EL2.EVNTEN == '1' then
        n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(CNTHCTL_EL2.EVNTI);
        if <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; CNTHCTL_EL2.EVNTIS == '1' then
            n = n + 8;
        boolean ecv = FALSE;
        if <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() then
            ecv = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; CNTHCTL_EL2.ECV == '1' &amp;&amp;
                   SCR_EL3.ECVEn == '1');
            offset = if ecv then CNTPOFF_EL2 else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        samplebit   = (current_physical_count - offset)&lt;n&gt;;
        previousbit = (prev_physical_count - offset)&lt;n&gt;;
        if CNTHCTL_EL2.EVNTDIR == '0' then
            if previousbit == '0' &amp;&amp; samplebit == '1' then <a href="shared_pseudocode.html#impl-shared.SetEventRegister.0" title="function: SetEventRegister()">SetEventRegister</a>();
        else
            if previousbit == '1' &amp;&amp; samplebit == '0' then <a href="shared_pseudocode.html#impl-shared.SetEventRegister.0" title="function: SetEventRegister()">SetEventRegister</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.TestEventCNTV"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/TestEventCNTV</h3>
      <p class="pseudocode">// TestEventCNTV()
// ===============
// Generate Event stream from the virtual counter

<a id="impl-shared.TestEventCNTV.2"/>TestEventCNTV(bits(64) prev_physical_count, bits(64) current_physical_count)
    bits(64) offset;
    bits(1) samplebit, previousbit;
    if (!(<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11') &amp;&amp;
        CNTKCTL_EL1.EVNTEN == '1') then
        n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(CNTKCTL_EL1.EVNTI);
        if <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; CNTKCTL_EL1.EVNTIS == '1' then
            n = n + 8;
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() || HCR_EL2.&lt;E2H,TGE&gt; != '11') then
            offset = CNTVOFF_EL2;
        else
            offset = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        samplebit   = (current_physical_count - offset)&lt;n&gt;;
        previousbit = (prev_physical_count - offset)&lt;n&gt;;
        if CNTKCTL_EL1.EVNTDIR == '0' then
            if previousbit == '0' &amp;&amp; samplebit == '1' then <a href="shared_pseudocode.html#impl-shared.SetEventRegister.0" title="function: SetEventRegister()">SetEventRegister</a>();
        else
            if previousbit == '1' &amp;&amp; samplebit == '0' then <a href="shared_pseudocode.html#impl-shared.SetEventRegister.0" title="function: SetEventRegister()">SetEventRegister</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.crc.BitReverse"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crc/BitReverse</h3>
      <p class="pseudocode">// BitReverse()
// ============

bits(N) <a id="impl-shared.BitReverse.1"/>BitReverse(bits(N) data)
    bits(N) result;
    for i = 0 to N-1
        result&lt;(N-i)-1&gt; = data&lt;i&gt;;
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.crc.HaveCRCExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crc/HaveCRCExt</h3>
      <p class="pseudocode">// HaveCRCExt()
// ============

boolean <a id="impl-shared.HaveCRCExt.0"/>HaveCRCExt()
    return IsFeatureImplemented(FEAT_CRC32);</p>
    </div>
    <div class="ps"><a id="shared.functions.crc.Poly32Mod2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crc/Poly32Mod2</h3>
      <p class="pseudocode">// Poly32Mod2()
// ============

// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation

bits(32) <a id="impl-shared.Poly32Mod2.2"/>Poly32Mod2(bits(N) data_in, bits(32) poly)
    assert N &gt; 32;
    bits(N) data = data_in;
    for i = N-1 downto 32
        if data&lt;i&gt; == '1' then
            data&lt;i-1:0&gt; = data&lt;i-1:0&gt; EOR (poly:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(i-32));
    return data&lt;31:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESInvMixColumns"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESInvMixColumns</h3>
      <p class="pseudocode">// AESInvMixColumns()
// ==================
// Transformation in the Inverse Cipher that is the inverse of AESMixColumns.

bits(128) <a id="impl-shared.AESInvMixColumns.1"/>AESInvMixColumns(bits (128) op)
    bits(4*8) in0 = op&lt; 96+:8&gt; : op&lt; 64+:8&gt; : op&lt; 32+:8&gt; : op&lt;  0+:8&gt;;
    bits(4*8) in1 = op&lt;104+:8&gt; : op&lt; 72+:8&gt; : op&lt; 40+:8&gt; : op&lt;  8+:8&gt;;
    bits(4*8) in2 = op&lt;112+:8&gt; : op&lt; 80+:8&gt; : op&lt; 48+:8&gt; : op&lt; 16+:8&gt;;
    bits(4*8) in3 = op&lt;120+:8&gt; : op&lt; 88+:8&gt; : op&lt; 56+:8&gt; : op&lt; 24+:8&gt;;

    bits(4*8) out0;
    bits(4*8) out1;
    bits(4*8) out2;
    bits(4*8) out3;

    for c = 0 to 3
        out0&lt;c*8+:8&gt; =  <a href="shared_pseudocode.html#impl-shared.FFmul0E.1" title="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</a>(in0&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0B.1" title="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</a>(in1&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0D.1" title="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</a>(in2&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul09.1" title="function: bits(8) FFmul09(bits(8) b)">FFmul09</a>(in3&lt;c*8+:8&gt;);
        out1&lt;c*8+:8&gt; =  <a href="shared_pseudocode.html#impl-shared.FFmul09.1" title="function: bits(8) FFmul09(bits(8) b)">FFmul09</a>(in0&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0E.1" title="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</a>(in1&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0B.1" title="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</a>(in2&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0D.1" title="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</a>(in3&lt;c*8+:8&gt;);
        out2&lt;c*8+:8&gt; =  <a href="shared_pseudocode.html#impl-shared.FFmul0D.1" title="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</a>(in0&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul09.1" title="function: bits(8) FFmul09(bits(8) b)">FFmul09</a>(in1&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0E.1" title="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</a>(in2&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0B.1" title="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</a>(in3&lt;c*8+:8&gt;);
        out3&lt;c*8+:8&gt; =  <a href="shared_pseudocode.html#impl-shared.FFmul0B.1" title="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</a>(in0&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0D.1" title="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</a>(in1&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul09.1" title="function: bits(8) FFmul09(bits(8) b)">FFmul09</a>(in2&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0E.1" title="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</a>(in3&lt;c*8+:8&gt;);

    return (
        out3&lt;3*8+:8&gt; : out2&lt;3*8+:8&gt; : out1&lt;3*8+:8&gt; : out0&lt;3*8+:8&gt; :
        out3&lt;2*8+:8&gt; : out2&lt;2*8+:8&gt; : out1&lt;2*8+:8&gt; : out0&lt;2*8+:8&gt; :
        out3&lt;1*8+:8&gt; : out2&lt;1*8+:8&gt; : out1&lt;1*8+:8&gt; : out0&lt;1*8+:8&gt; :
        out3&lt;0*8+:8&gt; : out2&lt;0*8+:8&gt; : out1&lt;0*8+:8&gt; : out0&lt;0*8+:8&gt;
    );</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESInvShiftRows"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESInvShiftRows</h3>
      <p class="pseudocode">// AESInvShiftRows()
// =================
// Transformation in the Inverse Cipher that is inverse of AESShiftRows.

bits(128) <a id="impl-shared.AESInvShiftRows.1"/>AESInvShiftRows(bits(128) op)
    return (
        op&lt; 31: 24&gt; : op&lt; 55: 48&gt; : op&lt; 79: 72&gt; : op&lt;103: 96&gt; :
        op&lt;127:120&gt; : op&lt; 23: 16&gt; : op&lt; 47: 40&gt; : op&lt; 71: 64&gt; :
        op&lt; 95: 88&gt; : op&lt;119:112&gt; : op&lt; 15:  8&gt; : op&lt; 39: 32&gt; :
        op&lt; 63: 56&gt; : op&lt; 87: 80&gt; : op&lt;111:104&gt; : op&lt;  7:  0&gt;
    );</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESInvSubBytes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESInvSubBytes</h3>
      <p class="pseudocode">// AESInvSubBytes()
// ================
// Transformation in the Inverse Cipher that is the inverse of AESSubBytes.

bits(128) <a id="impl-shared.AESInvSubBytes.1"/>AESInvSubBytes(bits(128) op)
    // Inverse S-box values
    bits(16*16*8) GF2_inv = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x7d0c2155631469e126d677ba7e042b17&lt;127:0&gt; :
        /*E*/ 0x619953833cbbebc8b0f52aae4d3be0a0&lt;127:0&gt; :
        /*D*/ 0xef9cc9939f7ae52d0d4ab519a97f5160&lt;127:0&gt; :
        /*C*/ 0x5fec8027591012b131c7078833a8dd1f&lt;127:0&gt; :
        /*B*/ 0xf45acd78fec0db9a2079d2c64b3e56fc&lt;127:0&gt; :
        /*A*/ 0x1bbe18aa0e62b76f89c5291d711af147&lt;127:0&gt; :
        /*9*/ 0x6edf751ce837f9e28535ade72274ac96&lt;127:0&gt; :
        /*8*/ 0x73e6b4f0cecff297eadc674f4111913a&lt;127:0&gt; :
        /*7*/ 0x6b8a130103bdafc1020f3fca8f1e2cd0&lt;127:0&gt; :
        /*6*/ 0x0645b3b80558e4f70ad3bc8c00abd890&lt;127:0&gt; :
        /*5*/ 0x849d8da75746155edab9edfd5048706c&lt;127:0&gt; :
        /*4*/ 0x92b6655dcc5ca4d41698688664f6f872&lt;127:0&gt; :
        /*3*/ 0x25d18b6d49a25b76b224d92866a12e08&lt;127:0&gt; :
        /*2*/ 0x4ec3fa420b954cee3d23c2a632947b54&lt;127:0&gt; :
        /*1*/ 0xcbe9dec444438e3487ff2f9b8239e37c&lt;127:0&gt; :
        /*0*/ 0xfbd7f3819ea340bf38a53630d56a0952&lt;127:0&gt;
    );
    bits(128) out;
    for i = 0 to 15
        out&lt;i*8+:8&gt; = GF2_inv&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(op&lt;i*8+:8&gt;)*8+:8&gt;;
    return out;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESMixColumns"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESMixColumns</h3>
      <p class="pseudocode">// AESMixColumns()
// ===============
// Transformation in the Cipher that takes all of the columns of the
// State and mixes their data (independently of one another) to
// produce new columns.

bits(128) <a id="impl-shared.AESMixColumns.1"/>AESMixColumns(bits (128) op)
    bits(4*8) in0 = op&lt; 96+:8&gt; : op&lt; 64+:8&gt; : op&lt; 32+:8&gt; : op&lt;  0+:8&gt;;
    bits(4*8) in1 = op&lt;104+:8&gt; : op&lt; 72+:8&gt; : op&lt; 40+:8&gt; : op&lt;  8+:8&gt;;
    bits(4*8) in2 = op&lt;112+:8&gt; : op&lt; 80+:8&gt; : op&lt; 48+:8&gt; : op&lt; 16+:8&gt;;
    bits(4*8) in3 = op&lt;120+:8&gt; : op&lt; 88+:8&gt; : op&lt; 56+:8&gt; : op&lt; 24+:8&gt;;

    bits(4*8) out0;
    bits(4*8) out1;
    bits(4*8) out2;
    bits(4*8) out3;

    for c = 0 to 3
        out0&lt;c*8+:8&gt; =  <a href="shared_pseudocode.html#impl-shared.FFmul02.1" title="function: bits(8) FFmul02(bits(8) b)">FFmul02</a>(in0&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul03.1" title="function: bits(8) FFmul03(bits(8) b)">FFmul03</a>(in1&lt;c*8+:8&gt;) EOR         in2&lt;c*8+:8&gt;  EOR         in3&lt;c*8+:8&gt;;
        out1&lt;c*8+:8&gt; =          in0&lt;c*8+:8&gt;  EOR <a href="shared_pseudocode.html#impl-shared.FFmul02.1" title="function: bits(8) FFmul02(bits(8) b)">FFmul02</a>(in1&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul03.1" title="function: bits(8) FFmul03(bits(8) b)">FFmul03</a>(in2&lt;c*8+:8&gt;) EOR         in3&lt;c*8+:8&gt;;
        out2&lt;c*8+:8&gt; =          in0&lt;c*8+:8&gt;  EOR         in1&lt;c*8+:8&gt;  EOR <a href="shared_pseudocode.html#impl-shared.FFmul02.1" title="function: bits(8) FFmul02(bits(8) b)">FFmul02</a>(in2&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul03.1" title="function: bits(8) FFmul03(bits(8) b)">FFmul03</a>(in3&lt;c*8+:8&gt;);
        out3&lt;c*8+:8&gt; =  <a href="shared_pseudocode.html#impl-shared.FFmul03.1" title="function: bits(8) FFmul03(bits(8) b)">FFmul03</a>(in0&lt;c*8+:8&gt;) EOR         in1&lt;c*8+:8&gt;  EOR         in2&lt;c*8+:8&gt;  EOR <a href="shared_pseudocode.html#impl-shared.FFmul02.1" title="function: bits(8) FFmul02(bits(8) b)">FFmul02</a>(in3&lt;c*8+:8&gt;);

    return (
        out3&lt;3*8+:8&gt; : out2&lt;3*8+:8&gt; : out1&lt;3*8+:8&gt; : out0&lt;3*8+:8&gt; :
        out3&lt;2*8+:8&gt; : out2&lt;2*8+:8&gt; : out1&lt;2*8+:8&gt; : out0&lt;2*8+:8&gt; :
        out3&lt;1*8+:8&gt; : out2&lt;1*8+:8&gt; : out1&lt;1*8+:8&gt; : out0&lt;1*8+:8&gt; :
        out3&lt;0*8+:8&gt; : out2&lt;0*8+:8&gt; : out1&lt;0*8+:8&gt; : out0&lt;0*8+:8&gt;
    );</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESShiftRows"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESShiftRows</h3>
      <p class="pseudocode">// AESShiftRows()
// ==============
// Transformation in the Cipher that processes the State by cyclically
// shifting the last three rows of the State by different offsets.

bits(128) <a id="impl-shared.AESShiftRows.1"/>AESShiftRows(bits(128) op)
    return (
        op&lt; 95: 88&gt; : op&lt; 55: 48&gt; : op&lt; 15:  8&gt; : op&lt;103: 96&gt; :
        op&lt; 63: 56&gt; : op&lt; 23: 16&gt; : op&lt;111:104&gt; : op&lt; 71: 64&gt; :
        op&lt; 31: 24&gt; : op&lt;119:112&gt; : op&lt; 79: 72&gt; : op&lt; 39: 32&gt; :
        op&lt;127:120&gt; : op&lt; 87: 80&gt; : op&lt; 47: 40&gt; : op&lt;  7:  0&gt;
    );</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESSubBytes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESSubBytes</h3>
      <p class="pseudocode">// AESSubBytes()
// =============
// Transformation in the Cipher that processes the State using a nonlinear
// byte substitution table (S-box) that operates on each of the State bytes
// independently.

bits(128) <a id="impl-shared.AESSubBytes.1"/>AESSubBytes(bits(128) op)
    // S-box values
    bits(16*16*8) GF2 = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x16bb54b00f2d99416842e6bf0d89a18c&lt;127:0&gt; :
        /*E*/ 0xdf2855cee9871e9b948ed9691198f8e1&lt;127:0&gt; :
        /*D*/ 0x9e1dc186b95735610ef6034866b53e70&lt;127:0&gt; :
        /*C*/ 0x8a8bbd4b1f74dde8c6b4a61c2e2578ba&lt;127:0&gt; :
        /*B*/ 0x08ae7a65eaf4566ca94ed58d6d37c8e7&lt;127:0&gt; :
        /*A*/ 0x79e4959162acd3c25c2406490a3a32e0&lt;127:0&gt; :
        /*9*/ 0xdb0b5ede14b8ee4688902a22dc4f8160&lt;127:0&gt; :
        /*8*/ 0x73195d643d7ea7c41744975fec130ccd&lt;127:0&gt; :
        /*7*/ 0xd2f3ff1021dab6bcf5389d928f40a351&lt;127:0&gt; :
        /*6*/ 0xa89f3c507f02f94585334d43fbaaefd0&lt;127:0&gt; :
        /*5*/ 0xcf584c4a39becb6a5bb1fc20ed00d153&lt;127:0&gt; :
        /*4*/ 0x842fe329b3d63b52a05a6e1b1a2c8309&lt;127:0&gt; :
        /*3*/ 0x75b227ebe28012079a059618c323c704&lt;127:0&gt; :
        /*2*/ 0x1531d871f1e5a534ccf73f362693fdb7&lt;127:0&gt; :
        /*1*/ 0xc072a49cafa2d4adf04759fa7dc982ca&lt;127:0&gt; :
        /*0*/ 0x76abd7fe2b670130c56f6bf27b777c63&lt;127:0&gt;
    );
    bits(128) out;
    for i = 0 to 15
        out&lt;i*8+:8&gt; = GF2&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(op&lt;i*8+:8&gt;)*8+:8&gt;;
    return out;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul02"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul02</h3>
      <p class="pseudocode">// FFmul02()
// =========

bits(8) <a id="impl-shared.FFmul02.1"/>FFmul02(bits(8) b)
    bits(256*8) FFmul_02 = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0xE5E7E1E3EDEFE9EBF5F7F1F3FDFFF9FB&lt;127:0&gt; :
        /*E*/ 0xC5C7C1C3CDCFC9CBD5D7D1D3DDDFD9DB&lt;127:0&gt; :
        /*D*/ 0xA5A7A1A3ADAFA9ABB5B7B1B3BDBFB9BB&lt;127:0&gt; :
        /*C*/ 0x858781838D8F898B959791939D9F999B&lt;127:0&gt; :
        /*B*/ 0x656761636D6F696B757771737D7F797B&lt;127:0&gt; :
        /*A*/ 0x454741434D4F494B555751535D5F595B&lt;127:0&gt; :
        /*9*/ 0x252721232D2F292B353731333D3F393B&lt;127:0&gt; :
        /*8*/ 0x050701030D0F090B151711131D1F191B&lt;127:0&gt; :
        /*7*/ 0xFEFCFAF8F6F4F2F0EEECEAE8E6E4E2E0&lt;127:0&gt; :
        /*6*/ 0xDEDCDAD8D6D4D2D0CECCCAC8C6C4C2C0&lt;127:0&gt; :
        /*5*/ 0xBEBCBAB8B6B4B2B0AEACAAA8A6A4A2A0&lt;127:0&gt; :
        /*4*/ 0x9E9C9A98969492908E8C8A8886848280&lt;127:0&gt; :
        /*3*/ 0x7E7C7A78767472706E6C6A6866646260&lt;127:0&gt; :
        /*2*/ 0x5E5C5A58565452504E4C4A4846444240&lt;127:0&gt; :
        /*1*/ 0x3E3C3A38363432302E2C2A2826242220&lt;127:0&gt; :
        /*0*/ 0x1E1C1A18161412100E0C0A0806040200&lt;127:0&gt;
    );
    return FFmul_02&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul03"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul03</h3>
      <p class="pseudocode">// FFmul03()
// =========

bits(8) <a id="impl-shared.FFmul03.1"/>FFmul03(bits(8) b)
    bits(256*8) FFmul_03 = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x1A191C1F16151013020104070E0D080B&lt;127:0&gt; :
        /*E*/ 0x2A292C2F26252023323134373E3D383B&lt;127:0&gt; :
        /*D*/ 0x7A797C7F76757073626164676E6D686B&lt;127:0&gt; :
        /*C*/ 0x4A494C4F46454043525154575E5D585B&lt;127:0&gt; :
        /*B*/ 0xDAD9DCDFD6D5D0D3C2C1C4C7CECDC8CB&lt;127:0&gt; :
        /*A*/ 0xEAE9ECEFE6E5E0E3F2F1F4F7FEFDF8FB&lt;127:0&gt; :
        /*9*/ 0xBAB9BCBFB6B5B0B3A2A1A4A7AEADA8AB&lt;127:0&gt; :
        /*8*/ 0x8A898C8F86858083929194979E9D989B&lt;127:0&gt; :
        /*7*/ 0x818287848D8E8B88999A9F9C95969390&lt;127:0&gt; :
        /*6*/ 0xB1B2B7B4BDBEBBB8A9AAAFACA5A6A3A0&lt;127:0&gt; :
        /*5*/ 0xE1E2E7E4EDEEEBE8F9FAFFFCF5F6F3F0&lt;127:0&gt; :
        /*4*/ 0xD1D2D7D4DDDEDBD8C9CACFCCC5C6C3C0&lt;127:0&gt; :
        /*3*/ 0x414247444D4E4B48595A5F5C55565350&lt;127:0&gt; :
        /*2*/ 0x717277747D7E7B78696A6F6C65666360&lt;127:0&gt; :
        /*1*/ 0x212227242D2E2B28393A3F3C35363330&lt;127:0&gt; :
        /*0*/ 0x111217141D1E1B18090A0F0C05060300&lt;127:0&gt;
    );
    return FFmul_03&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul09"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul09</h3>
      <p class="pseudocode">// FFmul09()
// =========

bits(8) <a id="impl-shared.FFmul09.1"/>FFmul09(bits(8) b)
    bits(256*8) FFmul_09 = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x464F545D626B70790E071C152A233831&lt;127:0&gt; :
        /*E*/ 0xD6DFC4CDF2FBE0E99E978C85BAB3A8A1&lt;127:0&gt; :
        /*D*/ 0x7D746F6659504B42353C272E1118030A&lt;127:0&gt; :
        /*C*/ 0xEDE4FFF6C9C0DBD2A5ACB7BE8188939A&lt;127:0&gt; :
        /*B*/ 0x3039222B141D060F78716A635C554E47&lt;127:0&gt; :
        /*A*/ 0xA0A9B2BB848D969FE8E1FAF3CCC5DED7&lt;127:0&gt; :
        /*9*/ 0x0B0219102F263D34434A5158676E757C&lt;127:0&gt; :
        /*8*/ 0x9B928980BFB6ADA4D3DAC1C8F7FEE5EC&lt;127:0&gt; :
        /*7*/ 0xAAA3B8B18E879C95E2EBF0F9C6CFD4DD&lt;127:0&gt; :
        /*6*/ 0x3A3328211E170C05727B6069565F444D&lt;127:0&gt; :
        /*5*/ 0x9198838AB5BCA7AED9D0CBC2FDF4EFE6&lt;127:0&gt; :
        /*4*/ 0x0108131A252C373E49405B526D647F76&lt;127:0&gt; :
        /*3*/ 0xDCD5CEC7F8F1EAE3949D868FB0B9A2AB&lt;127:0&gt; :
        /*2*/ 0x4C455E5768617A73040D161F2029323B&lt;127:0&gt; :
        /*1*/ 0xE7EEF5FCC3CAD1D8AFA6BDB48B829990&lt;127:0&gt; :
        /*0*/ 0x777E656C535A41483F362D241B120900&lt;127:0&gt;
    );
    return FFmul_09&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul0B"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul0B</h3>
      <p class="pseudocode">// FFmul0B()
// =========

bits(8) <a id="impl-shared.FFmul0B.1"/>FFmul0B(bits(8) b)
    bits(256*8) FFmul_0B = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0xA3A8B5BE8F849992FBF0EDE6D7DCC1CA&lt;127:0&gt; :
        /*E*/ 0x1318050E3F3429224B405D56676C717A&lt;127:0&gt; :
        /*D*/ 0xD8D3CEC5F4FFE2E9808B969DACA7BAB1&lt;127:0&gt; :
        /*C*/ 0x68637E75444F5259303B262D1C170A01&lt;127:0&gt; :
        /*B*/ 0x555E434879726F640D061B10212A373C&lt;127:0&gt; :
        /*A*/ 0xE5EEF3F8C9C2DFD4BDB6ABA0919A878C&lt;127:0&gt; :
        /*9*/ 0x2E2538330209141F767D606B5A514C47&lt;127:0&gt; :
        /*8*/ 0x9E958883B2B9A4AFC6CDD0DBEAE1FCF7&lt;127:0&gt; :
        /*7*/ 0x545F424978736E650C071A11202B363D&lt;127:0&gt; :
        /*6*/ 0xE4EFF2F9C8C3DED5BCB7AAA1909B868D&lt;127:0&gt; :
        /*5*/ 0x2F2439320308151E777C616A5B504D46&lt;127:0&gt; :
        /*4*/ 0x9F948982B3B8A5AEC7CCD1DAEBE0FDF6&lt;127:0&gt; :
        /*3*/ 0xA2A9B4BF8E859893FAF1ECE7D6DDC0CB&lt;127:0&gt; :
        /*2*/ 0x1219040F3E3528234A415C57666D707B&lt;127:0&gt; :
        /*1*/ 0xD9D2CFC4F5FEE3E8818A979CADA6BBB0&lt;127:0&gt; :
        /*0*/ 0x69627F74454E5358313A272C1D160B00&lt;127:0&gt;
    );
    return FFmul_0B&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul0D"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul0D</h3>
      <p class="pseudocode">// FFmul0D()
// =========

bits(8) <a id="impl-shared.FFmul0D.1"/>FFmul0D(bits(8) b)
    bits(256*8) FFmul_0D = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x979A8D80A3AEB9B4FFF2E5E8CBC6D1DC&lt;127:0&gt; :
        /*E*/ 0x474A5D50737E69642F2235381B16010C&lt;127:0&gt; :
        /*D*/ 0x2C21363B1815020F44495E53707D6A67&lt;127:0&gt; :
        /*C*/ 0xFCF1E6EBC8C5D2DF94998E83A0ADBAB7&lt;127:0&gt; :
        /*B*/ 0xFAF7E0EDCEC3D4D9929F8885A6ABBCB1&lt;127:0&gt; :
        /*A*/ 0x2A27303D1E130409424F5855767B6C61&lt;127:0&gt; :
        /*9*/ 0x414C5B5675786F622924333E1D10070A&lt;127:0&gt; :
        /*8*/ 0x919C8B86A5A8BFB2F9F4E3EECDC0D7DA&lt;127:0&gt; :
        /*7*/ 0x4D40575A7974636E25283F32111C0B06&lt;127:0&gt; :
        /*6*/ 0x9D90878AA9A4B3BEF5F8EFE2C1CCDBD6&lt;127:0&gt; :
        /*5*/ 0xF6FBECE1C2CFD8D59E938489AAA7B0BD&lt;127:0&gt; :
        /*4*/ 0x262B3C31121F08054E4354597A77606D&lt;127:0&gt; :
        /*3*/ 0x202D3A3714190E034845525F7C71666B&lt;127:0&gt; :
        /*2*/ 0xF0FDEAE7C4C9DED39895828FACA1B6BB&lt;127:0&gt; :
        /*1*/ 0x9B96818CAFA2B5B8F3FEE9E4C7CADDD0&lt;127:0&gt; :
        /*0*/ 0x4B46515C7F726568232E3934171A0D00&lt;127:0&gt;
    );
    return FFmul_0D&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul0E"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul0E</h3>
      <p class="pseudocode">// FFmul0E()
// =========

bits(8) <a id="impl-shared.FFmul0E.1"/>FFmul0E(bits(8) b)
    bits(256*8) FFmul_0E = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x8D83919FB5BBA9A7FDF3E1EFC5CBD9D7&lt;127:0&gt; :
        /*E*/ 0x6D63717F555B49471D13010F252B3937&lt;127:0&gt; :
        /*D*/ 0x56584A446E60727C26283A341E10020C&lt;127:0&gt; :
        /*C*/ 0xB6B8AAA48E80929CC6C8DAD4FEF0E2EC&lt;127:0&gt; :
        /*B*/ 0x202E3C321816040A505E4C426866747A&lt;127:0&gt; :
        /*A*/ 0xC0CEDCD2F8F6E4EAB0BEACA28886949A&lt;127:0&gt; :
        /*9*/ 0xFBF5E7E9C3CDDFD18B859799B3BDAFA1&lt;127:0&gt; :
        /*8*/ 0x1B150709232D3F316B657779535D4F41&lt;127:0&gt; :
        /*7*/ 0xCCC2D0DEF4FAE8E6BCB2A0AE848A9896&lt;127:0&gt; :
        /*6*/ 0x2C22303E141A08065C52404E646A7876&lt;127:0&gt; :
        /*5*/ 0x17190B052F21333D67697B755F51434D&lt;127:0&gt; :
        /*4*/ 0xF7F9EBE5CFC1D3DD87899B95BFB1A3AD&lt;127:0&gt; :
        /*3*/ 0x616F7D735957454B111F0D032927353B&lt;127:0&gt; :
        /*2*/ 0x818F9D93B9B7A5ABF1FFEDE3C9C7D5DB&lt;127:0&gt; :
        /*1*/ 0xBAB4A6A8828C9E90CAC4D6D8F2FCEEE0&lt;127:0&gt; :
        /*0*/ 0x5A544648626C7E702A243638121C0E00&lt;127:0&gt;
    );
    return FFmul_0E&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveAESExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveAESExt</h3>
      <p class="pseudocode">// HaveAESExt()
// ============
// TRUE if AES cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveAESExt.0"/>HaveAESExt()
    return IsFeatureImplemented(FEAT_AES);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveBit128PMULLExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveBit128PMULLExt</h3>
      <p class="pseudocode">// HaveBit128PMULLExt()
// ====================
// TRUE if 128 bit form of PMULL instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveBit128PMULLExt.0"/>HaveBit128PMULLExt()
    return IsFeatureImplemented(FEAT_PMULL);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveSHA1Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveSHA1Ext</h3>
      <p class="pseudocode">// HaveSHA1Ext()
// =============
// TRUE if SHA1 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveSHA1Ext.0"/>HaveSHA1Ext()
    return IsFeatureImplemented(FEAT_SHA1);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveSHA256Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveSHA256Ext</h3>
      <p class="pseudocode">// HaveSHA256Ext()
// ===============
// TRUE if SHA256 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveSHA256Ext.0"/>HaveSHA256Ext()
    return IsFeatureImplemented(FEAT_SHA256);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveSHA3Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveSHA3Ext</h3>
      <p class="pseudocode">// HaveSHA3Ext()
// =============
// TRUE if SHA3 cryptographic instructions support is implemented,
// and when SHA1 and SHA2 basic cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveSHA3Ext.0"/>HaveSHA3Ext()
    return IsFeatureImplemented(FEAT_SHA3);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveSHA512Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveSHA512Ext</h3>
      <p class="pseudocode">// HaveSHA512Ext()
// ===============
// TRUE if SHA512 cryptographic instructions support is implemented,
// and when SHA1 and SHA2 basic cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveSHA512Ext.0"/>HaveSHA512Ext()
    return IsFeatureImplemented(FEAT_SHA512);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveSM3Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveSM3Ext</h3>
      <p class="pseudocode">// HaveSM3Ext()
// ============
// TRUE if SM3 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveSM3Ext.0"/>HaveSM3Ext()
    return IsFeatureImplemented(FEAT_SM3);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveSM4Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveSM4Ext</h3>
      <p class="pseudocode">// HaveSM4Ext()
// ============
// TRUE if SM4 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveSM4Ext.0"/>HaveSM4Ext()
    return IsFeatureImplemented(FEAT_SM4);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.ROL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/ROL</h3>
      <p class="pseudocode">// ROL()
// =====

bits(N) <a id="impl-shared.ROL.2"/>ROL(bits(N) x, integer shift)
    assert shift &gt;= 0 &amp;&amp; shift &lt;= N;
    if (shift == 0) then
        return x;
    return <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, N-shift);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHA256hash"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHA256hash</h3>
      <p class="pseudocode">// SHA256hash()
// ============

bits(128) <a id="impl-shared.SHA256hash.4"/>SHA256hash(bits (128) x_in, bits(128) y_in, bits(128) w, boolean part1)
    bits(32) chs, maj, t;
    bits(128) x = x_in;
    bits(128) y = y_in;

    for e = 0 to 3
        chs = <a href="shared_pseudocode.html#impl-shared.SHAchoose.3" title="function: bits(32) SHAchoose(bits(32) x, bits(32) y, bits(32) z)">SHAchoose</a>(y&lt;31:0&gt;, y&lt;63:32&gt;, y&lt;95:64&gt;);
        maj = <a href="shared_pseudocode.html#impl-shared.SHAmajority.3" title="function: bits(32) SHAmajority(bits(32) x, bits(32) y, bits(32) z)">SHAmajority</a>(x&lt;31:0&gt;, x&lt;63:32&gt;, x&lt;95:64&gt;);
        t = y&lt;127:96&gt; + <a href="shared_pseudocode.html#impl-shared.SHAhashSIGMA1.1" title="function: bits(32) SHAhashSIGMA1(bits(32) x)">SHAhashSIGMA1</a>(y&lt;31:0&gt;) + chs + <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[w, e, 32];
        x&lt;127:96&gt; = t + x&lt;127:96&gt;;
        y&lt;127:96&gt; = t + <a href="shared_pseudocode.html#impl-shared.SHAhashSIGMA0.1" title="function: bits(32) SHAhashSIGMA0(bits(32) x)">SHAhashSIGMA0</a>(x&lt;31:0&gt;) + maj;
        &lt;y, x&gt; = <a href="shared_pseudocode.html#impl-shared.ROL.2" title="function: bits(N) ROL(bits(N) x, integer shift)">ROL</a>(y : x, 32);
    return (if part1 then x else y);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAchoose"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAchoose</h3>
      <p class="pseudocode">// SHAchoose()
// ===========

bits(32) <a id="impl-shared.SHAchoose.3"/>SHAchoose(bits(32) x, bits(32) y, bits(32) z)
    return (((y EOR z) AND x) EOR z);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAhashSIGMA0"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAhashSIGMA0</h3>
      <p class="pseudocode">// SHAhashSIGMA0()
// ===============

bits(32) <a id="impl-shared.SHAhashSIGMA0.1"/>SHAhashSIGMA0(bits(32) x)
    return <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 2) EOR <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 13) EOR <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 22);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAhashSIGMA1"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAhashSIGMA1</h3>
      <p class="pseudocode">// SHAhashSIGMA1()
// ===============

bits(32) <a id="impl-shared.SHAhashSIGMA1.1"/>SHAhashSIGMA1(bits(32) x)
    return <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 6) EOR <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 11) EOR <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 25);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAmajority"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAmajority</h3>
      <p class="pseudocode">// SHAmajority()
// =============

bits(32) <a id="impl-shared.SHAmajority.3"/>SHAmajority(bits(32) x, bits(32) y, bits(32) z)
    return ((x AND y) OR ((x OR y) AND z));</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAparity"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAparity</h3>
      <p class="pseudocode">// SHAparity()
// ===========

bits(32) <a id="impl-shared.SHAparity.3"/>SHAparity(bits(32) x, bits(32) y, bits(32) z)
    return (x EOR y EOR z);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.Sbox"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/Sbox</h3>
      <p class="pseudocode">// Sbox()
// ======
// Used in SM4E crypto instruction

bits(8) <a id="impl-shared.Sbox.1"/>Sbox(bits(8) sboxin)
    bits(8) sboxout;
    bits(2048) sboxstring = 0xd690e9fecce13db716b614c228fb2c052b679a762abe04c3aa441326498606999c4250f491ef987a33540b43edcfac62e4b31ca9c908e89580df94fa758f3fa64707a7fcf37317ba83593c19e6854fa8686b81b27164da8bf8eb0f4b70569d351e240e5e6358d1a225227c3b01217887d40046579fd327524c3602e7a0c4c89eeabf8ad240c738b5a3f7f2cef96115a1e0ae5da49b341a55ad933230f58cb1e31df6e22e8266ca60c02923ab0d534e6fd5db3745defd8e2f03ff6a726d6c5b518d1baf92bbddbc7f11d95c411f105ad80ac13188a5cd7bbd2d74d012b8e5b4b08969974a0c96777e65b9f109c56ec68418f07dec3adc4d2079ee5f3ed7cb3948&lt;2047:0&gt;;

    sboxout = sboxstring&lt;(255-<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(sboxin))*8+7:(255-<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(sboxin))*8&gt;;
    return sboxout;</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ClearExclusiveByAddress"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ClearExclusiveByAddress</h3>
      <p class="pseudocode">// Clear the global Exclusives monitors for all PEs EXCEPT processorid if they
// record any part of the physical address region of size bytes starting at paddress.
// It is IMPLEMENTATION DEFINED whether the global Exclusives monitor for processorid
// is also cleared if it records any part of the address region.
<a id="impl-shared.ClearExclusiveByAddress.3"/>ClearExclusiveByAddress(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> paddress, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ClearExclusiveLocal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ClearExclusiveLocal</h3>
      <p class="pseudocode">// Clear the local Exclusives monitor for the specified processorid.
<a id="impl-shared.ClearExclusiveLocal.1"/>ClearExclusiveLocal(integer processorid);</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ClearExclusiveMonitors"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ClearExclusiveMonitors</h3>
      <p class="pseudocode">// ClearExclusiveMonitors()
// ========================
// Clear the local Exclusives monitor for the executing PE.

<a id="impl-shared.ClearExclusiveMonitors.0"/>ClearExclusiveMonitors()
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>());</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ExclusiveMonitorsStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ExclusiveMonitorsStatus</h3>
      <p class="pseudocode">// Returns '0' to indicate success if the last memory write by this PE was to
// the same physical address region endorsed by ExclusiveMonitorsPass().
// Returns '1' to indicate failure if address translation resulted in a different
// physical address.
bit <a id="impl-shared.ExclusiveMonitorsStatus.0"/>ExclusiveMonitorsStatus();</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.IsExclusiveGlobal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/IsExclusiveGlobal</h3>
      <p class="pseudocode">// Return TRUE if the global Exclusives monitor for processorid includes all of
// the physical address region of size bytes starting at paddress.
boolean <a id="impl-shared.IsExclusiveGlobal.3"/>IsExclusiveGlobal(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> paddress, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.IsExclusiveLocal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/IsExclusiveLocal</h3>
      <p class="pseudocode">// Return TRUE if the local Exclusives monitor for processorid includes all of
// the physical address region of size bytes starting at paddress.
boolean <a id="impl-shared.IsExclusiveLocal.3"/>IsExclusiveLocal(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> paddress, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.MarkExclusiveGlobal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/MarkExclusiveGlobal</h3>
      <p class="pseudocode">// Record the physical address region of size bytes starting at paddress in
// the global Exclusives monitor for processorid.
<a id="impl-shared.MarkExclusiveGlobal.3"/>MarkExclusiveGlobal(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> paddress, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.MarkExclusiveLocal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/MarkExclusiveLocal</h3>
      <p class="pseudocode">// Record the physical address region of size bytes starting at paddress in
// the local Exclusives monitor for processorid.
<a id="impl-shared.MarkExclusiveLocal.3"/>MarkExclusiveLocal(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> paddress, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ProcessorID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ProcessorID</h3>
      <p class="pseudocode">// Return the ID of the currently executing PE.
integer <a id="impl-shared.ProcessorID.0"/>ProcessorID();</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.AArch32.HaveHPDExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/AArch32.HaveHPDExt</h3>
      <p class="pseudocode">// AArch32.HaveHPDExt()
// ====================

boolean <a id="AArch32.HaveHPDExt.0"/>AArch32.HaveHPDExt()
    return IsFeatureImplemented(FEAT_AA32HPD);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.AArch64.HaveHPDExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/AArch64.HaveHPDExt</h3>
      <p class="pseudocode">// AArch64.HaveHPDExt()
// ====================

boolean <a id="AArch64.HaveHPDExt.0"/>AArch64.HaveHPDExt()
    return IsFeatureImplemented(FEAT_HPDS);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Have128BitDescriptorExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Have128BitDescriptorExt</h3>
      <p class="pseudocode">// Have128BitDescriptorExt()
// =========================
// Returns TRUE if 128-bit Descriptor extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.Have128BitDescriptorExt.0"/>Have128BitDescriptorExt()
    return IsFeatureImplemented(FEAT_D128);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Have16bitVMID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Have16bitVMID</h3>
      <p class="pseudocode">// Have16bitVMID()
// ===============
// Returns TRUE if EL2 and support for a 16-bit VMID are implemented.

boolean <a id="impl-shared.Have16bitVMID.0"/>Have16bitVMID()
    return IsFeatureImplemented(FEAT_VMID16);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Have52BitIPAAndPASpaceExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Have52BitIPAAndPASpaceExt</h3>
      <p class="pseudocode">// Have52BitIPAAndPASpaceExt()
// ===========================
// Returns TRUE if 52-bit IPA and PA extension support
// is implemented, and FALSE otherwise.

boolean <a id="impl-shared.Have52BitIPAAndPASpaceExt.0"/>Have52BitIPAAndPASpaceExt()
    return IsFeatureImplemented(FEAT_LPA2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Have52BitPAExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Have52BitPAExt</h3>
      <p class="pseudocode">// Have52BitPAExt()
// ================
// Returns TRUE if Large Physical Address extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.Have52BitPAExt.0"/>Have52BitPAExt()
    return IsFeatureImplemented(FEAT_LPA);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Have52BitVAExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Have52BitVAExt</h3>
      <p class="pseudocode">// Have52BitVAExt()
// ================
// Returns TRUE if Large Virtual Address extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.Have52BitVAExt.0"/>Have52BitVAExt()
    return IsFeatureImplemented(FEAT_LVA);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Have56BitPAExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Have56BitPAExt</h3>
      <p class="pseudocode">// Have56BitPAExt()
// ================
// Returns TRUE if 56-bit Physical Address extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.Have56BitPAExt.0"/>Have56BitPAExt()
    return IsFeatureImplemented(FEAT_D128);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Have56BitVAExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Have56BitVAExt</h3>
      <p class="pseudocode">// Have56BitVAExt()
// ================
// Returns TRUE if 56-bit Virtual Address extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.Have56BitVAExt.0"/>Have56BitVAExt()
    return IsFeatureImplemented(FEAT_LVA3);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveAArch32BF16Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveAArch32BF16Ext</h3>
      <p class="pseudocode">// HaveAArch32BF16Ext()
// ====================
// Returns TRUE if AArch32 BFloat16 instruction support is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveAArch32BF16Ext.0"/>HaveAArch32BF16Ext()
    return IsFeatureImplemented(FEAT_AA32BF16);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveAArch32Int8MatMulExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveAArch32Int8MatMulExt</h3>
      <p class="pseudocode">// HaveAArch32Int8MatMulExt()
// ==========================
// Returns TRUE if AArch32 8-bit integer matrix multiply instruction support
// implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveAArch32Int8MatMulExt.0"/>HaveAArch32Int8MatMulExt()
    return IsFeatureImplemented(FEAT_AA32I8MM);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveAIEExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveAIEExt</h3>
      <p class="pseudocode">// HaveAIEExt()
// ============
// Returns TRUE if AIE extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.HaveAIEExt.0"/>HaveAIEExt()
    return IsFeatureImplemented(FEAT_AIE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveAccessFlagUpdateExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveAccessFlagUpdateExt</h3>
      <p class="pseudocode">// HaveAccessFlagUpdateExt()
// =========================

boolean <a id="impl-shared.HaveAccessFlagUpdateExt.0"/>HaveAccessFlagUpdateExt()
    return IsFeatureImplemented(FEAT_HAFDBS);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveAccessFlagUpdateForTableExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveAccessFlagUpdateForTableExt</h3>
      <p class="pseudocode">// HaveAccessFlagUpdateForTableExt()
// =================================
// Returns TRUE if support for Access Flag Update for Table Descriptors
// is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveAccessFlagUpdateForTableExt.0"/>HaveAccessFlagUpdateForTableExt()
    return IsFeatureImplemented(FEAT_HAFT);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveAltFP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveAltFP</h3>
      <p class="pseudocode">// HaveAltFP()
// ===========
// Returns TRUE if alternative Floating-point extension support
// is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveAltFP.0"/>HaveAltFP()
    return IsFeatureImplemented(FEAT_AFP);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveAtomicExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveAtomicExt</h3>
      <p class="pseudocode">// HaveAtomicExt()
// ===============

boolean <a id="impl-shared.HaveAtomicExt.0"/>HaveAtomicExt()
    return IsFeatureImplemented(FEAT_LSE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveBF16Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveBF16Ext</h3>
      <p class="pseudocode">// HaveBF16Ext()
// =============
// Returns TRUE if AArch64 BFloat16 instruction support is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveBF16Ext.0"/>HaveBF16Ext()
    return IsFeatureImplemented(FEAT_BF16);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveBRBEv1p1"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveBRBEv1p1</h3>
      <p class="pseudocode">// HaveBRBEv1p1()
// ==============
// Returns TRUE if BRBEv1p1 extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveBRBEv1p1.0"/>HaveBRBEv1p1()
    return IsFeatureImplemented(FEAT_BRBEv1p1);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveBRBExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveBRBExt</h3>
      <p class="pseudocode">// HaveBRBExt()
// ============
// Returns TRUE if Branch Record Buffer Extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveBRBExt.0"/>HaveBRBExt()
    return IsFeatureImplemented(FEAT_BRBE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveBTIExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveBTIExt</h3>
      <p class="pseudocode">// HaveBTIExt()
// ============
// Returns TRUE if support for Branch Target Indentification is implemented.

boolean <a id="impl-shared.HaveBTIExt.0"/>HaveBTIExt()
    return IsFeatureImplemented(FEAT_BTI);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveBlockBBM"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveBlockBBM</h3>
      <p class="pseudocode">// HaveBlockBBM()
// ==============
// Returns TRUE if support for changing block size without requiring
// break-before-make is implemented.

boolean <a id="impl-shared.HaveBlockBBM.0"/>HaveBlockBBM()
    return IsFeatureImplemented(FEAT_BBM);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveCNTSCExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveCNTSCExt</h3>
      <p class="pseudocode">// HaveCNTSCExt()
// ==============
// Returns TRUE if the Generic Counter Scaling is implemented, and FALSE
// otherwise.

boolean <a id="impl-shared.HaveCNTSCExt.0"/>HaveCNTSCExt()
    return IsFeatureImplemented(FEAT_CNTSC);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveCSSC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveCSSC</h3>
      <p class="pseudocode">// HaveCSSC()
// ==========
// Returns TRUE if the Common Short Sequence Compression instructions extension is implemented,
// and FALSE otherwise.

boolean <a id="impl-shared.HaveCSSC.0"/>HaveCSSC()
    return IsFeatureImplemented(FEAT_CSSC);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveCommonNotPrivateTransExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveCommonNotPrivateTransExt</h3>
      <p class="pseudocode">// HaveCommonNotPrivateTransExt()
// ==============================

boolean <a id="impl-shared.HaveCommonNotPrivateTransExt.0"/>HaveCommonNotPrivateTransExt()
    return IsFeatureImplemented(FEAT_TTCNP);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDGHExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDGHExt</h3>
      <p class="pseudocode">// HaveDGHExt()
// ============
// Returns TRUE if Data Gathering Hint instruction support is implemented, and
// FALSE otherwise.

boolean <a id="impl-shared.HaveDGHExt.0"/>HaveDGHExt()
    return IsFeatureImplemented(FEAT_DGH);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDITExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDITExt</h3>
      <p class="pseudocode">// HaveDITExt()
// ============

boolean <a id="impl-shared.HaveDITExt.0"/>HaveDITExt()
    return IsFeatureImplemented(FEAT_DIT);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDOTPExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDOTPExt</h3>
      <p class="pseudocode">// HaveDOTPExt()
// =============
// Returns TRUE if Dot Product feature support is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveDOTPExt.0"/>HaveDOTPExt()
    return IsFeatureImplemented(FEAT_DotProd);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDirtyBitModifierExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDirtyBitModifierExt</h3>
      <p class="pseudocode">// HaveDirtyBitModifierExt()
// =========================

boolean <a id="impl-shared.HaveDirtyBitModifierExt.0"/>HaveDirtyBitModifierExt()
    return IsFeatureImplemented(FEAT_HAFDBS);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDoPD"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDoPD</h3>
      <p class="pseudocode">// HaveDoPD()
// ==========
// Returns TRUE if Debug Over Power Down extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.HaveDoPD.0"/>HaveDoPD()
    return IsFeatureImplemented(FEAT_DoPD);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDoubleFaultExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDoubleFaultExt</h3>
      <p class="pseudocode">// HaveDoubleFaultExt()
// ====================

boolean <a id="impl-shared.HaveDoubleFaultExt.0"/>HaveDoubleFaultExt()
    return IsFeatureImplemented(FEAT_DoubleFault);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDoubleLock"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDoubleLock</h3>
      <p class="pseudocode">// HaveDoubleLock()
// ================
// Returns TRUE if support for the OS Double Lock is implemented.

boolean <a id="impl-shared.HaveDoubleLock.0"/>HaveDoubleLock()
    return IsFeatureImplemented(FEAT_DoubleLock);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveE0PDExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveE0PDExt</h3>
      <p class="pseudocode">// HaveE0PDExt()
// =============
// Returns TRUE if support for constant fault times for unprivileged accesses
// to the memory map is implemented.

boolean <a id="impl-shared.HaveE0PDExt.0"/>HaveE0PDExt()
    return IsFeatureImplemented(FEAT_E0PD);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveEBF16"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveEBF16</h3>
      <p class="pseudocode">// HaveEBF16()
// ===========
// Returns TRUE if the EBF16 extension is implemented, FALSE otherwise.

boolean <a id="impl-shared.HaveEBF16.0"/>HaveEBF16()
    return IsFeatureImplemented(FEAT_EBF16);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveECVExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveECVExt</h3>
      <p class="pseudocode">// HaveECVExt()
// ============
// Returns TRUE if Enhanced Counter Virtualization extension
// support is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveECVExt.0"/>HaveECVExt()
    return IsFeatureImplemented(FEAT_ECV);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveETExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveETExt</h3>
      <p class="pseudocode">// HaveETExt()
// ===========
// Returns TRUE if Embedded Trace Extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveETExt.0"/>HaveETExt()
    return IsFeatureImplemented(FEAT_ETE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveExtendedCacheSets"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveExtendedCacheSets</h3>
      <p class="pseudocode">// HaveExtendedCacheSets()
// =======================

boolean <a id="impl-shared.HaveExtendedCacheSets.0"/>HaveExtendedCacheSets()
    return IsFeatureImplemented(FEAT_CCIDX);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveExtendedECDebugEvents"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveExtendedECDebugEvents</h3>
      <p class="pseudocode">// HaveExtendedECDebugEvents()
// ===========================

boolean <a id="impl-shared.HaveExtendedECDebugEvents.0"/>HaveExtendedECDebugEvents()
    return IsFeatureImplemented(FEAT_Debugv8p2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveExtendedExecuteNeverExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveExtendedExecuteNeverExt</h3>
      <p class="pseudocode">// HaveExtendedExecuteNeverExt()
// =============================

boolean <a id="impl-shared.HaveExtendedExecuteNeverExt.0"/>HaveExtendedExecuteNeverExt()
    return IsFeatureImplemented(FEAT_XNX);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFCADDExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFCADDExt</h3>
      <p class="pseudocode">// HaveFCADDExt()
// ==============

boolean <a id="impl-shared.HaveFCADDExt.0"/>HaveFCADDExt()
    return IsFeatureImplemented(FEAT_FCMA);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFGTExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFGTExt</h3>
      <p class="pseudocode">// HaveFGTExt()
// ============
// Returns TRUE if Fine Grained Trap is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveFGTExt.0"/>HaveFGTExt()
    return IsFeatureImplemented(FEAT_FGT);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFJCVTZSExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFJCVTZSExt</h3>
      <p class="pseudocode">// HaveFJCVTZSExt()
// ================

boolean <a id="impl-shared.HaveFJCVTZSExt.0"/>HaveFJCVTZSExt()
    return IsFeatureImplemented(FEAT_JSCVT);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFP16MulNoRoundingToFP32Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFP16MulNoRoundingToFP32Ext</h3>
      <p class="pseudocode">// HaveFP16MulNoRoundingToFP32Ext()
// ================================
// Returns TRUE if has FP16 multiply with no intermediate rounding accumulate
// to FP32 instructions, and FALSE otherwise

boolean <a id="impl-shared.HaveFP16MulNoRoundingToFP32Ext.0"/>HaveFP16MulNoRoundingToFP32Ext()
    return IsFeatureImplemented(FEAT_FHM);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatCLRBHB"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatCLRBHB</h3>
      <p class="pseudocode">// HaveFeatCLRBHB()
// ================
// Returns TRUE if the CLRBHB instruction is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatCLRBHB.0"/>HaveFeatCLRBHB()
    return IsFeatureImplemented(FEAT_CLRBHB);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatCMOW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatCMOW</h3>
      <p class="pseudocode">// HaveFeatCMOW()
// ==============
// Returns TRUE if the SCTLR_EL1.CMOW bit is implemented and the SCTLR_EL2.CMOW and
// HCRX_EL2.CMOW bits are implemented if EL2 is implemented.

boolean <a id="impl-shared.HaveFeatCMOW.0"/>HaveFeatCMOW()
    return IsFeatureImplemented(FEAT_CMOW);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatEBEP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatEBEP</h3>
      <p class="pseudocode">// HaveFeatEBEP()
// ==============
// Returns TRUE if the PMU exception is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatEBEP.0"/>HaveFeatEBEP()
    return IsFeatureImplemented(FEAT_EBEP);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatHBC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatHBC</h3>
      <p class="pseudocode">// HaveFeatHBC()
// =============
// Returns TRUE if the BC instruction is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatHBC.0"/>HaveFeatHBC()
    return IsFeatureImplemented(FEAT_HBC);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatHCX"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatHCX</h3>
      <p class="pseudocode">// HaveFeatHCX()
// =============
// Returns TRUE if HCRX_EL2 Trap Control register is implemented,
// and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatHCX.0"/>HaveFeatHCX()
    return IsFeatureImplemented(FEAT_HCX);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatHPMN0"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatHPMN0</h3>
      <p class="pseudocode">// HaveFeatHPMN0()
// ===============
// Returns TRUE if HDCR.HPMN or MDCR_EL2.HPMN is permitted to be 0 without
// generating UNPREDICTABLE behavior, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatHPMN0.0"/>HaveFeatHPMN0()
    return IsFeatureImplemented(FEAT_HPMN0);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatLS64"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatLS64</h3>
      <p class="pseudocode">// HaveFeatLS64()
// ==============
// Returns TRUE if the LD64B, ST64B instructions are
// supported, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatLS64.0"/>HaveFeatLS64()
    return IsFeatureImplemented(FEAT_LS64);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatLS64_ACCDATA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatLS64_ACCDATA</h3>
      <p class="pseudocode">// HaveFeatLS64_ACCDATA()
// ======================
// Returns TRUE if the ST64BV0 instruction is
// supported, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatLS64_ACCDATA.0"/>HaveFeatLS64_ACCDATA()
    return IsFeatureImplemented(FEAT_LS64_ACCDATA);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatLS64_V"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatLS64_V</h3>
      <p class="pseudocode">// HaveFeatLS64_V()
// ================
// Returns TRUE if the ST64BV instruction is
// supported, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatLS64_V.0"/>HaveFeatLS64_V()
    return IsFeatureImplemented(FEAT_LS64_V);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatMEC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatMEC</h3>
      <p class="pseudocode">// HaveFeatMEC()
// =============
// Returns TRUE if Memory Encryption Contexts are implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatMEC.0"/>HaveFeatMEC()
    return IsFeatureImplemented(FEAT_MEC);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatMOPS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatMOPS</h3>
      <p class="pseudocode">// HaveFeatMOPS()
// ==============
// Returns TRUE if the CPY* and SET* instructions are supported, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatMOPS.0"/>HaveFeatMOPS()
    return IsFeatureImplemented(FEAT_MOPS);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatNMI"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatNMI</h3>
      <p class="pseudocode">// HaveFeatNMI()
// =============
// Returns TRUE if the Non-Maskable Interrupt extension is
// implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatNMI.0"/>HaveFeatNMI()
    return IsFeatureImplemented(FEAT_NMI);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatRPRES"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatRPRES</h3>
      <p class="pseudocode">// HaveFeatRPRES()
// ===============
// Returns TRUE if reciprocal estimate implements 12-bit precision
// when FPCR.AH=1, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatRPRES.0"/>HaveFeatRPRES()
    return IsFeatureImplemented(FEAT_RPRES);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatSCTLR2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatSCTLR2</h3>
      <p class="pseudocode">// HaveFeatSCTLR2()
// ================
// Returns TRUE if SCTLR2 extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatSCTLR2.0"/>HaveFeatSCTLR2()
    return IsFeatureImplemented(FEAT_SCTLR2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatTCR2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatTCR2</h3>
      <p class="pseudocode">// HaveFeatTCR2()
// ==============
// Returns TRUE if TCR2 extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatTCR2.0"/>HaveFeatTCR2()
    return IsFeatureImplemented(FEAT_TCR2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatTIDCP1"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatTIDCP1</h3>
      <p class="pseudocode">// HaveFeatTIDCP1()
// ================
// Returns TRUE if the SCTLR_EL1.TIDCP bit is implemented and the SCTLR_EL2.TIDCP bit
// is implemented if EL2 is implemented.

boolean <a id="impl-shared.HaveFeatTIDCP1.0"/>HaveFeatTIDCP1()
    return IsFeatureImplemented(FEAT_TIDCP1);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatTRBEExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatTRBEExt</h3>
      <p class="pseudocode">// HaveFeatTRBEExt()
// =================
// Returns TRUE if the Trace Buffer Extension external mode is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatTRBEExt.0"/>HaveFeatTRBEExt()
    return IsFeatureImplemented(FEAT_TRBE_EXT);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatWFxT"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatWFxT</h3>
      <p class="pseudocode">// HaveFeatWFxT()
// ==============
// Returns TRUE if WFET and WFIT instruction support is implemented,
// and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatWFxT.0"/>HaveFeatWFxT()
    return IsFeatureImplemented(FEAT_WFxT);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatXS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatXS</h3>
      <p class="pseudocode">// HaveFeatXS()
// ============
// Returns TRUE if XS attribute and the TLBI and DSB instructions with nXS qualifier
// are supported, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatXS.0"/>HaveFeatXS()
    return IsFeatureImplemented(FEAT_XS);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFlagFormatExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFlagFormatExt</h3>
      <p class="pseudocode">// HaveFlagFormatExt()
// ===================
// Returns TRUE if flag format conversion instructions implemented.

boolean <a id="impl-shared.HaveFlagFormatExt.0"/>HaveFlagFormatExt()
    return IsFeatureImplemented(FEAT_FlagM2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFlagManipulateExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFlagManipulateExt</h3>
      <p class="pseudocode">// HaveFlagManipulateExt()
// =======================
// Returns TRUE if flag manipulate instructions are implemented.

boolean <a id="impl-shared.HaveFlagManipulateExt.0"/>HaveFlagManipulateExt()
    return IsFeatureImplemented(FEAT_FlagM);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFrintExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFrintExt</h3>
      <p class="pseudocode">// HaveFrintExt()
// ==============
// Returns TRUE if FRINT instructions are implemented.

boolean <a id="impl-shared.HaveFrintExt.0"/>HaveFrintExt()
    return IsFeatureImplemented(FEAT_FRINTTS);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveGTGExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveGTGExt</h3>
      <p class="pseudocode">// HaveGTGExt()
// ============
// Returns TRUE if support for guest translation granule size is implemented.

boolean <a id="impl-shared.HaveGTGExt.0"/>HaveGTGExt()
    return IsFeatureImplemented(FEAT_GTG);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveHPMDExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveHPMDExt</h3>
      <p class="pseudocode">// HaveHPMDExt()
// =============

boolean <a id="impl-shared.HaveHPMDExt.0"/>HaveHPMDExt()
    return IsFeatureImplemented(FEAT_PMUv3p1);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveIDSExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveIDSExt</h3>
      <p class="pseudocode">// HaveIDSExt()
// ============
// Returns TRUE if ID register handling feature is implemented.

boolean <a id="impl-shared.HaveIDSExt.0"/>HaveIDSExt()
    return IsFeatureImplemented(FEAT_IDST);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveIESB"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveIESB</h3>
      <p class="pseudocode">// HaveIESB()
// ==========

boolean <a id="impl-shared.HaveIESB.0"/>HaveIESB()
    return IsFeatureImplemented(FEAT_IESB);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveInt8MatMulExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveInt8MatMulExt</h3>
      <p class="pseudocode">// HaveInt8MatMulExt()
// ===================
// Returns TRUE if AArch64 8-bit integer matrix multiply instruction support
// implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveInt8MatMulExt.0"/>HaveInt8MatMulExt()
    return IsFeatureImplemented(FEAT_I8MM);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveLRCPC3Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveLRCPC3Ext</h3>
      <p class="pseudocode">// HaveLRCPC3Ext()
// ===============
// Returns TRUE if FEAT_LRCPC3 instructions are supported, and FALSE otherwise.

boolean <a id="impl-shared.HaveLRCPC3Ext.0"/>HaveLRCPC3Ext()
    return IsFeatureImplemented(FEAT_LRCPC3);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveLSE128"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveLSE128</h3>
      <p class="pseudocode">// HaveLSE128()
// ============
// Returns TRUE if LSE128 is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveLSE128.0"/>HaveLSE128()
    return IsFeatureImplemented(FEAT_LSE128);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveLSE2Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveLSE2Ext</h3>
      <p class="pseudocode">// HaveLSE2Ext()
// =============
// Returns TRUE if LSE2 is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveLSE2Ext.0"/>HaveLSE2Ext()
    return IsFeatureImplemented(FEAT_LSE2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMPAMExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMPAMExt</h3>
      <p class="pseudocode">// HaveMPAMExt()
// =============
// Returns TRUE if MPAM is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveMPAMExt.0"/>HaveMPAMExt()
    return IsFeatureImplemented(FEAT_MPAM);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMPAMv0p1Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMPAMv0p1Ext</h3>
      <p class="pseudocode">// HaveMPAMv0p1Ext()
// =================
// Returns TRUE if MPAMv0p1 is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveMPAMv0p1Ext.0"/>HaveMPAMv0p1Ext()
    return IsFeatureImplemented(FEAT_MPAMv0p1);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMPAMv1p1Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMPAMv1p1Ext</h3>
      <p class="pseudocode">// HaveMPAMv1p1Ext()
// =================
// Returns TRUE if MPAMv1p1 is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveMPAMv1p1Ext.0"/>HaveMPAMv1p1Ext()
    return IsFeatureImplemented(FEAT_MPAMv1p1);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMTE2Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMTE2Ext</h3>
      <p class="pseudocode">// HaveMTE2Ext()
// =============
// Returns TRUE if MTE support is beyond EL0, and FALSE otherwise.

boolean <a id="impl-shared.HaveMTE2Ext.0"/>HaveMTE2Ext()
    return IsFeatureImplemented(FEAT_MTE2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMTE4Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMTE4Ext</h3>
      <p class="pseudocode">// HaveMTE4Ext()
// =============
// Returns TRUE if functionality in FEAT_MTE4 is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveMTE4Ext.0"/>HaveMTE4Ext()
    return IsFeatureImplemented(FEAT_MTE4);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMTEAsymFaultExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMTEAsymFaultExt</h3>
      <p class="pseudocode">// HaveMTEAsymFaultExt()
// =====================
// Returns TRUE if MTE Asymmetric Fault Handling support is
// implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveMTEAsymFaultExt.0"/>HaveMTEAsymFaultExt()
    return IsFeatureImplemented(FEAT_MTE4);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMTEAsyncExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMTEAsyncExt</h3>
      <p class="pseudocode">// HaveMTEAsyncExt()
// =================
// Returns TRUE if MTE supports Asynchronous faulting, and FALSE otherwise.

boolean <a id="impl-shared.HaveMTEAsyncExt.0"/>HaveMTEAsyncExt()
    return IsFeatureImplemented(FEAT_MTE4);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMTECanonicalTagCheckingExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMTECanonicalTagCheckingExt</h3>
      <p class="pseudocode">// HaveMTECanonicalTagCheckingExt()
// ================================
// Returns TRUE if MTE Canonical Tag Checking functionality is
// implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveMTECanonicalTagCheckingExt.0"/>HaveMTECanonicalTagCheckingExt()
    return IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMTEExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMTEExt</h3>
      <p class="pseudocode">// HaveMTEExt()
// ============
// Returns TRUE if instruction-only MTE implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveMTEExt.0"/>HaveMTEExt()
    return IsFeatureImplemented(FEAT_MTE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMTEPermExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMTEPermExt</h3>
      <p class="pseudocode">// HaveMTEPermExt()
// ================
// Returns TRUE if MTE_PERM implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveMTEPermExt.0"/>HaveMTEPermExt()
    return IsFeatureImplemented(FEAT_MTE_PERM);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMTEStoreOnlyExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMTEStoreOnlyExt</h3>
      <p class="pseudocode">// HaveMTEStoreOnlyExt()
// =====================
// Returns TRUE if MTE Store-only Tag Checking functionality is
// implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveMTEStoreOnlyExt.0"/>HaveMTEStoreOnlyExt()
    return IsFeatureImplemented(FEAT_MTE_STORE_ONLY);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveNV2Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveNV2Ext</h3>
      <p class="pseudocode">// HaveNV2Ext()
// ============
// Returns TRUE if Enhanced Nested Virtualization is implemented.

boolean <a id="impl-shared.HaveNV2Ext.0"/>HaveNV2Ext()
    return IsFeatureImplemented(FEAT_NV2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveNVExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveNVExt</h3>
      <p class="pseudocode">// HaveNVExt()
// ===========
// Returns TRUE if Nested Virtualization is implemented.

boolean <a id="impl-shared.HaveNVExt.0"/>HaveNVExt()
    return IsFeatureImplemented(FEAT_NV);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveNoSecurePMUDisableOverride"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveNoSecurePMUDisableOverride</h3>
      <p class="pseudocode">// HaveNoSecurePMUDisableOverride()
// ================================

boolean <a id="impl-shared.HaveNoSecurePMUDisableOverride.0"/>HaveNoSecurePMUDisableOverride()
    return IsFeatureImplemented(FEAT_Debugv8p2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveNoninvasiveDebugAuth"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveNoninvasiveDebugAuth</h3>
      <p class="pseudocode">// HaveNoninvasiveDebugAuth()
// ==========================
// Returns TRUE if the Non-invasive debug controls are implemented.

boolean <a id="impl-shared.HaveNoninvasiveDebugAuth.0"/>HaveNoninvasiveDebugAuth()
    return !IsFeatureImplemented(FEAT_Debugv8p4);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePAN3Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePAN3Ext</h3>
      <p class="pseudocode">// HavePAN3Ext()
// =============
// Returns TRUE if SCTLR_EL1.EPAN and SCTLR_EL2.EPAN support is implemented,
// and FALSE otherwise.

boolean <a id="impl-shared.HavePAN3Ext.0"/>HavePAN3Ext()
    return IsFeatureImplemented(FEAT_PAN3);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePANExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePANExt</h3>
      <p class="pseudocode">// HavePANExt()
// ============

boolean <a id="impl-shared.HavePANExt.0"/>HavePANExt()
    return IsFeatureImplemented(FEAT_PAN);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePMUv3"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePMUv3</h3>
      <p class="pseudocode">// HavePMUv3()
// ===========
// Returns TRUE if the Performance Monitors extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HavePMUv3.0"/>HavePMUv3()
    return IsFeatureImplemented(FEAT_PMUv3);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePMUv3ICNTR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePMUv3ICNTR</h3>
      <p class="pseudocode">// HavePMUv3ICNTR()
// ================
// Returns TRUE if support for the Fixed-function instruction counter is
// implemented, and FALSE otherwise.

boolean <a id="impl-shared.HavePMUv3ICNTR.0"/>HavePMUv3ICNTR()
    return IsFeatureImplemented(FEAT_PMUv3_ICNTR);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePMUv3TH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePMUv3TH</h3>
      <p class="pseudocode">// HavePMUv3TH()
// =============
// Returns TRUE if the PMUv3 threshold extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HavePMUv3TH.0"/>HavePMUv3TH()
    return IsFeatureImplemented(FEAT_PMUv3_TH);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePMUv3p1"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePMUv3p1</h3>
      <p class="pseudocode">// HavePMUv3p1()
// =============
// Returns TRUE if the Performance Monitors extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HavePMUv3p1.0"/>HavePMUv3p1()
    return IsFeatureImplemented(FEAT_PMUv3p1);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePMUv3p4"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePMUv3p4</h3>
      <p class="pseudocode">// HavePMUv3p4()
// =============
// Returns TRUE if the PMUv3.4 extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HavePMUv3p4.0"/>HavePMUv3p4()
    return IsFeatureImplemented(FEAT_PMUv3p4);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePMUv3p5"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePMUv3p5</h3>
      <p class="pseudocode">// HavePMUv3p5()
// =============
// Returns TRUE if the PMUv3.5 extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HavePMUv3p5.0"/>HavePMUv3p5()
    return IsFeatureImplemented(FEAT_PMUv3p5);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePMUv3p7"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePMUv3p7</h3>
      <p class="pseudocode">// HavePMUv3p7()
// =============
// Returns TRUE if the PMUv3.7 extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HavePMUv3p7.0"/>HavePMUv3p7()
    return IsFeatureImplemented(FEAT_PMUv3p7);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePageBasedHardwareAttributes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePageBasedHardwareAttributes</h3>
      <p class="pseudocode">// HavePageBasedHardwareAttributes()
// =================================

boolean <a id="impl-shared.HavePageBasedHardwareAttributes.0"/>HavePageBasedHardwareAttributes()
    return IsFeatureImplemented(FEAT_HPDS2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveQRDMLAHExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveQRDMLAHExt</h3>
      <p class="pseudocode">// HaveQRDMLAHExt()
// ================

boolean <a id="impl-shared.HaveQRDMLAHExt.0"/>HaveQRDMLAHExt()
    return IsFeatureImplemented(FEAT_RDM);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveRASExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveRASExt</h3>
      <p class="pseudocode">// HaveRASExt()
// ============

boolean <a id="impl-shared.HaveRASExt.0"/>HaveRASExt()
    return IsFeatureImplemented(FEAT_RAS);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveRASv2Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveRASv2Ext</h3>
      <p class="pseudocode">// HaveRASv2Ext()
// ==============
// Returns TRUE if support for RASv2 is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveRASv2Ext.0"/>HaveRASv2Ext()
    return IsFeatureImplemented(FEAT_RASv2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveRME"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveRME</h3>
      <p class="pseudocode">// HaveRME()
// =========
// Returns TRUE if the Realm Management Extension is implemented, and FALSE
// otherwise.

boolean <a id="impl-shared.HaveRME.0"/>HaveRME()
    return IsFeatureImplemented(FEAT_RME);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveRNG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveRNG</h3>
      <p class="pseudocode">// HaveRNG()
// =========
// Returns TRUE if Random Number Generator extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.HaveRNG.0"/>HaveRNG()
    return IsFeatureImplemented(FEAT_RNG);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveS1PIExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveS1PIExt</h3>
      <p class="pseudocode">// HaveS1PIExt()
// =============
// Returns TRUE if the S1 Permission Indirection extension is
// implemented and FALSE otherwise.

boolean <a id="impl-shared.HaveS1PIExt.0"/>HaveS1PIExt()
    return IsFeatureImplemented(FEAT_S1PIE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveS1POExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveS1POExt</h3>
      <p class="pseudocode">// HaveS1POExt()
// =============
// Returns TRUE if the S1 Permission Overlay extension is
// implemented and FALSE otherwise.

boolean <a id="impl-shared.HaveS1POExt.0"/>HaveS1POExt()
    return IsFeatureImplemented(FEAT_S1POE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveS2PIExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveS2PIExt</h3>
      <p class="pseudocode">// HaveS2PIExt()
// =============
// Returns TRUE if the S2 Permission Indirection extension is
// implemented and FALSE otherwise.

boolean <a id="impl-shared.HaveS2PIExt.0"/>HaveS2PIExt()
    return IsFeatureImplemented(FEAT_S2PIE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveS2POExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveS2POExt</h3>
      <p class="pseudocode">// HaveS2POExt()
// =============
// Returns TRUE if the S2 Permission Overlay extension is
// implemented and FALSE otherwise.

boolean <a id="impl-shared.HaveS2POExt.0"/>HaveS2POExt()
    return IsFeatureImplemented(FEAT_S2POE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSBExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSBExt</h3>
      <p class="pseudocode">// HaveSBExt()
// ===========
// Returns TRUE if support for SB is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveSBExt.0"/>HaveSBExt()
    return IsFeatureImplemented(FEAT_SB);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSSBSExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSSBSExt</h3>
      <p class="pseudocode">// HaveSSBSExt()
// =============
// Returns TRUE if support for SSBS is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveSSBSExt.0"/>HaveSSBSExt()
    return IsFeatureImplemented(FEAT_SSBS);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSecureEL2Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSecureEL2Ext</h3>
      <p class="pseudocode">// HaveSecureEL2Ext()
// ==================
// Returns TRUE if Secure EL2 is implemented.

boolean <a id="impl-shared.HaveSecureEL2Ext.0"/>HaveSecureEL2Ext()
    return IsFeatureImplemented(FEAT_SEL2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSecureExtDebugView"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSecureExtDebugView</h3>
      <p class="pseudocode">// HaveSecureExtDebugView()
// ========================
// Returns TRUE if support for Secure and Non-secure views of debug peripherals
// is implemented.

boolean <a id="impl-shared.HaveSecureExtDebugView.0"/>HaveSecureExtDebugView()
    return IsFeatureImplemented(FEAT_Debugv8p4);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSelfHostedTrace"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSelfHostedTrace</h3>
      <p class="pseudocode">// HaveSelfHostedTrace()
// =====================

boolean <a id="impl-shared.HaveSelfHostedTrace.0"/>HaveSelfHostedTrace()
    return IsFeatureImplemented(FEAT_TRF);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSmallTranslationTblExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSmallTranslationTblExt</h3>
      <p class="pseudocode">// HaveSmallTranslationTblExt()
// ============================
// Returns TRUE if Small Translation Table Support is implemented.

boolean <a id="impl-shared.HaveSmallTranslationTableExt.0"/>HaveSmallTranslationTableExt()
    return IsFeatureImplemented(FEAT_TTST);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSoftwareLock"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSoftwareLock</h3>
      <p class="pseudocode">// HaveSoftwareLock()
// ==================
// Returns TRUE if Software Lock is implemented.

boolean <a id="impl-shared.HaveSoftwareLock.1"/>HaveSoftwareLock(<a href="shared_pseudocode.html#Component" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component</a> component)
    if <a href="shared_pseudocode.html#impl-shared.Havev8p4Debug.0" title="function: boolean Havev8p4Debug()">Havev8p4Debug</a>() then
        return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveDoPD.0" title="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; component != <a href="shared_pseudocode.html#Component_CTI" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_CTI</a> then
        return FALSE;
    case component of
        when <a href="shared_pseudocode.html#Component_Debug" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_Debug</a>
            return boolean IMPLEMENTATION_DEFINED "Debug has Software Lock";
        when <a href="shared_pseudocode.html#Component_PMU" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_PMU</a>
            return boolean IMPLEMENTATION_DEFINED "PMU has Software Lock";
        when <a href="shared_pseudocode.html#Component_CTI" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_CTI</a>
            return boolean IMPLEMENTATION_DEFINED "CTI has Software Lock";
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveStage2MemAttrControl"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveStage2MemAttrControl</h3>
      <p class="pseudocode">// HaveStage2MemAttrControl()
// ==========================
// Returns TRUE if support for Stage2 control of memory types and cacheability
// attributes is implemented.

boolean <a id="impl-shared.HaveStage2MemAttrControl.0"/>HaveStage2MemAttrControl()
    return IsFeatureImplemented(FEAT_S2FWB);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveStatisticalProfiling"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveStatisticalProfiling</h3>
      <p class="pseudocode">// HaveStatisticalProfiling()
// ==========================
// Returns TRUE if Statistical Profiling Extension is implemented,
// and FALSE otherwise.

boolean <a id="impl-shared.HaveStatisticalProfiling.0"/>HaveStatisticalProfiling()
    return IsFeatureImplemented(FEAT_SPE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveStatisticalProfilingv1p1"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveStatisticalProfilingv1p1</h3>
      <p class="pseudocode">// HaveStatisticalProfilingv1p1()
// ==============================
// Returns TRUE if the SPEv1p1 extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveStatisticalProfilingv1p1.0"/>HaveStatisticalProfilingv1p1()
    return IsFeatureImplemented(FEAT_SPEv1p1);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveStatisticalProfilingv1p2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveStatisticalProfilingv1p2</h3>
      <p class="pseudocode">// HaveStatisticalProfilingv1p2()
// ==============================
// Returns TRUE if the SPEv1p2 extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveStatisticalProfilingv1p2.0"/>HaveStatisticalProfilingv1p2()
    return IsFeatureImplemented(FEAT_SPEv1p2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSysInstr128"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSysInstr128</h3>
      <p class="pseudocode">// HaveSysInstr128()
// =================
// Returns TRUE if support for System Instructions that can
// take 128-bit inputs is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveSysInstr128.0"/>HaveSysInstr128()
    return IsFeatureImplemented(FEAT_SYSINSTR128);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSysReg128"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSysReg128</h3>
      <p class="pseudocode">// HaveSysReg128()
// ===============
// Returns TRUE if support for 128-bit System Registers is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveSysReg128.0"/>HaveSysReg128()
    return IsFeatureImplemented(FEAT_SYSREG128);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveTHExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveTHExt</h3>
      <p class="pseudocode">// HaveTHExt()
// ===========
// Returns TRUE if support for Translation Hardening Extension is implemented.

boolean <a id="impl-shared.HaveTHExt.0"/>HaveTHExt()
    return IsFeatureImplemented(FEAT_THE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveTME"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveTME</h3>
      <p class="pseudocode">// HaveTME()
// =========

boolean <a id="impl-shared.HaveTME.0"/>HaveTME()
    return IsFeatureImplemented(FEAT_TME);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveTWEDExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveTWEDExt</h3>
      <p class="pseudocode">// HaveTWEDExt()
// =============
// Returns TRUE if Delayed Trapping of WFE instruction support is implemented,
// and FALSE otherwise.

boolean <a id="impl-shared.HaveTWEDExt.0"/>HaveTWEDExt()
    return IsFeatureImplemented(FEAT_TWED);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveTraceBufferExtension"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveTraceBufferExtension</h3>
      <p class="pseudocode">// HaveTraceBufferExtension()
// ==========================
// Returns TRUE if Trace Buffer Extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveTraceBufferExtension.0"/>HaveTraceBufferExtension()
    return IsFeatureImplemented(FEAT_TRBE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveTraceExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveTraceExt</h3>
      <p class="pseudocode">// HaveTraceExt()
// ==============
// Returns TRUE if Trace functionality as described by the Trace Architecture
// is implemented.

boolean <a id="impl-shared.HaveTraceExt.0"/>HaveTraceExt()
    return boolean IMPLEMENTATION_DEFINED "Has Trace Architecture functionality";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveTrapLoadStoreMultipleDeviceExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveTrapLoadStoreMultipleDeviceExt</h3>
      <p class="pseudocode">// HaveTrapLoadStoreMultipleDeviceExt()
// ====================================

boolean <a id="impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0"/>HaveTrapLoadStoreMultipleDeviceExt()
    return IsFeatureImplemented(FEAT_LSMAOC);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveUAOExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveUAOExt</h3>
      <p class="pseudocode">// HaveUAOExt()
// ============

boolean <a id="impl-shared.HaveUAOExt.0"/>HaveUAOExt()
    return IsFeatureImplemented(FEAT_UAO);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveV82Debug"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveV82Debug</h3>
      <p class="pseudocode">// HaveV82Debug()
// ==============

boolean <a id="impl-shared.HaveV82Debug.0"/>HaveV82Debug()
    return IsFeatureImplemented(FEAT_Debugv8p2);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveVirtHostExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveVirtHostExt</h3>
      <p class="pseudocode">// HaveVirtHostExt()
// =================

boolean <a id="impl-shared.HaveVirtHostExt.0"/>HaveVirtHostExt()
    return IsFeatureImplemented(FEAT_VHE);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Havev8p4Debug"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Havev8p4Debug</h3>
      <p class="pseudocode">// Havev8p4Debug()
// ===============
// Returns TRUE if support for the Debugv8p4 feature is implemented and FALSE otherwise.

boolean <a id="impl-shared.Havev8p4Debug.0"/>Havev8p4Debug()
    return IsFeatureImplemented(FEAT_Debugv8p4);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Havev8p8Debug"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Havev8p8Debug</h3>
      <p class="pseudocode">// Havev8p8Debug()
// ===============
// Returns TRUE if support for the Debugv8p8 feature is implemented and FALSE otherwise.

boolean <a id="impl-shared.Havev8p8Debug.0"/>Havev8p8Debug()
    return IsFeatureImplemented(FEAT_Debugv8p8);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Havev8p9Debug"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Havev8p9Debug</h3>
      <p class="pseudocode">// Havev8p9Debug()
// ===============
// Returns TRUE if support for the Debugv8p9 feature is implemented, and FALSE otherwise.

boolean <a id="impl-shared.Havev8p9Debug.0"/>Havev8p9Debug()
    return IsFeatureImplemented(FEAT_Debugv8p9);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.InsertIESBBeforeException"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/InsertIESBBeforeException</h3>
      <p class="pseudocode">// InsertIESBBeforeException()
// ===========================
// Returns an implementation defined choice whether to insert an implicit error synchronization
// barrier before exception.
// If SCTLR_ELx.IESB is 1 when an exception is generated to ELx, any pending Unrecoverable
// SError interrupt must be taken before executing any instructions in the exception handler.
// However, this can be before the branch to the exception handler is made.

boolean <a id="impl-shared.InsertIESBBeforeException.1"/>InsertIESBBeforeException(bits(2) el)
    return (<a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()">HaveIESB</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED
            "Has Implicit Error Synchronization Barrier before <a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a>");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.IsG1ActivityMonitorImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/IsG1ActivityMonitorImplemented</h3>
      <p class="pseudocode">// Returns TRUE if a G1 activity monitor is implemented for the counter
// and FALSE otherwise.
boolean <a id="impl-shared.IsG1ActivityMonitorImplemented.1"/>IsG1ActivityMonitorImplemented(integer i);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.IsG1ActivityMonitorOffsetImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/IsG1ActivityMonitorOffsetImplemented</h3>
      <p class="pseudocode">// Returns TRUE if a G1 activity monitor offset is implemented for the counter,
// and FALSE otherwise.
boolean <a id="impl-shared.IsG1ActivityMonitorOffsetImplemented.1"/>IsG1ActivityMonitorOffsetImplemented(integer i);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.AArch32.PEErrorState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/AArch32.PEErrorState</h3>
      <p class="pseudocode">// AArch32.PEErrorState()
// ======================
// Returns the error state by PE on taking an SError Interrupt
// to AArch32 level.

ErrorState <a id="AArch32.PEErrorState.1"/>AArch32.PEErrorState(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    if (!<a href="shared_pseudocode.html#impl-shared.ErrorIsContained.0" title="function: boolean ErrorIsContained()">ErrorIsContained</a>() ||
        (!<a href="shared_pseudocode.html#impl-shared.ErrorIsSynchronized.0" title="function: boolean ErrorIsSynchronized()">ErrorIsSynchronized</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.StateIsRecoverable.0" title="function: boolean StateIsRecoverable()">StateIsRecoverable</a>()) ||
         <a href="shared_pseudocode.html#impl-shared.ReportErrorAsUC.0" title="function: boolean ReportErrorAsUC()">ReportErrorAsUC</a>()) then
        return <a href="shared_pseudocode.html#ErrorState_UC" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UC</a>;

    if !<a href="shared_pseudocode.html#impl-shared.StateIsRecoverable.0" title="function: boolean StateIsRecoverable()">StateIsRecoverable</a>() || <a href="shared_pseudocode.html#impl-shared.ReportErrorAsUEU.0" title="function: boolean ReportErrorAsUEU()">ReportErrorAsUEU</a>() then
        return <a href="shared_pseudocode.html#ErrorState_UEU" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UEU</a>;

    if <a href="shared_pseudocode.html#impl-shared.ActionRequired.0" title="function: boolean ActionRequired()">ActionRequired</a>() || <a href="shared_pseudocode.html#impl-shared.ReportErrorAsUER.0" title="function: boolean ReportErrorAsUER()">ReportErrorAsUER</a>() then
        return <a href="shared_pseudocode.html#ErrorState_UER" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UER</a>;

    return <a href="shared_pseudocode.html#ErrorState_UEO" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UEO</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.AArch64.PEErrorState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/AArch64.PEErrorState</h3>
      <p class="pseudocode">// AArch64.PEErrorState()
// ======================
// Returns the error state by PE on taking a Synchronous
// or Asynchronous exception.

ErrorState <a id="AArch64.PEErrorState.1"/>AArch64.PEErrorState(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    if !<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ExtAbortToA64.1" title="function: boolean ExtAbortToA64(FaultRecord fault)">ExtAbortToA64</a>(fault) then
        if <a href="shared_pseudocode.html#impl-shared.ReportErrorAsUncategorized.0" title="function: boolean ReportErrorAsUncategorized()">ReportErrorAsUncategorized</a>() then
            return <a href="shared_pseudocode.html#ErrorState_Uncategorized" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_Uncategorized</a>;
        if <a href="shared_pseudocode.html#impl-shared.ReportErrorAsIMPDEF.0" title="function: boolean ReportErrorAsIMPDEF()">ReportErrorAsIMPDEF</a>() then
            return <a href="shared_pseudocode.html#ErrorState_IMPDEF" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_IMPDEF</a>;

    assert !<a href="shared_pseudocode.html#impl-shared.FaultIsCorrected.0" title="function: boolean FaultIsCorrected()">FaultIsCorrected</a>();
    if (!<a href="shared_pseudocode.html#impl-shared.ErrorIsContained.0" title="function: boolean ErrorIsContained()">ErrorIsContained</a>() ||
        (!<a href="shared_pseudocode.html#impl-shared.ErrorIsSynchronized.0" title="function: boolean ErrorIsSynchronized()">ErrorIsSynchronized</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.StateIsRecoverable.0" title="function: boolean StateIsRecoverable()">StateIsRecoverable</a>()) ||
         <a href="shared_pseudocode.html#impl-shared.ReportErrorAsUC.0" title="function: boolean ReportErrorAsUC()">ReportErrorAsUC</a>()) then
        return <a href="shared_pseudocode.html#ErrorState_UC" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UC</a>;

    if !<a href="shared_pseudocode.html#impl-shared.StateIsRecoverable.0" title="function: boolean StateIsRecoverable()">StateIsRecoverable</a>() || <a href="shared_pseudocode.html#impl-shared.ReportErrorAsUEU.0" title="function: boolean ReportErrorAsUEU()">ReportErrorAsUEU</a>() then
        if <a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) then  // Implies taken to AArch64
            return <a href="shared_pseudocode.html#ErrorState_UC" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UC</a>;
        else
            return <a href="shared_pseudocode.html#ErrorState_UEU" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UEU</a>;

    if (<a href="shared_pseudocode.html#impl-shared.ActionRequired.0" title="function: boolean ActionRequired()">ActionRequired</a>() || <a href="shared_pseudocode.html#impl-shared.ReportErrorAsUER.0" title="function: boolean ReportErrorAsUER()">ReportErrorAsUER</a>()) then
        return <a href="shared_pseudocode.html#ErrorState_UER" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UER</a>;

    return <a href="shared_pseudocode.html#ErrorState_UEO" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState_UEO</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ActionRequired"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ActionRequired</h3>
      <p class="pseudocode">// Return an implementation specific value:
// returns TRUE if action is required, FALSE otherwise.
boolean <a id="impl-shared.ActionRequired.0"/>ActionRequired();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ClearPendingPhysicalSError"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ClearPendingPhysicalSError</h3>
      <p class="pseudocode">// Clear a pending physical SError interrupt.
<a id="impl-shared.ClearPendingPhysicalSError.0"/>ClearPendingPhysicalSError();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ClearPendingVirtualSError"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ClearPendingVirtualSError</h3>
      <p class="pseudocode">// ClearPendingVirtualSError()
// ===========================
// Clear a pending virtual SError interrupt.

<a id="impl-shared.ClearPendingVirtualSError.0"/>ClearPendingVirtualSError()
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        HCR.VA = '0';
    else
        HCR_EL2.VSE = '0';</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ErrorIsContained"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ErrorIsContained</h3>
      <p class="pseudocode">// Return an implementation specific value:
// TRUE if Error is contained by the PE, FALSE otherwise.
boolean <a id="impl-shared.ErrorIsContained.0"/>ErrorIsContained();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ErrorIsSynchronized"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ErrorIsSynchronized</h3>
      <p class="pseudocode">// Return an implementation specific value:
// returns TRUE if Error is synchronized by any synchronization event
// FALSE otherwise.
boolean <a id="impl-shared.ErrorIsSynchronized.0"/>ErrorIsSynchronized();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ExtAbortToA64"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ExtAbortToA64</h3>
      <p class="pseudocode">// ExtAbortToA64()
// ===============
// Returns TRUE if synchronous exception is being taken to A64 exception
// level.

boolean <a id="impl-shared.ExtAbortToA64.1"/>ExtAbortToA64(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = (HCR_EL2.TGE == '1' || <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) ||
                            (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR_EL2.TEA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                            (<a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; MDCR_EL2.TDE == '1'));

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].EA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);

    return route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault.statuscode);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.FaultIsCorrected"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/FaultIsCorrected</h3>
      <p class="pseudocode">// Return an implementation specific value:
// TRUE if fault is corrected by the PE, FALSE otherwise.
boolean <a id="impl-shared.FaultIsCorrected.0"/>FaultIsCorrected();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.GetPendingPhysicalSError"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/GetPendingPhysicalSError</h3>
      <p class="pseudocode">// Returns the FaultRecord containing details of pending Physical SError
// interrupt.
FaultRecord <a id="impl-shared.GetPendingPhysicalSError.0"/>GetPendingPhysicalSError();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.HandleExternalAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/HandleExternalAbort</h3>
      <p class="pseudocode">// HandleExternalAbort()
// =====================
// Takes a Synchronous/Asynchronous abort based on fault.

<a id="impl-shared.HandleExternalAbort.5"/>HandleExternalAbort(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memretstatus, boolean iswrite,
                    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc, integer size,
                    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    assert (memretstatus.statuscode IN {<a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>, <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>} ||
           (!<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; memretstatus.statuscode IN {<a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>,
                                                         <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>}));

    fault = <a href="shared_pseudocode.html#impl-shared.NoFault.1" title="function: FaultRecord NoFault(AccessDescriptor accdesc)">NoFault</a>(accdesc);
    fault.statuscode = memretstatus.statuscode;
    fault.write      = iswrite;
    fault.extflag    = memretstatus.extflag;
    // It is implementation specific whether External aborts signaled
    // in-band synchronously are taken synchronously or asynchronously
    if (<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) &amp;&amp;
            !<a href="shared_pseudocode.html#impl-shared.IsExternalAbortTakenSynchronously.5" title="function: boolean IsExternalAbortTakenSynchronously(PhysMemRetStatus memstatus,&#13; boolean iswrite,&#13; AddressDescriptor desc,&#13; integer size,&#13; AccessDescriptor accdesc)">IsExternalAbortTakenSynchronously</a>(memretstatus, iswrite, memaddrdesc,
                                               size, accdesc)) then
        if fault.statuscode == <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>;
        else
            fault.statuscode = <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>;

    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() then
        fault.merrorstate = memretstatus.merrorstate;

    if <a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) then
        if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(memaddrdesc.vaddress&lt;31:0&gt;, fault);
        else
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(memaddrdesc.vaddress, fault);

    else
        <a href="shared_pseudocode.html#impl-shared.PendSErrorInterrupt.1" title="function: PendSErrorInterrupt(FaultRecord fault)">PendSErrorInterrupt</a>(fault);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.HandleExternalReadAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/HandleExternalReadAbort</h3>
      <p class="pseudocode">// HandleExternalReadAbort()
// =========================
// Wrapper function for HandleExternalAbort function in case of an External
// Abort on memory read.

<a id="impl-shared.HandleExternalReadAbort.4"/>HandleExternalReadAbort(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc,
                        integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    iswrite = FALSE;
    <a href="shared_pseudocode.html#impl-shared.HandleExternalAbort.5" title="function: HandleExternalAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc, integer size,&#13; AccessDescriptor accdesc)">HandleExternalAbort</a>(memstatus, iswrite, memaddrdesc, size, accdesc);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.HandleExternalTTWAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/HandleExternalTTWAbort</h3>
      <p class="pseudocode">// HandleExternalTTWAbort()
// ========================
// Take Asynchronous abort or update FaultRecord for Translation Table Walk
// based on PhysMemRetStatus.

FaultRecord <a id="impl-shared.HandleExternalTTWAbort.6"/>HandleExternalTTWAbort(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memretstatus, boolean iswrite,
                                   <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc,
                                   <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc, integer size,
                                   <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> input_fault)
    output_fault = input_fault;
    output_fault.extflag = memretstatus.extflag;
    output_fault.statuscode = memretstatus.statuscode;
    if (<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(output_fault) &amp;&amp;
            !<a href="shared_pseudocode.html#impl-shared.IsExternalAbortTakenSynchronously.5" title="function: boolean IsExternalAbortTakenSynchronously(PhysMemRetStatus memstatus,&#13; boolean iswrite,&#13; AddressDescriptor desc,&#13; integer size,&#13; AccessDescriptor accdesc)">IsExternalAbortTakenSynchronously</a>(memretstatus, iswrite, memaddrdesc,
                                               size, accdesc)) then
        if output_fault.statuscode == <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a> then
            output_fault.statuscode = <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>;
        else
            output_fault.statuscode = <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>;

    // If a synchronous fault is on a translation table walk, then update
    // the fault type
    if <a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(output_fault) then
        if output_fault.statuscode == <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a> then
            output_fault.statuscode = <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>;
        else
            output_fault.statuscode = <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>;
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() then
        output_fault.merrorstate = memretstatus.merrorstate;
    if !<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(output_fault) then
        <a href="shared_pseudocode.html#impl-shared.PendSErrorInterrupt.1" title="function: PendSErrorInterrupt(FaultRecord fault)">PendSErrorInterrupt</a>(output_fault);
        output_fault.statuscode = <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    return output_fault;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.HandleExternalWriteAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/HandleExternalWriteAbort</h3>
      <p class="pseudocode">// HandleExternalWriteAbort()
// ==========================
// Wrapper function for HandleExternalAbort function in case of an External
// Abort on memory write.

<a id="impl-shared.HandleExternalWriteAbort.4"/>HandleExternalWriteAbort(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc,
                         integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    iswrite = TRUE;
    <a href="shared_pseudocode.html#impl-shared.HandleExternalAbort.5" title="function: HandleExternalAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc, integer size,&#13; AccessDescriptor accdesc)">HandleExternalAbort</a>(memstatus, iswrite, memaddrdesc, size, accdesc);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.IsExternalAbortTakenSynchronously"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/IsExternalAbortTakenSynchronously</h3>
      <p class="pseudocode">// Return an implementation specific value:
// TRUE if the fault returned for the access can be taken synchronously,
// FALSE otherwise.
//
// This might vary between accesses, for example depending on the error type
// or memory type being accessed.
// External aborts on data accesses and translation table walks on data accesses
// can be either synchronous or asynchronous.
//
// When FEAT_DoubleFault is not implemented, External aborts on instruction
// fetches and translation table walks on instruction fetches can be either
// synchronous or asynchronous.
// When FEAT_DoubleFault is implemented, all External abort exceptions on
// instruction fetches and translation table walks on instruction fetches
// must be synchronous.
boolean <a id="impl-shared.IsExternalAbortTakenSynchronously.5"/>IsExternalAbortTakenSynchronously(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus,
                                          boolean iswrite,
                                          <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> desc,
                                          integer size,
                                          <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.IsPhysicalSErrorPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/IsPhysicalSErrorPending</h3>
      <p class="pseudocode">// Returns TRUE if a physical SError interrupt is pending.
boolean <a id="impl-shared.IsPhysicalSErrorPending.0"/>IsPhysicalSErrorPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.IsSErrorEdgeTriggered"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/IsSErrorEdgeTriggered</h3>
      <p class="pseudocode">// IsSErrorEdgeTriggered()
// =======================
// Returns TRUE if the physical SError interrupt is edge-triggered
// and FALSE otherwise.

boolean <a id="impl-shared.IsSErrorEdgeTriggered.2"/>IsSErrorEdgeTriggered(bits(2) target_el, bits(25) syndrome)
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then
            return TRUE;

        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) then
            if syndrome&lt;11:10&gt; != '00' then
                // AArch32 and not Uncontainable.
                return TRUE;
        else
            if syndrome&lt;24&gt; == '0' &amp;&amp; syndrome&lt;5:0&gt; != '000000' then
                // AArch64 and neither IMPLEMENTATION DEFINED syndrome nor Uncategorized.
                return TRUE;
    return boolean IMPLEMENTATION_DEFINED "Edge-triggered SError";</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.IsSynchronizablePhysicalSErrorPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/IsSynchronizablePhysicalSErrorPending</h3>
      <p class="pseudocode">// Returns TRUE if a synchronizable physical SError interrupt is pending.
boolean <a id="impl-shared.IsSynchronizablePhysicalSErrorPending.0"/>IsSynchronizablePhysicalSErrorPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.IsVirtualSErrorPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/IsVirtualSErrorPending</h3>
      <p class="pseudocode">// IsVirtualSErrorPending()
// ========================
// Return TRUE if a virtual SError interrupt is pending.

boolean <a id="impl-shared.IsVirtualSErrorPending.0"/>IsVirtualSErrorPending()
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        return HCR.VA == '1';
    else
        return HCR_EL2.VSE == '1';</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.PendSErrorInterrupt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/PendSErrorInterrupt</h3>
      <p class="pseudocode">// Pend the SError Interrupt.
<a id="impl-shared.PendSErrorInterrupt.1"/>PendSErrorInterrupt(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ReportErrorAsIMPDEF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ReportErrorAsIMPDEF</h3>
      <p class="pseudocode">// Return an implementation specific value:
// returns TRUE if Error is IMPDEF, FALSE otherwise.
boolean <a id="impl-shared.ReportErrorAsIMPDEF.0"/>ReportErrorAsIMPDEF();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ReportErrorAsUC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ReportErrorAsUC</h3>
      <p class="pseudocode">// Return an implementation specific value:
// returns TRUE if Error is Uncontainable, FALSE otherwise.
boolean <a id="impl-shared.ReportErrorAsUC.0"/>ReportErrorAsUC();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ReportErrorAsUER"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ReportErrorAsUER</h3>
      <p class="pseudocode">// Return an implementation specific value:
// returns TRUE if Error is Recoverable, FALSE otherwise.
boolean <a id="impl-shared.ReportErrorAsUER.0"/>ReportErrorAsUER();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ReportErrorAsUEU"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ReportErrorAsUEU</h3>
      <p class="pseudocode">// Return an implementation specific value:
// returns TRUE if Error is Unrecoverable, FALSE otherwise.
boolean <a id="impl-shared.ReportErrorAsUEU.0"/>ReportErrorAsUEU();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ReportErrorAsUncategorized"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ReportErrorAsUncategorized</h3>
      <p class="pseudocode">// Return an implementation specific value:
// returns TRUE if Error is uncategorized, FALSE otherwise.
boolean <a id="impl-shared.ReportErrorAsUncategorized.0"/>ReportErrorAsUncategorized();</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.StateIsRecoverable"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/StateIsRecoverable</h3>
      <p class="pseudocode">// Return an implementation specific value:
// returns TRUE is PE State is unrecoverable else FALSE.
boolean <a id="impl-shared.StateIsRecoverable.0"/>StateIsRecoverable();</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFAdd</h3>
      <p class="pseudocode">// BFAdd()
// =======
// Non-widening BFloat16 addition used by SVE2 instructions.

bits(16) <a id="impl-shared.BFAdd.3"/>BFAdd(bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;
    return <a href="shared_pseudocode.html#impl-shared.BFAdd.4" title="function: bits(16) BFAdd(bits(16) op1, bits(16) op2, FPCRType fpcr, boolean fpexc)">BFAdd</a>(op1, op2, fpcr, fpexc);

// BFAdd()
// =======
// Non-widening BFloat16 addition following computational behaviors
// corresponding to instructions that read and write BFloat16 values.
// Calculates op1 + op2.
// The 'fpcr' argument supplies the FPCR control bits.

bits(16) <a id="impl-shared.BFAdd.4"/>BFAdd(bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    boolean done;
    bits(32) result;

    bits(32) op1_s = op1 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    bits(32) op2_s = op2 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1_s, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2_s, fpcr, fpexc);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.6" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1_s, op2_s, fpcr, fpexc);

    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, 32);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('0', 32);
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('1', 32);
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign1, 32);
        else
            result_value = value1 + value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(result_sign, 32);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRoundBF.4" title="function: bits(32) FPRoundBF(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRoundBF</a>(result_value, fpcr, rounding, fpexc);

        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, 32, fpcr);

    return result&lt;31:16&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFAdd_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFAdd_ZA</h3>
      <p class="pseudocode">// BFAdd_ZA()
// ==========
// Non-widening BFloat16 addition used by SME2 ZA-targeting instructions.

bits(16) <a id="impl-shared.BFAdd_ZA.3"/>BFAdd_ZA(bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)
    boolean fpexc = FALSE;
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.DN = '1';          // Generate default NaN values
    return <a href="shared_pseudocode.html#impl-shared.BFAdd.4" title="function: bits(16) BFAdd(bits(16) op1, bits(16) op2, FPCRType fpcr, boolean fpexc)">BFAdd</a>(op1, op2, fpcr, fpexc);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFDotAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFDotAdd</h3>
      <p class="pseudocode">// BFDotAdd()
// ==========
// BFloat16 2-way dot-product and add to single-precision
// result = addend + op1_a*op2_a + op1_b*op2_b

bits(32) <a id="impl-shared.BFDotAdd.6"/>BFDotAdd(bits(32) addend, bits(16) op1_a, bits(16) op1_b,
                  bits(16) op2_a, bits(16) op2_b, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;

    bits(32) prod;

    bits(32) result;
    if !<a href="shared_pseudocode.html#impl-shared.HaveEBF16.0" title="function: boolean HaveEBF16()">HaveEBF16</a>() || fpcr.EBF == '0' then   // Standard BFloat16 behaviors
        prod = <a href="shared_pseudocode.html#impl-shared.FPAdd_BF16.2" title="function: bits(32) FPAdd_BF16(bits(32) op1, bits(32) op2)">FPAdd_BF16</a>(<a href="shared_pseudocode.html#impl-shared.BFMulH.2" title="function: bits(32) BFMulH(bits(16) op1, bits(16) op2)">BFMulH</a>(op1_a, op2_a), <a href="shared_pseudocode.html#impl-shared.BFMulH.2" title="function: bits(32) BFMulH(bits(16) op1, bits(16) op2)">BFMulH</a>(op1_b, op2_b));
        result = <a href="shared_pseudocode.html#impl-shared.FPAdd_BF16.2" title="function: bits(32) FPAdd_BF16(bits(32) op1, bits(32) op2)">FPAdd_BF16</a>(addend, prod);
    else                                      // Extended BFloat16 behaviors
        boolean isbfloat16 = TRUE;
        boolean fpexc = FALSE;  // Do not generate floating-point exceptions
        fpcr.DN = '1';          // Generate default NaN values
        prod = <a href="shared_pseudocode.html#impl-shared.FPDot.7" title="function: bits(N) FPDot(bits(N DIV 2) op1_a, bits(N DIV 2) op1_b, bits(N DIV 2) op2_a,&#13; bits(N DIV 2) op2_b, FPCRType fpcr_in, boolean isbfloat16, boolean fpexc)">FPDot</a>(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
        result = <a href="shared_pseudocode.html#impl-shared.FPAdd.4" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPAdd</a>(addend, prod, fpcr, fpexc);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFInfinity"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFInfinity</h3>
      <p class="pseudocode">// BFInfinity()
// ============

bits(16) <a id="impl-shared.BFInfinity.1"/>BFInfinity(bit sign)
    return sign : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(8) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(7);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMatMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMatMulAdd</h3>
      <p class="pseudocode">// BFMatMulAdd()
// =============
// BFloat16 matrix multiply and add to single-precision matrix
// result[2, 2] = addend[2, 2] + (op1[2, 4] * op2[4, 2])

bits(N) <a id="impl-shared.BFMatMulAdd.3"/>BFMatMulAdd(bits(N) addend, bits(N) op1, bits(N) op2)

    assert N == 128;

    bits(N) result;
    bits(32) sum;

    for i = 0 to 1
        for j = 0 to 1
            sum = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[addend, 2*i + j, 32];
            for k = 0 to 1
                bits(16) elt1_a = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 4*i + 2*k + 0, 16];
                bits(16) elt1_b = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 4*i + 2*k + 1, 16];
                bits(16) elt2_a = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 4*j + 2*k + 0, 16];
                bits(16) elt2_b = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 4*j + 2*k + 1, 16];
                sum = <a href="shared_pseudocode.html#impl-shared.BFDotAdd.6" title="function: bits(32) BFDotAdd(bits(32) addend, bits(16) op1_a, bits(16) op1_b,&#13; bits(16) op2_a, bits(16) op2_b, FPCRType fpcr_in)">BFDotAdd</a>(sum, elt1_a, elt1_b, elt2_a, elt2_b, FPCR[]);
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, 2*i + j, 32] = sum;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMax"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMax</h3>
      <p class="pseudocode">// BFMax()
// =======
// BFloat16 maximum.

bits(16) <a id="impl-shared.BFMax.3"/>BFMax(bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    return <a href="shared_pseudocode.html#impl-shared.BFMax.4" title="function: bits(16) BFMax(bits(16) op1, bits(16) op2, FPCRType fpcr_in, boolean altfp)">BFMax</a>(op1, op2, fpcr, altfp);

// BFMax()
// =======
// BFloat16 maximum following computational behaviors
// corresponding to instructions that read and write BFloat16 values.
// Compare op1 and op2 and return the larger value after rounding.
// The 'fpcr' argument supplies the FPCR control bits and 'altfp' determines
// if the function should use alternative floating-point behavior.

bits(16) <a id="impl-shared.BFMax.4"/>BFMax(bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, boolean altfp)

    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    boolean fpexc = TRUE;
    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    boolean done;
    bits(32) result;

    bits(32) op1_s = op1 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    bits(32) op2_s = op2 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1_s, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2_s, fpcr, fpexc);

    if altfp &amp;&amp; type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp; sign1 != sign2 then
        // Alternate handling of zeros with differing sign
        return <a href="shared_pseudocode.html#impl-shared.BFZero.1" title="function: bits(16) BFZero(bit sign)">BFZero</a>(sign2);

    if altfp &amp;&amp; (type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>}) then
        // Alternate handling of NaN inputs
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        result = if type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then <a href="shared_pseudocode.html#impl-shared.BFZero.1" title="function: bits(16) BFZero(bit sign)">BFZero</a>(sign2) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16) else op2_s;
        done = TRUE;
    else
        (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1_s, op2_s, fpcr);

    if !done then
        <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype;
        bit sign;
        real value;
        if value1 &gt; value2 then
            (fptype,sign,value) = (type1,sign1,value1);
        else
            (fptype,sign,value) = (type2,sign2,value2);
        if fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, 32);
        elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
            sign = sign1 AND sign2;              // Use most positive sign
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, 32);
        else
            if altfp then    // Denormal output is not flushed to zero
                fpcr.FZ = '0';
            result = <a href="shared_pseudocode.html#impl-shared.FPRoundBF.4" title="function: bits(32) FPRoundBF(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRoundBF</a>(value, fpcr, rounding, fpexc);

        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, 32, fpcr);

    return result&lt;31:16&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMaxNum"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMaxNum</h3>
      <p class="pseudocode">// BFMaxNum()
// ==========
// BFloat16 maximum number following computational behaviors corresponding
// to instructions that read and write BFloat16 values.
// Compare op1 and op2 and return the smaller number operand after rounding.
// The 'fpcr' argument supplies the FPCR control bits.

bits(16) <a id="impl-shared.BFMaxNum.3"/>BFMaxNum(bits(16) op1_in, bits(16) op2_in, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    boolean fpexc = TRUE;
    boolean isbfloat16 = TRUE;
    bits(16) op1 = op1_in;
    bits(16) op2 = op2_in;
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    bits(16) result;

    (type1,-,-) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op1, fpcr, fpexc, isbfloat16);
    (type2,-,-) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op2, fpcr, fpexc, isbfloat16);

    boolean type1_nan = type1 IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean type2_nan = type2 IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};

    if !(altfp &amp;&amp; type1_nan &amp;&amp; type2_nan) then
        // Treat a single quiet-NaN as -Infinity.
        if type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 != <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op1 = <a href="shared_pseudocode.html#impl-shared.BFInfinity.1" title="function: bits(16) BFInfinity(bit sign)">BFInfinity</a>('1');
        elsif type1 != <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op2 = <a href="shared_pseudocode.html#impl-shared.BFInfinity.1" title="function: bits(16) BFInfinity(bit sign)">BFInfinity</a>('1');

    boolean altfmaxfmin = FALSE;    // Do not use alternate NaN handling
    result = <a href="shared_pseudocode.html#impl-shared.BFMax.4" title="function: bits(16) BFMax(bits(16) op1, bits(16) op2, FPCRType fpcr_in, boolean altfp)">BFMax</a>(op1, op2, fpcr, altfmaxfmin);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMin"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMin</h3>
      <p class="pseudocode">// BFMin()
// =======
// BFloat16 minimum.

bits(16) <a id="impl-shared.BFMin.3"/>BFMin(bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    return <a href="shared_pseudocode.html#impl-shared.BFMin.4" title="function: bits(16) BFMin(bits(16) op1, bits(16) op2, FPCRType fpcr_in, boolean altfp)">BFMin</a>(op1, op2, fpcr, altfp);

// BFMin()
// =======
// BFloat16 minimum following computational behaviors
// corresponding to instructions that read and write BFloat16 values.
// Compare op1 and op2 and return the smaller value after rounding.
// The 'fpcr' argument supplies the FPCR control bits and 'altfp' determines
// if the function should use alternative floating-point behavior.

bits(16) <a id="impl-shared.BFMin.4"/>BFMin(bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, boolean altfp)

    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    boolean fpexc = TRUE;
    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    boolean done;
    bits(32) result;

    bits(32) op1_s = op1 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    bits(32) op2_s = op2 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1_s, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2_s, fpcr, fpexc);

    if altfp &amp;&amp; type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp; sign1 != sign2 then
        // Alternate handling of zeros with differing sign
        return <a href="shared_pseudocode.html#impl-shared.BFZero.1" title="function: bits(16) BFZero(bit sign)">BFZero</a>(sign2);

    if altfp &amp;&amp; (type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>}) then
        // Alternate handling of NaN inputs
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        result = if type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then <a href="shared_pseudocode.html#impl-shared.BFZero.1" title="function: bits(16) BFZero(bit sign)">BFZero</a>(sign2) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16) else op2_s;
        done = TRUE;
    else
        (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1_s, op2_s, fpcr);

    if !done then
        <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype;
        bit sign;
        real value;
        if value1 &lt; value2 then
            (fptype,sign,value) = (type1,sign1,value1);
        else
            (fptype,sign,value) = (type2,sign2,value2);
        if fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, 32);
        elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
            sign = sign1 OR sign2;              // Use most negative sign
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, 32);
        else
            if altfp then    // Denormal output is not flushed to zero
                fpcr.FZ = '0';
            result = <a href="shared_pseudocode.html#impl-shared.FPRoundBF.4" title="function: bits(32) FPRoundBF(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRoundBF</a>(value, fpcr, rounding, fpexc);

        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, 32, fpcr);

    return result&lt;31:16&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMinNum"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMinNum</h3>
      <p class="pseudocode">// BFMinNum()
// ==========
// BFloat16 minimum number following computational behaviors corresponding
// to instructions that read and write BFloat16 values.
// Compare op1 and op2 and return the smaller number operand after rounding.
// The 'fpcr' argument supplies the FPCR control bits.

bits(16) <a id="impl-shared.BFMinNum.3"/>BFMinNum(bits(16) op1_in, bits(16) op2_in, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    boolean fpexc = TRUE;
    boolean isbfloat16 = TRUE;
    bits(16) op1 = op1_in;
    bits(16) op2 = op2_in;
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    bits(16) result;

    (type1,-,-) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op1, fpcr, fpexc, isbfloat16);
    (type2,-,-) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op2, fpcr, fpexc, isbfloat16);

    boolean type1_nan = type1 IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean type2_nan = type2 IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};

    if !(altfp &amp;&amp; type1_nan &amp;&amp; type2_nan) then
        // Treat a single quiet-NaN as +Infinity.
        if type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 != <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op1 = <a href="shared_pseudocode.html#impl-shared.BFInfinity.1" title="function: bits(16) BFInfinity(bit sign)">BFInfinity</a>('0');
        elsif type1 != <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op2 = <a href="shared_pseudocode.html#impl-shared.BFInfinity.1" title="function: bits(16) BFInfinity(bit sign)">BFInfinity</a>('0');

    boolean altfmaxfmin = FALSE;    // Do not use alternate NaN handling
    result = <a href="shared_pseudocode.html#impl-shared.BFMin.4" title="function: bits(16) BFMin(bits(16) op1, bits(16) op2, FPCRType fpcr_in, boolean altfp)">BFMin</a>(op1, op2, fpcr, altfmaxfmin);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMul"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMul</h3>
      <p class="pseudocode">// BFMul()
// =======
// Non-widening BFloat16 multiply used by SVE2 instructions.

bits(16) <a id="impl-shared.BFMul.3"/>BFMul(bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;
    return <a href="shared_pseudocode.html#impl-shared.BFMul.4" title="function: bits(16) BFMul(bits(16) op1, bits(16) op2, FPCRType fpcr, boolean fpexc)">BFMul</a>(op1, op2, fpcr, fpexc);

// BFMul()
// =======
// Non-widening BFloat16 multiply following computational behaviors
// corresponding to instructions that read and write BFloat16 values.
// Calculates op1 * op2.
// The 'fpcr' argument supplies the FPCR control bits.

bits(16) <a id="impl-shared.BFMul.4"/>BFMul(bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    boolean done;
    bits(32) result;

    bits(32) op1_s = op1 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    bits(32) op2_s = op2 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1_s, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2_s, fpcr, fpexc);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.6" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1_s, op2_s, fpcr, fpexc);

    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, 32);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign1 EOR sign2, 32);
        elsif zero1 || zero2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign1 EOR sign2, 32);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPRoundBF.4" title="function: bits(32) FPRoundBF(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRoundBF</a>(value1*value2, fpcr, rounding, fpexc);

        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, 32, fpcr);

    return result&lt;31:16&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMulAdd</h3>
      <p class="pseudocode">// BFMulAdd()
// ==========
// Non-widening BFloat16 fused multiply-add used by SVE2 instructions.

bits(16) <a id="impl-shared.BFMulAdd.4"/>BFMulAdd(bits(16) addend, bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;
    return <a href="shared_pseudocode.html#impl-shared.BFMulAdd.5" title="function: bits(16) BFMulAdd(bits(16) addend, bits(16) op1, bits(16) op2, FPCRType fpcr, boolean fpexc)">BFMulAdd</a>(addend, op1, op2, fpcr, fpexc);

// BFMulAdd()
// ==========
// Non-widening BFloat16 fused multiply-add following computational behaviors
// corresponding to instructions that read and write BFloat16 values.
// Calculates addend + op1*op2 with a single rounding.
// The 'fpcr' argument supplies the FPCR control bits.

bits(16) <a id="impl-shared.BFMulAdd.5"/>BFMulAdd(bits(16) addend, bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    boolean done;
    bits(32) result;

    bits(32) addend_s = addend : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    bits(32) op1_s = op1 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    bits(32) op2_s = op2 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    (typeA,signA,valueA) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(addend_s, fpcr, fpexc);
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1_s, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2_s, fpcr, fpexc);

    inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
    inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
    zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs3.8" title="function: (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N) op2, bits(N) op3,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs3</a>(typeA, type1, type2, addend_s, op1_s, op2_s, fpcr, fpexc);

    if !(<a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1') then
        if typeA == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, 32);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    if !done then
        infA = (typeA == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zeroA = (typeA == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        // Determine sign and type product will have if it does not cause an
        // Invalid Operation.
        signP = sign1 EOR sign2;
        infP  = inf1 || inf2;
        zeroP = zero1 || zero2;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero
        // by infinity and additions of opposite-signed infinities.
        invalidop = (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP);

        if invalidop then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, 32);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('0', 32);
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('1', 32);

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(signA, 32);

        // Otherwise calculate numerical result and round it.
        else
            result_value = valueA + (value1 * value2);
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(result_sign, 32);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRoundBF.4" title="function: bits(32) FPRoundBF(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRoundBF</a>(result_value, fpcr, rounding, fpexc);

        if !invalidop &amp;&amp; fpexc then
            <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms3.5" title="function: FPProcessDenorms3(FPType type1, FPType type2, FPType type3, integer N, FPCRType fpcr)">FPProcessDenorms3</a>(typeA, type1, type2, 32, fpcr);

    return result&lt;31:16&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMulAddH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMulAddH</h3>
      <p class="pseudocode">// BFMulAddH()
// ===========
// Used by BFMLALB, BFMLALT, BFMLSLB and BFMLSLT instructions.

bits(N) <a id="impl-shared.BFMulAddH.4"/>BFMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)
    bits(N) value1 = op1 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N DIV 2);
    bits(N) value2 = op2 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N DIV 2);
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; fpcr.AH == '1';  // When TRUE:
    boolean fpexc = !altfp;                         //     Do not generate floating point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';             //     Flush denormal input and output to zero
    if altfp then fpcr.RMode    = '00';             //     Use RNE rounding mode
    return <a href="shared_pseudocode.html#impl-shared.FPMulAdd.5" title="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAdd</a>(addend, value1, value2, fpcr, fpexc);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMulAddH_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMulAddH_ZA</h3>
      <p class="pseudocode">// BFMulAddH_ZA()
// ==============
// Used by SME2 ZA-targeting BFMLAL and BFMLSL instructions.

bits(N) <a id="impl-shared.BFMulAddH_ZA.4"/>BFMulAddH_ZA(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    bits(N) value1 = op1 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N DIV 2);
    bits(N) value2 = op2 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N DIV 2);
    return <a href="shared_pseudocode.html#impl-shared.FPMulAdd_ZA.4" title="function: bits(N) FPMulAdd_ZA(bits(N) addend, bits(N) op1, bits(N) op2, FPCRType fpcr_in)">FPMulAdd_ZA</a>(addend, value1, value2, fpcr);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMulAdd_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMulAdd_ZA</h3>
      <p class="pseudocode">// BFMulAdd_ZA()
// =============
// Non-widening BFloat16 fused multiply-add used by SME2 ZA-targeting instructions.

bits(16) <a id="impl-shared.BFMulAdd_ZA.4"/>BFMulAdd_ZA(bits(16) addend, bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)
    boolean fpexc = FALSE;
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.DN = '1';          // Generate default NaN values
    return <a href="shared_pseudocode.html#impl-shared.BFMulAdd.5" title="function: bits(16) BFMulAdd(bits(16) addend, bits(16) op1, bits(16) op2, FPCRType fpcr, boolean fpexc)">BFMulAdd</a>(addend, op1, op2, fpcr, fpexc);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMulH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMulH</h3>
      <p class="pseudocode">// BFMulH()
// ========
// BFloat16 widening multiply to single-precision following BFloat16
// computation behaviors.

bits(32) <a id="impl-shared.BFMulH.2"/>BFMulH(bits(16) op1, bits(16) op2)

    bits(32) result;

    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.BFUnpack.1" title="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</a>(op1);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.BFUnpack.1" title="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</a>(op2);
    if type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, 32);
    else
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, 32);
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign1 EOR sign2, 32);
        elsif zero1 || zero2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign1 EOR sign2, 32);
        else
            result = <a href="shared_pseudocode.html#impl-shared.BFRound.1" title="function: bits(32) BFRound(real op)">BFRound</a>(value1*value2);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFNeg"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFNeg</h3>
      <p class="pseudocode">// BFNeg()
// =======

bits(16) <a id="impl-shared.BFNeg.1"/>BFNeg(bits(16) op)
    boolean honor_altfp = TRUE;    // Honor alternate handling
    return <a href="shared_pseudocode.html#impl-shared.BFNeg.2" title="function: bits(16) BFNeg(bits(16) op, boolean honor_altfp)">BFNeg</a>(op, honor_altfp);

// BFNeg()
// =======

bits(16) <a id="impl-shared.BFNeg.2"/>BFNeg(bits(16) op, boolean honor_altfp)

    if honor_altfp &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() then
        <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
        if fpcr.AH == '1' then
            boolean fpexc = FALSE;
            boolean isbfloat16 = TRUE;
            (fptype, -, -) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op, fpcr, fpexc, isbfloat16);
            if fptype IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then

                return op;        // When fpcr.AH=1, sign of NaN has no consequence

    return NOT(op&lt;15&gt;) : op&lt;14:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFRound"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFRound</h3>
      <p class="pseudocode">// BFRound()
// =========
// Converts a real number OP into a single-precision value using the
// Round to Odd rounding mode and following BFloat16 computation behaviors.

bits(32) <a id="impl-shared.BFRound.1"/>BFRound(real op)

    assert op != 0.0;
    bits(32) result;

    // Format parameters - minimum exponent, numbers of exponent and fraction bits.
    minimum_exp = -126;  E = 8;  F = 23;

    // Split value into sign, unrounded mantissa and exponent.
    bit sign;
    real mantissa;
    if op &lt; 0.0 then
        sign = '1';  mantissa = -op;
    else
        sign = '0';  mantissa = op;
    exponent = 0;
    while mantissa &lt; 1.0 do
        mantissa = mantissa * 2.0;  exponent = exponent - 1;
    while mantissa &gt;= 2.0 do
        mantissa = mantissa / 2.0;  exponent = exponent + 1;

    // Fixed Flush-to-zero.
    if exponent &lt; minimum_exp then
        return <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, 32);

    // Start creating the exponent value for the result. Start by biasing the actual exponent
    // so that the minimum exponent becomes 1, lower values 0 (indicating possible underflow).
    biased_exp = <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>((exponent - minimum_exp) + 1, 0);
    if biased_exp == 0 then mantissa = mantissa / 2.0^(minimum_exp - exponent);

    // Get the unrounded mantissa as an integer, and the "units in last place" rounding error.
    int_mant = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(mantissa * 2.0^F);  // &lt; 2.0^F if biased_exp == 0, &gt;= 2.0^F if not
    error = mantissa * 2.0^F - Real(int_mant);

    // Round to Odd
    if error != 0.0 then
        int_mant&lt;0&gt; = '1';

    // Deal with overflow and generate result.
    if biased_exp &gt;= 2^E - 1 then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, 32);      // Overflows generate appropriately-signed Infinity
    else
        result = sign : biased_exp&lt;30-F:0&gt; : int_mant&lt;F-1:0&gt;;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFSub"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFSub</h3>
      <p class="pseudocode">// BFSub()
// =======
// Non-widening BFloat16 subtraction used by SVE2 instructions.

bits(16) <a id="impl-shared.BFSub.3"/>BFSub(bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;
    return <a href="shared_pseudocode.html#impl-shared.BFSub.4" title="function: bits(16) BFSub(bits(16) op1, bits(16) op2, FPCRType fpcr, boolean fpexc)">BFSub</a>(op1, op2, fpcr, fpexc);

// BFSub()
// =======
// Non-widening BFloat16 subtraction following computational behaviors
// corresponding to instructions that read and write BFloat16 values.
// Calculates op1 - op2.
// The 'fpcr' argument supplies the FPCR control bits.

bits(16) <a id="impl-shared.BFSub.4"/>BFSub(bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    boolean done;
    bits(32) result;

    bits(32) op1_s = op1 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    bits(32) op2_s = op2 : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1_s, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2_s, fpcr, fpexc);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.6" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1_s, op2_s, fpcr, fpexc);

    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, 32);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('0', 32);
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('1', 32);
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign1, 32);
        else
            result_value = value1 - value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(result_sign, 32);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRoundBF.4" title="function: bits(32) FPRoundBF(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRoundBF</a>(result_value, fpcr, rounding, fpexc);

        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, 32, fpcr);

    return result&lt;31:16&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFSub_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFSub_ZA</h3>
      <p class="pseudocode">// BFSub_ZA()
// ==========
// Non-widening BFloat16 subtraction used by SME2 ZA-targeting instructions.

bits(16) <a id="impl-shared.BFSub_ZA.3"/>BFSub_ZA(bits(16) op1, bits(16) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)
    boolean fpexc = FALSE;
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.DN = '1';          // Generate default NaN values
    return <a href="shared_pseudocode.html#impl-shared.BFSub.4" title="function: bits(16) BFSub(bits(16) op1, bits(16) op2, FPCRType fpcr, boolean fpexc)">BFSub</a>(op1, op2, fpcr, fpexc);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFUnpack"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFUnpack</h3>
      <p class="pseudocode">// BFUnpack()
// ==========
// Unpacks a BFloat16 or single-precision value into its type,
// sign bit and real number that it represents.
// The real number result has the correct sign for numbers and infinities,
// is very large in magnitude for infinities, and is 0.0 for NaNs.
// (These values are chosen to simplify the description of
// comparisons and conversions.)

(FPType, bit, real) <a id="impl-shared.BFUnpack.1"/>BFUnpack(bits(N) fpval)

    assert N IN {16,32};

    bit sign;
    bits(8) exp;
    bits(23) frac;
    if N == 16 then
        sign   = fpval&lt;15&gt;;
        exp    = fpval&lt;14:7&gt;;
        frac   = fpval&lt;6:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    else  // N == 32
        sign   = fpval&lt;31&gt;;
        exp    = fpval&lt;30:23&gt;;
        frac   = fpval&lt;22:0&gt;;

    <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype;
    real value;
    if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(exp) then
        fptype = <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;    // Fixed Flush to Zero
    elsif <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exp) then
        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac) then
            fptype = <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;  value = 2.0^1000000;
        else    // no SNaN for BF16 arithmetic
            fptype = <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>; value = 0.0;
    else
        fptype = <a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</a>;
        value = 2.0^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(exp)-127) * (1.0 + Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac)) * 2.0^-23);

    if sign == '1' then value = -value;

    return (fptype, sign, value);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFZero"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFZero</h3>
      <p class="pseudocode">// BFZero()
// ========

bits(16) <a id="impl-shared.BFZero.1"/>BFZero(bit sign)
    return sign : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(7);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.FPAdd_BF16"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/FPAdd_BF16</h3>
      <p class="pseudocode">// FPAdd_BF16()
// ============
// Single-precision add following BFloat16 computation behaviors.

bits(32) <a id="impl-shared.FPAdd_BF16.2"/>FPAdd_BF16(bits(32) op1, bits(32) op2)

    bits(32) result;

    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.BFUnpack.1" title="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</a>(op1);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.BFUnpack.1" title="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</a>(op2);
    if type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, 32);
    else
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, 32);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('0', 32);
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('1', 32);
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign1, 32);
        else
            result_value = value1 + value2;
            if result_value == 0.0 then
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>('0', 32);    // Positive sign when Round to Odd
            else
                result = <a href="shared_pseudocode.html#impl-shared.BFRound.1" title="function: bits(32) BFRound(real op)">BFRound</a>(result_value);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.FPConvertBF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/FPConvertBF</h3>
      <p class="pseudocode">// FPConvertBF()
// =============
// Converts a single-precision OP to BFloat16 value with using rounding mode of
// Round to Nearest Even when executed from AArch64 state and
// FPCR.AH == '1', otherwise rounding is controlled by FPCR/FPSCR.

bits(16) <a id="impl-shared.FPConvertBF.3"/>FPConvertBF(bits(32) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding_in)

    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = rounding_in;
    bits(32) result;                                // BF16 value in top 16 bits
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;                         // Generate no floating-point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';             // Flush denormal input and output to zero
    if altfp then rounding = <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>;    // Use RNE rounding mode

    // Unpack floating-point operand, with always flush-to-zero if fpcr.AH == '1'.
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        if fpcr.DN == '1' then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, 32);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(op, 32);
        if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, 32);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, 32);
    else
        result = <a href="shared_pseudocode.html#impl-shared.FPRoundBF.4" title="function: bits(32) FPRoundBF(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRoundBF</a>(value, fpcr, rounding, fpexc);

    // Returns correctly rounded BF16 value from top 16 bits
    return result&lt;31:16&gt;;

// FPConvertBF()
// =============
// Converts a single-precision operand to BFloat16 value.

bits(16) <a id="impl-shared.FPConvertBF.2"/>FPConvertBF(bits(32) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    return <a href="shared_pseudocode.html#impl-shared.FPConvertBF.3" title="function: bits(16) FPConvertBF(bits(32) op, FPCRType fpcr_in, FPRounding rounding_in)">FPConvertBF</a>(op, fpcr, <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr));</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.FPRoundBF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/FPRoundBF</h3>
      <p class="pseudocode">// FPRoundBF()
// ===========
// Converts a real number OP into a BFloat16 value using the supplied
// rounding mode RMODE. The 'fpexc' argument controls the generation of
// floating-point exceptions.

bits(32) <a id="impl-shared.FPRoundBF.4"/>FPRoundBF(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, boolean fpexc)
    boolean isbfloat16 = TRUE;
    return <a href="shared_pseudocode.html#impl-shared.FPRoundBase.6" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc, integer N)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc, 32);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fixedtofp.FixedToFP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fixedtofp/FixedToFP</h3>
      <p class="pseudocode">// FixedToFP()
// ===========

// Convert M-bit fixed point 'op' with FBITS fractional bits to
// N-bit precision floating point, controlled by UNSIGNED and ROUNDING.

bits(N) <a id="impl-shared.FixedToFP.6"/>FixedToFP(bits(M) op, integer fbits, boolean unsigned, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr,
                    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, integer N)

    assert N IN {16,32,64};
    assert M IN {16,32,64};
    bits(N) result;
    assert fbits &gt;= 0;
    assert rounding != <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>;

    // Correct signed-ness
    int_operand = <a href="shared_pseudocode.html#impl-shared.Int.2" title="function: integer Int(bits(N) x, boolean unsigned)">Int</a>(op, unsigned);

    // Scale by fractional bits and generate a real value
    real_operand = Real(int_operand) / 2.0^fbits;

    if real_operand == 0.0 then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>('0', N);
    else
        result = <a href="shared_pseudocode.html#impl-shared.FPRound.4" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, integer N)">FPRound</a>(real_operand, fpcr, rounding, N);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpabs.FPAbs"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpabs/FPAbs</h3>
      <p class="pseudocode">// FPAbs()
// =======

bits(N) <a id="impl-shared.FPAbs.1"/>FPAbs(bits(N) op)

    assert N IN {16,32,64};
    if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() then
        <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
        if fpcr.AH == '1' then
            (fptype, -, -) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, FALSE);
            if fptype IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
                return op;        // When fpcr.AH=1, sign of NaN has no consequence

    return '0' : op&lt;N-2:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpadd.FPAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpadd/FPAdd</h3>
      <p class="pseudocode">// FPAdd()
// =======

bits(N) <a id="impl-shared.FPAdd.3"/>FPAdd(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPAdd.4" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPAdd</a>(op1, op2, fpcr, fpexc);

// FPAdd()
// =======

bits(N) <a id="impl-shared.FPAdd.4"/>FPAdd(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};
    rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.6" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, fpexc);
    if !done then
        inf1  = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);  inf2  = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);      zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('0', N);
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('1', N);
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign1, N);
        else
            result_value = value1 + value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(result_sign, N);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.5" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc, integer N)">FPRound</a>(result_value, fpcr, rounding, fpexc, N);

        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpadd.FPAdd_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpadd/FPAdd_ZA</h3>
      <p class="pseudocode">// FPAdd_ZA()
// ==========
// Calculates op1+op2 for SME2 ZA-targeting instructions.

bits(N) <a id="impl-shared.FPAdd_ZA.3"/>FPAdd_ZA(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    boolean fpexc = FALSE;      // Do not generate floating-point exceptions
    fpcr.DN = '1';              // Generate default NaN values
    return <a href="shared_pseudocode.html#impl-shared.FPAdd.4" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPAdd</a>(op1, op2, fpcr, fpexc);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcompare.FPCompare"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcompare/FPCompare</h3>
      <p class="pseudocode">// FPCompare()
// ===========

bits(4) <a id="impl-shared.FPCompare.4"/>FPCompare(bits(N) op1, bits(N) op2, boolean signal_nans, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    bits(4) result;
    if type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
        result = '0011';
        if type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || signal_nans then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        if value1 == value2 then
            result = '0110';
        elsif value1 &lt; value2 then
            result = '1000';
        else  // value1 &gt; value2
            result = '0010';

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcompareeq.FPCompareEQ"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcompareeq/FPCompareEQ</h3>
      <p class="pseudocode">// FPCompareEQ()
// =============

boolean <a id="impl-shared.FPCompareEQ.3"/>FPCompareEQ(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    boolean result;
    if type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
        result = FALSE;
        if type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 == value2);
        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcomparege.FPCompareGE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcomparege/FPCompareGE</h3>
      <p class="pseudocode">// FPCompareGE()
// =============

boolean <a id="impl-shared.FPCompareGE.3"/>FPCompareGE(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    boolean result;
    if type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
        result = FALSE;
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 &gt;= value2);
        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcomparegt.FPCompareGT"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcomparegt/FPCompareGT</h3>
      <p class="pseudocode">// FPCompareGT()
// =============

boolean <a id="impl-shared.FPCompareGT.3"/>FPCompareGT(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    boolean result;
    if type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
        result = FALSE;
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 &gt; value2);
        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpconvert.FPConvert"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpconvert/FPConvert</h3>
      <p class="pseudocode">// FPConvert()
// ===========

// Convert floating point 'op' with N-bit precision to M-bit precision,
// with rounding controlled by ROUNDING.
// This is used by the FP-to-FP conversion instructions and so for
// half-precision data ignores FZ16, but observes AHP.

bits(M) <a id="impl-shared.FPConvert.4"/>FPConvert(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, integer M)

    assert M IN {16,32,64};
    assert N IN {16,32,64};
    bits(M) result;

    // Unpack floating-point operand optionally with flush-to-zero.
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpackCV.2" title="function: (FPType, bit, real) FPUnpackCV(bits(N) fpval, FPCRType fpcr_in)">FPUnpackCV</a>(op, fpcr);

    alt_hp = (M == 16) &amp;&amp; (fpcr.AHP == '1');

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        if alt_hp then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, M);
        elsif fpcr.DN == '1' then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, M);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(op, M);
        if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || alt_hp then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>,fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        if alt_hp then
            result = sign:<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(M-1);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, M);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, M);
    else
        result = <a href="shared_pseudocode.html#impl-shared.FPRoundCV.4" title="function: bits(N) FPRoundCV(real op, FPCRType fpcr_in, FPRounding rounding, integer N)">FPRoundCV</a>(value, fpcr, rounding, M);
        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorm.3" title="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(fptype, N, fpcr);

    return result;

// FPConvert()
// ===========

bits(M) <a id="impl-shared.FPConvert.3"/>FPConvert(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, integer M)
    return <a href="shared_pseudocode.html#impl-shared.FPConvert.4" title="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding, integer M)">FPConvert</a>(op, fpcr, <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr), M);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpconvertnan.FPConvertNaN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpconvertnan/FPConvertNaN</h3>
      <p class="pseudocode">// FPConvertNaN()
// ==============
// Converts a NaN of one floating-point type to another

bits(M) <a id="impl-shared.FPConvertNaN.2"/>FPConvertNaN(bits(N) op, integer M)

    assert N IN {16,32,64};
    assert M IN {16,32,64};
    bits(M) result;
    bits(51) frac;

    sign = op&lt;N-1&gt;;

    // Unpack payload from input NaN
    case N of
        when 64 frac = op&lt;50:0&gt;;
        when 32 frac = op&lt;21:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(29);
        when 16 frac = op&lt;8:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(42);

    // Repack payload into output NaN, while
    // converting an SNaN to a QNaN.
    case M of
        when 64 result = sign:<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(M-52):frac;
        when 32 result = sign:<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(M-23):frac&lt;50:29&gt;;
        when 16 result = sign:<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(M-10):frac&lt;50:42&gt;;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcrtype.FPCRType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcrtype/FPCRType</h3>
      <p class="pseudocode">type <a id="FPCRType"/>FPCRType;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdecoderm.FPDecodeRM"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdecoderm/FPDecodeRM</h3>
      <p class="pseudocode">// FPDecodeRM()
// ============

// Decode most common AArch32 floating-point rounding encoding.

FPRounding <a id="impl-shared.FPDecodeRM.1"/>FPDecodeRM(bits(2) rm)

    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> result;
    case rm of
        when '00' result = <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>; // A
        when '01' result = <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>; // N
        when '10' result = <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>;  // P
        when '11' result = <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>;  // M

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdecoderounding.FPDecodeRounding"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdecoderounding/FPDecodeRounding</h3>
      <p class="pseudocode">// FPDecodeRounding()
// ==================

// Decode floating-point rounding mode and common AArch64 encoding.

FPRounding <a id="impl-shared.FPDecodeRounding.1"/>FPDecodeRounding(bits(2) rmode)
    case rmode of
        when '00' return <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>; // N
        when '01' return <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>;  // P
        when '10' return <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>;  // M
        when '11' return <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>;    // Z</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdefaultnan.FPDefaultNaN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdefaultnan/FPDefaultNaN</h3>
      <p class="pseudocode">// FPDefaultNaN()
// ==============

bits(N) <a id="impl-shared.FPDefaultNaN.1"/>FPDefaultNaN(integer N)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
    return <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);

bits(N) <a id="impl-shared.FPDefaultNaN.2"/>FPDefaultNaN(<a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, integer N)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    bit sign = if <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then fpcr.AH else '0';

    bits(E) exp  = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(E);
    bits(F) frac = '1':<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F-1);

    return sign : exp : frac;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdiv.FPDiv"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdiv/FPDiv</h3>
      <p class="pseudocode">// FPDiv()
// =======

bits(N) <a id="impl-shared.FPDiv.3"/>FPDiv(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);

    if !done then
        inf1  = type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;
        inf2  = type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;
        zero1 = type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;
        zero2 = type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;

        if (inf1 &amp;&amp; inf2) || (zero1 &amp;&amp; zero2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif inf1 || zero2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign1 EOR sign2, N);
            if !inf1 then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</a>, fpcr);
        elsif zero1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign1 EOR sign2, N);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, integer N)">FPRound</a>(value1/value2, fpcr, N);

        if !zero2 then
            <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdot.FPDot"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdot/FPDot</h3>
      <p class="pseudocode">// FPDot()
// =======
// Calculates single-precision result of 2-way 16-bit floating-point dot-product
// with a single rounding.
// The 'fpcr' argument supplies the FPCR control bits and 'isbfloat16'
// determines whether input operands are BFloat16 or half-precision type.
// and 'fpexc' controls the generation of floating-point exceptions.

bits(N) <a id="impl-shared.FPDot.6"/>FPDot(bits(N DIV 2) op1_a, bits(N DIV 2) op1_b, bits(N DIV 2) op2_a,
              bits(N DIV 2) op2_b, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean isbfloat16)
    boolean fpexc = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPDot.7" title="function: bits(N) FPDot(bits(N DIV 2) op1_a, bits(N DIV 2) op1_b, bits(N DIV 2) op2_a,&#13; bits(N DIV 2) op2_b, FPCRType fpcr_in, boolean isbfloat16, boolean fpexc)">FPDot</a>(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);

bits(N) <a id="impl-shared.FPDot.7"/>FPDot(bits(N DIV 2) op1_a, bits(N DIV 2) op1_b, bits(N DIV 2) op2_a,
              bits(N DIV 2) op2_b, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, boolean isbfloat16, boolean fpexc)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;

    assert N == 32;
    bits(N) result;
    boolean done;
    fpcr.AHP = '0';           // Ignore alternative half-precision option
    rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    (type1_a,sign1_a,value1_a) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op1_a, fpcr, fpexc, isbfloat16);
    (type1_b,sign1_b,value1_b) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op1_b, fpcr, fpexc, isbfloat16);
    (type2_a,sign2_a,value2_a) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op2_a, fpcr, fpexc, isbfloat16);
    (type2_b,sign2_b,value2_b) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op2_b, fpcr, fpexc, isbfloat16);

    inf1_a = (type1_a == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero1_a = (type1_a == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    inf1_b = (type1_b == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero1_b = (type1_b == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    inf2_a = (type2_a == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero2_a = (type2_a == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    inf2_b = (type2_b == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero2_b = (type2_b == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs4.10" title="function: (boolean, bits(N)) FPProcessNaNs4(FPType type1, FPType type2, FPType type3, FPType type4,&#13; bits(N DIV 2) op1, bits(N DIV 2) op2, bits(N DIV 2) op3,&#13; bits(N DIV 2) op4, FPCRType fpcr, boolean fpexc)">FPProcessNaNs4</a>(type1_a, type1_b, type2_a, type2_b,
                                   op1_a, op1_b, op2_a, op2_b, fpcr, fpexc);

    if (((inf1_a &amp;&amp; zero2_a) || (zero1_a &amp;&amp; inf2_a)) &amp;&amp;
        ((inf1_b &amp;&amp; zero2_b) || (zero1_b &amp;&amp; inf2_b))) then
        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    if !done then
        // Determine sign and type products will have if it does not cause an Invalid
        // Operation.
        signPa = sign1_a EOR sign2_a;
        signPb = sign1_b EOR sign2_b;
        infPa = inf1_a || inf2_a;
        infPb = inf1_b || inf2_b;
        zeroPa = zero1_a || zero2_a;
        zeroPb = zero1_b || zero2_b;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero
        // by infinity and additions of opposite-signed infinities.
        invalidop = ((inf1_a &amp;&amp; zero2_a) || (zero1_a &amp;&amp; inf2_a) ||
            (inf1_b &amp;&amp; zero2_b) || (zero1_b &amp;&amp; inf2_b) || (infPa &amp;&amp; infPb &amp;&amp; signPa != signPb));

        if invalidop then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

       // Other cases involving infinities produce an infinity of the same sign.
        elsif (infPa &amp;&amp; signPa == '0') || (infPb &amp;&amp; signPb == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('0', N);
        elsif (infPa &amp;&amp; signPa == '1') || (infPb &amp;&amp; signPb == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('1', N);

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroPa &amp;&amp; zeroPb &amp;&amp; signPa == signPb then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(signPa, N);

        // Otherwise calculate fused sum of products and round it.
        else
            result_value = (value1_a * value2_a) + (value1_b * value2_b);
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(result_sign, N);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.5" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc, integer N)">FPRound</a>(result_value, fpcr, rounding, fpexc, N);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdot.FPDotAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdot/FPDotAdd</h3>
      <p class="pseudocode">// FPDotAdd()
// ==========
// Half-precision 2-way dot-product and add to single-precision.

bits(N) <a id="impl-shared.FPDotAdd.6"/>FPDotAdd(bits(N) addend, bits(N DIV 2) op1_a, bits(N DIV 2) op1_b,
                 bits(N DIV 2) op2_a, bits(N DIV 2) op2_b, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N == 32;

    bits(N) prod;
    boolean isbfloat16 = FALSE;
    boolean fpexc = TRUE;     // Generate floating-point exceptions
    prod = <a href="shared_pseudocode.html#impl-shared.FPDot.7" title="function: bits(N) FPDot(bits(N DIV 2) op1_a, bits(N DIV 2) op1_b, bits(N DIV 2) op2_a,&#13; bits(N DIV 2) op2_b, FPCRType fpcr_in, boolean isbfloat16, boolean fpexc)">FPDot</a>(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
    result = <a href="shared_pseudocode.html#impl-shared.FPAdd.4" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPAdd</a>(addend, prod, fpcr, fpexc);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdot.FPDotAdd_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdot/FPDotAdd_ZA</h3>
      <p class="pseudocode">// FPDotAdd_ZA()
// =============
// Half-precision 2-way dot-product and add to single-precision
// for SME ZA-targeting instructions.

bits(N) <a id="impl-shared.FPDotAdd_ZA.6"/>FPDotAdd_ZA(bits(N) addend, bits(N DIV 2) op1_a, bits(N DIV 2) op1_b,
                    bits(N DIV 2) op2_a, bits(N DIV 2) op2_b, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    assert N == 32;

    bits(N) prod;
    boolean isbfloat16 = FALSE;
    boolean fpexc = FALSE;    // Do not generate floating-point exceptions
    fpcr.DN = '1';            // Generate default NaN values
    prod = <a href="shared_pseudocode.html#impl-shared.FPDot.7" title="function: bits(N) FPDot(bits(N DIV 2) op1_a, bits(N DIV 2) op1_b, bits(N DIV 2) op2_a,&#13; bits(N DIV 2) op2_b, FPCRType fpcr_in, boolean isbfloat16, boolean fpexc)">FPDot</a>(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
    result = <a href="shared_pseudocode.html#impl-shared.FPAdd.4" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPAdd</a>(addend, prod, fpcr, fpexc);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpexc.FPExc"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpexc/FPExc</h3>
      <p class="pseudocode">enumeration <a id="FPExc"/>FPExc       {<a id="FPExc_InvalidOp"/>FPExc_InvalidOp, <a id="FPExc_DivideByZero"/>FPExc_DivideByZero, <a id="FPExc_Overflow"/>FPExc_Overflow,
                         <a id="FPExc_Underflow"/>FPExc_Underflow, <a id="FPExc_Inexact"/>FPExc_Inexact, <a id="FPExc_InputDenorm"/>FPExc_InputDenorm};</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpinfinity.FPInfinity"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpinfinity/FPInfinity</h3>
      <p class="pseudocode">// FPInfinity()
// ============

bits(N) <a id="impl-shared.FPInfinity.2"/>FPInfinity(bit sign, integer N)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    bits(E) exp  = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(E);
    bits(F) frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);

    return sign : exp : frac;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmatmul.FPMatMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmatmul/FPMatMulAdd</h3>
      <p class="pseudocode">// FPMatMulAdd()
// =============
//
// Floating point matrix multiply and add to same precision matrix
// result[2, 2] = addend[2, 2] + (op1[2, 2] * op2[2, 2])

bits(N) <a id="impl-shared.FPMatMulAdd.5"/>FPMatMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, integer esize, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N == esize * 2 * 2;
    bits(N)  result;
    bits(esize) prod0, prod1, sum;

    for i = 0 to 1
        for j = 0 to 1
            sum   = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[addend, 2*i + j, esize];
            prod0 = <a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 2*i + 0, esize],
                          <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 2*j + 0, esize], fpcr);
            prod1 = <a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 2*i + 1, esize],
                          <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 2*j + 1, esize], fpcr);
            sum   = <a href="shared_pseudocode.html#impl-shared.FPAdd.3" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPAdd</a>(sum, <a href="shared_pseudocode.html#impl-shared.FPAdd.3" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPAdd</a>(prod0, prod1, fpcr), fpcr);
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, 2*i + j, esize] = sum;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmax.FPMax"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmax/FPMax</h3>
      <p class="pseudocode">// FPMax()
// =======

bits(N) <a id="impl-shared.FPMax.3"/>FPMax(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    return <a href="shared_pseudocode.html#impl-shared.FPMax.4" title="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMax</a>(op1, op2, fpcr, altfp);

// FPMax()
// =======
// Compare two inputs and return the larger value after rounding. The
// 'fpcr' argument supplies the FPCR control bits and 'altfp' determines
// if the function should use alternative floating-point behavior.

bits(N) <a id="impl-shared.FPMax.4"/>FPMax(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, boolean altfp)

    assert N IN {16,32,64};
    boolean done;
    bits(N) result;
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    if altfp &amp;&amp; type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp; sign1 != sign2 then
        // Alternate handling of zeros with differing sign
        return <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign2, N);

    if altfp &amp;&amp; (type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>}) then
        // Alternate handling of NaN inputs
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        result = if type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign2, N) else op2;
        done = TRUE;
    else
        (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);

    if !done then
        <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype;
        bit sign;
        real value;
        if value1 &gt; value2 then
            (fptype,sign,value) = (type1,sign1,value1);
        else
            (fptype,sign,value) = (type2,sign2,value2);
        if fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, N);
        elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
            sign = sign1 AND sign2;         // Use most positive sign
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);
        else
            // The use of FPRound() covers the case where there is a trapped underflow exception
            // for a denormalized number even though the result is exact.
            rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
            if altfp then    // Denormal output is not flushed to zero
                fpcr.FZ = '0';
                fpcr.FZ16 = '0';

            result = <a href="shared_pseudocode.html#impl-shared.FPRound.5" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc, integer N)">FPRound</a>(value, fpcr, rounding, TRUE, N);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmaxnormal.FPMaxNormal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmaxnormal/FPMaxNormal</h3>
      <p class="pseudocode">// FPMaxNormal()
// =============

bits(N) <a id="impl-shared.FPMaxNormal.2"/>FPMaxNormal(bit sign, integer N)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(E-1):'0';
    frac = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(F);

    return sign : exp : frac;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmaxnum.FPMaxNum"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmaxnum/FPMaxNum</h3>
      <p class="pseudocode">// FPMaxNum()
// ==========

bits(N) <a id="impl-shared.FPMaxNum.3"/>FPMaxNum(bits(N) op1_in, bits(N) op2_in, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    bits(N) op1 = op1_in;
    bits(N) op2 = op2_in;
    (type1,-,-) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,-,-) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    boolean type1_nan = type1 IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean type2_nan = type2 IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';

    if !(altfp &amp;&amp; type1_nan &amp;&amp; type2_nan) then
        // Treat a single quiet-NaN as -Infinity.
        if type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 != <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op1 = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('1', N);
        elsif type1 != <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op2 = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('1', N);

    altfmaxfmin = FALSE;    // Restrict use of FMAX/FMIN NaN propagation rules
    result = <a href="shared_pseudocode.html#impl-shared.FPMax.4" title="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMax</a>(op1, op2, fpcr, altfmaxfmin);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmerge.IsMerging"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmerge/IsMerging</h3>
      <p class="pseudocode">// IsMerging()
// ===========
// Returns TRUE if the output elements other than the lowest are taken from
// the destination register.

boolean <a id="impl-shared.IsMerging.1"/>IsMerging(<a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    bit nep = if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.IsFullA64Enabled.0" title="function: boolean IsFullA64Enabled()">IsFullA64Enabled</a>() then '0' else fpcr.NEP;
    return <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; nep == '1';</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmin.FPMin"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmin/FPMin</h3>
      <p class="pseudocode">// FPMin()
// =======

bits(N) <a id="impl-shared.FPMin.3"/>FPMin(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    return <a href="shared_pseudocode.html#impl-shared.FPMin.4" title="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMin</a>(op1, op2, fpcr, altfp);

// FPMin()
// =======
// Compare two operands and return the smaller operand after rounding. The
// 'fpcr' argument supplies the FPCR control bits and 'altfp' determines
// if the function should use alternative behavior.

bits(N) <a id="impl-shared.FPMin.4"/>FPMin(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, boolean altfp)

    assert N IN {16,32,64};
    boolean done;
    bits(N) result;
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);
    if altfp &amp;&amp; type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp; sign1 != sign2 then
        // Alternate handling of zeros with differing sign
        return <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign2, N);

    if altfp &amp;&amp; (type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>}) then
        // Alternate handling of NaN inputs
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        result = if type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign2, N) else op2;
        done = TRUE;
    else
        (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);

    if !done then
        <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype;
        bit sign;
        real value;
        <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding;
        if value1 &lt; value2 then
            (fptype,sign,value) = (type1,sign1,value1);
        else
            (fptype,sign,value) = (type2,sign2,value2);
        if fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, N);
        elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
            sign = sign1 OR sign2;              // Use most negative sign
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);
        else
            // The use of FPRound() covers the case where there is a trapped underflow exception
            // for a denormalized number even though the result is exact.
            rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
            if altfp then    // Denormal output is not flushed to zero
                fpcr.FZ = '0';
                fpcr.FZ16 = '0';

            result = <a href="shared_pseudocode.html#impl-shared.FPRound.5" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc, integer N)">FPRound</a>(value, fpcr, rounding, TRUE, N);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpminnum.FPMinNum"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpminnum/FPMinNum</h3>
      <p class="pseudocode">// FPMinNum()
// ==========

bits(N) <a id="impl-shared.FPMinNum.3"/>FPMinNum(bits(N) op1_in, bits(N) op2_in, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    bits(N) op1 = op1_in;
    bits(N) op2 = op2_in;
    (type1,-,-) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,-,-) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    boolean type1_nan = type1 IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean type2_nan = type2 IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';

    if !(altfp &amp;&amp; type1_nan &amp;&amp; type2_nan) then
        // Treat a single quiet-NaN as +Infinity.
        if type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 != <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op1 = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('0', N);
        elsif type1 != <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op2 = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('0', N);

    altfmaxfmin = FALSE;    // Restrict use of FMAX/FMIN NaN propagation rules
    result = <a href="shared_pseudocode.html#impl-shared.FPMin.4" title="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMin</a>(op1, op2, fpcr, altfmaxfmin);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmul.FPMul"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmul/FPMul</h3>
      <p class="pseudocode">// FPMul()
// =======

bits(N) <a id="impl-shared.FPMul.3"/>FPMul(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign1 EOR sign2, N);
        elsif zero1 || zero2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign1 EOR sign2, N);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, integer N)">FPRound</a>(value1*value2, fpcr, N);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladd.FPMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladd/FPMulAdd</h3>
      <p class="pseudocode">// FPMulAdd()
// ==========

bits(N) <a id="impl-shared.FPMulAdd.4"/>FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPMulAdd.5" title="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAdd</a>(addend, op1, op2, fpcr, fpexc);

// FPMulAdd()
// ==========
//
// Calculates addend + op1*op2 with a single rounding. The 'fpcr' argument
// supplies the FPCR control bits, and 'fpexc' controls the generation of
// floating-point exceptions.

bits(N) <a id="impl-shared.FPMulAdd.5"/>FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,
                 <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};

    (typeA,signA,valueA) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(addend, fpcr, fpexc);
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);
    rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs3.8" title="function: (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N) op2, bits(N) op3,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs3</a>(typeA, type1, type2, addend, op1, op2, fpcr, fpexc);

    if !(<a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1') then
        if typeA == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    if !done then
        infA = (typeA == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zeroA = (typeA == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        // Determine sign and type product will have if it does not cause an
        // Invalid Operation.
        signP = sign1 EOR sign2;
        infP  = inf1 || inf2;
        zeroP = zero1 || zero2;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero
        // by infinity and additions of opposite-signed infinities.
        invalidop = (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP);

        if invalidop then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('0', N);
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('1', N);

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(signA, N);

        // Otherwise calculate numerical result and round it.
        else
            result_value = valueA + (value1 * value2);
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(result_sign, N);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.5" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc, integer N)">FPRound</a>(result_value, fpcr, rounding, fpexc, N);

        if !invalidop &amp;&amp; fpexc then
            <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms3.5" title="function: FPProcessDenorms3(FPType type1, FPType type2, FPType type3, integer N, FPCRType fpcr)">FPProcessDenorms3</a>(typeA, type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladd.FPMulAdd_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladd/FPMulAdd_ZA</h3>
      <p class="pseudocode">// FPMulAdd_ZA()
// =============
// Calculates addend + op1*op2 with a single rounding for SME ZA-targeting
// instructions.

bits(N) <a id="impl-shared.FPMulAdd_ZA.4"/>FPMulAdd_ZA(bits(N) addend, bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    boolean fpexc = FALSE;      // Do not generate floating-point exceptions
    fpcr.DN = '1';              // Generate default NaN values
    return <a href="shared_pseudocode.html#impl-shared.FPMulAdd.5" title="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAdd</a>(addend, op1, op2, fpcr, fpexc);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladdh.FPMulAddH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladdh/FPMulAddH</h3>
      <p class="pseudocode">// FPMulAddH()
// ===========
// Calculates addend + op1*op2.

bits(N) <a id="impl-shared.FPMulAddH.4"/>FPMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPMulAddH.5" title="function: bits(N) FPMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAddH</a>(addend, op1, op2, fpcr, fpexc);

// FPMulAddH()
// ===========
// Calculates addend + op1*op2.

bits(N) <a id="impl-shared.FPMulAddH.5"/>FPMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2,
                  <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N == 32;
    rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    (typeA,signA,valueA) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(addend, fpcr, fpexc);
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);
    inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs3H.8" title="function: (boolean, bits(N)) FPProcessNaNs3H(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N DIV 2) op2, bits(N DIV 2) op3,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs3H</a>(typeA, type1, type2, addend, op1, op2, fpcr, fpexc);

    if !(<a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1') then
        if typeA == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    if !done then
        infA = (typeA == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zeroA = (typeA == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        // Determine sign and type product will have if it does not cause an
        // Invalid Operation.
        signP = sign1 EOR sign2;
        infP = inf1 || inf2;
        zeroP = zero1 || zero2;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero by infinity and
        // additions of opposite-signed infinities.
        invalidop = (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP);

        if invalidop then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('0', N);
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('1', N);

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(signA, N);

        // Otherwise calculate numerical result and round it.
        else
            result_value = valueA + (value1 * value2);
            if result_value == 0.0 then // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(result_sign, N);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.5" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc, integer N)">FPRound</a>(result_value, fpcr, rounding, fpexc, N);

        if !invalidop &amp;&amp; fpexc then
            <a href="shared_pseudocode.html#impl-shared.FPProcessDenorm.3" title="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(typeA, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladdh.FPMulAddH_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladdh/FPMulAddH_ZA</h3>
      <p class="pseudocode">// FPMulAddH_ZA()
// ==============
// Calculates addend + op1*op2 for SME2 ZA-targeting instructions.

bits(N) <a id="impl-shared.FPMulAddH_ZA.4"/>FPMulAddH_ZA(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    boolean fpexc = FALSE;      // Do not generate floating-point exceptions
    fpcr.DN = '1';              // Generate default NaN values
    return <a href="shared_pseudocode.html#impl-shared.FPMulAddH.5" title="function: bits(N) FPMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAddH</a>(addend, op1, op2, fpcr, fpexc);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladdh.FPProcessNaNs3H"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladdh/FPProcessNaNs3H</h3>
      <p class="pseudocode">// FPProcessNaNs3H()
// =================

(boolean, bits(N)) <a id="impl-shared.FPProcessNaNs3H.8"/>FPProcessNaNs3H(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3,
                                   bits(N) op1, bits(N DIV 2) op2, bits(N DIV 2) op3,
                                   <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {32,64};

    bits(N) result;
    <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type_nan;
    // When TRUE, use alternative NaN propagation rules.
    boolean altfp   = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean op1_nan = type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op2_nan = type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op3_nan = type3 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    if altfp then
        if (type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type3 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>) then
            type_nan = <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
        else
            type_nan = <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>;

    boolean done;
    if altfp &amp;&amp; op1_nan &amp;&amp; op2_nan &amp;&amp; op3_nan then          // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op2, fpcr, fpexc), N);
    elsif altfp &amp;&amp; op2_nan &amp;&amp; (op1_nan || op3_nan) then     // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op2, fpcr, fpexc), N);
    elsif altfp &amp;&amp; op3_nan &amp;&amp; op1_nan then                  // &lt;m&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op3, fpcr, fpexc), N);
    elsif type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc), N);
    elsif type3 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc), N);
    elsif type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc), N);
    elsif type3 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc), N);
    else
        done = FALSE; result = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N); // 'Don't care' result
    return (done, result);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmulx.FPMulX"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmulx/FPMulX</h3>
      <p class="pseudocode">// FPMulX()
// ========

bits(N) <a id="impl-shared.FPMulX.3"/>FPMulX(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    bits(N) result;
    boolean done;
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPTwo.2" title="function: bits(N) FPTwo(bit sign, integer N)">FPTwo</a>(sign1 EOR sign2, N);
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign1 EOR sign2, N);
        elsif zero1 || zero2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign1 EOR sign2, N);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, integer N)">FPRound</a>(value1*value2, fpcr, N);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpneg.FPNeg"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpneg/FPNeg</h3>
      <p class="pseudocode">// FPNeg()
// =======

bits(N) <a id="impl-shared.FPNeg.1"/>FPNeg(bits(N) op)

    assert N IN {16,32,64};
    if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() then
        <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
        if fpcr.AH == '1' then
            (fptype, -, -) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, FALSE);
            if fptype IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then

                return op;        // When fpcr.AH=1, sign of NaN has no consequence

    return NOT(op&lt;N-1&gt;) : op&lt;N-2:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fponepointfive.FPOnePointFive"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fponepointfive/FPOnePointFive</h3>
      <p class="pseudocode">// FPOnePointFive()
// ================

bits(N) <a id="impl-shared.FPOnePointFive.2"/>FPOnePointFive(bit sign, integer N)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '0':<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(E-1);
    frac = '1':<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F-1);
    result = sign : exp : frac;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessdenorms.FPProcessDenorm"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessdenorms/FPProcessDenorm</h3>
      <p class="pseudocode">// FPProcessDenorm()
// =================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

<a id="impl-shared.FPProcessDenorm.3"/>FPProcessDenorm(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype, integer N, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; fptype == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessdenorms.FPProcessDenorms"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessdenorms/FPProcessDenorms</h3>
      <p class="pseudocode">// FPProcessDenorms()
// ==================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

<a id="impl-shared.FPProcessDenorms.4"/>FPProcessDenorms(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, integer N, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; (type1 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> || type2 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>) then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessdenorms.FPProcessDenorms3"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessdenorms/FPProcessDenorms3</h3>
      <p class="pseudocode">// FPProcessDenorms3()
// ===================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

<a id="impl-shared.FPProcessDenorms3.5"/>FPProcessDenorms3(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3, integer N, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; (type1 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> || type2 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> ||
        type3 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>) then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessdenorms.FPProcessDenorms4"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessdenorms/FPProcessDenorms4</h3>
      <p class="pseudocode">// FPProcessDenorms4()
// ===================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

<a id="impl-shared.FPProcessDenorms4.6"/>FPProcessDenorms4(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type4, integer N, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; (type1 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> || type2 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> ||
        type3 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> || type4 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>) then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessexception.FPProcessException"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessexception/FPProcessException</h3>
      <p class="pseudocode">// FPProcessException()
// ====================
//
// The 'fpcr' argument supplies FPCR control bits. Status information is
// updated directly in the FPSR where appropriate.

<a id="impl-shared.FPProcessException.2"/>FPProcessException(<a href="shared_pseudocode.html#FPExc" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc</a> exception, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    integer cumul;
    // Determine the cumulative exception bit number
    case exception of
        when <a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>     cumul = 0;
        when <a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</a>  cumul = 1;
        when <a href="shared_pseudocode.html#FPExc_Overflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Overflow</a>      cumul = 2;
        when <a href="shared_pseudocode.html#FPExc_Underflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Underflow</a>     cumul = 3;
        when <a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>       cumul = 4;
        when <a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>   cumul = 7;
    enable = cumul + 8;
    if fpcr&lt;enable&gt; == '1' &amp;&amp; (!<a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() || PSTATE.SM == '0' || <a href="shared_pseudocode.html#impl-aarch64.IsFullA64Enabled.0" title="function: boolean IsFullA64Enabled()">IsFullA64Enabled</a>()) then
        // Trapping of the exception enabled.
        // It is IMPLEMENTATION DEFINED whether the enable bit may be set at all,
        // and if so then how exceptions and in what order that they may be
        // accumulated before calling FPTrappedException().
        bits(8) accumulated_exceptions = <a href="shared_pseudocode.html#impl-shared.GetAccumulatedFPExceptions.0" title="function: bits(8) GetAccumulatedFPExceptions()">GetAccumulatedFPExceptions</a>();
        accumulated_exceptions&lt;cumul&gt; = '1';
        if boolean IMPLEMENTATION_DEFINED "Support trapping of floating-point exceptions" then
            if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
                <a href="shared_pseudocode.html#AArch32.FPTrappedException.1" title="function: AArch32.FPTrappedException(bits(8) accumulated_exceptions)">AArch32.FPTrappedException</a>(accumulated_exceptions);
            else
                is_ase = <a href="shared_pseudocode.html#impl-shared.IsASEInstruction.0" title="function: boolean IsASEInstruction()">IsASEInstruction</a>();
                <a href="shared_pseudocode.html#AArch64.FPTrappedException.2" title="function: AArch64.FPTrappedException(boolean is_ase, bits(8) accumulated_exceptions)">AArch64.FPTrappedException</a>(is_ase, accumulated_exceptions);
        else
            // The exceptions generated by this instruction are accumulated by the PE and
            // FPTrappedException is called later during its execution, before the next
            // instruction is executed. This field is cleared at the start of each FP instruction.
            <a href="shared_pseudocode.html#impl-shared.SetAccumulatedFPExceptions.1" title="function: SetAccumulatedFPExceptions(bits(8) accumulated_exceptions)">SetAccumulatedFPExceptions</a>(accumulated_exceptions);
    elsif <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        // Set the cumulative exception bit
        FPSCR&lt;cumul&gt; = '1';
    else
        // Set the cumulative exception bit
        FPSR&lt;cumul&gt; = '1';

    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessnan.FPProcessNaN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessnan/FPProcessNaN</h3>
      <p class="pseudocode">// FPProcessNaN()
// ==============

bits(N) <a id="impl-shared.FPProcessNaN.3"/>FPProcessNaN(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype, bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(fptype, op, fpcr, fpexc);

// FPProcessNaN()
// ==============
// Handle NaN input operands, returning the operand or default NaN value
// if fpcr.DN is selected. The 'fpcr' argument supplies the FPCR control bits.
// The 'fpexc' argument controls the generation of exceptions, regardless of
// whether 'fptype' is a signalling NaN or a quiet NaN.

bits(N) <a id="impl-shared.FPProcessNaN.4"/>FPProcessNaN(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype, bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};
    assert fptype IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    integer topfrac;

    case N of
        when 16 topfrac =  9;
        when 32 topfrac = 22;
        when 64 topfrac = 51;

    result = op;
    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        result&lt;topfrac&gt; = '1';
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    if fpcr.DN == '1' then  // DefaultNaN requested
        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessnans.FPProcessNaNs"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessnans/FPProcessNaNs</h3>
      <p class="pseudocode">// FPProcessNaNs()
// ===============

(boolean, bits(N)) <a id="impl-shared.FPProcessNaNs.5"/>FPProcessNaNs(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, bits(N) op1,
                                 bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc       = TRUE;     // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.6" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, fpexc);

// FPProcessNaNs()
// ===============
//
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits and 'altfmaxfmin' controls
// alternative floating-point behavior for FMAX, FMIN and variants. 'fpexc'
// controls the generation of floating-point exceptions. Status information
// is updated directly in the FPSR where appropriate.

(boolean, bits(N)) <a id="impl-shared.FPProcessNaNs.6"/>FPProcessNaNs(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, bits(N) op1, bits(N) op2,
                                 <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};
    boolean done;
    bits(N) result;
    boolean altfp    = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean op1_nan  = type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op2_nan  = type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean any_snan = type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
    <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a>  type_nan = if any_snan then <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> else <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>;

    if altfp &amp;&amp; op1_nan &amp;&amp; op2_nan then
        // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op1, fpcr, fpexc);
    elsif type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc);
    elsif type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc);
    else
        done = FALSE;  result = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N);  // 'Don't care' result

    return (done, result);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessnans3.FPProcessNaNs3"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessnans3/FPProcessNaNs3</h3>
      <p class="pseudocode">// FPProcessNaNs3()
// ================

(boolean, bits(N)) <a id="impl-shared.FPProcessNaNs3.7"/>FPProcessNaNs3(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3,
                                  bits(N) op1, bits(N) op2, bits(N) op3,
                                  <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs3.8" title="function: (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N) op2, bits(N) op3,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs3</a>(type1, type2, type3, op1, op2, op3, fpcr, fpexc);

// FPProcessNaNs3()
// ================
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits and 'fpexc' controls the
// generation of floating-point exceptions. Status information is updated
// directly in the FPSR where appropriate.

(boolean, bits(N)) <a id="impl-shared.FPProcessNaNs3.8"/>FPProcessNaNs3(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3,
                                  bits(N) op1, bits(N) op2, bits(N) op3,
                                  <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};
    bits(N) result;
    boolean op1_nan = type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op2_nan = type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op3_nan = type3 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};

    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type_nan;
    if altfp then
        if type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type3 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
            type_nan = <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
        else
            type_nan = <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>;

    boolean done;
    if altfp &amp;&amp; op1_nan &amp;&amp; op2_nan &amp;&amp; op3_nan then
        // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op2, fpcr, fpexc);
    elsif altfp &amp;&amp; op2_nan &amp;&amp; (op1_nan || op3_nan) then
        // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op2, fpcr, fpexc);
    elsif altfp &amp;&amp; op3_nan &amp;&amp; op1_nan then
        // &lt;m&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op3, fpcr, fpexc);
    elsif type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc);
    elsif type3 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc);
    elsif type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc);
    elsif type3 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc);
    else
        done = FALSE;  result = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N);  // 'Don't care' result

    return (done, result);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessnans4.FPProcessNaNs4"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessnans4/FPProcessNaNs4</h3>
      <p class="pseudocode">// FPProcessNaNs4()
// ================
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits.
// Status information is updated directly in the FPSR where appropriate.
// The 'fpexc' controls the generation of floating-point exceptions.

(boolean, bits(N)) <a id="impl-shared.FPProcessNaNs4.10"/>FPProcessNaNs4(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type4,
                                  bits(N DIV 2) op1, bits(N DIV 2) op2, bits(N DIV 2) op3,
                                  bits(N DIV 2) op4, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N == 32;

    bits(N) result;
    boolean done;
    // The FPCR.AH control does not affect these checks
    if type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc), N);
    elsif type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc), N);
    elsif type3 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc), N);
    elsif type4 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type4, op4, fpcr, fpexc), N);
    elsif type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc), N);
    elsif type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc), N);
    elsif type3 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc), N);
    elsif type4 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.2" title="function: bits(M) FPConvertNaN(bits(N) op, integer M)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type4, op4, fpcr, fpexc), N);
    else
        done = FALSE;  result = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N);  // 'Don't care' result

    return (done, result);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprecipestimate.FPRecipEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprecipestimate/FPRecipEstimate</h3>
      <p class="pseudocode">// FPRecipEstimate()
// =================

bits(N) <a id="impl-shared.FPRecipEstimate.2"/>FPRecipEstimate(bits(N) operand, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)

    assert N IN {16,32,64};
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    bits(N) result;
    boolean overflow_to_inf;
    // When using alternative floating-point behavior, do not generate
    // floating-point exceptions, flush denormal input and output to zero,
    // and use RNE rounding mode.
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';
    if altfp then fpcr.RMode    = '00';

    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(operand, fpcr, fpexc);

    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(fptype, operand, fpcr, fpexc);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, N);
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</a>, fpcr);
    elsif (
            (N == 16 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value) &lt; 2.0^-16) ||
            (N == 32 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value) &lt; 2.0^-128) ||
            (N == 64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value) &lt; 2.0^-1024)
          ) then
        case rounding of
            when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                overflow_to_inf = TRUE;
            when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                overflow_to_inf = (sign == '0');
            when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                overflow_to_inf = (sign == '1');
            when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>
                overflow_to_inf = FALSE;
        result = if overflow_to_inf then <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, N) else <a href="shared_pseudocode.html#impl-shared.FPMaxNormal.2" title="function: bits(N) FPMaxNormal(bit sign, integer N)">FPMaxNormal</a>(sign, N);
        if fpexc then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Overflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Overflow</a>, fpcr);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);
    elsif ((fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16))
          &amp;&amp; (
               (N == 16 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value) &gt;= 2.0^14) ||
               (N == 32 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value) &gt;= 2.0^126) ||
               (N == 64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value) &gt;= 2.0^1022)
             ) then
        // Result flushed to zero of correct sign
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);

        // Flush-to-zero never generates a trapped exception.
        if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            FPSCR.UFC = '1';
        else
            if fpexc then FPSR.UFC = '1';
    else
        // Scale to a fixed point value in the range 0.5 &lt;= x &lt; 1.0 in steps of 1/512, and
        // calculate result exponent. Scaled value has copied sign bit,
        // exponent = 1022 = double-precision biased version of -1,
        // fraction = original fraction
        bits(52) fraction;
        integer exp;
        case N of
            when 16
                fraction = operand&lt;9:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(42);
                exp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;14:10&gt;);
            when 32
                fraction = operand&lt;22:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(29);
                exp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;30:23&gt;);
            when 64
                fraction = operand&lt;51:0&gt;;
                exp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;62:52&gt;);

        if exp == 0 then
            if fraction&lt;51&gt; == '0' then
                exp = -1;
                fraction = fraction&lt;49:0&gt;:'00';
            else
                fraction = fraction&lt;50:0&gt;:'0';

        integer scaled;
        boolean increasedprecision = N==32 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatRPRES.0" title="function: boolean HaveFeatRPRES()">HaveFeatRPRES</a>() &amp;&amp; altfp;

        if !increasedprecision then
            scaled = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('1':fraction&lt;51:44&gt;);
        else
            scaled = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('1':fraction&lt;51:41&gt;);

        integer result_exp;
        case N of
            when 16 result_exp =   29 - exp; // In range 29-30 = -1 to 29+1 = 30
            when 32 result_exp =  253 - exp; // In range 253-254 = -1 to 253+1 = 254
            when 64 result_exp = 2045 - exp; // In range 2045-2046 = -1 to 2045+1 = 2046

        // Scaled is in range 256 .. 511 or 2048 .. 4095 range representing a
        // fixed-point number in range [0.5 .. 1.0].
        estimate = <a href="shared_pseudocode.html#impl-shared.RecipEstimate.2" title="function: integer RecipEstimate(integer a_in, boolean increasedprecision)">RecipEstimate</a>(scaled, increasedprecision);

        // Estimate is in the range 256 .. 511 or 4096 .. 8191 representing a
        // fixed-point result in the range [1.0 .. 2.0].
        // Convert to scaled floating point result with copied sign bit,
        // high-order bits from estimate, and exponent calculated above.
        if !increasedprecision then
            fraction = estimate&lt;7:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(44);
        else
            fraction = estimate&lt;11:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(40);

        if result_exp == 0 then
            fraction = '1' : fraction&lt;51:1&gt;;
        elsif result_exp == -1 then
            fraction = '01' : fraction&lt;51:2&gt;;
            result_exp = 0;

        case N of
            when 16 result = sign : result_exp&lt;N-12:0&gt; : fraction&lt;51:42&gt;;
            when 32 result = sign : result_exp&lt;N-25:0&gt; : fraction&lt;51:29&gt;;
            when 64 result = sign : result_exp&lt;N-54:0&gt; : fraction&lt;51:0&gt;;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprecipestimate.RecipEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprecipestimate/RecipEstimate</h3>
      <p class="pseudocode">// RecipEstimate()
// ===============
// Compute estimate of reciprocal of 9-bit fixed-point number.
//
// a is in range 256 .. 511 or 2048 .. 4096 representing a number in
// the range 0.5 &lt;= x &lt; 1.0.
// increasedprecision determines if the mantissa is 8-bit or 12-bit.
// result is in the range 256 .. 511 or 4096 .. 8191 representing a
// number in the range 1.0 to 511/256 or 1.00 to 8191/4096.

integer <a id="impl-shared.RecipEstimate.2"/>RecipEstimate(integer a_in, boolean increasedprecision)

    integer a = a_in;
    integer r;
    if !increasedprecision then
        assert 256 &lt;= a &amp;&amp; a &lt; 512;
        a = a*2+1;                       // Round to nearest
        integer b = (2 ^ 19) DIV a;
        r = (b+1) DIV 2;                 // Round to nearest
        assert 256 &lt;= r &amp;&amp; r &lt; 512;
    else
        assert 2048 &lt;= a &amp;&amp; a &lt; 4096;
        a = a*2+1;                       // Round to nearest
        real real_val = Real(2^25)/Real(a);
        r = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(real_val);
        real error = real_val - Real(r);
        boolean round_up = error &gt; 0.5;  // Error cannot be exactly 0.5 so do not need tie case
        if round_up then r = r+1;
        assert 4096 &lt;= r &amp;&amp; r &lt; 8192;

    return r;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprecpx.FPRecpX"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprecpx/FPRecpX</h3>
      <p class="pseudocode">// FPRecpX()
// =========

bits(N) <a id="impl-shared.FPRecpX.2"/>FPRecpX(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)

    assert N IN {16,32,64};
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    integer esize;
    case N of
        when 16 esize =  5;
        when 32 esize =  8;
        when 64 esize = 11;

    bits(N)           result;
    bits(esize)       exp;
    bits(esize)       max_exp;
    bits(N-(esize+1)) frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N-(esize+1));

    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;                 // Generate no floating-point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';     // Flush denormal input and output to zero
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    case N of
        when 16 exp = op&lt;10+esize-1:10&gt;;
        when 32 exp = op&lt;23+esize-1:23&gt;;
        when 64 exp = op&lt;52+esize-1:52&gt;;

    max_exp = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(esize) - 1;

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(fptype, op, fpcr, fpexc);
    else
        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(exp) then                 // Zero and denormals
            result = sign:max_exp:frac;
        else                                // Infinities and normals
            result = sign:NOT(exp):frac;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpround.FPRound"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpround/FPRound</h3>
      <p class="pseudocode">// FPRound()
// =========
// Generic conversion from precise, unbounded real data type to IEEE format.

bits(N) <a id="impl-shared.FPRound.3"/>FPRound(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, integer N)
    return <a href="shared_pseudocode.html#impl-shared.FPRound.4" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, integer N)">FPRound</a>(op, fpcr, <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr), N);

// FPRound()
// =========
// For directed FP conversion, includes an explicit 'rounding' argument.

bits(N) <a id="impl-shared.FPRound.4"/>FPRound(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, integer N)
    boolean fpexc = TRUE;    // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPRound.5" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc, integer N)">FPRound</a>(op, fpcr_in, rounding, fpexc, N);

// FPRound()
// =========
// For AltFP, includes an explicit FPEXC argument to disable exception
// generation and switches off Arm alternate half-precision mode.

bits(N) <a id="impl-shared.FPRound.5"/>FPRound(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, boolean fpexc, integer N)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.AHP = '0';
    boolean isbfloat16 = FALSE;
    return <a href="shared_pseudocode.html#impl-shared.FPRoundBase.6" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc, integer N)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc, N);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpround.FPRoundBase"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpround/FPRoundBase</h3>
      <p class="pseudocode">// FPRoundBase()
// =============
// For BFloat16, includes an explicit 'isbfloat16' argument.

bits(N) <a id="impl-shared.FPRoundBase.5"/>FPRoundBase(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, boolean isbfloat16, integer N)
    boolean fpexc = TRUE;    // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPRoundBase.6" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc, integer N)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc, N);

// FPRoundBase()
// =============
// Convert a real number 'op' into an N-bit floating-point value using the
// supplied rounding mode 'rounding'.
//
// The 'fpcr' argument supplies FPCR control bits and 'fpexc' controls the
// generation of floating-point exceptions. Status information is updated
// directly in the FPSR where appropriate.

bits(N) <a id="impl-shared.FPRoundBase.6"/>FPRoundBase(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding,
                    boolean isbfloat16, boolean fpexc, integer N)

    assert N IN {16,32,64};
    assert op != 0.0;
    assert rounding != <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>;
    bits(N) result;

    // Obtain format parameters - minimum exponent, numbers of exponent and fraction bits.
    integer minimum_exp;
    integer F;
    integer E;
    if N == 16 then
        minimum_exp = -14;  E = 5;  F = 10;
    elsif N == 32 &amp;&amp; isbfloat16 then
        minimum_exp = -126;  E = 8;  F = 7;
    elsif N == 32 then
        minimum_exp = -126;  E = 8;  F = 23;
    else  // N == 64
        minimum_exp = -1022;  E = 11;  F = 52;

    // Split value into sign, unrounded mantissa and exponent.
    bit sign;
    real mantissa;
    if op &lt; 0.0 then
        sign = '1';  mantissa = -op;
    else
        sign = '0';  mantissa = op;
    exponent = 0;
    while mantissa &lt; 1.0 do
        mantissa = mantissa * 2.0;  exponent = exponent - 1;
    while mantissa &gt;= 2.0 do
        mantissa = mantissa / 2.0;  exponent = exponent + 1;

    // When TRUE, detection of underflow occurs after rounding and the test for a
    // denormalized number for single and double precision values occurs after rounding.
    altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';

    // Deal with flush-to-zero before rounding if FPCR.AH != '1'.
    if (!altfp &amp;&amp; ((fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16)) &amp;&amp;
        exponent &lt; minimum_exp) then
        // Flush-to-zero never generates a trapped exception.
        if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            FPSCR.UFC = '1';
        else
            if fpexc then FPSR.UFC = '1';
        return <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);

    biased_exp_unconstrained = (exponent - minimum_exp) + 1;
    int_mant_unconstrained = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(mantissa * 2.0^F);
    error_unconstrained = mantissa * 2.0^F - Real(int_mant_unconstrained);

    // Start creating the exponent value for the result. Start by biasing the actual exponent
    // so that the minimum exponent becomes 1, lower values 0 (indicating possible underflow).
    biased_exp = <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>((exponent - minimum_exp) + 1, 0);
    if biased_exp == 0 then mantissa = mantissa / 2.0^(minimum_exp - exponent);

    // Get the unrounded mantissa as an integer, and the "units in last place" rounding error.
    int_mant = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(mantissa * 2.0^F);  // &lt; 2.0^F if biased_exp == 0, &gt;= 2.0^F if not
    error = mantissa * 2.0^F - Real(int_mant);

    // Underflow occurs if exponent is too small before rounding, and result is inexact or
    // the Underflow exception is trapped. This applies before rounding if FPCR.AH != '1'.
    boolean trapped_UF = fpcr.UFE == '1' &amp;&amp; (!<a href="shared_pseudocode.html#impl-aarch64.InStreamingMode.0" title="function: boolean InStreamingMode()">InStreamingMode</a>() || <a href="shared_pseudocode.html#impl-aarch64.IsFullA64Enabled.0" title="function: boolean IsFullA64Enabled()">IsFullA64Enabled</a>());
    if !altfp &amp;&amp; biased_exp == 0 &amp;&amp; (error != 0.0 || trapped_UF) then
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Underflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Underflow</a>, fpcr);

    // Round result according to rounding mode.
    boolean round_up_unconstrained;
    boolean round_up;
    boolean overflow_to_inf;
    if altfp then

        case rounding of
            when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                round_up_unconstrained = (error_unconstrained &gt; 0.5 ||
                   (error_unconstrained == 0.5 &amp;&amp; int_mant_unconstrained&lt;0&gt; == '1'));
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_mant&lt;0&gt; == '1'));
                overflow_to_inf = TRUE;
            when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                round_up_unconstrained = (error_unconstrained != 0.0 &amp;&amp; sign == '0');
                round_up = (error != 0.0 &amp;&amp; sign == '0');
                overflow_to_inf = (sign == '0');
            when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                round_up_unconstrained = (error_unconstrained != 0.0 &amp;&amp; sign == '1');
                round_up = (error != 0.0 &amp;&amp; sign == '1');
                overflow_to_inf = (sign == '1');
            when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>, <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>
                round_up_unconstrained = FALSE;
                round_up = FALSE;
                overflow_to_inf = FALSE;

        if round_up_unconstrained then
            int_mant_unconstrained = int_mant_unconstrained + 1;
            if int_mant_unconstrained == 2^(F+1) then    // Rounded up to next exponent
                biased_exp_unconstrained = biased_exp_unconstrained + 1;
                int_mant_unconstrained   = int_mant_unconstrained DIV 2;

        // Deal with flush-to-zero and underflow after rounding if FPCR.AH == '1'.
        if biased_exp_unconstrained &lt; 1 &amp;&amp; int_mant_unconstrained != 0 then
            // the result of unconstrained rounding is less than the minimum normalized number
            if (fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16) then   // Flush-to-zero
                if fpexc then
                    FPSR.UFC = '1';
                    <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);
                return <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);
            elsif error != 0.0 || trapped_UF then
                if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Underflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Underflow</a>, fpcr);
    else    // altfp == FALSE
        case rounding of
            when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_mant&lt;0&gt; == '1'));
                overflow_to_inf = TRUE;
            when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                round_up = (error != 0.0 &amp;&amp; sign == '0');
                overflow_to_inf = (sign == '0');
            when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                round_up = (error != 0.0 &amp;&amp; sign == '1');
                overflow_to_inf = (sign == '1');
            when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>, <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>
                round_up = FALSE;
                overflow_to_inf = FALSE;

    if round_up then
        int_mant = int_mant + 1;
        if int_mant == 2^F then      // Rounded up from denormalized to normalized
            biased_exp = 1;
        if int_mant == 2^(F+1) then  // Rounded up to next exponent
            biased_exp = biased_exp + 1;
            int_mant = int_mant DIV 2;

    // Handle rounding to odd
    if error != 0.0 &amp;&amp; rounding == <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a> then
        int_mant&lt;0&gt; = '1';

    // Deal with overflow and generate result.
    if N != 16 || fpcr.AHP == '0' then  // Single, double or IEEE half precision
        if biased_exp &gt;= 2^E - 1 then
            result = if overflow_to_inf then <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, N) else <a href="shared_pseudocode.html#impl-shared.FPMaxNormal.2" title="function: bits(N) FPMaxNormal(bit sign, integer N)">FPMaxNormal</a>(sign, N);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Overflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Overflow</a>, fpcr);
            error = 1.0;  // Ensure that an Inexact exception occurs
        else
            result = sign : biased_exp&lt;E-1:0&gt; : int_mant&lt;F-1:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N-(E+F+1));
    else                                     // Alternative half precision
        if biased_exp &gt;= 2^E then
            result = sign : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(N-1);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
            error = 0.0;  // Ensure that an Inexact exception does not occur
        else
            result = sign : biased_exp&lt;E-1:0&gt; : int_mant&lt;F-1:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N-(E+F+1));

    // Deal with Inexact exception.
    if error != 0.0 then
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpround.FPRoundCV"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpround/FPRoundCV</h3>
      <p class="pseudocode">// FPRoundCV()
// ===========
// Used for FP to FP conversion instructions.
// For half-precision data ignores FZ16 and observes AHP.

bits(N) <a id="impl-shared.FPRoundCV.4"/>FPRoundCV(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, integer N)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.FZ16 = '0';
    boolean fpexc = TRUE;    // Generate floating-point exceptions
    boolean isbfloat16 = FALSE;
    return <a href="shared_pseudocode.html#impl-shared.FPRoundBase.6" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc, integer N)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc, N);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprounding.FPRounding"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprounding/FPRounding</h3>
      <p class="pseudocode">enumeration <a id="FPRounding"/>FPRounding  {<a id="FPRounding_TIEEVEN"/>FPRounding_TIEEVEN, <a id="FPRounding_POSINF"/>FPRounding_POSINF,
                         <a id="FPRounding_NEGINF"/>FPRounding_NEGINF,  <a id="FPRounding_ZERO"/>FPRounding_ZERO,
                         <a id="FPRounding_TIEAWAY"/>FPRounding_TIEAWAY, <a id="FPRounding_ODD"/>FPRounding_ODD};</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fproundingmode.FPRoundingMode"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fproundingmode/FPRoundingMode</h3>
      <p class="pseudocode">// FPRoundingMode()
// ================
// Return the current floating-point rounding mode.

FPRounding <a id="impl-shared.FPRoundingMode.1"/>FPRoundingMode(<a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    return <a href="shared_pseudocode.html#impl-shared.FPDecodeRounding.1" title="function: FPRounding FPDecodeRounding(bits(2) rmode)">FPDecodeRounding</a>(fpcr.RMode);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fproundint.FPRoundInt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fproundint/FPRoundInt</h3>
      <p class="pseudocode">// FPRoundInt()
// ============

// Round op to nearest integral floating point value using rounding mode in FPCR/FPSCR.
// If EXACT is TRUE, set FPSR.IXC if result is not numerically equal to op.

bits(N) <a id="impl-shared.FPRoundInt.4"/>FPRoundInt(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, boolean exact)

    assert rounding != <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>;
    assert N IN {16,32,64};

    // When alternative floating-point support is TRUE, do not generate
    // Input Denormal floating-point exceptions.
    altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    fpexc = !altfp;

    // Unpack using FPCR to determine if subnormals are flushed-to-zero.
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    bits(N) result;
    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr)">FPProcessNaN</a>(fptype, op, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, N);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);
    else
        // Extract integer component.
        int_result = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(value);
        error = value - Real(int_result);

        // Determine whether supplied rounding mode requires an increment.
        boolean round_up;
        case rounding of
            when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0&gt; == '1'));
            when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                round_up = (error != 0.0);
            when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                round_up = FALSE;
            when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>
                round_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
            when <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result &gt;= 0));

        if round_up then int_result = int_result + 1;

        // Convert integer value into an equivalent real value.
        real_result = Real(int_result);

        // Re-encode as a floating-point value, result is always exact.
        if real_result == 0.0 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPRound.4" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, integer N)">FPRound</a>(real_result, fpcr, <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>, N);

        // Generate inexact exceptions.
        if error != 0.0 &amp;&amp; exact then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fproundintn.FPRoundIntN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fproundintn/FPRoundIntN</h3>
      <p class="pseudocode">// FPRoundIntN()
// =============

bits(N) <a id="impl-shared.FPRoundIntN.4"/>FPRoundIntN(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, integer intsize)
    assert rounding != <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>;
    assert N IN {32,64};
    assert intsize IN {32, 64};
    integer exp;
    bits(N) result;
    boolean round_up;
    constant integer E = (if N == 32 then 8 else 11);
    constant integer F = N - (E + 1);

    // When alternative floating-point support is TRUE, do not generate
    // Input Denormal floating-point exceptions.
    altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    fpexc = !altfp;

    // Unpack using FPCR to determine if subnormals are flushed-to-zero.
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    if fptype IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>} then
        if N == 32 then
            exp = 126 + intsize;
            result = '1':exp&lt;(E-1):0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
        else
            exp = 1022+intsize;
            result = '1':exp&lt;(E-1):0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);
    else
        // Extract integer component.
        int_result = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(value);
        error = value - Real(int_result);

        // Determine whether supplied rounding mode requires an increment.
        case rounding of
            when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                round_up = error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0&gt; == '1');
            when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                round_up = error != 0.0;
            when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                round_up = FALSE;
            when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>
                round_up = error != 0.0 &amp;&amp; int_result &lt; 0;
            when <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>
                round_up = error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result &gt;= 0);

        if round_up then int_result = int_result + 1;
        overflow = int_result &gt; 2^(intsize-1)-1 || int_result &lt; -1*2^(intsize-1);

        if overflow then
            if N == 32 then
                exp = 126 + intsize;
                result = '1':exp&lt;(E-1):0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
            else
                exp = 1022 + intsize;
                result = '1':exp&lt;(E-1):0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
            // This case shouldn't set Inexact.
            error = 0.0;

        else
            // Convert integer value into an equivalent real value.
            real_result = Real(int_result);

            // Re-encode as a floating-point value, result is always exact.
            if real_result == 0.0 then
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.4" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, integer N)">FPRound</a>(real_result, fpcr, <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>, N);

        // Generate inexact exceptions.
        if error != 0.0 then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprsqrtestimate.FPRSqrtEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprsqrtestimate/FPRSqrtEstimate</h3>
      <p class="pseudocode">// FPRSqrtEstimate()
// =================

bits(N) <a id="impl-shared.FPRSqrtEstimate.2"/>FPRSqrtEstimate(bits(N) operand, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)

    assert N IN {16,32,64};
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;

    // When using alternative floating-point behavior, do not generate
    // floating-point exceptions and flush denormal input to zero.
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';

    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(operand, fpcr, fpexc);

    bits(N) result;
    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(fptype, operand, fpcr, fpexc);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, N);
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</a>, fpcr);
    elsif sign == '1' then
        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>('0', N);
    else
        // Scale to a fixed-point value in the range 0.25 &lt;= x &lt; 1.0 in steps of 512, with the
        // evenness or oddness of the exponent unchanged, and calculate result exponent.
        // Scaled value has copied sign bit, exponent = 1022 or 1021 = double-precision
        // biased version of -1 or -2, fraction = original fraction extended with zeros.

        bits(52) fraction;
        integer exp;
        case N of
            when 16
                fraction = operand&lt;9:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(42);
                exp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;14:10&gt;);
            when 32
                fraction = operand&lt;22:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(29);
                exp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;30:23&gt;);
            when 64
                fraction = operand&lt;51:0&gt;;
                exp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;62:52&gt;);

        if exp == 0 then
            while fraction&lt;51&gt; == '0' do
                fraction = fraction&lt;50:0&gt; : '0';
                exp = exp - 1;
            fraction = fraction&lt;50:0&gt; : '0';

        integer scaled;
        boolean increasedprecision = N==32 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatRPRES.0" title="function: boolean HaveFeatRPRES()">HaveFeatRPRES</a>() &amp;&amp; altfp;

        if !increasedprecision then
            if exp&lt;0&gt; == '0' then
                scaled = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('1':fraction&lt;51:44&gt;);
            else
                scaled = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('01':fraction&lt;51:45&gt;);
        else
            if exp&lt;0&gt; == '0' then
                scaled = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('1':fraction&lt;51:41&gt;);
            else
                scaled = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('01':fraction&lt;51:42&gt;);

        integer result_exp;
        case N of
            when 16 result_exp = (  44 - exp) DIV 2;
            when 32 result_exp = ( 380 - exp) DIV 2;
            when 64 result_exp = (3068 - exp) DIV 2;

        estimate = <a href="shared_pseudocode.html#impl-shared.RecipSqrtEstimate.2" title="function: integer RecipSqrtEstimate(integer a_in, boolean increasedprecision)">RecipSqrtEstimate</a>(scaled, increasedprecision);

        // Estimate is in the range 256 .. 511 or 4096 .. 8191 representing a
        // fixed-point result in the range [1.0 .. 2.0].
        // Convert to scaled floating point result with copied sign bit and high-order
        // fraction bits, and exponent calculated above.
        case N of
            when 16 result = '0' : result_exp&lt;N-12:0&gt; : estimate&lt;7:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(2);
            when 32
                if !increasedprecision then
                    result = '0' : result_exp&lt;N-25:0&gt; : estimate&lt;7:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(15);
                else
                    result = '0' : result_exp&lt;N-25:0&gt; : estimate&lt;11:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(11);
            when 64 result = '0' : result_exp&lt;N-54:0&gt; : estimate&lt;7:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(44);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprsqrtestimate.RecipSqrtEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprsqrtestimate/RecipSqrtEstimate</h3>
      <p class="pseudocode">// RecipSqrtEstimate()
// ===================
// Compute estimate of reciprocal square root of 9-bit fixed-point number.
//
// a_in is in range 128 .. 511 or 1024 .. 4095, with increased precision,
// representing a number in the range 0.25 &lt;= x &lt; 1.0.
// increasedprecision determines if the mantissa is 8-bit or 12-bit.
// result is in the range 256 .. 511 or 4096 .. 8191, with increased precision,
// representing a number in the range 1.0 to 511/256 or 8191/4096.

integer <a id="impl-shared.RecipSqrtEstimate.2"/>RecipSqrtEstimate(integer a_in, boolean increasedprecision)

    integer a = a_in;
    integer r;
    if !increasedprecision then
        assert 128 &lt;= a &amp;&amp; a &lt; 512;
        if a &lt; 256 then                      // 0.25 .. 0.5
            a = a*2+1;                       // a in units of 1/512 rounded to nearest
        else                                 // 0.5 .. 1.0
            a = (a &gt;&gt; 1) &lt;&lt; 1;               // Discard bottom bit
            a = (a+1)*2;                     // a in units of 1/256 rounded to nearest
        integer b = 512;
        while a*(b+1)*(b+1) &lt; 2^28 do
            b = b+1;
        // b = largest b such that b &lt; 2^14 / sqrt(a)
        r = (b+1) DIV 2;                     // Round to nearest
        assert 256 &lt;= r &amp;&amp; r &lt; 512;
    else
        assert 1024 &lt;= a &amp;&amp; a &lt; 4096;
        real real_val;
        real error;
        integer int_val;

        if a &lt; 2048 then                     // 0.25... 0.5
            a = a*2 + 1;                     // Take 10 bits of fraction and force a 1 at the bottom
            real_val = Real(a)/2.0;
        else                                 // 0.5..1.0
            a = (a &gt;&gt; 1) &lt;&lt; 1;               // Discard bottom bit
            a = a+1;                         // Take 10 bits of fraction and force a 1 at the bottom
            real_val = Real(a);

        real_val = Sqrt(real_val);           // This number will lie in the range of 32 to 64
                                             // Round to nearest even for a DP float number
        real_val = real_val * Real(2^47);    // The integer is the size of the whole DP mantissa
        int_val  = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(real_val);      // Calculate rounding value
        error    = real_val - Real(int_val);
        round_up = error &gt; 0.5;              // Error cannot be exactly 0.5 so do not need tie case
        if round_up then int_val = int_val+1;

        real_val = Real(2^65)/Real(int_val); // Lies in the range 4096 &lt;= real_val &lt; 8192
        int_val  = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(real_val);      // Round that (to nearest even) to give integer
        error    = real_val - Real(int_val);
        round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_val&lt;0&gt; == '1'));
        if round_up then int_val = int_val+1;

        r = int_val;
        assert 4096 &lt;= r &amp;&amp; r &lt; 8192;

    return r;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpsqrt.FPSqrt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpsqrt/FPSqrt</h3>
      <p class="pseudocode">// FPSqrt()
// ========

bits(N) <a id="impl-shared.FPSqrt.2"/>FPSqrt(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op, fpcr);

    bits(N) result;
    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr)">FPProcessNaN</a>(fptype, op, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign, N);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> &amp;&amp; sign == '0' then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>(sign, N);
    elsif sign == '1' then
        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        result = <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, integer N)">FPRound</a>(Sqrt(value), fpcr, N);
        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorm.3" title="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(fptype, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpsub.FPSub"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpsub/FPSub</h3>
      <p class="pseudocode">// FPSub()
// =======

bits(N) <a id="impl-shared.FPSub.3"/>FPSub(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPSub.4" title="function: bits(N) FPSub(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPSub</a>(op1, op2, fpcr, fpexc);

// FPSub()
// =======

bits(N) <a id="impl-shared.FPSub.4"/>FPSub(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};
    rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.6" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, fpexc);
    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.2" title="function: bits(N) FPDefaultNaN(FPCRType fpcr, integer N)">FPDefaultNaN</a>(fpcr, N);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('0', N);
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.2" title="function: bits(N) FPInfinity(bit sign, integer N)">FPInfinity</a>('1', N);
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(sign1, N);
        else
            result_value = value1 - value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.2" title="function: bits(N) FPZero(bit sign, integer N)">FPZero</a>(result_sign, N);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.5" title="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc, integer N)">FPRound</a>(result_value, fpcr, rounding, fpexc, N);

        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpsub.FPSub_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpsub/FPSub_ZA</h3>
      <p class="pseudocode">// FPSub_ZA()
// ==========
// Calculates op1-op2 for SME2 ZA-targeting instructions.

bits(N) <a id="impl-shared.FPSub_ZA.3"/>FPSub_ZA(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    boolean fpexc = FALSE;      // Do not generate floating-point exceptions
    fpcr.DN = '1';              // Generate default NaN values
    return <a href="shared_pseudocode.html#impl-shared.FPSub.4" title="function: bits(N) FPSub(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPSub</a>(op1, op2, fpcr, fpexc);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpthree.FPThree"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpthree/FPThree</h3>
      <p class="pseudocode">// FPThree()
// =========

bits(N) <a id="impl-shared.FPThree.2"/>FPThree(bit sign, integer N)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '1':<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(E-1);
    frac = '1':<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F-1);
    result = sign : exp : frac;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fptofixed.FPToFixed"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fptofixed/FPToFixed</h3>
      <p class="pseudocode">// FPToFixed()
// ===========

// Convert N-bit precision floating point 'op' to M-bit fixed point with
// FBITS fractional bits, controlled by UNSIGNED and ROUNDING.

bits(M) <a id="impl-shared.FPToFixed.6"/>FPToFixed(bits(N) op, integer fbits, boolean unsigned, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, integer M)

    assert N IN {16,32,64};
    assert M IN {16,32,64};
    assert fbits &gt;= 0;
    assert rounding != <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>;

    // When alternative floating-point support is TRUE, do not generate
    // Input Denormal floating-point exceptions.
    altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    fpexc = !altfp;

    // Unpack using fpcr to determine if subnormals are flushed-to-zero.
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    // If NaN, set cumulative flag or take exception.
    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    // Scale by fractional bits and produce integer rounded towards minus-infinity.
    value = value * 2.0^fbits;
    int_result = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(value);
    error = value - Real(int_result);

    // Determine whether supplied rounding mode requires an increment.
    boolean round_up;
    case rounding of
        when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
            round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0&gt; == '1'));
        when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
            round_up = (error != 0.0);
        when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
            round_up = FALSE;
        when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>
            round_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
        when <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>
            round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result &gt;= 0));

    if round_up then int_result = int_result + 1;

    // Generate saturated result and exceptions.
    (result, overflow) = <a href="shared_pseudocode.html#impl-shared.SatQ.3" title="function: (bits(N), boolean) SatQ(integer i, integer N, boolean unsigned)">SatQ</a>(int_result, M, unsigned);
    if overflow then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    elsif error != 0.0 then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fptofixedjs.FPToFixedJS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fptofixedjs/FPToFixedJS</h3>
      <p class="pseudocode">// FPToFixedJS()
// =============

// Converts a double precision floating point input value
// to a signed integer, with rounding to zero.

(bits(N), bit) <a id="impl-shared.FPToFixedJS.4"/>FPToFixedJS(bits(M) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean Is64, integer N)

    assert M == 64 &amp;&amp; N == 32;

    // If FALSE, never generate Input Denormal floating-point exceptions.
    fpexc_idenorm = !(<a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1');

    // Unpack using fpcr to determine if subnormals are flushed-to-zero.
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc_idenorm);

    z = '1';
    // If NaN, set cumulative flag or take exception.
    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        z = '0';

    int_result = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(value);
    error = value - Real(int_result);

    // Determine whether supplied rounding mode requires an increment.

    round_it_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
    if round_it_up then int_result = int_result + 1;

    integer result;
    if int_result &lt; 0 then
        result = int_result - 2^32*<a href="shared_pseudocode.html#impl-shared.RoundUp.1" title="function: integer RoundUp(real x)">RoundUp</a>(Real(int_result)/Real(2^32));
    else
        result = int_result - 2^32*<a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(Real(int_result)/Real(2^32));

    // Generate exceptions.
    if int_result &lt; -(2^31) || int_result &gt; (2^31)-1 then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        z = '0';
    elsif error != 0.0 then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);
        z = '0';
    elsif sign == '1' &amp;&amp; value == 0.0 then
        z = '0';
    elsif sign == '0' &amp;&amp; value == 0.0 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(op&lt;51:0&gt;) then
        z = '0';

    if fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then result = 0;

    return (result&lt;N-1:0&gt;, z);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fptwo.FPTwo"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fptwo/FPTwo</h3>
      <p class="pseudocode">// FPTwo()
// =======

bits(N) <a id="impl-shared.FPTwo.2"/>FPTwo(bit sign, integer N)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '1':<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(E-1);
    frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
    result = sign : exp : frac;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fptype.FPType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fptype/FPType</h3>
      <p class="pseudocode">enumeration <a id="FPType"/>FPType {<a id="FPType_Zero"/>FPType_Zero,
                    <a id="FPType_Denormal"/>FPType_Denormal,
                    <a id="FPType_Nonzero"/>FPType_Nonzero,
                    <a id="FPType_Infinity"/>FPType_Infinity,
                    <a id="FPType_QNaN"/>FPType_QNaN,
                    <a id="FPType_SNaN"/>FPType_SNaN};</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpunpack.FPUnpack"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpunpack/FPUnpack</h3>
      <p class="pseudocode">// FPUnpack()
// ==========

(FPType, bit, real) <a id="impl-shared.FPUnpack.2"/>FPUnpack(bits(N) fpval, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.AHP = '0';
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    (fp_type, sign, value) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.3" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpackBase</a>(fpval, fpcr, fpexc);
    return (fp_type, sign, value);

// FPUnpack()
// ==========
//
// Used by data processing, int/fixed to FP and FP to int/fixed conversion instructions.
// For half-precision data it ignores AHP, and observes FZ16.

(FPType, bit, real) <a id="impl-shared.FPUnpack.3"/>FPUnpack(bits(N) fpval, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, boolean fpexc)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.AHP = '0';
    (fp_type, sign, value) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.3" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpackBase</a>(fpval, fpcr, fpexc);
    return (fp_type, sign, value);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpunpack.FPUnpackBase"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpunpack/FPUnpackBase</h3>
      <p class="pseudocode">// FPUnpackBase()
// ==============

(FPType, bit, real) <a id="impl-shared.FPUnpackBase.3"/>FPUnpackBase(bits(N) fpval, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)
    boolean isbfloat16 = FALSE;
    (fp_type, sign, value) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(fpval, fpcr, fpexc, isbfloat16);
    return (fp_type, sign, value);

// FPUnpackBase()
// ==============
//
// Unpack a floating-point number into its type, sign bit and the real number
// that it represents. The real number result has the correct sign for numbers
// and infinities, is very large in magnitude for infinities, and is 0.0 for
// NaNs. (These values are chosen to simplify the description of comparisons
// and conversions.)
//
// The 'fpcr_in' argument supplies FPCR control bits, 'fpexc' controls the
// generation of floating-point exceptions and 'isbfloat16' determines whether
// N=16 signifies BFloat16 or half-precision type. Status information is updated
// directly in the FPSR where appropriate.

(FPType, bit, real) <a id="impl-shared.FPUnpackBase.4"/>FPUnpackBase(bits(N) fpval, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in, boolean fpexc,
                                 boolean isbfloat16)

    assert N IN {16,32,64};

    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;

    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    boolean fiz   = altfp &amp;&amp; fpcr.FIZ == '1';
    boolean fz    = fpcr.FZ == '1' &amp;&amp; !(altfp &amp;&amp; fpcr.AH == '1');
    real value;
    bit sign;
    <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype;

    if N == 16 &amp;&amp; !isbfloat16 then
        sign   = fpval&lt;15&gt;;
        exp16  = fpval&lt;14:10&gt;;
        frac16 = fpval&lt;9:0&gt;;
        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(exp16) then
            if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac16) || fpcr.FZ16 == '1' then
                fptype = <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
            else
                fptype = <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>;  value = 2.0^-14 * (Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac16)) * 2.0^-10);
        elsif <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exp16) &amp;&amp; fpcr.AHP == '0' then  // Infinity or NaN in IEEE format
            if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac16) then
                fptype = <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;  value = 2.0^1000000;
            else
                fptype = if frac16&lt;9&gt; == '1' then <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> else <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
                value = 0.0;
        else
            fptype = <a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</a>;
            value = 2.0^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(exp16)-15) * (1.0 + Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac16)) * 2.0^-10);

    elsif N == 32 || isbfloat16 then
        bits(8) exp32;
        bits(23) frac32;
        if isbfloat16 then
            sign   = fpval&lt;15&gt;;
            exp32  = fpval&lt;14:7&gt;;
            frac32 = fpval&lt;6:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
        else
            sign   = fpval&lt;31&gt;;
            exp32  = fpval&lt;30:23&gt;;
            frac32 = fpval&lt;22:0&gt;;

        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(exp32) then
            if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac32) then
                // Produce zero if value is zero.
                fptype = <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
            elsif fz || fiz then        // Flush-to-zero if FIZ==1 or AH,FZ==01
                fptype = <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
                // Check whether to raise Input Denormal floating-point exception.
                // fpcr.FIZ==1 does not raise Input Denormal exception.
                if fz then
                    // Denormalized input flushed to zero
                    if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);
            else
                fptype = <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>;  value = 2.0^-126 * (Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac32)) * 2.0^-23);
        elsif <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exp32) then
            if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac32) then
                fptype = <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;  value = 2.0^1000000;
            else
                fptype = if frac32&lt;22&gt; == '1' then <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> else <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
                value = 0.0;
        else
            fptype = <a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</a>;
            value = 2.0^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(exp32)-127) * (1.0 + Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac32)) * 2.0^-23);

    else // N == 64
        sign   = fpval&lt;63&gt;;
        exp64  = fpval&lt;62:52&gt;;
        frac64 = fpval&lt;51:0&gt;;

        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(exp64) then
            if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac64) then
                // Produce zero if value is zero.
                fptype = <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
            elsif fz || fiz then        // Flush-to-zero if FIZ==1 or AH,FZ==01
                fptype = <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
                // Check whether to raise Input Denormal floating-point exception.
                // fpcr.FIZ==1 does not raise Input Denormal exception.
                if fz then
                    // Denormalized input flushed to zero
                    if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);
            else
                fptype = <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>;  value = 2.0^-1022 * (Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac64)) * 2.0^-52);
        elsif <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exp64) then
            if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac64) then
                fptype = <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;  value = 2.0^1000000;
            else
                fptype = if frac64&lt;51&gt; == '1' then <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> else <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
                value = 0.0;
        else
            fptype = <a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</a>;
            value = 2.0^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(exp64)-1023) * (1.0 + Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac64)) * 2.0^-52);

    if sign == '1' then value = -value;

    return (fptype, sign, value);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpunpack.FPUnpackCV"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpunpack/FPUnpackCV</h3>
      <p class="pseudocode">// FPUnpackCV()
// ============
//
// Used for FP to FP conversion instructions.
// For half-precision data ignores FZ16 and observes AHP.

(FPType, bit, real) <a id="impl-shared.FPUnpackCV.2"/>FPUnpackCV(bits(N) fpval, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr_in)
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.FZ16 = '0';
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    (fp_type, sign, value) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.3" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpackBase</a>(fpval, fpcr, fpexc);
    return (fp_type, sign, value);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpzero.FPZero"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpzero/FPZero</h3>
      <p class="pseudocode">// FPZero()
// ========

bits(N) <a id="impl-shared.FPZero.2"/>FPZero(bit sign, integer N)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(E);
    frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
    result = sign : exp : frac;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.vfpexpandimm.VFPExpandImm"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/vfpexpandimm/VFPExpandImm</h3>
      <p class="pseudocode">// VFPExpandImm()
// ==============

bits(N) <a id="impl-shared.VFPExpandImm.2"/>VFPExpandImm(bits(8) imm8, integer N)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = (N - E) - 1;
    sign = imm8&lt;7&gt;;
    exp  = NOT(imm8&lt;6&gt;):<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;6&gt;,E-3):imm8&lt;5:4&gt;;
    frac = imm8&lt;3:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F-4);
    result = sign : exp : frac;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.integer.AddWithCarry"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/integer/AddWithCarry</h3>
      <p class="pseudocode">// AddWithCarry()
// ==============
// Integer addition with carry input, returning result and NZCV flags

(bits(N), bits(4)) <a id="impl-shared.AddWithCarry.3"/>AddWithCarry(bits(N) x, bits(N) y, bit carry_in)
    integer unsigned_sum = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(x) + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(y) + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(carry_in);
    integer signed_sum = <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(x) + <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(y) + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(carry_in);
    bits(N) result = unsigned_sum&lt;N-1:0&gt;; // same value as signed_sum&lt;N-1:0&gt;
    bit n = result&lt;N-1&gt;;
    bit z = if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(result) then '1' else '0';
    bit c = if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(result) == unsigned_sum then '0' else '1';
    bit v = if <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(result) == signed_sum then '0' else '1';
    return (result, n:z:c:v);</p>
    </div>
    <div class="ps"><a id="shared.functions.interrupts.InterruptID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/interrupts/InterruptID</h3>
      <p class="pseudocode">enumeration <a id="InterruptID"/>InterruptID {
    <a id="InterruptID_PMUIRQ"/>InterruptID_PMUIRQ,
    <a id="InterruptID_COMMIRQ"/>InterruptID_COMMIRQ,
    <a id="InterruptID_CTIIRQ"/>InterruptID_CTIIRQ,
    <a id="InterruptID_COMMRX"/>InterruptID_COMMRX,
    <a id="InterruptID_COMMTX"/>InterruptID_COMMTX,
    <a id="InterruptID_CNTP"/>InterruptID_CNTP,
    <a id="InterruptID_CNTHP"/>InterruptID_CNTHP,
    <a id="InterruptID_CNTHPS"/>InterruptID_CNTHPS,
    <a id="InterruptID_CNTPS"/>InterruptID_CNTPS,
    <a id="InterruptID_CNTV"/>InterruptID_CNTV,
    <a id="InterruptID_CNTHV"/>InterruptID_CNTHV,
    <a id="InterruptID_CNTHVS"/>InterruptID_CNTHVS,
};</p>
    </div>
    <div class="ps"><a id="shared.functions.interrupts.SetInterruptRequestLevel"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/interrupts/SetInterruptRequestLevel</h3>
      <p class="pseudocode">// Set a level-sensitive interrupt to the specified level.
SetInterruptRequestLevel(<a href="shared_pseudocode.html#InterruptID" title="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID</a> id, signal level);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AArch64.BranchAddr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AArch64.BranchAddr</h3>
      <p class="pseudocode">// AArch64.BranchAddr()
// ====================
// Return the virtual address with tag bits removed.
// This is typically used when the address will be stored to the program counter.

bits(64) <a id="AArch64.BranchAddr.2"/>AArch64.BranchAddr(bits(64) vaddress, bits(2) el)
    assert !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    msbit = <a href="shared_pseudocode.html#impl-shared.AddrTop.3" title="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)">AddrTop</a>(vaddress, TRUE, el);
    if msbit == 63 then
        return vaddress;
    elsif (el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} || <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) &amp;&amp; vaddress&lt;msbit&gt; == '1' then
        return <a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(vaddress&lt;msbit:0&gt;, 64);
    else
        return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(vaddress&lt;msbit:0&gt;, 64);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AccessDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AccessDescriptor</h3>
      <p class="pseudocode">type <a id="AccessDescriptor"/>AccessDescriptor is (
    <a href="shared_pseudocode.html#AccessType" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType</a> acctype,
    bits(2) el,             // Acting EL for the access
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,       // Acting Security State for the access
    boolean acqsc,          // Acquire with Sequential Consistency
    boolean acqpc,          // FEAT_LRCPC: Acquire with Processor Consistency
    boolean relsc,          // Release with Sequential Consistency
    boolean limitedordered, // FEAT_LOR: Acquire/Release with limited ordering
    boolean exclusive,      // Access has Exclusive semantics
    boolean atomicop,       // FEAT_LSE: Atomic read-modify-write access
    <a href="shared_pseudocode.html#MemAtomicOp" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp</a> modop,      // FEAT_LSE: The modification operation in the 'atomicop' access
    boolean nontemporal,    // Hints the access is non-temporal
    boolean read,           // Read from memory or only require read permissions
    boolean write,          // Write to memory or only require write permissions
    <a href="shared_pseudocode.html#CacheOp" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp</a> cacheop,        // DC/IC: Cache operation
    <a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoE,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope,   // DC/IC: Scope of cache operation
    <a href="shared_pseudocode.html#CacheType" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype,    // DC/IC: Type of target cache
    boolean pan,            // FEAT_PAN: The access is subject to PSTATE.PAN
    boolean transactional,  // FEAT_TME: Access is part of a transaction
    boolean nonfault,       // SVE: Non-faulting load
    boolean firstfault,     // SVE: First-fault load
    boolean first,          // SVE: First-fault load for the first active element
    boolean contiguous,     // SVE: Contiguous load/store not gather load/scatter store
    boolean streamingsve,   // SME: Access made by PE while in streaming SVE mode
    boolean ls64,           // FEAT_LS64: Accesses by accelerator support loads/stores
    boolean mops,           // FEAT_MOPS: Memory operation (CPY/SET) accesses
    boolean rcw,            // FEAT_THE: Read-Check-Write access
    boolean rcws,           // FEAT_THE: Read-Check-Write Software access
    boolean toplevel,       // FEAT_THE: Translation table walk access for TTB address
    <a href="shared_pseudocode.html#VARange" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> varange,        // FEAT_THE: The corresponding TTBR supplying the TTB
    boolean a32lsmd,        // A32 Load/Store Multiple Data access
    boolean tagchecked,     // FEAT_MTE2: Access is tag checked
    boolean tagaccess,      // FEAT_MTE: Access targets the tag bits
    <a href="shared_pseudocode.html#MPAMinfo" title="type MPAMinfo is ( PARTIDspaceType mpam_sp, PARTIDtype partid, PMGtype pmg )">MPAMinfo</a> mpam           // FEAT_MPAM: MPAM information
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AccessType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AccessType</h3>
      <p class="pseudocode">enumeration <a id="AccessType"/>AccessType {
    <a id="AccessType_IFETCH"/>AccessType_IFETCH,  // Instruction FETCH
    <a id="AccessType_GPR"/>AccessType_GPR,     // Software load/store to a General Purpose Register
    <a id="AccessType_ASIMD"/>AccessType_ASIMD,   // Software ASIMD extension load/store instructions
    <a id="AccessType_SVE"/>AccessType_SVE,     // Software SVE load/store instructions
    <a id="AccessType_SME"/>AccessType_SME,     // Software SME load/store instructions
    <a id="AccessType_IC"/>AccessType_IC,      // Sysop IC
    <a id="AccessType_DC"/>AccessType_DC,      // Sysop DC (not DC {Z,G,GZ}VA)
    <a id="AccessType_DCZero"/>AccessType_DCZero,  // Sysop DC {Z,G,GZ}VA
    <a id="AccessType_AT"/>AccessType_AT,      // Sysop AT
    <a id="AccessType_NV2"/>AccessType_NV2,     // NV2 memory redirected access
    <a id="AccessType_SPE"/>AccessType_SPE,     // Statistical Profiling buffer access
    <a id="AccessType_TRBE"/>AccessType_TRBE,    // Trace Buffer access
    <a id="AccessType_GPTW"/>AccessType_GPTW,    // Granule Protection Table Walk
    <a id="AccessType_TTW"/>AccessType_TTW      // Translation Table Walk
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AddrTop"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AddrTop</h3>
      <p class="pseudocode">// AddrTop()
// =========
// Return the MSB number of a virtual address in the stage 1 translation regime for "el".
// If EL1 is using AArch64 then addresses from EL0 using AArch32 are zero-extended to 64 bits.

integer <a id="impl-shared.AddrTop.3"/>AddrTop(bits(64) address, boolean IsInstr, bits(2) el)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el);
    regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(el);
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(regime) then
        // AArch32 translation regime.
        return 31;
    else
        if <a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(address, IsInstr, el) == '1' then
            return 55;
        else
            return 63;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AlignmentEnforced"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AlignmentEnforced</h3>
      <p class="pseudocode">// AlignmentEnforced()
// ===================
// For the active translation regime, determine if alignment is required by all accesses

boolean <a id="impl-shared.AlignmentEnforced.0"/>AlignmentEnforced()
    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.1" title="function: Regime TranslationRegime(bits(2) el)">TranslationRegime</a>(PSTATE.EL);

    bit A;
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  A = SCTLR_EL3.A;
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> A = SCTLR.A;
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  A = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HSCTLR.A else SCTLR_EL2.A;
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> A = SCTLR_EL2.A;
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> A = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then SCTLR.A  else SCTLR_EL1.A;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    return A == '1';</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Allocation"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Allocation</h3>
      <p class="pseudocode">constant bits(2) <a id="MemHint_No"/>MemHint_No = '00';     // No Read-Allocate, No Write-Allocate
constant bits(2) <a id="MemHint_WA"/>MemHint_WA = '01';     // No Read-Allocate, Write-Allocate
constant bits(2) <a id="MemHint_RA"/>MemHint_RA = '10';     // Read-Allocate, No Write-Allocate
constant bits(2) <a id="MemHint_RWA"/>MemHint_RWA = '11';    // Read-Allocate, Write-Allocate</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.BigEndian"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/BigEndian</h3>
      <p class="pseudocode">// BigEndian()
// ===========

boolean <a id="impl-shared.BigEndian.1"/>BigEndian(<a href="shared_pseudocode.html#AccessType" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType</a> acctype)
    boolean bigend;
    if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; acctype == <a href="shared_pseudocode.html#AccessType_NV2" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_NV2</a> then
        return SCTLR_EL2.EE == '1';

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        bigend = (PSTATE.E != '0');
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        bigend = (<a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].E0E != '0');
    else
        bigend = (<a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].EE != '0');
    return bigend;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.BigEndianReverse"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/BigEndianReverse</h3>
      <p class="pseudocode">// BigEndianReverse()
// ==================

bits(width) <a id="impl-shared.BigEndianReverse.1"/>BigEndianReverse (bits(width) value)
    assert width IN {8, 16, 32, 64, 128};
    integer half = width DIV 2;
    if width == 8 then return value;
    return <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value&lt;half-1:0&gt;) : <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value&lt;width-1:half&gt;);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Cacheability"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Cacheability</h3>
      <p class="pseudocode">constant bits(2) <a id="MemAttr_NC"/>MemAttr_NC = '00';     // Non-cacheable
constant bits(2) <a id="MemAttr_WT"/>MemAttr_WT = '10';     // Write-through
constant bits(2) <a id="MemAttr_WB"/>MemAttr_WB = '11';     // Write-back</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescA32LSMD"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescA32LSMD</h3>
      <p class="pseudocode">// CreateAccDescA32LSMD()
// ======================
// Access descriptor for A32 loads/store multiple general purpose registers

AccessDescriptor <a id="impl-shared.CreateAccDescA32LSMD.1"/>CreateAccDescA32LSMD(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPR" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPR</a>);

    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.pan             = TRUE;
    accdesc.a32lsmd         = TRUE;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescASIMD"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescASIMD</h3>
      <p class="pseudocode">// CreateAccDescASIMD()
// ====================
// Access descriptor for ASIMD&amp;FP loads/stores

AccessDescriptor <a id="impl-shared.CreateAccDescASIMD.3"/>CreateAccDescASIMD(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop, boolean nontemporal, boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_ASIMD" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_ASIMD</a>);

    accdesc.nontemporal     = nontemporal;
    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.pan             = TRUE;
    accdesc.streamingsve    = <a href="shared_pseudocode.html#impl-aarch64.InStreamingMode.0" title="function: boolean InStreamingMode()">InStreamingMode</a>();
    if (accdesc.streamingsve &amp;&amp; boolean IMPLEMENTATION_DEFINED
            "No tag checking of SIMD&amp;FP loads and stores in Streaming SVE mode") then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescASIMDAcqRel"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescASIMDAcqRel</h3>
      <p class="pseudocode">// CreateAccDescASIMDAcqRel()
// ==========================
// Access descriptor for ASIMD&amp;FP loads/stores with ordering semantics

AccessDescriptor <a id="impl-shared.CreateAccDescASIMDAcqRel.2"/>CreateAccDescASIMDAcqRel(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop, boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_ASIMD" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_ASIMD</a>);

    accdesc.acqpc           = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.relsc           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.pan             = TRUE;
    accdesc.streamingsve    = <a href="shared_pseudocode.html#impl-aarch64.InStreamingMode.0" title="function: boolean InStreamingMode()">InStreamingMode</a>();
    if (accdesc.streamingsve &amp;&amp; boolean IMPLEMENTATION_DEFINED
            "No tag checking of SIMD&amp;FP loads and stores in Streaming SVE mode") then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescAT"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescAT</h3>
      <p class="pseudocode">// CreateAccDescAT()
// =================
// Access descriptor for address translation operations

AccessDescriptor <a id="impl-shared.CreateAccDescAT.4"/>CreateAccDescAT(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(2) el, boolean write, boolean pan)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_AT" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_AT</a>);

    accdesc.el              = el;
    accdesc.ss              = ss;
    accdesc.read            = !write;
    accdesc.write           = write;
    accdesc.pan             = pan;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescAcqRel"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescAcqRel</h3>
      <p class="pseudocode">// CreateAccDescAcqRel()
// =====================
// Access descriptor for general purpose register loads/stores with ordering semantics

AccessDescriptor <a id="impl-shared.CreateAccDescAcqRel.2"/>CreateAccDescAcqRel(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop, boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPR" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPR</a>);

    accdesc.acqsc           = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.relsc           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescAtomicOp"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescAtomicOp</h3>
      <p class="pseudocode">// CreateAccDescAtomicOp()
// =======================
// Access descriptor for atomic read-modify-write memory accesses

AccessDescriptor <a id="impl-shared.CreateAccDescAtomicOp.4"/>CreateAccDescAtomicOp(<a href="shared_pseudocode.html#MemAtomicOp" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp</a> modop, boolean acquire, boolean release,
                                       boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPR" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPR</a>);

    accdesc.acqsc           = acquire;
    accdesc.relsc           = release;
    accdesc.atomicop        = TRUE;
    accdesc.modop           = modop;
    accdesc.read            = TRUE;
    accdesc.write           = TRUE;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescDC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescDC</h3>
      <p class="pseudocode">// CreateAccDescDC()
// =================
// Access descriptor for data cache operations

AccessDescriptor <a id="impl-shared.CreateAccDescDC.1"/>CreateAccDescDC(<a href="shared_pseudocode.html#CacheRecord" title="type CacheRecord is ( AccessType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>);

    accdesc.cacheop         = cache.cacheop;
    accdesc.cachetype       = cache.cachetype;
    accdesc.opscope         = cache.opscope;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescDCZero"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescDCZero</h3>
      <p class="pseudocode">// CreateAccDescDCZero()
// =====================
// Access descriptor for data cache zero operations

AccessDescriptor <a id="impl-shared.CreateAccDescDCZero.2"/>CreateAccDescDCZero(boolean tagaccess, boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_DCZero" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DCZero</a>);

    accdesc.write           = TRUE;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.tagaccess       = tagaccess;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescExLDST"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescExLDST</h3>
      <p class="pseudocode">// CreateAccDescExLDST()
// =====================
// Access descriptor for general purpose register loads/stores with exclusive semantics

AccessDescriptor <a id="impl-shared.CreateAccDescExLDST.3"/>CreateAccDescExLDST(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop, boolean acqrel, boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPR" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPR</a>);

    accdesc.acqsc           = acqrel &amp;&amp; memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.relsc           = acqrel &amp;&amp; memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.exclusive       = TRUE;
    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescGPR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescGPR</h3>
      <p class="pseudocode">// CreateAccDescGPR()
// ==================
// Access descriptor for general purpose register loads/stores
// without exclusive or ordering semantics

AccessDescriptor <a id="impl-shared.CreateAccDescGPR.4"/>CreateAccDescGPR(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop, boolean nontemporal, boolean privileged,
                                  boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPR" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPR</a>);

    accdesc.el              = if !privileged then <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> else PSTATE.EL;
    accdesc.nontemporal     = nontemporal;
    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescGPTW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescGPTW</h3>
      <p class="pseudocode">// CreateAccDescGPTW()
// ===================
// Access descriptor for Granule Protection Table walks

AccessDescriptor <a id="impl-shared.CreateAccDescGPTW.1"/>CreateAccDescGPTW(<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPTW</a>);

    accdesc.el              = accdesc_in.el;
    accdesc.ss              = accdesc_in.ss;
    accdesc.read            = TRUE;
    accdesc.mpam            = accdesc_in.mpam;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescIC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescIC</h3>
      <p class="pseudocode">// CreateAccDescIC()
// =================
// Access descriptor for instruction cache operations

AccessDescriptor <a id="impl-shared.CreateAccDescIC.1"/>CreateAccDescIC(<a href="shared_pseudocode.html#CacheRecord" title="type CacheRecord is ( AccessType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>);

    accdesc.cacheop         = cache.cacheop;
    accdesc.cachetype       = cache.cachetype;
    accdesc.opscope         = cache.opscope;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescIFetch"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescIFetch</h3>
      <p class="pseudocode">// CreateAccDescIFetch()
// =====================
// Access descriptor for instruction fetches

AccessDescriptor <a id="impl-shared.CreateAccDescIFetch.0"/>CreateAccDescIFetch()
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a>);

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescLDAcqPC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescLDAcqPC</h3>
      <p class="pseudocode">// CreateAccDescLDAcqPC()
// ======================
// Access descriptor for general purpose register loads with local ordering semantics

AccessDescriptor <a id="impl-shared.CreateAccDescLDAcqPC.1"/>CreateAccDescLDAcqPC(boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPR" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPR</a>);

    accdesc.acqpc           = TRUE;
    accdesc.read            = TRUE;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescLDGSTG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescLDGSTG</h3>
      <p class="pseudocode">// CreateAccDescLDGSTG()
// =====================
// Access descriptor for tag memory loads/stores

AccessDescriptor <a id="impl-shared.CreateAccDescLDGSTG.1"/>CreateAccDescLDGSTG(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPR" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPR</a>);

    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.pan             = TRUE;
    accdesc.tagaccess       = TRUE;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescLOR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescLOR</h3>
      <p class="pseudocode">// CreateAccDescLOR()
// ==================
// Access descriptor for general purpose register loads/stores with limited ordering semantics

AccessDescriptor <a id="impl-shared.CreateAccDescLOR.2"/>CreateAccDescLOR(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop, boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPR" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPR</a>);

    accdesc.acqsc           = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.relsc           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.limitedordered  = TRUE;
    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescLS64"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescLS64</h3>
      <p class="pseudocode">// CreateAccDescLS64()
// ===================
// Access descriptor for accelerator-supporting memory accesses

AccessDescriptor <a id="impl-shared.CreateAccDescLS64.2"/>CreateAccDescLS64(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop, boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPR" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPR</a>);

    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.pan             = TRUE;
    accdesc.ls64            = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescMOPS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescMOPS</h3>
      <p class="pseudocode">// CreateAccDescMOPS()
// ===================
// Access descriptor for data memory copy and set instructions

AccessDescriptor <a id="impl-shared.CreateAccDescMOPS.3"/>CreateAccDescMOPS(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop, boolean privileged, boolean nontemporal)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPR" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPR</a>);

    accdesc.el              = if !privileged then <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> else PSTATE.EL;
    accdesc.nontemporal     = nontemporal;
    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.pan             = TRUE;
    accdesc.mops            = TRUE;
    accdesc.tagchecked      = TRUE;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescNV2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescNV2</h3>
      <p class="pseudocode">// CreateAccDescNV2()
// ==================
// Access descriptor nested virtualization memory indirection loads/stores

AccessDescriptor <a id="impl-shared.CreateAccDescNV2.1"/>CreateAccDescNV2(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_NV2" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_NV2</a>);

    accdesc.el              = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    accdesc.ss              = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescRCW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescRCW</h3>
      <p class="pseudocode">// CreateAccDescRCW()
// ==================
// Access descriptor for atomic read-check-write memory accesses

AccessDescriptor <a id="impl-shared.CreateAccDescRCW.5"/>CreateAccDescRCW(<a href="shared_pseudocode.html#MemAtomicOp" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp</a> modop, boolean soft, boolean acquire,
                                  boolean release, boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPR" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPR</a>);

    accdesc.acqsc           = acquire;
    accdesc.relsc           = release;
    accdesc.rcw             = TRUE;
    accdesc.rcws            = soft;
    accdesc.atomicop        = TRUE;
    accdesc.modop           = modop;
    accdesc.read            = TRUE;
    accdesc.write           = TRUE;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescS1TTW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescS1TTW</h3>
      <p class="pseudocode">// CreateAccDescS1TTW()
// ====================
// Access descriptor for stage 1 translation table walks

AccessDescriptor <a id="impl-shared.CreateAccDescS1TTW.3"/>CreateAccDescS1TTW(boolean toplevel, <a href="shared_pseudocode.html#VARange" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> varange, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a>);

    accdesc.el              = accdesc_in.el;
    accdesc.ss              = accdesc_in.ss;
    accdesc.read            = TRUE;
    accdesc.toplevel        = toplevel;
    accdesc.varange         = varange;
    accdesc.mpam            = accdesc_in.mpam;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescS2TTW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescS2TTW</h3>
      <p class="pseudocode">// CreateAccDescS2TTW()
// ====================
// Access descriptor for stage 2 translation table walks

AccessDescriptor <a id="impl-shared.CreateAccDescS2TTW.1"/>CreateAccDescS2TTW(<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a>);

    accdesc.el              = accdesc_in.el;
    accdesc.ss              = accdesc_in.ss;
    accdesc.read            = TRUE;
    accdesc.mpam            = accdesc_in.mpam;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescSME"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescSME</h3>
      <p class="pseudocode">// CreateAccDescSME()
// ==================
// Access descriptor for SME loads/stores

AccessDescriptor <a id="impl-shared.CreateAccDescSME.4"/>CreateAccDescSME(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop, boolean nontemporal, boolean contiguous,
                                  boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_SME" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_SME</a>);

    accdesc.nontemporal     = nontemporal;
    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.pan             = TRUE;
    accdesc.contiguous      = contiguous;
    accdesc.streamingsve    = TRUE;
    if boolean IMPLEMENTATION_DEFINED "No tag checking of SME LDR &amp; STR instructions" then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescSPE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescSPE</h3>
      <p class="pseudocode">// CreateAccDescSPE()
// ==================
// Access descriptor for memory accesses by Statistical Profiling unit

AccessDescriptor <a id="impl-shared.CreateAccDescSPE.2"/>CreateAccDescSPE(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> owning_ss, bits(2) owning_el)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_SPE" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_SPE</a>);

    accdesc.el              = owning_el;
    accdesc.ss              = owning_ss;
    accdesc.write           = TRUE;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescSTGMOPS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescSTGMOPS</h3>
      <p class="pseudocode">// CreateAccDescSTGMOPS()
// ======================
// Access descriptor for tag memory set instructions

AccessDescriptor <a id="impl-shared.CreateAccDescSTGMOPS.2"/>CreateAccDescSTGMOPS(boolean privileged, boolean nontemporal)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_GPR" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_GPR</a>);

    accdesc.el              = if !privileged then <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> else PSTATE.EL;
    accdesc.nontemporal     = nontemporal;
    accdesc.write           = TRUE;
    accdesc.pan             = TRUE;
    accdesc.mops            = TRUE;
    accdesc.tagaccess       = TRUE;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescSVE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescSVE</h3>
      <p class="pseudocode">// CreateAccDescSVE()
// ==================
// Access descriptor for general SVE loads/stores

AccessDescriptor <a id="impl-shared.CreateAccDescSVE.4"/>CreateAccDescSVE(<a href="shared_pseudocode.html#MemOp" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</a> memop, boolean nontemporal, boolean contiguous,
                                  boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_SVE" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_SVE</a>);

    accdesc.nontemporal     = nontemporal;
    accdesc.read            = memop == <a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>;
    accdesc.write           = memop == <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>;
    accdesc.pan             = TRUE;
    accdesc.contiguous      = contiguous;
    accdesc.streamingsve    = <a href="shared_pseudocode.html#impl-aarch64.InStreamingMode.0" title="function: boolean InStreamingMode()">InStreamingMode</a>();
    if (accdesc.streamingsve &amp;&amp; boolean IMPLEMENTATION_DEFINED
            "No tag checking of SIMD&amp;FP loads and stores in Streaming SVE mode") then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescSVEFF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescSVEFF</h3>
      <p class="pseudocode">// CreateAccDescSVEFF()
// ====================
// Access descriptor for first-fault SVE loads

AccessDescriptor <a id="impl-shared.CreateAccDescSVEFF.2"/>CreateAccDescSVEFF(boolean contiguous, boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_SVE" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_SVE</a>);

    accdesc.read            = TRUE;
    accdesc.pan             = TRUE;
    accdesc.firstfault      = TRUE;
    accdesc.first           = TRUE;
    accdesc.contiguous      = contiguous;
    accdesc.streamingsve    = <a href="shared_pseudocode.html#impl-aarch64.InStreamingMode.0" title="function: boolean InStreamingMode()">InStreamingMode</a>();
    if (accdesc.streamingsve &amp;&amp; boolean IMPLEMENTATION_DEFINED
            "No tag checking of SIMD&amp;FP loads and stores in Streaming SVE mode") then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescSVENF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescSVENF</h3>
      <p class="pseudocode">// CreateAccDescSVENF()
// ====================
// Access descriptor for non-fault SVE loads

AccessDescriptor <a id="impl-shared.CreateAccDescSVENF.2"/>CreateAccDescSVENF(boolean contiguous, boolean tagchecked)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_SVE" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_SVE</a>);

    accdesc.read            = TRUE;
    accdesc.pan             = TRUE;
    accdesc.nonfault        = TRUE;
    accdesc.contiguous      = contiguous;
    accdesc.streamingsve    = <a href="shared_pseudocode.html#impl-aarch64.InStreamingMode.0" title="function: boolean InStreamingMode()">InStreamingMode</a>();
    if (accdesc.streamingsve &amp;&amp; boolean IMPLEMENTATION_DEFINED
            "No tag checking of SIMD&amp;FP loads and stores in Streaming SVE mode") then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    accdesc.transactional   = TSTATE.depth &gt; 0;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescTRBE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescTRBE</h3>
      <p class="pseudocode">// CreateAccDescTRBE()
// ===================
// Access descriptor for memory accesses by Trace Buffer Unit

AccessDescriptor <a id="impl-shared.CreateAccDescTRBE.2"/>CreateAccDescTRBE(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> owning_ss, bits(2) owning_el)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_TRBE" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TRBE</a>);

    accdesc.el              = owning_el;
    accdesc.ss              = owning_ss;
    accdesc.write           = TRUE;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescTTEUpdate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescTTEUpdate</h3>
      <p class="pseudocode">// CreateAccDescTTEUpdate()
// ========================
// Access descriptor for translation table entry HW update

AccessDescriptor <a id="impl-shared.CreateAccDescTTEUpdate.1"/>CreateAccDescTTEUpdate(<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc_in)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.NewAccDesc.1" title="function: AccessDescriptor NewAccDesc(AccessType acctype)">NewAccDesc</a>(<a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a>);

    accdesc.el              = accdesc_in.el;
    accdesc.ss              = accdesc_in.ss;
    accdesc.atomicop        = TRUE;
    accdesc.modop           = <a href="shared_pseudocode.html#MemAtomicOp_CAS" title="enumeration MemAtomicOp {&#13; MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP,&#13; MemAtomicOp_CAS&#13; }">MemAtomicOp_CAS</a>;
    accdesc.read            = TRUE;
    accdesc.write           = TRUE;
    accdesc.mpam            = accdesc_in.mpam;

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.DataMemoryBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/DataMemoryBarrier</h3>
      <p class="pseudocode"><a id="impl-shared.DataMemoryBarrier.2"/>DataMemoryBarrier(<a href="shared_pseudocode.html#MBReqDomain" title="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable,&#13; MBReqDomain_OuterShareable, MBReqDomain_FullSystem}">MBReqDomain</a> domain, <a href="shared_pseudocode.html#MBReqTypes" title="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}">MBReqTypes</a> types);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.DataSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/DataSynchronizationBarrier</h3>
      <p class="pseudocode"><a id="impl-shared.DataSynchronizationBarrier.3"/>DataSynchronizationBarrier(<a href="shared_pseudocode.html#MBReqDomain" title="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable,&#13; MBReqDomain_OuterShareable, MBReqDomain_FullSystem}">MBReqDomain</a> domain, <a href="shared_pseudocode.html#MBReqTypes" title="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}">MBReqTypes</a> types, boolean nXS);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.DeviceType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/DeviceType</h3>
      <p class="pseudocode">enumeration <a id="DeviceType"/>DeviceType {<a id="DeviceType_GRE"/>DeviceType_GRE, <a id="DeviceType_nGRE"/>DeviceType_nGRE, <a id="DeviceType_nGnRE"/>DeviceType_nGnRE, <a id="DeviceType_nGnRnE"/>DeviceType_nGnRnE};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.EffectiveMTX"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/EffectiveMTX</h3>
      <p class="pseudocode">// EffectiveMTX()
// ==============
// Returns the effective MTX in the AArch64 stage 1 translation regime for "el".

bit <a id="impl-shared.EffectiveMTX.3"/>EffectiveMTX(bits(64) address, boolean is_instr, bits(2) el)
    bit mtx;
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el);
    regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(el);
    assert(!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(regime));

    if !<a href="shared_pseudocode.html#impl-shared.HaveMTE4Ext.0" title="function: boolean HaveMTE4Ext()">HaveMTE4Ext</a>() || is_instr then
        mtx = '0';
    else
        case regime of
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
                mtx = if address&lt;55&gt; == '1' then TCR_EL1.MTX1 else TCR_EL1.MTX0;
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
                if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(el) then
                    mtx = if address&lt;55&gt; == '1' then TCR_EL2.MTX1 else TCR_EL2.MTX0;
                else
                    mtx = TCR_EL2.MTX;
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
                mtx = TCR_EL3.MTX;

    return mtx;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.EffectiveTBI"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/EffectiveTBI</h3>
      <p class="pseudocode">// EffectiveTBI()
// ==============
// Returns the effective TBI in the AArch64 stage 1 translation regime for "el".

bit <a id="impl-shared.EffectiveTBI.3"/>EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)
    bit tbi;
    bit tbid;
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el);
    regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(el);
    assert(!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(regime));

    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            tbi = if address&lt;55&gt; == '1' then TCR_EL1.TBI1 else TCR_EL1.TBI0;
            if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() then
                tbid = if address&lt;55&gt; == '1' then TCR_EL1.TBID1 else TCR_EL1.TBID0;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(el) then
                tbi = if address&lt;55&gt; == '1' then TCR_EL2.TBI1 else TCR_EL2.TBI0;
                if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() then
                    tbid = if address&lt;55&gt; == '1' then TCR_EL2.TBID1 else TCR_EL2.TBID0;
            else
                tbi = TCR_EL2.TBI;
                if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() then tbid = TCR_EL2.TBID;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            tbi = TCR_EL3.TBI;
            if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() then tbid = TCR_EL3.TBID;

    return (if tbi == '1' &amp;&amp; (!<a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() || tbid == '0' || !IsInstr) then '1' else '0');</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.EffectiveTCMA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/EffectiveTCMA</h3>
      <p class="pseudocode">// EffectiveTCMA()
// ===============
// Returns the effective TCMA of a virtual address in the stage 1 translation regime for "el".

bit <a id="impl-shared.EffectiveTCMA.2"/>EffectiveTCMA(bits(64) address, bits(2) el)
    bit tcma;
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el);
    regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(el);
    assert(!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(regime));

    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            tcma = if address&lt;55&gt; == '1' then TCR_EL1.TCMA1 else TCR_EL1.TCMA0;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(el) then
                tcma = if address&lt;55&gt; == '1' then TCR_EL2.TCMA1 else TCR_EL2.TCMA0;
            else
                tcma = TCR_EL2.TCMA;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            tcma = TCR_EL3.TCMA;

    return tcma;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.ErrorState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/ErrorState</h3>
      <p class="pseudocode">enumeration <a id="ErrorState"/>ErrorState {<a id="ErrorState_UC"/>ErrorState_UC,            // Uncontainable
                        <a id="ErrorState_UEU"/>ErrorState_UEU,           // Unrecoverable state
                        <a id="ErrorState_UEO"/>ErrorState_UEO,           // Restartable state
                        <a id="ErrorState_UER"/>ErrorState_UER,           // Recoverable state
                        <a id="ErrorState_CE"/>ErrorState_CE,            // Corrected
                        <a id="ErrorState_Uncategorized"/>ErrorState_Uncategorized,
                        <a id="ErrorState_IMPDEF"/>ErrorState_IMPDEF};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Fault"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Fault</h3>
      <p class="pseudocode">enumeration <a id="Fault"/>Fault {<a id="Fault_None"/>Fault_None,
                   <a id="Fault_AccessFlag"/>Fault_AccessFlag,
                   <a id="Fault_Alignment"/>Fault_Alignment,
                   <a id="Fault_Background"/>Fault_Background,
                   <a id="Fault_Domain"/>Fault_Domain,
                   <a id="Fault_Permission"/>Fault_Permission,
                   <a id="Fault_Translation"/>Fault_Translation,
                   <a id="Fault_AddressSize"/>Fault_AddressSize,
                   <a id="Fault_SyncExternal"/>Fault_SyncExternal,
                   <a id="Fault_SyncExternalOnWalk"/>Fault_SyncExternalOnWalk,
                   <a id="Fault_SyncParity"/>Fault_SyncParity,
                   <a id="Fault_SyncParityOnWalk"/>Fault_SyncParityOnWalk,
                   <a id="Fault_GPCFOnWalk"/>Fault_GPCFOnWalk,
                   <a id="Fault_GPCFOnOutput"/>Fault_GPCFOnOutput,
                   <a id="Fault_AsyncParity"/>Fault_AsyncParity,
                   <a id="Fault_AsyncExternal"/>Fault_AsyncExternal,
                   <a id="Fault_TagCheck"/>Fault_TagCheck,
                   <a id="Fault_Debug"/>Fault_Debug,
                   <a id="Fault_TLBConflict"/>Fault_TLBConflict,
                   <a id="Fault_BranchTarget"/>Fault_BranchTarget,
                   <a id="Fault_HWUpdateAccessFlag"/>Fault_HWUpdateAccessFlag,
                   <a id="Fault_Lockdown"/>Fault_Lockdown,
                   <a id="Fault_Exclusive"/>Fault_Exclusive,
                   <a id="Fault_ICacheMaint"/>Fault_ICacheMaint};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.FaultRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/FaultRecord</h3>
      <p class="pseudocode">type <a id="FaultRecord"/>FaultRecord is (
    <a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a>            statuscode,  // Fault Status
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> access,      // Details of the faulting access
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a>      ipaddress,   // Intermediate physical address
    <a href="shared_pseudocode.html#GPCFRecord" title="type GPCFRecord is ( GPCF gpf, integer level )">GPCFRecord</a>       gpcf,        // Granule Protection Check Fault record
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a>      paddress,    // Physical address
    boolean          gpcfs2walk,  // GPC for a stage 2 translation table walk
    boolean          s2fs1walk,   // Is on a Stage 1 translation table walk
    boolean          write,       // TRUE for a write, FALSE for a read
    boolean          tagaccess,   // TRUE for a fault due to NoTagAccess permission.
    integer          level,       // For translation, access flag and Permission faults
    bit              extflag,     // IMPLEMENTATION DEFINED syndrome for External aborts
    boolean          secondstage, // Is a Stage 2 abort
    boolean          assuredonly, // Stage 2 Permission fault due to AssuredOnly attribute
    boolean          toplevel,    // Stage 2 Permission fault due to TopLevel
    boolean          overlay,     // Fault due to overlay permissions
    boolean          dirtybit,    // Fault due to dirty state
    bits(4)          domain,      // Domain number, AArch32 only
    <a href="shared_pseudocode.html#ErrorState" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState</a>       merrorstate, // Incoming error state from memory
    bits(4)          debugmoe     // Debug method of entry, from AArch32 only
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.FullAddress"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/FullAddress</h3>
      <p class="pseudocode">type <a id="FullAddress"/>FullAddress is (
    <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a>  paspace,
    bits(56) address
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.GPCF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/GPCF</h3>
      <p class="pseudocode">enumeration <a id="GPCF"/>GPCF {
    <a id="GPCF_None"/>GPCF_None,        // No fault
    <a id="GPCF_AddressSize"/>GPCF_AddressSize, // GPT address size fault
    <a id="GPCF_Walk"/>GPCF_Walk,        // GPT walk fault
    <a id="GPCF_EABT"/>GPCF_EABT,        // Synchronous External abort on GPT fetch
    <a id="GPCF_Fail"/>GPCF_Fail         // Granule protection fault
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.GPCFRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/GPCFRecord</h3>
      <p class="pseudocode">type <a id="GPCFRecord"/>GPCFRecord is (
    <a href="shared_pseudocode.html#GPCF" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF</a>    gpf,
    integer level
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Hint_Prefetch"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Hint_Prefetch</h3>
      <p class="pseudocode">// Signals the memory system that memory accesses of type HINT to or from the specified address are
// likely in the near future. The memory system may take some action to speed up the memory
// accesses when they do occur, such as pre-loading the specified address into one or more
// caches as indicated by the innermost cache level target (0=L1, 1=L2, etc) and non-temporal hint
// stream. Any or all prefetch hints may be treated as a NOP. A prefetch hint must not cause a
// synchronous abort due to Alignment or Translation faults and the like. Its only effect on
// software-visible state should be on caches and TLBs associated with address, which must be
// accessible by reads, writes or execution, as defined in the translation regime of the current
// Exception level. It is guaranteed not to access Device memory.
// A Prefetch_EXEC hint must not result in an access that could not be performed by a speculative
// instruction fetch, therefore if all associated MMUs are disabled, then it cannot access any
// memory location that cannot be accessed by instruction fetches.
<a id="impl-shared.Hint_Prefetch.4"/>Hint_Prefetch(bits(64) address, <a href="shared_pseudocode.html#PrefetchHint" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">PrefetchHint</a> hint, integer target, boolean stream);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Hint_RangePrefetch"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Hint_RangePrefetch</h3>
      <p class="pseudocode">// Signals the memory system that data memory accesses from a specified range
// of addresses are likely to occur in the near future. The memory system can
// respond by taking actions that are expected to speed up the memory accesses
// when they do occur, such as preloading the locations within the specified
// address ranges into one or more caches.
<a id="impl-shared.Hint_RangePrefetch.6"/>Hint_RangePrefetch(bits(64) address, integer length, integer stride,
                   integer count, integer reuse, bits(6) operation);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.IsDataAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/IsDataAccess</h3>
      <p class="pseudocode">// IsDataAccess()
// ==============
// Return TRUE if access is to data memory.

boolean <a id="impl-shared.IsDataAccess.1"/>IsDataAccess(<a href="shared_pseudocode.html#AccessType" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType</a> acctype)
    return !(acctype IN {<a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a>,
                         <a href="shared_pseudocode.html#AccessType_TTW" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_TTW</a>,
                         <a href="shared_pseudocode.html#AccessType_DC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_DC</a>,
                         <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>,
                         <a href="shared_pseudocode.html#AccessType_AT" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_AT</a>});</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MBReqDomain"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MBReqDomain</h3>
      <p class="pseudocode">enumeration <a id="MBReqDomain"/>MBReqDomain    {<a id="MBReqDomain_Nonshareable"/>MBReqDomain_Nonshareable, <a id="MBReqDomain_InnerShareable"/>MBReqDomain_InnerShareable,
                            <a id="MBReqDomain_OuterShareable"/>MBReqDomain_OuterShareable, <a id="MBReqDomain_FullSystem"/>MBReqDomain_FullSystem};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MBReqTypes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MBReqTypes</h3>
      <p class="pseudocode">enumeration <a id="MBReqTypes"/>MBReqTypes     {<a id="MBReqTypes_Reads"/>MBReqTypes_Reads, <a id="MBReqTypes_Writes"/>MBReqTypes_Writes, <a id="MBReqTypes_All"/>MBReqTypes_All};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MPAM"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MPAM</h3>
      <p class="pseudocode">type <a id="PARTIDtype"/>PARTIDtype = bits(16);
type <a id="PMGtype"/>PMGtype = bits(8);

enumeration <a id="PARTIDspaceType"/>PARTIDspaceType {
    <a id="PIdSpace_Secure"/>PIdSpace_Secure,
    <a id="PIdSpace_Root"/>PIdSpace_Root,
    <a id="PIdSpace_Realm"/>PIdSpace_Realm,
    <a id="PIdSpace_NonSecure"/>PIdSpace_NonSecure
};

type <a id="MPAMinfo"/>MPAMinfo is (
     <a href="shared_pseudocode.html#PARTIDspaceType" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PARTIDspaceType</a> mpam_sp,
     <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> partid,
     <a href="shared_pseudocode.html#PMGtype" title="type PMGtype">PMGtype</a> pmg
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemAtomicOp"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemAtomicOp</h3>
      <p class="pseudocode">enumeration <a id="MemAtomicOp"/>MemAtomicOp {
    <a id="MemAtomicOp_ADD"/>MemAtomicOp_ADD,
    <a id="MemAtomicOp_BIC"/>MemAtomicOp_BIC,
    <a id="MemAtomicOp_EOR"/>MemAtomicOp_EOR,
    <a id="MemAtomicOp_ORR"/>MemAtomicOp_ORR,
    <a id="MemAtomicOp_SMAX"/>MemAtomicOp_SMAX,
    <a id="MemAtomicOp_SMIN"/>MemAtomicOp_SMIN,
    <a id="MemAtomicOp_UMAX"/>MemAtomicOp_UMAX,
    <a id="MemAtomicOp_UMIN"/>MemAtomicOp_UMIN,
    <a id="MemAtomicOp_SWP"/>MemAtomicOp_SWP,
    <a id="MemAtomicOp_CAS"/>MemAtomicOp_CAS
};

enumeration <a id="CacheOp"/>CacheOp {
    <a id="CacheOp_Clean"/>CacheOp_Clean,
    <a id="CacheOp_Invalidate"/>CacheOp_Invalidate,
    <a id="CacheOp_CleanInvalidate"/>CacheOp_CleanInvalidate
};

enumeration <a id="CacheOpScope"/>CacheOpScope {
    <a id="CacheOpScope_SetWay"/>CacheOpScope_SetWay,
    <a id="CacheOpScope_PoU"/>CacheOpScope_PoU,
    <a id="CacheOpScope_PoC"/>CacheOpScope_PoC,
    <a id="CacheOpScope_PoE"/>CacheOpScope_PoE,
    <a id="CacheOpScope_PoP"/>CacheOpScope_PoP,
    <a id="CacheOpScope_PoDP"/>CacheOpScope_PoDP,
    <a id="CacheOpScope_ALLU"/>CacheOpScope_ALLU,
    <a id="CacheOpScope_ALLUIS"/>CacheOpScope_ALLUIS
};

enumeration <a id="CacheType"/>CacheType {
    <a id="CacheType_Data"/>CacheType_Data,
    <a id="CacheType_Tag"/>CacheType_Tag,
    <a id="CacheType_Data_Tag"/>CacheType_Data_Tag,
    <a id="CacheType_Instruction"/>CacheType_Instruction
};

enumeration <a id="CachePASpace"/>CachePASpace {
    <a id="CPAS_NonSecure"/>CPAS_NonSecure,
    <a id="CPAS_Any"/>CPAS_Any,               // Applicable only for DC *SW / IC IALLU* in Root state:
                            // match entries from any PA Space
    <a id="CPAS_RealmNonSecure"/>CPAS_RealmNonSecure,    // Applicable only for DC *SW / IC IALLU* in Realm state:
                            // match entries from Realm or Non-Secure PAS
    <a id="CPAS_Realm"/>CPAS_Realm,
    <a id="CPAS_Root"/>CPAS_Root,
    <a id="CPAS_SecureNonSecure"/>CPAS_SecureNonSecure,   // Applicable only for DC *SW / IC IALLU* in Secure state:
                            // match entries from Secure or Non-Secure PAS
    <a id="CPAS_Secure"/>CPAS_Secure
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemAttrHints"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemAttrHints</h3>
      <p class="pseudocode">type <a id="MemAttrHints"/>MemAttrHints is (
    bits(2) attrs,  // See MemAttr_*, Cacheability attributes
    bits(2) hints,  // See MemHint_*, Allocation hints
    boolean transient
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemOp"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemOp</h3>
      <p class="pseudocode">enumeration <a id="MemOp"/>MemOp {<a id="MemOp_LOAD"/>MemOp_LOAD, <a id="MemOp_STORE"/>MemOp_STORE, <a id="MemOp_PREFETCH"/>MemOp_PREFETCH};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemType</h3>
      <p class="pseudocode">enumeration <a id="MemType"/>MemType {<a id="MemType_Normal"/>MemType_Normal, <a id="MemType_Device"/>MemType_Device};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Memory"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Memory</h3>
      <p class="pseudocode">enumeration <a id="MemTagType"/>MemTagType {
    <a id="MemTag_Untagged"/>MemTag_Untagged,
    <a id="MemTag_AllocationTagged"/>MemTag_AllocationTagged,
    <a id="MemTag_CanonicallyTagged"/>MemTag_CanonicallyTagged
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemoryAttributes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemoryAttributes</h3>
      <p class="pseudocode">type <a id="MemoryAttributes"/>MemoryAttributes is (
    <a href="shared_pseudocode.html#MemType" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a>      memtype,
    <a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType</a>   device,       // For Device memory types
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> inner,        // Inner hints and attributes
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> outer,        // Outer hints and attributes
    <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, // Shareability attribute
    <a href="shared_pseudocode.html#MemTagType" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTagType</a>   tags,         // MTE tag type for this memory.
    boolean      notagaccess,  // Allocation Tag access permission
    bit          xs            // XS attribute
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.NewAccDesc"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/NewAccDesc</h3>
      <p class="pseudocode">// NewAccDesc()
// ============
// Create a new AccessDescriptor with initialised fields

AccessDescriptor <a id="impl-shared.NewAccDesc.1"/>NewAccDesc(<a href="shared_pseudocode.html#AccessType" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType</a> acctype)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc;

    accdesc.acctype         = acctype;
    accdesc.el              = PSTATE.EL;
    accdesc.ss              = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
    accdesc.acqsc           = FALSE;
    accdesc.acqpc           = FALSE;
    accdesc.relsc           = FALSE;
    accdesc.limitedordered  = FALSE;
    accdesc.exclusive       = FALSE;
    accdesc.rcw             = FALSE;
    accdesc.rcws            = FALSE;
    accdesc.atomicop        = FALSE;
    accdesc.nontemporal     = FALSE;
    accdesc.read            = FALSE;
    accdesc.write           = FALSE;
    accdesc.pan             = FALSE;
    accdesc.nonfault        = FALSE;
    accdesc.firstfault      = FALSE;
    accdesc.first           = FALSE;
    accdesc.contiguous      = FALSE;
    accdesc.streamingsve    = FALSE;
    accdesc.ls64            = FALSE;
    accdesc.mops            = FALSE;
    accdesc.a32lsmd         = FALSE;
    accdesc.tagchecked      = FALSE;
    accdesc.tagaccess       = FALSE;
    accdesc.transactional   = FALSE;
    accdesc.mpam            = <a href="shared_pseudocode.html#impl-shared.GenMPAMcurEL.1" title="function: MPAMinfo GenMPAMcurEL(AccessType acctype)">GenMPAMcurEL</a>(acctype);

    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PASpace"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PASpace</h3>
      <p class="pseudocode">enumeration <a id="PASpace"/>PASpace {
    <a id="PAS_NonSecure"/>PAS_NonSecure,
    <a id="PAS_Secure"/>PAS_Secure,
    <a id="PAS_Root"/>PAS_Root,
    <a id="PAS_Realm"/>PAS_Realm
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Permissions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Permissions</h3>
      <p class="pseudocode">type <a id="Permissions"/>Permissions is (
    bits(2) ap_table,   // Stage 1 hierarchical access permissions
    bit     xn_table,   // Stage 1 hierarchical execute-never for single EL regimes
    bit     pxn_table,  // Stage 1 hierarchical privileged execute-never
    bit     uxn_table,  // Stage 1 hierarchical unprivileged execute-never
    bits(3) ap,         // Stage 1 access permissions
    bit     xn,         // Stage 1 execute-never for single EL regimes
    bit     uxn,        // Stage 1 unprivileged execute-never
    bit     pxn,        // Stage 1 privileged execute-never
    bits(4) ppi,        // Stage 1 privileged indirect permissions
    bits(4) upi,        // Stage 1 unprivileged indirect permissions
    bit     ndirty,     // Stage 1 dirty state for indirect permissions scheme
    bits(4) s2pi,       // Stage 2 indirect permissions
    bit     s2dirty,    // Stage 2 dirty state
    bits(4) po_index,   // Stage 1 overlay permissions index
    bits(4) s2po_index, // Stage 2 overlay permissions index
    bits(2) s2ap,       // Stage 2 access permissions
    bit     s2tag_na,   // Stage 2 tag access
    bit     s2xnx,      // Stage 2 extended execute-never
    bit     s2xn        // Stage 2 execute-never
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PhysMemRead"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PhysMemRead</h3>
      <p class="pseudocode">// Returns the value read from memory, and a status.
// Returned value is UNKNOWN if an External abort occurred while reading the
// memory.
// Otherwise the PhysMemRetStatus statuscode is Fault_None.
(PhysMemRetStatus, bits(8*size)) <a id="impl-shared.PhysMemRead.3"/>PhysMemRead(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> desc, integer size,
                                             <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PhysMemRetStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PhysMemRetStatus</h3>
      <p class="pseudocode">type <a id="PhysMemRetStatus"/>PhysMemRetStatus is (
    <a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a>       statuscode,     // Fault Status
    bit         extflag,        // IMPLEMENTATION DEFINED syndrome for External aborts
    <a href="shared_pseudocode.html#ErrorState" title="enumeration ErrorState {ErrorState_UC, ErrorState_UEU, ErrorState_UEO, ErrorState_UER, ErrorState_CE, ErrorState_Uncategorized,&#13; ErrorState_IMPDEF}">ErrorState</a>  merrorstate,    // Optional error state returned on a physical memory access
    bits(64)    store64bstatus  // Status of 64B store
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PhysMemWrite"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PhysMemWrite</h3>
      <p class="pseudocode">// Writes the value to memory, and returns the status of the write.
// If there is an External abort on the write, the PhysMemRetStatus indicates this.
// Otherwise the statuscode of PhysMemRetStatus is Fault_None.
PhysMemRetStatus <a id="impl-shared.PhysMemWrite.4"/>PhysMemWrite(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> desc, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc,
                              bits(8*size) value);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PrefetchHint"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PrefetchHint</h3>
      <p class="pseudocode">enumeration <a id="PrefetchHint"/>PrefetchHint {<a id="Prefetch_READ"/>Prefetch_READ, <a id="Prefetch_WRITE"/>Prefetch_WRITE, <a id="Prefetch_EXEC"/>Prefetch_EXEC};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.S1AccessControls"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/S1AccessControls</h3>
      <p class="pseudocode">type <a id="S1AccessControls"/>S1AccessControls is (
    bit r,                 // Stage 1 base read permission
    bit w,                 // Stage 1 base write permission
    bit x,                 // Stage 1 base execute permission
    bit gcs,               // Stage 1 GCS permission
    boolean overlay,       // Stage 1 overlay feature enabled
    bit or,                // Stage 1 overlay read permission
    bit ow,                // Stage 1 overlay write permission
    bit ox,                // Stage 1 overlay execute permission
    bit wxn                // Stage 1 write permission implies execute-never
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.S2AccessControls"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/S2AccessControls</h3>
      <p class="pseudocode">type <a id="S2AccessControls"/>S2AccessControls is (
    bit r,                 // Stage 2 read permission.
    bit w,                 // Stage 2 write permission.
    bit x,                 // Stage 2 execute permission.
    bit r_rcw,             // Stage 2 Read perms for RCW instruction.
    bit w_rcw,             // Stage 2 Write perms for RCW instruction.
    bit r_mmu,             // Stage 2 Read perms for TTW data.
    bit w_mmu,             // Stage 2 Write perms for TTW data.
    bit toplevel0,         // IPA as top level table for TTBR0_EL1.
    bit toplevel1,         // IPA as top level table for TTBR1_EL1.
    boolean overlay,       // Overlay enable
    bit or,                // Stage 2 overlay read permission.
    bit ow,                // Stage 2 overlay write permission.
    bit ox,                // Stage 2 overlay execute permission.
    bit or_rcw,            // Stage 2 overlay Read perms for RCW instruction.
    bit ow_rcw,            // Stage 2 overlay Write perms for RCW instruction.
    bit or_mmu,            // Stage 2 overlay Read perms for TTW data.
    bit ow_mmu,            // Stage 2 overlay Write perms for TTW data.
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Shareability"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Shareability</h3>
      <p class="pseudocode">enumeration <a id="Shareability"/>Shareability {
    <a id="Shareability_NSH"/>Shareability_NSH,
    <a id="Shareability_ISH"/>Shareability_ISH,
    <a id="Shareability_OSH"/>Shareability_OSH
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.SpeculativeStoreBypassBarrierToPA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/SpeculativeStoreBypassBarrierToPA</h3>
      <p class="pseudocode"><a id="impl-shared.SpeculativeStoreBypassBarrierToPA.0"/>SpeculativeStoreBypassBarrierToPA();</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.SpeculativeStoreBypassBarrierToVA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/SpeculativeStoreBypassBarrierToVA</h3>
      <p class="pseudocode"><a id="impl-shared.SpeculativeStoreBypassBarrierToVA.0"/>SpeculativeStoreBypassBarrierToVA();</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Tag"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Tag</h3>
      <p class="pseudocode">constant integer <a id="LOG2_TAG_GRANULE"/>LOG2_TAG_GRANULE = 4;

constant integer <a id="TAG_GRANULE"/>TAG_GRANULE = 1 &lt;&lt; <a href="shared_pseudocode.html#LOG2_TAG_GRANULE" title="constant integer LOG2_TAG_GRANULE = 4">LOG2_TAG_GRANULE</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.VARange"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/VARange</h3>
      <p class="pseudocode">enumeration <a id="VARange"/>VARange {
    <a id="VARange_LOWER"/>VARange_LOWER,
    <a id="VARange_UPPER"/>VARange_UPPER
};</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.AltPARTIDspace"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/AltPARTIDspace</h3>
      <p class="pseudocode">// AltPARTIDspace()
// ================
// From the Security state, EL and ALTSP configuration, determine
// whether to primary space or the alt space is selected and which
// PARTID space is the alternative space. Return that alternative
// PARTID space if selected or the primary space if not.

PARTIDspaceType <a id="impl-shared.AltPARTIDspace.3"/>AltPARTIDspace(bits(2) el, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security,
                                <a href="shared_pseudocode.html#PARTIDspaceType" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PARTIDspaceType</a> primaryPIdSpace)
    case security of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            assert el != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
            return primaryPIdSpace; // there is no ALTSP for Non_secure
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
            assert el != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
            if primaryPIdSpace == <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a> then
                return primaryPIdSpace;
            return <a href="shared_pseudocode.html#impl-shared.AltPIdSecure.2" title="function: PARTIDspaceType AltPIdSecure(bits(2) el, PARTIDspaceType primaryPIdSpace)">AltPIdSecure</a>(el, primaryPIdSpace);
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>
            assert el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
            if MPAM3_EL3.ALTSP_EL3 == '1' then
                if MPAM3_EL3.RT_ALTSP_NS == '1' then
                    return <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
                else
                    return <a href="shared_pseudocode.html#PIdSpace_Secure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_Secure</a>;
            else
                return primaryPIdSpace;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
            assert el != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
            return <a href="shared_pseudocode.html#impl-shared.AltPIdRealm.2" title="function: PARTIDspaceType AltPIdRealm(bits(2) el, PARTIDspaceType primaryPIdSpace)">AltPIdRealm</a>(el, primaryPIdSpace);
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.AltPIdRealm"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/AltPIdRealm</h3>
      <p class="pseudocode">// AltPIdRealm()
// =============
// Compute PARTID space as either the primary PARTID space or
// alternative PARTID space in the Realm Security state.
// Helper for AltPARTIDspace.

PARTIDspaceType <a id="impl-shared.AltPIdRealm.2"/>AltPIdRealm(bits(2) el, <a href="shared_pseudocode.html#PARTIDspaceType" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PARTIDspaceType</a> primaryPIdSpace)
    <a href="shared_pseudocode.html#PARTIDspaceType" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PARTIDspaceType</a> PIdSpace = primaryPIdSpace;
    case el of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            if <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>) then
                if !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL2.0" title="function: boolean UsePrimarySpaceEL2()">UsePrimarySpaceEL2</a>() then
                    PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
            elsif !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL10.0" title="function: boolean UsePrimarySpaceEL10()">UsePrimarySpaceEL10</a>() then
                PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            if !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL10.0" title="function: boolean UsePrimarySpaceEL10()">UsePrimarySpaceEL10</a>() then
                PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL2.0" title="function: boolean UsePrimarySpaceEL2()">UsePrimarySpaceEL2</a>() then
                PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return PIdSpace;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.AltPIdSecure"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/AltPIdSecure</h3>
      <p class="pseudocode">// AltPIdSecure()
// ==============
// Compute PARTID space as either the primary PARTID space or
// alternative PARTID space in the Secure Security state.
// Helper for AltPARTIDspace.

PARTIDspaceType <a id="impl-shared.AltPIdSecure.2"/>AltPIdSecure(bits(2) el, <a href="shared_pseudocode.html#PARTIDspaceType" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PARTIDspaceType</a> primaryPIdSpace)
    <a href="shared_pseudocode.html#PARTIDspaceType" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PARTIDspaceType</a> PIdSpace = primaryPIdSpace;
    boolean el2en = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    case el of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            if el2en then
                if <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>) then
                    if !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL2.0" title="function: boolean UsePrimarySpaceEL2()">UsePrimarySpaceEL2</a>() then
                        PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
                elsif !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL10.0" title="function: boolean UsePrimarySpaceEL10()">UsePrimarySpaceEL10</a>() then
                    PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
            elsif MPAM3_EL3.ALTSP_HEN == '0' &amp;&amp; MPAM3_EL3.ALTSP_HFC == '1' then
                PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            if el2en then
                if !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL10.0" title="function: boolean UsePrimarySpaceEL10()">UsePrimarySpaceEL10</a>() then
                    PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
            elsif MPAM3_EL3.ALTSP_HEN == '0' &amp;&amp; MPAM3_EL3.ALTSP_HFC == '1' then
                PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL2.0" title="function: boolean UsePrimarySpaceEL2()">UsePrimarySpaceEL2</a>() then
                PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return PIdSpace;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.DefaultMPAMinfo"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/DefaultMPAMinfo</h3>
      <p class="pseudocode">// DefaultMPAMinfo()
// =================
// Returns default MPAM info.  The partidspace argument sets
// the PARTID space of the default MPAM information returned.

MPAMinfo <a id="impl-shared.DefaultMPAMinfo.1"/>DefaultMPAMinfo(<a href="shared_pseudocode.html#PARTIDspaceType" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PARTIDspaceType</a> partidspace)
    <a href="shared_pseudocode.html#MPAMinfo" title="type MPAMinfo is ( PARTIDspaceType mpam_sp, PARTIDtype partid, PMGtype pmg )">MPAMinfo</a> DefaultInfo;
    DefaultInfo.mpam_sp = partidspace;
    DefaultInfo.partid  = <a href="shared_pseudocode.html#DefaultPARTID" title="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</a>;
    DefaultInfo.pmg     = <a href="shared_pseudocode.html#DefaultPMG" title="constant PMGtype DefaultPMG = 0&lt;7:0&gt;">DefaultPMG</a>;
    return DefaultInfo;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.DefaultPARTID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/DefaultPARTID</h3>
      <p class="pseudocode">constant PARTIDtype <a id="DefaultPARTID"/>DefaultPARTID = 0&lt;15:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.DefaultPMG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/DefaultPMG</h3>
      <p class="pseudocode">constant PMGtype    <a id="DefaultPMG"/>DefaultPMG = 0&lt;7:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.GenMPAMcurEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/GenMPAMcurEL</h3>
      <p class="pseudocode">// GenMPAMcurEL()
// ==============
// Returns MPAMinfo for the current EL and security state.
// May be called if MPAM is not implemented (but in an version that supports
// MPAM), MPAM is disabled, or in AArch32.  In AArch32, convert the mode to
// EL if can and use that to drive MPAM information generation.  If mode
// cannot be converted, MPAM is not implemented, or MPAM is disabled return
// default MPAM information for the current security state.

MPAMinfo <a id="impl-shared.GenMPAMcurEL.1"/>GenMPAMcurEL(<a href="shared_pseudocode.html#AccessType" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType</a> acctype)
    bits(2) mpamEL;
    boolean validEL = FALSE;
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security = <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    boolean InD = FALSE;
    boolean InSM = FALSE;
    <a href="shared_pseudocode.html#PARTIDspaceType" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PARTIDspaceType</a> pspace = <a href="shared_pseudocode.html#impl-shared.PARTIDspaceFromSS.1" title="function: PARTIDspaceType PARTIDspaceFromSS(SecurityState security)">PARTIDspaceFromSS</a>(security);
    if pspace == <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.MPAMisEnabled.0" title="function: boolean MPAMisEnabled()">MPAMisEnabled</a>() then
        return <a href="shared_pseudocode.html#impl-shared.DefaultMPAMinfo.1" title="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(pspace);
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        (validEL, mpamEL) = <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(PSTATE.M);
    else
        mpamEL = if acctype == <a href="shared_pseudocode.html#AccessType_NV2" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_NV2</a> then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else PSTATE.EL;
        validEL = TRUE;
    case acctype of
        when <a href="shared_pseudocode.html#AccessType_IFETCH" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IFETCH</a>, <a href="shared_pseudocode.html#AccessType_IC" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_IC</a>
            InD = TRUE;
        when <a href="shared_pseudocode.html#AccessType_SME" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_SME</a>
            InSM = (boolean IMPLEMENTATION_DEFINED "Shared SMCU" ||
                    boolean IMPLEMENTATION_DEFINED "MPAMSM_EL1 label precedence");
        when <a href="shared_pseudocode.html#AccessType_ASIMD" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_ASIMD</a>
            InSM = (<a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' &amp;&amp;
                    (boolean IMPLEMENTATION_DEFINED "Shared SMCU" ||
                    boolean IMPLEMENTATION_DEFINED "MPAMSM_EL1 label precedence"));
        when <a href="shared_pseudocode.html#AccessType_SVE" title="enumeration AccessType {&#13; AccessType_IFETCH, AccessType_GPR, AccessType_ASIMD, AccessType_SVE, AccessType_SME, AccessType_IC, AccessType_DC, AccessType_DCZero, AccessType_AT, AccessType_NV2, AccessType_SPE, AccessType_TRBE, AccessType_GPTW, AccessType_TTW }">AccessType_SVE</a>
            InSM = (<a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' &amp;&amp;
                    (boolean IMPLEMENTATION_DEFINED "Shared SMCU" ||
                    boolean IMPLEMENTATION_DEFINED "MPAMSM_EL1 label precedence"));
        otherwise
            // Other access types are DATA accesses
            InD = FALSE;
    if !validEL then
        return <a href="shared_pseudocode.html#impl-shared.DefaultMPAMinfo.1" title="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(pspace);
    elsif <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; MPAMIDR_EL1.HAS_ALTSP == '1' then
        // Substitute alternative PARTID space if selected
        pspace = <a href="shared_pseudocode.html#impl-shared.AltPARTIDspace.3" title="function: PARTIDspaceType AltPARTIDspace(bits(2) el, SecurityState security,&#13; PARTIDspaceType primaryPIdSpace)">AltPARTIDspace</a>(mpamEL, security, pspace);
    if <a href="shared_pseudocode.html#impl-shared.HaveMPAMv0p1Ext.0" title="function: boolean HaveMPAMv0p1Ext()">HaveMPAMv0p1Ext</a>() &amp;&amp; MPAMIDR_EL1.HAS_FORCE_NS == '1' then
        if MPAM3_EL3.FORCE_NS == '1' &amp;&amp; security == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
            pspace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
    if (<a href="shared_pseudocode.html#impl-shared.HaveMPAMv0p1Ext.0" title="function: boolean HaveMPAMv0p1Ext()">HaveMPAMv0p1Ext</a>() || <a href="shared_pseudocode.html#impl-shared.HaveMPAMv1p1Ext.0" title="function: boolean HaveMPAMv1p1Ext()">HaveMPAMv1p1Ext</a>()) &amp;&amp; MPAMIDR_EL1.HAS_SDEFLT == '1' then
        if MPAM3_EL3.SDEFLT == '1' &amp;&amp; security == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
            return <a href="shared_pseudocode.html#impl-shared.DefaultMPAMinfo.1" title="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(pspace);
    if !<a href="shared_pseudocode.html#impl-shared.MPAMisEnabled.0" title="function: boolean MPAMisEnabled()">MPAMisEnabled</a>() then
        return <a href="shared_pseudocode.html#impl-shared.DefaultMPAMinfo.1" title="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(pspace);
    else
        return <a href="shared_pseudocode.html#impl-shared.genMPAM.4" title="function: MPAMinfo genMPAM(bits(2) el, boolean InD, boolean InSM, PARTIDspaceType pspace)">genMPAM</a>(mpamEL, InD, InSM, pspace);</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.MAP_vPARTID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/MAP_vPARTID</h3>
      <p class="pseudocode">// MAP_vPARTID()
// =============
// Performs conversion of virtual PARTID into physical PARTID
// Contains all of the error checking and implementation
// choices for the conversion.

(PARTIDtype, boolean) <a id="impl-shared.MAP_vPARTID.1"/>MAP_vPARTID(<a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> vpartid)
    // should not ever be called if EL2 is not implemented
    // or is implemented but not enabled in the current
    // security state.
    <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> ret;
    boolean err;
    integer virt    = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vpartid);
    integer vpmrmax = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MPAMIDR_EL1.VPMR_MAX);

    // vpartid_max is largest vpartid supported
    integer vpartid_max = (vpmrmax &lt;&lt; 2) + 3;

    // One of many ways to reduce vpartid to value less than vpartid_max.
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vpartid) &gt; vpartid_max then
        virt = virt MOD (vpartid_max+1);

    // Check for valid mapping entry.
    if MPAMVPMV_EL2&lt;virt&gt; == '1' then
        // vpartid has a valid mapping so access the map.
        ret = <a href="shared_pseudocode.html#impl-shared.mapvpmw.1" title="function: PARTIDtype mapvpmw(integer vpartid)">mapvpmw</a>(virt);
        err = FALSE;

    // Is the default virtual PARTID valid?
    elsif MPAMVPMV_EL2&lt;0&gt; == '1' then
        // Yes, so use default mapping for vpartid == 0.
        ret = MPAMVPM0_EL2&lt;0 +: 16&gt;;
        err = FALSE;

    // Neither is valid so use default physical PARTID.
    else
        ret = <a href="shared_pseudocode.html#DefaultPARTID" title="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</a>;
        err = TRUE;

    // Check that the physical PARTID is in-range.
    // This physical PARTID came from a virtual mapping entry.
    integer partid_max = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MPAMIDR_EL1.PARTID_MAX);
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ret) &gt; partid_max then
        // Out of range, so return default physical PARTID
        ret = <a href="shared_pseudocode.html#DefaultPARTID" title="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</a>;
        err = TRUE;
    return (ret, err);</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.MPAMisEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/MPAMisEnabled</h3>
      <p class="pseudocode">// MPAMisEnabled()
// ===============
// Returns TRUE if MPAMisEnabled.

boolean <a id="impl-shared.MPAMisEnabled.0"/>MPAMisEnabled()
    el = <a href="shared_pseudocode.html#impl-shared.HighestEL.0" title="function: bits(2) HighestEL()">HighestEL</a>();
    case el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> return MPAM3_EL3.MPAMEN == '1';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> return MPAM2_EL2.MPAMEN == '1';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> return MPAM1_EL1.MPAMEN == '1';</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.MPAMisVirtual"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/MPAMisVirtual</h3>
      <p class="pseudocode">// MPAMisVirtual()
// ===============
// Returns TRUE if MPAM is configured to be virtual at EL.

boolean <a id="impl-shared.MPAMisVirtual.1"/>MPAMisVirtual(bits(2) el)
    return (MPAMIDR_EL1.HAS_HCR == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
            ((el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; MPAMHCR_EL2.EL0_VPMEN == '1' &amp;&amp;
               (HCR_EL2.E2H == '0' || HCR_EL2.TGE == '0')) ||
             (el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; MPAMHCR_EL2.EL1_VPMEN == '1')));</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.PARTIDspaceFromSS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/PARTIDspaceFromSS</h3>
      <p class="pseudocode">// PARTIDspaceFromSS()
// ===================
// Returns the primary PARTID space from the Security State.

PARTIDspaceType <a id="impl-shared.PARTIDspaceFromSS.1"/>PARTIDspaceFromSS(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security)
    case security of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            return <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>
            return <a href="shared_pseudocode.html#PIdSpace_Root" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_Root</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
            return <a href="shared_pseudocode.html#PIdSpace_Realm" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_Realm</a>;
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
            return <a href="shared_pseudocode.html#PIdSpace_Secure" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PIdSpace_Secure</a>;
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.UsePrimarySpaceEL10"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/UsePrimarySpaceEL10</h3>
      <p class="pseudocode">// UsePrimarySpaceEL10()
// =====================
// Checks whether Primary space is configured in the
// MPAM3_EL3 and MPAM2_EL2 ALTSP control bits that affect
// MPAM ALTSP use at EL1 and EL0.

boolean <a id="impl-shared.UsePrimarySpaceEL10.0"/>UsePrimarySpaceEL10()
    if MPAM3_EL3.ALTSP_HEN == '0' then
        return MPAM3_EL3.ALTSP_HFC == '0';
    return !<a href="shared_pseudocode.html#impl-shared.MPAMisEnabled.0" title="function: boolean MPAMisEnabled()">MPAMisEnabled</a>() || !<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() || MPAM2_EL2.ALTSP_HFC == '0';</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.UsePrimarySpaceEL2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/UsePrimarySpaceEL2</h3>
      <p class="pseudocode">// UsePrimarySpaceEL2()
// ====================
// Checks whether Primary space is configured in the
// MPAM3_EL3 and MPAM2_EL2 ALTSP control bits that affect
// MPAM ALTSP use at EL2.

boolean <a id="impl-shared.UsePrimarySpaceEL2.0"/>UsePrimarySpaceEL2()
    if MPAM3_EL3.ALTSP_HEN == '0' then
        return MPAM3_EL3.ALTSP_HFC == '0';
    return !<a href="shared_pseudocode.html#impl-shared.MPAMisEnabled.0" title="function: boolean MPAMisEnabled()">MPAMisEnabled</a>() || MPAM2_EL2.ALTSP_EL2 == '0';</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.genMPAM"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/genMPAM</h3>
      <p class="pseudocode">// genMPAM()
// =========
// Returns MPAMinfo for exception level el.
// If InD is TRUE returns MPAM information using PARTID_I and PMG_I fields
// of MPAMel_ELx register and otherwise using PARTID_D and PMG_D fields.
// If InSM is TRUE returns MPAM information using PARTID_D and PMG_D fields
// of MPAMSM_EL1 register.
// Produces a PARTID in PARTID space pspace.

MPAMinfo <a id="impl-shared.genMPAM.4"/>genMPAM(bits(2) el, boolean InD, boolean InSM, <a href="shared_pseudocode.html#PARTIDspaceType" title="enumeration PARTIDspaceType {&#13; PIdSpace_Secure,&#13; PIdSpace_Root,&#13; PIdSpace_Realm,&#13; PIdSpace_NonSecure&#13; }">PARTIDspaceType</a> pspace)
    <a href="shared_pseudocode.html#MPAMinfo" title="type MPAMinfo is ( PARTIDspaceType mpam_sp, PARTIDtype partid, PMGtype pmg )">MPAMinfo</a> returninfo;
    <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> partidel;
    boolean perr;
    // gstplk is guest OS application locked by the EL2 hypervisor to
    // only use EL1 the virtual machine's PARTIDs.
    boolean gstplk = (el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                      MPAMHCR_EL2.GSTAPP_PLK == '1' &amp;&amp;
                      HCR_EL2.TGE == '0');
    bits(2) eff_el = if gstplk then <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> else el;
    (partidel, perr) = <a href="shared_pseudocode.html#impl-shared.genPARTID.3" title="function: (PARTIDtype, boolean) genPARTID(bits(2) el, boolean InD, boolean InSM)">genPARTID</a>(eff_el, InD, InSM);
    <a href="shared_pseudocode.html#PMGtype" title="type PMGtype">PMGtype</a> groupel  = <a href="shared_pseudocode.html#impl-shared.genPMG.4" title="function: PMGtype genPMG(bits(2) el, boolean InD, boolean InSM, boolean partid_err)">genPMG</a>(eff_el, InD, InSM, perr);
    returninfo.mpam_sp = pspace;
    returninfo.partid  = partidel;
    returninfo.pmg     = groupel;
    return returninfo;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.genPARTID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/genPARTID</h3>
      <p class="pseudocode">// genPARTID()
// ===========
// Returns physical PARTID and error boolean for exception level el.
// If InD is TRUE then PARTID is from MPAMel_ELx.PARTID_I and
// otherwise from MPAMel_ELx.PARTID_D.
// If InSM is TRUE then PARTID is from MPAMSM_EL1.PARTID_D.

(PARTIDtype, boolean) <a id="impl-shared.genPARTID.3"/>genPARTID(bits(2) el, boolean InD, boolean InSM)
    <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> partidel = <a href="shared_pseudocode.html#impl-shared.getMPAM_PARTID.3" title="function: PARTIDtype getMPAM_PARTID(bits(2) MPAMn, boolean InD, boolean InSM)">getMPAM_PARTID</a>(el, InD, InSM);
    <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> partid_max = MPAMIDR_EL1.PARTID_MAX;
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(partidel) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(partid_max) then
        return (<a href="shared_pseudocode.html#DefaultPARTID" title="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</a>, TRUE);
    if <a href="shared_pseudocode.html#impl-shared.MPAMisVirtual.1" title="function: boolean MPAMisVirtual(bits(2) el)">MPAMisVirtual</a>(el) then
        return <a href="shared_pseudocode.html#impl-shared.MAP_vPARTID.1" title="function: (PARTIDtype, boolean) MAP_vPARTID(PARTIDtype vpartid)">MAP_vPARTID</a>(partidel);
    else
        return (partidel, FALSE);</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.genPMG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/genPMG</h3>
      <p class="pseudocode">// genPMG()
// ========
// Returns PMG for exception level el and I- or D-side (InD).
// If PARTID generation (genPARTID) encountered an error, genPMG() should be
// called with partid_err as TRUE.

PMGtype <a id="impl-shared.genPMG.4"/>genPMG(bits(2) el, boolean InD, boolean InSM, boolean partid_err)
    integer pmg_max = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MPAMIDR_EL1.PMG_MAX);
    // It is CONSTRAINED UNPREDICTABLE whether partid_err forces PMG to
    // use the default or if it uses the PMG from getMPAM_PMG.
    if partid_err then
        return <a href="shared_pseudocode.html#DefaultPMG" title="constant PMGtype DefaultPMG = 0&lt;7:0&gt;">DefaultPMG</a>;
    <a href="shared_pseudocode.html#PMGtype" title="type PMGtype">PMGtype</a> groupel = <a href="shared_pseudocode.html#impl-shared.getMPAM_PMG.3" title="function: PMGtype getMPAM_PMG(bits(2) MPAMn, boolean InD, boolean InSM)">getMPAM_PMG</a>(el, InD, InSM);
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(groupel) &lt;= pmg_max then
        return groupel;
    return <a href="shared_pseudocode.html#DefaultPMG" title="constant PMGtype DefaultPMG = 0&lt;7:0&gt;">DefaultPMG</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.getMPAM_PARTID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/getMPAM_PARTID</h3>
      <p class="pseudocode">// getMPAM_PARTID()
// ================
// Returns a PARTID from one of the MPAMn_ELx or MPAMSM_EL1 registers.
// If InSM is TRUE, the MPAMSM_EL1 register is used. Otherwise,
// MPAMn selects the MPAMn_ELx register used.
// If InD is TRUE, selects the PARTID_I field of that
// register.  Otherwise, selects the PARTID_D field.

PARTIDtype <a id="impl-shared.getMPAM_PARTID.3"/>getMPAM_PARTID(bits(2) MPAMn, boolean InD, boolean InSM)
    <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> partid;
    boolean el2avail = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    if InSM then
        partid = MPAMSM_EL1.PARTID_D;
        return partid;

    if InD then
        case MPAMn of
            when '11' partid = MPAM3_EL3.PARTID_I;
            when '10' partid = if el2avail then MPAM2_EL2.PARTID_I else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
            when '01' partid = MPAM1_EL1.PARTID_I;
            when '00' partid = MPAM0_EL1.PARTID_I;
            otherwise partid = <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> UNKNOWN;
    else
        case MPAMn of
            when '11' partid = MPAM3_EL3.PARTID_D;
            when '10' partid = if el2avail then MPAM2_EL2.PARTID_D else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
            when '01' partid = MPAM1_EL1.PARTID_D;
            when '00' partid = MPAM0_EL1.PARTID_D;
            otherwise partid = <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> UNKNOWN;
    return partid;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.getMPAM_PMG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/getMPAM_PMG</h3>
      <p class="pseudocode">// getMPAM_PMG()
// =============
// Returns a PMG from one of the MPAMn_ELx or MPAMSM_EL1 registers.
// If InSM is TRUE, the MPAMSM_EL1 register is used. Otherwise,
// MPAMn selects the MPAMn_ELx register used.
// If InD is TRUE, selects the PMG_I field of that
// register.  Otherwise, selects the PMG_D field.

PMGtype <a id="impl-shared.getMPAM_PMG.3"/>getMPAM_PMG(bits(2) MPAMn, boolean InD, boolean InSM)
    <a href="shared_pseudocode.html#PMGtype" title="type PMGtype">PMGtype</a> pmg;
    boolean el2avail = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    if InSM then
        pmg = MPAMSM_EL1.PMG_D;
        return pmg;

    if InD then
        case MPAMn of
            when '11' pmg = MPAM3_EL3.PMG_I;
            when '10' pmg = if el2avail then MPAM2_EL2.PMG_I else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8);
            when '01' pmg = MPAM1_EL1.PMG_I;
            when '00' pmg = MPAM0_EL1.PMG_I;
            otherwise pmg = <a href="shared_pseudocode.html#PMGtype" title="type PMGtype">PMGtype</a> UNKNOWN;
    else
        case MPAMn of
            when '11' pmg = MPAM3_EL3.PMG_D;
            when '10' pmg = if el2avail then MPAM2_EL2.PMG_D else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8);
            when '01' pmg = MPAM1_EL1.PMG_D;
            when '00' pmg = MPAM0_EL1.PMG_D;
            otherwise pmg = <a href="shared_pseudocode.html#PMGtype" title="type PMGtype">PMGtype</a> UNKNOWN;
    return pmg;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.mapvpmw"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/mapvpmw</h3>
      <p class="pseudocode">// mapvpmw()
// =========
// Map a virtual PARTID into a physical PARTID using
// the MPAMVPMn_EL2 registers.
// vpartid is now assumed in-range and valid (checked by caller)
// returns physical PARTID from mapping entry.

PARTIDtype <a id="impl-shared.mapvpmw.1"/>mapvpmw(integer vpartid)
    bits(64) vpmw;
    integer  wd = vpartid DIV 4;
    case wd of
        when 0 vpmw = MPAMVPM0_EL2;
        when 1 vpmw = MPAMVPM1_EL2;
        when 2 vpmw = MPAMVPM2_EL2;
        when 3 vpmw = MPAMVPM3_EL2;
        when 4 vpmw = MPAMVPM4_EL2;
        when 5 vpmw = MPAMVPM5_EL2;
        when 6 vpmw = MPAMVPM6_EL2;
        when 7 vpmw = MPAMVPM7_EL2;
        otherwise vpmw = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    // vpme_lsb selects LSB of field within register
    integer vpme_lsb = (vpartid MOD 4) * 16;
    return vpmw&lt;vpme_lsb +: 16&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.ASID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/ASID</h3>
      <p class="pseudocode">// ASID[]
// ======
// Effective ASID.

bits(16) <a id="impl-shared.ASID.read.0"/>ASID[]
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.&lt;E2H, TGE&gt; == '11' then
        if TCR_EL2.A1 == '1' then
            return TTBR1_EL2.ASID;
        else
            return TTBR0_EL2.ASID;

    elsif !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        if TCR_EL1.A1 == '1' then
            return TTBR1_EL1.ASID;
        else
            return TTBR0_EL1.ASID;

    else
        if TTBCR.EAE == '0' then
            return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(CONTEXTIDR.ASID, 16);
        else
            if TTBCR.A1 == '1' then
                return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(TTBR1.ASID, 16);
            else
                return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(TTBR0.ASID, 16);</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.ExecutionCntxt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/ExecutionCntxt</h3>
      <p class="pseudocode">type <a id="ExecutionCntxt"/>ExecutionCntxt is (
    boolean          is_vmid_valid, // is vmid valid for current context
    boolean          all_vmid,      // should the operation be applied for all vmids
    bits(16)         vmid,          // if all_vmid = FALSE, vmid to which operation is applied
    boolean          is_asid_valid, // is asid valid for current context
    boolean          all_asid,      // should the operation be applied for all asids
    bits(16)         asid,          // if all_asid = FALSE, ASID to which operation is applied
    bits(2)          target_el,     // target EL at which operation is performed
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a>    security,
    <a href="shared_pseudocode.html#RestrictType" title="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch,&#13; RestrictType_Other }">RestrictType</a>     restriction    // type of restriction operation
)</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.RESTRICT_PREDICTIONS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/RESTRICT_PREDICTIONS</h3>
      <p class="pseudocode">// RESTRICT_PREDICTIONS()
// ======================
// Clear all speculated values.

<a id="impl-shared.RESTRICT_PREDICTIONS.1"/>RESTRICT_PREDICTIONS(<a href="shared_pseudocode.html#ExecutionCntxt" title="type ExecutionCntxt is ( boolean is_vmid_valid, boolean all_vmid, bits(16) vmid, boolean is_asid_valid, boolean all_asid, bits(16) asid, bits(2) target_el, SecurityState security, RestrictType restriction )">ExecutionCntxt</a> c)
    IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.RestrictType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/RestrictType</h3>
      <p class="pseudocode">enumeration <a id="RestrictType"/>RestrictType {
    <a id="RestrictType_DataValue"/>RestrictType_DataValue,
    <a id="RestrictType_ControlFlow"/>RestrictType_ControlFlow,
    <a id="RestrictType_CachePrefetch"/>RestrictType_CachePrefetch,
    <a id="RestrictType_Other"/>RestrictType_Other              // Any other trained speculation mechanisms than those above
};</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.TargetSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/TargetSecurityState</h3>
      <p class="pseudocode">// TargetSecurityState()
// =====================
// Decode the target security state for the prediction context.

SecurityState <a id="impl-shared.TargetSecurityState.2"/>TargetSecurityState(bit NS, bit NSE)
    curr_ss =  <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
    if curr_ss == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
        return <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    elsif curr_ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        case NS of
            when '0' return <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
            when '1' return <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        if curr_ss == <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a> then
            case NSE:NS of
                when '00' return <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
                when '01' return <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
                when '11' return <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>;
                when '10' return <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>;
        elsif curr_ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> then
            return <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.BranchTo"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/BranchTo</h3>
      <p class="pseudocode">// BranchTo()
// ==========
// Set program counter to a new address, with a branch type.
// Parameter branch_conditional indicates whether the executed branch has a conditional encoding.
// In AArch64 state the address might include a tag in the top eight bits.

<a id="impl-shared.BranchTo.3"/>BranchTo(bits(N) target, <a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> branch_type, boolean branch_conditional)
    <a href="shared_pseudocode.html#impl-shared.Hint_Branch.1" title="function: Hint_Branch(BranchType hint)">Hint_Branch</a>(branch_type);
    if N == 32 then
        assert <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
        _PC = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(target, 64);
    else
        assert N == 64 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
        bits(64) target_vaddress = <a href="shared_pseudocode.html#AArch64.BranchAddr.2" title="function: bits(64) AArch64.BranchAddr(bits(64) vaddress, bits(2) el)">AArch64.BranchAddr</a>(target&lt;63:0&gt;, PSTATE.EL);
        if (<a href="shared_pseudocode.html#impl-shared.HaveBRBExt.0" title="function: boolean HaveBRBExt()">HaveBRBExt</a>() &amp;&amp;
            branch_type IN {<a href="shared_pseudocode.html#BranchType_DIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIR</a>, <a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>,
                            <a href="shared_pseudocode.html#BranchType_DIRCALL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIRCALL</a>, <a href="shared_pseudocode.html#BranchType_INDCALL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDCALL</a>,
                            <a href="shared_pseudocode.html#BranchType_RET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RET</a>}) then
            <a href="shared_pseudocode.html#impl-aarch64.BRBEBranch.3" title="function: BRBEBranch(BranchType br_type, boolean cond, bits(64) target_address)">BRBEBranch</a>(branch_type, branch_conditional, target_vaddress);

        _PC = target_vaddress;
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.BranchToAddr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/BranchToAddr</h3>
      <p class="pseudocode">// BranchToAddr()
// ==============
// Set program counter to a new address, with a branch type.
// In AArch64 state the address does not include a tag in the top eight bits.

<a id="impl-shared.BranchToAddr.2"/>BranchToAddr(bits(N) target, <a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> branch_type)
    <a href="shared_pseudocode.html#impl-shared.Hint_Branch.1" title="function: Hint_Branch(BranchType hint)">Hint_Branch</a>(branch_type);
    if N == 32 then
        assert <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
        _PC = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(target, 64);
    else
        assert N == 64 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
        _PC = target&lt;63:0&gt;;
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.BranchType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/BranchType</h3>
      <p class="pseudocode">enumeration <a id="BranchType"/>BranchType {
    <a id="BranchType_DIRCALL"/>BranchType_DIRCALL,     // Direct Branch with link
    <a id="BranchType_INDCALL"/>BranchType_INDCALL,     // Indirect Branch with link
    <a id="BranchType_ERET"/>BranchType_ERET,        // Exception return (indirect)
    <a id="BranchType_DBGEXIT"/>BranchType_DBGEXIT,     // Exit from Debug state
    <a id="BranchType_RET"/>BranchType_RET,         // Indirect branch with function return hint
    <a id="BranchType_DIR"/>BranchType_DIR,         // Direct branch
    <a id="BranchType_INDIR"/>BranchType_INDIR,       // Indirect branch
    <a id="BranchType_EXCEPTION"/>BranchType_EXCEPTION,   // Exception entry
    <a id="BranchType_TMFAIL"/>BranchType_TMFAIL,      // Transaction failure
    <a id="BranchType_RESET"/>BranchType_RESET,       // Reset
    <a id="BranchType_UNKNOWN"/>BranchType_UNKNOWN};    // Other</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.Hint_Branch"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/Hint_Branch</h3>
      <p class="pseudocode">// Report the hint passed to BranchTo() and BranchToAddr(), for consideration when processing
// the next instruction.
<a id="impl-shared.Hint_Branch.1"/>Hint_Branch(<a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> hint);</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.NextInstrAddr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/NextInstrAddr</h3>
      <p class="pseudocode">// Return address of the sequentially next instruction.
bits(N) <a id="impl-shared.NextInstrAddr.1"/>NextInstrAddr(integer N);</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.ResetExternalDebugRegisters"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/ResetExternalDebugRegisters</h3>
      <p class="pseudocode">// Reset the External Debug registers in the Core power domain.
<a id="impl-shared.ResetExternalDebugRegisters.1"/>ResetExternalDebugRegisters(boolean cold_reset);</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.ThisInstrAddr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/ThisInstrAddr</h3>
      <p class="pseudocode">// ThisInstrAddr()
// ===============
// Return address of the current instruction.

bits(N) <a id="impl-shared.ThisInstrAddr.1"/>ThisInstrAddr(integer N)
    assert N == 64 || (N == 32 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>());
    return _PC&lt;N-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers._PC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/_PC</h3>
      <p class="pseudocode">bits(64) _PC;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers._R"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/_R</h3>
      <p class="pseudocode">array bits(64) _R[0..30];</p>
    </div>
    <div class="ps"><a id="shared.functions.sysregisters.SPSR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/sysregisters/SPSR</h3>
      <p class="pseudocode">// SPSR[] - non-assignment form
// ============================

bits(N) <a id="impl-shared.SPSR.read.0"/>SPSR[]
    bits(N) result;
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        assert N == 32;
        case PSTATE.M of
            when <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>      result = SPSR_fiq&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>      result = SPSR_irq&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>      result = SPSR_svc&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>  result = SPSR_mon&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>    result = SPSR_abt&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>      result = SPSR_hyp&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>    result = SPSR_und&lt;N-1:0&gt;;
            otherwise         <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    else
        assert N == 64;
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>          result = SPSR_EL1&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>          result = SPSR_EL2&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>          result = SPSR_EL3&lt;N-1:0&gt;;
            otherwise         <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return result;

// SPSR[] - assignment form
// ========================

<a id="impl-shared.SPSR.write.0"/>SPSR[] = bits(N) value
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        assert N == 32;
        case PSTATE.M of
            when <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>      SPSR_fiq&lt;N-1:0&gt; = value&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>      SPSR_irq&lt;N-1:0&gt; = value&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>      SPSR_svc&lt;N-1:0&gt; = value&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>  SPSR_mon&lt;N-1:0&gt; = value&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>    SPSR_abt&lt;N-1:0&gt; = value&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>      SPSR_hyp&lt;N-1:0&gt; = value&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>    SPSR_und&lt;N-1:0&gt; = value&lt;N-1:0&gt;;
            otherwise         <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    else
        assert N == 64;
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>          SPSR_EL1&lt;N-1:0&gt; = value&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>          SPSR_EL2&lt;N-1:0&gt; = value&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>          SPSR_EL3&lt;N-1:0&gt; = value&lt;N-1:0&gt;;
            otherwise         <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.BranchTargetCheck"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/BranchTargetCheck</h3>
      <p class="pseudocode">// BranchTargetCheck()
// ===================
// This function is executed checks if the current instruction is a valid target for a branch
// taken into, or inside, a guarded page. It is executed on every cycle once the current
// instruction has been decoded and the values of InGuardedPage and BTypeCompatible have been
// determined for the current instruction.

<a id="impl-shared.BranchTargetCheck.0"/>BranchTargetCheck()
    assert <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();

    // The branch target check considers two state variables:
    // * InGuardedPage, which is evaluated during instruction fetch.
    // * BTypeCompatible, which is evaluated during instruction decode.
    if InGuardedPage &amp;&amp; PSTATE.BTYPE != '00' &amp;&amp; !BTypeCompatible &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then
        bits(64) pc = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.1" title="function: bits(N) ThisInstrAddr(integer N)">ThisInstrAddr</a>(64);
        <a href="shared_pseudocode.html#AArch64.BranchTargetException.1" title="function: AArch64.BranchTargetException(bits(52) vaddress)">AArch64.BranchTargetException</a>(pc&lt;51:0&gt;);

    boolean branch_instr = <a href="shared_pseudocode.html#AArch64.ExecutingBROrBLROrRetInstr.0" title="function: boolean AArch64.ExecutingBROrBLROrRetInstr()">AArch64.ExecutingBROrBLROrRetInstr</a>();
    boolean bti_instr    = <a href="shared_pseudocode.html#AArch64.ExecutingBTIInstr.0" title="function: boolean AArch64.ExecutingBTIInstr()">AArch64.ExecutingBTIInstr</a>();

    // PSTATE.BTYPE defaults to 00 for instructions that do not explictly set BTYPE.
    if !(branch_instr || bti_instr) then
        BTypeNext = '00';</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ClearEventRegister"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ClearEventRegister</h3>
      <p class="pseudocode">// ClearEventRegister()
// ====================
// Clear the Event Register of this PE.

<a id="impl-shared.ClearEventRegister.0"/>ClearEventRegister()
    EventRegister = '0';
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ConditionHolds"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ConditionHolds</h3>
      <p class="pseudocode">// ConditionHolds()
// ================
// Return TRUE iff COND currently holds

boolean <a id="impl-shared.ConditionHolds.1"/>ConditionHolds(bits(4) cond)
    // Evaluate base condition.
    boolean result;
    case cond&lt;3:1&gt; of
        when '000' result = (PSTATE.Z == '1');                          // EQ or NE
        when '001' result = (PSTATE.C == '1');                          // CS or CC
        when '010' result = (PSTATE.N == '1');                          // MI or PL
        when '011' result = (PSTATE.V == '1');                          // VS or VC
        when '100' result = (PSTATE.C == '1' &amp;&amp; PSTATE.Z == '0');       // HI or LS
        when '101' result = (PSTATE.N == PSTATE.V);                     // GE or LT
        when '110' result = (PSTATE.N == PSTATE.V &amp;&amp; PSTATE.Z == '0');  // GT or LE
        when '111' result = TRUE;                                       // AL

    // Condition flag values in the set '111x' indicate always true
    // Otherwise, invert condition if necessary.
    if cond&lt;0&gt; == '1' &amp;&amp; cond != '1111' then
        result = !result;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ConsumptionOfSpeculativeDataBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ConsumptionOfSpeculativeDataBarrier</h3>
      <p class="pseudocode"><a id="impl-shared.ConsumptionOfSpeculativeDataBarrier.0"/>ConsumptionOfSpeculativeDataBarrier();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.CurrentInstrSet"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/CurrentInstrSet</h3>
      <p class="pseudocode">// CurrentInstrSet()
// =================

InstrSet <a id="impl-shared.CurrentInstrSet.0"/>CurrentInstrSet()
    <a href="shared_pseudocode.html#InstrSet" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet</a> result;
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        result = if PSTATE.T == '0' then <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> else <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>;
        // PSTATE.J is RES0. Implementation of T32EE or Jazelle state not permitted.
    else
        result = <a href="shared_pseudocode.html#InstrSet_A64" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A64</a>;
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.CurrentPL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/CurrentPL</h3>
      <p class="pseudocode">// CurrentPL()
// ===========

PrivilegeLevel <a id="impl-shared.CurrentPL.0"/>CurrentPL()
    return <a href="shared_pseudocode.html#impl-shared.PLOfEL.1" title="function: PrivilegeLevel PLOfEL(bits(2) el)">PLOfEL</a>(PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.CurrentSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/CurrentSecurityState</h3>
      <p class="pseudocode">// CurrentSecurityState()
// ======================
// Returns the effective security state at the exception level based off current settings.

SecurityState <a id="impl-shared.CurrentSecurityState.0"/>CurrentSecurityState()
    return <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.DSBAlias"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/DSBAlias</h3>
      <p class="pseudocode">enumeration <a id="DSBAlias"/>DSBAlias {<a id="DSBAlias_SSBB"/>DSBAlias_SSBB, <a id="DSBAlias_PSSBB"/>DSBAlias_PSSBB, <a id="DSBAlias_DSB"/>DSBAlias_DSB};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EL0</h3>
      <p class="pseudocode">constant bits(2) <a id="EL3"/>EL3 = '11';
constant bits(2) <a id="EL2"/>EL2 = '10';
constant bits(2) <a id="EL1"/>EL1 = '01';
constant bits(2) <a id="EL0"/>EL0 = '00';</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EL2Enabled</h3>
      <p class="pseudocode">// EL2Enabled()
// ============
// Returns TRUE if EL2 is present and executing
// - with the PE in Non-secure state when Non-secure EL2 is implemented, or
// - with the PE in Realm state when Realm EL2 is implemented, or
// - with the PE in Secure state when Secure EL2 is implemented and enabled, or
// - when EL3 is not implemented.

boolean <a id="impl-shared.EL2Enabled.0"/>EL2Enabled()
    return <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].NS == '1' || <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>());</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EL3SDDUndef"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EL3SDDUndef</h3>
      <p class="pseudocode">// EL3SDDUndef()
// =============
// Returns TRUE if in Debug state and EDSCR.SDD is set.

boolean <a id="impl-shared.EL3SDDUndef.0"/>EL3SDDUndef()
    return <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.SDD == '1';</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EL3SDDUndefPriority"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EL3SDDUndefPriority</h3>
      <p class="pseudocode">// EL3SDDUndefPriority()
// =====================
// Returns TRUE if in Debug state, EDSCR.SDD is set, and an EL3 trap by an
// EL3 control register has priority over other traps.
// The IMPLEMENTATION DEFINED priority may be different for each case.

boolean <a id="impl-shared.EL3SDDUndefPriority.0"/>EL3SDDUndefPriority()
    return (<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.SDD == '1' &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> trap priority when SDD == '1'");</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELFromM32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELFromM32</h3>
      <p class="pseudocode">// ELFromM32()
// ===========

(boolean,bits(2)) <a id="impl-shared.ELFromM32.1"/>ELFromM32(bits(5) mode)
    // Convert an AArch32 mode encoding to an Exception level.
    // Returns (valid,EL):
    //   'valid' is TRUE if 'mode&lt;4:0&gt;' encodes a mode that is both valid for this implementation
    //           and the current value of SCR.NS/SCR_EL3.NS.
    //   'EL'    is the Exception level decoded from 'mode'.
    bits(2) el;
    boolean valid = !<a href="shared_pseudocode.html#impl-aarch32.BadMode.1" title="function: boolean BadMode(bits(5) mode)">BadMode</a>(mode);  // Check for modes that are not valid for this implementation
    case mode of
        when <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>
            el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
        when <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>
            el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
        when <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>, <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>, <a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>
            // If EL3 is implemented and using AArch32, then these modes are EL3 modes in Secure
            // state, and EL1 modes in Non-secure state. If EL3 is not implemented or is using
            // AArch64, then these modes are EL1 modes.
            el = (if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() &amp;&amp; SCR.NS == '0' then <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
        when <a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>
            el = <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
        otherwise
            valid = FALSE;           // Passed an illegal mode value

    if valid &amp;&amp; el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].NS == '0' then
        valid = FALSE;               // EL2 only valid in Non-secure state in AArch32
    elsif valid &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; SCR_EL3.&lt;NSE,NS&gt; == '10' then
        valid = FALSE;               // No AArch32 modes in Root state

    if !valid then el = bits(2) UNKNOWN;
    return (valid, el);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELFromSPSR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELFromSPSR</h3>
      <p class="pseudocode">// ELFromSPSR()
// ============

// Convert an SPSR value encoding to an Exception level.
// Returns (valid,EL):
//   'valid' is TRUE if 'spsr&lt;4:0&gt;' encodes a valid mode for the current state.
//   'EL'    is the Exception level decoded from 'spsr'.

(boolean,bits(2)) <a id="impl-shared.ELFromSPSR.1"/>ELFromSPSR(bits(N) spsr)
    bits(2) el;
    boolean valid;
    if spsr&lt;4&gt; == '0' then      // AArch64 state
        el = spsr&lt;3:2&gt;;
        if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
            valid = FALSE;      // No AArch64 support
        elsif !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el) then
            valid = FALSE;      // Exception level not implemented
        elsif spsr&lt;1&gt; == '1' then
            valid = FALSE;      // M[1] must be 0
        elsif el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; spsr&lt;0&gt; == '1' then
            valid = FALSE;      // for EL0, M[0] must be 0
        elsif <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; el != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; SCR_EL3.&lt;NSE,NS&gt; == '10' then
            valid = FALSE;      // Only EL3 valid in Root state
        elsif el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() &amp;&amp; SCR_EL3.NS == '0' then
            valid = FALSE;      // Unless Secure EL2 is enabled, EL2 valid only in Non-secure state
        else
            valid = TRUE;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() then    // AArch32 state
        (valid, el) = <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(spsr&lt;4:0&gt;);
    else
        valid = FALSE;

    if !valid then el = bits(2) UNKNOWN;
    return (valid,el);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELIsInHost"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELIsInHost</h3>
      <p class="pseudocode">// ELIsInHost()
// ============

boolean <a id="impl-shared.ELIsInHost.1"/>ELIsInHost(bits(2) el)
    if !<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        return FALSE;
    case el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            return FALSE;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            return <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.E2H == '1';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            return FALSE;
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            return <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11';
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELStateUsingAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELStateUsingAArch32</h3>
      <p class="pseudocode">// ELStateUsingAArch32()
// =====================

boolean <a id="impl-shared.ELStateUsingAArch32.2"/>ELStateUsingAArch32(bits(2) el, boolean secure)
    // See ELStateUsingAArch32K() for description. Must only be called in circumstances where
    // result is valid (typically, that means 'el IN {EL1,EL2,EL3}').
    (known, aarch32) = <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32K.2" title="function: (boolean,boolean) ELStateUsingAArch32K(bits(2) el, boolean secure)">ELStateUsingAArch32K</a>(el, secure);
    assert known;
    return aarch32;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELStateUsingAArch32K"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELStateUsingAArch32K</h3>
      <p class="pseudocode">// ELStateUsingAArch32K()
// ======================

(boolean,boolean) <a id="impl-shared.ELStateUsingAArch32K.2"/>ELStateUsingAArch32K(bits(2) el, boolean secure)
    // Returns (known, aarch32):
    //   'known'   is FALSE for EL0 if the current Exception level is not EL0 and EL1 is
    //             using AArch64, since it cannot determine the state of EL0; TRUE otherwise.
    //   'aarch32' is TRUE if the specified Exception level is using AArch32; FALSE otherwise.
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(el) then
        return (TRUE, FALSE);   // Exception level is using AArch64
    elsif secure &amp;&amp; el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        return (TRUE, FALSE);   // Secure EL2 is using AArch64
    elsif !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        return (TRUE, TRUE);    // Highest Exception level, therefore all levels are using AArch32

    // Remainder of function deals with the interprocessing cases when highest
    // Exception level is using AArch64

    boolean aarch32 = boolean UNKNOWN;
    boolean known = TRUE;

    aarch32_below_el3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.RW == '0' &amp;&amp; (!secure || !<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() || SCR_EL3.EEL2 == '0');
    aarch32_at_el1 = (aarch32_below_el3 || (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
                                            ((<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; SCR_EL3.EEL2 == '1') || !secure) &amp;&amp; HCR_EL2.RW == '0' &amp;&amp;
                                            !(HCR_EL2.E2H == '1' &amp;&amp; HCR_EL2.TGE == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>())));
    if el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !aarch32_at_el1 then       // Only know if EL0 using AArch32 from PSTATE
        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            aarch32 = PSTATE.nRW == '1';       // EL0 controlled by PSTATE
        else
            known = FALSE;                     // EL0 state is UNKNOWN
    else
        aarch32 = (aarch32_below_el3 &amp;&amp; el != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || (aarch32_at_el1 &amp;&amp; el IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>,<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>});

    if !known then aarch32 = boolean UNKNOWN;
    return (known, aarch32);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELUsingAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELUsingAArch32</h3>
      <p class="pseudocode">// ELUsingAArch32()
// ================

boolean <a id="impl-shared.ELUsingAArch32.1"/>ELUsingAArch32(bits(2) el)
    return <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(el, <a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>());</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELUsingAArch32K"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELUsingAArch32K</h3>
      <p class="pseudocode">// ELUsingAArch32K()
// =================

(boolean,boolean) <a id="impl-shared.ELUsingAArch32K.1"/>ELUsingAArch32K(bits(2) el)
    return <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32K.2" title="function: (boolean,boolean) ELStateUsingAArch32K(bits(2) el, boolean secure)">ELStateUsingAArch32K</a>(el, <a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>());</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EffectiveSCR_EL3_RW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EffectiveSCR_EL3_RW</h3>
      <p class="pseudocode">// EffectiveSCR_EL3_RW()
// =====================
// Returns effective SCR_EL3.RW value

bit <a id="impl-shared.EffectiveSCR_EL3_RW.0"/>EffectiveSCR_EL3_RW()
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        return '0';
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        return '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        if !<a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; SCR_EL3.NS == '1' then
            return '1';
        if <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; SCR_EL3.EEL2 == '1' &amp;&amp; SCR_EL3.NS == '0' then
            return '1';
    return SCR_EL3.RW;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EffectiveTGE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EffectiveTGE</h3>
      <p class="pseudocode">// EffectiveTGE()
// ==============
// Returns effective TGE value

bit <a id="impl-shared.EffectiveTGE.0"/>EffectiveTGE()
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        return if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HCR.TGE else HCR_EL2.TGE;
    else
        return '0';        // Effective value of TGE is zero</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EndOfInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EndOfInstruction</h3>
      <p class="pseudocode">// Terminate processing of the current instruction.
<a id="impl-shared.EndOfInstruction.0"/>EndOfInstruction();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EnterLowPowerState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EnterLowPowerState</h3>
      <p class="pseudocode">// PE enters a low-power state.
<a id="impl-shared.EnterLowPowerState.0"/>EnterLowPowerState();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EventRegister"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EventRegister</h3>
      <p class="pseudocode">bits(1) EventRegister;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ExceptionalOccurrenceTargetState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ExceptionalOccurrenceTargetState</h3>
      <p class="pseudocode">enumeration <a id="ExceptionalOccurrenceTargetState"/>ExceptionalOccurrenceTargetState {
    <a id="AArch32_NonDebugState"/>AArch32_NonDebugState,
    <a id="AArch64_NonDebugState"/>AArch64_NonDebugState,
    <a id="DebugState"/>DebugState
};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.FIQPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/FIQPending</h3>
      <p class="pseudocode">// Returns a tuple indicating if there is any pending physical FIQ
// and if the pending FIQ has superpriority.
(boolean, boolean) <a id="impl-shared.FIQPending.0"/>FIQPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.GetAccumulatedFPExceptions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/GetAccumulatedFPExceptions</h3>
      <p class="pseudocode">// Returns FP exceptions accumulated by the PE.
bits(8) <a id="impl-shared.GetAccumulatedFPExceptions.0"/>GetAccumulatedFPExceptions();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.GetLoadStoreType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/GetLoadStoreType</h3>
      <p class="pseudocode">// Returns the Load/Store Type. Used when a Translation fault,
// Access flag fault, or Permission fault generates a Data Abort.
bits(2) <a id="impl-shared.GetLoadStoreType.0"/>GetLoadStoreType();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.GetPSRFromPSTATE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/GetPSRFromPSTATE</h3>
      <p class="pseudocode">// GetPSRFromPSTATE()
// ==================
// Return a PSR value which represents the current PSTATE

bits(N) <a id="impl-shared.GetPSRFromPSTATE.2"/>GetPSRFromPSTATE(<a href="shared_pseudocode.html#ExceptionalOccurrenceTargetState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">ExceptionalOccurrenceTargetState</a> targetELState, integer N)
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; targetELState == <a href="shared_pseudocode.html#AArch32_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a> then
        assert N == 32;
    else
        assert N == 64;

    bits(N) spsr = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N);
    spsr&lt;31:28&gt; = PSTATE.&lt;N,Z,C,V&gt;;
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() then spsr&lt;22&gt; = PSTATE.PAN;
    spsr&lt;20&gt;    = PSTATE.IL;
    if PSTATE.nRW == '1' then                           // AArch32 state
        spsr&lt;27&gt;    = PSTATE.Q;
        spsr&lt;26:25&gt; = PSTATE.IT&lt;1:0&gt;;
        if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then spsr&lt;23&gt; = PSTATE.SSBS;
        if <a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()">HaveDITExt</a>() then
            if targetELState == <a href="shared_pseudocode.html#AArch32_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a> then
                spsr&lt;21&gt; = PSTATE.DIT;
            else                                        // AArch64_NonDebugState or DebugState
                spsr&lt;24&gt; = PSTATE.DIT;
        if targetELState IN {<a href="shared_pseudocode.html#AArch64_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch64_NonDebugState</a>, <a href="shared_pseudocode.html#DebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">DebugState</a>} then
            spsr&lt;21&gt; = PSTATE.SS;
        spsr&lt;19:16&gt; = PSTATE.GE;
        spsr&lt;15:10&gt; = PSTATE.IT&lt;7:2&gt;;
        spsr&lt;9&gt;     = PSTATE.E;
        spsr&lt;8:6&gt;   = PSTATE.&lt;A,I,F&gt;;                   // No PSTATE.D in AArch32 state
        spsr&lt;5&gt;     = PSTATE.T;
        assert PSTATE.M&lt;4&gt; == PSTATE.nRW;               // bit [4] is the discriminator
        spsr&lt;4:0&gt;   = PSTATE.M;
    else                                                // AArch64 state
        if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then spsr&lt;25&gt; = PSTATE.TCO;
        if <a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()">HaveDITExt</a>() then spsr&lt;24&gt; = PSTATE.DIT;
        if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() then spsr&lt;23&gt; = PSTATE.UAO;
        spsr&lt;21&gt;    = PSTATE.SS;
        if <a href="shared_pseudocode.html#impl-shared.HaveFeatNMI.0" title="function: boolean HaveFeatNMI()">HaveFeatNMI</a>() then spsr&lt;13&gt; = PSTATE.ALLINT;
        if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then spsr&lt;12&gt; = PSTATE.SSBS;
        if <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then spsr&lt;11:10&gt; = PSTATE.BTYPE;
        spsr&lt;9:6&gt;   = PSTATE.&lt;D,A,I,F&gt;;
        spsr&lt;4&gt;     = PSTATE.nRW;
        spsr&lt;3:2&gt;   = PSTATE.EL;
        spsr&lt;0&gt;     = PSTATE.SP;
    return spsr;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HasArchVersion"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HasArchVersion</h3>
      <p class="pseudocode">// HasArchVersion()
// ================
// Returns TRUE if the implemented architecture includes the extensions defined in the specified
// architecture version.

boolean HasArchVersion(ArchVersion version)
    return Variant(version);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveAArch32</h3>
      <p class="pseudocode">// HaveAArch32()
// =============
// Return TRUE if AArch32 state is supported at at least EL0.

boolean <a id="impl-shared.HaveAArch32.0"/>HaveAArch32()
    return boolean IMPLEMENTATION_DEFINED "AArch32 state is supported at at least <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>";</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveAArch32EL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveAArch32EL</h3>
      <p class="pseudocode">// HaveAArch32EL()
// ===============

boolean <a id="impl-shared.HaveAArch32EL.1"/>HaveAArch32EL(bits(2) el)
    // Return TRUE if Exception level 'el' supports AArch32 in this implementation
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el) then
        return FALSE;                    // The Exception level is not implemented
    elsif !<a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() then
        return FALSE;                    // No Exception level can use AArch32
    elsif !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        return TRUE;                     // All Exception levels are using AArch32
    elsif el == <a href="shared_pseudocode.html#impl-shared.HighestEL.0" title="function: bits(2) HighestEL()">HighestEL</a>() then
        return FALSE;                    // The highest Exception level is using AArch64
    elsif el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        return TRUE;                     // EL0 must support using AArch32 if any AArch32
    return boolean IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveAArch64"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveAArch64</h3>
      <p class="pseudocode">// HaveAArch64()
// =============
// Return TRUE if the highest Exception level is using AArch64 state.

boolean <a id="impl-shared.HaveAArch64.0"/>HaveAArch64()
    return boolean IMPLEMENTATION_DEFINED "Highest EL using AArch64";</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveEL</h3>
      <p class="pseudocode">// HaveEL()
// ========
// Return TRUE if Exception level 'el' is supported

boolean <a id="impl-shared.HaveEL.1"/>HaveEL(bits(2) el)
    if el IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>,<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>} then
        return TRUE;                             // EL1 and EL0 must exist
    return boolean IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveELUsingSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveELUsingSecurityState</h3>
      <p class="pseudocode">// HaveELUsingSecurityState()
// ==========================
// Returns TRUE if Exception level 'el' with Security state 'secure' is supported,
// FALSE otherwise.

boolean <a id="impl-shared.HaveELUsingSecurityState.2"/>HaveELUsingSecurityState(bits(2) el, boolean secure)

    case el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            assert secure;
            return <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if secure then
                return <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>();
            else
                return <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        otherwise
            return (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) ||
                    (secure == boolean IMPLEMENTATION_DEFINED "Secure-only implementation"));</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveFP16Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveFP16Ext</h3>
      <p class="pseudocode">// HaveFP16Ext()
// =============
// Return TRUE if FP16 extension is supported

boolean <a id="impl-shared.HaveFP16Ext.0"/>HaveFP16Ext()
    return IsFeatureImplemented(FEAT_FP16);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HighestEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HighestEL</h3>
      <p class="pseudocode">// HighestEL()
// ===========
// Returns the highest implemented Exception level.

bits(2) <a id="impl-shared.HighestEL.0"/>HighestEL()
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        return <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        return <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        return <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_CLRBHB"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_CLRBHB</h3>
      <p class="pseudocode">// Provides a hint to clear the branch history for the current context.
<a id="impl-shared.Hint_CLRBHB.0"/>Hint_CLRBHB();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_DGH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_DGH</h3>
      <p class="pseudocode">// Provides a hint to close any gathering occurring within the micro-architecture.
<a id="impl-shared.Hint_DGH.0"/>Hint_DGH();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_WFE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_WFE</h3>
      <p class="pseudocode">// Hint_WFE()
// ==========
// Provides a hint indicating that the PE can enter a low-power state
// and remain there until a wakeup event occurs or, for WFET,  a local
// timeout event is generated when the virtual timer value equals or
// exceeds the supplied threshold value.

<a id="impl-shared.Hint_WFE.2"/>Hint_WFE(integer localtimeout, <a href="shared_pseudocode.html#WFxType" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype)
    if <a href="shared_pseudocode.html#impl-shared.IsEventRegisterSet.0" title="function: boolean IsEventRegisterSet()">IsEventRegisterSet</a>() then
        <a href="shared_pseudocode.html#impl-shared.ClearEventRegister.0" title="function: ClearEventRegister()">ClearEventRegister</a>();
    elsif <a href="shared_pseudocode.html#impl-shared.HaveFeatWFxT.0" title="function: boolean HaveFeatWFxT()">HaveFeatWFxT</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.LocalTimeoutEvent.1" title="function: boolean LocalTimeoutEvent(integer localtimeout)">LocalTimeoutEvent</a>(localtimeout) then
        // No further operation if the local timeout has expired.
        <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();
    else
        bits(2) target_el;
        trap = FALSE;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            // Check for traps described by the OS which may be EL1 or EL2.
            if <a href="shared_pseudocode.html#impl-shared.HaveTWEDExt.0" title="function: boolean HaveTWEDExt()">HaveTWEDExt</a>() then
                sctlr     = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[];
                trap      = sctlr.nTWE == '0';
                target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            else
                <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, wfxtype);
        if !trap &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            // Check for traps described by the Hypervisor.
            if <a href="shared_pseudocode.html#impl-shared.HaveTWEDExt.0" title="function: boolean HaveTWEDExt()">HaveTWEDExt</a>() then
                trap      = HCR_EL2.TWE == '1';
                target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
            else
                <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, wfxtype);

        if !trap &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            // Check for traps described by the Secure Monitor.
            if <a href="shared_pseudocode.html#impl-shared.HaveTWEDExt.0" title="function: boolean HaveTWEDExt()">HaveTWEDExt</a>() then
                trap      = SCR_EL3.TWE == '1';
                target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
            else
                <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, wfxtype);

        if trap &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            (delay_enabled, delay) = <a href="shared_pseudocode.html#impl-aarch64.WFETrapDelay.1" title="function: (boolean, integer) WFETrapDelay(bits(2) target_el)">WFETrapDelay</a>(target_el);    // (If trap delay is enabled, Delay amount)
            if !<a href="shared_pseudocode.html#impl-aarch64.WaitForEventUntilDelay.2" title="function: boolean WaitForEventUntilDelay(boolean delay_enabled, integer delay)">WaitForEventUntilDelay</a>(delay_enabled, delay) then
                // Event did not arrive before delay expired
                <a href="shared_pseudocode.html#AArch64.WFxTrap.2" title="function: AArch64.WFxTrap(WFxType wfxtype, bits(2) target_el)">AArch64.WFxTrap</a>(wfxtype, target_el);             // Trap WFE
        else
            <a href="shared_pseudocode.html#impl-shared.WaitForEvent.1" title="function: WaitForEvent(integer localtimeout)">WaitForEvent</a>(localtimeout);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_WFI"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_WFI</h3>
      <p class="pseudocode">// Hint_WFI()
// ==========
// Provides a hint indicating that the PE can enter a low-power state and
// remain there until a wakeup event occurs or, for WFIT, a local timeout
// event is generated when the virtual timer value equals or exceeds the
// supplied threshold value.

<a id="impl-shared.Hint_WFI.2"/>Hint_WFI(integer localtimeout, <a href="shared_pseudocode.html#WFxType" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype)
    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then
        <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(<a href="shared_pseudocode.html#TMFailure_ERR" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_ERR</a>, FALSE);

    if <a href="shared_pseudocode.html#impl-shared.InterruptPending.0" title="function: boolean InterruptPending()">InterruptPending</a>() || (<a href="shared_pseudocode.html#impl-shared.HaveFeatWFxT.0" title="function: boolean HaveFeatWFxT()">HaveFeatWFxT</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.LocalTimeoutEvent.1" title="function: boolean LocalTimeoutEvent(integer localtimeout)">LocalTimeoutEvent</a>(localtimeout)) then
        // No further operation if an interrupt is pending or the local timeout has expired.
        <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();
    else
        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            // Check for traps described by the OS.
            <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, wfxtype);
        if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            // Check for traps described by the Hypervisor.
            <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, wfxtype);
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            // Check for traps described by the Secure Monitor.
            <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, wfxtype);
        <a href="shared_pseudocode.html#impl-shared.WaitForInterrupt.1" title="function: WaitForInterrupt(integer localtimeout)">WaitForInterrupt</a>(localtimeout);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_Yield"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_Yield</h3>
      <p class="pseudocode">// Provides a hint that the task performed by a thread is of low
// importance so that it could yield to improve overall performance.
<a id="impl-shared.Hint_Yield.0"/>Hint_Yield();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IRQPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IRQPending</h3>
      <p class="pseudocode">// Returns a tuple indicating if there is any pending physical IRQ
// and if the pending IRQ has superpriority.
(boolean, boolean) <a id="impl-shared.IRQPending.0"/>IRQPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IllegalExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IllegalExceptionReturn</h3>
      <p class="pseudocode">// IllegalExceptionReturn()
// ========================

boolean <a id="impl-shared.IllegalExceptionReturn.1"/>IllegalExceptionReturn(bits(N) spsr)

    // Check for illegal return:
    //   * To an unimplemented Exception level.
    //   * To EL2 in Secure state, when SecureEL2 is not enabled.
    //   * To EL0 using AArch64 state, with SPSR.M[0]==1.
    //   * To AArch64 state with SPSR.M[1]==1.
    //   * To AArch32 state with an illegal value of SPSR.M.
    (valid, target) = <a href="shared_pseudocode.html#impl-shared.ELFromSPSR.1" title="function: (boolean,bits(2)) ELFromSPSR(bits(N) spsr)">ELFromSPSR</a>(spsr);
    if !valid then return TRUE;

    // Check for return to higher Exception level
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then return TRUE;

    spsr_mode_is_aarch32 = (spsr&lt;4&gt; == '1');

    // Check for illegal return:
    //   * To EL1, EL2 or EL3 with register width specified in the SPSR different from the
    //     Execution state used in the Exception level being returned to, as determined by
    //     the SCR_EL3.RW or HCR_EL2.RW bits, or as configured from reset.
    //   * To EL0 using AArch64 state when EL1 is using AArch32 state as determined by the
    //     SCR_EL3.RW or HCR_EL2.RW bits or as configured from reset.
    //   * To AArch64 state from AArch32 state (should be caught by above)
    (known, target_el_is_aarch32) = <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32K.1" title="function: (boolean,boolean) ELUsingAArch32K(bits(2) el)">ELUsingAArch32K</a>(target);
    assert known || (target == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>));
    if known &amp;&amp; spsr_mode_is_aarch32 != target_el_is_aarch32 then return TRUE;

    // Check for illegal return from AArch32 to AArch64
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; !spsr_mode_is_aarch32 then return TRUE;

    // Check for illegal return to EL1 when HCR.TGE is set and when either of
    // * SecureEL2 is enabled.
    // * SecureEL2 is not enabled and EL1 is in Non-secure state.
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; target == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; HCR_EL2.TGE == '1' then
        if (!<a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>() || <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) then return TRUE;
    return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.InstrSet"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/InstrSet</h3>
      <p class="pseudocode">enumeration <a id="InstrSet"/>InstrSet {<a id="InstrSet_A64"/>InstrSet_A64, <a id="InstrSet_A32"/>InstrSet_A32, <a id="InstrSet_T32"/>InstrSet_T32};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.InstructionSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/InstructionSynchronizationBarrier</h3>
      <p class="pseudocode"><a id="impl-shared.InstructionSynchronizationBarrier.0"/>InstructionSynchronizationBarrier();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.InterruptPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/InterruptPending</h3>
      <p class="pseudocode">// InterruptPending()
// ==================
// Returns TRUE if there are any pending physical or virtual
// interrupts, and FALSE otherwise.

boolean <a id="impl-shared.InterruptPending.0"/>InterruptPending()
    boolean pending_virtual_interrupt = FALSE;
    (irq_pending, -) = <a href="shared_pseudocode.html#impl-shared.IRQPending.0" title="function: (boolean, boolean) IRQPending()">IRQPending</a>();
    (fiq_pending, -) = <a href="shared_pseudocode.html#impl-shared.FIQPending.0" title="function: (boolean, boolean) FIQPending()">FIQPending</a>();
    boolean pending_physical_interrupt = (irq_pending || fiq_pending ||
                                          <a href="shared_pseudocode.html#impl-shared.IsPhysicalSErrorPending.0" title="function: boolean IsPhysicalSErrorPending()">IsPhysicalSErrorPending</a>());

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; HCR_EL2.TGE == '0' then
        boolean virq_pending = HCR_EL2.IMO == '1' &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.VirtualIRQPending.0" title="function: boolean VirtualIRQPending()">VirtualIRQPending</a>() || HCR_EL2.VI == '1') ;
        boolean vfiq_pending = HCR_EL2.FMO == '1' &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.VirtualFIQPending.0" title="function: boolean VirtualFIQPending()">VirtualFIQPending</a>() || HCR_EL2.VF == '1');
        boolean vsei_pending = HCR_EL2.AMO == '1' &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.IsVirtualSErrorPending.0" title="function: boolean IsVirtualSErrorPending()">IsVirtualSErrorPending</a>() || HCR_EL2.VSE == '1');
        pending_virtual_interrupt = vsei_pending || virq_pending || vfiq_pending;

    return pending_physical_interrupt || pending_virtual_interrupt;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsASEInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsASEInstruction</h3>
      <p class="pseudocode">// Returns TRUE if the current instruction is an ASIMD or SVE vector instruction.
boolean <a id="impl-shared.IsASEInstruction.0"/>IsASEInstruction();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsCMOWControlledInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsCMOWControlledInstruction</h3>
      <p class="pseudocode">// When using AArch64, returns TRUE if the current instruction is one of IC IVAU,
// DC CIVAC, DC CIGDVAC, or DC CIGVAC.
// When using AArch32, returns TRUE if the current instruction is ICIMVAU or DCCIMVAC.
boolean <a id="impl-shared.IsCMOWControlledInstruction.0"/>IsCMOWControlledInstruction();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsCurrentSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsCurrentSecurityState</h3>
      <p class="pseudocode">// IsCurrentSecurityState()
// ========================
// Returns TRUE if the current Security state matches
// the given Security state, and FALSE otherwise.

boolean <a id="impl-shared.IsCurrentSecurityState.1"/>IsCurrentSecurityState(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    return <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == ss;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsEventRegisterSet"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsEventRegisterSet</h3>
      <p class="pseudocode">// IsEventRegisterSet()
// ====================
// Return TRUE if the Event Register of this PE is set, and FALSE if it is clear.

boolean <a id="impl-shared.IsEventRegisterSet.0"/>IsEventRegisterSet()
    return EventRegister == '1';</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsHighestEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsHighestEL</h3>
      <p class="pseudocode">// IsHighestEL()
// =============
// Returns TRUE if given exception level is the highest exception level implemented

boolean <a id="impl-shared.IsHighestEL.1"/>IsHighestEL(bits(2) el)
    return <a href="shared_pseudocode.html#impl-shared.HighestEL.0" title="function: bits(2) HighestEL()">HighestEL</a>() == el;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsInHost"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsInHost</h3>
      <p class="pseudocode">// IsInHost()
// ==========

boolean <a id="impl-shared.IsInHost.0"/>IsInHost()
    return <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsSecure"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsSecure</h3>
      <p class="pseudocode">// IsSecure()
// ==========
// Returns TRUE if current Exception level is in Secure state.

boolean <a id="impl-shared.IsSecure.0"/>IsSecure()
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        return TRUE;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then
        return TRUE;
    return <a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsSecureBelowEL3"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsSecureBelowEL3</h3>
      <p class="pseudocode">// IsSecureBelowEL3()
// ==================
// Return TRUE if an Exception level below EL3 is in Secure state
// or would be following an exception return to that level.
//
// Differs from IsSecure in that it ignores the current EL or Mode
// in considering security state.
// That is, if at AArch64 EL3 or in AArch32 Monitor mode, whether an
// exception return would pass to Secure or Non-secure state.

boolean <a id="impl-shared.IsSecureBelowEL3.0"/>IsSecureBelowEL3()
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        return <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].NS == '0';
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() || !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>()) then
        // If Secure EL2 is not an architecture option then we must be Non-secure.
        return FALSE;
    else
        // TRUE if processor is Secure or FALSE if Non-secure.
        return boolean IMPLEMENTATION_DEFINED "Secure-only implementation";</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsSecureEL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsSecureEL2Enabled</h3>
      <p class="pseudocode">// IsSecureEL2Enabled()
// ====================
// Returns TRUE if Secure EL2 is enabled, FALSE otherwise.

boolean <a id="impl-shared.IsSecureEL2Enabled.0"/>IsSecureEL2Enabled()
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EEL2 == '1' then
                return TRUE;
            else
                return FALSE;
        else
            return <a href="shared_pseudocode.html#impl-shared.SecureOnlyImplementation.0" title="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</a>();
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.LocalTimeoutEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/LocalTimeoutEvent</h3>
      <p class="pseudocode">// Returns TRUE if CNTVCT_EL0 equals or exceeds the localtimeout value.
boolean <a id="impl-shared.LocalTimeoutEvent.1"/>LocalTimeoutEvent(integer localtimeout);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Mode_Bits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Mode_Bits</h3>
      <p class="pseudocode">constant bits(5) <a id="M32_User"/>M32_User    = '10000';
constant bits(5) <a id="M32_FIQ"/>M32_FIQ     = '10001';
constant bits(5) <a id="M32_IRQ"/>M32_IRQ     = '10010';
constant bits(5) <a id="M32_Svc"/>M32_Svc     = '10011';
constant bits(5) <a id="M32_Monitor"/>M32_Monitor = '10110';
constant bits(5) <a id="M32_Abort"/>M32_Abort   = '10111';
constant bits(5) <a id="M32_Hyp"/>M32_Hyp     = '11010';
constant bits(5) <a id="M32_Undef"/>M32_Undef   = '11011';
constant bits(5) <a id="M32_System"/>M32_System  = '11111';</p>
    </div>
    <div class="ps"><a id="shared.functions.system.NonSecureOnlyImplementation"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/NonSecureOnlyImplementation</h3>
      <p class="pseudocode">// NonSecureOnlyImplementation()
// =============================
// Returns TRUE if the security state is always Non-secure for this implementation.

boolean <a id="impl-shared.NonSecureOnlyImplementation.0"/>NonSecureOnlyImplementation()
    return boolean IMPLEMENTATION_DEFINED "Non-secure only implementation";</p>
    </div>
    <div class="ps"><a id="shared.functions.system.PLOfEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/PLOfEL</h3>
      <p class="pseudocode">// PLOfEL()
// ========

PrivilegeLevel <a id="impl-shared.PLOfEL.1"/>PLOfEL(bits(2) el)
    case el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  return if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then <a href="shared_pseudocode.html#PL1" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL1</a> else <a href="shared_pseudocode.html#PL3" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL3</a>;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  return <a href="shared_pseudocode.html#PL2" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL2</a>;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  return <a href="shared_pseudocode.html#PL1" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL1</a>;
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  return <a href="shared_pseudocode.html#PL0" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL0</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.PSTATE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/PSTATE</h3>
      <p class="pseudocode"><a href="shared_pseudocode.html#ProcState" title="type ProcState is ( bits (1) N, bits (1) Z, bits (1) C, bits (1) V, bits (1) D, bits (1) A, bits (1) I, bits (1) F, bits (1) PAN, bits (1) UAO, bits (1) DIT, bits (1) TCO, bits (1) PM, bits (1) PPEND, bits (2) BTYPE, bits (1) ZA, bits (1) SM, bits (1) ALLINT, bits (1) SS, bits (1) IL, bits (2) EL, bits (1) nRW, bits (1) SP, bits (1) Q, bits (4) GE, bits (1) SSBS, bits (8) IT, bits (1) J, bits (1) T, bits (1) E, bits (5) M )">ProcState</a> PSTATE;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.PhysicalCountInt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/PhysicalCountInt</h3>
      <p class="pseudocode">// PhysicalCountInt()
// ==================
// Returns the integral part of physical count value of the System counter.

bits(64) <a id="impl-shared.PhysicalCountInt.0"/>PhysicalCountInt()
    return PhysicalCount&lt;87:24&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.PrivilegeLevel"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/PrivilegeLevel</h3>
      <p class="pseudocode">enumeration <a id="PrivilegeLevel"/>PrivilegeLevel {<a id="PL3"/>PL3, <a id="PL2"/>PL2, <a id="PL1"/>PL1, <a id="PL0"/>PL0};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ProcState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ProcState</h3>
      <p class="pseudocode">type <a id="ProcState"/>ProcState is (
    bits (1) N,        // Negative condition flag
    bits (1) Z,        // Zero condition flag
    bits (1) C,        // Carry condition flag
    bits (1) V,        // Overflow condition flag
    bits (1) D,        // Debug mask bit                     [AArch64 only]
    bits (1) A,        // SError interrupt mask bit
    bits (1) I,        // IRQ mask bit
    bits (1) F,        // FIQ mask bit
    bits (1) PAN,      // Privileged Access Never Bit        [v8.1]
    bits (1) UAO,      // User Access Override               [v8.2]
    bits (1) DIT,      // Data Independent Timing            [v8.4]
    bits (1) TCO,      // Tag Check Override                 [v8.5, AArch64 only]
    bits (1) PM,       // PMU exception Mask
    bits (1) PPEND,     // synchronous PMU exception to be observed
    bits (2) BTYPE,    // Branch Type                        [v8.5]
    bits (1) ZA,       // Accumulation array enabled         [SME]
    bits (1) SM,       // Streaming SVE mode enabled         [SME]
    bits (1) ALLINT,   // Interrupt mask bit
    bits (1) SS,       // Software step bit
    bits (1) IL,       // Illegal Execution state bit
    bits (2) EL,       // Exception level
    bits (1) nRW,      // Execution state: 0=AArch64, 1=AArch32
    bits (1) SP,       // Stack pointer select: 0=SP0, 1=SPx [AArch64 only]
    bits (1) Q,        // Cumulative saturation flag         [AArch32 only]
    bits (4) GE,       // Greater than or Equal flags        [AArch32 only]
    bits (1) SSBS,     // Speculative Store Bypass Safe
    bits (8) IT,       // If-then bits, RES0 in CPSR         [AArch32 only]
    bits (1) J,        // J bit, RES0                        [AArch32 only, RES0 in SPSR and CPSR]
    bits (1) T,        // T32 bit, RES0 in CPSR              [AArch32 only]
    bits (1) E,        // Endianness bit                     [AArch32 only]
    bits (5) M         // Mode field                         [AArch32 only]
)</p>
    </div>
    <div class="ps"><a id="shared.functions.system.RestoredITBits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/RestoredITBits</h3>
      <p class="pseudocode">// RestoredITBits()
// ================
// Get the value of PSTATE.IT to be restored on this exception return.

bits(8) <a id="impl-shared.RestoredITBits.1"/>RestoredITBits(bits(N) spsr)
    it = spsr&lt;15:10,26:25&gt;;

    // When PSTATE.IL is set, it is CONSTRAINED UNPREDICTABLE whether the IT bits are each set
    // to zero or copied from the SPSR.
    if PSTATE.IL == '1' then
        if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ILZEROIT" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_ILZEROIT</a>) then return '00000000';
        else return it;

    // The IT bits are forced to zero when they are set to a reserved value.
    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(it&lt;7:4&gt;) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(it&lt;3:0&gt;) then
        return '00000000';

    // The IT bits are forced to zero when returning to A32 state, or when returning to an EL
    // with the ITD bit set to 1, and the IT bits are describing a multi-instruction block.
    itd = if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then HSCTLR.ITD else SCTLR.ITD;
    if (spsr&lt;5&gt; == '0' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(it)) || (itd == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(it&lt;2:0&gt;)) then
        return '00000000';
    else
        return it;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SCRType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SCRType</h3>
      <p class="pseudocode">type <a id="SCRType"/>SCRType;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SCR_GEN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SCR_GEN</h3>
      <p class="pseudocode">// SCR_GEN[]
// =========

SCRType <a id="impl-shared.SCR_GEN.read.0"/>SCR_GEN[]
    // AArch32 secure &amp; AArch64 EL3 registers are not architecturally mapped
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    bits(64) r;
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        r = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(SCR, 64);
    else
        r = SCR_EL3;
    return r;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SecureOnlyImplementation"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SecureOnlyImplementation</h3>
      <p class="pseudocode">// SecureOnlyImplementation()
// ==========================
// Returns TRUE if the security state is always Secure for this implementation.

boolean <a id="impl-shared.SecureOnlyImplementation.0"/>SecureOnlyImplementation()
    return boolean IMPLEMENTATION_DEFINED "Secure-only implementation";</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SecurityState</h3>
      <p class="pseudocode">enumeration <a id="SecurityState"/>SecurityState {
    <a id="SS_NonSecure"/>SS_NonSecure,
    <a id="SS_Root"/>SS_Root,
    <a id="SS_Realm"/>SS_Realm,
    <a id="SS_Secure"/>SS_Secure
};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SecurityStateAtEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SecurityStateAtEL</h3>
      <p class="pseudocode">// SecurityStateAtEL()
// ===================
// Returns the effective security state at the exception level based off current settings.

SecurityState <a id="impl-shared.SecurityStateAtEL.1"/>SecurityStateAtEL(bits(2) EL)
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        if EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then return <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>;
        case SCR_EL3.&lt;NSE, NS&gt; of
            when '00' return <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
            when '01' return <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
            when '11' return <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>;
            otherwise        <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if <a href="shared_pseudocode.html#impl-shared.SecureOnlyImplementation.0" title="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</a>() then
            return <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
        else
            return <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    elsif EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        return <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
    else
        // For EL2 call only when EL2 is enabled in current security state
        assert(EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>());
        if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            return if SCR_EL3.NS == '1' then <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> else <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
        else
            return if SCR.NS == '1' then <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> else <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SendEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SendEvent</h3>
      <p class="pseudocode">// Signal an event to all PEs in a multiprocessor system to set their Event Registers.
// When a PE executes the SEV instruction, it causes this function to be executed.
<a id="impl-shared.SendEvent.0"/>SendEvent();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SendEventLocal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SendEventLocal</h3>
      <p class="pseudocode">// SendEventLocal()
// ================
// Set the local Event Register of this PE.
// When a PE executes the SEVL instruction, it causes this function to be executed.

<a id="impl-shared.SendEventLocal.0"/>SendEventLocal()
    EventRegister = '1';
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SetAccumulatedFPExceptions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SetAccumulatedFPExceptions</h3>
      <p class="pseudocode">// Stores FP Exceptions accumulated by the PE.
<a id="impl-shared.SetAccumulatedFPExceptions.1"/>SetAccumulatedFPExceptions(bits(8) accumulated_exceptions);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SetPSTATEFromPSR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SetPSTATEFromPSR</h3>
      <p class="pseudocode">// SetPSTATEFromPSR()
// ==================

<a id="impl-shared.SetPSTATEFromPSR.1"/>SetPSTATEFromPSR(bits(N) spsr)
    boolean illegal_psr_state = <a href="shared_pseudocode.html#impl-shared.IllegalExceptionReturn.1" title="function: boolean IllegalExceptionReturn(bits(N) spsr)">IllegalExceptionReturn</a>(spsr);
    <a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.2" title="function: SetPSTATEFromPSR(bits(N) spsr_in, boolean illegal_psr_state)">SetPSTATEFromPSR</a>(spsr, illegal_psr_state);

// SetPSTATEFromPSR()
// ==================
// Set PSTATE based on a PSR value

<a id="impl-shared.SetPSTATEFromPSR.2"/>SetPSTATEFromPSR(bits(N) spsr_in, boolean illegal_psr_state)
    bits(N) spsr = spsr_in;
    boolean from_aarch64 = !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    PSTATE.SS = <a href="shared_pseudocode.html#impl-shared.DebugExceptionReturnSS.1" title="function: bit DebugExceptionReturnSS(bits(N) spsr)">DebugExceptionReturnSS</a>(spsr);

    ShouldAdvanceSS = FALSE;
    if illegal_psr_state then
        PSTATE.IL = '1';
        if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then PSTATE.BTYPE = bits(2) UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = bit UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()">HaveDITExt</a>() then PSTATE.DIT = bit UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = bit UNKNOWN;
    else
        // State that is reinstated only on a legal exception return
        PSTATE.IL = spsr&lt;20&gt;;
        if spsr&lt;4&gt; == '1' then                    // AArch32 state
            <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(spsr&lt;4:0&gt;);         // Sets PSTATE.EL correctly
            if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = spsr&lt;23&gt;;
        else                                      // AArch64 state
            PSTATE.nRW = '0';
            PSTATE.EL  = spsr&lt;3:2&gt;;
            PSTATE.SP  = spsr&lt;0&gt;;
            if <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then PSTATE.BTYPE = spsr&lt;11:10&gt;;
            if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = spsr&lt;12&gt;;
            if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = spsr&lt;23&gt;;
            if <a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()">HaveDITExt</a>() then PSTATE.DIT = spsr&lt;24&gt;;
            if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = spsr&lt;25&gt;;

    // If PSTATE.IL is set, it is CONSTRAINED UNPREDICTABLE whether the T bit is set to zero or
    // copied from SPSR.
    if PSTATE.IL == '1' &amp;&amp; PSTATE.nRW == '1' then
        if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ILZEROT" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_ILZEROT</a>) then spsr&lt;5&gt; = '0';

    // State that is reinstated regardless of illegal exception return
    PSTATE.&lt;N,Z,C,V&gt; = spsr&lt;31:28&gt;;
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() then PSTATE.PAN = spsr&lt;22&gt;;
    if PSTATE.nRW == '1' then                     // AArch32 state
        PSTATE.Q         = spsr&lt;27&gt;;
        PSTATE.IT        = <a href="shared_pseudocode.html#impl-shared.RestoredITBits.1" title="function: bits(8) RestoredITBits(bits(N) spsr)">RestoredITBits</a>(spsr);
        ShouldAdvanceIT  = FALSE;
        if <a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()">HaveDITExt</a>() then
            PSTATE.DIT = (if (<a href="shared_pseudocode.html#impl-shared.Restarting.0" title="function: boolean Restarting()">Restarting</a>() || from_aarch64) then spsr&lt;24&gt; else spsr&lt;21&gt;);
        PSTATE.GE        = spsr&lt;19:16&gt;;
        PSTATE.E         = spsr&lt;9&gt;;
        PSTATE.&lt;A,I,F&gt;   = spsr&lt;8:6&gt;;             // No PSTATE.D in AArch32 state
        PSTATE.T         = spsr&lt;5&gt;;               // PSTATE.J is RES0
    else                                          // AArch64 state
        if <a href="shared_pseudocode.html#impl-shared.HaveFeatNMI.0" title="function: boolean HaveFeatNMI()">HaveFeatNMI</a>() then PSTATE.ALLINT = spsr&lt;13&gt;;
        PSTATE.&lt;D,A,I,F&gt; = spsr&lt;9:6&gt;;             // No PSTATE.&lt;Q,IT,GE,E,T&gt; in AArch64 state
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ShouldAdvanceIT"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ShouldAdvanceIT</h3>
      <p class="pseudocode">boolean ShouldAdvanceIT;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ShouldAdvanceSS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ShouldAdvanceSS</h3>
      <p class="pseudocode">boolean ShouldAdvanceSS;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SpeculationBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SpeculationBarrier</h3>
      <p class="pseudocode"><a id="impl-shared.SpeculationBarrier.0"/>SpeculationBarrier();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SynchronizeContext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SynchronizeContext</h3>
      <p class="pseudocode"><a id="impl-shared.SynchronizeContext.0"/>SynchronizeContext();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SynchronizeErrors"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SynchronizeErrors</h3>
      <p class="pseudocode">// Implements the error synchronization event.
<a id="impl-shared.SynchronizeErrors.0"/>SynchronizeErrors();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.TakeUnmaskedPhysicalSErrorInterrupts"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/TakeUnmaskedPhysicalSErrorInterrupts</h3>
      <p class="pseudocode">// Take any pending unmasked physical SError interrupt.
<a id="impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1"/>TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.TakeUnmaskedSErrorInterrupts"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/TakeUnmaskedSErrorInterrupts</h3>
      <p class="pseudocode">// Take any pending unmasked physical SError interrupt or unmasked virtual SError
// interrupt.
<a id="impl-shared.TakeUnmaskedSErrorInterrupts.0"/>TakeUnmaskedSErrorInterrupts();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ThisInstr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ThisInstr</h3>
      <p class="pseudocode">bits(32) <a id="impl-shared.ThisInstr.0"/>ThisInstr();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ThisInstrLength"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ThisInstrLength</h3>
      <p class="pseudocode">integer <a id="impl-shared.ThisInstrLength.0"/>ThisInstrLength();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Unreachable"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Unreachable</h3>
      <p class="pseudocode"><a id="impl-shared.Unreachable.0"/>Unreachable()
    assert FALSE;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.UsingAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/UsingAArch32</h3>
      <p class="pseudocode">// UsingAArch32()
// ==============
// Return TRUE if the current Exception level is using AArch32, FALSE if using AArch64.

boolean <a id="impl-shared.UsingAArch32.0"/>UsingAArch32()
    boolean aarch32 = (PSTATE.nRW == '1');
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() then assert !aarch32;
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then assert aarch32;
    return aarch32;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ValidSecurityStateAtEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ValidSecurityStateAtEL</h3>
      <p class="pseudocode">// ValidSecurityStateAtEL()
// ========================
// Returns TRUE if the current settings and architecture choices for this
// implementation permit a valid Security state at the indicated EL.

boolean <a id="impl-shared.ValidSecurityStateAtEL.1"/>ValidSecurityStateAtEL(bits(2) el)
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el) then
        return FALSE;

    if el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        return TRUE;

    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        if SCR_EL3.&lt;NSE,NS&gt; == '10' then
            return FALSE;

    if el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        return <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    return TRUE;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.VirtualFIQPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/VirtualFIQPending</h3>
      <p class="pseudocode">// Returns TRUE if there is any pending virtual FIQ.
boolean <a id="impl-shared.VirtualFIQPending.0"/>VirtualFIQPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.VirtualIRQPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/VirtualIRQPending</h3>
      <p class="pseudocode">// Returns TRUE if there is any pending virtual IRQ.
boolean <a id="impl-shared.VirtualIRQPending.0"/>VirtualIRQPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.WFxType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/WFxType</h3>
      <p class="pseudocode">enumeration <a id="WFxType"/>WFxType {<a id="WFxType_WFE"/>WFxType_WFE, <a id="WFxType_WFI"/>WFxType_WFI, <a id="WFxType_WFET"/>WFxType_WFET, <a id="WFxType_WFIT"/>WFxType_WFIT};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.WaitForEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/WaitForEvent</h3>
      <p class="pseudocode">// WaitForEvent()
// ==============
// PE optionally suspends execution until one of the following occurs:
// - A WFE wakeup event.
// - A reset.
// - The implementation chooses to resume execution.
// - A Wait for Event with Timeout (WFET) is executing, and a local timeout event occurs
// It is IMPLEMENTATION DEFINED whether restarting execution after the period of
// suspension causes the Event Register to be cleared.

<a id="impl-shared.WaitForEvent.1"/>WaitForEvent(integer localtimeout)
    if !(<a href="shared_pseudocode.html#impl-shared.IsEventRegisterSet.0" title="function: boolean IsEventRegisterSet()">IsEventRegisterSet</a>() || (<a href="shared_pseudocode.html#impl-shared.HaveFeatWFxT.0" title="function: boolean HaveFeatWFxT()">HaveFeatWFxT</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.LocalTimeoutEvent.1" title="function: boolean LocalTimeoutEvent(integer localtimeout)">LocalTimeoutEvent</a>(localtimeout))) then
        <a href="shared_pseudocode.html#impl-shared.EnterLowPowerState.0" title="function: EnterLowPowerState()">EnterLowPowerState</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.WaitForInterrupt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/WaitForInterrupt</h3>
      <p class="pseudocode">// WaitForInterrupt()
// ==================
// PE optionally suspends execution until one of the following occurs:
// - A WFI wakeup event.
// - A reset.
// - The implementation chooses to resume execution.
// - A Wait for Interrupt with Timeout (WFIT) is executing, and a local timeout event occurs.

<a id="impl-shared.WaitForInterrupt.1"/>WaitForInterrupt(integer localtimeout)
    if !(<a href="shared_pseudocode.html#impl-shared.HaveFeatWFxT.0" title="function: boolean HaveFeatWFxT()">HaveFeatWFxT</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.LocalTimeoutEvent.1" title="function: boolean LocalTimeoutEvent(integer localtimeout)">LocalTimeoutEvent</a>(localtimeout)) then
        <a href="shared_pseudocode.html#impl-shared.EnterLowPowerState.0" title="function: EnterLowPowerState()">EnterLowPowerState</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictable"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictable</h3>
      <p class="pseudocode">// Return the appropriate Constraint result to control the caller's behavior.
// The return value is IMPLEMENTATION DEFINED within a permitted list for each
// UNPREDICTABLE case.
// (The permitted list is determined by an assert or case statement at the call site.)
Constraint <a id="impl-shared.ConstrainUnpredictable.1"/>ConstrainUnpredictable(<a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable</a> which);</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictableBits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictableBits</h3>
      <p class="pseudocode">// This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN.
// If the result is Constraint_UNKNOWN then the function also returns UNKNOWN value, but that
// value is always an allocated value; that is, one for which the behavior is not itself
// CONSTRAINED.
(Constraint,bits(width)) <a id="impl-shared.ConstrainUnpredictableBits.2"/>ConstrainUnpredictableBits(<a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable</a> which, integer width);</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictableBool"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictableBool</h3>
      <p class="pseudocode">// This is a variant of the ConstrainUnpredictable function where the result is either
// Constraint_TRUE or Constraint_FALSE.
boolean <a id="impl-shared.ConstrainUnpredictableBool.1"/>ConstrainUnpredictableBool(<a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable</a> which);</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictableInteger"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictableInteger</h3>
      <p class="pseudocode">// This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN.
// If the result is Constraint_UNKNOWN then the function also returns an UNKNOWN
// value in the range low to high, inclusive.
(Constraint,integer) <a id="impl-shared.ConstrainUnpredictableInteger.3"/>ConstrainUnpredictableInteger(integer low, integer high,
                                                   <a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable</a> which);</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictableProcedure"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictableProcedure</h3>
      <p class="pseudocode">// This is a variant of ConstrainUnpredictable that implements a Constrained
// Unpredictable behavior for a given Unpredictable situation.
// The behavior is within permitted behaviors for a given Unpredictable situation,
// these are documented in the textual part of the architecture specification.
//
// This function is expected to be refined in an IMPLEMENTATION DEFINED manner.
// The details of possible outcomes may not be present in the code and must be interpreted
// for each use with respect to the CONSTRAINED UNPREDICTABLE specifications
// for the specific area.
<a id="impl-shared.ConstrainUnpredictableProcedure.1"/>ConstrainUnpredictableProcedure(<a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable</a> which);</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.Constraint"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/Constraint</h3>
      <p class="pseudocode">enumeration <a id="Constraint"/>Constraint    {// General
                           <a id="Constraint_NONE"/>Constraint_NONE,              // Instruction executes with
                                                         // no change or side-effect
                                                         // to its described behavior
                           <a id="Constraint_UNKNOWN"/>Constraint_UNKNOWN,           // Destination register
                                                         // has UNKNOWN value
                           <a id="Constraint_UNDEF"/>Constraint_UNDEF,             // Instruction is UNDEFINED
                           <a id="Constraint_UNDEFEL0"/>Constraint_UNDEFEL0,          // Instruction is UNDEFINED at EL0 only
                           <a id="Constraint_NOP"/>Constraint_NOP,               // Instruction executes as NOP
                           <a id="Constraint_TRUE"/>Constraint_TRUE,
                           <a id="Constraint_FALSE"/>Constraint_FALSE,
                           <a id="Constraint_DISABLED"/>Constraint_DISABLED,
                           <a id="Constraint_UNCOND"/>Constraint_UNCOND,            // Instruction executes unconditionally
                           <a id="Constraint_COND"/>Constraint_COND,              // Instruction executes conditionally
                           <a id="Constraint_ADDITIONAL_DECODE"/>Constraint_ADDITIONAL_DECODE, // Instruction executes
                                                         // with additional decode
                           // Load-store
                           <a id="Constraint_WBSUPPRESS"/>Constraint_WBSUPPRESS,
                           <a id="Constraint_FAULT"/>Constraint_FAULT,
                           <a id="Constraint_LIMITED_ATOMICITY"/>Constraint_LIMITED_ATOMICITY, // Accesses are not
                                                         // single-copy atomic
                                                         // above the byte level
                           <a id="Constraint_NVNV1_00"/>Constraint_NVNV1_00,
                           <a id="Constraint_NVNV1_01"/>Constraint_NVNV1_01,
                           <a id="Constraint_NVNV1_11"/>Constraint_NVNV1_11,
                           <a id="Constraint_EL1TIMESTAMP"/>Constraint_EL1TIMESTAMP,      // Constrain to Virtual Timestamp
                           <a id="Constraint_EL2TIMESTAMP"/>Constraint_EL2TIMESTAMP,      // Constrain to Virtual Timestamp
                           <a id="Constraint_OSH"/>Constraint_OSH,               // Constrain to Outer Shareable
                           <a id="Constraint_ISH"/>Constraint_ISH,               // Constrain to Inner Shareable
                           <a id="Constraint_NSH"/>Constraint_NSH,               // Constrain to Nonshareable

                           <a id="Constraint_NC"/>Constraint_NC,                // Constrain to Noncacheable
                           <a id="Constraint_WT"/>Constraint_WT,                // Constrain to Writethrough
                           <a id="Constraint_WB"/>Constraint_WB,                // Constrain to Writeback

                           // IPA too large
                           <a id="Constraint_FORCE"/>Constraint_FORCE, <a id="Constraint_FORCENOSLCHECK"/>Constraint_FORCENOSLCHECK,
                           // PMSCR_PCT reserved values select Virtual timestamp
                           <a id="Constraint_PMSCR_PCT_VIRT"/>Constraint_PMSCR_PCT_VIRT};</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.Unpredictable"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/Unpredictable</h3>
      <p class="pseudocode">enumeration <a id="Unpredictable"/>Unpredictable {
                           // VMSR on MVFR
                           <a id="Unpredictable_VMSR"/>Unpredictable_VMSR,
                           // Writeback/transfer register overlap (load)
                           <a id="Unpredictable_WBOVERLAPLD"/>Unpredictable_WBOVERLAPLD,
                           // Writeback/transfer register overlap (store)
                           <a id="Unpredictable_WBOVERLAPST"/>Unpredictable_WBOVERLAPST,
                           // Load Pair transfer register overlap
                           <a id="Unpredictable_LDPOVERLAP"/>Unpredictable_LDPOVERLAP,
                           // Store-exclusive base/status register overlap
                           <a id="Unpredictable_BASEOVERLAP"/>Unpredictable_BASEOVERLAP,
                           // Store-exclusive data/status register overlap
                           <a id="Unpredictable_DATAOVERLAP"/>Unpredictable_DATAOVERLAP,
                           // Load-store alignment checks
                           <a id="Unpredictable_DEVPAGE2"/>Unpredictable_DEVPAGE2,
                           // Instruction fetch from Device memory
                           <a id="Unpredictable_INSTRDEVICE"/>Unpredictable_INSTRDEVICE,
                           // Reserved CPACR value
                           <a id="Unpredictable_RESCPACR"/>Unpredictable_RESCPACR,
                           // Reserved MAIR value
                           <a id="Unpredictable_RESMAIR"/>Unpredictable_RESMAIR,
                           // Effect of SCTLR_ELx.C on Tagged attribute
                           <a id="Unpredictable_S1CTAGGED"/>Unpredictable_S1CTAGGED,
                           // Reserved Stage 2 MemAttr value
                           <a id="Unpredictable_S2RESMEMATTR"/>Unpredictable_S2RESMEMATTR,
                           // Reserved TEX:C:B value
                           <a id="Unpredictable_RESTEXCB"/>Unpredictable_RESTEXCB,
                           // Reserved PRRR value
                           <a id="Unpredictable_RESPRRR"/>Unpredictable_RESPRRR,
                           // Reserved DACR field
                           <a id="Unpredictable_RESDACR"/>Unpredictable_RESDACR,
                           // Reserved VTCR.S value
                           <a id="Unpredictable_RESVTCRS"/>Unpredictable_RESVTCRS,
                           // Reserved TCR.TnSZ value
                           <a id="Unpredictable_RESTnSZ"/>Unpredictable_RESTnSZ,
                           // Reserved SCTLR_ELx.TCF value
                           <a id="Unpredictable_RESTCF"/>Unpredictable_RESTCF,
                           // Tag stored to Device memory
                           <a id="Unpredictable_DEVICETAGSTORE"/>Unpredictable_DEVICETAGSTORE,
                           // Out-of-range TCR.TnSZ value
                           <a id="Unpredictable_OORTnSZ"/>Unpredictable_OORTnSZ,
                           // IPA size exceeds PA size
                           <a id="Unpredictable_LARGEIPA"/>Unpredictable_LARGEIPA,
                           // Syndrome for a known-passing conditional A32 instruction
                           <a id="Unpredictable_ESRCONDPASS"/>Unpredictable_ESRCONDPASS,
                           // Illegal State exception: zero PSTATE.IT
                           <a id="Unpredictable_ILZEROIT"/>Unpredictable_ILZEROIT,
                           // Illegal State exception: zero PSTATE.T
                           <a id="Unpredictable_ILZEROT"/>Unpredictable_ILZEROT,
                           // Debug: prioritization of Vector Catch
                           <a id="Unpredictable_BPVECTORCATCHPRI"/>Unpredictable_BPVECTORCATCHPRI,
                           // Debug Vector Catch: match on 2nd halfword
                           <a id="Unpredictable_VCMATCHHALF"/>Unpredictable_VCMATCHHALF,
                           // Debug Vector Catch: match on Data Abort
                           // or Prefetch abort
                           <a id="Unpredictable_VCMATCHDAPA"/>Unpredictable_VCMATCHDAPA,
                           // Debug watchpoints: non-zero MASK and non-ones BAS
                           <a id="Unpredictable_WPMASKANDBAS"/>Unpredictable_WPMASKANDBAS,
                           // Debug watchpoints: non-contiguous BAS
                           <a id="Unpredictable_WPBASCONTIGUOUS"/>Unpredictable_WPBASCONTIGUOUS,
                           // Debug watchpoints: reserved MASK
                           <a id="Unpredictable_RESWPMASK"/>Unpredictable_RESWPMASK,
                           // Debug watchpoints: non-zero MASKed bits of address
                           <a id="Unpredictable_WPMASKEDBITS"/>Unpredictable_WPMASKEDBITS,
                           // Debug breakpoints and watchpoints: reserved control bits
                           <a id="Unpredictable_RESBPWPCTRL"/>Unpredictable_RESBPWPCTRL,
                           // Debug breakpoints: not implemented
                           <a id="Unpredictable_BPNOTIMPL"/>Unpredictable_BPNOTIMPL,
                           // Debug breakpoints: reserved type
                           <a id="Unpredictable_RESBPTYPE"/>Unpredictable_RESBPTYPE,
                           // Debug breakpoints: not-context-aware breakpoint
                           <a id="Unpredictable_BPNOTCTXCMP"/>Unpredictable_BPNOTCTXCMP,
                           // Debug breakpoints: match on 2nd halfword of instruction
                           <a id="Unpredictable_BPMATCHHALF"/>Unpredictable_BPMATCHHALF,
                           // Debug breakpoints: mismatch on 2nd halfword of instruction
                           <a id="Unpredictable_BPMISMATCHHALF"/>Unpredictable_BPMISMATCHHALF,
                           // Debug: restart to a misaligned AArch32 PC value
                           <a id="Unpredictable_RESTARTALIGNPC"/>Unpredictable_RESTARTALIGNPC,
                           // Debug: restart to a not-zero-extended AArch32 PC value
                           <a id="Unpredictable_RESTARTZEROUPPERPC"/>Unpredictable_RESTARTZEROUPPERPC,
                           // Zero top 32 bits of X registers in AArch32 state
                           <a id="Unpredictable_ZEROUPPER"/>Unpredictable_ZEROUPPER,
                           // Zero top 32 bits of PC on illegal return to
                           // AArch32 state
                           <a id="Unpredictable_ERETZEROUPPERPC"/>Unpredictable_ERETZEROUPPERPC,
                           // Force address to be aligned when interworking
                           // branch to A32 state
                           <a id="Unpredictable_A32FORCEALIGNPC"/>Unpredictable_A32FORCEALIGNPC,
                           // SMC disabled
                           <a id="Unpredictable_SMD"/>Unpredictable_SMD,
                           // FF speculation
                           <a id="Unpredictable_NONFAULT"/>Unpredictable_NONFAULT,
                           // Zero top bits of Z registers in EL change
                           <a id="Unpredictable_SVEZEROUPPER"/>Unpredictable_SVEZEROUPPER,
                           // Load mem data in NF loads
                           <a id="Unpredictable_SVELDNFDATA"/>Unpredictable_SVELDNFDATA,
                           // Write zeros in NF loads
                           <a id="Unpredictable_SVELDNFZERO"/>Unpredictable_SVELDNFZERO,
                           // SP alignment fault when predicate is all zero
                           <a id="Unpredictable_CHECKSPNONEACTIVE"/>Unpredictable_CHECKSPNONEACTIVE,
                           // Zero top bits of ZA registers in EL change
                           <a id="Unpredictable_SMEZEROUPPER"/>Unpredictable_SMEZEROUPPER,
                           // HCR_EL2.&lt;NV,NV1&gt; == '01'
                           <a id="Unpredictable_NVNV1"/>Unpredictable_NVNV1,
                           // Reserved shareability encoding
                           <a id="Unpredictable_Shareability"/>Unpredictable_Shareability,
                           // Access Flag Update by HW
                           <a id="Unpredictable_AFUPDATE"/>Unpredictable_AFUPDATE,
                           // Dirty Bit State Update by HW
                           <a id="Unpredictable_DBUPDATE"/>Unpredictable_DBUPDATE,
                           // Consider SCTLR[].IESB in Debug state
                           <a id="Unpredictable_IESBinDebug"/>Unpredictable_IESBinDebug,
                           // Bad settings for PMSFCR_EL1/PMSEVFR_EL1/PMSLATFR_EL1
                           <a id="Unpredictable_BADPMSFCR"/>Unpredictable_BADPMSFCR,
                           // Zero saved BType value in SPSR_ELx/DPSR_EL0
                           <a id="Unpredictable_ZEROBTYPE"/>Unpredictable_ZEROBTYPE,
                           // Timestamp constrained to virtual or physical
                           <a id="Unpredictable_EL2TIMESTAMP"/>Unpredictable_EL2TIMESTAMP,
                           <a id="Unpredictable_EL1TIMESTAMP"/>Unpredictable_EL1TIMESTAMP,
                            // Reserved MDCR_EL3.&lt;NSTBE,NSTB&gt; or MDCR_EL3.&lt;NSPBE,NSPB&gt; value
                            <a id="Unpredictable_RESERVEDNSxB"/>Unpredictable_RESERVEDNSxB,
                           // WFET or WFIT instruction in Debug state
                           <a id="Unpredictable_WFxTDEBUG"/>Unpredictable_WFxTDEBUG,
                           // Address does not support LS64 instructions
                           <a id="Unpredictable_LS64UNSUPPORTED"/>Unpredictable_LS64UNSUPPORTED,
                           // Misaligned exclusives, atomics, acquire/release
                           // to region that is not Normal Cacheable WB
                           <a id="Unpredictable_MISALIGNEDATOMIC"/>Unpredictable_MISALIGNEDATOMIC,
                           // Clearing DCC/ITR sticky flags when instruction is in flight
                           <a id="Unpredictable_CLEARERRITEZERO"/>Unpredictable_CLEARERRITEZERO,
                           // ALUEXCEPTIONRETURN when in user/system mode in
                           // A32 instructions
                           <a id="Unpredictable_ALUEXCEPTIONRETURN"/>Unpredictable_ALUEXCEPTIONRETURN,
                           // Trap to register in debug state are ignored
                           <a id="Unpredictable_IGNORETRAPINDEBUG"/>Unpredictable_IGNORETRAPINDEBUG,
                           // Compare DBGBVR.RESS for BP/WP
                           <a id="Unpredictable_DBGxVR_RESS"/>Unpredictable_DBGxVR_RESS,
                           // Inaccessible event counter
                           <a id="Unpredictable_PMUEVENTCOUNTER"/>Unpredictable_PMUEVENTCOUNTER,
                           // Reserved PMSCR.PCT behavior.
                           <a id="Unpredictable_PMSCR_PCT"/>Unpredictable_PMSCR_PCT,
                           // Generate BRB_FILTRATE event on BRB injection
                           <a id="Unpredictable_BRBFILTRATE"/>Unpredictable_BRBFILTRATE,
                          // Operands for CPY*/SET* instructions overlap or
                          // use 0b11111 as a register specifier
                          <a id="Unpredictable_MOPSOVERLAP31"/>Unpredictable_MOPSOVERLAP31,
                          // Store-only Tag checking on a failed Atomic Compare and Swap
                          <a id="Unpredictable_STOREONLYTAGCHECKEDCAS"/>Unpredictable_STOREONLYTAGCHECKEDCAS
};</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.AdvSIMDExpandImm"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/AdvSIMDExpandImm</h3>
      <p class="pseudocode">// AdvSIMDExpandImm()
// ==================

bits(64) <a id="impl-shared.AdvSIMDExpandImm.3"/>AdvSIMDExpandImm(bit op, bits(4) cmode, bits(8) imm8)
    bits(64) imm64;
    case cmode&lt;3:1&gt; of
        when '000'
            imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24):imm8, 2);
        when '001'
            imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16):imm8:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8), 2);
        when '010'
            imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8):imm8:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16), 2);
        when '011'
            imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24), 2);
        when '100'
            imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8):imm8, 4);
        when '101'
            imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8), 4);
        when '110'
            if cmode&lt;0&gt; == '0' then
                imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16):imm8:<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(8), 2);
            else
                imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8):imm8:<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(16), 2);
        when '111'
            if cmode&lt;0&gt; == '0' &amp;&amp; op == '0' then
                imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8, 8);
            if cmode&lt;0&gt; == '0' &amp;&amp; op == '1' then
                imm8a = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;7&gt;, 8); imm8b = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;6&gt;, 8);
                imm8c = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;5&gt;, 8); imm8d = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;4&gt;, 8);
                imm8e = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;3&gt;, 8); imm8f = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;2&gt;, 8);
                imm8g = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;1&gt;, 8); imm8h = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;0&gt;, 8);
                imm64 = imm8a:imm8b:imm8c:imm8d:imm8e:imm8f:imm8g:imm8h;
            if cmode&lt;0&gt; == '1' &amp;&amp; op == '0' then
                imm32 = imm8&lt;7&gt;:NOT(imm8&lt;6&gt;):<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;6&gt;,5):imm8&lt;5:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(19);
                imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm32, 2);
            if cmode&lt;0&gt; == '1' &amp;&amp; op == '1' then
                if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then ReservedEncoding();
                imm64 = imm8&lt;7&gt;:NOT(imm8&lt;6&gt;):<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;6&gt;,8):imm8&lt;5:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(48);

    return imm64;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.MatMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/MatMulAdd</h3>
      <p class="pseudocode">// MatMulAdd()
// ===========
//
// Signed or unsigned 8-bit integer matrix multiply and add to 32-bit integer matrix
// result[2, 2] = addend[2, 2] + (op1[2, 8] * op2[8, 2])

bits(N) <a id="impl-shared.MatMulAdd.5"/>MatMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, boolean op1_unsigned, boolean op2_unsigned)
    assert N == 128;

    bits(N)  result;
    bits(32) sum;
    integer  prod;

    for i = 0 to 1
        for j = 0 to 1
            sum = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[addend, 2*i + j, 32];
            for k = 0 to 7
                prod = <a href="shared_pseudocode.html#impl-shared.Int.2" title="function: integer Int(bits(N) x, boolean unsigned)">Int</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 8*i + k, 8], op1_unsigned) * <a href="shared_pseudocode.html#impl-shared.Int.2" title="function: integer Int(bits(N) x, boolean unsigned)">Int</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 8*j + k, 8], op2_unsigned);
                sum  = sum + prod;
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, 2*i + j, 32] = sum;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.PolynomialMult"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/PolynomialMult</h3>
      <p class="pseudocode">// PolynomialMult()
// ================

bits(M+N) <a id="impl-shared.PolynomialMult.2"/>PolynomialMult(bits(M) op1, bits(N) op2)
    result = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(M+N);
    extended_op2 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(op2, M+N);
    for i=0 to M-1
        if op1&lt;i&gt; == '1' then
            result = result EOR <a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(extended_op2, i);
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.SatQ"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/SatQ</h3>
      <p class="pseudocode">// SatQ()
// ======

(bits(N), boolean) <a id="impl-shared.SatQ.3"/>SatQ(integer i, integer N, boolean unsigned)
    (result, sat) = if unsigned then <a href="shared_pseudocode.html#impl-shared.UnsignedSatQ.2" title="function: (bits(N), boolean) UnsignedSatQ(integer i, integer N)">UnsignedSatQ</a>(i, N) else <a href="shared_pseudocode.html#impl-shared.SignedSatQ.2" title="function: (bits(N), boolean) SignedSatQ(integer i, integer N)">SignedSatQ</a>(i, N);
    return (result, sat);</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.SignedSatQ"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/SignedSatQ</h3>
      <p class="pseudocode">// SignedSatQ()
// ============

(bits(N), boolean) <a id="impl-shared.SignedSatQ.2"/>SignedSatQ(integer i, integer N)
    integer result;
    boolean saturated;
    if i &gt; 2^(N-1) - 1 then
        result = 2^(N-1) - 1;  saturated = TRUE;
    elsif i &lt; -(2^(N-1)) then
        result = -(2^(N-1));  saturated = TRUE;
    else
        result = i;  saturated = FALSE;
    return (result&lt;N-1:0&gt;, saturated);</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.UnsignedRSqrtEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/UnsignedRSqrtEstimate</h3>
      <p class="pseudocode">// UnsignedRSqrtEstimate()
// =======================

bits(N) <a id="impl-shared.UnsignedRSqrtEstimate.1"/>UnsignedRSqrtEstimate(bits(N) operand)
    assert N == 32;
    bits(N) result;
    if operand&lt;N-1:N-2&gt; == '00' then  // Operands &lt;= 0x3FFFFFFF produce 0xFFFFFFFF
        result = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(N);
    else
        // input is in the range 0x40000000 .. 0xffffffff representing [0.25 .. 1.0)
        // estimate is in the range 256 .. 511 representing [1.0 .. 2.0)
        increasedprecision = FALSE;
        estimate = <a href="shared_pseudocode.html#impl-shared.RecipSqrtEstimate.2" title="function: integer RecipSqrtEstimate(integer a_in, boolean increasedprecision)">RecipSqrtEstimate</a>(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;31:23&gt;), increasedprecision);
        // result is in the range 0x80000000 .. 0xff800000 representing [1.0 .. 2.0)
        result = estimate&lt;8:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N-9);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.UnsignedRecipEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/UnsignedRecipEstimate</h3>
      <p class="pseudocode">// UnsignedRecipEstimate()
// =======================

bits(N) <a id="impl-shared.UnsignedRecipEstimate.1"/>UnsignedRecipEstimate(bits(N) operand)
    assert N == 32;
    bits(N) result;
    if operand&lt;N-1&gt; == '0' then  // Operands &lt;= 0x7FFFFFFF produce 0xFFFFFFFF
        result = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(N);
    else
        // input is in the range 0x80000000 .. 0xffffffff representing [0.5 .. 1.0)

        // estimate is in the range 256 to 511 representing [1.0 .. 2.0)
        increasedprecision = FALSE;
        estimate = <a href="shared_pseudocode.html#impl-shared.RecipEstimate.2" title="function: integer RecipEstimate(integer a_in, boolean increasedprecision)">RecipEstimate</a>(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;31:23&gt;), increasedprecision);

        // result is in the range 0x80000000 .. 0xff800000 representing [1.0 .. 2.0)
        result = estimate&lt;8:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N-9);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.UnsignedSatQ"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/UnsignedSatQ</h3>
      <p class="pseudocode">// UnsignedSatQ()
// ==============

(bits(N), boolean) <a id="impl-shared.UnsignedSatQ.2"/>UnsignedSatQ(integer i, integer N)
    integer result;
    boolean saturated;
    if i &gt; 2^N - 1 then
        result = 2^N - 1;  saturated = TRUE;
    elsif i &lt; 0 then
        result = 0;  saturated = TRUE;
    else
        result = i;  saturated = FALSE;
    return (result&lt;N-1:0&gt;, saturated);</p>
    </div>
    <div class="ps"><a id="shared.trace.Common.GetTimestamp"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/Common/GetTimestamp</h3>
      <p class="pseudocode">// GetTimestamp()
// ==============
// Returns the Timestamp depending on the type

bits(64) <a id="impl-shared.GetTimestamp.1"/>GetTimestamp(<a href="shared_pseudocode.html#TimeStamp" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp</a> timeStampType)
    case timeStampType of
        when <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>
            return <a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>();
        when <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>
            return <a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>() - CNTVOFF_EL2;
        when <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>
            bits(64) physoff = if <a href="shared_pseudocode.html#impl-shared.PhysicalOffsetIsValid.0" title="function: boolean PhysicalOffsetIsValid()">PhysicalOffsetIsValid</a>() then CNTPOFF_EL2 else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
            return <a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>() - physoff;
        when <a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</a>
            return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        when <a href="shared_pseudocode.html#TimeStamp_CoreSight" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_CoreSight</a>
            return bits(64) IMPLEMENTATION_DEFINED "CoreSight timestamp";
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.trace.Common.PhysicalOffsetIsValid"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/Common/PhysicalOffsetIsValid</h3>
      <p class="pseudocode">// PhysicalOffsetIsValid()
// =======================
// Returns whether the Physical offset for the timestamp is valid

boolean <a id="impl-shared.PhysicalOffsetIsValid.0"/>PhysicalOffsetIsValid()
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        return FALSE;
    elsif !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) || !<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() then
        return FALSE;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.NS == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EffectiveSCR_EL3_RW.0" title="function: bit EffectiveSCR_EL3_RW()">EffectiveSCR_EL3_RW</a>() == '0' then
        return FALSE;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.ECVEn == '0' then
        return FALSE;
    elsif CNTHCTL_EL2.ECV == '0' then
        return FALSE;
    else
        return TRUE;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TraceBufferEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TraceBufferEnabled</h3>
      <p class="pseudocode">// TraceBufferEnabled()
// ====================

boolean <a id="impl-shared.TraceBufferEnabled.0"/>TraceBufferEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveTraceBufferExtension.0" title="function: boolean HaveTraceBufferExtension()">HaveTraceBufferExtension</a>() || TRBLIMITR_EL1.E == '0' then
        return FALSE;
    if !<a href="shared_pseudocode.html#impl-shared.SelfHostedTraceEnabled.0" title="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>() then
        return FALSE;
    (-, el) = <a href="shared_pseudocode.html#impl-shared.TraceBufferOwner.0" title="function: (SecurityState, bits(2)) TraceBufferOwner()">TraceBufferOwner</a>();
    return !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el);</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TraceBufferOwner"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TraceBufferOwner</h3>
      <p class="pseudocode">// TraceBufferOwner()
// ==================
// Return the owning Security state and Exception level. Must only be called
// when SelfHostedTraceEnabled() is TRUE.

(SecurityState, bits(2)) <a id="impl-shared.TraceBufferOwner.0"/>TraceBufferOwner()
    assert <a href="shared_pseudocode.html#impl-shared.HaveTraceBufferExtension.0" title="function: boolean HaveTraceBufferExtension()">HaveTraceBufferExtension</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.SelfHostedTraceEnabled.0" title="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>();

    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> owning_ss;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        bits(3) state_bits;
        if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
            state_bits = MDCR_EL3.&lt;NSTBE,NSTB&gt;;
            if state_bits IN {'10x'} then
                // Reserved value
                (-, state_bits) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESERVEDNSxB" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESERVEDNSxB</a>, 3);
        else
            state_bits = '0' : MDCR_EL3.NSTB;

        case state_bits of
            when '00x' owning_ss = <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
            when '01x' owning_ss = <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
            when '11x' owning_ss = <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>;
    else
        owning_ss = if <a href="shared_pseudocode.html#impl-shared.SecureOnlyImplementation.0" title="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</a>() then <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> else <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    bits(2) owning_el;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (owning_ss != <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> || <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) then
        owning_el = if MDCR_EL2.E2TB == '00' then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    else
        owning_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    return (owning_ss, owning_el);</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TraceBufferRunning"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TraceBufferRunning</h3>
      <p class="pseudocode">// TraceBufferRunning()
// ====================

boolean <a id="impl-shared.TraceBufferRunning.0"/>TraceBufferRunning()
    return <a href="shared_pseudocode.html#impl-shared.TraceBufferEnabled.0" title="function: boolean TraceBufferEnabled()">TraceBufferEnabled</a>() &amp;&amp; TRBSR_EL1.S == '0';</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceInstrumentationAllowed.TraceInstrumentationAllowed"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceInstrumentationAllowed/TraceInstrumentationAllowed</h3>
      <p class="pseudocode">// TraceInstrumentationAllowed()
// =============================
// Returns TRUE if Instrumentation Trace is allowed
// in the given Exception level and Security state.

boolean <a id="impl-shared.TraceInstrumentationAllowed.2"/>TraceInstrumentationAllowed(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(2) el)
    if !IsFeatureImplemented(FEAT_ITE) then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el) then return FALSE;

    if <a href="shared_pseudocode.html#impl-shared.TraceAllowed.1" title="function: boolean TraceAllowed(bits(2) el)">TraceAllowed</a>(el) then
        bit ite_bit;
        case el of
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> ite_bit = '0';
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> ite_bit = TRCITECR_EL2.E2E;
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> ite_bit = TRCITECR_EL1.E1E;
            when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
                if <a href="shared_pseudocode.html#impl-shared.EffectiveTGE.0" title="function: bit EffectiveTGE()">EffectiveTGE</a>() == '1' then
                    ite_bit = TRCITECR_EL2.E0HE;
                else
                    ite_bit = TRCITECR_EL1.E0E;

        if <a href="shared_pseudocode.html#impl-shared.SelfHostedTraceEnabled.0" title="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>() then
            return ite_bit == '1';
        else
            bit el_bit;
            bit ss_bit;
            case el of
                when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> el_bit = TRCITEEDCR.E0;
                when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> el_bit = TRCITEEDCR.E1;
                when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> el_bit = TRCITEEDCR.E2;
                when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> el_bit = TRCITEEDCR.E3;
            case ss of
                when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     ss_bit = TRCITEEDCR.RL;
                when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    ss_bit = TRCITEEDCR.S;
                when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> ss_bit = TRCITEEDCR.NS;
                otherwise ss_bit = '1';

            boolean ed_allowed = ss_bit == '1' &amp;&amp; el_bit == '1';

            if TRCCONFIGR.ITO == '1' then
                return ed_allowed;
            else
                return ed_allowed &amp;&amp; ite_bit == '1';
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.EffectiveE0HTRE"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/EffectiveE0HTRE</h3>
      <p class="pseudocode">// EffectiveE0HTRE()
// =================
// Returns effective E0HTRE value

bit <a id="impl-shared.EffectiveE0HTRE.0"/>EffectiveE0HTRE()
    return if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HTRFCR.E0HTRE else TRFCR_EL2.E0HTRE;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.EffectiveE0TRE"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/EffectiveE0TRE</h3>
      <p class="pseudocode">// EffectiveE0TRE()
// ================
// Returns effective E0TRE value

bit <a id="impl-shared.EffectiveE0TRE.0"/>EffectiveE0TRE()
    return if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then TRFCR.E0TRE else TRFCR_EL1.E0TRE;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.EffectiveE1TRE"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/EffectiveE1TRE</h3>
      <p class="pseudocode">// EffectiveE1TRE()
// ================
// Returns effective E1TRE value

bit <a id="impl-shared.EffectiveE1TRE.0"/>EffectiveE1TRE()
    return if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then TRFCR.E1TRE else TRFCR_EL1.E1TRE;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.EffectiveE2TRE"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/EffectiveE2TRE</h3>
      <p class="pseudocode">// EffectiveE2TRE()
// ================
// Returns effective E2TRE value

bit <a id="impl-shared.EffectiveE2TRE.0"/>EffectiveE2TRE()
    return if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then HTRFCR.E2TRE else TRFCR_EL2.E2TRE;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.SelfHostedTraceEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/SelfHostedTraceEnabled</h3>
      <p class="pseudocode">// SelfHostedTraceEnabled()
// ========================
// Returns TRUE if Self-hosted Trace is enabled.

boolean <a id="impl-shared.SelfHostedTraceEnabled.0"/>SelfHostedTraceEnabled()
    if !(<a href="shared_pseudocode.html#impl-shared.HaveTraceExt.0" title="function: boolean HaveTraceExt()">HaveTraceExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSelfHostedTrace.0" title="function: boolean HaveSelfHostedTrace()">HaveSelfHostedTrace</a>()) then return FALSE;
    if EDSCR.TFO == '0' then return TRUE;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        secure_trace_enable = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.STE else MDCR_EL3.STE;
        if secure_trace_enable == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>() then
            return TRUE;
        if (<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; MDCR_EL3.RLTE == '1' &amp;&amp;
            !<a href="shared_pseudocode.html#impl-shared.ExternalRealmNoninvasiveDebugEnabled.0" title="function: boolean ExternalRealmNoninvasiveDebugEnabled()">ExternalRealmNoninvasiveDebugEnabled</a>()) then
            return TRUE;
    else
        if <a href="shared_pseudocode.html#impl-shared.SecureOnlyImplementation.0" title="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>() then
            return TRUE;

    return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.TraceAllowed"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/TraceAllowed</h3>
      <p class="pseudocode">// TraceAllowed()
// ==============
// Returns TRUE if Self-hosted Trace is allowed in the given Exception level.

boolean <a id="impl-shared.TraceAllowed.1"/>TraceAllowed(bits(2) el)
    if !<a href="shared_pseudocode.html#impl-shared.HaveTraceExt.0" title="function: boolean HaveTraceExt()">HaveTraceExt</a>() then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.SelfHostedTraceEnabled.0" title="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>() then
        boolean trace_allowed;
        ss = <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(el);
        // Detect scenarios where tracing in this Security state is never allowed.
        case ss of
            when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
                trace_allowed = TRUE;
            when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
                bit trace_bit;
                if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
                    trace_bit = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.STE else MDCR_EL3.STE;
                else
                    trace_bit = '1';
                trace_allowed = trace_bit == '1';
            when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
                trace_allowed = MDCR_EL3.RLTE == '1';
            when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>
                trace_allowed = FALSE;

        // Tracing is prohibited if the trace buffer owning security state is not the
        // current Security state or the owning Exception level is a lower Exception level.
        if <a href="shared_pseudocode.html#impl-shared.HaveTraceBufferExtension.0" title="function: boolean HaveTraceBufferExtension()">HaveTraceBufferExtension</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.TraceBufferEnabled.0" title="function: boolean TraceBufferEnabled()">TraceBufferEnabled</a>() then
            (owning_ss, owning_el) = <a href="shared_pseudocode.html#impl-shared.TraceBufferOwner.0" title="function: (SecurityState, bits(2)) TraceBufferOwner()">TraceBufferOwner</a>();
            if (ss != owning_ss || <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(owning_el) &lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(el) ||
                (<a href="shared_pseudocode.html#impl-shared.EffectiveTGE.0" title="function: bit EffectiveTGE()">EffectiveTGE</a>() == '1' &amp;&amp; owning_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) then
                trace_allowed = FALSE;

        bit TRE_bit;
        case el of
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  TRE_bit = if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then TRFCR.E1TRE else '0';
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  TRE_bit = <a href="shared_pseudocode.html#impl-shared.EffectiveE2TRE.0" title="function: bit EffectiveE2TRE()">EffectiveE2TRE</a>();
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  TRE_bit = <a href="shared_pseudocode.html#impl-shared.EffectiveE1TRE.0" title="function: bit EffectiveE1TRE()">EffectiveE1TRE</a>();
            when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
                if <a href="shared_pseudocode.html#impl-shared.EffectiveTGE.0" title="function: bit EffectiveTGE()">EffectiveTGE</a>() == '1' then
                    TRE_bit = <a href="shared_pseudocode.html#impl-shared.EffectiveE0HTRE.0" title="function: bit EffectiveE0HTRE()">EffectiveE0HTRE</a>();
                else
                    TRE_bit = <a href="shared_pseudocode.html#impl-shared.EffectiveE0TRE.0" title="function: bit EffectiveE0TRE()">EffectiveE0TRE</a>();

        return trace_allowed &amp;&amp; TRE_bit == '1';
    else
        return <a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugAllowed.1" title="function: boolean ExternalNoninvasiveDebugAllowed(bits(2) el)">ExternalNoninvasiveDebugAllowed</a>(el);</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.TraceContextIDR2"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/TraceContextIDR2</h3>
      <p class="pseudocode">// TraceContextIDR2()
// ==================

boolean <a id="impl-shared.TraceContextIDR2.0"/>TraceContextIDR2()
    if !<a href="shared_pseudocode.html#impl-shared.TraceAllowed.1" title="function: boolean TraceAllowed(bits(2) el)">TraceAllowed</a>(PSTATE.EL)|| !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then return FALSE;
    return (!<a href="shared_pseudocode.html#impl-shared.SelfHostedTraceEnabled.0" title="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>() || TRFCR_EL2.CX == '1');</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.TraceSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/TraceSynchronizationBarrier</h3>
      <p class="pseudocode">// Memory barrier instruction that preserves the relative order of memory accesses to System
// registers due to trace operations and other memory accesses to the same registers
<a id="impl-shared.TraceSynchronizationBarrier.0"/>TraceSynchronizationBarrier();</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.TraceTimeStamp"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/TraceTimeStamp</h3>
      <p class="pseudocode">// TraceTimeStamp()
// ================

TimeStamp <a id="impl-shared.TraceTimeStamp.0"/>TraceTimeStamp()
    if <a href="shared_pseudocode.html#impl-shared.SelfHostedTraceEnabled.0" title="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            TS_el2 = TRFCR_EL2.TS;
            if !<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; TS_el2 == '10' then
                // Reserved value
                (-, TS_el2) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_EL2TIMESTAMP" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_EL2TIMESTAMP</a>, 2);

            case TS_el2 of
                when '00'
                    // Falls out to check TRFCR_EL1.TS
                when '01'
                    return <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
                when '10'
                    assert <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>();  // Otherwise ConstrainUnpredictableBits removes this case
                    return <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
                when '11'
                    return <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;

        TS_el1 = TRFCR_EL1.TS;
        if TS_el1 == '00' || (!<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; TS_el1 == '10') then
            // Reserved value
            (-, TS_el1) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_EL1TIMESTAMP" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_EL1TIMESTAMP</a>, 2);

        case TS_el1 of
            when '01'
                return <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
            when '10'
                assert <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>();
                return <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
            when '11'
                return <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;
            otherwise
                <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();         // ConstrainUnpredictableBits removes this case
    else
        return <a href="shared_pseudocode.html#TimeStamp_CoreSight" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_CoreSight</a>;</p>
    </div>
    <div class="ps"><a id="shared.trace.system.IsTraceCorePowered"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/system/IsTraceCorePowered</h3>
      <p class="pseudocode">// Returns TRUE if the Trace Core Power Domain is powered up
boolean <a id="impl-shared.IsTraceCorePowered.0"/>IsTraceCorePowered();</p>
    </div>
    <div class="ps"><a id="shared.translation.at.ATAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at/ATAccess</h3>
      <p class="pseudocode">enumeration <a id="ATAccess"/>ATAccess {
    <a id="ATAccess_Read"/>ATAccess_Read,
    <a id="ATAccess_Write"/>ATAccess_Write,
    <a id="ATAccess_ReadPAN"/>ATAccess_ReadPAN,
    <a id="ATAccess_WritePAN"/>ATAccess_WritePAN
};</p>
    </div>
    <div class="ps"><a id="shared.translation.at.EncodePARAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at/EncodePARAttrs</h3>
      <p class="pseudocode">// EncodePARAttrs()
// ================
// Convert orthogonal attributes and hints to 64-bit PAR ATTR field.

bits(8) <a id="impl-shared.EncodePARAttrs.1"/>EncodePARAttrs(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs)
    bits(8) result;

    if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() &amp;&amp; memattrs.tags == <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a> then
        if <a href="shared_pseudocode.html#impl-shared.HaveMTEPermExt.0" title="function: boolean HaveMTEPermExt()">HaveMTEPermExt</a>() &amp;&amp; memattrs.notagaccess then
            result&lt;7:0&gt; = '11100000';
        else
            result&lt;7:0&gt; = '11110000';
        return result;

    if memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        result&lt;7:4&gt; = '0000';
        if memattrs.device == <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a> then
            result&lt;3:0&gt; = '0000';
        elsif memattrs.device == <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a> then
            result&lt;3:0&gt; = '0100';
        elsif memattrs.device == <a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a> then
            result&lt;3:0&gt; = '1000';
        else // DeviceType_GRE
            result&lt;3:0&gt; = '1100';
    else
        if memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> then
            result&lt;7:6&gt; = if memattrs.outer.transient then '00' else '10';
            result&lt;5:4&gt; = memattrs.outer.hints;
        elsif memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> then
            result&lt;7:6&gt; = if memattrs.outer.transient then '01' else '11';
            result&lt;5:4&gt; = memattrs.outer.hints;
        else // MemAttr_NC
            result&lt;7:4&gt; = '0100';

        if memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> then
            result&lt;3:2&gt; = if memattrs.inner.transient then '00' else '10';
            result&lt;1:0&gt; = memattrs.inner.hints;
        elsif memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> then
            result&lt;3:2&gt; = if memattrs.inner.transient then '01' else '11';
            result&lt;1:0&gt; = memattrs.inner.hints;
        else // MemAttr_NC
            result&lt;3:0&gt; = '0100';

    return result;</p>
    </div>
    <div class="ps"><a id="shared.translation.at.PAREncodeShareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at/PAREncodeShareability</h3>
      <p class="pseudocode">// PAREncodeShareability()
// =======================
// Derive 64-bit PAR SH field.

bits(2) <a id="impl-shared.PAREncodeShareability.1"/>PAREncodeShareability(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs)
    if (memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> ||
            (memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp;
             memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>)) then
        // Force Outer-Shareable on Device and Normal Non-Cacheable memory
        return '10';

    case memattrs.shareability of
        when <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> return '00';
        when <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a> return '11';
        when <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> return '10';</p>
    </div>
    <div class="ps"><a id="shared.translation.at.TranslationStage"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at/TranslationStage</h3>
      <p class="pseudocode">enumeration <a id="TranslationStage"/>TranslationStage {
    <a id="TranslationStage_1"/>TranslationStage_1,
    <a id="TranslationStage_12"/>TranslationStage_12
};</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.DecodeDevice"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/DecodeDevice</h3>
      <p class="pseudocode">// DecodeDevice()
// ==============
// Decode output Device type

DeviceType <a id="impl-shared.DecodeDevice.1"/>DecodeDevice(bits(2) device)
    case device of
        when '00'   return <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
        when '01'   return <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a>;
        when '10'   return <a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a>;
        when '11'   return <a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</a>;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.DecodeLDFAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/DecodeLDFAttr</h3>
      <p class="pseudocode">// DecodeLDFAttr()
// ===============
// Decode memory attributes using LDF (Long Descriptor Format) mapping

MemAttrHints <a id="impl-shared.DecodeLDFAttr.1"/>DecodeLDFAttr(bits(4) attr)
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> ldfattr;

    if    attr IN {'x0xx'} then ldfattr.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>; // Write-through
    elsif attr == '0100' then ldfattr.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;   // Non-cacheable
    elsif attr IN {'x1xx'} then ldfattr.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>; // Write-back
    else                      <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    // Allocation hints are applicable only to cacheable memory.
    if ldfattr.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
        case attr&lt;1:0&gt; of
            when '00' ldfattr.hints = <a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'">MemHint_No</a>;  // No allocation hints
            when '01' ldfattr.hints = <a href="shared_pseudocode.html#MemHint_WA" title="constant bits(2) MemHint_WA = '01'">MemHint_WA</a>;  // Write-allocate
            when '10' ldfattr.hints = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;  // Read-allocate
            when '11' ldfattr.hints = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>; // Read/Write allocate

    // The Transient hint applies only to cacheable memory with some allocation hints.
    if ldfattr.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp; ldfattr.hints != <a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'">MemHint_No</a> then
        ldfattr.transient = attr&lt;3&gt; == '0';

    return ldfattr;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.DecodeSDFAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/DecodeSDFAttr</h3>
      <p class="pseudocode">// DecodeSDFAttr()
// ===============
// Decode memory attributes using SDF (Short Descriptor Format) mapping

MemAttrHints <a id="impl-shared.DecodeSDFAttr.1"/>DecodeSDFAttr(bits(2) rgn)
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> sdfattr;

    case rgn of
        when '00'                   // Non-cacheable (no allocate)
            sdfattr.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
        when '01'                   // Write-back, Read and Write allocate
            sdfattr.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            sdfattr.hints = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
        when '10'                   // Write-through, Read allocate
            sdfattr.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            sdfattr.hints = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
        when '11'                   // Write-back, Read allocate
            sdfattr.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            sdfattr.hints = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;

    sdfattr.transient = FALSE;

    return sdfattr;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.DecodeShareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/DecodeShareability</h3>
      <p class="pseudocode">// DecodeShareability()
// ====================
// Decode shareability of target memory region

Shareability <a id="impl-shared.DecodeShareability.1"/>DecodeShareability(bits(2) sh)
    case sh of
        when '10' return <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '11' return <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
        when '00' return <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        otherwise
            case <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_Shareability" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_Shareability</a>) of
                when <a href="shared_pseudocode.html#Constraint_OSH" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_OSH</a> return <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
                when <a href="shared_pseudocode.html#Constraint_ISH" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_ISH</a> return <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
                when <a href="shared_pseudocode.html#Constraint_NSH" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NSH</a> return <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.EffectiveShareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/EffectiveShareability</h3>
      <p class="pseudocode">// EffectiveShareability()
// =======================
// Force Outer Shareability on Device and Normal iNCoNC memory

Shareability <a id="impl-shared.EffectiveShareability.1"/>EffectiveShareability(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs)
    if (memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> ||
            (memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp;
             memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>)) then
        return <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
    else
        return memattrs.shareability;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.NormalNCMemAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/NormalNCMemAttr</h3>
      <p class="pseudocode">// NormalNCMemAttr()
// =================
// Normal Non-cacheable memory attributes

MemoryAttributes <a id="impl-shared.NormalNCMemAttr.0"/>NormalNCMemAttr()
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> non_cacheable;
    non_cacheable.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> nc_memattrs;
    nc_memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
    nc_memattrs.outer        = non_cacheable;
    nc_memattrs.inner        = non_cacheable;
    nc_memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
    nc_memattrs.tags         = <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;
    nc_memattrs.notagaccess  = FALSE;

    return nc_memattrs;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S1ConstrainUnpredictableRESMAIR"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S1ConstrainUnpredictableRESMAIR</h3>
      <p class="pseudocode">// S1ConstrainUnpredictableRESMAIR()
// =================================
// Determine whether a reserved value occupies MAIR_ELx.AttrN

boolean <a id="impl-shared.S1ConstrainUnpredictableRESMAIR.2"/>S1ConstrainUnpredictableRESMAIR(bits(8) attr, boolean s1aarch64)
    case attr of
        when '0000xx01' return !(s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatXS.0" title="function: boolean HaveFeatXS()">HaveFeatXS</a>());
        when '0000xxxx' return attr&lt;1:0&gt; != '00';
        when '01000000' return !(s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatXS.0" title="function: boolean HaveFeatXS()">HaveFeatXS</a>());
        when '10100000' return !(s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatXS.0" title="function: boolean HaveFeatXS()">HaveFeatXS</a>());
        when '11110000' return !(s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>());
        when 'xxxx0000' return TRUE;
        otherwise       return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S1DecodeMemAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S1DecodeMemAttrs</h3>
      <p class="pseudocode">// S1DecodeMemAttrs()
// ==================
// Decode MAIR-format memory attributes assigned in stage 1

<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> S1DecodeMemAttrs(bits(8) attr_in, bits(2) sh, boolean s1aarch64,
                                  S1TTWParams walkparams)
    bits(8) attr = attr_in;
    if <a href="shared_pseudocode.html#impl-shared.S1ConstrainUnpredictableRESMAIR.2" title="function: boolean S1ConstrainUnpredictableRESMAIR(bits(8) attr, boolean s1aarch64)">S1ConstrainUnpredictableRESMAIR</a>(attr, s1aarch64) then
        (-, attr) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.2" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which, integer width)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_RESMAIR</a>, 8);

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs;
    case attr of
        when '0000xxxx' // Device memory
            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device  = <a href="shared_pseudocode.html#impl-shared.DecodeDevice.1" title="function: DeviceType DecodeDevice(bits(2) device)">DecodeDevice</a>(attr&lt;3:2&gt;);
            memattrs.xs      = if s1aarch64 then NOT attr&lt;0&gt; else '1';
        when '01000000'
            assert s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatXS.0" title="function: boolean HaveFeatXS()">HaveFeatXS</a>();
            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.outer.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.inner.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.xs          = '0';

        when '10100000'
            assert s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatXS.0" title="function: boolean HaveFeatXS()">HaveFeatXS</a>();
            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.outer.attrs     = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.outer.hints     = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.outer.transient = FALSE;
            memattrs.inner.attrs     = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.inner.hints     = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.inner.transient = FALSE;
            memattrs.xs              = '0';
        when '11110000' // Tagged memory
            assert s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>();
            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.outer.attrs     = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.outer.hints     = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.outer.transient = FALSE;
            memattrs.inner.attrs     = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.inner.hints     = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.inner.transient = FALSE;
            memattrs.xs              = '0';
        otherwise
            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.outer   = <a href="shared_pseudocode.html#impl-shared.DecodeLDFAttr.1" title="function: MemAttrHints DecodeLDFAttr(bits(4) attr)">DecodeLDFAttr</a>(attr&lt;7:4&gt;);
            memattrs.inner   = <a href="shared_pseudocode.html#impl-shared.DecodeLDFAttr.1" title="function: MemAttrHints DecodeLDFAttr(bits(4) attr)">DecodeLDFAttr</a>(attr&lt;3:0&gt;);

            if (memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
                    memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>) then
                memattrs.xs = '0';
            else
                memattrs.xs = '1';

    if s1aarch64 &amp;&amp; attr IN {'111x0000'} then
        memattrs.tags = <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a>;
    elsif s1aarch64 &amp;&amp; walkparams.mtx == '1' then
        memattrs.tags = <a href="shared_pseudocode.html#MemTag_CanonicallyTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_CanonicallyTagged</a>;
    else
        memattrs.tags = <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;

    memattrs.notagaccess = FALSE;

    memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.DecodeShareability.1" title="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(sh);

    return memattrs;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2CombineS1AttrHints"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2CombineS1AttrHints</h3>
      <p class="pseudocode">// S2CombineS1AttrHints()
// ======================
// Determine resultant Normal memory cacheability and allocation hints from
// combining stage 1 Normal memory attributes and stage 2 cacheability attributes.

MemAttrHints <a id="impl-shared.S2CombineS1AttrHints.2"/>S2CombineS1AttrHints(<a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> s1_attrhints, <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> s2_attrhints)
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> attrhints;

    if s1_attrhints.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> || s2_attrhints.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
        attrhints.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
    elsif s1_attrhints.attrs == <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> || s2_attrhints.attrs == <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> then
        attrhints.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
    else
        attrhints.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;

    // Stage 2 does not assign any allocation hints
    // Instead, they are inherited from stage 1
    if attrhints.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
        attrhints.hints     = s1_attrhints.hints;
        attrhints.transient = s1_attrhints.transient;

    return attrhints;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2CombineS1Device"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2CombineS1Device</h3>
      <p class="pseudocode">// S2CombineS1Device()
// ===================
// Determine resultant Device type from combining output memory attributes
// in stage 1 and Device attributes in stage 2

DeviceType <a id="impl-shared.S2CombineS1Device.2"/>S2CombineS1Device(<a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType</a> s1_device, <a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType</a> s2_device)
    if s1_device == <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a> || s2_device == <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a> then
        return <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
    elsif s1_device == <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a> || s2_device == <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a> then
        return <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a>;
    elsif s1_device == <a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a> || s2_device == <a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a> then
        return <a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a>;
    else
        return <a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</a>;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2CombineS1MemAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2CombineS1MemAttrs</h3>
      <p class="pseudocode">// S2CombineS1MemAttrs()
// =====================
// Combine stage 2 with stage 1 memory attributes

MemoryAttributes <a id="impl-shared.S2CombineS1MemAttrs.2"/>S2CombineS1MemAttrs(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> s1_memattrs,
                                     <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> s2_memattrs)
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs;

    if s1_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp; s2_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        memattrs.memtype = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
        memattrs.device  = <a href="shared_pseudocode.html#impl-shared.S2CombineS1Device.2" title="function: DeviceType S2CombineS1Device(DeviceType s1_device, DeviceType s2_device)">S2CombineS1Device</a>(s1_memattrs.device, s2_memattrs.device);
    elsif s1_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then    // S2 Normal, S1 Device
        memattrs = s1_memattrs;
    elsif s2_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then    // S2 Device, S1 Normal
        memattrs = s2_memattrs;
    else                                                // S2 Normal, S1 Normal
        memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.inner   = <a href="shared_pseudocode.html#impl-shared.S2CombineS1AttrHints.2" title="function: MemAttrHints S2CombineS1AttrHints(MemAttrHints s1_attrhints, MemAttrHints s2_attrhints)">S2CombineS1AttrHints</a>(s1_memattrs.inner, s2_memattrs.inner);
        memattrs.outer   = <a href="shared_pseudocode.html#impl-shared.S2CombineS1AttrHints.2" title="function: MemAttrHints S2CombineS1AttrHints(MemAttrHints s1_attrhints, MemAttrHints s2_attrhints)">S2CombineS1AttrHints</a>(s1_memattrs.outer, s2_memattrs.outer);

        memattrs.tags   = <a href="shared_pseudocode.html#impl-shared.S2MemTagType.2" title="function: MemTagType S2MemTagType(MemoryAttributes s2_memattrs, MemTagType s1_tagtype)">S2MemTagType</a>(memattrs, s1_memattrs.tags);

    if !<a href="shared_pseudocode.html#impl-shared.HaveMTEPermExt.0" title="function: boolean HaveMTEPermExt()">HaveMTEPermExt</a>() then
        memattrs.notagaccess = FALSE;
    else
        memattrs.notagaccess = (s2_memattrs.notagaccess &amp;&amp;
                               s1_memattrs.tags == <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a>);
    memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.S2CombineS1Shareability.2" title="function: Shareability S2CombineS1Shareability(Shareability s1_shareability,&#13; Shareability s2_shareability)">S2CombineS1Shareability</a>(s1_memattrs.shareability,
                                                    s2_memattrs.shareability);
    memattrs.xs           = s2_memattrs.xs;

    memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);
    return memattrs;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2CombineS1Shareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2CombineS1Shareability</h3>
      <p class="pseudocode">// S2CombineS1Shareability()
// =========================
// Combine stage 2 shareability with stage 1

Shareability <a id="impl-shared.S2CombineS1Shareability.2"/>S2CombineS1Shareability(<a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> s1_shareability,
                                     <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> s2_shareability)

    if (s1_shareability == <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> ||
            s2_shareability == <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>) then
        return <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
    elsif (s1_shareability == <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a> ||
            s2_shareability == <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>) then
        return <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
    else
        return <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2DecodeCacheability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2DecodeCacheability</h3>
      <p class="pseudocode">// S2DecodeCacheability()
// ======================
// Determine the stage 2 cacheability for Normal memory

MemAttrHints <a id="impl-shared.S2DecodeCacheability.1"/>S2DecodeCacheability(bits(2) attr)
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> s2attr;

    case attr of
        when '01' s2attr.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;  // Non-cacheable
        when '10' s2attr.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;  // Write-through
        when '11' s2attr.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;  // Write-back
        otherwise // Constrained unpredictable
            case <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_S2RESMEMATTR" title="enumeration Unpredictable {&#13;  Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;   Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;   Unpredictable_ERETZEROUPPERPC,&#13;   Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_DBUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_RESERVEDNSxB,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;   Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;   Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13;  Unpredictable_BRBFILTRATE,&#13;   Unpredictable_MOPSOVERLAP31,&#13;  Unpredictable_STOREONLYTAGCHECKEDCAS&#13; }">Unpredictable_S2RESMEMATTR</a>) of
                when <a href="shared_pseudocode.html#Constraint_NC" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NC</a> s2attr.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
                when <a href="shared_pseudocode.html#Constraint_WT" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_WT</a> s2attr.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
                when <a href="shared_pseudocode.html#Constraint_WB" title="enumeration Constraint    { Constraint_NONE,   Constraint_UNKNOWN,  Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,   Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY,   Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_EL1TIMESTAMP, Constraint_EL2TIMESTAMP, Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_WB</a> s2attr.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;

    // Stage 2 does not assign hints or the transient property
    // They are inherited from stage 1 if the result of the combination allows it
    s2attr.hints     = bits(2) UNKNOWN;
    s2attr.transient = boolean UNKNOWN;

    return s2attr;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2DecodeMemAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2DecodeMemAttrs</h3>
      <p class="pseudocode">// S2DecodeMemAttrs()
// ==================
// Decode stage 2 memory attributes

MemoryAttributes <a id="impl-shared.S2DecodeMemAttrs.3"/>S2DecodeMemAttrs(bits(4) attr, bits(2) sh, boolean s2aarch64)
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs;

    case attr of
        when '00xx' // Device memory
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a href="shared_pseudocode.html#impl-shared.DecodeDevice.1" title="function: DeviceType DecodeDevice(bits(2) device)">DecodeDevice</a>(attr&lt;1:0&gt;);
        when '0100' // Normal, Inner+Outer WB cacheable NoTagAccess memory
            if s2aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveMTEPermExt.0" title="function: boolean HaveMTEPermExt()">HaveMTEPermExt</a>() then
                memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
                memattrs.outer        = <a href="shared_pseudocode.html#impl-shared.S2DecodeCacheability.1" title="function: MemAttrHints S2DecodeCacheability(bits(2) attr)">S2DecodeCacheability</a>('11'); // Write-back
                memattrs.inner        = <a href="shared_pseudocode.html#impl-shared.S2DecodeCacheability.1" title="function: MemAttrHints S2DecodeCacheability(bits(2) attr)">S2DecodeCacheability</a>('11'); // Write-back
            else
                memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
                memattrs.outer        = <a href="shared_pseudocode.html#impl-shared.S2DecodeCacheability.1" title="function: MemAttrHints S2DecodeCacheability(bits(2) attr)">S2DecodeCacheability</a>(attr&lt;3:2&gt;);
                memattrs.inner        = <a href="shared_pseudocode.html#impl-shared.S2DecodeCacheability.1" title="function: MemAttrHints S2DecodeCacheability(bits(2) attr)">S2DecodeCacheability</a>(attr&lt;1:0&gt;);
        otherwise   // Normal memory
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.outer        = <a href="shared_pseudocode.html#impl-shared.S2DecodeCacheability.1" title="function: MemAttrHints S2DecodeCacheability(bits(2) attr)">S2DecodeCacheability</a>(attr&lt;3:2&gt;);
            memattrs.inner        = <a href="shared_pseudocode.html#impl-shared.S2DecodeCacheability.1" title="function: MemAttrHints S2DecodeCacheability(bits(2) attr)">S2DecodeCacheability</a>(attr&lt;1:0&gt;);

    memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.DecodeShareability.1" title="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(sh);

    if s2aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveMTEPermExt.0" title="function: boolean HaveMTEPermExt()">HaveMTEPermExt</a>() then
        memattrs.notagaccess = attr == '0100';
    else
        memattrs.notagaccess = FALSE;

    return memattrs;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2MemTagType"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2MemTagType</h3>
      <p class="pseudocode">// S2MemTagType()
// ==============
// Determine whether the combined output memory attributes of stage 1 and
// stage 2 indicate tagged memory

MemTagType <a id="impl-shared.S2MemTagType.2"/>S2MemTagType(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> s2_memattrs, <a href="shared_pseudocode.html#MemTagType" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTagType</a> s1_tagtype)

    if !<a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        return <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;

    if ((s1_tagtype == <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a>)  &amp;&amp;
        (s2_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>)  &amp;&amp;
        (s2_memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>)  &amp;&amp;
        (s2_memattrs.inner.hints == <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>) &amp;&amp;
        (!s2_memattrs.inner.transient)           &amp;&amp;
        (s2_memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>)  &amp;&amp;
        (s2_memattrs.outer.hints == <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>) &amp;&amp;
        (!s2_memattrs.outer.transient)) then
        return <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a>;

    // Return what stage 1 asked for if we can, otherwise Untagged.
    if s1_tagtype != <a href="shared_pseudocode.html#MemTag_AllocationTagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_AllocationTagged</a> then
        return s1_tagtype;

    return <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.WalkMemAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/WalkMemAttrs</h3>
      <p class="pseudocode">// WalkMemAttrs()
// ==============
// Retrieve memory attributes of translation table walk

MemoryAttributes <a id="impl-shared.WalkMemAttrs.3"/>WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> walkmemattrs;

    walkmemattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
    walkmemattrs.shareability = <a href="shared_pseudocode.html#impl-shared.DecodeShareability.1" title="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(sh);
    walkmemattrs.inner        = <a href="shared_pseudocode.html#impl-shared.DecodeSDFAttr.1" title="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(irgn);
    walkmemattrs.outer        = <a href="shared_pseudocode.html#impl-shared.DecodeSDFAttr.1" title="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(orgn);
    walkmemattrs.tags         = <a href="shared_pseudocode.html#MemTag_Untagged" title="enumeration MemTagType {&#13; MemTag_Untagged,&#13; MemTag_AllocationTagged,&#13; MemTag_CanonicallyTagged&#13; }">MemTag_Untagged</a>;
    if (walkmemattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
            walkmemattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>) then
        walkmemattrs.xs = '0';
    else
        walkmemattrs.xs = '1';
    walkmemattrs.notagaccess = FALSE;

    return walkmemattrs;</p>
    </div>
    <div class="ps"><a id="shared.translation.faults.AlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/faults/AlignmentFault</h3>
      <p class="pseudocode">// AlignmentFault()
// ================
// Return a fault record indicating an Alignment fault not due to memory type has occured
// for a specific access

FaultRecord <a id="impl-shared.AlignmentFault.1"/>AlignmentFault(<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault;

    fault.statuscode  = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
    fault.access      = accdesc;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;
    fault.write       = !accdesc.read &amp;&amp; accdesc.write;
    fault.gpcfs2walk  = FALSE;
    fault.gpcf        = <a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>();

    return fault;</p>
    </div>
    <div class="ps"><a id="shared.translation.faults.ExclusiveFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/faults/ExclusiveFault</h3>
      <p class="pseudocode">// ExclusiveFault()
// ================
// Return a fault record indicating an Exclusive fault for a specific access

FaultRecord <a id="impl-shared.ExclusiveFault.1"/>ExclusiveFault(<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault;

    fault.statuscode  = <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>;
    fault.access      = accdesc;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;
    fault.write       = !accdesc.read &amp;&amp; accdesc.write;
    fault.gpcfs2walk  = FALSE;
    fault.gpcf        = <a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>();

    return fault;</p>
    </div>
    <div class="ps"><a id="shared.translation.faults.NoFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/faults/NoFault</h3>
      <p class="pseudocode">// NoFault()
// =========
// Return a clear fault record indicating no faults have occured

FaultRecord <a id="impl-shared.NoFault.0"/>NoFault()
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault;

    fault.statuscode  = <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    fault.access      = <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> UNKNOWN;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;
    fault.dirtybit    = FALSE;
    fault.overlay     = FALSE;
    fault.toplevel    = FALSE;
    fault.assuredonly = FALSE;
    fault.tagaccess   = FALSE;
    fault.gpcfs2walk  = FALSE;
    fault.gpcf        = <a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>();

    return fault;

// NoFault()
// =========
// Return a clear fault record indicating no faults have occured for a specific access

FaultRecord <a id="impl-shared.NoFault.1"/>NoFault(<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault;

    fault.statuscode  = <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    fault.access      = accdesc;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;
    fault.dirtybit    = FALSE;
    fault.overlay     = FALSE;
    fault.toplevel    = FALSE;
    fault.assuredonly = FALSE;
    fault.tagaccess   = FALSE;
    fault.write       = !accdesc.read &amp;&amp; accdesc.write;
    fault.gpcfs2walk  = FALSE;
    fault.gpcf        = <a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>();

    return fault;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.AbovePPS"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/AbovePPS</h3>
      <p class="pseudocode">// AbovePPS()
// ==========
// Returns TRUE if an address exceeds the range configured in GPCCR_EL3.PPS.

boolean <a id="impl-shared.AbovePPS.1"/>AbovePPS(bits(56) address)
    pps = <a href="shared_pseudocode.html#impl-shared.DecodePPS.0" title="function: integer DecodePPS()">DecodePPS</a>();
    if pps &gt;= 56 then
        return FALSE;

    return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(address&lt;55:pps&gt;);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodeGPTBlock"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodeGPTBlock</h3>
      <p class="pseudocode">// DecodeGPTBlock()
// ================
// Validate and decode a GPT Block descriptor

(GPCF, GPTEntry) <a id="impl-shared.DecodeGPTBlock.2"/>DecodeGPTBlock(<a href="shared_pseudocode.html#PGSe" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGSe</a> pgs, bits(64) entry)
    assert entry&lt;3:0&gt; == <a href="shared_pseudocode.html#GPT_Block" title="constant bits(4) GPT_Block = '0001'">GPT_Block</a>;
    <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> result;

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(entry&lt;63:8&gt;) then
        return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> UNKNOWN);

    if !<a href="shared_pseudocode.html#impl-shared.GPIValid.1" title="function: boolean GPIValid(bits(4) gpi)">GPIValid</a>(entry&lt;7:4&gt;) then
        return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> UNKNOWN);

    result.gpi   = entry&lt;7:4&gt;;
    result.level = 0;

    // GPT information from a level 0 GPT Block descriptor is permitted
    // to be cached in a TLB as though the Block is a contiguous region
    // of granules each of the size configured in GPCCR_EL3.PGS.
    case pgs of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  result.size = <a href="shared_pseudocode.html#GPTRange_4KB" title="constant integer GPTRange_4KB = 12">GPTRange_4KB</a>;
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> result.size = <a href="shared_pseudocode.html#GPTRange_16KB" title="constant integer GPTRange_16KB = 14">GPTRange_16KB</a>;
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> result.size = <a href="shared_pseudocode.html#GPTRange_64KB" title="constant integer GPTRange_64KB = 16">GPTRange_64KB</a>;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    result.contig_size = <a href="shared_pseudocode.html#impl-shared.GPTL0Size.0" title="function: integer GPTL0Size()">GPTL0Size</a>();

    return (<a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a>, result);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodeGPTContiguous"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodeGPTContiguous</h3>
      <p class="pseudocode">// DecodeGPTContiguous()
// =====================
// Validate and decode a GPT Contiguous descriptor

(GPCF, GPTEntry) <a id="impl-shared.DecodeGPTContiguous.2"/>DecodeGPTContiguous(<a href="shared_pseudocode.html#PGSe" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGSe</a> pgs, bits(64) entry)
    assert entry&lt;3:0&gt; == <a href="shared_pseudocode.html#GPT_Contig" title="constant bits(4) GPT_Contig = '0001'">GPT_Contig</a>;
    <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> result;

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(entry&lt;63:10&gt;) then
        return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, result);

    result.gpi = entry&lt;7:4&gt;;
    if !<a href="shared_pseudocode.html#impl-shared.GPIValid.1" title="function: boolean GPIValid(bits(4) gpi)">GPIValid</a>(result.gpi) then
        return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, result);

    case pgs of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  result.size = <a href="shared_pseudocode.html#GPTRange_4KB" title="constant integer GPTRange_4KB = 12">GPTRange_4KB</a>;
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> result.size = <a href="shared_pseudocode.html#GPTRange_16KB" title="constant integer GPTRange_16KB = 14">GPTRange_16KB</a>;
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> result.size = <a href="shared_pseudocode.html#GPTRange_64KB" title="constant integer GPTRange_64KB = 16">GPTRange_64KB</a>;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    case entry&lt;9:8&gt; of
        when '01' result.contig_size = <a href="shared_pseudocode.html#GPTRange_2MB" title="constant integer GPTRange_2MB = 21">GPTRange_2MB</a>;
        when '10' result.contig_size = <a href="shared_pseudocode.html#GPTRange_32MB" title="constant integer GPTRange_32MB = 25">GPTRange_32MB</a>;
        when '11' result.contig_size = <a href="shared_pseudocode.html#GPTRange_512MB" title="constant integer GPTRange_512MB = 29">GPTRange_512MB</a>;
        otherwise return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> UNKNOWN);

    result.level = 1;

    return (<a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a>, result);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodeGPTGranules"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodeGPTGranules</h3>
      <p class="pseudocode">// DecodeGPTGranules()
// ===================
// Validate and decode a GPT Granules descriptor

(GPCF, GPTEntry) <a id="impl-shared.DecodeGPTGranules.3"/>DecodeGPTGranules(<a href="shared_pseudocode.html#PGSe" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGSe</a> pgs, integer index, bits(64) entry)
    <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> result;

    for i = 0 to 15
        if !<a href="shared_pseudocode.html#impl-shared.GPIValid.1" title="function: boolean GPIValid(bits(4) gpi)">GPIValid</a>(entry&lt;i*4 +:4&gt;) then
            return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, result);

    result.gpi = entry&lt;index*4 +:4&gt;;

    case pgs of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  result.size = <a href="shared_pseudocode.html#GPTRange_4KB" title="constant integer GPTRange_4KB = 12">GPTRange_4KB</a>;
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> result.size = <a href="shared_pseudocode.html#GPTRange_16KB" title="constant integer GPTRange_16KB = 14">GPTRange_16KB</a>;
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> result.size = <a href="shared_pseudocode.html#GPTRange_64KB" title="constant integer GPTRange_64KB = 16">GPTRange_64KB</a>;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    result.contig_size = result.size; // No contiguity
    result.level = 1;

    return (<a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a>, result);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodeGPTTable"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodeGPTTable</h3>
      <p class="pseudocode">// DecodeGPTTable()
// ================
// Validate and decode a GPT Table descriptor

(GPCF, GPTTable) <a id="impl-shared.DecodeGPTTable.2"/>DecodeGPTTable(<a href="shared_pseudocode.html#PGSe" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGSe</a> pgs, bits(64) entry)
    assert entry&lt;3:0&gt; == <a href="shared_pseudocode.html#GPT_Table" title="constant bits(4) GPT_Table = '0011'">GPT_Table</a>;
    <a href="shared_pseudocode.html#GPTTable" title="type GPTTable is ( bits(56) address )">GPTTable</a> result;

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(entry&lt;63:52,11:4&gt;) then
        return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, <a href="shared_pseudocode.html#GPTTable" title="type GPTTable is ( bits(56) address )">GPTTable</a> UNKNOWN);

    l0sz = <a href="shared_pseudocode.html#impl-shared.GPTL0Size.0" title="function: integer GPTL0Size()">GPTL0Size</a>();
    integer p;
    case pgs of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  p = 12;
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> p = 14;
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> p = 16;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(entry&lt;(l0sz-p)-2:12&gt;) then
        return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, <a href="shared_pseudocode.html#GPTTable" title="type GPTTable is ( bits(56) address )">GPTTable</a> UNKNOWN);

    case pgs of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  result.address = entry&lt;55:17&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(17);
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> result.address = entry&lt;55:15&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(15);
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> result.address = entry&lt;55:13&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(13);
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    // The address must be within the range covered by the GPT
    if <a href="shared_pseudocode.html#impl-shared.AbovePPS.1" title="function: boolean AbovePPS(bits(56) address)">AbovePPS</a>(result.address) then
        return (<a href="shared_pseudocode.html#GPCF_AddressSize" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_AddressSize</a>, <a href="shared_pseudocode.html#GPTTable" title="type GPTTable is ( bits(56) address )">GPTTable</a> UNKNOWN);

    return (<a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a>, result);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodePGS"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodePGS</h3>
      <p class="pseudocode">// DecodePGS()
// ===========

PGSe <a id="impl-shared.DecodePGS.1"/>DecodePGS(bits(2) pgs)
    case pgs of
        when '00' return <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>;
        when '10' return <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a>;
        when '01' return <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a>;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodePPS"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodePPS</h3>
      <p class="pseudocode">// DecodePPS()
// ===========
// Size of region protected by the GPT, in bits.

integer <a id="impl-shared.DecodePPS.0"/>DecodePPS()
    case GPCCR_EL3.PPS of
        when '000' return 32;
        when '001' return 36;
        when '010' return 40;
        when '011' return 42;
        when '100' return 44;
        when '101' return 48;
        when '110' return 52;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPCFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPCFault</h3>
      <p class="pseudocode">// GPCFault()
// ==========
// Constructs and returns a GPCF

GPCFRecord <a id="impl-shared.GPCFault.2"/>GPCFault(<a href="shared_pseudocode.html#GPCF" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF</a> gpf, integer level)
    <a href="shared_pseudocode.html#GPCFRecord" title="type GPCFRecord is ( GPCF gpf, integer level )">GPCFRecord</a> fault;
    fault.gpf   = gpf;
    fault.level = level;
    return fault;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPCNoFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPCNoFault</h3>
      <p class="pseudocode">// GPCNoFault()
// ============
// Returns the default properties of a GPCF that does not represent a fault

GPCFRecord <a id="impl-shared.GPCNoFault.0"/>GPCNoFault()
    <a href="shared_pseudocode.html#GPCFRecord" title="type GPCFRecord is ( GPCF gpf, integer level )">GPCFRecord</a> result;
    result.gpf = <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a>;
    return result;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPCRegistersConsistent"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPCRegistersConsistent</h3>
      <p class="pseudocode">// GPCRegistersConsistent()
// ========================
// Returns whether the GPT registers are configured correctly.
// This returns false if any fields select a Reserved value.

boolean <a id="impl-shared.GPCRegistersConsistent.0"/>GPCRegistersConsistent()

    // Check for Reserved register values
    if GPCCR_EL3.PPS == '111' || <a href="shared_pseudocode.html#impl-shared.DecodePPS.0" title="function: integer DecodePPS()">DecodePPS</a>() &gt; <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>() then
        return FALSE;
    if GPCCR_EL3.PGS == '11' then
        return FALSE;
    if GPCCR_EL3.SH == '01' then
        return FALSE;

    // Inner and Outer Non-cacheable requires Outer Shareable
    if GPCCR_EL3.&lt;ORGN, IRGN&gt; == '0000' &amp;&amp; GPCCR_EL3.SH != '10' then
        return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPICheck"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPICheck</h3>
      <p class="pseudocode">// GPICheck()
// ==========
// Returns whether an access to a given physical address space is permitted
// given the configured GPI value.
// paspace: Physical address space of the access
// gpi: Value read from GPT for the access

boolean <a id="impl-shared.GPICheck.2"/>GPICheck(<a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> paspace, bits(4) gpi)

    case gpi of
        when <a href="shared_pseudocode.html#GPT_NoAccess" title="constant bits(4) GPT_NoAccess = '0000'">GPT_NoAccess</a>  return FALSE;
        when <a href="shared_pseudocode.html#GPT_Secure" title="constant bits(4) GPT_Secure = '1000'">GPT_Secure</a>    return paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#GPT_NonSecure" title="constant bits(4) GPT_NonSecure = '1001'">GPT_NonSecure</a> return paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#GPT_Root" title="constant bits(4) GPT_Root = '1010'">GPT_Root</a>      return paspace == <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>;
        when <a href="shared_pseudocode.html#GPT_Realm" title="constant bits(4) GPT_Realm = '1011'">GPT_Realm</a>     return paspace == <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
        when <a href="shared_pseudocode.html#GPT_Any" title="constant bits(4) GPT_Any = '1111'">GPT_Any</a>       return TRUE;
        otherwise          <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPIIndex"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPIIndex</h3>
      <p class="pseudocode">// GPIIndex()
// ==========

integer <a id="impl-shared.GPIIndex.1"/>GPIIndex(bits(56) pa)
    case <a href="shared_pseudocode.html#impl-shared.DecodePGS.1" title="function: PGSe DecodePGS(bits(2) pgs)">DecodePGS</a>(GPCCR_EL3.PGS) of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;15:12&gt;);
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;17:14&gt;);
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;19:16&gt;);
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPIValid"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPIValid</h3>
      <p class="pseudocode">// GPIValid()
// ==========
// Returns whether a given value is a valid encoding for a GPI value

boolean <a id="impl-shared.GPIValid.1"/>GPIValid(bits(4) gpi)
    return gpi IN {<a href="shared_pseudocode.html#GPT_NoAccess" title="constant bits(4) GPT_NoAccess = '0000'">GPT_NoAccess</a>,
                   <a href="shared_pseudocode.html#GPT_Secure" title="constant bits(4) GPT_Secure = '1000'">GPT_Secure</a>,
                   <a href="shared_pseudocode.html#GPT_NonSecure" title="constant bits(4) GPT_NonSecure = '1001'">GPT_NonSecure</a>,
                   <a href="shared_pseudocode.html#GPT_Root" title="constant bits(4) GPT_Root = '1010'">GPT_Root</a>,
                   <a href="shared_pseudocode.html#GPT_Realm" title="constant bits(4) GPT_Realm = '1011'">GPT_Realm</a>,
                   <a href="shared_pseudocode.html#GPT_Any" title="constant bits(4) GPT_Any = '1111'">GPT_Any</a>};</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTL0Size"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTL0Size</h3>
      <p class="pseudocode">// GPTL0Size()
// ===========
// Returns number of bits covered by a level 0 GPT entry

integer <a id="impl-shared.GPTL0Size.0"/>GPTL0Size()
    case GPCCR_EL3.L0GPTSZ of
        when '0000' return <a href="shared_pseudocode.html#GPTRange_1GB" title="constant integer GPTRange_1GB = 30">GPTRange_1GB</a>;
        when '0100' return <a href="shared_pseudocode.html#GPTRange_16GB" title="constant integer GPTRange_16GB = 34">GPTRange_16GB</a>;
        when '0110' return <a href="shared_pseudocode.html#GPTRange_64GB" title="constant integer GPTRange_64GB = 36">GPTRange_64GB</a>;
        when '1001' return <a href="shared_pseudocode.html#GPTRange_512GB" title="constant integer GPTRange_512GB = 39">GPTRange_512GB</a>;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return 30;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTLevel0Index"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTLevel0Index</h3>
      <p class="pseudocode">// GPTLevel0Index()
// ================
// Compute the level 0 index based on input PA.

integer <a id="impl-shared.GPTLevel0Index.1"/>GPTLevel0Index(bits(56) pa)
    // Input address and index bounds
    pps = <a href="shared_pseudocode.html#impl-shared.DecodePPS.0" title="function: integer DecodePPS()">DecodePPS</a>();
    l0sz = <a href="shared_pseudocode.html#impl-shared.GPTL0Size.0" title="function: integer GPTL0Size()">GPTL0Size</a>();
    if pps &lt;= l0sz then
        return 0;

    return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;pps-1:l0sz&gt;);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTLevel1Index"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTLevel1Index</h3>
      <p class="pseudocode">// GPTLevel1Index()
// ================
// Compute the level 1 index based on input PA.

integer <a id="impl-shared.GPTLevel1Index.1"/>GPTLevel1Index(bits(56) pa)
    // Input address and index bounds
    l0sz = <a href="shared_pseudocode.html#impl-shared.GPTL0Size.0" title="function: integer GPTL0Size()">GPTL0Size</a>();
    case <a href="shared_pseudocode.html#impl-shared.DecodePGS.1" title="function: PGSe DecodePGS(bits(2) pgs)">DecodePGS</a>(GPCCR_EL3.PGS) of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;l0sz-1:16&gt;);
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;l0sz-1:18&gt;);
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;l0sz-1:20&gt;);
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTWalk"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTWalk</h3>
      <p class="pseudocode">// GPTWalk()
// =========
// Get the GPT entry for a given physical address, pa

(GPCFRecord, GPTEntry) <a id="impl-shared.GPTWalk.2"/>GPTWalk(bits(56) pa, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)

    // GPT base address
    bits(56) base;
    pgs = <a href="shared_pseudocode.html#impl-shared.DecodePGS.1" title="function: PGSe DecodePGS(bits(2) pgs)">DecodePGS</a>(GPCCR_EL3.PGS);

    // The level 0 GPT base address is aligned to the greater of:
    // * the size of the level 0 GPT, determined by GPCCR_EL3.{PPS, L0GPTSZ}.
    // * 4KB
    base = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(GPTBR_EL3.BADDR:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12), 56);
    pps = <a href="shared_pseudocode.html#impl-shared.DecodePPS.0" title="function: integer DecodePPS()">DecodePPS</a>();
    l0sz = <a href="shared_pseudocode.html#impl-shared.GPTL0Size.0" title="function: integer GPTL0Size()">GPTL0Size</a>();
    integer alignment = <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>((pps - l0sz) + 3, 12);
    base = base AND NOT <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(alignment), 56);

    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> gptaccdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescGPTW.1" title="function: AccessDescriptor CreateAccDescGPTW(AccessDescriptor accdesc_in)">CreateAccDescGPTW</a>(accdesc);

    // Access attributes and address for GPT fetches
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> gptaddrdesc;
    gptaddrdesc.memattrs = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(GPCCR_EL3.SH, GPCCR_EL3.ORGN, GPCCR_EL3.IRGN);
    gptaddrdesc.fault    = <a href="shared_pseudocode.html#impl-shared.NoFault.1" title="function: FaultRecord NoFault(AccessDescriptor accdesc)">NoFault</a>(gptaccdesc);

    // Address of level 0 GPT entry
    gptaddrdesc.paddress.paspace = <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>;
    gptaddrdesc.paddress.address = base + <a href="shared_pseudocode.html#impl-shared.GPTLevel0Index.1" title="function: integer GPTLevel0Index(bits(56) pa)">GPTLevel0Index</a>(pa) * 8;

    // Fetch L0GPT entry
    bits(64) level_0_entry;
    <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
    (memstatus, level_0_entry) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(gptaddrdesc, 8, gptaccdesc);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_EABT" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_EABT</a>, 0), <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> UNKNOWN);

    <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> result;
    <a href="shared_pseudocode.html#GPTTable" title="type GPTTable is ( bits(56) address )">GPTTable</a> table;
    <a href="shared_pseudocode.html#GPCF" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF</a> gpf;
    case level_0_entry&lt;3:0&gt; of
        when <a href="shared_pseudocode.html#GPT_Block" title="constant bits(4) GPT_Block = '0001'">GPT_Block</a>
            // Decode the GPI value and return that
            (gpf, result) = <a href="shared_pseudocode.html#impl-shared.DecodeGPTBlock.2" title="function: (GPCF, GPTEntry) DecodeGPTBlock(PGSe pgs, bits(64) entry)">DecodeGPTBlock</a>(pgs, level_0_entry);
            result.pa = pa;
            return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(gpf, 0), result);
        when <a href="shared_pseudocode.html#GPT_Table" title="constant bits(4) GPT_Table = '0011'">GPT_Table</a>
            // Decode the table entry and continue walking
            (gpf, table) = <a href="shared_pseudocode.html#impl-shared.DecodeGPTTable.2" title="function: (GPCF, GPTTable) DecodeGPTTable(PGSe pgs, bits(64) entry)">DecodeGPTTable</a>(pgs, level_0_entry);
            if gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
                return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(gpf, 0), <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> UNKNOWN);
        otherwise
            // GPF - invalid encoding
            return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, 0), <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> UNKNOWN);

    // Must be a GPT Table entry
    assert level_0_entry&lt;3:0&gt; == <a href="shared_pseudocode.html#GPT_Table" title="constant bits(4) GPT_Table = '0011'">GPT_Table</a>;

    // Address of level 1 GPT entry
    offset = <a href="shared_pseudocode.html#impl-shared.GPTLevel1Index.1" title="function: integer GPTLevel1Index(bits(56) pa)">GPTLevel1Index</a>(pa) * 8;
    gptaddrdesc.paddress.address = table.address + offset;

    // Fetch L1GPT entry
    bits(64) level_1_entry;
    (memstatus, level_1_entry) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(gptaddrdesc, 8, gptaccdesc);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_EABT" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_EABT</a>, 1), <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> UNKNOWN);

    case level_1_entry&lt;3:0&gt; of
        when <a href="shared_pseudocode.html#GPT_Contig" title="constant bits(4) GPT_Contig = '0001'">GPT_Contig</a>
            (gpf, result) = <a href="shared_pseudocode.html#impl-shared.DecodeGPTContiguous.2" title="function: (GPCF, GPTEntry) DecodeGPTContiguous(PGSe pgs, bits(64) entry)">DecodeGPTContiguous</a>(pgs, level_1_entry);
        otherwise
            gpi_index = <a href="shared_pseudocode.html#impl-shared.GPIIndex.1" title="function: integer GPIIndex(bits(56) pa)">GPIIndex</a>(pa);
            (gpf, result) = <a href="shared_pseudocode.html#impl-shared.DecodeGPTGranules.3" title="function: (GPCF, GPTEntry) DecodeGPTGranules(PGSe pgs, integer index, bits(64) entry)">DecodeGPTGranules</a>(pgs, gpi_index, level_1_entry);

    if gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
        return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(gpf, 1), <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level, bits(56) pa )">GPTEntry</a> UNKNOWN);

    result.pa = pa;
    return (<a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>(), result);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GranuleProtectionCheck"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GranuleProtectionCheck</h3>
      <p class="pseudocode">// GranuleProtectionCheck()
// ========================
// Returns whether a given access is permitted, according to the
// granule protection check.
// addrdesc and accdesc describe the access to be checked.

GPCFRecord <a id="impl-shared.GranuleProtectionCheck.2"/>GranuleProtectionCheck(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> addrdesc, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc)

    assert <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>();
    // The address to be checked
    address = addrdesc.paddress;

    // Bypass mode - all accesses pass
    if GPCCR_EL3.GPC == '0' then
        return <a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>();

    // Configuration consistency check
    if !<a href="shared_pseudocode.html#impl-shared.GPCRegistersConsistent.0" title="function: boolean GPCRegistersConsistent()">GPCRegistersConsistent</a>() then
        return <a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, 0);

    // Input address size check
    if <a href="shared_pseudocode.html#impl-shared.AbovePPS.1" title="function: boolean AbovePPS(bits(56) address)">AbovePPS</a>(address.address) then
        if address.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
            return <a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>();
        else
            return <a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_Fail" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Fail</a>, 0);

    // GPT base address size check
    bits(56) gpt_base = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(GPTBR_EL3.BADDR:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12), 56);
    if <a href="shared_pseudocode.html#impl-shared.AbovePPS.1" title="function: boolean AbovePPS(bits(56) address)">AbovePPS</a>(gpt_base) then
        return <a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_AddressSize" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_AddressSize</a>, 0);

    // GPT lookup
    (gpcf, gpt_entry) = <a href="shared_pseudocode.html#impl-shared.GPTWalk.2" title="function: (GPCFRecord, GPTEntry) GPTWalk(bits(56) pa, AccessDescriptor accdesc)">GPTWalk</a>(address.address, accdesc);
    if gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
        return gpcf;

    // Check input physical address space against GPI
    permitted = <a href="shared_pseudocode.html#impl-shared.GPICheck.2" title="function: boolean GPICheck(PASpace paspace, bits(4) gpi)">GPICheck</a>(address.paspace, gpt_entry.gpi);

    if !permitted then
        gpcf = <a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_Fail" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Fail</a>, gpt_entry.level);
        return gpcf;

    // Check passed

    return <a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.PGS"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/PGS</h3>
      <p class="pseudocode">enumeration <a id="PGSe"/>PGSe {
    <a id="PGS_4KB"/>PGS_4KB,
    <a id="PGS_16KB"/>PGS_16KB,
    <a id="PGS_64KB"/>PGS_64KB
};</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.Table"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/Table</h3>
      <p class="pseudocode">constant bits(4) <a id="GPT_NoAccess"/>GPT_NoAccess  = '0000';
constant bits(4) <a id="GPT_Table"/>GPT_Table     = '0011';
constant bits(4) <a id="GPT_Block"/>GPT_Block     = '0001';
constant bits(4) <a id="GPT_Contig"/>GPT_Contig    = '0001';
constant bits(4) <a id="GPT_Secure"/>GPT_Secure    = '1000';
constant bits(4) <a id="GPT_NonSecure"/>GPT_NonSecure = '1001';
constant bits(4) <a id="GPT_Root"/>GPT_Root      = '1010';
constant bits(4) <a id="GPT_Realm"/>GPT_Realm     = '1011';
constant bits(4) <a id="GPT_Any"/>GPT_Any       = '1111';
constant integer <a id="GPTRange_4KB"/>GPTRange_4KB   = 12;
constant integer <a id="GPTRange_16KB"/>GPTRange_16KB  = 14;
constant integer <a id="GPTRange_64KB"/>GPTRange_64KB  = 16;
constant integer <a id="GPTRange_2MB"/>GPTRange_2MB   = 21;
constant integer <a id="GPTRange_32MB"/>GPTRange_32MB  = 25;
constant integer <a id="GPTRange_512MB"/>GPTRange_512MB = 29;
constant integer <a id="GPTRange_1GB"/>GPTRange_1GB   = 30;
constant integer <a id="GPTRange_16GB"/>GPTRange_16GB  = 34;
constant integer <a id="GPTRange_64GB"/>GPTRange_64GB  = 36;
constant integer <a id="GPTRange_512GB"/>GPTRange_512GB = 39;

type <a id="GPTTable"/>GPTTable is (
    bits(56) address        // Base address of next table
)

type <a id="GPTEntry"/>GPTEntry is (
    bits(4)  gpi,           // GPI value for this region
    integer  size,          // Region size
    integer  contig_size,   // Contiguous region size
    integer  level,         // Level of GPT lookup
    bits(56) pa             // PA uniquely identifying the GPT entry
)</p>
    </div>
    <div class="ps"><a id="shared.translation.translation.S1TranslationRegime"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/translation/S1TranslationRegime</h3>
      <p class="pseudocode">// S1TranslationRegime()
// =====================
// Stage 1 translation regime for the given Exception level

bits(2) <a id="impl-shared.S1TranslationRegime.1"/>S1TranslationRegime(bits(2) el)
    if el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        return el;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.NS == '0' then
        return <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(el) then
        return <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        return <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

// S1TranslationRegime()
// =====================
// Returns the Exception level controlling the current Stage 1 translation regime. For the most
// part this is unused in code because the System register accessors (SCTLR[], etc.) implicitly
// return the correct value.

bits(2) <a id="impl-shared.S1TranslationRegime.0"/>S1TranslationRegime()
    return <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.AddressDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/AddressDescriptor</h3>
      <p class="pseudocode">type <a id="AddressDescriptor"/>AddressDescriptor is (
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a>      fault,      // fault.statuscode indicates whether the address is valid
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs,
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a>      paddress,
    boolean          s1assured,  // Stage 1 Assured Translation Property
    boolean          s2fs1mro,   // Stage 2 MRO permission for Satge 1
    bits(16)         mecid,      // FEAT_MEC: Memory Encryption Context ID
    bits(64)         vaddress
)

constant integer <a id="FINAL_LEVEL"/>FINAL_LEVEL = 3;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.ContiguousSize"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/ContiguousSize</h3>
      <p class="pseudocode">// ContiguousSize()
// ================
// Return the number of entries log 2 marking a contiguous output range

integer <a id="impl-shared.ContiguousSize.3"/>ContiguousSize(bit d128, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    if d128 == '1' then
        return 4;
    else
        case tgx of
            when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>
                assert level != 0;
                return 4;
            when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>
                assert level IN {2, 3};
                return if level == 2 then 5 else 7;
            when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>
                assert level != 1;
                return 5;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.CreateAddressDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/CreateAddressDescriptor</h3>
      <p class="pseudocode">// CreateAddressDescriptor()
// =========================
// Set internal members for address descriptor type to valid values

AddressDescriptor <a id="impl-shared.CreateAddressDescriptor.3"/>CreateAddressDescriptor(bits(64) va, <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> pa,
                                          <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a> memattrs)
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> addrdesc;

    addrdesc.paddress = pa;
    addrdesc.vaddress = va;
    addrdesc.memattrs = memattrs;
    addrdesc.fault    = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
    addrdesc.s1assured = FALSE;

    return addrdesc;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.CreateFaultyAddressDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/CreateFaultyAddressDescriptor</h3>
      <p class="pseudocode">// CreateFaultyAddressDescriptor()
// ===============================
// Set internal members for address descriptor type with values indicating error

AddressDescriptor <a id="impl-shared.CreateFaultyAddressDescriptor.2"/>CreateFaultyAddressDescriptor(bits(64) va, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault)
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> addrdesc;

    addrdesc.vaddress = va;
    addrdesc.fault    = fault;

    return addrdesc;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.DescriptorType"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/DescriptorType</h3>
      <p class="pseudocode">enumeration <a id="DescriptorType"/>DescriptorType {
    <a id="DescriptorType_Table"/>DescriptorType_Table,
    <a id="DescriptorType_Leaf"/>DescriptorType_Leaf,
    <a id="DescriptorType_Invalid"/>DescriptorType_Invalid
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.Domains"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/Domains</h3>
      <p class="pseudocode">constant bits(2) <a id="Domain_NoAccess"/>Domain_NoAccess = '00';
constant bits(2) <a id="Domain_Client"/>Domain_Client   = '01';
constant bits(2) <a id="Domain_Manager"/>Domain_Manager  = '11';</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.FetchDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/FetchDescriptor</h3>
      <p class="pseudocode">// FetchDescriptor()
// =================
// Fetch a translation table descriptor

(FaultRecord, bits(N)) <a id="impl-shared.FetchDescriptor.5"/>FetchDescriptor(bit ee, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, boolean s1assured, boolean s2fs1mro, bits(16) mecid, bits(64) vaddress )">AddressDescriptor</a> walkaddress,
                                       <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> walkaccess, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault_in,
                                       integer N)
    // 32-bit descriptors for AArch32 Short-descriptor format
    // 64-bit descriptors for AArch64 or AArch32 Long-descriptor format
    // 128-bit descriptors for AArch64 when FEAT_D128 is set and {V}TCR_ELx.d128 is set
    assert N == 32 || N == 64 || N == 128;
    bits(N) descriptor;
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is ( Fault statuscode, AccessDescriptor access, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, boolean tagaccess, integer level, bit extflag, boolean secondstage, boolean assuredonly, boolean toplevel, boolean overlay, boolean dirtybit, bits(4) domain, ErrorState merrorstate, bits(4) debugmoe )">FaultRecord</a> fault = fault_in;

    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(walkaddress, walkaccess);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_TagCheck,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnWalk</a>;
            fault.paddress   = walkaddress.paddress;
            fault.gpcfs2walk = fault.secondstage;
            return (fault, bits(N) UNKNOWN);

    <a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is ( Fault statuscode, bit extflag, ErrorState merrorstate, bits(64) store64bstatus )">PhysMemRetStatus</a> memstatus;
    (memstatus, descriptor) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(walkaddress, N DIV 8, walkaccess);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        boolean iswrite = FALSE;
        fault = <a href="shared_pseudocode.html#impl-shared.HandleExternalTTWAbort.6" title="function: FaultRecord HandleExternalTTWAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc,&#13; AccessDescriptor accdesc, integer size,&#13; FaultRecord input_fault)">HandleExternalTTWAbort</a>(memstatus, iswrite, walkaddress,
                                       walkaccess, N DIV 8, fault);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(fault.statuscode) then
            return (fault, bits(N) UNKNOWN);

    if ee == '1' then
        descriptor = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(descriptor);

    return (fault, descriptor);</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.HasUnprivileged"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/HasUnprivileged</h3>
      <p class="pseudocode">// HasUnprivileged()
// =================
// Returns whether a translation regime serves EL0 as well as a higher EL

boolean <a id="impl-shared.HasUnprivileged.1"/>HasUnprivileged(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    return (regime IN {
        <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>,
        <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a>,
        <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>
    });</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.Regime"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/Regime</h3>
      <p class="pseudocode">enumeration <a id="Regime"/>Regime {
    <a id="Regime_EL3"/>Regime_EL3,            // EL3
    <a id="Regime_EL30"/>Regime_EL30,           // EL3&amp;0 (PL1&amp;0 when EL3 is AArch32)
    <a id="Regime_EL2"/>Regime_EL2,            // EL2
    <a id="Regime_EL20"/>Regime_EL20,           // EL2&amp;0
    <a id="Regime_EL10"/>Regime_EL10            // EL1&amp;0
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.RegimeUsingAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/RegimeUsingAArch32</h3>
      <p class="pseudocode">// RegimeUsingAArch32()
// ====================
// Determine if the EL controlling the regime executes in AArch32 state

boolean <a id="impl-shared.RegimeUsingAArch32.1"/>RegimeUsingAArch32(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> return TRUE;
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return FALSE;
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.S1TTWParams"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/S1TTWParams</h3>
      <p class="pseudocode">type S1TTWParams is (
// A64-VMSA exclusive parameters
    bit         ha,         // TCR_ELx.HA
    bit         hd,         // TCR_ELx.HD
    bit         tbi,        // TCR_ELx.TBI{x}
    bit         tbid,       // TCR_ELx.TBID{x}
    bit         nfd,        // TCR_EL1.NFDx or TCR_EL2.NFDx when HCR_EL2.E2H == '1'
    bit         e0pd,       // TCR_EL1.E0PDx or TCR_EL2.E0PDx when HCR_EL2.E2H == '1'
    bit         d128,       // TCR_ELx.D128
    bit         aie,         // (TCR2_ELx/TCR_EL3).AIE
    MAIRType    mair2,       // MAIR2_ELx
    bit         ds,         // TCR_ELx.DS
    bits(3)     ps,         // TCR_ELx.{I}PS
    bits(6)     txsz,       // TCR_ELx.TxSZ
    bit         epan,       // SCTLR_EL1.EPAN or SCTLR_EL2.EPAN when HCR_EL2.E2H == '1'
    bit         dct,        // HCR_EL2.DCT
    bit         nv1,        // HCR_EL2.NV1
    bit         cmow,       // SCTLR_EL1.CMOW or SCTLR_EL2.CMOW when HCR_EL2.E2H == '1'
    bit         pnch,       // TCR{2}_ELx.PnCH
    bit         disch,      // TCR{2}_ELx.DisCH
    bit         haft,       // TCR{2}_ELx.HAFT
    bit         mtx,        // TCR_ELx.MTX{y}
    bits(2)     skl,        // TCR_ELx.SKL
    bit         pie,        // TCR2_ELx.PIE or TCR_EL3.PIE
    S1PIRType   pir,        // PIR_ELx
    S1PIRType   pire0,      // PIRE0_EL1 or PIRE0_EL2 when HCR_EL2.E2H == '1'
    bit         mecrl,      // SCTLR2_EL2.MECRL or SCTLR2_EL3.MECRL
    bit         amec,       // TCR2_EL2.AMEC0 or TCR2_EL2.AMEC1 when HCR_EL2.E2H == '1'

// A32-VMSA exclusive parameters
    bits(3)     t0sz,       // TTBCR.T0SZ
    bits(3)     t1sz,       // TTBCR.T1SZ
    bit         uwxn,       // SCTLR.UWXN

// Parameters common to both A64-VMSA &amp; A32-VMSA (A64/A32)
    <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a>         tgx,        // TCR_ELx.TGx      / Always TGx_4KB
    bits(2)     irgn,       // TCR_ELx.IRGNx    / TTBCR.IRGNx or HTCR.IRGN0
    bits(2)     orgn,       // TCR_ELx.ORGNx    / TTBCR.ORGNx or HTCR.ORGN0
    bits(2)     sh,         // TCR_ELx.SHx      / TTBCR.SHx or HTCR.SH0
    bit         hpd,        // TCR_ELx.HPD{x}   / TTBCR2.HPDx or HTCR.HPD
    bit         ee,         // SCTLR_ELx.EE     / SCTLR.EE or HSCTLR.EE
    bit         wxn,        // SCTLR_ELx.WXN    / SCTLR.WXN or HSCTLR.WXN
    bit         ntlsmd,     // SCTLR_ELx.nTLSMD / SCTLR.nTLSMD or HSCTLR.nTLSMD
    bit         dc,         // HCR_EL2.DC       / HCR.DC
    bit         sif,        // SCR_EL3.SIF      / SCR.SIF
    MAIRType    mair        // MAIR_ELx         / MAIR1:MAIR0 or HMAIR1:HMAIR0
)</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.S2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/S2TTWParams</h3>
      <p class="pseudocode">type S2TTWParams is (
// A64-VMSA exclusive parameters
    bit         ha,         // VTCR_EL2.HA
    bit         hd,         // VTCR_EL2.HD
    bit         sl2,        // V{S}TCR_EL2.SL2
    bit         ds,         // VTCR_EL2.DS
    bit         d128,       // VTCR_ELx.D128
    bit         sw,         // VSTCR_EL2.SW
    bit         nsw,        // VTCR_EL2.NSW
    bit         sa,         // VSTCR_EL2.SA
    bit         nsa,        // VTCR_EL2.NSA
    bits(3)     ps,         // VTCR_EL2.PS
    bits(6)     txsz,       // V{S}TCR_EL2.T0SZ
    bit         fwb,        // HCR_EL2.PTW
    bit         cmow,       // HCRX_EL2.CMOW
    bits(2)     skl,        // VTCR_EL2.SKL
    bit         s2pie,      // VTCR_EL2.S2PIE
    S2PIRType   s2pir,      // S2PIR_EL2
    bit         tl0,        // VTCR_EL2.TL0
    bit         tl1,        // VTCR_EL2.TL1
    bit         assuredonly,// VTCR_EL2.AssuredOnly
    bit         haft,       // VTCR_EL2.HAFT
    bit         mecrl,      // SCTLR2_EL2.MECRL

// A32-VMSA exclusive parameters
    bit         s,          // VTCR.S
    bits(4)     t0sz,       // VTCR.T0SZ

// Parameters common to both A64-VMSA &amp; A32-VMSA if implemented (A64/A32)
    <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a>         tgx,        // V{S}TCR_EL2.TG0  / Always TGx_4KB
    bits(2)     sl0,        // V{S}TCR_EL2.SL0  / VTCR.SL0
    bits(2)     irgn,       // VTCR_EL2.IRGN0   / VTCR.IRGN0
    bits(2)     orgn,       // VTCR_EL2.ORGN0   / VTCR.ORGN0
    bits(2)     sh,         // VTCR_EL2.SH0     / VTCR.SH0
    bit         ee,         // SCTLR_EL2.EE     / HSCTLR.EE
    bit         ptw,        // HCR_EL2.PTW      / HCR.PTW
    bit         vm          // HCR_EL2.VM       / HCR.VM
)</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.SDFType"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/SDFType</h3>
      <p class="pseudocode">enumeration <a id="SDFType"/>SDFType {
    <a id="SDFType_Table"/>SDFType_Table,
    <a id="SDFType_Invalid"/>SDFType_Invalid,
    <a id="SDFType_Supersection"/>SDFType_Supersection,
    <a id="SDFType_Section"/>SDFType_Section,
    <a id="SDFType_LargePage"/>SDFType_LargePage,
    <a id="SDFType_SmallPage"/>SDFType_SmallPage
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.SecurityStateForRegime"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/SecurityStateForRegime</h3>
      <p class="pseudocode">// SecurityStateForRegime()
// ========================
// Return the Security State of the given translation regime

SecurityState <a id="impl-shared.SecurityStateForRegime.1"/>SecurityStateForRegime(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>     return <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a>    return <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>; // A32 EL3 is always Secure
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>     return <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>    return <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>    return <a href="shared_pseudocode.html#impl-shared.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.StageOA"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/StageOA</h3>
      <p class="pseudocode">// StageOA()
// =========
// Given the final walk state (a page or block descriptor), map the untranslated
// input address bits to the output address

FullAddress <a id="impl-shared.StageOA.4"/>StageOA(bits(64) ia, bit d128, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate)
    // Output Address
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a> oa;
    integer csize;

    tsize = <a href="shared_pseudocode.html#impl-shared.TranslationSize.3" title="function: integer TranslationSize(bit d128, TGx tgx, integer level)">TranslationSize</a>(d128, tgx, walkstate.level);
    if walkstate.contiguous == '1' then
        csize = <a href="shared_pseudocode.html#impl-shared.ContiguousSize.3" title="function: integer ContiguousSize(bit d128, TGx tgx, integer level)">ContiguousSize</a>(d128, tgx, walkstate.level);
    else
        csize = 0;

    ia_msb = tsize + csize;
    oa.paspace = walkstate.baseaddress.paspace;
    oa.address = walkstate.baseaddress.address&lt;55:ia_msb&gt;:ia&lt;ia_msb-1:0&gt;;

    return oa;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TGx"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TGx</h3>
      <p class="pseudocode">enumeration <a id="TGx"/>TGx {
    <a id="TGx_4KB"/>TGx_4KB,
    <a id="TGx_16KB"/>TGx_16KB,
    <a id="TGx_64KB"/>TGx_64KB
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TGxGranuleBits"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TGxGranuleBits</h3>
      <p class="pseudocode">// TGxGranuleBits()
// ================
// Retrieve the address size, in bits, of a granule

integer <a id="impl-shared.TGxGranuleBits.1"/>TGxGranuleBits(<a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    case tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  return 12;
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> return 14;
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> return 16;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TLBContext"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TLBContext</h3>
      <p class="pseudocode">type <a id="TLBContext"/>TLBContext is (
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,
    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a>        regime,
    bits(16)      vmid,
    bits(16)      asid,
    bit           nG,
    <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a>       ipaspace, // Used in stage 2 lookups &amp; invalidations only
    boolean       includes_s1,
    boolean       includes_s2,
    boolean       includes_gpt,
    bits(64)      ia,       // Input Address
    <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a>           tg,
    bit           cnp,
    integer       level,    // Assist TLBI level hints (FEAT_TTL)
    boolean       isd128,
    bit           xs        // XS attribute (FEAT_XS)
)</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TLBRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TLBRecord</h3>
      <p class="pseudocode">type <a id="TLBRecord"/>TLBRecord is (
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a>  context,
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, boolean s1assured, bit s2assuredonly, bit disch, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    walkstate,
    integer     blocksize,    // Number of bits directly mapped from IA to OA
    integer     contigsize,   // Number of entries log 2 marking a contiguous output range
    bits(128)   s1descriptor, // Stage 1 leaf descriptor in memory (valid if the TLB caches stage 1)
    bits(128)   s2descriptor  // Stage 2 leaf descriptor in memory (valid if the TLB caches stage 2)
)</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TTWState"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TTWState</h3>
      <p class="pseudocode">type <a id="TTWState"/>TTWState is (
    boolean             istable,
    integer             level,
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(56) address )">FullAddress</a>         baseaddress,
    bit                 contiguous,
    boolean             s1assured,      // Stage 1 Assured Translation Property
    bit                 s2assuredonly,  // Stage 2 AssuredOnly attribute
    bit                 disch,          // Stage 1 Disable Contiguous Hint
    bit                 nG,
    bit                 guardedpage,
    <a href="shared_pseudocode.html#SDFType" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a>             sdftype,    // AArch32 Short-descriptor format walk only
    bits(4)             domain,     // AArch32 Short-descriptor format walk only
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, MemTagType tags, boolean notagaccess, bit xs )">MemoryAttributes</a>    memattrs,
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(4) ppi, bits(4) upi, bit ndirty, bits(4) s2pi, bit s2dirty, bits(4) po_index, bits(4) s2po_index, bits(2) s2ap, bit s2tag_na, bit s2xnx, bit s2xn )">Permissions</a>         permissions
)</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TranslationRegime"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TranslationRegime</h3>
      <p class="pseudocode">// TranslationRegime()
// ===================
// Select the translation regime given the target EL and PE state

Regime <a id="impl-shared.TranslationRegime.1"/>TranslationRegime(bits(2) el)
    if el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        return if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> else <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>;
    elsif el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        return if <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> else <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
    elsif el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
        return <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    elsif el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        if <a href="shared_pseudocode.html#impl-shared.CurrentSecurityState.0" title="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            return <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a>;
        elsif <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>) then
            return <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>;
        else
            return <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    else
        <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TranslationSize"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TranslationSize</h3>
      <p class="pseudocode">// TranslationSize()
// =================
// Compute the number of bits directly mapped from the input address
// to the output address

integer <a id="impl-shared.TranslationSize.3"/>TranslationSize(bit d128, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(tgx);
    descsizelog2 = if d128 == '1' then 4 else 3;
    blockbits   = (<a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - level) * (granulebits - descsizelog2);

    return granulebits + blockbits;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.UseASID"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/UseASID</h3>
      <p class="pseudocode">// UseASID()
// =========
// Determine whether the translation context for the access requires ASID or is a global entry

boolean <a id="impl-shared.UseASID.1"/>UseASID(<a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> access)
    return <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(access.regime);</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.UseVMID"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/UseVMID</h3>
      <p class="pseudocode">// UseVMID()
// =========
// Determine whether the translation context for the access requires VMID to match a TLB entry

boolean <a id="impl-shared.UseVMID.1"/>UseVMID(<a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, integer level, boolean isd128, bit xs )">TLBContext</a> access)
    return access.regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();</p>
    </div>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v33.53, AdvSIMD v29.11, pseudocode v2022-09_rel, sve v2022-09_rel
      ; Build timestamp: 2022-09-30T16:37
    </p><p class="copyconf">
      Copyright © 2010-2022 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
