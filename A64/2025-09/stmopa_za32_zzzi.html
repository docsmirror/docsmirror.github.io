<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>STMOPA (2-way) -- A64</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">STMOPA (2-way)</h2><p>Signed 16-bit integer sparse sum of outer products to 32-bit integer, accumulating</p>
      <p class="aml">This instruction generates signed integer sum of outer
products by multiplying the 2-in-4 selected elements from the
dense sub-matrices in the two first source vectors with the corresponding
elements of the compressed sparse sub-matrix in the second source vector
and accumulates the results to the corresponding elements of
a 32-bit element ZA tile.</p>
      <p class="aml">The sum of outer products is generated by multiplying the selected 2-in-4 16-bit signed
values from each overlapping 32-bit containers of the two SVL<sub>S</sub>×2 sub-matrices in
the first source vectors by the two 16-bit signed
values from the corresponding 32-bit container of the
2×SVL<sub>S</sub> sub-matrix in the second source vector.
The two selected elements from each overlapping 32-bit containers of
the first source vectors correspond to 2-in-4 elements of
rows of two SVL<sub>S</sub>×2 sub-matrices. Each 32-bit container of the
second source vector holds 2 elements of columns of a compressed
2×SVL<sub>S</sub> sub-matrix.</p>
      <p class="aml">The 2-in-4 16-bit signed values from overlapping 32-bit
containers of the first source vectors are selected by
4-bit controls in the indexed segment of the control vector register.
If the control bit corresponding
to an element in the first source vectors is 0, the element is discarded
and does not contribute to the sum of products result. If more than two bits
of the 4-bit control corresponding to 32-bit containers of the first source vectors are 1,
only the elements corresponding to the least two significant bits are selected.</p>
      <p class="aml">The resulting SVL<sub>S</sub>×SVL<sub>S</sub> widened 32-bit integer
sum of outer products is then destructively added to the 32-bit integer
destination tile. This is equivalent to performing a 2-way dot product and
accumulate to each of the destination tile elements.</p>
      <p class="aml">This instruction is unpredicated.</p>
    
    <h3 class="classheading"><a id="iclass_sme2"/>SME2<span style="font-size:smaller;"><br/>(FEAT_SME_TMOP)
          </span></h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">1</td><td class="l">0</td><td class="r">0</td><td class="l">0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">0</td><td class="l">0</td><td class="r">1</td><td class="lr">0</td><td colspan="5" class="lr">Zm</td><td class="lr">1</td><td class="lr">0</td><td class="lr">0</td><td class="lr">K</td><td colspan="2" class="lr">Zk</td><td colspan="4" class="lr">Zn</td><td colspan="2" class="lr">i2</td><td class="lr">1</td><td class="lr">0</td><td colspan="2" class="lr">ZAda</td></tr><tr class="secondrow"><td/><td colspan="2"/><td colspan="4"/><td class="droppedname">u0</td><td colspan="2"/><td/><td colspan="5"/><td/><td/><td/><td/><td colspan="2"/><td colspan="4"/><td colspan="2"/><td/><td/><td colspan="2"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Encoding</h4><a id="stmopa_za32_zzzi_h2x1"/><p class="asm-code">STMOPA  <a href="#ZAda" title="For the &quot;Single-precision&quot; variant: is the name of the ZA tile ZA0-ZA3, encoded in the &quot;ZAda&quot; field.">&lt;ZAda&gt;</a>.S, { <a href="#Zn1__2" title="Is the name of the first scalable vector register of the first source multi-vector group, encoded as &quot;Zn&quot; times 2.">&lt;Zn1&gt;</a>.H-<a href="#Zn2__2" title="Is the name of the second scalable vector register of the first source multi-vector group, encoded as &quot;Zn&quot; times 2 plus 1.">&lt;Zn2&gt;</a>.H }, <a href="#Zm" title="Is the name of the second source scalable vector register, encoded in the &quot;Zm&quot; field.">&lt;Zm&gt;</a>.H, <a href="#Zk__2" title="Is the name of the control vector register Z20-Z23 or Z28-Z31, encoded in the &quot;K:Zk&quot; fields.">&lt;Zk&gt;</a>[<a href="#index_i2_control_seg_idx" title="Is the control segment index, in the range 0 to 3, encoded in the &quot;i2&quot; field.">&lt;index&gt;</a>]</p></div><h4>Decode for this encoding</h4><p class="pseudocode">if !IsFeatureImplemented(FEAT_SME_TMOP) then EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>); end;
let n : integer = UInt(Zn::'0');
let m : integer = UInt(Zm);
let k : integer = UInt('1'::K::'1'::Zk);
let index : integer = UInt(i2);
let da : integer = UInt(ZAda);
let unsigned : boolean = FALSE;</p>
  <div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;ZAda&gt;</td><td><a id="ZAda"/>
        
          <p class="aml">Is the name of the ZA tile ZA0-ZA3, encoded in the "ZAda" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zn1&gt;</td><td><a id="Zn1__2"/>
        
          <p class="aml">Is the name of the first scalable vector register of the first source multi-vector group, encoded as "Zn" times 2.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zn2&gt;</td><td><a id="Zn2__2"/>
        
          <p class="aml">Is the name of the second scalable vector register of the first source multi-vector group, encoded as "Zn" times 2 plus 1.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zm&gt;</td><td><a id="Zm"/>
        
          <p class="aml">Is the name of the second source scalable vector register, encoded in the "Zm" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zk&gt;</td><td><a id="Zk__2"/>
        
          <p class="aml">Is the name of the control vector register Z20-Z23 or Z28-Z31, encoded in the "K:Zk" fields.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;index&gt;</td><td><a id="index_i2_control_seg_idx"/>
        
          <p class="aml">Is the control segment index, in the range 0 to 3, encoded in the "i2" field.</p>
        
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id=""/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">CheckStreamingSVEAndZAEnabled();
let VL : integer{} = CurrentVL();
let dim : integer{} = VL DIV 32;
let csize : integer{} = VL DIV 8;
let op2 : bits(VL) = Z{}(m);
let op3 : bits(VL) = Z{}(k);
let ctrl : bits(csize) = op3[index*:csize];
let op4 : bits(dim*dim*32) = ZAtile{}(da, 32);
var result : bits(dim*dim*32);

for row = 0 to dim-1 do
    for col = 0 to dim-1 do
        var erow : array [[2]] of bits(16);
        var ecol : array [[2]] of bits(16);
        for j = 0 to 1 do
            erow[[j]] = Zeros{16};
            ecol[[j]] = op2[(2*col + j)*:16];
        end;
        var i : integer = 0;
        for r = 0 to 1 do
            let op1 : bits(VL) = Z{}(n+r);
            for e = 0 to 1 do
                if i &lt; 2 &amp;&amp; ctrl[(4*col + 2*r + e)*:1] == '1' then
                    erow[[i]] = op1[(2*row + e)*:16];
                    i = i + 1;
                end;
            end;
        end;
        var sum : bits(32) = op4[(row*dim+col)*:32];
        for j = 0 to 1 do
            let erowval : integer = if unsigned then UInt(erow[[j]]) else SInt(erow[[j]]);
            let ecolval : integer = if unsigned then UInt(ecol[[j]]) else SInt(ecol[[j]]);
            sum = sum + (erowval * ecolval);
        end;
        result[(row*dim+col)*:32] = sum;
    end;
end;
ZAtile{dim*dim*32}(da, 32) = result;</p>
    </div>
  <h3>Operational information</h3>
    
      
        <p class="aml">This instruction is a data-independent-time instruction as described in <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="ARMARM_BEICCDDAB3">About PSTATE.DIT</a>.</p>
      
    
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      2025-09_rel_asl1

      2025-10-24 12:15:02
    </p><p class="copyconf">
      Copyright © 2010-2025 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
