<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>SM3TT1B -- A64</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">SM3TT1B</h2><p>SM3TT1B</p>
      <p class="aml">This instruction takes three 128-bit vectors from three source SIMD&amp;FP
registers and a 2-bit immediate index value, and returns a 128-bit
result in the destination SIMD&amp;FP register. It performs a 32-bit
majority function between the three 32-bit fields held in the upper
three elements of the first source vector, and adds the resulting
32-bit value and the following three other 32-bit values:</p>
      <ul>
        <li>
          The bottom 32-bit element of the first source vector, Vd, that was used
  for the 32-bit majority function.
        </li>
        <li>
          The result of the exclusive-OR of the top 32-bit element of the
  second source vector, Vn, with a rotation left by 12 of the top
  32-bit element of the first source vector.
        </li>
        <li>
          A 32-bit element indexed out of the third source vector, Vm.
        </li>
      </ul>
      <p class="aml">The result of this addition is returned as the top element of the
result. The other elements of the result are taken from elements of
the first source vector, with the element returned in bits&lt;63:32&gt;
being rotated left by 9.</p>
    
    <h3 class="classheading"><a id="iclass_advanced_simd"/>Advanced SIMD<span style="font-size:smaller;"><br/>(FEAT_SM3)
          </span></h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>0</td><td class="r">0</td><td class="l">1</td><td>1</td><td class="r">1</td><td class="l">0</td><td class="r">0</td><td class="l">1</td><td class="r">0</td><td colspan="5" class="lr">Rm</td><td class="l">1</td><td class="r">0</td><td colspan="2" class="lr">imm2</td><td class="l">0</td><td class="r">1</td><td colspan="5" class="lr">Rn</td><td colspan="5" class="lr">Rd</td></tr><tr class="secondrow"><td colspan="4"/><td colspan="3"/><td colspan="2"/><td colspan="2"/><td colspan="5"/><td colspan="2"/><td colspan="2"/><td colspan="2" class="droppedname">opcode</td><td colspan="5"/><td colspan="5"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Encoding</h4><a id="SM3TT1B_VVV4_crypto3_imm2"/><p class="asm-code">SM3TT1B  <a href="#Vd__4" title="Is the name of the SIMD&amp;FP source and destination register, encoded in the &quot;Rd&quot; field.">&lt;Vd&gt;</a>.4S, <a href="#Vn__6" title="Is the name of the second SIMD&amp;FP source register, encoded in the &quot;Rn&quot; field.">&lt;Vn&gt;</a>.4S, <a href="#Vm__7" title="Is the name of the third SIMD&amp;FP source register, encoded in the &quot;Rm&quot; field.">&lt;Vm&gt;</a>.S[<a href="#index__16" title="Is a 32-bit element indexed out of &lt;Vm&gt;, encoded in &quot;imm2&quot;.">&lt;imm2&gt;</a>]</p></div><h4>Decode for this encoding</h4><p class="pseudocode">if !IsFeatureImplemented(FEAT_SM3) then EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>); end;
let d : integer{} = UInt(Rd);
let n : integer{} = UInt(Rn);
let m : integer{} = UInt(Rm);
let i : integer = UInt(imm2);</p>
  <div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Vd&gt;</td><td><a id="Vd__4"/>
        
          <p class="aml">Is the name of the SIMD&amp;FP source and destination register, encoded in the "Rd" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Vn&gt;</td><td><a id="Vn__6"/>
        
          <p class="aml">Is the name of the second SIMD&amp;FP source register, encoded in the "Rn" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Vm&gt;</td><td><a id="Vm__7"/>
        
          <p class="aml">Is the name of the third SIMD&amp;FP source register, encoded in the "Rm" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;imm2&gt;</td><td><a id="index__16"/>
        
          <p class="aml">Is a 32-bit element indexed out of &lt;Vm&gt;, encoded in "imm2".</p>
        
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id=""/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">AArch64_CheckFPAdvSIMDEnabled();

let Vm : bits(128) = V{}(m);
let Vn : bits(128) = V{}(n);
let Vd : bits(128) = V{}(d);

var WjPrime : bits(32);
var result : bits(128);
var TT1 : bits(32);
var SS2 : bits(32);

WjPrime = Vm[i*:32];
SS2 = Vn[127:96] XOR ROL(Vd[127:96], 12);
TT1 = (Vd[127:96] AND Vd[63:32]) OR (Vd[127:96] AND Vd[95:64]) OR (Vd[63:32] AND Vd[95:64]);
TT1 = (TT1 + Vd[31:0] + SS2 + WjPrime)[31:0];
result[31:0] = Vd[63:32];
result[63:32] = ROL(Vd[95:64], 9);
result[95:64] = Vd[127:96];
result[127:96] = TT1;
V{128}(d) = result;</p>
    </div>
  <h3>Operational information</h3>
    
      
        <p class="aml">This instruction is a data-independent-time instruction as described in <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="ARMARM_BEICCDDAB3">About PSTATE.DIT</a>.</p>
      
    
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      2025-09_rel_asl1

      2025-10-24 12:15:02
    </p><p class="copyconf">
      Copyright Â© 2010-2025 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
