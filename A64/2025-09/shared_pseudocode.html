<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>A64 Instruction Summary -- Shared Pseudocode</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">Shared Pseudocode Functions</h2><p>This page displays common pseudocode functions shared by many pages</p><h2 class="pseudocode">Pseudocodes</h2>
    <div class="ps"><a id="aarch32.at.AArch32_AT"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32_AT</h3>
      <p class="pseudocode">// AArch32_AT()
// ============
// Perform address translation as per AT instructions.

func AArch32_AT(vaddress : bits(32), stage_in : <a href="shared_pseudocode.html#type_TranslationStage" title="">TranslationStage</a>, el : bits(2), ataccess : <a href="shared_pseudocode.html#type_ATAccess" title="">ATAccess</a>)
begin
    var stage : <a href="shared_pseudocode.html#type_TranslationStage" title="">TranslationStage</a> = stage_in;
    var ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>;
    var regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>;
    var eae : boolean;

    // ATS1Hx instructions
    if el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        regime = <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>;
        eae = TRUE;
        ss = <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;

    // ATS1Cxx instructions
    elsif stage == <a href="shared_pseudocode.html#enum_TranslationStage_1" title="">TranslationStage_1</a> || (stage == <a href="shared_pseudocode.html#enum_TranslationStage_12" title="">TranslationStage_12</a> &amp;&amp; !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>)) then
        stage = <a href="shared_pseudocode.html#enum_TranslationStage_1" title="">TranslationStage_1</a>;
        ss = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(PSTATE.EL);
        regime = if ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> else <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>;
        eae = TTBCR().EAE == '1';

    // ATS12NSOxx instructions
    else
        regime = <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>;
        eae = (if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then TTBCR_NS().EAE == '1'
                                                     else TTBCR().EAE == '1');
        ss = <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;
    end;

    var addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    var sdftype : <a href="shared_pseudocode.html#type_SDFType" title="">SDFType</a>;
    let aligned : boolean = TRUE;
    var supersection : bit = '0';

    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescAT_3" title="">CreateAccDescAT</a>(ss, el, ataccess);

    // Prepare fault fields in case a fault is detected
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, ZeroExtend{64}(vaddress));

    if eae then
        (fault, addrdesc) = <a href="shared_pseudocode.html#func_AArch32_S1TranslateLD_5" title="">AArch32_S1TranslateLD</a>(fault, regime, vaddress, aligned, accdesc);
    else
        (fault, addrdesc, sdftype) = <a href="shared_pseudocode.html#func_AArch32_S1TranslateSD_5" title="">AArch32_S1TranslateSD</a>(fault, regime, vaddress, aligned,
                                                           accdesc);
        supersection = if sdftype == <a href="shared_pseudocode.html#enum_SDFType_Supersection" title="">SDFType_Supersection</a> then '1' else '0';
    end;

    // ATS12NSOxx instructions
    if stage == <a href="shared_pseudocode.html#enum_TranslationStage_12" title="">TranslationStage_12</a> &amp;&amp; fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        (fault, addrdesc) = <a href="shared_pseudocode.html#func_AArch32_S2Translate_4" title="">AArch32_S2Translate</a>(fault, addrdesc, aligned, accdesc);
    end;

    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        // Take exception on External abort or when a fault occurs on translation table walk
        if <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) || (PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; fault.s2fs1walk) then
            PAR() = ARBITRARY : bits(64);
            AArch32_Abort(fault);
        end;
    end;

    addrdesc.fault = fault;

    if (eae || (stage == <a href="shared_pseudocode.html#enum_TranslationStage_12" title="">TranslationStage_12</a> &amp;&amp; (HCR().VM == '1' || HCR().DC == '1'))
            || (stage == <a href="shared_pseudocode.html#enum_TranslationStage_1" title="">TranslationStage_1</a> &amp;&amp; el != <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>)) then
        AArch32_EncodePARLD(addrdesc, ss);
    else
        AArch32_EncodePARSD(addrdesc, supersection, ss);
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32_EncodePARLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32_EncodePARLD</h3>
      <p class="pseudocode">// AArch32_EncodePARLD()
// =====================
// Returns 64-bit format PAR on address translation instruction.

func AArch32_EncodePARLD(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>)
begin

    if !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(addrdesc) then
        var ns : bit;
        if ss == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> then
            ns = ARBITRARY : bit;
        elsif addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then
            ns = '0';
        else
            ns = '1';
        end;
        PAR().F      = '0';
        PAR().SH     = <a href="shared_pseudocode.html#func_ReportedPARShareability_1" title="">ReportedPARShareability</a>(<a href="shared_pseudocode.html#func_PAREncodeShareability_1" title="">PAREncodeShareability</a>(addrdesc.memattrs));
        PAR().NS     = ns;
        PAR()[10]    = ImpDefBit("Non-Faulting PAR");               // IMPDEF
        PAR().LPAE   = '1';
        PAR().PA     = addrdesc.paddress.address[39:12];
        PAR().ATTR   = <a href="shared_pseudocode.html#func_ReportedPARAttrs_1" title="">ReportedPARAttrs</a>(<a href="shared_pseudocode.html#func_EncodePARAttrs_1" title="">EncodePARAttrs</a>(addrdesc.memattrs));
    else
        PAR().F      = '1';
        PAR().FST    = <a href="shared_pseudocode.html#func_AArch32_PARFaultStatusLD_1" title="">AArch32_PARFaultStatusLD</a>(addrdesc.fault);
        PAR().S2WLK  = if addrdesc.fault.s2fs1walk then '1' else '0';
        PAR().FSTAGE = if addrdesc.fault.secondstage then '1' else '0';
        PAR().LPAE   = '1';
        PAR()[63:48] = ImpDefBits{16}("Faulting PAR");              // IMPDEF
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32_EncodePARSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32_EncodePARSD</h3>
      <p class="pseudocode">// AArch32_EncodePARSD()
// =====================
// Returns 32-bit format PAR on address translation instruction.

func AArch32_EncodePARSD(addrdesc_in : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, supersection : bit, ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>)
begin
    var addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = addrdesc_in;
    if !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(addrdesc) then
        if (addrdesc.memattrs.memtype == MemType_Device ||
              (addrdesc.memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp;
               addrdesc.memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>)) then
            addrdesc.memattrs.shareability = <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
        end;
        var ns : bit;
        if ss == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> then
            ns = ARBITRARY : bit;
        elsif addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then
            ns = '0';
        else
            ns = '1';
        end;
        let sh : bits(2) = (if addrdesc.memattrs.shareability != <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> then '01'
                                                                                  else '00');
        PAR().F      = '0';
        PAR().SS     = supersection;
        PAR().Outer  = <a href="shared_pseudocode.html#func_AArch32_ReportedOuterAttrs_1" title="">AArch32_ReportedOuterAttrs</a>(<a href="shared_pseudocode.html#func_AArch32_PAROuterAttrs_1" title="">AArch32_PAROuterAttrs</a>(addrdesc.memattrs));
        PAR().Inner  = <a href="shared_pseudocode.html#func_AArch32_ReportedInnerAttrs_1" title="">AArch32_ReportedInnerAttrs</a>(<a href="shared_pseudocode.html#func_AArch32_PARInnerAttrs_1" title="">AArch32_PARInnerAttrs</a>(addrdesc.memattrs));
        PAR().SH     = <a href="shared_pseudocode.html#func_ReportedPARShareability_1" title="">ReportedPARShareability</a>(sh);
        PAR()[8]     = ImpDefBit("Non-Faulting PAR");               // IMPDEF
        PAR().NS     = ns;
        PAR().NOS    = if addrdesc.memattrs.shareability == <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a> then '0' else '1';
        PAR().LPAE   = '0';
        PAR().PA     = addrdesc.paddress.address[39:12];
    else
        PAR().F      = '1';
        PAR().FST    = <a href="shared_pseudocode.html#func_AArch32_PARFaultStatusSD_1" title="">AArch32_PARFaultStatusSD</a>(addrdesc.fault);
        PAR().LPAE   = '0';
        PAR()[31:16] = ImpDefBits{16}("Faulting PAR");              // IMPDEF
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32_PARFaultStatusLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32_PARFaultStatusLD</h3>
      <p class="pseudocode">// AArch32_PARFaultStatusLD()
// ==========================
// Fault status field decoding of 64-bit PAR

func <a id="func_AArch32_PARFaultStatusLD_1"/>AArch32_PARFaultStatusLD(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; bits(6)
begin
    var syndrome : bits(6);

    if fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_Domain" title="">Fault_Domain</a> then
        // Report Domain fault
        assert fault.level IN {1,2};
        syndrome[1:0] = if fault.level == 1 then '01' else '10';
        syndrome[5:2] = '1111';
    else
        syndrome = <a href="shared_pseudocode.html#func_EncodeLDFSC_2" title="">EncodeLDFSC</a>(fault.statuscode, fault.level);
    end;
    return syndrome;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32_PARFaultStatusSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32_PARFaultStatusSD</h3>
      <p class="pseudocode">// AArch32_PARFaultStatusSD()
// ==========================
// Fault status field decoding of 32-bit PAR.

func <a id="func_AArch32_PARFaultStatusSD_1"/>AArch32_PARFaultStatusSD(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; bits(6)
begin
    var syndrome : bits(6);

    syndrome[5] = if <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) then fault.extflag else '0';
    syndrome[4:0] = <a href="shared_pseudocode.html#func_EncodeSDFSC_2" title="">EncodeSDFSC</a>(fault.statuscode, fault.level);
    return syndrome;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32_PARInnerAttrs"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32_PARInnerAttrs</h3>
      <p class="pseudocode">// AArch32_PARInnerAttrs()
// =======================
// Convert orthogonal attributes and hints to 32-bit PAR Inner field.

func <a id="func_AArch32_PARInnerAttrs_1"/>AArch32_PARInnerAttrs(memattrs : MemoryAttributes) =&gt; bits(3)
begin
    var result : bits(3);

    if memattrs.memtype == MemType_Device then
        if memattrs.device == <a href="shared_pseudocode.html#enum_DeviceType_nGnRnE" title="">DeviceType_nGnRnE</a> then
            result = '001'; // Non-cacheable
        elsif memattrs.device == <a href="shared_pseudocode.html#enum_DeviceType_nGnRE" title="">DeviceType_nGnRE</a> then
            result = '011'; // Non-cacheable
        end;
    else
        let inner : <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a> = memattrs.inner;
        if inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> then
            result = '000'; // Non-cacheable
        elsif inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> &amp;&amp; inner.hints[0] == '1' then
            result = '101'; // Write-Back, Write-Allocate
        elsif inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a> then
            result = '110'; // Write-Through
        elsif inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> &amp;&amp; inner.hints[0] == '0' then
            result = '111'; // Write-Back, no Write-Allocate
        end;
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32_PAROuterAttrs"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32_PAROuterAttrs</h3>
      <p class="pseudocode">// AArch32_PAROuterAttrs()
// =======================
// Convert orthogonal attributes and hints to 32-bit PAR Outer field.

func <a id="func_AArch32_PAROuterAttrs_1"/>AArch32_PAROuterAttrs(memattrs : MemoryAttributes) =&gt; bits(2)
begin
    var result : bits(2);

    if memattrs.memtype == MemType_Device then
        result = ARBITRARY : bits(2);
    else
        let outer : <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a> = memattrs.outer;
        if outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> then
            result = '00'; // Non-cacheable
        elsif outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> &amp;&amp; outer.hints[0] == '1' then
            result = '01'; // Write-Back, Write-Allocate
        elsif outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a> &amp;&amp; outer.hints[0] == '0' then
            result = '10'; // Write-Through, no Write-Allocate
        elsif outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> &amp;&amp; outer.hints[0] == '0' then
            result = '11'; // Write-Back, no Write-Allocate
        end;
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32_ReportedInnerAttrs"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32_ReportedInnerAttrs</h3>
      <p class="pseudocode">// AArch32_ReportedInnerAttrs()
// ============================
// The value returned in this field can be the resulting attribute, as determined by any permitted
// implementation choices and any applicable configuration bits, instead of the value that appears
// in the translation table descriptor.

impdef func <a id="func_AArch32_ReportedInnerAttrs_1"/>AArch32_ReportedInnerAttrs(attrs : bits(3)) =&gt; bits(3)
begin
    return attrs;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32_ReportedOuterAttrs"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32_ReportedOuterAttrs</h3>
      <p class="pseudocode">// AArch32_ReportedOuterAttrs()
// ============================
// The value returned in this field can be the resulting attribute, as determined by any permitted
// implementation choices and any applicable configuration bits, instead of the value that appears
// in the translation table descriptor.

impdef func <a id="func_AArch32_ReportedOuterAttrs_1"/>AArch32_ReportedOuterAttrs(attrs : bits(2)) =&gt; bits(2)
begin
    return attrs;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.dc.AArch32_CanTrapDC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/dc/AArch32_CanTrapDC</h3>
      <p class="pseudocode">// AArch32_CanTrapDC()
// ===================
// Determines whether the execution of the DC instruction can be trapped.

func <a id="func_AArch32_CanTrapDC_2"/>AArch32_CanTrapDC(cacheop : <a href="shared_pseudocode.html#type_CacheOp" title="">CacheOp</a>, opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>) =&gt; boolean
begin
    return (!<a href="shared_pseudocode.html#func_AArch32_TreatDCAsNOP_2" title="">AArch32_TreatDCAsNOP</a>(cacheop, opscope) || ImpDefBool(
            "When DC is treated as NOP, data cache maintenance operations are trapped"));
end;</p>
    </div>
    <div class="ps"><a id="aarch32.dc.AArch32_DC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/dc/AArch32_DC</h3>
      <p class="pseudocode">// AArch32_DC()
// ============
// Perform Data Cache Operation.

func AArch32_DC(regval : bits(32), cacheop : CacheOp, opscope : CacheOpScope)
begin
    var cache : CacheRecord;

    cache.acctype   = AccessType_DC;
    cache.cacheop   = cacheop;
    cache.opscope   = opscope;
    cache.cachetype = CacheType_Data;
    cache.security  = SecurityStateAtEL(PSTATE.EL);

    if opscope == CacheOpScope_SetWay then
        cache.shareability = Shareability_NSH;
        cache.(setnum, waynum, level) = DecodeSW(ZeroExtend{64}(regval),
                                                             CacheType_Data);

        if (cacheop == CacheOp_Invalidate &amp;&amp; PSTATE.EL == EL1 &amp;&amp; EL2Enabled() &amp;&amp;
              ((!ELUsingAArch32(EL2) &amp;&amp; (HCR_EL2().SWIO == '1' || HCR_EL2().[DC,VM] != '00')) ||
                 (ELUsingAArch32(EL2) &amp;&amp; (HCR().SWIO == '1' || HCR().[DC,VM] != '00')))) then
            cache.cacheop = CacheOp_CleanInvalidate;
        end;
        CACHE_OP(cache);
        return;
    end;

    if EL2Enabled() then
        if PSTATE.EL IN {EL0, EL1} then
            cache.is_vmid_valid = TRUE;
            cache.vmid          = VMID();
        else
            cache.is_vmid_valid = FALSE;
        end;
    else
        cache.is_vmid_valid = FALSE;
    end;

    if PSTATE.EL == EL0 then
        cache.is_asid_valid = TRUE;
        cache.asid          = ASID();
    else
        cache.is_asid_valid = FALSE;
    end;

    var vaddress : bits(32) = regval;

    var size : integer = 0;        // by default no watchpoint address
    if cacheop == CacheOp_Invalidate then
        size     = DataCacheWatchpointSize();
        vaddress = AlignDownSize{32}(regval, size as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>);
    end;

    cache.vaddress = ZeroExtend{64}(vaddress);

    let aligned : boolean               = TRUE;
    let accdesc : AccessDescriptor      = CreateAccDescDC(cache);
    var memaddrdesc : AddressDescriptor = AArch32_TranslateAddress(vaddress, accdesc,
                                                                   aligned, size);
    if IsFault(memaddrdesc) then
        memaddrdesc.fault.vaddress = ZeroExtend{64}(regval);
        AArch32_Abort(memaddrdesc.fault);
    end;

    cache.paddress = memaddrdesc.paddress;
    if opscope == CacheOpScope_PoC then
        cache.shareability = memaddrdesc.memattrs.shareability;
    else
        cache.shareability = Shareability_NSH;
    end;

    if (cacheop == CacheOp_Invalidate &amp;&amp; PSTATE.EL == EL1 &amp;&amp; EL2Enabled() &amp;&amp;
          ((!ELUsingAArch32(EL2) &amp;&amp; HCR_EL2().[DC,VM] != '00') ||
             (ELUsingAArch32(EL2) &amp;&amp; HCR().[DC,VM] != '00'))) then
        cache.cacheop = CacheOp_CleanInvalidate;
    end;

    CACHE_OP(cache);
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.dc.AArch32_TreatDCAsNOP"/><h3 class="pseudocode">
            Library pseudocode for aarch32/dc/AArch32_TreatDCAsNOP</h3>
      <p class="pseudocode">// AArch32_TreatDCAsNOP()
// ======================
// Determines whether the execution of the DC instruction is treated as a NOP.

func <a id="func_AArch32_TreatDCAsNOP_2"/>AArch32_TreatDCAsNOP(cacheop : <a href="shared_pseudocode.html#type_CacheOp" title="">CacheOp</a>, opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>) =&gt; boolean
begin
    // DC to PoU: IMPLEMENTATION DEFINED - treated as NOP if LoUU and LoUIS are 0
    if opscope == <a href="shared_pseudocode.html#enum_CacheOpScope_PoU" title="">CacheOpScope_PoU</a> &amp;&amp; CLIDR().LoUU == '000' &amp;&amp; CLIDR().LoUIS == '000' then
        return ImpDefBool("DC to PoU is treated as a NOP");
    end;

    // DC to PoC: IMPLEMENTATION DEFINED - treated as NOP if LoC is 0
    if opscope == <a href="shared_pseudocode.html#enum_CacheOpScope_PoC" title="">CacheOpScope_PoC</a> &amp;&amp; CLIDR().LoC == '000' then
        return ImpDefBool("DC to PoC is treated as a NOP");
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.VCRMatch.AArch32_VCRMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/VCRMatch/AArch32_VCRMatch</h3>
      <p class="pseudocode">// AArch32_VCRMatch()
// ==================

func <a id="func_AArch32_VCRMatch_1"/>AArch32_VCRMatch(vaddress : bits(32)) =&gt; boolean
begin

    var match : boolean;
    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        // Each bit position in this string corresponds to a bit in DBGVCR and an exception vector.
        var match_word : bits(32) = Zeros{};

        let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();
        if vaddress[31:5] == <a href="shared_pseudocode.html#func_ExcVectorBase_0" title="">ExcVectorBase</a>()[31:5] then
            if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; ss == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> then
                match_word[UInt(vaddress[4:2]) + 24] = '1';     // Non-secure vectors
            else
                match_word[UInt(vaddress[4:2]) + 0] = '1';      // Secure vectors (or no EL3)
            end;
        end;

        if (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; vaddress[31:5] == MVBAR()[31:5] &amp;&amp;
            ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>) then
            match_word[UInt(vaddress[4:2]) + 8] = '1';          // Monitor vectors
        end;

        // Mask out bits not corresponding to vectors.
        var mask : bits(32);
        if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            mask = '00000000'::'00000000'::'00000000'::'11011110'; // DBGVCR[31:8] are RES0
        elsif !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            mask = '11011110'::'00000000'::'00000000'::'11011110'; // DBGVCR[15:8] are RES0
        else
            mask = '11011110'::'00000000'::'11011100'::'11011110';
        end;

        match_word = match_word AND DBGVCR() AND mask;
        match = !IsZero(match_word);

        // Check for UNPREDICTABLE case - match on Prefetch Abort and Data Abort vectors
        if !IsZero(match_word[28:27,12:11,4:3]) &amp;&amp; <a href="shared_pseudocode.html#func_DebugTarget_0" title="">DebugTarget</a>() == PSTATE.EL then
            match = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_VCMATCHDAPA" title="">Unpredictable_VCMATCHDAPA</a>);
        end;

        if !IsZero(vaddress[1:0]) &amp;&amp; match then
            match = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_VCMATCHHALF" title="">Unpredictable_VCMATCHHALF</a>);
        end;
    else
        match = FALSE;
    end;

    return match;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.authentication.AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/authentication/AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled</h3>
      <p class="pseudocode">// AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled()
// ========================================================

func <a id="func_AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled_0"/>AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled() =&gt; boolean
begin
    // The definition of this function is IMPLEMENTATION DEFINED.
    // In the recommended interface, AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled returns
    // the state of the (DBGEN AND SPIDEN) signal.
    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_NonSecureOnlyImplementation_0" title="">NonSecureOnlyImplementation</a>() then return FALSE; end;
    return DBGEN == HIGH &amp;&amp; SPIDEN == HIGH;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.breakpoint.AArch32_BreakpointMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32_BreakpointMatch</h3>
      <p class="pseudocode">// AArch32_BreakpointMatch()
// =========================
// Breakpoint matching in an AArch32 translation regime.

func <a id="func_AArch32_BreakpointMatch_4"/>AArch32_BreakpointMatch(n : integer, vaddress : bits(32), accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                             size : integer) =&gt; <a href="shared_pseudocode.html#type_BreakpointInfo" title="">BreakpointInfo</a>
begin
    assert <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    assert n &lt; <a href="shared_pseudocode.html#func_NumBreakpointsImplemented_0" title="">NumBreakpointsImplemented</a>();

    var brkptinfo : <a href="shared_pseudocode.html#type_BreakpointInfo" title="">BreakpointInfo</a>;
    let enabled : boolean    = DBGBCR(n).E == '1';
    let isbreakpnt : boolean = TRUE;
    let linked : boolean     = DBGBCR(n).BT == '0x01';
    let linked_to : boolean  = FALSE;
    let linked_n : integer{} = UInt(DBGBCR(n).LBN);

    let state_match : boolean = <a href="shared_pseudocode.html#func_AArch32_StateMatch_7" title="">AArch32_StateMatch</a>(DBGBCR(n).SSC, DBGBCR(n).HMC, DBGBCR(n).PMC,
                                                   linked, linked_n, isbreakpnt,  accdesc);
    var (value_match, value_mismatch) = <a href="shared_pseudocode.html#func_AArch32_BreakpointValueMatch_3" title="">AArch32_BreakpointValueMatch</a>(n,vaddress, linked_to);

    if size == 4 then                    // Check second halfword
        // If the breakpoint address and BAS of an Address breakpoint match the address of the
        // second halfword of an instruction, but not the address of the first halfword, it is
        // CONSTRAINED UNPREDICTABLE whether or not this breakpoint generates a Breakpoint debug
        // event.
        let (match_i, mismatch_i) = <a href="shared_pseudocode.html#func_AArch32_BreakpointValueMatch_3" title="">AArch32_BreakpointValueMatch</a>(n, vaddress + 2, linked_to);

        if !value_match &amp;&amp; match_i then
            value_match = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BPMATCHHALF" title="">Unpredictable_BPMATCHHALF</a>);
        end;

        if value_mismatch &amp;&amp; !mismatch_i then
            value_mismatch = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BPMISMATCHHALF" title="">Unpredictable_BPMISMATCHHALF</a>);
        end;
    end;

    if vaddress[1] == '1' &amp;&amp; DBGBCR(n).BAS == '1111' then
        // The above notwithstanding, if DBGBCR(n).BAS == '1111', then it is CONSTRAINED
        // UNPREDICTABLE whether or not a Breakpoint debug event is generated for an instruction
        // at the address DBGBVR(n)+2.
        if value_match then
            value_match = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BPMATCHHALF" title="">Unpredictable_BPMATCHHALF</a>);
        end;

        if !value_mismatch then
            value_mismatch = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BPMISMATCHHALF" title="">Unpredictable_BPMISMATCHHALF</a>);
        end;
    end;

    brkptinfo.match    = value_match &amp;&amp; state_match &amp;&amp; enabled;
    brkptinfo.mismatch = value_mismatch &amp;&amp; state_match &amp;&amp; enabled;

    return brkptinfo;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.breakpoint.AArch32_BreakpointValueMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32_BreakpointValueMatch</h3>
      <p class="pseudocode">// AArch32_BreakpointValueMatch()
// ==============================
// The first result is whether an Address Match or Context breakpoint is programmed on the
// instruction at "address". The second result is whether an Address Mismatch breakpoint is
// programmed on the instruction, that is, whether the instruction should be stepped.

func <a id="func_AArch32_BreakpointValueMatch_3"/>AArch32_BreakpointValueMatch(n_in : integer, vaddress : bits(32),
                                  linked_to : boolean) =&gt; (boolean, boolean)
begin

    // "n" is the identity of the breakpoint unit to match against.
    // "vaddress" is the current instruction address, ignored if linked_to is TRUE and for Context
    //   matching breakpoints.
    // "linked_to" is TRUE if this is a call from StateMatch for linking.
    var n : integer = n_in;
    var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;

    // If a non-existent breakpoint then it is CONSTRAINED UNPREDICTABLE whether this gives
    // no match or the breakpoint is mapped to another UNKNOWN implemented breakpoint.
    if n &gt;= <a href="shared_pseudocode.html#func_NumBreakpointsImplemented_0" title="">NumBreakpointsImplemented</a>() then
        (c, n) = <a href="shared_pseudocode.html#func_ConstrainUnpredictableInteger_3" title="">ConstrainUnpredictableInteger</a>(0, <a href="shared_pseudocode.html#func_NumBreakpointsImplemented_0" title="">NumBreakpointsImplemented</a>() - 1,
                                               <a href="shared_pseudocode.html#enum_Unpredictable_BPNOTIMPL" title="">Unpredictable_BPNOTIMPL</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then return (FALSE, FALSE); end;
    end;

    // If this breakpoint is not enabled, it cannot generate a match.
    // (This could also happen on a call from StateMatch for linking).
    if DBGBCR(n).E == '0' then return (FALSE, FALSE); end;

    var dbgtype : bits(4) = DBGBCR(n).BT;

    (c, dbgtype) = <a href="shared_pseudocode.html#func_AArch32_ReservedBreakpointType_2" title="">AArch32_ReservedBreakpointType</a>(n, dbgtype);
    if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then return (FALSE, FALSE); end;
    // Otherwise the dbgtype value returned by AArch32_ReservedBreakpointType is valid.

    // Determine what to compare against.
    let match_addr : boolean      = (dbgtype == '0x0x');
    let mismatch : boolean        = (dbgtype == '010x');
    let match_vmid : boolean      = (dbgtype == '10xx');
    let match_cid1 : boolean      = (dbgtype == 'xx1x');
    let match_cid2 : boolean      = (dbgtype == '11xx');
    let linking_enabled : boolean = (dbgtype == 'xxx1');

    // If called from StateMatch, is is CONSTRAINED UNPREDICTABLE if the
    // breakpoint is not programmed with linking enabled.
    if linked_to &amp;&amp; !linking_enabled then
        if !<a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BPLINKINGDISABLED" title="">Unpredictable_BPLINKINGDISABLED</a>) then
            return (FALSE, FALSE);
        end;
    end;

    // If called from BreakpointMatch return FALSE for Linked context ID and/or VMID matches.
    if !linked_to &amp;&amp; linking_enabled &amp;&amp; !match_addr then
        return (FALSE, FALSE);
    end;

    var bvr_match : boolean  = FALSE;
    var bxvr_match : boolean = FALSE;

    // Do the comparison.
    if match_addr then
        let byte : integer = UInt(vaddress[1:0]);
        assert byte IN {0,2};                     // "vaddress" is halfword aligned

        let byte_select_match : boolean = (DBGBCR(n).BAS[byte] == '1');
        bvr_match = (vaddress[31:2] == DBGBVR(n)[31:2]) &amp;&amp; byte_select_match;

    elsif match_cid1 then
        bvr_match = (PSTATE.EL != <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> &amp;&amp; CONTEXTIDR() == DBGBVR(n)[31:0]);
    end;

    if match_vmid then
        let vmid : bits(16) = <a href="shared_pseudocode.html#func_VMID_0" title="">VMID</a>();
        var bvr_vmid : bits(16);

        if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            bvr_vmid = ZeroExtend{16}(DBGBXVR(n)[7:0]);
        elsif !IsFeatureImplemented(FEAT_VMID16) || VTCR_EL2().VS == '0' then
            bvr_vmid = ZeroExtend{16}(DBGBXVR(n)[7:0]);
        else
            bvr_vmid = DBGBXVR(n)[15:0];
        end;

        bxvr_match = (PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; vmid == bvr_vmid);

    elsif match_cid2 then
        bxvr_match = (PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp;
                      DBGBXVR(n)[31:0] == CONTEXTIDR_EL2()[31:0]);
    end;

    let bvr_match_valid : boolean  = (match_addr || match_cid1);
    let bxvr_match_valid : boolean = (match_vmid || match_cid2);

    let match : boolean = (!bxvr_match_valid || bxvr_match) &amp;&amp; (!bvr_match_valid || bvr_match);

    return (match &amp;&amp; !mismatch, !match &amp;&amp; mismatch);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.breakpoint.AArch32_ReservedBreakpointType"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32_ReservedBreakpointType</h3>
      <p class="pseudocode">// AArch32_ReservedBreakpointType()
// ================================
// Checks if the given DBGBCR(n).BT value is reserved and will generate Constrained Unpredictable
// behavior, otherwise returns Constraint_NONE.

func <a id="func_AArch32_ReservedBreakpointType_2"/>AArch32_ReservedBreakpointType(n : integer, bt_in : bits(4)) =&gt; (<a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>, bits(4))
begin
    var bt : bits(4)       = bt_in;
    var reserved : boolean = FALSE;
    let context_aware : boolean = <a href="shared_pseudocode.html#func_IsContextAwareBreakpoint_1" title="">IsContextAwareBreakpoint</a>(n);

    // Address mismatch
    if bt == '010x' &amp;&amp; <a href="shared_pseudocode.html#func_HaltOnBreakpointOrWatchpoint_0" title="">HaltOnBreakpointOrWatchpoint</a>() then
        reserved = TRUE;
    end;

    // Context matching
    if bt != '0x0x' &amp;&amp; !context_aware then
        reserved = TRUE;
    end;

    // EL2 extension
    if bt == '1xxx' &amp;&amp; !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        reserved = TRUE;
    end;

    // Context matching
    if (bt IN {'011x','11xx'} &amp;&amp; !IsFeatureImplemented(FEAT_VHE) &amp;&amp;
          !IsFeatureImplemented(FEAT_Debugv8p2)) then
        reserved = TRUE;
    end;

    if reserved then
        var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;
        (c, bt) = ConstrainUnpredictableBits{4}(<a href="shared_pseudocode.html#enum_Unpredictable_RESBPTYPE" title="">Unpredictable_RESBPTYPE</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then
            return (c, ARBITRARY : bits(4));
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value
        end;
    end;

    return (<a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>, bt);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.breakpoint.AArch32_StateMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32_StateMatch</h3>
      <p class="pseudocode">// AArch32_StateMatch()
// ====================
// Determine whether a breakpoint or watchpoint is enabled in the current mode and state.

func <a id="func_AArch32_StateMatch_7"/>AArch32_StateMatch(ssc_in : bits(2),  hmc_in : bit, pxc_in : bits(2), linked_in : boolean,
                        linked_n_in : integer, isbreakpnt : boolean,
                        accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin

    // "ssc_in","hmc_in","pxc_in" are the control fields from the DBGBCR(n) or DBGWCR(n) register.
    // "linked_in" is TRUE if this is a linked breakpoint/watchpoint type.
    // "linked_n_in" is the linked breakpoint number from the DBGBCR(n) or DBGWCR(n) register.
    // "isbreakpnt" is TRUE for breakpoints, FALSE for watchpoints.
    // "accdesc" describes the properties of the access being matched.
    var hmc : bit          = hmc_in;
    var ssc : bits(2)      = ssc_in;
    var pxc : bits(2)      = pxc_in;
    var linked : boolean   = linked_in;
    var linked_n : integer = linked_n_in;

    // If parameters are set to a reserved type, behaves as either disabled or a defined type
    var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;
    // SSCE value discarded as there is no SSCE bit in AArch32_
    (c, ssc, -, hmc, pxc) = <a href="shared_pseudocode.html#func_CheckValidStateMatch_5" title="">CheckValidStateMatch</a>(ssc, '0', hmc, pxc, isbreakpnt);
    if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then return FALSE; end;
    // Otherwise the hmc,ssc,pxc values are either valid or the values returned by
    // CheckValidStateMatch are valid.

    let pl2_match : boolean = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; ((hmc == '1' &amp;&amp; (ssc::pxc != '1000')) || ssc == '11');
    let pl1_match : boolean = pxc[0] == '1';
    let pl0_match : boolean = pxc[1] == '1';
    let ssu_match : boolean = isbreakpnt &amp;&amp; hmc == '0' &amp;&amp; pxc == '00' &amp;&amp; ssc != '11';

    var priv_match : boolean;
    if ssu_match then
        priv_match = PSTATE.M IN {<a href="shared_pseudocode.html#global_M32_User" title="">M32_User</a>,<a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>,<a href="shared_pseudocode.html#global_M32_System" title="">M32_System</a>};
    else
        case accdesc.el of
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; priv_match = pl1_match;           // EL3 and EL1 are both PL1
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; priv_match = pl2_match;
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; priv_match = pl1_match;
            when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt; priv_match = pl0_match;
        end;
    end;

    // Security state match
    var ss_match : boolean;
    case ssc of
        when '00' =&gt; ss_match = TRUE;                                     // Both
        when '01' =&gt; ss_match = accdesc.ss == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;               // Non-secure only
        when '10' =&gt; ss_match = accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;                  // Secure only
        when '11' =&gt; ss_match = (hmc == '1' || accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>);  // HMC=1 -&gt; Both,
                                                                          // HMC=0 -&gt; Secure only
    end;

    var linked_match : boolean = FALSE;

    if linked then
        // "linked_n" must be an enabled context-aware breakpoint unit.
        // If it is not context-aware then it is CONSTRAINED UNPREDICTABLE whether
        // this gives no match, gives a match without linking, or linked_n is mapped to some
        // UNKNOWN breakpoint that is context-aware.
        if !<a href="shared_pseudocode.html#func_IsContextAwareBreakpoint_1" title="">IsContextAwareBreakpoint</a>(linked_n) then
            let (first_ctx_cmp, last_ctx_cmp) : (integer, integer) = <a href="shared_pseudocode.html#func_ContextAwareBreakpointRange_0" title="">ContextAwareBreakpointRange</a>();
            (c, linked_n) = <a href="shared_pseudocode.html#func_ConstrainUnpredictableInteger_3" title="">ConstrainUnpredictableInteger</a>(first_ctx_cmp, last_ctx_cmp,
                                                          <a href="shared_pseudocode.html#enum_Unpredictable_BPNOTCTXCMP" title="">Unpredictable_BPNOTCTXCMP</a>);
            assert c IN {<a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};

            case c of
                when <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> =&gt;  return FALSE;      // Disabled
                when <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a> =&gt;      linked = FALSE;    // No linking
                // Otherwise ConstrainUnpredictableInteger returned a context-aware breakpoint
            end;
        end;

        let vaddress : bits(32) = ARBITRARY : bits(32);
        let linked_to : boolean = TRUE;
        (linked_match,-) = <a href="shared_pseudocode.html#func_AArch32_BreakpointValueMatch_3" title="">AArch32_BreakpointValueMatch</a>(linked_n, vaddress, linked_to);
    end;

    return priv_match &amp;&amp; ss_match &amp;&amp; (!linked || linked_match);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.enables.AArch32_GenerateDebugExceptions"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/enables/AArch32_GenerateDebugExceptions</h3>
      <p class="pseudocode">// AArch32_GenerateDebugExceptions()
// =================================

func <a id="func_AArch32_GenerateDebugExceptions_0"/>AArch32_GenerateDebugExceptions() =&gt; boolean
begin
    let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();
    return <a href="shared_pseudocode.html#func_AArch32_GenerateDebugExceptionsFrom_2" title="">AArch32_GenerateDebugExceptionsFrom</a>(PSTATE.EL, ss);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.enables.AArch32_GenerateDebugExceptionsFrom"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/enables/AArch32_GenerateDebugExceptionsFrom</h3>
      <p class="pseudocode">// AArch32_GenerateDebugExceptionsFrom()
// =====================================

func <a id="func_AArch32_GenerateDebugExceptionsFrom_2"/>AArch32_GenerateDebugExceptionsFrom(from_el : bits(2), from_state : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>) =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_DebugTargetFrom_1" title="">DebugTargetFrom</a>(from_state)) then
        let mask : bit = '0';    // No PSTATE.D in AArch32 state
        return <a href="shared_pseudocode.html#func_AArch64_GenerateDebugExceptionsFrom_3" title="">AArch64_GenerateDebugExceptionsFrom</a>(from_el, from_state, mask);
    end;
    if DBGOSLSR().OSLK == '1' || <a href="shared_pseudocode.html#func_DoubleLockStatus_0" title="">DoubleLockStatus</a>() || <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        return FALSE;
    end;

    var enabled : boolean;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; from_state == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
        assert from_el != <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;    // Secure EL2 always uses AArch64
        if <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>() then
            // Implies that EL3 and EL2 both using AArch64
            enabled = MDCR_EL3().SDD == '0';
        else
            let spd : bits(2) = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then SDCR().SPD else MDCR_EL3().SPD32;
            if spd[1] == '1' then
                enabled = spd[0] == '1';
            else
                // SPD == 0b01 is reserved, but behaves the same as 0b00.
                enabled = <a href="shared_pseudocode.html#func_AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled_0" title="">AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled</a>();
            end;
        end;
        if from_el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then enabled = enabled || SDER().SUIDEN == '1'; end;
    else
        enabled = from_el != <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    end;

    return enabled;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32_IncrementCycleCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32_IncrementCycleCounter</h3>
      <p class="pseudocode">// AArch32_IncrementCycleCounter()
// ===============================
// Increment the cycle counter and possibly set overflow bits.

func AArch32_IncrementCycleCounter()
begin
    if !<a href="shared_pseudocode.html#func_CountPMUEvents_1" title="">CountPMUEvents</a>(<a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a>) then return; end;
    var d : bit = PMCR().D;   // Check divide-by-64
    var lc : bit = PMCR().LC;
    // Effective value of 'D' bit is 0 when Effective value of LC is '1'
    if lc == '1' then d = '0'; end;
    if d == '1' &amp;&amp; !<a href="shared_pseudocode.html#func_HasElapsed64Cycles_0" title="">HasElapsed64Cycles</a>() then return; end;

    let old_value : integer = UInt(PMCCNTR());
    let new_value : integer = old_value + 1;
    PMCCNTR() = new_value[63:0];

    let ovflw : integer{} = if lc == '1' then 64 else 32;

    if old_value[64:ovflw] != new_value[64:ovflw] then
        PMOVSSET().C = '1';
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32_IncrementEventCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32_IncrementEventCounter</h3>
      <p class="pseudocode">// AArch32_IncrementEventCounter()
// ===============================
// Increment the specified event counter 'idx' by the specified amount 'increment'.
// 'Vm' is the value event counter 'idx-1' is being incremented by if 'idx' is odd,
// zero otherwise.
// Returns the amount the counter was incremented by.

func <a id="func_AArch32_IncrementEventCounter_3"/>AArch32_IncrementEventCounter(idx : integer, increment_in : integer, Vm : integer) =&gt; integer
begin
    if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
        // Force the counter to be incremented as a 64-bit counter.
        return <a href="shared_pseudocode.html#func_AArch64_IncrementEventCounter_3" title="">AArch64_IncrementEventCounter</a>(idx, increment_in, Vm);
    end;

    // In this model, event counters in an AArch32-only implementation are 32 bits and
    // the LP bits are RES0 in this model, even if FEAT_PMUv3p5 is implemented.
    var old_value : integer;
    var new_value : integer;

    old_value = UInt(PMEVCNTR(idx));
    let increment : integer = <a href="shared_pseudocode.html#func_PMUCountValue_3" title="">PMUCountValue</a>(idx, increment_in, Vm);
    new_value = old_value + increment;

    PMEVCNTR(idx) = new_value[31:0];
    let ovflw : integer{} = 32;
    if old_value[64:ovflw] != new_value[64:ovflw] then
        PMOVSSET()[idx] = '1';
        // Check for the CHAIN event from an even counter
        if (idx[0] == '0' &amp;&amp; idx + 1 &lt; NUM_PMU_COUNTERS &amp;&amp;
              (<a href="shared_pseudocode.html#func_GetPMUCounterRange_1" title="">GetPMUCounterRange</a>(idx) == <a href="shared_pseudocode.html#func_GetPMUCounterRange_1" title="">GetPMUCounterRange</a>(idx+1) ||
                 <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_COUNT_CHAIN" title="">Unpredictable_COUNT_CHAIN</a>))) then
            // If PMU counters idx and idx+1 are not in same range,
            // it is CONSTRAINED UNPREDICTABLE if CHAIN event is counted
            PMUEvent(PMU_EVENT_CHAIN, 1, idx + 1);
        end;
    end;

    return increment;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32_PMUCycle"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32_PMUCycle</h3>
      <p class="pseudocode">// AArch32_PMUCycle()
// ==================
// Called at the end of each cycle to increment event counters and
// check for PMU overflow. In pseudocode, a cycle ends after the
// execution of the operational pseudocode.

func AArch32_PMUCycle()
begin
    if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
        AArch64_PMUCycle();
        return;
    end;

    if !IsFeatureImplemented(FEAT_PMUv3) then
        return;
    end;
    PMUEvent(PMU_EVENT_CPU_CYCLES);
    let counters : integer = NUM_PMU_COUNTERS;
    var Vm : integer = 0;
    if counters != 0 then
        for idx = 0 to counters - 1 do
            if <a href="shared_pseudocode.html#func_CountPMUEvents_1" title="">CountPMUEvents</a>(idx) then
                let accumulated : integer = <a href="shared_pseudocode.html#global_PMUEventAccumulator" title="">PMUEventAccumulator</a>[[idx]];
                if (idx MOD 2) == 0 then Vm = 0; end;
                Vm = <a href="shared_pseudocode.html#func_AArch32_IncrementEventCounter_3" title="">AArch32_IncrementEventCounter</a>(idx, accumulated, Vm);
            end;
            <a href="shared_pseudocode.html#global_PMUEventAccumulator" title="">PMUEventAccumulator</a>[[idx]] = 0;
        end;
    end;
    AArch32_IncrementCycleCounter();
    CheckForPMUOverflow();
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.takeexceptiondbg.AArch32_EnterHypModeInDebugState"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/takeexceptiondbg/AArch32_EnterHypModeInDebugState</h3>
      <p class="pseudocode">// AArch32_EnterHypModeInDebugState()
// ==================================
// Take an exception in Debug state to Hyp mode.

noreturn func AArch32_EnterHypModeInDebugState(except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>)
begin
    SynchronizeContext();
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);

    AArch32_ReportHypEntry(except);
    AArch32_WriteMode(<a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>);
    <a href="shared_pseudocode.html#accessor_SPSR_curr_0" title="">SPSR_curr</a>() = ARBITRARY : bits(32);
    ELR_hyp()   = ARBITRARY : bits(32);
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.[SS,A,I,F] are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.[SS,A,I,F] = ARBITRARY : bits(4);
    DLR()   = ARBITRARY : bits(32);
    DSPSR() = ARBITRARY : bits(32);
    if IsFeatureImplemented(FEAT_Debugv8p9) then
        DSPSR2() = ARBITRARY : bits(32);
    end;
    PSTATE.E  = HSCTLR().EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if IsFeatureImplemented(FEAT_SSBS) then PSTATE.SSBS = ARBITRARY : bit; end;
    EDSCR().ERR = '1';
    UpdateEDSCRFields();

    EndOfInstruction();
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.takeexceptiondbg.AArch32_EnterModeInDebugState"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/takeexceptiondbg/AArch32_EnterModeInDebugState</h3>
      <p class="pseudocode">// AArch32_EnterModeInDebugState()
// ===============================
// Take an exception in Debug state to a mode other than Monitor and Hyp mode.

noreturn func AArch32_EnterModeInDebugState(target_mode : bits(5))
begin
    SynchronizeContext();
    assert <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;

    if PSTATE.M == <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> then SCR().NS = '0'; end;
    AArch32_WriteMode(target_mode);
    <a href="shared_pseudocode.html#accessor_SPSR_curr_0" title="">SPSR_curr</a>() = ARBITRARY : bits(32);
    <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(14)       = ARBITRARY : bits(32);
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.[SS,A,I,F] are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.[SS,A,I,F] = ARBITRARY : bits(4);
    DLR() = ARBITRARY : bits(32);
    DSPSR() = ARBITRARY : bits(32);
    if IsFeatureImplemented(FEAT_Debugv8p9) then
        DSPSR2() = ARBITRARY : bits(32);
    end;
    PSTATE.E  = SCTLR().EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if IsFeatureImplemented(FEAT_PAN) &amp;&amp; SCTLR().SPAN == '0' then PSTATE.PAN = '1'; end;
    if IsFeatureImplemented(FEAT_SSBS) then PSTATE.SSBS = ARBITRARY : bit; end;
    EDSCR().ERR = '1';
    UpdateEDSCRFields();                        // Update EDSCR PE state flags.

    EndOfInstruction();
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.takeexceptiondbg.AArch32_EnterMonitorModeInDebugState"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/takeexceptiondbg/AArch32_EnterMonitorModeInDebugState</h3>
      <p class="pseudocode">// AArch32_EnterMonitorModeInDebugState()
// ======================================
// Take an exception in Debug state to Monitor mode.

func AArch32_EnterMonitorModeInDebugState()
begin
    SynchronizeContext();
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
    let from_secure : boolean = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
    if PSTATE.M == <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> then SCR().NS = '0'; end;
    AArch32_WriteMode(<a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a>);
    <a href="shared_pseudocode.html#accessor_SPSR_curr_0" title="">SPSR_curr</a>() = ARBITRARY : bits(32);
    <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(14) = ARBITRARY : bits(32);
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.[SS,A,I,F] are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.[SS,A,I,F] = ARBITRARY : bits(4);
    PSTATE.E = SCTLR().EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if IsFeatureImplemented(FEAT_PAN) then
        if !from_secure then
            PSTATE.PAN = '0';
        elsif SCTLR().SPAN == '0' then
            PSTATE.PAN = '1';
        end;
    end;
    if IsFeatureImplemented(FEAT_SSBS) then PSTATE.SSBS = ARBITRARY : bit; end;
    DLR() = ARBITRARY : bits(32);
    DSPSR() = ARBITRARY : bits(32);
    if IsFeatureImplemented(FEAT_Debugv8p9) then
        DSPSR2() = ARBITRARY : bits(32);
    end;
    EDSCR().ERR = '1';
    UpdateEDSCRFields();                        // Update EDSCR PE state flags.

    EndOfInstruction();
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.watchpoint.AArch32_WatchpointByteMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/watchpoint/AArch32_WatchpointByteMatch</h3>
      <p class="pseudocode">// AArch32_WatchpointByteMatch()
// =============================

func <a id="func_AArch32_WatchpointByteMatch_2"/>AArch32_WatchpointByteMatch(n : integer, vaddress : bits(32)) =&gt; boolean
begin
    let dbgtop : integer{} = 31;
    let cmpbottom : integer{} = if DBGWVR(n)[2] == '1' then 2 else 3; // Word or doubleword
    var bottom = cmpbottom;
    let select : integer{} = UInt(vaddress[cmpbottom-1:0]);
    var byte_select_match : boolean = (DBGWCR(n).BAS[select] != '0');
    var mask : integer{} = UInt(DBGWCR(n).MASK);

    // If DBGWCR(n).MASK is a nonzero value and DBGWCR(n).BAS is not set to '11111111', or
    // DBGWCR(n).BAS specifies a non-contiguous set of bytes behavior is CONSTRAINED
    // UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; !IsOnes(DBGWCR(n).BAS) then
        byte_select_match = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_WPMASKANDBAS" title="">Unpredictable_WPMASKANDBAS</a>);
    else
        let LSB : bits(8) = (DBGWCR(n).BAS AND NOT(DBGWCR(n).BAS - 1));
        let MSB : bits(8) = (DBGWCR(n).BAS + LSB);
        if !IsZero(MSB AND (MSB - 1)) then          // Not contiguous
            byte_select_match = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_WPBASCONTIGUOUS" title="">Unpredictable_WPBASCONTIGUOUS</a>);
            bottom = 3;                             // For the whole doubleword
        end;
    end;

    // If the address mask is set to a reserved value, the behavior is CONSTRAINED UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; mask &lt;= 2 then
        var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;
        (c, mask) = (<a href="shared_pseudocode.html#func_ConstrainUnpredictableInteger_3" title="">ConstrainUnpredictableInteger</a>(3, 31, <a href="shared_pseudocode.html#enum_Unpredictable_RESWPMASK" title="">Unpredictable_RESWPMASK</a>)
                        as (<a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>, integer{0..31}));
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};
        case c of
            when <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> =&gt;  return FALSE; // Disabled
            when <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a> =&gt;      mask = 0;     // No masking
            // Otherwise the value returned by ConstrainUnpredictableInteger is a not-reserved value
        end;
    end;

    let cmpmsb : integer{} = dbgtop;
    let cmplsb : integer{} = if mask &gt; bottom then mask else bottom;
    let bottombit : integer{} = bottom;
    var WVR_match : boolean = (vaddress[cmpmsb:cmplsb] == DBGWVR(n)[cmpmsb:cmplsb]);
    if mask &gt; bottom then
        // If masked bits of DBGWVR(n) are not zero, the behavior is CONSTRAINED UNPREDICTABLE.
        if WVR_match &amp;&amp; !IsZero(DBGWVR(n)[cmplsb-1:bottombit]) then
            WVR_match = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_WPMASKEDBITS" title="">Unpredictable_WPMASKEDBITS</a>);
        end;
    end;

    return (WVR_match &amp;&amp; byte_select_match);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.watchpoint.AArch32_WatchpointMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/watchpoint/AArch32_WatchpointMatch</h3>
      <p class="pseudocode">// AArch32_WatchpointMatch()
// =========================
// Watchpoint matching in an AArch32 translation regime.

func <a id="func_AArch32_WatchpointMatch_4"/>AArch32_WatchpointMatch(n : integer, vaddress : bits(32), size : integer,
                             accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_WatchpointInfo" title="">WatchpointInfo</a>
begin
    assert <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    assert n &lt; <a href="shared_pseudocode.html#func_NumWatchpointsImplemented_0" title="">NumWatchpointsImplemented</a>();

    let enabled : boolean = DBGWCR(n).E == '1';
    let linked : boolean = DBGWCR(n).WT == '1';
    let isbreakpnt : boolean = FALSE;
    let linked_n : integer{} = UInt(DBGWCR_EL1(n).LBN);
    let state_match : boolean = <a href="shared_pseudocode.html#func_AArch32_StateMatch_7" title="">AArch32_StateMatch</a>(DBGWCR(n).SSC, DBGWCR(n).HMC, DBGWCR(n).PAC,
                                                   linked, linked_n, isbreakpnt, accdesc);

    var watchptinfo : <a href="shared_pseudocode.html#type_WatchpointInfo" title="">WatchpointInfo</a>;
    var ls_match : boolean;
    case DBGWCR(n).LSC[1:0] of
        when '00' =&gt; ls_match = FALSE;
        when '01' =&gt; ls_match = accdesc.read;
        when '10' =&gt; ls_match = accdesc.write || accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>;
        when '11' =&gt; ls_match = TRUE;
    end;

    var value_match : boolean = FALSE;
    watchptinfo.vaddress = ZeroExtend{64}(vaddress);
    for byte = 0 to size - 1 do
        if (!value_match &amp;&amp;
              !<a href="shared_pseudocode.html#func_AddressInNaturallyAlignedBlock_2" title="">AddressInNaturallyAlignedBlock</a>(watchptinfo.vaddress,
                                              ZeroExtend{64}(vaddress + byte))) then
            // Watchpoint should report an address which is in
            // the naturally aligned block of the matched address.
            watchptinfo.vaddress = ZeroExtend{64}(vaddress + byte);
        end;
        value_match = value_match || <a href="shared_pseudocode.html#func_AArch32_WatchpointByteMatch_2" title="">AArch32_WatchpointByteMatch</a>(n, vaddress + byte);
    end;

    watchptinfo.watchpt_num = n;
    watchptinfo.value_match = value_match &amp;&amp; state_match &amp;&amp; ls_match &amp;&amp; enabled;
    return watchptinfo;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32_Abort"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32_Abort</h3>
      <p class="pseudocode">// AArch32_Abort()
// ===============
// Abort and Debug exception handling in an AArch32 translation regime.

func AArch32_Abort(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    // Check if routed to AArch64 state
    var route_to_aarch64 : boolean = ((<a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) &amp;&amp;
                                      !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_SyncExternalAbortTarget_1" title="">SyncExternalAbortTarget</a>(fault))) ||
                                      (PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>)));

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        route_to_aarch64 = (HCR_EL2().TGE == '1' || <a href="shared_pseudocode.html#func_IsSecondStage_1" title="">IsSecondStage</a>(fault) ||
                            (<a href="shared_pseudocode.html#func_IsDebugException_1" title="">IsDebugException</a>(fault) &amp;&amp; MDCR_EL2().TDE == '1'));
    end;

    if route_to_aarch64 then
        AArch64_Abort(fault);
    end;
    if fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> then
        AArch32_TakePrefetchAbortException(fault);
    else
        AArch32_TakeDataAbortException(fault);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32_AbortSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32_AbortSyndrome</h3>
      <p class="pseudocode">// AArch32_AbortSyndrome()
// =======================
// Creates an exception syndrome record for Abort exceptions
// taken to Hyp mode
// from an AArch32 translation regime.

func <a id="func_AArch32_AbortSyndrome_3"/>AArch32_AbortSyndrome(exceptype : <a href="shared_pseudocode.html#type_Exception" title="">Exception</a>, fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>,
                           target_el : bits(2)) =&gt; <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>
begin
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(exceptype);

    except.syndrome.iss = <a href="shared_pseudocode.html#func_AArch32_FaultSyndrome_2" title="">AArch32_FaultSyndrome</a>(exceptype, fault);
    if exceptype == <a href="shared_pseudocode.html#enum_Exception_Watchpoint" title="">Exception_Watchpoint</a> then
        except.vaddress = fault.watchptinfo.vaddress;
    else
        except.vaddress = ZeroExtend{64}(fault.vaddress);
    end;

    if <a href="shared_pseudocode.html#func_IPAValid_1" title="">IPAValid</a>(fault) then
        except.ipavalid  = TRUE;
        except.NS        = if fault.ipaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> then '1' else '0';
        except.ipaddress = ZeroExtend{56}(fault.ipaddress.address);
    else
        except.ipavalid  = FALSE;
    end;

    return except;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32_CheckPCAlignment"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32_CheckPCAlignment</h3>
      <p class="pseudocode">// AArch32_CheckPCAlignment()
// ==========================

func AArch32_CheckPCAlignment()
begin
    let pc : bits(32) = ThisInstrAddr{}();

    if (CurrentInstrSet() == InstrSet_A32 &amp;&amp; pc[1] == '1') || pc[0] == '1' then
        if <a href="shared_pseudocode.html#func_AArch32_GeneralExceptionsToAArch64_0" title="">AArch32_GeneralExceptionsToAArch64</a>() then AArch64_PCAlignmentFault(); end;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescIFetch_0" title="">CreateAccDescIFetch</a>();
        var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, ZeroExtend{64}(pc));
        // Generate an Alignment fault Prefetch Abort exception
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a>;
        AArch32_Abort(fault);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32_CommonFaultStatus"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32_CommonFaultStatus</h3>
      <p class="pseudocode">// AArch32_CommonFaultStatus()
// ===========================
// Return the common part of the fault status on reporting a Data
// or Prefetch Abort.

func <a id="func_AArch32_CommonFaultStatus_2"/>AArch32_CommonFaultStatus(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, long_format : boolean) =&gt; bits(32)
begin
    var target : bits(32) = Zeros{};
    if IsFeatureImplemented(FEAT_RAS) &amp;&amp; <a href="shared_pseudocode.html#func_IsAsyncAbort_1" title="">IsAsyncAbort</a>(fault) then
        let errstate : <a href="shared_pseudocode.html#type_ErrorState" title="">ErrorState</a> = <a href="shared_pseudocode.html#func_PEErrorState_1" title="">PEErrorState</a>(fault);
        target[15:14] = <a href="shared_pseudocode.html#func_AArch32_EncodeAsyncErrorSyndrome_1" title="">AArch32_EncodeAsyncErrorSyndrome</a>(errstate);   // AET
    end;
    if <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) then target[12] = fault.extflag; end;   // ExT
    target[9] = if long_format then '1' else '0';                     // LPAE
    if long_format then                                               // Long-descriptor format
        target[5:0]    = <a href="shared_pseudocode.html#func_EncodeLDFSC_2" title="">EncodeLDFSC</a>(fault.statuscode, fault.level);  // STATUS
    else                                                              // Short-descriptor format
        target[10,3:0] = <a href="shared_pseudocode.html#func_EncodeSDFSC_2" title="">EncodeSDFSC</a>(fault.statuscode, fault.level);  // FS
    end;
    return target;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32_ReportDataAbort"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32_ReportDataAbort</h3>
      <p class="pseudocode">// AArch32_ReportDataAbort()
// =========================
// Report syndrome information for aborts taken to modes other than Hyp mode.

func AArch32_ReportDataAbort(route_to_monitor : boolean, fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    var long_format : boolean;
    if route_to_monitor &amp;&amp; <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
        long_format = ((TTBCR_S().EAE == '1') ||
                       (<a href="shared_pseudocode.html#func_IsExternalSyncAbort_1" title="">IsExternalSyncAbort</a>(fault) &amp;&amp; ((PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || TTBCR().EAE == '1') ||
                        (fault.secondstage &amp;&amp; (ImpDefBool(
                                               "Report abort using Long-descriptor format"))))));
    else
        long_format = TTBCR().EAE == '1';
    end;
    var syndrome : bits(32) = <a href="shared_pseudocode.html#func_AArch32_CommonFaultStatus_2" title="">AArch32_CommonFaultStatus</a>(fault, long_format);

    // bits of syndrome that are not common to I and D side
    if fault.accessdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>, <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>} then
        syndrome[13] = '1';                              // CM
        syndrome[11] = '1';                              // WnR
    else
        syndrome[11] = if fault.write then '1' else '0'; // WnR
    end;

    if !long_format then
        syndrome[7:4] = fault.domain;                    // Domain
    end;

    if fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a> then
        var i_syndrome : bits(32);
        if (!long_format &amp;&amp;
            ImpDefBool("Report I-cache maintenance fault in IFSR")) then
            i_syndrome = syndrome;
            syndrome[10,3:0] = <a href="shared_pseudocode.html#func_EncodeSDFSC_2" title="">EncodeSDFSC</a>(<a href="shared_pseudocode.html#enum_Fault_ICacheMaint" title="">Fault_ICacheMaint</a>, 1);
        else
            i_syndrome = ARBITRARY : bits(32);
        end;
        if route_to_monitor then
            IFSR_S() = i_syndrome;
        else
            IFSR()   = i_syndrome;
        end;
    end;

    if route_to_monitor then
        DFSR_S() = syndrome;
        DFAR_S() = fault.vaddress[31:0];
    else
        DFSR()   = syndrome;
        DFAR()   = fault.vaddress[31:0];
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32_ReportPrefetchAbort"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32_ReportPrefetchAbort</h3>
      <p class="pseudocode">// AArch32_ReportPrefetchAbort()
// =============================
// Report syndrome information for aborts taken to modes other than Hyp mode.

func AArch32_ReportPrefetchAbort(route_to_monitor : boolean, fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    // The encoding used in the IFSR can be Long-descriptor format or Short-descriptor format.
    // Normally, the current translation table format determines the format. For an abort from
    // Non-secure state to Monitor mode, the IFSR uses the Long-descriptor format if any of the
    // following applies:
    // * The Secure TTBCR.EAE is set to 1.
    // * It is taken from Hyp mode.
    // * It is taken from EL1 or EL0, and the Non-secure TTBCR.EAE is set to 1.
    var long_format : boolean = FALSE;
    if route_to_monitor &amp;&amp; <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
        long_format = TTBCR_S().EAE == '1' || PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || TTBCR().EAE == '1';
    else
        long_format = TTBCR().EAE == '1';
    end;

    let fsr : bits(32) = <a href="shared_pseudocode.html#func_AArch32_CommonFaultStatus_2" title="">AArch32_CommonFaultStatus</a>(fault, long_format);

    if route_to_monitor then
        IFSR_S() = fsr;
        IFAR_S() = fault.vaddress[31:0];
    else
        IFSR() = fsr;
        IFAR() = fault.vaddress[31:0];
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32_TakeDataAbortException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32_TakeDataAbortException</h3>
      <p class="pseudocode">// AArch32_TakeDataAbortException()
// ================================

func AArch32_TakeDataAbortException(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin

    var sea_target : bits(2);
    if <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) then
        sea_target = <a href="shared_pseudocode.html#func_SyncExternalAbortTarget_1" title="">SyncExternalAbortTarget</a>(fault);
    else
        sea_target = ARBITRARY : bits(2);
    end;

    let route_to_monitor : boolean = <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) &amp;&amp; sea_target == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
    let route_to_hyp : boolean     = (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp;
                                     (HCR().TGE == '1' ||
                                      (<a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) &amp;&amp; sea_target == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) ||
                                      (<a href="shared_pseudocode.html#func_IsDebugException_1" title="">IsDebugException</a>(fault) &amp;&amp; HDCR().TDE == '1') ||
                                      <a href="shared_pseudocode.html#func_IsSecondStage_1" title="">IsSecondStage</a>(fault)));

    let preferred_exception_return : bits(32) = ThisInstrAddr{}();
    let vect_offset : integer = 0x10;
    let lr_offset : integer = 8;

    if <a href="shared_pseudocode.html#func_IsDebugException_1" title="">IsDebugException</a>(fault) then DBGDSCRext().MOE = fault.debugmoe; end;
    if route_to_monitor then
        AArch32_ReportDataAbort(route_to_monitor, fault);
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_hyp then
        let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_AArch32_AbortSyndrome_3" title="">AArch32_AbortSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a>, fault, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
            AArch32_EnterHypMode(except, preferred_exception_return, vect_offset);
        else
            AArch32_EnterHypMode(except, preferred_exception_return, 0x14);
        end;
    else
        AArch32_ReportDataAbort(route_to_monitor, fault);
        AArch32_EnterMode(<a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32_TakePrefetchAbortException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32_TakePrefetchAbortException</h3>
      <p class="pseudocode">// AArch32_TakePrefetchAbortException()
// ====================================

func AArch32_TakePrefetchAbortException(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin

    var sea_target : bits(2);
    if <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) then
        sea_target = <a href="shared_pseudocode.html#func_SyncExternalAbortTarget_1" title="">SyncExternalAbortTarget</a>(fault);
    else
        sea_target = ARBITRARY : bits(2);
    end;

    let route_to_monitor : boolean = <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) &amp;&amp; sea_target == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
    let route_to_hyp : boolean = (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp;
                                  (HCR().TGE == '1' ||
                                  (<a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) &amp;&amp; sea_target == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) ||
                                  (<a href="shared_pseudocode.html#func_IsDebugException_1" title="">IsDebugException</a>(fault) &amp;&amp; HDCR().TDE == '1') ||
                                   <a href="shared_pseudocode.html#func_IsSecondStage_1" title="">IsSecondStage</a>(fault)));

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>;
    let preferred_exception_return : bits(32) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0C;
    let lr_offset : integer = 4;

    if <a href="shared_pseudocode.html#func_IsDebugException_1" title="">IsDebugException</a>(fault) then DBGDSCRext().MOE = fault.debugmoe; end;
    if route_to_monitor then
        AArch32_ReportPrefetchAbort(route_to_monitor, fault);
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_hyp then
        if fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a> then             // PC Alignment fault
            except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_PCAlignment" title="">Exception_PCAlignment</a>);
            except.vaddress = <a href="shared_pseudocode.html#func_ThisInstrAddr_1" title="">ThisInstrAddr</a>{64}();
        else
            except = <a href="shared_pseudocode.html#func_AArch32_AbortSyndrome_3" title="">AArch32_AbortSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_InstructionAbort" title="">Exception_InstructionAbort</a>, fault, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
        end;
        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
            AArch32_EnterHypMode(except, preferred_exception_return, vect_offset);
        else
            AArch32_EnterHypMode(except, preferred_exception_return, 0x14);
        end;
    else
        AArch32_ReportPrefetchAbort(route_to_monitor, fault);
        AArch32_EnterMode(<a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32_TakePhysicalFIQException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32_TakePhysicalFIQException</h3>
      <p class="pseudocode">// AArch32_TakePhysicalFIQException()
// ==================================

func AArch32_TakePhysicalFIQException()
begin

    // Check if routed to AArch64 state
    var route_to_aarch64 : boolean = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        route_to_aarch64 = HCR_EL2().TGE == '1' || (HCR_EL2().FMO == '1' &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>());
    end;

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        route_to_aarch64 = SCR_EL3().FIQ == '1';
    end;

    if route_to_aarch64 then AArch64_TakePhysicalFIQException(); end;
    let route_to_monitor : boolean = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR().FIQ == '1';
    let route_to_hyp : boolean = (PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
                                  (HCR().TGE == '1' || HCR().FMO == '1'));
    let preferred_exception_return : bits(32) = ThisInstrAddr{}();
    let vect_offset : integer = 0x1C;
    let lr_offset : integer = 4;
    if route_to_monitor then
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_hyp then
        let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_FIQ" title="">Exception_FIQ</a>);
        AArch32_EnterHypMode(except, preferred_exception_return, vect_offset);
    else
        AArch32_EnterMode(<a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a>, preferred_exception_return, lr_offset, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32_TakePhysicalIRQException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32_TakePhysicalIRQException</h3>
      <p class="pseudocode">// AArch32_TakePhysicalIRQException()
// ==================================
// Take an enabled physical IRQ exception.

func AArch32_TakePhysicalIRQException()
begin

    // Check if routed to AArch64 state
    var route_to_aarch64 : boolean = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        route_to_aarch64 = HCR_EL2().TGE == '1' || (HCR_EL2().IMO == '1' &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>());
    end;
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        route_to_aarch64 = SCR_EL3().IRQ == '1';
    end;

    if route_to_aarch64 then AArch64_TakePhysicalIRQException(); end;

    let route_to_monitor : boolean = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR().IRQ == '1';
    let route_to_hyp : boolean = (PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
                                  (HCR().TGE == '1' || HCR().IMO == '1'));
    let preferred_exception_return : bits(32) = ThisInstrAddr{}();
    let vect_offset : integer = 0x18;
    let lr_offset : integer = 4;
    if route_to_monitor then
        AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_hyp then
        let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_IRQ" title="">Exception_IRQ</a>);
        AArch32_EnterHypMode(except, preferred_exception_return, vect_offset);
    else
        AArch32_EnterMode(<a href="shared_pseudocode.html#global_M32_IRQ" title="">M32_IRQ</a>, preferred_exception_return, lr_offset, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32_TakePhysicalSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32_TakePhysicalSErrorException</h3>
      <p class="pseudocode">// AArch32_TakePhysicalSErrorException()
// =====================================

func AArch32_TakePhysicalSErrorException(implicit_esb : boolean)
begin
    var masked : boolean;
    var target_el : bits(2);

    (masked, target_el) = <a href="shared_pseudocode.html#func_PhysicalSErrorTarget_0" title="">PhysicalSErrorTarget</a>();
    assert !masked;

    // Check if routed to AArch64 state
    if !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(target_el) then
        AArch64_TakePhysicalSErrorException(implicit_esb);
    end;

    let preferred_exception_return : bits(32) = ThisInstrAddr{}();
    let vect_offset : integer = 0x10;
    let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_GetPendingPhysicalSError_0" title="">GetPendingPhysicalSError</a>();
    let lr_offset : integer = 8;

    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>   = <a href="shared_pseudocode.html#func_AArch32_AbortSyndrome_3" title="">AArch32_AbortSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a>, fault, target_el);
    let route_to_monitor : boolean = (target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);

    if <a href="shared_pseudocode.html#func_IsSErrorEdgeTriggered_0" title="">IsSErrorEdgeTriggered</a>() then
        ClearPendingPhysicalSError();
    end;

    case target_el of
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            AArch32_ReportDataAbort(route_to_monitor, fault);
            AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset);
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
                AArch32_EnterHypMode(except, preferred_exception_return, vect_offset);
            else
                AArch32_EnterHypMode(except, preferred_exception_return, 0x14);
            end;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            AArch32_ReportDataAbort(route_to_monitor, fault);
            AArch32_EnterMode(<a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32_TakeVirtualFIQException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32_TakeVirtualFIQException</h3>
      <p class="pseudocode">// AArch32_TakeVirtualFIQException()
// =================================

func AArch32_TakeVirtualFIQException()
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then  // Virtual IRQ enabled if TGE==0 and FMO==1
        assert HCR().TGE == '0' &amp;&amp; HCR().FMO == '1';
    else
        assert HCR_EL2().TGE == '0' &amp;&amp; HCR_EL2().FMO == '1';
    end;
    // Check if routed to AArch64 state
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then AArch64_TakeVirtualFIQException(); end;

    let preferred_exception_return : bits(32) = ThisInstrAddr{}();
    let vect_offset : integer = 0x1C;
    let lr_offset : integer   = 4;

    AArch32_EnterMode(<a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a>, preferred_exception_return, lr_offset, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32_TakeVirtualIRQException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32_TakeVirtualIRQException</h3>
      <p class="pseudocode">// AArch32_TakeVirtualIRQException()
// =================================

func AArch32_TakeVirtualIRQException()
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();

    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then   // Virtual IRQs enabled if TGE==0 and IMO==1
        assert HCR().TGE == '0' &amp;&amp; HCR().IMO == '1';
    else
        assert HCR_EL2().TGE == '0' &amp;&amp; HCR_EL2().IMO == '1';
    end;

    // Check if routed to AArch64 state
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then AArch64_TakeVirtualIRQException(); end;

    let preferred_exception_return :  bits(32) = ThisInstrAddr{}();
    let vect_offset : integer = 0x18;
    let lr_offset : integer = 4;

    AArch32_EnterMode(<a href="shared_pseudocode.html#global_M32_IRQ" title="">M32_IRQ</a>, preferred_exception_return, lr_offset, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32_TakeVirtualSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32_TakeVirtualSErrorException</h3>
      <p class="pseudocode">// AArch32_TakeVirtualSErrorException()
// ====================================

func AArch32_TakeVirtualSErrorException()
begin

    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then   // Virtual SError enabled if TGE==0 and AMO==1
        assert HCR().TGE == '0' &amp;&amp; HCR().AMO == '1';
    else
        assert HCR_EL2().TGE == '0' &amp;&amp; HCR_EL2().AMO == '1';
    end;
    // Check if routed to AArch64 state
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then AArch64_TakeVirtualSErrorException(); end;
    let route_to_monitor : boolean = FALSE;

    let preferred_exception_return : bits(32) = ThisInstrAddr{}();
    let vect_offset : integer = 0x10;
    let lr_offset : integer   = 8;

    let vaddress : bits(32)   = ARBITRARY : bits(32);
    let parity : boolean      = FALSE;
    let fault : <a href="shared_pseudocode.html#type_Fault" title="">Fault</a>         = <a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a>;
    let level : integer       = ARBITRARY : integer;
    var fsr : bits(32)        = Zeros{};
    if IsFeatureImplemented(FEAT_RAS) then
        if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            fsr[15:14] =  VDFSR().AET;
            fsr[12] =  VDFSR().ExT;
        else
            fsr[15:14] =  VSESR_EL2().AET;
            fsr[12] =  VSESR_EL2().ExT;
        end;
    else
        fsr[12] = ImpDefBit("Virtual External abort type");
    end;
    if TTBCR().EAE == '1' then // Long-descriptor format
        fsr[9] = '1';
        fsr[5:0] = <a href="shared_pseudocode.html#func_EncodeLDFSC_2" title="">EncodeLDFSC</a>(fault, level);
    else                       // Short-descriptor format
        fsr[9] = '0';
        fsr[10,3:0] = <a href="shared_pseudocode.html#func_EncodeSDFSC_2" title="">EncodeSDFSC</a>(fault, level);
    end;
    DFSR() = fsr;
    DFAR() = ARBITRARY : bits(32);
    ClearPendingVirtualSError();
    AArch32_EnterMode(<a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.debug.AArch32_SoftwareBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/debug/AArch32_SoftwareBreakpoint</h3>
      <p class="pseudocode">// AArch32_SoftwareBreakpoint()
// ============================

func AArch32_SoftwareBreakpoint(immediate : bits(16))
begin

    if (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp;
        (HCR_EL2().TGE == '1' || MDCR_EL2().TDE == '1')) || !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        AArch64_SoftwareBreakpoint(immediate);
    end;

    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescIFetch_0" title="">CreateAccDescIFetch</a>();
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, ARBITRARY : bits(64));

    fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Debug" title="">Fault_Debug</a>;
    fault.debugmoe   = <a href="shared_pseudocode.html#global_DebugException_BKPT" title="">DebugException_BKPT</a>;

    AArch32_Abort(fault);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.debug.DebugException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/debug/DebugException</h3>
      <p class="pseudocode">// DebugException
// ==============
// Reason codes for debug exceptions, taken to AArch32

constant <a id="global_DebugException_Breakpoint"/>DebugException_Breakpoint : bits(4)  = '0001';

constant <a id="global_DebugException_BKPT"/>DebugException_BKPT : bits(4)        = '0011';

constant <a id="global_DebugException_VectorCatch"/>DebugException_VectorCatch : bits(4) = '0101';

constant <a id="global_DebugException_Watchpoint"/>DebugException_Watchpoint : bits(4)  = '1010';</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32_CheckAdvSIMDOrFPRegisterTraps"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32_CheckAdvSIMDOrFPRegisterTraps</h3>
      <p class="pseudocode">// AArch32_CheckAdvSIMDOrFPRegisterTraps()
// =======================================
// Check if an instruction that accesses an Advanced SIMD and
// floating-point System register is trapped by an appropriate HCR.TIDx
// ID group trap control.

func AArch32_CheckAdvSIMDOrFPRegisterTraps(reg : bits(4))
begin
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        let tid0 : bit = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then HCR().TID0 else HCR_EL2().TID0;
        let tid3 : bit = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then HCR().TID3 else HCR_EL2().TID3;
        if ((tid0 == '1' &amp;&amp; reg == '0000') ||                            // FPSID
              (tid3 == '1' &amp;&amp; reg IN {'0101', '0110', '0111'})) then     // MVFRx
            if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
                AArch32_SystemAccessTrap(<a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>, 0x8);
            else
                AArch64_AArch32SystemAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, 0x8);
            end;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32_ExceptionClass"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32_ExceptionClass</h3>
      <p class="pseudocode">// AArch32_ExceptionClass()
// ========================
// Returns the Exception Class and Instruction Length fields to be reported in HSR

func <a id="func_AArch32_ExceptionClass_1"/>AArch32_ExceptionClass(exceptype : <a href="shared_pseudocode.html#type_Exception" title="">Exception</a>) =&gt; (integer,bit)
begin
    var il_is_valid : boolean = TRUE;
    var ec : integer;
    case exceptype of
        when <a href="shared_pseudocode.html#enum_Exception_Uncategorized" title="">Exception_Uncategorized</a> =&gt;        ec = 0x00; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_WFxTrap" title="">Exception_WFxTrap</a> =&gt;              ec = 0x01;
        when <a href="shared_pseudocode.html#enum_Exception_CP15RTTrap" title="">Exception_CP15RTTrap</a> =&gt;           ec = 0x03;
        when <a href="shared_pseudocode.html#enum_Exception_CP15RRTTrap" title="">Exception_CP15RRTTrap</a> =&gt;          ec = 0x04;
        when <a href="shared_pseudocode.html#enum_Exception_CP14RTTrap" title="">Exception_CP14RTTrap</a> =&gt;           ec = 0x05;
        when <a href="shared_pseudocode.html#enum_Exception_CP14DTTrap" title="">Exception_CP14DTTrap</a> =&gt;           ec = 0x06;
        when <a href="shared_pseudocode.html#enum_Exception_AdvSIMDFPAccessTrap" title="">Exception_AdvSIMDFPAccessTrap</a> =&gt;  ec = 0x07;
        when <a href="shared_pseudocode.html#enum_Exception_FPIDTrap" title="">Exception_FPIDTrap</a> =&gt;             ec = 0x08;
        when <a href="shared_pseudocode.html#enum_Exception_PACTrap" title="">Exception_PACTrap</a> =&gt;               ec = 0x09;
        when <a href="shared_pseudocode.html#enum_Exception_GPC" title="">Exception_GPC</a> =&gt;                   ec = 0x1E;
        when <a href="shared_pseudocode.html#enum_Exception_CP14RRTTrap" title="">Exception_CP14RRTTrap</a> =&gt;           ec = 0x0C;
        when <a href="shared_pseudocode.html#enum_Exception_BranchTarget" title="">Exception_BranchTarget</a> =&gt;          ec = 0x0D;
        when <a href="shared_pseudocode.html#enum_Exception_IllegalState" title="">Exception_IllegalState</a> =&gt;         ec = 0x0E; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_SupervisorCall" title="">Exception_SupervisorCall</a> =&gt;       ec = 0x11;
        when <a href="shared_pseudocode.html#enum_Exception_HypervisorCall" title="">Exception_HypervisorCall</a> =&gt;       ec = 0x12;
        when <a href="shared_pseudocode.html#enum_Exception_MonitorCall" title="">Exception_MonitorCall</a> =&gt;          ec = 0x13;
        when <a href="shared_pseudocode.html#enum_Exception_InstructionAbort" title="">Exception_InstructionAbort</a> =&gt;
            ec = if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then 0x21 else 0x20;
            il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_PCAlignment" title="">Exception_PCAlignment</a> =&gt;          ec = 0x22; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a> =&gt;            ec = if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then 0x25 else 0x24;
        when <a href="shared_pseudocode.html#enum_Exception_NV2DataAbort" title="">Exception_NV2DataAbort</a> =&gt;          ec = 0x25;
        when <a href="shared_pseudocode.html#enum_Exception_FPTrappedException" title="">Exception_FPTrappedException</a> =&gt;    ec = 0x28;
        when <a href="shared_pseudocode.html#enum_Exception_Profiling" title="">Exception_Profiling</a> =&gt;             ec = 0x3D;
        otherwise =&gt;                            unreachable;
    end;

    var il : bit;
    if il_is_valid then
        il = if <a href="shared_pseudocode.html#func_ThisInstrLength_0" title="">ThisInstrLength</a>() == 32 then '1' else '0';
    else
        il = '1';
    end;

    return (ec,il);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32_GeneralExceptionsToAArch64"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32_GeneralExceptionsToAArch64</h3>
      <p class="pseudocode">// AArch32_GeneralExceptionsToAArch64()
// ====================================
// Returns TRUE if exceptions normally routed to EL1 are being handled at an Exception
// level using AArch64, because either EL1 is using AArch64 or TGE is in force and EL2
// is using AArch64.

func <a id="func_AArch32_GeneralExceptionsToAArch64_0"/>AArch32_GeneralExceptionsToAArch64() =&gt; boolean
begin
    return ((PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>)) ||
            (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; HCR_EL2().TGE == '1'));
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32_ReportHypEntry"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32_ReportHypEntry</h3>
      <p class="pseudocode">// AArch32_ReportHypEntry()
// ========================
// Report syndrome information to Hyp mode registers.

func AArch32_ReportHypEntry(except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>)
begin

    let exceptype : <a href="shared_pseudocode.html#type_Exception" title="">Exception</a> = except.exceptype;

    var (ec,il) : (integer, bit) = <a href="shared_pseudocode.html#func_AArch32_ExceptionClass_1" title="">AArch32_ExceptionClass</a>(exceptype);
    let iss  : bits(25)= except.syndrome.iss;
    let iss2 : bits(24)= except.syndrome.iss2;

    // IL is not valid for Data Abort exceptions without valid instruction syndrome information
    if ec IN {0x24,0x25} &amp;&amp; iss[24] == '0' then
        il = '1';
    end;

    HSR() = ec[5:0]::il::iss;

    if exceptype IN {<a href="shared_pseudocode.html#enum_Exception_InstructionAbort" title="">Exception_InstructionAbort</a>, <a href="shared_pseudocode.html#enum_Exception_PCAlignment" title="">Exception_PCAlignment</a>} then
        HIFAR() = except.vaddress[31:0];
        HDFAR() = ARBITRARY : bits(32);
    elsif exceptype == <a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a> then
        HIFAR() = ARBITRARY : bits(32);
        HDFAR() = except.vaddress[31:0];
    end;

    if except.ipavalid then
        HPFAR()[31:4] = except.ipaddress[39:12];
    else
        HPFAR()[31:4] = ARBITRARY : bits(28);
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32_ResetControlRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32_ResetControlRegisters</h3>
      <p class="pseudocode">// AArch32_ResetControlRegisters()
// ===============================
// Resets System registers and memory-mapped control registers that have architecturally-defined
// reset values to those values.

impdef func AArch32_ResetControlRegisters(cold_reset : boolean)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32_TakeReset"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32_TakeReset</h3>
      <p class="pseudocode">// AArch32_TakeReset()
// ===================
// Reset into AArch32 state

func AArch32_TakeReset(cold_reset : boolean)
begin
    assert !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>();

    // Enter the highest implemented Exception level in AArch32 state
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        AArch32_WriteMode(<a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>);
        SCR().NS = '0';                                 // Secure state
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        AArch32_WriteMode(<a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>);
    else
        AArch32_WriteMode(<a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>);
    end;

    // Reset System registers in the coproc=0b111x encoding space
    // and other system components
    AArch32_ResetControlRegisters(cold_reset);
    FPEXC().EN = '0';

    // Reset all other PSTATE fields, including instruction set and endianness according to the
    // SCTLR values produced by the above call to ResetControlRegisters()
    PSTATE.[A,I,F] = '111';             // All asynchronous exceptions masked
    PSTATE.IT = '00000000';             // IT block state reset
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        PSTATE.T = HSCTLR().TE;           // Instruction set: TE=0:A32, TE=1:T32. PSTATE.J is RES0.
        PSTATE.E = HSCTLR().EE;           // Endianness: EE=0: little-endian, EE=1: big-endian.
    else
        PSTATE.T = SCTLR().TE;            // Instruction set: TE=0:A32, TE=1:T32. PSTATE.J is RES0.
        PSTATE.E = SCTLR().EE;            // Endianness: EE=0: little-endian, EE=1: big-endian.
    end;
    PSTATE.IL = '0';                    // Clear Illegal Execution state bit

    // All registers, bits and fields not reset by the above pseudocode or by the BranchTo() call
    // below are UNKNOWN bitstrings after reset. In particular, the return information registers
    // R14 or ELR_hyp and SPSR have UNKNOWN values, so that it
    // is impossible to return from a reset in an architecturally defined way.
    AArch32_ResetGeneralRegisters();
    if IsFeatureImplemented(FEAT_SME) || IsFeatureImplemented(FEAT_SVE) then
        ResetSVERegisters();
    else
        AArch32_ResetSIMDFPRegisters();
    end;
    AArch32_ResetSpecialRegisters();
    ResetExternalDebugRegisters(cold_reset);

    var rv : bits(32);                          // IMPLEMENTATION DEFINED reset vector

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if MVBAR()[0] == '1' then           // Reset vector in MVBAR
            rv = MVBAR()[31:1]::'0';
        else
            rv = ImpDefBits{32}("reset vector address");
        end;
    else
        rv = RVBAR()[31:1]::'0';
    end;

    // The reset vector must be correctly aligned
    assert rv[0] == '0' &amp;&amp; (PSTATE.T == '1' || rv[1] == '0');

    let branch_conditional : boolean = FALSE;
    EDPRSR().R = '0';                 // Leaving Reset State.
    BranchTo{32}(rv, <a href="shared_pseudocode.html#enum_BranchType_RESET" title="">BranchType_RESET</a>, branch_conditional);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.ExcVectorBase"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/ExcVectorBase</h3>
      <p class="pseudocode">// ExcVectorBase()
// ===============

func <a id="func_ExcVectorBase_0"/>ExcVectorBase() =&gt; bits(32)
begin
    if SCTLR().V == '1' then  // Hivecs selected, base = 0xFFFF0000
        return Ones{16}::Zeros{16};
    else
        return VBAR()[31:5]::Zeros{5};
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.ieeefp.AArch32_FPTrappedException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/ieeefp/AArch32_FPTrappedException</h3>
      <p class="pseudocode">// AArch32_FPTrappedException()
// ============================

func AArch32_FPTrappedException(accumulated_exceptions : bits(8))
begin
    if <a href="shared_pseudocode.html#func_AArch32_GeneralExceptionsToAArch64_0" title="">AArch32_GeneralExceptionsToAArch64</a>() then
        let is_ase : boolean = FALSE;
        let element : integer = 0;
        AArch64_FPTrappedException(is_ase, accumulated_exceptions);
    end;
    FPEXC().DEX    = '1';
    FPEXC().TFV    = '1';
    FPEXC()[7,4:0] = accumulated_exceptions[7,4:0];                  // IDF,IXF,UFF,OFF,DZF,IOF
    FPEXC()[10:8]  = '111';                                          // VECITR is RES1

    AArch32_TakeUndefInstrException();
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32_CallHypervisor"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32_CallHypervisor</h3>
      <p class="pseudocode">// AArch32_CallHypervisor()
// ========================
// Performs a HVC call

func AArch32_CallHypervisor(immediate : bits(16))
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);

    if !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        AArch64_CallHypervisor(immediate);
    else
        AArch32_TakeHVCException(immediate);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32_CallSupervisor"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32_CallSupervisor</h3>
      <p class="pseudocode">// AArch32_CallSupervisor()
// ========================
// Calls the Supervisor

func AArch32_CallSupervisor(immediate_in : bits(16))
begin
    var immediate : bits(16) = immediate_in;
    if <a href="shared_pseudocode.html#func_CurrentCond_0" title="">CurrentCond</a>() != '1110' then
        immediate = ARBITRARY : bits(16);
    end;
    if <a href="shared_pseudocode.html#func_AArch32_GeneralExceptionsToAArch64_0" title="">AArch32_GeneralExceptionsToAArch64</a>() then
        AArch64_CallSupervisor(immediate);
    else
        AArch32_TakeSVCException(immediate);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32_TakeHVCException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32_TakeHVCException</h3>
      <p class="pseudocode">// AArch32_TakeHVCException()
// ==========================

func AArch32_TakeHVCException(immediate : bits(16))
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);

    AArch32_ITAdvance();
    SSAdvance();
    let preferred_exception_return : bits(32) = NextInstrAddr{}();
    let vect_offset : integer{} = 0x08;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_HypervisorCall" title="">Exception_HypervisorCall</a>);
    except.syndrome.iss[15:0] = immediate;

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        AArch32_EnterHypMode(except, preferred_exception_return, vect_offset);
    else
        AArch32_EnterHypMode(except, preferred_exception_return, 0x14);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32_TakeSMCException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32_TakeSMCException</h3>
      <p class="pseudocode">// AArch32_TakeSMCException()
// ==========================

func AArch32_TakeSMCException()
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
    AArch32_ITAdvance();
    HSAdvance();
    SSAdvance();
    let preferred_exception_return : bits(32) = NextInstrAddr{}();
    let vect_offset : integer{} = 0x08;
    let lr_offset : integer{} = 0;

    AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32_TakeSVCException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32_TakeSVCException</h3>
      <p class="pseudocode">// AArch32_TakeSVCException()
// ==========================

func AArch32_TakeSVCException(immediate : bits(16))
begin

    AArch32_ITAdvance();
    SSAdvance();
    let route_to_hyp : boolean = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR().TGE == '1';

    let preferred_exception_return : bits(32) = NextInstrAddr{}();
    let vect_offset : integer{} = 0x08;
    let lr_offset : integer{} = 0;

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_hyp then
        var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SupervisorCall" title="">Exception_SupervisorCall</a>);
        except.syndrome.iss[15:0] = immediate;
        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
            AArch32_EnterHypMode(except, preferred_exception_return, vect_offset);
        else
            AArch32_EnterHypMode(except, preferred_exception_return, 0x14);
        end;
    else
        AArch32_EnterMode(<a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>, preferred_exception_return, lr_offset, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.takeexception.AArch32_EnterHypMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/takeexception/AArch32_EnterHypMode</h3>
      <p class="pseudocode">// AArch32_EnterHypMode()
// ======================
// Take an exception to Hyp mode.

noreturn func AArch32_EnterHypMode(except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>, preferred_exception_return : bits(32),
                                   vect_offset : integer)
begin
    SynchronizeContext();
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);

    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        AArch32_EnterHypModeInDebugState(except);
    end;
    let spsr : bits(32) = GetPSRFromPSTATE{}(<a href="shared_pseudocode.html#enum_AArch32_NonDebugState" title="">AArch32_NonDebugState</a>);
    if ! except.exceptype IN {<a href="shared_pseudocode.html#enum_Exception_IRQ" title="">Exception_IRQ</a>, <a href="shared_pseudocode.html#enum_Exception_FIQ" title="">Exception_FIQ</a>} then
        AArch32_ReportHypEntry(except);
    end;
    AArch32_WriteMode(<a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>);
    <a href="shared_pseudocode.html#accessor_SPSR_curr_0" title="">SPSR_curr</a>() = spsr;
    ELR_hyp() = preferred_exception_return;
    PSTATE.T = HSCTLR().TE;                       // PSTATE.J is RES0
    PSTATE.SS = '0';
    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        PSTATE.A = '1';
        PSTATE.I = '1';
        PSTATE.F = '1';
    else
        if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            if SCR().EA  == '0' then PSTATE.A = '1'; end;
            if SCR().IRQ == '0' then PSTATE.I = '1'; end;
            if SCR().FIQ == '0' then PSTATE.F = '1'; end;
        else
            if SCR_EL3().EA  == '0' then PSTATE.A = '1'; end;
            if SCR_EL3().IRQ == '0' then PSTATE.I = '1'; end;
            if SCR_EL3().FIQ == '0' then PSTATE.F = '1'; end;
        end;
    end;
    PSTATE.E = HSCTLR().EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if IsFeatureImplemented(FEAT_SSBS) then PSTATE.SSBS = HSCTLR().DSSBS; end;
    let branch_conditional : boolean = FALSE;
    BranchTo{32}(HVBAR()[31:5]::vect_offset[4:0], <a href="shared_pseudocode.html#enum_BranchType_EXCEPTION" title="">BranchType_EXCEPTION</a>, branch_conditional);

    CheckExceptionCatch(TRUE);                  // Check for debug event on exception entry

    EndOfInstruction();
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.takeexception.AArch32_EnterMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/takeexception/AArch32_EnterMode</h3>
      <p class="pseudocode">// AArch32_EnterMode()
// ===================
// Take an exception to a mode other than Monitor and Hyp mode.

noreturn func AArch32_EnterMode(target_mode : bits(5),
                                preferred_exception_return : bits(32),
                                lr_offset : integer,
                                vect_offset : integer)
begin
    SynchronizeContext();
    assert <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;

    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        AArch32_EnterModeInDebugState(target_mode);
    end;
    let spsr : bits(32) = GetPSRFromPSTATE{}(<a href="shared_pseudocode.html#enum_AArch32_NonDebugState" title="">AArch32_NonDebugState</a>);
    if PSTATE.M == <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> then SCR().NS = '0'; end;
    AArch32_WriteMode(target_mode);
    <a href="shared_pseudocode.html#accessor_SPSR_curr_0" title="">SPSR_curr</a>() = spsr;
    <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(14) = preferred_exception_return + lr_offset;
    PSTATE.T  = SCTLR().TE;                       // PSTATE.J is RES0
    PSTATE.SS = '0';
    if target_mode == <a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a> then
        PSTATE.[A,I,F] = '111';
    elsif target_mode IN {<a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>, <a href="shared_pseudocode.html#global_M32_IRQ" title="">M32_IRQ</a>} then
        PSTATE.[A,I] = '11';
    else
        PSTATE.I = '1';
    end;
    PSTATE.E  = SCTLR().EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if IsFeatureImplemented(FEAT_PAN) &amp;&amp; SCTLR().SPAN == '0' then PSTATE.PAN = '1'; end;
    if IsFeatureImplemented(FEAT_SSBS) then PSTATE.SSBS = SCTLR().DSSBS; end;
    let branch_conditional : boolean = FALSE;
    BranchTo{32}(<a href="shared_pseudocode.html#func_ExcVectorBase_0" title="">ExcVectorBase</a>()[31:5]::vect_offset[4:0], <a href="shared_pseudocode.html#enum_BranchType_EXCEPTION" title="">BranchType_EXCEPTION</a>, branch_conditional);

    CheckExceptionCatch(TRUE);                  // Check for debug event on exception entry

    EndOfInstruction();
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.takeexception.AArch32_EnterMonitorMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/takeexception/AArch32_EnterMonitorMode</h3>
      <p class="pseudocode">// AArch32_EnterMonitorMode()
// ==========================
// Take an exception to Monitor mode.

func AArch32_EnterMonitorMode(preferred_exception_return : bits(32), lr_offset : integer,
                              vect_offset : integer)
begin
    SynchronizeContext();
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
    let from_secure : boolean = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        AArch32_EnterMonitorModeInDebugState();
    end;
    let spsr : bits(32) = GetPSRFromPSTATE{}(<a href="shared_pseudocode.html#enum_AArch32_NonDebugState" title="">AArch32_NonDebugState</a>);
    if PSTATE.M == <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> then SCR().NS = '0'; end;
    AArch32_WriteMode(<a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a>);
    <a href="shared_pseudocode.html#accessor_SPSR_curr_0" title="">SPSR_curr</a>() = spsr;
    <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(14) = preferred_exception_return + lr_offset;
    PSTATE.T       = SCTLR().TE;                        // PSTATE.J is RES0
    PSTATE.SS      = '0';
    PSTATE.[A,I,F] = '111';
    PSTATE.E       = SCTLR().EE;
    PSTATE.IL      = '0';
    PSTATE.IT      = '00000000';
    if IsFeatureImplemented(FEAT_PAN) then
        if !from_secure then
            PSTATE.PAN = '0';
        elsif SCTLR().SPAN == '0' then
            PSTATE.PAN = '1';
        end;
    end;
    if IsFeatureImplemented(FEAT_SSBS) then PSTATE.SSBS = SCTLR().DSSBS; end;
    let branch_conditional : boolean = FALSE;
    BranchTo{32}(MVBAR()[31:5]::vect_offset[4:0], <a href="shared_pseudocode.html#enum_BranchType_EXCEPTION" title="">BranchType_EXCEPTION</a>, branch_conditional);

    CheckExceptionCatch(TRUE);                  // Check for debug event on exception entry

    EndOfInstruction();
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_CheckAdvSIMDOrFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_CheckAdvSIMDOrFPEnabled</h3>
      <p class="pseudocode">// AArch32_CheckAdvSIMDOrFPEnabled()
// =================================
// Check against CPACR, FPEXC, HCPTR, NSACR, and CPTR_EL3.

func AArch32_CheckAdvSIMDOrFPEnabled(fpexc_check_in : boolean, advsimd : boolean)
begin
    var fpexc_check : boolean = fpexc_check_in;
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        // When executing at EL0 using AArch32, if EL1 is using AArch64 then the Effective value of
        // FPEXC.EN is 1. This includes when EL2 is using AArch64 and enabled in the current
        // Security state, HCR_EL2.TGE is 1, and the Effective value of HCR_EL2.RW is 1.
        AArch64_CheckFPAdvSIMDEnabled();
    else
        var cpacr_asedis = CPACR().ASEDIS;
        var cpacr_cp10 = CPACR().cp10;

        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> then
            // Check if access disabled in NSACR
            if NSACR().NSASEDIS == '1' then cpacr_asedis = '1'; end;
            if NSACR().cp10 == '0' then cpacr_cp10 = '00'; end;
        end;

        if PSTATE.EL != <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
            // Check if Advanced SIMD disabled in CPACR
            if advsimd &amp;&amp; cpacr_asedis == '1' then AArch32_Undefined(); end;

            // Check if access disabled in CPACR
            var disabled : boolean;
            case cpacr_cp10 of
                when '00' =&gt; disabled = TRUE;
                when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
                when '10' =&gt; disabled = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_RESCPACR" title="">Unpredictable_RESCPACR</a>);
                when '11' =&gt; disabled = FALSE;
            end;
            if disabled then AArch32_Undefined(); end;
        end;

        // If required, check FPEXC enabled bit.
        if (fpexc_check &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp;
              HCR_EL2().TGE == '1') then
            // When executing at EL0 using AArch32, if EL2 is using AArch64 and enabled in the
            // current Security state, HCR_EL2.TGE is 1, and the Effective value of HCR_EL2.RW is 0
            // then it is IMPLEMENTATION DEFINED whether the Effective value of FPEXC.EN is 1
            // or the value of FPEXC32_EL2.EN.
            fpexc_check = (ImpDefBool(
                           "Use FPEXC32_EL2.EN value when {TGE,RW} == {1,0}"));
        end;

        if fpexc_check &amp;&amp; FPEXC().EN == '0' then
            AArch32_Undefined();
        end;

        AArch32_CheckFPAdvSIMDTrap(advsimd);    // Also check against HCPTR and CPTR_EL3
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_CheckFPAdvSIMDTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_CheckFPAdvSIMDTrap</h3>
      <p class="pseudocode">// AArch32_CheckFPAdvSIMDTrap()
// ============================
// Check against CPTR_EL2 and CPTR_EL3.

func AArch32_CheckFPAdvSIMDTrap(advsimd : boolean)
begin
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        AArch64_CheckFPAdvSIMDTrap();
    else
        if (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp;
            CPTR_EL3().TFP == '1' &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndefPriority_0" title="">EL3SDDUndefPriority</a>()) then
            Undefined();
        end;

        let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; ss != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
            var hcptr_tase = HCPTR().TASE;
            var hcptr_cp10 = HCPTR().TCP10;

            if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
                // Check if access disabled in NSACR
                if NSACR().NSASEDIS == '1' then hcptr_tase = '1'; end;
                if NSACR().cp10 == '0' then hcptr_cp10 = '1'; end;
            end;

            // Check if access disabled in HCPTR
            if (advsimd &amp;&amp; hcptr_tase == '1') || hcptr_cp10 == '1' then
                var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_AdvSIMDFPAccessTrap" title="">Exception_AdvSIMDFPAccessTrap</a>);
                except.syndrome.iss[24:20] = <a href="shared_pseudocode.html#func_ConditionSyndrome_0" title="">ConditionSyndrome</a>();

                if advsimd then
                    except.syndrome.iss[5] = '1';
                else
                    except.syndrome.iss[5]   = '0';
                    except.syndrome.iss[3:0] = '1010';         // coproc field, always 0xA
                end;

                if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
                    AArch32_TakeUndefInstrException(except);
                else
                    AArch32_TakeHypTrapException(except);
                end;
            end;
        end;

        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            // Check if access disabled in CPTR_EL3
            if CPTR_EL3().TFP == '1' then
                if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then
                    Undefined();
                else
                    AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
                end;
            end;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_CheckForSMCUndefOrTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_CheckForSMCUndefOrTrap</h3>
      <p class="pseudocode">// AArch32_CheckForSMCUndefOrTrap()
// ================================
// Check for UNDEFINED or trap on SMC instruction

func AArch32_CheckForSMCUndefOrTrap()
begin
    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        Undefined();
    end;

    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        AArch64_CheckForSMCUndefOrTrap(Zeros{16});
    else
        let route_to_hyp : boolean = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; HCR().TSC == '1';
        if route_to_hyp then
            let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_MonitorCall" title="">Exception_MonitorCall</a>);
            AArch32_TakeHypTrapException(except);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_CheckForSVCTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_CheckForSVCTrap</h3>
      <p class="pseudocode">// AArch32_CheckForSVCTrap()
// =========================
// Check for trap on SVC instruction

func AArch32_CheckForSVCTrap(immediate : bits(16))
begin
    if IsFeatureImplemented(FEAT_FGT) then
        var route_to_el2 : boolean = FALSE;
        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
            route_to_el2 = (!<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HFGITR_EL2().SVC_EL0 == '1' &amp;&amp;
                           (!<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() &amp;&amp; (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || SCR_EL3().FGTEn == '1')));
        end;

        if route_to_el2 then
            var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SupervisorCall" title="">Exception_SupervisorCall</a>);
            except.syndrome.iss[15:0] = immediate;
            except.trappedsyscallinst = TRUE;
            let preferred_exception_return : bits(64) = ThisInstrAddr{}();
            let vect_offset : integer = 0x0;

            AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_CheckForWFxTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_CheckForWFxTrap</h3>
      <p class="pseudocode">// AArch32_CheckForWFxTrap()
// =========================
// Check for trap on WFE or WFI instruction

func AArch32_CheckForWFxTrap(target_el : bits(2), wfxtype : <a href="shared_pseudocode.html#WFxType" title="type WFxType">WFxType</a>)
begin
    assert HaveEL(target_el);

    // Check for routing to AArch64
    if !ELUsingAArch32(target_el) then
        var trap : boolean;
        let is_wfe : boolean = wfxtype == WFxType_WFE;
        case target_el of
            when EL1 =&gt;
                trap = (if is_wfe then SCTLR_ELx().nTWE else SCTLR_ELx().nTWI) == '0';
            when EL2 =&gt;
                trap = (if is_wfe then HCR_EL2().TWE else HCR_EL2().TWI) == '1';
            when EL3 =&gt;
                trap = (if is_wfe then SCR_EL3().TWE else SCR_EL3().TWI) == '1';
        end;

        if trap then
            if target_el == EL3 &amp;&amp; EL3SDDUndef() then
                Undefined();
            else
                AArch64_WFxTrap(wfxtype, target_el);
            end;
        end;
        return;
    end;

    let is_wfe : boolean = wfxtype == WFxType_WFE;
    var trap : boolean;
    case target_el of
        when EL1 =&gt;
            trap = (if is_wfe then SCTLR().nTWE else SCTLR().nTWI) == '0';
        when EL2 =&gt;
            trap = (if is_wfe then HCR().TWE else HCR().TWI) == '1';
        when EL3 =&gt;
            trap = (if is_wfe then SCR().TWE else SCR().TWI) == '1';
    end;

    if trap then
        if target_el == EL1 &amp;&amp; EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2().TGE == '1' then
            AArch64_WFxTrap(wfxtype, target_el);
        end;

        if target_el == EL3 &amp;&amp; !EL3SDDUndef() then
            AArch32_TakeMonitorTrapException();
        elsif target_el == EL2 then
            var except : ExceptionRecord = ExceptionSyndrome(Exception_WFxTrap);
            except.syndrome.iss[24:20]   = ConditionSyndrome();
            except.syndrome.iss[0]       = if wfxtype == WFxType_WFI then '0' else '1';
            AArch32_TakeHypTrapException(except);
        else
            AArch32_TakeUndefInstrException();
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_CheckITEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_CheckITEnabled</h3>
      <p class="pseudocode">// AArch32_CheckITEnabled()
// ========================
// Check whether the T32 IT instruction is disabled.

func AArch32_CheckITEnabled(mask : bits(4))
begin
    var it_disabled : bit;

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        it_disabled = HSCTLR().ITD;
    else
        it_disabled = (if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then SCTLR().ITD else <a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().ITD);
    end;
    if it_disabled == '1' then
        if mask != '1000' then Undefined(); end;

        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescIFetch_0" title="">CreateAccDescIFetch</a>();
        let aligned = TRUE;
        // Otherwise whether the IT block is allowed depends on hw1 of the next instruction.
        let next_instr = <a href="shared_pseudocode.html#accessor_AArch32_MemSingle_4" title="">AArch32_MemSingle</a>{16}(<a href="shared_pseudocode.html#func_NextInstrAddr_1" title="">NextInstrAddr</a>{32}(), accdesc, aligned);

        if next_instr IN {'11xxxxxxxxxxxxxx', '1011xxxxxxxxxxxx', '10100xxxxxxxxxxx',
                          '01001xxxxxxxxxxx', '010001xxx1111xxx', '010001xx1xxxx111'} then
            // It is IMPLEMENTATION DEFINED whether the Undefined Instruction exception is
            // taken on the IT instruction or the next instruction. This is not reflected in
            // the pseudocode, which always takes the exception on the IT instruction. This
            // also does not take into account cases where the next instruction is UNPREDICTABLE.
            Undefined();
        end;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_CheckIllegalState"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_CheckIllegalState</h3>
      <p class="pseudocode">// AArch32_CheckIllegalState()
// ===========================
// Check PSTATE.IL bit and generate Illegal Execution state exception if set.

func AArch32_CheckIllegalState()
begin
    if <a href="shared_pseudocode.html#func_AArch32_GeneralExceptionsToAArch64_0" title="">AArch32_GeneralExceptionsToAArch64</a>() then
        AArch64_CheckIllegalState();
    elsif PSTATE.IL == '1' then
        let route_to_hyp = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR().TGE == '1';

        let preferred_exception_return : bits(32) = ThisInstrAddr{}();
        let vect_offset : integer = 0x04;

        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_hyp then
            let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_IllegalState" title="">Exception_IllegalState</a>);
            if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
                AArch32_EnterHypMode(except, preferred_exception_return, vect_offset);
            else
                AArch32_EnterHypMode(except, preferred_exception_return, 0x14);
            end;
        else
            AArch32_TakeUndefInstrException();
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_CheckSETENDEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_CheckSETENDEnabled</h3>
      <p class="pseudocode">// AArch32_CheckSETENDEnabled()
// ============================
// Check whether the AArch32 SETEND instruction is disabled.

func AArch32_CheckSETENDEnabled()
begin
    var setend_disabled : bit;
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        setend_disabled = HSCTLR().SED;
    else
        setend_disabled = (if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then SCTLR().SED else <a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().SED);
    end;
    if setend_disabled == '1' then
        Undefined();
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_SystemAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_SystemAccessTrap</h3>
      <p class="pseudocode">// AArch32_SystemAccessTrap()
// ==========================
// Trapped AArch32 System register access.

func AArch32_SystemAccessTrap(mode : bits(5), ec : integer)
begin
    let (valid, target_el) = <a href="shared_pseudocode.html#func_ELFromM32_1" title="">ELFromM32</a>(mode);
    assert valid &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(target_el) &amp;&amp; target_el != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; UInt(target_el) &gt;= UInt(PSTATE.EL);

    if target_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_AArch32_SystemAccessTrapSyndrome_2" title="">AArch32_SystemAccessTrapSyndrome</a>(<a href="shared_pseudocode.html#func_ThisInstr_0" title="">ThisInstr</a>(), ec);
        AArch32_TakeHypTrapException(except);
    else
        AArch32_TakeUndefInstrException();
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_SystemAccessTrapSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_SystemAccessTrapSyndrome</h3>
      <p class="pseudocode">// AArch32_SystemAccessTrapSyndrome()
// ==================================
// Returns the syndrome information for traps on AArch32 MCR, MCRR, MRC, MRRC, and VMRS,
// VMSR instructions, other than traps that are due to HCPTR or CPACR.

func <a id="func_AArch32_SystemAccessTrapSyndrome_2"/>AArch32_SystemAccessTrapSyndrome(instr : bits(32), ec : integer) =&gt; <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>
begin
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>;

    case ec of
        when 0x0  =&gt;   except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_Uncategorized" title="">Exception_Uncategorized</a>);
        when 0x3  =&gt;   except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_CP15RTTrap" title="">Exception_CP15RTTrap</a>);
        when 0x4  =&gt;   except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_CP15RRTTrap" title="">Exception_CP15RRTTrap</a>);
        when 0x5  =&gt;   except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_CP14RTTrap" title="">Exception_CP14RTTrap</a>);
        when 0x6  =&gt;   except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_CP14DTTrap" title="">Exception_CP14DTTrap</a>);
        when 0x7  =&gt;   except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_AdvSIMDFPAccessTrap" title="">Exception_AdvSIMDFPAccessTrap</a>);
        when 0x8  =&gt;   except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_FPIDTrap" title="">Exception_FPIDTrap</a>);
        when 0xC  =&gt;   except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_CP14RRTTrap" title="">Exception_CP14RRTTrap</a>);
        otherwise =&gt;   unreachable;
    end;

    var iss : bits(20) = Zeros{};

    if except.exceptype == <a href="shared_pseudocode.html#enum_Exception_Uncategorized" title="">Exception_Uncategorized</a> then
        return except;
    elsif except.exceptype IN {<a href="shared_pseudocode.html#enum_Exception_FPIDTrap" title="">Exception_FPIDTrap</a>, <a href="shared_pseudocode.html#enum_Exception_CP14RTTrap" title="">Exception_CP14RTTrap</a>,
                               <a href="shared_pseudocode.html#enum_Exception_CP15RTTrap" title="">Exception_CP15RTTrap</a>} then
        // Trapped MRC/MCR, VMRS on FPSID
        iss[13:10] = instr[19:16];       // CRn, Reg in case of VMRS
        iss[8:5]   = instr[15:12];       // Rt
        iss[9]     = '0';                // RES0

        if except.exceptype != <a href="shared_pseudocode.html#enum_Exception_FPIDTrap" title="">Exception_FPIDTrap</a> then    // When trap is not for VMRS
            iss[19:17] = instr[7:5];     // opc2
            iss[16:14] = instr[23:21];   // opc1
            iss[4:1]   = instr[3:0];     // CRm
        else //VMRS Access
            iss[19:17] = '000';          // opc2 - Hardcoded for VMRS
            iss[16:14] = '111';          // opc1 - Hardcoded for VMRS
            iss[4:1]   = '0000';         // CRm  - Hardcoded for VMRS
        end;
    elsif except.exceptype IN {<a href="shared_pseudocode.html#enum_Exception_CP14RRTTrap" title="">Exception_CP14RRTTrap</a>, <a href="shared_pseudocode.html#enum_Exception_AdvSIMDFPAccessTrap" title="">Exception_AdvSIMDFPAccessTrap</a>,
                               <a href="shared_pseudocode.html#enum_Exception_CP15RRTTrap" title="">Exception_CP15RRTTrap</a>} then
        // Trapped MRRC/MCRR, VMRS/VMSR
        iss[19:16] = instr[7:4];         // opc1
        iss[13:10] = instr[19:16];       // Rt2
        iss[8:5]   = instr[15:12];       // Rt
        iss[4:1]   = instr[3:0];         // CRm
    elsif except.exceptype == <a href="shared_pseudocode.html#enum_Exception_CP14DTTrap" title="">Exception_CP14DTTrap</a> then
        // Trapped LDC/STC
        iss[19:12] = instr[7:0];         // imm8
        iss[4]     = instr[23];          // U
        iss[2:1]   = instr[24,21];       // P,W
        if instr[19:16] == '1111' then   // Rn==15, LDC(Literal addressing)/STC
            iss[8:5] = ARBITRARY : bits(4);
            iss[3]   = '1';
        end;
    end;
    iss[0] = instr[20];                  // Direction

    except.syndrome.iss[24:20] = <a href="shared_pseudocode.html#func_ConditionSyndrome_0" title="">ConditionSyndrome</a>();
    except.syndrome.iss[19:0]  = iss;

    return except;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_TakeHypTrapException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_TakeHypTrapException</h3>
      <p class="pseudocode">// AArch32_TakeHypTrapException()
// ==============================
// Exceptions routed to Hyp mode as a Hyp Trap exception.

func AArch32_TakeHypTrapException(ec : integer)
begin
    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_AArch32_SystemAccessTrapSyndrome_2" title="">AArch32_SystemAccessTrapSyndrome</a>(<a href="shared_pseudocode.html#func_ThisInstr_0" title="">ThisInstr</a>(), ec);
    AArch32_TakeHypTrapException(except);
end;

// AArch32_TakeHypTrapException()
// ==============================
// Exceptions routed to Hyp mode as a Hyp Trap exception.

func AArch32_TakeHypTrapException(except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>)
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);

    let preferred_exception_return : bits(32) = ThisInstrAddr{}();
    let vect_offset : integer = 0x14;

    AArch32_EnterHypMode(except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_TakeMonitorTrapException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_TakeMonitorTrapException</h3>
      <p class="pseudocode">// AArch32_TakeMonitorTrapException()
// ==================================
// Exceptions routed to Monitor mode as a Monitor Trap exception.

func AArch32_TakeMonitorTrapException()
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);

    let preferred_exception_return : bits(32) = ThisInstrAddr{}();
    let vect_offset : integer = 0x04;
    let lr_offset : integer = if CurrentInstrSet() == InstrSet_A32 then 4 else 2;

    AArch32_EnterMonitorMode(preferred_exception_return, lr_offset, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_TakeUndefInstrException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_TakeUndefInstrException</h3>
      <p class="pseudocode">// AArch32_TakeUndefInstrException()
// =================================

noreturn func AArch32_TakeUndefInstrException(except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>)
begin

    let route_to_hyp : boolean = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR().TGE == '1';
    let preferred_exception_return : bits(32) = ThisInstrAddr{}();
    let vect_offset : integer = 0x04;
    let lr_offset : integer = if CurrentInstrSet() == InstrSet_A32 then 4 else 2;

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        AArch32_EnterHypMode(except, preferred_exception_return, vect_offset);
    elsif route_to_hyp then
        AArch32_EnterHypMode(except, preferred_exception_return, 0x14);
    else
        AArch32_EnterMode(<a href="shared_pseudocode.html#global_M32_Undef" title="">M32_Undef</a>, preferred_exception_return, lr_offset, vect_offset);
    end;
end;

// AArch32_TakeUndefInstrException()
// =================================

noreturn func AArch32_TakeUndefInstrException()
begin
    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_Uncategorized" title="">Exception_Uncategorized</a>);
    AArch32_TakeUndefInstrException(except);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32_Undefined"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32_Undefined</h3>
      <p class="pseudocode">// AArch32_Undefined()
// ===================

noreturn func AArch32_Undefined()
begin

    if <a href="shared_pseudocode.html#func_AArch32_GeneralExceptionsToAArch64_0" title="">AArch32_GeneralExceptionsToAArch64</a>() then AArch64_Undefined(); end;
    AArch32_TakeUndefInstrException();
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.aborts.AArch32_DomainValid"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32_DomainValid</h3>
      <p class="pseudocode">// AArch32_DomainValid()
// =====================
// Returns TRUE if the Domain is valid for a Short-descriptor translation scheme.

func <a id="func_AArch32_DomainValid_2"/>AArch32_DomainValid(statuscode : <a href="shared_pseudocode.html#type_Fault" title="">Fault</a>, level : integer) =&gt; boolean
begin
    assert statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;

    case statuscode of
        when <a href="shared_pseudocode.html#enum_Fault_Domain" title="">Fault_Domain</a> =&gt;
            return TRUE;
        when <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>,<a href="shared_pseudocode.html#enum_Fault_AccessFlag" title="">Fault_AccessFlag</a>, <a href="shared_pseudocode.html#enum_Fault_SyncExternalOnWalk" title="">Fault_SyncExternalOnWalk</a>, <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a> =&gt;
            return level == 2;
        otherwise =&gt;
            return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.aborts.AArch32_FaultSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32_FaultSyndrome</h3>
      <p class="pseudocode">// AArch32_FaultSyndrome()
// =======================
// Creates an exception syndrome value and updates the virtual address for Abort and Watchpoint
// exceptions taken to AArch32 Hyp mode.

func <a id="func_AArch32_FaultSyndrome_2"/>AArch32_FaultSyndrome(exceptype : <a href="shared_pseudocode.html#type_Exception" title="">Exception</a>, fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; bits(25)
begin
    assert fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;

    var isstype : <a href="shared_pseudocode.html#type_IssType" title="">IssType</a>;
    isstype.iss  = Zeros{25};

    let d_side : boolean = exceptype == <a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a>;
    if IsFeatureImplemented(FEAT_RAS) &amp;&amp; <a href="shared_pseudocode.html#func_IsAsyncAbort_1" title="">IsAsyncAbort</a>(fault) then
        let errstate : <a href="shared_pseudocode.html#type_ErrorState" title="">ErrorState</a> = <a href="shared_pseudocode.html#func_PEErrorState_1" title="">PEErrorState</a>(fault);
        isstype.iss[11:10] = <a href="shared_pseudocode.html#func_AArch32_EncodeAsyncErrorSyndrome_1" title="">AArch32_EncodeAsyncErrorSyndrome</a>(errstate); // AET
    end;

    if d_side then

        if <a href="shared_pseudocode.html#func_AArch32_InstructionSyndromeValid_1" title="">AArch32_InstructionSyndromeValid</a>(fault) then
            isstype.iss[24:14] = <a href="shared_pseudocode.html#func_LSInstructionSyndrome_0" title="">LSInstructionSyndrome</a>();
        end;

        if fault.accessdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>, <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>} then
            isstype.iss[8] = '1';
        end;

        if fault.accessdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>, <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>} then
            isstype.iss[6] = '1';
        elsif fault.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_HWUpdateAccessFlag" title="">Fault_HWUpdateAccessFlag</a>, <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a>} then
            isstype.iss[6] = ARBITRARY : bit;
        elsif fault.accessdesc.atomicop &amp;&amp; <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) then
            isstype.iss[6] = ARBITRARY : bit;
        else
            isstype.iss[6] = if fault.write then '1' else '0';
        end;

    end;
    if <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) then isstype.iss[9] = fault.extflag; end;
    isstype.iss[7] = if fault.s2fs1walk then '1' else '0';
    isstype.iss[5:0] = <a href="shared_pseudocode.html#func_EncodeLDFSC_2" title="">EncodeLDFSC</a>(fault.statuscode, fault.level);

    return isstype.iss;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.aborts.AArch32_InstructionSyndromeValid"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32_InstructionSyndromeValid</h3>
      <p class="pseudocode">// AArch32_InstructionSyndromeValid()
// ==================================
// Returns TRUE if ESR_ELx.ISV is '1' for the given Fault.

func <a id="func_AArch32_InstructionSyndromeValid_1"/>AArch32_InstructionSyndromeValid(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_IsSecondStage_1" title="">IsSecondStage</a>(fault) &amp;&amp; !fault.s2fs1walk then
        return (!<a href="shared_pseudocode.html#func_IsExternalSyncAbort_1" title="">IsExternalSyncAbort</a>(fault) ||
               (!IsFeatureImplemented(FEAT_RAS) &amp;&amp; <a href="shared_pseudocode.html#func_IsExternalAbortOnWalk_1" title="">IsExternalAbortOnWalk</a>(fault) &amp;&amp;
                  ImpDefBool("ISV on second stage translation table walk")));
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.aborts.EncodeSDFSC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/EncodeSDFSC</h3>
      <p class="pseudocode">// EncodeSDFSC()
// =============
// Function that gives the Short-descriptor FSR code for different types of Fault

func <a id="func_EncodeSDFSC_2"/>EncodeSDFSC(statuscode : <a href="shared_pseudocode.html#type_Fault" title="">Fault</a>, level : integer) =&gt; bits(5)
begin
    var result : bits(5);
    case statuscode of
        when <a href="shared_pseudocode.html#enum_Fault_AccessFlag" title="">Fault_AccessFlag</a> =&gt;
            assert level IN {1,2};
            result = if level == 1 then '00011' else '00110';
        when <a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a> =&gt;
            result = '00001';
        when <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a> =&gt;
            assert level IN {1,2};
            result = if level == 1 then '01101' else '01111';
        when <a href="shared_pseudocode.html#enum_Fault_Domain" title="">Fault_Domain</a> =&gt;
            assert level IN {1,2};
            result = if level == 1 then '01001' else '01011';
        when <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a> =&gt;
            assert level IN {1,2};
            result = if level == 1 then '00101' else '00111';
        when <a href="shared_pseudocode.html#enum_Fault_SyncExternal" title="">Fault_SyncExternal</a> =&gt;
            result = '01000';
        when <a href="shared_pseudocode.html#enum_Fault_SyncExternalOnWalk" title="">Fault_SyncExternalOnWalk</a> =&gt;
            assert level IN {1,2};
            result = if level == 1 then '01100' else '01110';
        when <a href="shared_pseudocode.html#enum_Fault_SyncParity" title="">Fault_SyncParity</a> =&gt;
            result = '11001';
        when <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a> =&gt;
            assert level IN {1,2};
            result = if level == 1 then '11100' else '11110';
        when <a href="shared_pseudocode.html#enum_Fault_AsyncParity" title="">Fault_AsyncParity</a> =&gt;
            result = '11000';
        when <a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a> =&gt;
            result = '10110';
        when <a href="shared_pseudocode.html#enum_Fault_Debug" title="">Fault_Debug</a> =&gt;
            result = '00010';
        when <a href="shared_pseudocode.html#enum_Fault_TLBConflict" title="">Fault_TLBConflict</a> =&gt;
            result = '10000';
        when <a href="shared_pseudocode.html#enum_Fault_Lockdown" title="">Fault_Lockdown</a> =&gt;
            result = '10100';   // IMPLEMENTATION DEFINED
        when <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a> =&gt;
            result = '10101';   // IMPLEMENTATION DEFINED
        when <a href="shared_pseudocode.html#enum_Fault_ICacheMaint" title="">Fault_ICacheMaint</a> =&gt;
            result = '00100';
        otherwise =&gt;
            unreachable;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.A32ExpandImm"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/A32ExpandImm</h3>
      <p class="pseudocode">// A32ExpandImm()
// ==============

func <a id="func_A32ExpandImm_1"/>A32ExpandImm(imm12 : bits(12)) =&gt; bits(32)
begin
    // PSTATE.C argument to following function call does not affect the imm32 result.
    let (imm32, -) = <a href="shared_pseudocode.html#func_A32ExpandImm_C_2" title="">A32ExpandImm_C</a>(imm12, PSTATE.C);

    return imm32;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.A32ExpandImm_C"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/A32ExpandImm_C</h3>
      <p class="pseudocode">// A32ExpandImm_C()
// ================

func <a id="func_A32ExpandImm_C_2"/>A32ExpandImm_C(imm12 : bits(12), carry_in : bit) =&gt; (bits(32), bit)
begin
    let unrotated_value : bits(32) = ZeroExtend{}(imm12[7:0]);
    let (imm32, carry_out) : (bits(32), bit) = Shift_C{32}(unrotated_value, SRType_ROR,
                                                           2*UInt(imm12[11:8]), carry_in);

    return (imm32, carry_out);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.DecodeImmShift"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/DecodeImmShift</h3>
      <p class="pseudocode">// DecodeImmShift()
// ================

func DecodeImmShift(srtype : bits(2), imm5 : bits(5)) =&gt; (<a href="shared_pseudocode.html#SRType" title="type SRType">SRType</a>, integer{0..32})
begin
    var shift_t : <a href="shared_pseudocode.html#SRType" title="type SRType">SRType</a>;
    var shift_n : integer{0..32};
    case srtype of
        when '00' =&gt;
            shift_t = SRType_LSL;  shift_n = UInt(imm5);
        when '01' =&gt;
            shift_t = SRType_LSR;  shift_n = if imm5 == '00000' then 32 else UInt(imm5);
        when '10' =&gt;
            shift_t = SRType_ASR;  shift_n = if imm5 == '00000' then 32 else UInt(imm5);
        when '11' =&gt;
            if imm5 == '00000' then
                shift_t = SRType_RRX;  shift_n = 1;
            else
                shift_t = SRType_ROR;  shift_n = UInt(imm5);
            end;
    end;

    return (shift_t, shift_n);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.DecodeRegShift"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/DecodeRegShift</h3>
      <p class="pseudocode">// DecodeRegShift()
// ================

func DecodeRegShift(srtype : bits(2)) =&gt; <a href="shared_pseudocode.html#SRType" title="type SRType">SRType</a>
begin
    var shift_t : <a href="shared_pseudocode.html#SRType" title="type SRType">SRType</a>;
    case srtype of
        when '00' =&gt;  shift_t = SRType_LSL;
        when '01' =&gt;  shift_t = SRType_LSR;
        when '10' =&gt;  shift_t = SRType_ASR;
        when '11' =&gt;  shift_t = SRType_ROR;
    end;
    return shift_t;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.RRX"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/RRX</h3>
      <p class="pseudocode">// RRX()
// =====

func <a id="func_RRX_3"/>RRX{N}(x : bits(N), carry_in : bit) =&gt; bits(N)
begin
    let (result, -) = <a href="shared_pseudocode.html#func_RRX_C_3" title="">RRX_C</a>{N}(x, carry_in);
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.RRX_C"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/RRX_C</h3>
      <p class="pseudocode">// RRX_C()
// =======

func <a id="func_RRX_C_3"/>RRX_C{N}(x : bits(N), carry_in : bit) =&gt; (bits(N), bit)
begin
    let result : bits(N) = carry_in :: x[N-1:1];
    let carry_out : bit = x[0];
    return (result, carry_out);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.SRType"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/SRType</h3>
      <p class="pseudocode">// SRType
// ======

type <a id="SRType"/>SRType of enumeration {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.Shift"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/Shift</h3>
      <p class="pseudocode">// Shift()
// =======

func Shift{N}(value : bits(N), srtype : <a href="shared_pseudocode.html#SRType" title="type SRType">SRType</a>, amount : integer, carry_in : bit) =&gt; bits(N)
begin
    let (result, -) = Shift_C{N}(value, srtype, amount, carry_in);
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.Shift_C"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/Shift_C</h3>
      <p class="pseudocode">// Shift_C()
// =========

func Shift_C{N}(value : bits(N), srtype : <a href="shared_pseudocode.html#SRType" title="type SRType">SRType</a>, amount : integer,
                carry_in : bit) =&gt; (bits(N), bit)
begin
    assert !(srtype == SRType_RRX &amp;&amp; amount != 1);

    var result : bits(N);
    var carry_out : bit;
    if amount == 0 then
        (result, carry_out) = (value, carry_in);
    else
        case srtype of
            when SRType_LSL =&gt;
                (result, carry_out) = LSL_C(value, amount);
            when SRType_LSR =&gt;
                (result, carry_out) = LSR_C(value, amount);
            when SRType_ASR =&gt;
                (result, carry_out) = ASR_C(value, amount);
            when SRType_ROR =&gt;
                (result, carry_out) = ROR_C(value, amount);
            when SRType_RRX =&gt;
                (result, carry_out) = RRX_C{N}(value, carry_in);
        end;
    end;

    return (result, carry_out);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.T32ExpandImm"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/T32ExpandImm</h3>
      <p class="pseudocode">// T32ExpandImm()
// ==============

func <a id="func_T32ExpandImm_1"/>T32ExpandImm(imm12 : bits(12)) =&gt; bits(32)
begin
    // PSTATE.C argument to following function call does not affect the imm32 result.
    let (imm32, -) = <a href="shared_pseudocode.html#func_T32ExpandImm_C_2" title="">T32ExpandImm_C</a>(imm12, PSTATE.C);

    return imm32;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.T32ExpandImm_C"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/T32ExpandImm_C</h3>
      <p class="pseudocode">// T32ExpandImm_C()
// ================

func <a id="func_T32ExpandImm_C_2"/>T32ExpandImm_C(imm12 : bits(12), carry_in : bit) =&gt; (bits(32), bit)
begin
    var imm32 : bits(32);
    var carry_out : bit;
    if imm12[11:10] == '00' then
        case imm12[9:8] of
            when '00' =&gt;
                imm32 = ZeroExtend{32}(imm12[7:0]);
            when '01' =&gt;
                imm32 = '00000000' :: imm12[7:0] :: '00000000' :: imm12[7:0];
            when '10' =&gt;
                imm32 = imm12[7:0] :: '00000000' :: imm12[7:0] :: '00000000';
            when '11' =&gt;
                imm32 = imm12[7:0] :: imm12[7:0] :: imm12[7:0] :: imm12[7:0];
        end;
        carry_out = carry_in;
    else
        let unrotated_value : bits(32) = ZeroExtend{}('1'::imm12[6:0]);
        (imm32, carry_out) = ROR_C(unrotated_value, UInt(imm12[11:7]));
    end;

    return (imm32, carry_out);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.VBitOps"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/VBitOps</h3>
      <p class="pseudocode">// VBitOps
// =======

type <a id="VBitOp"/>VBitOps of enumeration {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.VCGEType"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/VCGEType</h3>
      <p class="pseudocode">// VCGEType
// ========

type <a id="VCGEType"/>VCGEType of enumeration {VCGEType_signed, VCGEType_unsigned, VCGEType_fp};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.VCGTtype"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/VCGTtype</h3>
      <p class="pseudocode">// VCGTtype
// ========

type <a id="VCGTtype"/>VCGTtype of enumeration {VCGTtype_signed, VCGTtype_unsigned, VCGTtype_fp};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.VFPNegMul"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/VFPNegMul</h3>
      <p class="pseudocode">// VFPNegMul
// =========

type <a id="VFPNegMul"/>VFPNegMul of enumeration {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.coproc.AArch32_CheckCP15InstrCoarseTraps"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/coproc/AArch32_CheckCP15InstrCoarseTraps</h3>
      <p class="pseudocode">// AArch32_CheckCP15InstrCoarseTraps()
// ===================================
// Check for coarse-grained traps to System registers in the
// coproc=0b1111 encoding space by HSTR and HCR.

func AArch32_CheckCP15InstrCoarseTraps(CRn : integer, nreg : integer, CRm : integer)
begin
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; (!<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) ||
            (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>))) then
        AArch64_CheckCP15InstrCoarseTraps(CRn, nreg, CRm);
    end;

    let trapped_encoding = ((CRn == 9  &amp;&amp; CRm IN {0,1,2,    5,6,7,8   }) ||
                            (CRn == 10 &amp;&amp; CRm IN {0,1,    4,      8   }) ||
                            (CRn == 11 &amp;&amp; CRm IN {0,1,2,3,4,5,6,7,8,15}));

    // Check for coarse-grained Hyp traps
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        let major : integer = if nreg == 1 then CRn else CRm;
        // Check for MCR, MRC, MCRR, and MRRC disabled by HSTR().CRn/HSTR().CRm
        // and MRC and MCR disabled by HCR.TIDCP.
        if ((! major IN {4,14} &amp;&amp; HSTR()[major] == '1') ||
              (HCR().TIDCP == '1' &amp;&amp; nreg == 1 &amp;&amp; trapped_encoding)) then
            if (PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp;
                  ImpDefBool("UNDEF unallocated CP15 access at EL0")) then
                Undefined();
            end;
            if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
                AArch32_SystemAccessTrap(<a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>, 0x3);
            else
                AArch64_AArch32SystemAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, 0x3);
            end;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.exclusive.AArch32_ExclusiveMonitorsPass"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/exclusive/AArch32_ExclusiveMonitorsPass</h3>
      <p class="pseudocode">// AArch32_ExclusiveMonitorsPass()
// ===============================
// Return TRUE if the Exclusives monitors for the current PE include all of the addresses
// associated with the virtual address region of size bytes starting at address.
// The immediately following memory write must be to the same addresses.

// It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
// before or after the check on the local Exclusives monitor. As a result a failure
// of the local monitor can occur on some implementations even if the memory
// access would give an memory abort.

func <a id="func_AArch32_ExclusiveMonitorsPass_2"/>AArch32_ExclusiveMonitorsPass(address : bits(32),
                                   size : integer{1, 2, 4, 8, 16, 32}) =&gt; boolean
begin
    let acqrel : boolean = FALSE;
    let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
    let tagchecked : boolean = FALSE;
    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescExLDST(MemOp_STORE, acqrel,
                                                            tagchecked, privileged);
    let aligned : boolean = IsAlignedSize(address, size);

    if !aligned then
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, ZeroExtend{64}(address));
        AArch32_Abort(fault);
    end;

    if !<a href="shared_pseudocode.html#func_AArch32_IsExclusiveVA_3" title="">AArch32_IsExclusiveVA</a>(address, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), size) then
        return FALSE;
    end;

    let memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch32_TranslateAddress_4" title="">AArch32_TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        AArch32_Abort(memaddrdesc.fault);
    end;

    var passed : boolean = <a href="shared_pseudocode.html#func_IsExclusiveLocal_3" title="">IsExclusiveLocal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), size);
    ClearExclusiveLocal(<a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>());

    if passed &amp;&amp; memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> then
        passed = <a href="shared_pseudocode.html#func_IsExclusiveGlobal_3" title="">IsExclusiveGlobal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), size);
    end;

    return passed;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.exclusive.AArch32_IsExclusiveVA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/exclusive/AArch32_IsExclusiveVA</h3>
      <p class="pseudocode">// AArch32_IsExclusiveVA()
// =======================
// An optional IMPLEMENTATION DEFINED test for an exclusive access to a virtual
// address region of size bytes starting at address.
//
// It is permitted (but not required) for this function to return FALSE and
// cause a store exclusive to fail if the virtual address region is not
// totally included within the region recorded by MarkExclusiveVA().
//
// It is always safe to return TRUE which will check the physical address only.

impdef func <a id="func_AArch32_IsExclusiveVA_3"/>AArch32_IsExclusiveVA(address : bits(32),
                                  processorid : integer,
                                  size : integer) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.exclusive.AArch32_MarkExclusiveVA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/exclusive/AArch32_MarkExclusiveVA</h3>
      <p class="pseudocode">// AArch32_MarkExclusiveVA()
// =========================
// Optionally record an exclusive access to the virtual address region of size bytes
// starting at address for processorid.

func AArch32_MarkExclusiveVA(address : bits(32), processorid : integer, size : integer)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.exclusive.AArch32_SetExclusiveMonitors"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/exclusive/AArch32_SetExclusiveMonitors</h3>
      <p class="pseudocode">// AArch32_SetExclusiveMonitors()
// ==============================
// Sets the Exclusives monitors for the current PE to record the addresses associated
// with the virtual address region of size bytes starting at address.

func AArch32_SetExclusiveMonitors(address : bits(32), size : integer{1, 2, 4, 8, 16, 32})
begin
    let acqrel : boolean = FALSE;
    let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
    let tagchecked : boolean = FALSE;
    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescExLDST(MemOp_LOAD, acqrel,
                                                            tagchecked, privileged);
    let aligned : boolean = IsAlignedSize(address, size);

    if !aligned then
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, ZeroExtend{64}(address));
        AArch32_Abort(fault);
    end;

    let memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch32_TranslateAddress_4" title="">AArch32_TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        return;
    end;

    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> then
        MarkExclusiveGlobal(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), size);
    end;

    MarkExclusiveLocal(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), size);

    AArch32_MarkExclusiveVA(address, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), size);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.CheckAdvSIMDEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/CheckAdvSIMDEnabled</h3>
      <p class="pseudocode">// CheckAdvSIMDEnabled()
// =====================

func CheckAdvSIMDEnabled()
begin
    let fpexc_check : boolean = TRUE;
    let advsimd : boolean = TRUE;

    AArch32_CheckAdvSIMDOrFPEnabled(fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if Advanced SIMD access is permitted

    // Make temporary copy of D registers
    // _Dclone[] is used as input data for instruction pseudocode
    for i = 0 to 31 do
        <a href="shared_pseudocode.html#global__Dclone" title="">_Dclone</a>[[i]] = <a href="shared_pseudocode.html#accessor_D_1" title="">D</a>(i);
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.CheckAdvSIMDOrVFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/CheckAdvSIMDOrVFPEnabled</h3>
      <p class="pseudocode">// CheckAdvSIMDOrVFPEnabled()
// ==========================

func CheckAdvSIMDOrVFPEnabled(include_fpexc_check : boolean, advsimd : boolean)
begin
    AArch32_CheckAdvSIMDOrFPEnabled(include_fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if VFP access is permitted
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.CheckCryptoEnabled32"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/CheckCryptoEnabled32</h3>
      <p class="pseudocode">// CheckCryptoEnabled32()
// ======================

func CheckCryptoEnabled32()
begin
    CheckAdvSIMDEnabled();
    // Return from CheckAdvSIMDEnabled() occurs only if access is permitted
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.CheckVFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/CheckVFPEnabled</h3>
      <p class="pseudocode">// CheckVFPEnabled()
// =================

func CheckVFPEnabled(include_fpexc_check : boolean)
begin
    let advsimd : boolean = FALSE;
    AArch32_CheckAdvSIMDOrFPEnabled(include_fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if VFP access is permitted
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.FPHalvedSub"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/FPHalvedSub</h3>
      <p class="pseudocode">// FPHalvedSub()
// =============

func <a id="func_FPHalvedSub_4"/>FPHalvedSub{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);
    var (done,result) : (boolean, bits(N)) = <a href="shared_pseudocode.html#func_FPProcessNaNs_6" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr);
    if !done then
        let inf1 : boolean  = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2 : boolean  = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{N}(fpcr);
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 != sign2 then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign1);
        else
            let result_value : real = (value1 - value2) / 2.0;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                let result_sign : bit = if rounding == <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(result_sign);
            else
                result = <a href="shared_pseudocode.html#func_FPRound_3" title="">FPRound</a>{N}(result_value, fpcr);
            end;
        end;
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.FPRSqrtStep"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/FPRSqrtStep</h3>
      <p class="pseudocode">// FPRSqrtStep()
// =============

func <a id="func_FPRSqrtStep_3"/>FPRSqrtStep{N}(op1 : bits(N), op2 : bits(N)) =&gt; bits(N)
begin
    assert N IN {16,32};
    let fpcr : FPCR_Type = <a href="shared_pseudocode.html#func_StandardFPCR_0" title="">StandardFPCR</a>();
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);
    var (done,result) : (boolean, bits(N)) = <a href="shared_pseudocode.html#func_FPProcessNaNs_6" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr);
    if !done then
        let inf1 : boolean  = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2 : boolean  = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        var product : bits(N);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            product = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}('0');
        else
            product = <a href="shared_pseudocode.html#func_FPMul_4" title="">FPMul</a>{N}(op1, op2, fpcr);
        end;
        let three : bits(N) = FPThree{}('0');
        result = <a href="shared_pseudocode.html#func_FPHalvedSub_4" title="">FPHalvedSub</a>{N}(three, product, fpcr);
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.FPRecipStep"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/FPRecipStep</h3>
      <p class="pseudocode">// FPRecipStep()
// =============

func <a id="func_FPRecipStep_3"/>FPRecipStep{N}(op1 : bits(N), op2 : bits(N)) =&gt; bits(N)
begin
    assert N IN {16,32};
    let fpcr : FPCR_Type = <a href="shared_pseudocode.html#func_StandardFPCR_0" title="">StandardFPCR</a>();
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);
    var (done,result) : (boolean, bits(N)) = <a href="shared_pseudocode.html#func_FPProcessNaNs_6" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr);
    if !done then
        let inf1 : boolean  = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2 : boolean  = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        var product : bits(N);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            product = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}('0');
        else
            product = <a href="shared_pseudocode.html#func_FPMul_4" title="">FPMul</a>{N}(op1, op2, fpcr);
        end;
        let two : bits(N) = FPTwo{}('0');
        result = <a href="shared_pseudocode.html#func_FPSub_4" title="">FPSub</a>{N}(two, product, fpcr);
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.StandardFPCR"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/StandardFPCR</h3>
      <p class="pseudocode">// StandardFPCR()
// ==============

func <a id="func_StandardFPCR_0"/>StandardFPCR() =&gt; FPCR_Type
begin
    let value : bits(32) = ('00000' :: FPSCR().AHP :: '110000' ::
                            FPSCR().FZ16 :: '0000000000000000000');
    return ZeroExtend{64}(value);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.AArch32_MemSingle"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/AArch32_MemSingle</h3>
      <p class="pseudocode">// AArch32_MemSingle
// =================

accessor <a id="accessor_AArch32_MemSingle_4"/>AArch32_MemSingle{size : integer{8, 16, 32, 64}}(address : bits(32),
                                                          accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                                          aligned : boolean) &lt;=&gt; value : bits(size)
begin
    // Perform an atomic, little-endian read of 'size' bits.
    getter
        let bytes : integer{} = size DIV 8;
        var value : bits(size);
        var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
        var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;

        (value, memaddrdesc, memstatus) = <a href="shared_pseudocode.html#func_AArch32_MemSingleRead_4" title="">AArch32_MemSingleRead</a>{size}(address, accdesc, aligned);

        // Check for a fault from translation or the output of translation.
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
            AArch32_Abort(memaddrdesc.fault);
        end;

        // Check for external aborts.
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            HandleExternalAbort(memstatus, accdesc.write, memaddrdesc, bytes, accdesc);
        end;

        return value;
    end;

    // Perform an atomic, little-endian write of 'size' bits.
    setter
        let bytes : integer{} = size DIV 8;
        var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
        var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;

        (memaddrdesc, memstatus) = <a href="shared_pseudocode.html#func_AArch32_MemSingleWrite_5" title="">AArch32_MemSingleWrite</a>{size}(address, accdesc, aligned, value);

        // Check for a fault from translation or the output of translation.
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
            AArch32_Abort(memaddrdesc.fault);
        end;

        // Check for external aborts.
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            HandleExternalWriteAbort(memstatus, memaddrdesc, bytes, accdesc);
        end;

        return;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.AArch32_MemSingleRead"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/AArch32_MemSingleRead</h3>
      <p class="pseudocode">// AArch32_MemSingleRead()
// =======================
// Perform an atomic, little-endian read of 'size' bits.

func <a id="func_AArch32_MemSingleRead_4"/>AArch32_MemSingleRead{size : integer{8, 16, 32, 64}}(address : bits(32),
                                                          accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                                          aligned : boolean
                                                          ) =&gt; (bits(size), <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                                                                <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>)
begin
    let bytes : integer{}            = size DIV 8;
    var value : bits(size)           = ARBITRARY : bits(size);
    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a> = ARBITRARY : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
    assert IsAlignedSize(address, bytes);

    var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    memaddrdesc = <a href="shared_pseudocode.html#func_AArch32_TranslateAddress_4" title="">AArch32_TranslateAddress</a>(address, accdesc, aligned, bytes);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        return (value, memaddrdesc, memstatus);
    end;

    // Memory array access
    (memstatus, value) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{size}(memaddrdesc, accdesc);
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
        return (value, memaddrdesc, memstatus);
    end;

    if accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> then
        if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>()) then
            memaddrdesc.fault = <a href="shared_pseudocode.html#func_AArch32_CheckDebug_3" title="">AArch32_CheckDebug</a>(address, accdesc, bytes);
        else
            memaddrdesc.fault = <a href="shared_pseudocode.html#func_AArch64_CheckDebug_3" title="">AArch64_CheckDebug</a>(ZeroExtend{64}(address), accdesc, bytes);
        end;
    end;

    return (value, memaddrdesc, memstatus);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.AArch32_MemSingleWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/AArch32_MemSingleWrite</h3>
      <p class="pseudocode">// AArch32_MemSingleWrite()
// ========================
// Perform an atomic, little-endian write of 'size' bits.

func <a id="func_AArch32_MemSingleWrite_5"/>AArch32_MemSingleWrite{size : integer{8, 16, 32, 64}}(address : bits(32),
                                                           accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                                           aligned : boolean,
                                                           value : bits(size)
                                                          ) =&gt; (<a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>)
begin
    let bytes : integer{} = size DIV 8;
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
    assert IsAlignedSize(address, bytes);

    var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a> = ARBITRARY : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    memaddrdesc = <a href="shared_pseudocode.html#func_AArch32_TranslateAddress_4" title="">AArch32_TranslateAddress</a>(address, accdesc, aligned, bytes);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        return (memaddrdesc, memstatus);
    end;

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> then
        ClearExclusiveByAddress(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), bytes);
    end;

    memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{size}(memaddrdesc, accdesc, value);
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
        return (memaddrdesc, memstatus);
    end;

    return (memaddrdesc, memstatus);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.AArch32_UnalignedAccessFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/AArch32_UnalignedAccessFaults</h3>
      <p class="pseudocode">// AArch32_UnalignedAccessFaults()
// ===============================
// Determine whether the unaligned access generates an Alignment fault

func <a id="func_AArch32_UnalignedAccessFaults_1"/>AArch32_UnalignedAccessFaults(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    return (<a href="shared_pseudocode.html#func_AlignmentEnforced_0" title="">AlignmentEnforced</a>() ||
            accdesc.a32lsmd     ||
            accdesc.exclusive   ||
            accdesc.acqsc       ||
            accdesc.relsc);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.Hint_PreloadData"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/Hint_PreloadData</h3>
      <p class="pseudocode">// Hint_PreloadData()
// ==================

impdef func Hint_PreloadData(address : bits(32))
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.Hint_PreloadDataForWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/Hint_PreloadDataForWrite</h3>
      <p class="pseudocode">// Hint_PreloadDataForWrite()
// ==========================

impdef func Hint_PreloadDataForWrite(address : bits(32))
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.Hint_PreloadInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/Hint_PreloadInstr</h3>
      <p class="pseudocode">// Hint_PreloadInstr()
// ===================

impdef func Hint_PreloadInstr(address : bits(32))
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemA</h3>
      <p class="pseudocode">// MemA - accessor
// ===============

accessor <a id="accessor_MemA_2"/>MemA{size : integer{8, 16, 32, 64}}(address : bits(32)) &lt;=&gt; value : bits(size)
begin
    getter
        let acqrel : boolean = FALSE;
        let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
        let tagchecked : boolean = FALSE;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescExLDST(MemOp_LOAD, acqrel, tagchecked,
                                                                privileged);
        return <a href="shared_pseudocode.html#accessor_Mem_with_type_3" title="">Mem_with_type</a>{size}(address, accdesc);
    end;

    setter
        let acqrel : boolean = FALSE;
        let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
        let tagchecked : boolean = FALSE;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescExLDST(MemOp_STORE, acqrel, tagchecked,
                                                                privileged);
        <a href="shared_pseudocode.html#accessor_Mem_with_type_3" title="">Mem_with_type</a>{size}(address, accdesc) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemO"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemO</h3>
      <p class="pseudocode">// MemO
// ====

accessor <a id="accessor_MemO_2"/>MemO{size : integer{8, 16, 32, 64} }(address : bits(32)) &lt;=&gt; value : bits(size)
begin
    getter
        let acquire : boolean = TRUE;
        let tagchecked : boolean = FALSE;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescAcqRel(MemOp_LOAD, tagchecked, acquire);
        return <a href="shared_pseudocode.html#accessor_Mem_with_type_3" title="">Mem_with_type</a>{size}(address, accdesc);
    end;

    setter
        let acquire : boolean = FALSE;
        let tagchecked : boolean = FALSE;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescAcqRel(MemOp_STORE, tagchecked, acquire);
        <a href="shared_pseudocode.html#accessor_Mem_with_type_3" title="">Mem_with_type</a>{size}(address, accdesc) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemS"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemS</h3>
      <p class="pseudocode">// MemS - accessor
// ===============

accessor <a id="accessor_MemS_2"/>MemS{size : integer{8, 16, 32, 64}}(address : bits(32)) &lt;=&gt; value : bits(size)
begin
    // Memory accessor for streaming load multiple instructions
    getter
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescA32LSMD(MemOp_LOAD);
        return <a href="shared_pseudocode.html#accessor_Mem_with_type_3" title="">Mem_with_type</a>{size}(address, accdesc);
    end;

    // Memory accessor for streaming store multiple instructions
    setter
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescA32LSMD(MemOp_STORE);
        <a href="shared_pseudocode.html#accessor_Mem_with_type_3" title="">Mem_with_type</a>{size}(address, accdesc) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemU"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemU</h3>
      <p class="pseudocode">// MemU - accessor
// ===============

accessor <a id="accessor_MemU_2"/>MemU{size : integer{8, 16, 32, 64} }(address : bits(32) ) &lt;=&gt; value: bits(size)
begin
    getter
        let nontemporal : boolean = FALSE;
        let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
        let tagchecked : boolean = FALSE;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged,
                                                             tagchecked);
        return <a href="shared_pseudocode.html#accessor_Mem_with_type_3" title="">Mem_with_type</a>{size}(address, accdesc);
    end;

    setter
        let nontemporal : boolean = FALSE;
        let privileged : boolean  = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
        let tagchecked : boolean  = FALSE;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged,
                                                            tagchecked);
        <a href="shared_pseudocode.html#accessor_Mem_with_type_3" title="">Mem_with_type</a>{size}(address, accdesc) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemU_unpriv"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemU_unpriv</h3>
      <p class="pseudocode">// MemU_unpriv
// ===========

accessor <a id="accessor_MemU_unpriv_2"/>MemU_unpriv{size : integer{8, 16, 32, 64}}(address : bits(32)) &lt;=&gt; value : bits(size)
begin
    getter
        let nontemporal : boolean = FALSE;
        let privileged : boolean  = FALSE;
        let tagchecked : boolean  = FALSE;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescGPR(MemOp_LOAD, nontemporal, privileged,
                                                            tagchecked);
        return <a href="shared_pseudocode.html#accessor_Mem_with_type_3" title="">Mem_with_type</a>{size}(address, accdesc);
    end;

    setter
        let nontemporal : boolean = FALSE;
        let privileged : boolean  = FALSE;
        let tagchecked : boolean  = FALSE;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescGPR(MemOp_STORE, nontemporal, privileged,
                                                          tagchecked);
        <a href="shared_pseudocode.html#accessor_Mem_with_type_3" title="">Mem_with_type</a>{size}(address, accdesc) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.Mem_with_type"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/Mem_with_type</h3>
      <p class="pseudocode">// Mem_with_type
// =============

accessor <a id="accessor_Mem_with_type_3"/>Mem_with_type{size : integer{8, 16, 32, 64}}(address : bits(32),
                                                      accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
                                                     ) &lt;=&gt; value_in : bits(size)
begin
    // Perform a read of 'size' bits. The access byte order is reversed for a big-endian access.
    // Instruction fetches would call AArch32_MemSingle directly.
    getter
        let bytes : integer{} = size DIV 8;
        var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
        var value : bits(size);
        // Check alignment on size of element accessed, not overall access size
        let alignment : integer{} = if accdesc.ispair then bytes DIV 2 else bytes;
        var aligned : boolean     = IsAlignedSize(address, alignment);

        if !aligned &amp;&amp; <a href="shared_pseudocode.html#func_AArch32_UnalignedAccessFaults_1" title="">AArch32_UnalignedAccessFaults</a>(accdesc) then
            let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, ZeroExtend{64}(address));
            AArch32_Abort(fault);
        end;
        if aligned then
            value = <a href="shared_pseudocode.html#accessor_AArch32_MemSingle_4" title="">AArch32_MemSingle</a>{size}(address, accdesc, aligned);
        else
            assert bytes &gt; 1;
            value[7:0] = <a href="shared_pseudocode.html#accessor_AArch32_MemSingle_4" title="">AArch32_MemSingle</a>{8}(address, accdesc, aligned);

            // For subsequent bytes, if they cross to a new translation page which assigns
            // Device memory type, it is CONSTRAINED UNPREDICTABLE whether an unaligned access
            // will generate an Alignment Fault.
            let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_DEVPAGE2" title="">Unpredictable_DEVPAGE2</a>);
            assert c IN {<a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a>, <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>};
            if c == <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a> then aligned = TRUE; end;

            for i = 1 to bytes-1 do
                value[i*:8] = <a href="shared_pseudocode.html#accessor_AArch32_MemSingle_4" title="">AArch32_MemSingle</a>{8}(address+i, accdesc, aligned);
            end;
        end;

        if <a href="shared_pseudocode.html#func_BigEndian_1" title="">BigEndian</a>(accdesc.acctype) then
            value = <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{size}(value);
        end;

        return value;
    end;

    // Perform a write of 'size' bits. The byte order is reversed for a big-endian access.
    setter
        let bytes : integer{}          = size DIV 8;
        var value :  bits(size)        = value_in;
        var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;

        // Check alignment on size of element accessed, not overall access size
        let alignment : integer{} = if accdesc.ispair then bytes DIV 2 else bytes;
        var aligned : boolean     = IsAlignedSize(address, alignment);

        if !aligned &amp;&amp; <a href="shared_pseudocode.html#func_AArch32_UnalignedAccessFaults_1" title="">AArch32_UnalignedAccessFaults</a>(accdesc) then
            let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, ZeroExtend{64}(address));
            AArch32_Abort(fault);
        end;

        if <a href="shared_pseudocode.html#func_BigEndian_1" title="">BigEndian</a>(accdesc.acctype) then
            value = <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{size}(value);
        end;
        if aligned then
            <a href="shared_pseudocode.html#accessor_AArch32_MemSingle_4" title="">AArch32_MemSingle</a>{size}(address, accdesc, aligned) = value;
        else
            assert bytes &gt; 1;
            <a href="shared_pseudocode.html#accessor_AArch32_MemSingle_4" title="">AArch32_MemSingle</a>{8}(address, accdesc, aligned) = value[7:0];

            // For subsequent bytes, if they cross to a new translation page which assigns
            // Device memory type, it is CONSTRAINED UNPREDICTABLE whether an unaligned access
            // will generate an Alignment Fault.

            let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_DEVPAGE2" title="">Unpredictable_DEVPAGE2</a>);
            assert c IN {<a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a>, <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>};
            if c == <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a> then aligned = TRUE; end;

            for i = 1 to bytes-1 do
                <a href="shared_pseudocode.html#accessor_AArch32_MemSingle_4" title="">AArch32_MemSingle</a>{8}(address+i, accdesc, aligned) = value[i*:8];
            end;
        end;
        return;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32_ESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32_ESBOperation</h3>
      <p class="pseudocode">// AArch32_ESBOperation()
// ======================
// Perform the AArch32 ESB operation for ESB executed in AArch32 state.

func AArch32_ESBOperation()
begin
    var masked : boolean;
    var target_el : bits(2);

    (masked, target_el) = <a href="shared_pseudocode.html#func_PhysicalSErrorTarget_0" title="">PhysicalSErrorTarget</a>();

    // Check if routed to AArch64 state
    if !masked &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(target_el) then
        AArch64_ESBOperation();
        return;
    end;

    // Check for a masked Physical SError pending that can be synchronized
    // by an Error synchronization event.
    if masked &amp;&amp; <a href="shared_pseudocode.html#func_IsSynchronizablePhysicalSErrorPending_0" title="">IsSynchronizablePhysicalSErrorPending</a>() then
        var syndrome : bits(32) = Zeros{};
        syndrome[31] = '1';  // A
        syndrome[15:0] = <a href="shared_pseudocode.html#func_AArch32_PhysicalSErrorSyndrome_0" title="">AArch32_PhysicalSErrorSyndrome</a>();
        DISR() = syndrome;
        ClearPendingPhysicalSError();
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32_EncodeAsyncErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32_EncodeAsyncErrorSyndrome</h3>
      <p class="pseudocode">// AArch32_EncodeAsyncErrorSyndrome()
// ==================================
// Return the encoding for specified  ErrorState for an SError exception taken
// to AArch32 state.

func <a id="func_AArch32_EncodeAsyncErrorSyndrome_1"/>AArch32_EncodeAsyncErrorSyndrome(errorstate : <a href="shared_pseudocode.html#type_ErrorState" title="">ErrorState</a>) =&gt; bits(2)
begin
    case errorstate of
        when <a href="shared_pseudocode.html#enum_ErrorState_UC" title="">ErrorState_UC</a> =&gt;   return '00';
        when <a href="shared_pseudocode.html#enum_ErrorState_UEU" title="">ErrorState_UEU</a> =&gt;  return '01';
        when <a href="shared_pseudocode.html#enum_ErrorState_UEO" title="">ErrorState_UEO</a> =&gt;  return '10';
        when <a href="shared_pseudocode.html#enum_ErrorState_UER" title="">ErrorState_UER</a> =&gt;  return '11';
        otherwise =&gt; unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32_PhysicalSErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32_PhysicalSErrorSyndrome</h3>
      <p class="pseudocode">// AArch32_PhysicalSErrorSyndrome()
// ================================
// Generate SError syndrome.

func <a id="func_AArch32_PhysicalSErrorSyndrome_0"/>AArch32_PhysicalSErrorSyndrome() =&gt; bits(16)
begin
    var syndrome : bits(32) = Zeros{};
    let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_GetPendingPhysicalSError_0" title="">GetPendingPhysicalSError</a>();
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        let errstate : <a href="shared_pseudocode.html#type_ErrorState" title="">ErrorState</a> = <a href="shared_pseudocode.html#func_PEErrorState_1" title="">PEErrorState</a>(fault);
        syndrome[11:10] = <a href="shared_pseudocode.html#func_AArch32_EncodeAsyncErrorSyndrome_1" title="">AArch32_EncodeAsyncErrorSyndrome</a>(errstate);   // AET
        syndrome[9]     = fault.extflag;                                // EA
        syndrome[5:0]   = '010001';                                     // DFSC
    else
        let long_format : boolean = TTBCR().EAE == '1';
        syndrome = <a href="shared_pseudocode.html#func_AArch32_CommonFaultStatus_2" title="">AArch32_CommonFaultStatus</a>(fault, long_format);
    end;
    return syndrome[15:0];
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32_vESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32_vESBOperation</h3>
      <p class="pseudocode">// AArch32_vESBOperation()
// =======================
// Perform the ESB operation for virtual SError interrupts executed in AArch32 state.
// If FEAT_E3DSE is implemented and there is no unmasked virtual SError exception
// pending, then AArch64_dESBOperation() is called to perform the AArch64 ESB operation
// for a pending delegated SError exception.

func AArch32_vESBOperation()
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();

    // Check for EL2 using AArch64 state
    if !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        AArch64_vESBOperation();
        return;
    end;

    // If physical SError interrupts are routed to Hyp mode, and TGE is not set, then a virtual
    // SError interrupt might be pending.
    let vsei_pending : boolean = <a href="shared_pseudocode.html#func_IsVirtualSErrorPending_0" title="">IsVirtualSErrorPending</a>() &amp;&amp; HCR().TGE == '0' &amp;&amp; HCR().AMO == '1';
    let vsei_masked : boolean  = (PSTATE.A == '1' || <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() ||
                                  <a href="shared_pseudocode.html#func_ExternalDebugInterruptsDisabled_1" title="">ExternalDebugInterruptsDisabled</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>));

    // Check for a masked virtual SError pending
    if vsei_pending &amp;&amp; vsei_masked then
        var syndrome : bits(32) = Zeros{};
        syndrome[31]    = '1';           // A
        syndrome[15:14] = VDFSR()[15:14];  // AET
        syndrome[12]    = VDFSR()[12];     // ExT
        syndrome[9]     = TTBCR().EAE;     // LPAE
        if TTBCR().EAE == '1' then         // Long-descriptor format
            syndrome[5:0]    = '010001'; // STATUS
        else                             // Short-descriptor format
            syndrome[10,3:0] = '10110';  // FS
        end;
        VDISR() = syndrome;
        ClearPendingVirtualSError();
    elsif IsFeatureImplemented(FEAT_E3DSE) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        AArch64_dESBOperation();
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.AArch32_ResetGeneralRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/AArch32_ResetGeneralRegisters</h3>
      <p class="pseudocode">// AArch32_ResetGeneralRegisters()
// ===============================

func AArch32_ResetGeneralRegisters()
begin

    for i = 0 to 7 do
        <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(i) = ARBITRARY : bits(32);
    end;
    for i = 8 to 12 do
        <a href="shared_pseudocode.html#accessor_Rmode_2" title="">Rmode</a>(i, <a href="shared_pseudocode.html#global_M32_User" title="">M32_User</a>) = ARBITRARY : bits(32);
        <a href="shared_pseudocode.html#accessor_Rmode_2" title="">Rmode</a>(i, <a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a>)  = ARBITRARY : bits(32);
    end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then <a href="shared_pseudocode.html#accessor_Rmode_2" title="">Rmode</a>(13, <a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>) = ARBITRARY : bits(32); end;   // No R14_hyp
    for i = 13 to 14 do
        <a href="shared_pseudocode.html#accessor_Rmode_2" title="">Rmode</a>(i, <a href="shared_pseudocode.html#global_M32_User" title="">M32_User</a>)  = ARBITRARY : bits(32);
        <a href="shared_pseudocode.html#accessor_Rmode_2" title="">Rmode</a>(i, <a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a>)   = ARBITRARY : bits(32);
        <a href="shared_pseudocode.html#accessor_Rmode_2" title="">Rmode</a>(i, <a href="shared_pseudocode.html#global_M32_IRQ" title="">M32_IRQ</a>)   = ARBITRARY : bits(32);
        <a href="shared_pseudocode.html#accessor_Rmode_2" title="">Rmode</a>(i, <a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>)   = ARBITRARY : bits(32);
        <a href="shared_pseudocode.html#accessor_Rmode_2" title="">Rmode</a>(i, <a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>) = ARBITRARY : bits(32);
        <a href="shared_pseudocode.html#accessor_Rmode_2" title="">Rmode</a>(i, <a href="shared_pseudocode.html#global_M32_Undef" title="">M32_Undef</a>) = ARBITRARY : bits(32);
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then <a href="shared_pseudocode.html#accessor_Rmode_2" title="">Rmode</a>(i, <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a>) = ARBITRARY : bits(32); end;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.AArch32_ResetSIMDFPRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/AArch32_ResetSIMDFPRegisters</h3>
      <p class="pseudocode">// AArch32_ResetSIMDFPRegisters()
// ==============================

func AArch32_ResetSIMDFPRegisters()
begin

    for i = 0 to 15 do
        <a href="shared_pseudocode.html#accessor_Q_1" title="">Q</a>(i) = ARBITRARY : bits(128);
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.AArch32_ResetSpecialRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/AArch32_ResetSpecialRegisters</h3>
      <p class="pseudocode">// AArch32_ResetSpecialRegisters()
// ===============================

func AArch32_ResetSpecialRegisters()
begin

    // AArch32 special registers
    SPSR_fiq()[31:0] = ARBITRARY : bits(32);
    SPSR_irq()[31:0] = ARBITRARY : bits(32);
    SPSR_svc()[31:0] = ARBITRARY : bits(32);
    SPSR_abt()[31:0] = ARBITRARY : bits(32);
    SPSR_und()[31:0] = ARBITRARY : bits(32);
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        SPSR_hyp() = ARBITRARY : bits(32);
        ELR_hyp()  = ARBITRARY : bits(32);
    end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        SPSR_mon() = ARBITRARY : bits(32);
    end;

    // External debug special registers
    DLR()   = ARBITRARY : bits(32);
    DSPSR() = ARBITRARY : bits(32);

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.AArch32_ResetSystemRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/AArch32_ResetSystemRegisters</h3>
      <p class="pseudocode">// AArch32_ResetSystemRegisters()
// ==============================

impdef func AArch32_ResetSystemRegisters(cold_reset : boolean)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.ALUExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/ALUExceptionReturn</h3>
      <p class="pseudocode">// ALUExceptionReturn()
// ====================

func ALUExceptionReturn(address : bits(32))
begin
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        Undefined();
    elsif PSTATE.M IN {<a href="shared_pseudocode.html#global_M32_User" title="">M32_User</a>,<a href="shared_pseudocode.html#global_M32_System" title="">M32_System</a>} then
        let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_ALUEXCEPTIONRETURN" title="">Unpredictable_ALUEXCEPTIONRETURN</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>, <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a>};
        case c of
            when <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a> =&gt;
                Undefined();
            when <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a> =&gt;
                ExecuteAsNOP();
        end;
    else
        AArch32_ExceptionReturn(address, <a href="shared_pseudocode.html#accessor_SPSR_curr_0" title="">SPSR_curr</a>());
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.ALUWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/ALUWritePC</h3>
      <p class="pseudocode">// ALUWritePC()
// ============

func ALUWritePC(address : bits(32))
begin
    if CurrentInstrSet() == InstrSet_A32 then
        BXWritePC(address, <a href="shared_pseudocode.html#enum_BranchType_INDIR" title="">BranchType_INDIR</a>);
    else
        BranchWritePC(address, <a href="shared_pseudocode.html#enum_BranchType_INDIR" title="">BranchType_INDIR</a>);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.BXWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/BXWritePC</h3>
      <p class="pseudocode">// BXWritePC()
// ===========

func BXWritePC(address_in : bits(32), branch_type : <a href="shared_pseudocode.html#type_BranchType" title="">BranchType</a>)
begin
    var address : bits(32) = address_in;
    if address[0] == '1' then
        SelectInstrSet(InstrSet_T32);
        address[0] = '0';
    else
        SelectInstrSet(InstrSet_A32);
        // For branches to an unaligned PC counter in A32 state, the PE takes the branch
        // and does one of:
        // * Forces the address to be aligned
        // * Leaves the PC unaligned, meaning the target generates a PC Alignment fault.
        if address[1] == '1' &amp;&amp; <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_A32FORCEALIGNPC" title="">Unpredictable_A32FORCEALIGNPC</a>) then
            address[1] = '0';
        end;
    end;
    let branch_conditional : boolean = <a href="shared_pseudocode.html#func_CurrentCond_0" title="">CurrentCond</a>() != '111x';
    BranchTo{32}(address, branch_type, branch_conditional);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.BranchWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/BranchWritePC</h3>
      <p class="pseudocode">// BranchWritePC()
// ===============

func BranchWritePC(address_in : bits(32), branch_type : <a href="shared_pseudocode.html#type_BranchType" title="">BranchType</a>)
begin
    var address : bits(32) = address_in;
    if CurrentInstrSet() == InstrSet_A32 then
        address[1:0] = '00';
    else
        address[0] = '0';
    end;
    let branch_conditional : boolean = <a href="shared_pseudocode.html#func_CurrentCond_0" title="">CurrentCond</a>() != '111x';
    BranchTo{32}(address, branch_type, branch_conditional);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.CBWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/CBWritePC</h3>
      <p class="pseudocode">// CBWritePC()
// ===========
// Takes a branch from a CBNZ/CBZ instruction.

func CBWritePC(address_in : bits(32))
begin
    var address : bits(32) = address_in;
    assert CurrentInstrSet() == InstrSet_T32;
    address[0] = '0';
    let branch_conditional : boolean = TRUE;
    BranchTo{32}(address, <a href="shared_pseudocode.html#enum_BranchType_DIR" title="">BranchType_DIR</a>, branch_conditional);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.D"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/D</h3>
      <p class="pseudocode">// D - accessor
// ============

accessor <a id="accessor_D_1"/>D(n : integer) &lt;=&gt; value : bits(64)
begin
    getter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        let vreg : bits(128) = V{}(n DIVRM 2);
        return vreg[(n MOD 2)*:64];
    end;
    setter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        var vreg : bits(128) = V{}(n DIVRM 2);
        vreg[(n MOD 2)*:64] = value;
        V{128}(n DIVRM 2) = vreg;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Din"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Din</h3>
      <p class="pseudocode">// Din
// ===
// Return the initial value of D input

func <a id="func_Din_1"/>Din(n : integer) =&gt; bits(64)
begin
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    return <a href="shared_pseudocode.html#global__Dclone" title="">_Dclone</a>[[n]];
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.H"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/H</h3>
      <p class="pseudocode">// H - accessor
// ============

accessor <a id="accessor_H_1"/>H(n : integer) &lt;=&gt; value : bits(16)
begin
    getter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        return <a href="shared_pseudocode.html#accessor_S_1" title="">S</a>(n)[15:0];
    end;
    setter
        <a href="shared_pseudocode.html#accessor_S_1" title="">S</a>(n) = ZeroExtend{32}(value);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.LR"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/LR</h3>
      <p class="pseudocode">// LR - accessor
// =============

accessor <a id="accessor_LR_0"/>LR() &lt;=&gt; value : bits(32)
begin
    getter
        return <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(14);
    end;
    setter
        <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(14) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.LoadWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/LoadWritePC</h3>
      <p class="pseudocode">// LoadWritePC()
// =============

func LoadWritePC(address : bits(32))
begin
    BXWritePC(address, <a href="shared_pseudocode.html#enum_BranchType_INDIR" title="">BranchType_INDIR</a>);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.LookUpRIndex"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/LookUpRIndex</h3>
      <p class="pseudocode">// LookUpRIndex()
// ==============

func <a id="func_LookUpRIndex_2"/>LookUpRIndex(n : integer, mode : bits(5)) =&gt; integer
begin
    assert n &gt;= 0 &amp;&amp; n &lt;= 14;

    var result : integer;
    case n of  // Select  index by mode:     usr fiq irq svc abt und hyp
        when 8    =&gt;  result = <a href="shared_pseudocode.html#func_RBankSelect_8" title="">RBankSelect</a>(mode,  8, 24,  8,  8,  8,  8,  8);
        when 9    =&gt;  result = <a href="shared_pseudocode.html#func_RBankSelect_8" title="">RBankSelect</a>(mode,  9, 25,  9,  9,  9,  9,  9);
        when 10   =&gt;  result = <a href="shared_pseudocode.html#func_RBankSelect_8" title="">RBankSelect</a>(mode, 10, 26, 10, 10, 10, 10, 10);
        when 11   =&gt;  result = <a href="shared_pseudocode.html#func_RBankSelect_8" title="">RBankSelect</a>(mode, 11, 27, 11, 11, 11, 11, 11);
        when 12   =&gt;  result = <a href="shared_pseudocode.html#func_RBankSelect_8" title="">RBankSelect</a>(mode, 12, 28, 12, 12, 12, 12, 12);
        when 13   =&gt;  result = <a href="shared_pseudocode.html#func_RBankSelect_8" title="">RBankSelect</a>(mode, 13, 29, 17, 19, 21, 23, 15);
        when 14   =&gt;  result = <a href="shared_pseudocode.html#func_RBankSelect_8" title="">RBankSelect</a>(mode, 14, 30, 16, 18, 20, 22, 14);
        otherwise =&gt;  result = n;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Monitor"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Monitor</h3>
      <p class="pseudocode">// Monitor mode registers
// ======================
// The Monitor mode registers do not map to X registers, so must be defined separately

var <a id="global_SP_mon"/>SP_mon : bits(32);

var <a id="global_LR_mon"/>LR_mon : bits(32);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.PC32"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/PC32</h3>
      <p class="pseudocode">// PC32
// ====
// Read 32-bit program counter

func <a id="func_PC32_0"/>PC32() =&gt; bits(32)
begin
    return <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(15);               // This includes the offset from AArch32 state
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.PCStoreValue"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/PCStoreValue</h3>
      <p class="pseudocode">// PCStoreValue()
// ==============

func <a id="func_PCStoreValue_0"/>PCStoreValue() =&gt; bits(32)
begin
    // This function returns the PC value. On architecture versions before Armv7, it
    // is permitted to instead return PC+4, provided it does so consistently. It is
    // used only to describe A32 instructions, so it returns the address of the current
    // instruction plus 8 (normally) or 12 (when the alternative is permitted).
    return <a href="shared_pseudocode.html#func_PC32_0" title="">PC32</a>();
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Q"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Q</h3>
      <p class="pseudocode">// Q - accessor
// ============

accessor <a id="accessor_Q_1"/>Q(n : integer) &lt;=&gt; value : bits(128)
begin
    getter
        assert n &gt;= 0 &amp;&amp; n &lt;= 15;
        return V{128}(n);
    end;
    setter
        assert n &gt;= 0 &amp;&amp; n &lt;= 15;
        V{128}(n) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Qin"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Qin</h3>
      <p class="pseudocode">// Qin
// ===
// Return the initial value of Q input

func <a id="func_Qin_1"/>Qin(n : integer) =&gt; bits(128)
begin
    assert n &gt;= 0 &amp;&amp; n &lt;= 15;
    return <a href="shared_pseudocode.html#func_Din_1" title="">Din</a>(2*n+1)::<a href="shared_pseudocode.html#func_Din_1" title="">Din</a>(2*n);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.R"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/R</h3>
      <p class="pseudocode">// R - accessor
// ============

accessor <a id="accessor_R_1"/>R(n : integer) &lt;=&gt; value : bits(32)
begin
    getter
        if n == 15 then
            let offset : integer{} = (if CurrentInstrSet() == InstrSet_A32 then 8 else 4);
            return <a href="shared_pseudocode.html#global__PC" title="">_PC</a>[31:0] + offset;
        else
            return <a href="shared_pseudocode.html#accessor_Rmode_2" title="">Rmode</a>(n, PSTATE.M);
        end;
    end;
    setter
        <a href="shared_pseudocode.html#accessor_Rmode_2" title="">Rmode</a>(n, PSTATE.M) = value;
        return;
    end;
end;

// R - accessor
// ============

accessor <a id="accessor_R_2"/>R(lr : integer, hr : integer) &lt;=&gt; value : bits(64)
begin
    getter
        return <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(hr) :: <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(lr);
    end;

    setter
        <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(lr) = value[0+:32];
        <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(hr) = value[32+:32];
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.RBankSelect"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/RBankSelect</h3>
      <p class="pseudocode">// RBankSelect()
// =============

func <a id="func_RBankSelect_8"/>RBankSelect(mode : bits(5), usr : integer, fiq : integer, irq : integer,
                 svc : integer, abt : integer, und : integer, hyp : integer) =&gt; integer
begin

    var result : integer;
    case mode of
        when <a href="shared_pseudocode.html#global_M32_User" title="">M32_User</a>   =&gt; result = usr;  // User mode
        when <a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a>    =&gt; result = fiq;  // FIQ mode
        when <a href="shared_pseudocode.html#global_M32_IRQ" title="">M32_IRQ</a>    =&gt; result = irq;  // IRQ mode
        when <a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>    =&gt; result = svc;  // Supervisor mode
        when <a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>  =&gt; result = abt;  // Abort mode
        when <a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>    =&gt; result = hyp;  // Hyp mode
        when <a href="shared_pseudocode.html#global_M32_Undef" title="">M32_Undef</a>  =&gt; result = und;  // Undefined mode
        when <a href="shared_pseudocode.html#global_M32_System" title="">M32_System</a> =&gt; result = usr;  // System mode uses User mode registers
        otherwise       =&gt; unreachable;   // Monitor mode
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.ReadAnyAllocatedRegister"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/ReadAnyAllocatedRegister</h3>
      <p class="pseudocode">// ReadAnyAllocatedRegister()
// ==========================

impdef func <a id="func_ReadAnyAllocatedRegister_0"/>ReadAnyAllocatedRegister() =&gt; bits(32)
begin
    return Zeros{32};
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.ReadAnyAllocatedSPSR"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/ReadAnyAllocatedSPSR</h3>
      <p class="pseudocode">// ReadAnyAllocatedSPSR()
// ======================

impdef func <a id="func_ReadAnyAllocatedSPSR_0"/>ReadAnyAllocatedSPSR() =&gt; bits(32)
begin
    return Zeros{32};
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Rmode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Rmode</h3>
      <p class="pseudocode">// Rmode - accessor
// ================

accessor <a id="accessor_Rmode_2"/>Rmode(n : integer, mode : bits(5)) &lt;=&gt; value : bits(32)
begin
    getter
        assert n &gt;= 0 &amp;&amp; n &lt;= 14;

        // Check for attempted use of Monitor mode in Non-secure state.
        if <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then assert mode != <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a>; end;
        assert !<a href="shared_pseudocode.html#func_BadMode_1" title="">BadMode</a>(mode);

        if mode == <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> then
            if n == 13 then return <a href="shared_pseudocode.html#global_SP_mon" title="">SP_mon</a>;
            elsif n == 14 then return <a href="shared_pseudocode.html#global_LR_mon" title="">LR_mon</a>;
            else return <a href="shared_pseudocode.html#global__R" title="">_R</a>[[n]][31:0];
            end;
        else
            return <a href="shared_pseudocode.html#global__R" title="">_R</a>[[<a href="shared_pseudocode.html#func_LookUpRIndex_2" title="">LookUpRIndex</a>(n, mode)]][31:0];
        end;
    end;

    setter
        assert n &gt;= 0 &amp;&amp; n &lt;= 14;

        // Check for attempted use of Monitor mode in Non-secure state.
        if <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then assert mode != <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a>; end;
        assert !<a href="shared_pseudocode.html#func_BadMode_1" title="">BadMode</a>(mode);

        if mode == <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> then
            if n == 13 then <a href="shared_pseudocode.html#global_SP_mon" title="">SP_mon</a> = value;
            elsif n == 14 then <a href="shared_pseudocode.html#global_LR_mon" title="">LR_mon</a> = value;
            else <a href="shared_pseudocode.html#global__R" title="">_R</a>[[n]][31:0] = value;
            end;
        else
            // It is CONSTRAINED UNPREDICTABLE whether the upper 32 bits of the X
            // register are unchanged or set to zero. This is also tested for on
            // exception entry, as this applies to all AArch32 registers.
            if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() &amp;&amp; <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_ZEROUPPER" title="">Unpredictable_ZEROUPPER</a>) then
                <a href="shared_pseudocode.html#global__R" title="">_R</a>[[<a href="shared_pseudocode.html#func_LookUpRIndex_2" title="">LookUpRIndex</a>(n, mode)]] = ZeroExtend{64}(value);
            else
                <a href="shared_pseudocode.html#global__R" title="">_R</a>[[<a href="shared_pseudocode.html#func_LookUpRIndex_2" title="">LookUpRIndex</a>(n, mode)]][31:0] = value;
            end;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.S"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/S</h3>
      <p class="pseudocode">// S - accessor
// ============

accessor <a id="accessor_S_1"/>S(n : integer) &lt;=&gt; value : bits(32)
begin
    getter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        let vreg : bits(128) = V{}(n DIVRM 4);
        return vreg[(n MOD 4)*:32];
    end;

    setter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        var vreg : bits(128) = V{}(n DIVRM 4);
        vreg[(n MOD 4)*:32] = value;
        V{128}(n DIVRM 4) = vreg;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.WriteAnyAllocatedRegister"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/WriteAnyAllocatedRegister</h3>
      <p class="pseudocode">// WriteAnyAllocatedRegister()
// ===========================

impdef func WriteAnyAllocatedRegister(value : bits(32))
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.WriteAnyAllocatedSPSR"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/WriteAnyAllocatedSPSR</h3>
      <p class="pseudocode">// WriteAnyAllocatedSPSR()
// =======================

impdef func WriteAnyAllocatedSPSR(value : bits(32))
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers._Dclone"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/_Dclone</h3>
      <p class="pseudocode">// _Dclone[]
// =========
// Clone the 64-bit Advanced SIMD and VFP extension register bank for use as input to
// instruction pseudocode, to avoid read-after-write for Advanced SIMD and VFP operations.

var <a id="global__Dclone"/>_Dclone : array [[32]] of bits(64);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32_ExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32_ExceptionReturn</h3>
      <p class="pseudocode">// AArch32_ExceptionReturn()
// =========================

func AArch32_ExceptionReturn(new_pc_in : bits(32), spsr : bits(32))
begin
    var new_pc : bits(32) = new_pc_in;
    SynchronizeContext();
    // Attempts to change to an illegal mode or state will invoke the Illegal Execution state
    // mechanism
    SetPSTATEFromPSR{32}(spsr);
    ClearExclusiveLocal(<a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>());
    SendEventLocal();

    if PSTATE.IL == '1' then
        // If the exception return is illegal, PC[1:0] are UNKNOWN
        new_pc[1:0] = ARBITRARY : bits(2);
    else
        // LR[1:0] or LR[0] are treated as being 0, depending on the target instruction set state
        if PSTATE.T == '1' then
            new_pc[0] = '0';                 // T32
        else
            new_pc[1:0] = '00';              // A32
        end;
    end;

    let branch_conditional : boolean = <a href="shared_pseudocode.html#func_CurrentCond_0" title="">CurrentCond</a>() != '111x';
    BranchTo{32}(new_pc, <a href="shared_pseudocode.html#enum_BranchType_ERET" title="">BranchType_ERET</a>, branch_conditional);
    CheckExceptionCatch(FALSE);              // Check for debug event on exception return
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32_ExecutingCP10or11Instr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32_ExecutingCP10or11Instr</h3>
      <p class="pseudocode">// AArch32_ExecutingCP10or11Instr()
// ================================

func AArch32_ExecutingCP10or11Instr() =&gt; boolean
begin
    let instr : bits(32) =  ThisInstr();
    let instr_set : <a href="shared_pseudocode.html#InstrSet" title="type InstrSet">InstrSet</a> = CurrentInstrSet();
    assert instr_set IN {InstrSet_A32, InstrSet_T32};

    if instr_set == InstrSet_A32 then
        return ((instr[27:24] == '1110' || instr[27:25] == '110') &amp;&amp; instr[11:8] == '101x');
    else // InstrSet_T32
        return (instr[31:28] == '111x' &amp;&amp; (instr[27:24] == '1110' || instr[27:25] == '110') &amp;&amp;
                instr[11:8] == '101x');
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32_ITAdvance"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32_ITAdvance</h3>
      <p class="pseudocode">// AArch32_ITAdvance()
// ===================

func AArch32_ITAdvance()
begin
    if PSTATE.IT[2:0] == '000' then
        PSTATE.IT = '00000000';
    else
        PSTATE.IT[4:0] = LSL(PSTATE.IT[4:0], 1);
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32_InterruptPending"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32_InterruptPending</h3>
      <p class="pseudocode">// AArch32_InterruptPending()
// ==========================
// Returns TRUE if there are any pending physical or virtual interrupts, and FALSE otherwise.

func <a id="func_AArch32_InterruptPending_0"/>AArch32_InterruptPending() =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        return <a href="shared_pseudocode.html#func_AArch64_InterruptPending_0" title="">AArch64_InterruptPending</a>();
    end;

    let (irq_pending, -) = <a href="shared_pseudocode.html#func_IRQPending_0" title="">IRQPending</a>();
    let (fiq_pending, -) = <a href="shared_pseudocode.html#func_FIQPending_0" title="">FIQPending</a>();
    let pending_physical_interrupt : boolean = (irq_pending || fiq_pending ||
                                                <a href="shared_pseudocode.html#func_IsPhysicalSErrorPending_0" title="">IsPhysicalSErrorPending</a>());

    var pending_virtual_interrupt : boolean = FALSE;
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; HCR().TGE == '0' then
        let virq_pending : boolean = (HCR().IMO == '1' &amp;&amp; (<a href="shared_pseudocode.html#func_VirtualIRQPending_0" title="">VirtualIRQPending</a>() || HCR().VI == '1'));
        let vfiq_pending : boolean = (HCR().FMO == '1' &amp;&amp; (<a href="shared_pseudocode.html#func_VirtualFIQPending_0" title="">VirtualFIQPending</a>() || HCR().VF == '1'));
        let vsei_pending : boolean = (HCR().AMO == '1' &amp;&amp;
                                      (<a href="shared_pseudocode.html#func_IsVirtualSErrorPending_0" title="">IsVirtualSErrorPending</a>() || HCR().VA == '1'));

        pending_virtual_interrupt = vsei_pending || virq_pending || vfiq_pending;
    end;

    return pending_physical_interrupt || pending_virtual_interrupt;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32_SysRegRead"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32_SysRegRead</h3>
      <p class="pseudocode">// AArch32_SysRegRead()
// ====================
// Read from a 32-bit AArch32 System register and write the register's contents to R[t].

impdef func AArch32_SysRegRead(cp_num : integer, instr : bits(32), t : integer)
begin
    let (-, el) = <a href="shared_pseudocode.html#func_ELFromM32_1" title="">ELFromM32</a>(PSTATE.M);
    let opc1 = instr[21+:3];
    let CRn  = instr[16+:4];
    let CRm  = instr[0+:4];
    let opc2 = instr[5+:3];
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32_SysRegRead64"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32_SysRegRead64</h3>
      <p class="pseudocode">// AArch32_SysRegRead64()
// ======================
// Read from a 64-bit AArch32 System register and write the register's contents to R[t] and R[t2].

impdef func AArch32_SysRegRead64(cp_num : integer, instr : bits(32), t : integer, t2 : integer)
begin
    let (-, el) = <a href="shared_pseudocode.html#func_ELFromM32_1" title="">ELFromM32</a>(PSTATE.M);
    let opc1 = instr[4+:4];
    let CRm  = instr[0+:4];
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32_SysRegReadCanWriteAPSR"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32_SysRegReadCanWriteAPSR</h3>
      <p class="pseudocode">// AArch32_SysRegReadCanWriteAPSR()
// ================================
// Determines whether the AArch32 System register read instruction can write to APSR flags.

func <a id="func_AArch32_SysRegReadCanWriteAPSR_2"/>AArch32_SysRegReadCanWriteAPSR(cp_num : integer, instr : bits(32)) =&gt; boolean
begin
    assert <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
    assert (cp_num IN {14,15});
    assert cp_num == UInt(instr[11:8]);

    let opc1 : integer{} = UInt(instr[23:21]);
    let opc2 : integer{} = UInt(instr[7:5]);
    let CRn : integer{}  = UInt(instr[19:16]);
    let CRm : integer{}  = UInt(instr[3:0]);

    if cp_num == 14 &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0 then // DBGDSCRint
        return TRUE;
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32_SysRegWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32_SysRegWrite</h3>
      <p class="pseudocode">// AArch32_SysRegWrite()
// =====================
// Read the contents of R[t] and write to a 32-bit AArch32 System register.

impdef func AArch32_SysRegWrite(cp_num : integer, instr : bits(32), t : integer)
begin
    let (-, el) = <a href="shared_pseudocode.html#func_ELFromM32_1" title="">ELFromM32</a>(PSTATE.M);
    let opc1 = instr[21+:3];
    let CRn  = instr[16+:4];
    let CRm  = instr[ 0+:4];
    let opc2 = instr[ 5+:3];
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32_SysRegWrite64"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32_SysRegWrite64</h3>
      <p class="pseudocode">// AArch32_SysRegWrite64()
// =======================
// Read the contents of R[t] and R[t2] and write to a 64-bit AArch32 System register.

impdef func AArch32_SysRegWrite64(cp_num : integer,
                                  instr : bits(32),
                                  t : integer,
                                  t2 : integer)
begin
    let (-, el) = <a href="shared_pseudocode.html#func_ELFromM32_1" title="">ELFromM32</a>(PSTATE.M);
    let opc1 = instr[4+:4];
    let CRm  = instr[0+:4];
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32_SysRegWriteM"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32_SysRegWriteM</h3>
      <p class="pseudocode">// AArch32_SysRegWriteM()
// ======================
// Read a value from a virtual address and write it to an AArch32 System register.

impdef func AArch32_SysRegWriteM(cp_num : integer, instr : bits(32), address : bits(32))
begin
    let CRd : bits(4) = instr[15:12];
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32_WriteMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32_WriteMode</h3>
      <p class="pseudocode">// AArch32_WriteMode()
// ===================
// Function for dealing with writes to PSTATE.M from AArch32 state only.
// This ensures that PSTATE.EL and PSTATE.SP are always valid.

func AArch32_WriteMode(mode : bits(5))
begin
    let (valid,el) : (boolean, bits(2)) = <a href="shared_pseudocode.html#func_ELFromM32_1" title="">ELFromM32</a>(mode);
    assert valid;
    PSTATE.M   = mode;
    PSTATE.EL  = el;
    PSTATE.nRW = '1';
    PSTATE.SP  = (if mode IN {<a href="shared_pseudocode.html#global_M32_User" title="">M32_User</a>,<a href="shared_pseudocode.html#global_M32_System" title="">M32_System</a>} then '0' else '1');
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32_WriteModeByInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32_WriteModeByInstr</h3>
      <p class="pseudocode">// AArch32_WriteModeByInstr()
// ==========================
// Function for dealing with writes to PSTATE.M from an AArch32 instruction, and ensuring that
// illegal state changes are correctly flagged in PSTATE.IL.

func AArch32_WriteModeByInstr(mode : bits(5))
begin
    var (valid,el) : (boolean, bits(2)) = <a href="shared_pseudocode.html#func_ELFromM32_1" title="">ELFromM32</a>(mode);

    // 'valid' is set to FALSE if' mode' is invalid for this implementation or the current value
    // of SCR.NS/SCR_EL3.NS. Additionally, it is illegal for an instruction to write 'mode' to
    // PSTATE.EL if it would result in any of:
    // * A change to a mode that would cause entry to a higher Exception level.
    if UInt(el) &gt; UInt(PSTATE.EL) then
        valid = FALSE;
    end;

    // * A change to or from Hyp mode.
    if (PSTATE.M == <a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a> || mode == <a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>) &amp;&amp; PSTATE.M != mode then
        valid = FALSE;
    end;

    // * When EL2 is implemented, the value of HCR.TGE is '1', a change to a Non-secure EL1 mode.
    if (PSTATE.M == <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; SCR().NS == '1'
            &amp;&amp; HCR().TGE == '1') then
        valid = FALSE;
    end;

    if !valid then
        PSTATE.IL = '1';
    else
        AArch32_WriteMode(mode);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.BadMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/BadMode</h3>
      <p class="pseudocode">// BadMode()
// =========

readonly func <a id="func_BadMode_1"/>BadMode(mode : bits(5)) =&gt; boolean
begin
    // Return TRUE if 'mode' encodes a mode that is not valid for this implementation
    var valid : boolean;
    case mode of
        when <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> =&gt;
            valid = <a href="shared_pseudocode.html#func_HaveAArch32EL_1" title="">HaveAArch32EL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        when <a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a> =&gt;
            valid = <a href="shared_pseudocode.html#func_HaveAArch32EL_1" title="">HaveAArch32EL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
        when <a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a>, <a href="shared_pseudocode.html#global_M32_IRQ" title="">M32_IRQ</a>, <a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>, <a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>, <a href="shared_pseudocode.html#global_M32_Undef" title="">M32_Undef</a>, <a href="shared_pseudocode.html#global_M32_System" title="">M32_System</a> =&gt;
            // If EL3 is implemented and using AArch32, then these modes are EL3 modes in Secure
            // state, and EL1 modes in Non-secure state. If EL3 is not implemented or is using
            // AArch64, then these modes are EL1 modes.
            // Therefore it is sufficient to test this implementation supports EL1 using AArch32
            valid = <a href="shared_pseudocode.html#func_HaveAArch32EL_1" title="">HaveAArch32EL</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
        when <a href="shared_pseudocode.html#global_M32_User" title="">M32_User</a> =&gt;
            valid = <a href="shared_pseudocode.html#func_HaveAArch32EL_1" title="">HaveAArch32EL</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>);
        otherwise =&gt;
            valid = FALSE;           // Passed an illegal mode value
    end;
    return !valid;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.BankedRegisterAccessValid"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/BankedRegisterAccessValid</h3>
      <p class="pseudocode">// BankedRegisterAccessValid()
// ===========================
// Checks for MRS (Banked register) or MSR (Banked register) accesses to registers
// other than the SPSRs that are invalid. This includes ELR_hyp accesses.

func <a id="func_BankedRegisterAccessValid_2"/>BankedRegisterAccessValid(SYSm : bits(5), mode : bits(5)) =&gt; (boolean, <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>)
begin
    var valid : boolean = TRUE;
    var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>;
    var banked_unpred : boolean = FALSE;
    case SYSm of
        when '000xx', '00100' =&gt;                          // R8_usr to R12_usr
            banked_unpred = mode != <a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a>;
        when '00101' =&gt;                                   // SP_usr
            banked_unpred = mode == <a href="shared_pseudocode.html#global_M32_System" title="">M32_System</a>;
        when '00110' =&gt;                                   // LR_usr
            banked_unpred = mode IN {<a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>,<a href="shared_pseudocode.html#global_M32_System" title="">M32_System</a>};
        when '010xx', '0110x', '01110' =&gt;                 // R8_fiq to R12_fiq, SP_fiq, LR_fiq
            banked_unpred = mode == <a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a>;
        when '1000x' =&gt;                                   // LR_irq, SP_irq
            banked_unpred = mode == <a href="shared_pseudocode.html#global_M32_IRQ" title="">M32_IRQ</a>;
        when '1001x' =&gt;                                   // LR_svc, SP_svc
            banked_unpred = mode == <a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>;
        when '1010x' =&gt;                                   // LR_abt, SP_abt
            banked_unpred = mode == <a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>;
        when '1011x' =&gt;                                   // LR_und, SP_und
            banked_unpred = mode == <a href="shared_pseudocode.html#global_M32_Undef" title="">M32_Undef</a>;
        when '1110x' =&gt;                                   // LR_mon, SP_mon
            banked_unpred = (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> ||
                               mode == <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a>);
        when '11110' =&gt;                                   // ELR_hyp, only from Monitor or Hyp mode
            banked_unpred = !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) || ! mode IN {<a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a>,<a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>};
        when '11111' =&gt;                                   // SP_hyp, only from Monitor mode
            banked_unpred = !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) || mode != <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a>;
        otherwise =&gt;
            valid = FALSE;
            c     = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_UnimplementedRegister" title="">Unpredictable_UnimplementedRegister</a>);
            assert c IN {<a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>, <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a>, <a href="shared_pseudocode.html#enum_Constraint_ANYREG" title="">Constraint_ANYREG</a>};
    end;

    if banked_unpred then
        valid = FALSE;
        c     = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_BankedRegister" title="">Unpredictable_BankedRegister</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>, <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};
    end;

    return (valid, c);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.CPSRWriteByInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/CPSRWriteByInstr</h3>
      <p class="pseudocode">// CPSRWriteByInstr()
// ==================
// Update PSTATE.[N,Z,C,V,Q,GR,E,A,I,F,M] from a CPSR value written by an MSR instruction.

func CPSRWriteByInstr(value : bits(32), bytemask : bits(4))
begin
    let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;        // PSTATE.[A,I,F,M] are not writable at EL0

    // Write PSTATE from 'value', ignoring bytes masked by 'bytemask'
    if bytemask[3] == '1' then
        PSTATE.[N,Z,C,V,Q] = value[31:27];
        // Bits [26:24] are ignored
    end;

    if bytemask[2] == '1' then
        if IsFeatureImplemented(FEAT_SSBS) then
            PSTATE.SSBS = value[23];
        end;
        if privileged then
            PSTATE.PAN = value[22];
        end;
        if IsFeatureImplemented(FEAT_DIT) then
            PSTATE.DIT = value[21];
        end;
        // Bit [20] is RES0
        PSTATE.GE = value[19:16];
    end;

    if bytemask[1] == '1' then
        // Bits [15:10] are RES0
        PSTATE.E = value[9];                    // PSTATE.E is writable at EL0
        if privileged then
            PSTATE.A = value[8];
        end;
    end;

    if bytemask[0] == '1' then
        if privileged then
            PSTATE.[I,F] = value[7:6];
            // Bit [5] is RES0
            // AArch32_WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.
            AArch32_WriteModeByInstr(value[4:0]);
        end;
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.ConditionPassed"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/ConditionPassed</h3>
      <p class="pseudocode">// ConditionPassed()
// =================

func <a id="func_ConditionPassed_0"/>ConditionPassed() =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_ConditionHolds_1" title="">ConditionHolds</a>(<a href="shared_pseudocode.html#func_CurrentCond_0" title="">CurrentCond</a>());
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.CurrentCond"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/CurrentCond</h3>
      <p class="pseudocode">// CurrentCond()
// =============
// Returns the condition code that applies to the currently executing instruction

impdef func <a id="func_CurrentCond_0"/>CurrentCond() =&gt; bits(4)
begin
    return Zeros{4};
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.InITBlock"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/InITBlock</h3>
      <p class="pseudocode">// InITBlock()
// ===========

func <a id="func_InITBlock_0"/>InITBlock() =&gt; boolean
begin
    if CurrentInstrSet() == InstrSet_T32 then
        return PSTATE.IT[3:0] != '0000';
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.LastInITBlock"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/LastInITBlock</h3>
      <p class="pseudocode">// LastInITBlock()
// ===============

func <a id="func_LastInITBlock_0"/>LastInITBlock() =&gt; boolean
begin
    return (PSTATE.IT[3:0] == '1000');
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.SPSRWriteByInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/SPSRWriteByInstr</h3>
      <p class="pseudocode">// SPSRWriteByInstr()
// ==================

func SPSRWriteByInstr(value : bits(32), bytemask : bits(4))
begin
    var new_spsr : bits(32) = <a href="shared_pseudocode.html#accessor_SPSR_curr_0" title="">SPSR_curr</a>();

    if bytemask[3] == '1' then
        new_spsr[31:24] = value[31:24];  // N,Z,C,V,Q flags, IT[1:0],J bits
    end;

    if bytemask[2] == '1' then
        new_spsr[23:16] = value[23:16];  // IL bit, GE[3:0] flags
    end;

    if bytemask[1] == '1' then
        new_spsr[15:8] = value[15:8];    // IT[7:2] bits, E bit, A interrupt mask
    end;

    if bytemask[0] == '1' then
        new_spsr[7:0] = value[7:0];      // I,F interrupt masks, T bit, Mode bits
    end;

    <a href="shared_pseudocode.html#accessor_SPSR_curr_0" title="">SPSR_curr</a>() = new_spsr;              // UNPREDICTABLE if User or System mode

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.SPSRaccessValid"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/SPSRaccessValid</h3>
      <p class="pseudocode">// SPSRaccessValid()
// =================
// Checks for MRS (Banked register) or MSR (Banked register) accesses to the SPSRs
// that are UNPREDICTABLE

func <a id="func_SPSRaccessValid_2"/>SPSRaccessValid(SYSm : bits(5), mode : bits(5)) =&gt; (boolean, <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>)
begin
    var valid : boolean = TRUE;
    var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>;
    var banked_unpred : boolean = FALSE;
    case SYSm of
        when '01110' =&gt;                                                   // SPSR_fiq
            banked_unpred = mode == <a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a>;
        when '10000' =&gt;                                                   // SPSR_irq
            banked_unpred = mode == <a href="shared_pseudocode.html#global_M32_IRQ" title="">M32_IRQ</a>;
        when '10010' =&gt;                                                   // SPSR_svc
            banked_unpred = mode == <a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>;
        when '10100' =&gt;                                                   // SPSR_abt
            banked_unpred = mode == <a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>;
        when '10110' =&gt;                                                   // SPSR_und
            banked_unpred = mode == <a href="shared_pseudocode.html#global_M32_Undef" title="">M32_Undef</a>;
        when '11100' =&gt;                                                   // SPSR_mon
            banked_unpred = (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || mode == <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> ||
                               <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>);
        when '11110' =&gt;                                                   // SPSR_hyp
            banked_unpred = !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) || mode != <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a>;
        otherwise =&gt;
            valid = FALSE;
            c = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_UnimplementedRegister" title="">Unpredictable_UnimplementedRegister</a>);
            assert c IN {<a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>, <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a>, <a href="shared_pseudocode.html#enum_Constraint_ANYREG" title="">Constraint_ANYREG</a>};
    end;

    if banked_unpred then
        valid = FALSE;
        c     = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_BankedRegister" title="">Unpredictable_BankedRegister</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>, <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};
    end;

    return (valid, c);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.SelectInstrSet"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/SelectInstrSet</h3>
      <p class="pseudocode">// SelectInstrSet()
// ================

func SelectInstrSet(iset : <a href="shared_pseudocode.html#InstrSet" title="type InstrSet">InstrSet</a>)
begin
    assert CurrentInstrSet() IN {InstrSet_A32, InstrSet_T32};
    assert iset IN {InstrSet_A32, InstrSet_T32};

    PSTATE.T = if iset == InstrSet_A32 then '0' else '1';

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_DTLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_DTLBI_ALL</h3>
      <p class="pseudocode">// AArch32_DTLBI_ALL()
// ===================
// Invalidate all data TLB entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated broadcast domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.

func AArch32_DTLBI_ALL(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>,
                       attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>)
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_DALL" title="">TLBIOp_DALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.attr         = attr;

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_DTLBI_ASID"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_DTLBI_ASID</h3>
      <p class="pseudocode">// AArch32_DTLBI_ASID()
// ====================
// Invalidate all data TLB stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Rt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated broadcast domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch32_DTLBI_ASID(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                        broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>, Rt : bits(32))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_DASID" title="">TLBIOp_DASID</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = Zeros{8} :: Rt[7:0];

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_DTLBI_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_DTLBI_VA</h3>
      <p class="pseudocode">// AArch32_DTLBI_VA()
// ==================
// Invalidate by VA all stage 1 data TLB entries in the indicated broadcast domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch32_DTLBI_VA(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                      broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>,  attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>, Rt : bits(32))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_DVA" title="">TLBIOp_DVA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = level;
    r.attr         = attr;
    r.asid         = Zeros{8} :: Rt[7:0];
    r.address      = Zeros{32} :: Rt[31:12] :: Zeros{12};

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_ITLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_ITLBI_ALL</h3>
      <p class="pseudocode">// AArch32_ITLBI_ALL()
// ===================
// Invalidate all instruction TLB entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated broadcast domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.

func AArch32_ITLBI_ALL(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>,
                       attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>)
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_IALL" title="">TLBIOp_IALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.attr         = attr;

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_ITLBI_ASID"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_ITLBI_ASID</h3>
      <p class="pseudocode">// AArch32_ITLBI_ASID()
// ====================
// Invalidate all instruction TLB stage 1 entries matching the indicated VMID
// (where regime supports) and ASID in the parameter Rt in the indicated translation
// regime with the indicated security state for all TLBs within the indicated broadcast domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch32_ITLBI_ASID(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                        broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>, Rt : bits(32))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_IASID" title="">TLBIOp_IASID</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = Zeros{8} :: Rt[7:0];

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_ITLBI_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_ITLBI_VA</h3>
      <p class="pseudocode">// AArch32_ITLBI_VA()
// ==================
// Invalidate by VA all stage 1 instruction TLB entries in the indicated broadcast domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch32_ITLBI_VA(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                      broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>,  attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>, Rt : bits(32))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_IVA" title="">TLBIOp_IVA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = level;
    r.attr         = attr;
    r.asid         = Zeros{8} :: Rt[7:0];
    r.address      = Zeros{32} :: Rt[31:12] :: Zeros{12};

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_TLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_TLBI_ALL</h3>
      <p class="pseudocode">// AArch32_TLBI_ALL()
// ==================
// Invalidate all entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated broadcast domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.

func AArch32_TLBI_ALL(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                      broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>)
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_ALL" title="">TLBIOp_ALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.attr         = attr;

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_TLBI_ASID"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_TLBI_ASID</h3>
      <p class="pseudocode">// AArch32_TLBI_ASID()
// ===================
// Invalidate all stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Rt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated broadcast domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch32_TLBI_ASID(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                       broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>, Rt : bits(32))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_ASID" title="">TLBIOp_ASID</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = Zeros{8} :: Rt[7:0];

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_TLBI_IPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_TLBI_IPAS2</h3>
      <p class="pseudocode">// AArch32_TLBI_IPAS2()
// ====================
// Invalidate by IPA all stage 2 only TLB entries in the indicated broadcast
// domain matching the indicated VMID in the indicated regime with the indicated security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// IPA and related parameters of the are derived from Rt.

func AArch32_TLBI_IPAS2(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                        broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>, Rt : bits(32))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>};
    assert security == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_IPAS2" title="">TLBIOp_IPAS2</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = TRUE;
    r.level        = level;
    r.attr         = attr;
    r.address      = Zeros{24} :: Rt[27:0] :: Zeros{12};
    r.ipaspace     = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_TLBI_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_TLBI_VA</h3>
      <p class="pseudocode">// AArch32_TLBI_VA()
// =================
// Invalidate by VA all stage 1 TLB entries in the indicated broadcast domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch32_TLBI_VA(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                     broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>,  attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>, Rt : bits(32))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_VA" title="">TLBIOp_VA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = level;
    r.attr         = attr;
    r.asid         = Zeros{8} :: Rt[7:0];
    r.address      = Zeros{32} :: Rt[31:12] :: Zeros{12};

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_TLBI_VAA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_TLBI_VAA</h3>
      <p class="pseudocode">// AArch32_TLBI_VAA()
// ==================
// Invalidate by VA all stage 1 TLB entries in the indicated broadcast domain
// matching the indicated VMID (where regime supports VMID) and all ASID in the indicated regime
// with the indicated security state.
// VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch32_TLBI_VAA(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                      broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,  Rt : bits(32))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_VAA" title="">TLBIOp_VAA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = level;
    r.attr         = attr;
    r.address      = Zeros{32} :: Rt[31:12] :: Zeros{12};

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_TLBI_VMALL"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_TLBI_VMALL</h3>
      <p class="pseudocode">// AArch32_TLBI_VMALL()
// ====================
// Invalidate all stage 1 entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated broadcast
// domain that match the indicated VMID (where applicable).
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// Note: stage 2 only entries are not in the scope of this operation.

func AArch32_TLBI_VMALL(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                        broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>)
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_VMALL" title="">TLBIOp_VMALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.attr         = attr;

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.tlbi.AArch32_TLBI_VMALLS12"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/tlbi/AArch32_TLBI_VMALLS12</h3>
      <p class="pseudocode">// AArch32_TLBI_VMALLS12()
// =======================
// Invalidate all stage 1 and stage 2 entries for the indicated translation
// regime with the indicated security state for all TLBs within the indicated
// broadcast domain that match the indicated VMID.

func AArch32_TLBI_VMALLS12(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                           broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>)
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_VMALLS12" title="">TLBIOp_VMALLS12</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.use_vmid     = TRUE;
    r.attr         = attr;

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.v6simd.Sat"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/v6simd/Sat</h3>
      <p class="pseudocode">// Sat()
// =====

func <a id="func_Sat_3"/>Sat{N}(i : integer, unsigned : boolean) =&gt; bits(N)
begin
    let result : bits(N) = if unsigned then <a href="shared_pseudocode.html#func_UnsignedSat_2" title="">UnsignedSat</a>{N}(i) else <a href="shared_pseudocode.html#func_SignedSat_2" title="">SignedSat</a>{N}(i);
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.ic.AArch32_CanTrapIC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/ic/AArch32_CanTrapIC</h3>
      <p class="pseudocode">// AArch32_CanTrapIC()
// ===================
// Determines whether the execution of the IC instruction can be trapped.

func <a id="func_AArch32_CanTrapIC_2"/>AArch32_CanTrapIC(cacheop : <a href="shared_pseudocode.html#type_CacheOp" title="">CacheOp</a>, opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>) =&gt; boolean
begin
    return (!<a href="shared_pseudocode.html#func_AArch32_TreatICAsNOP_2" title="">AArch32_TreatICAsNOP</a>(cacheop, opscope) || ImpDefBool(
            "When IC is treated as NOP, data cache maintenance operations are trapped"));
end;</p>
    </div>
    <div class="ps"><a id="aarch32.ic.AArch32_IC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/ic/AArch32_IC</h3>
      <p class="pseudocode">// AArch32_IC()
// ============
// Perform Instruction Cache Operation.

func AArch32_IC(opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>)
begin
    let regval : bits(32) = ARBITRARY : bits(32);
    AArch32_IC(regval, opscope);
end;

// AArch32_IC()
// ============
// Perform Instruction Cache Operation.

func AArch32_IC(regval : bits(32), opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>)
begin
    var cache : <a href="shared_pseudocode.html#type_CacheRecord" title="">CacheRecord</a>;

    cache.acctype   = <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>;
    cache.cachetype = <a href="shared_pseudocode.html#enum_CacheType_Instruction" title="">CacheType_Instruction</a>;
    cache.cacheop   = <a href="shared_pseudocode.html#enum_CacheOp_Invalidate" title="">CacheOp_Invalidate</a>;
    cache.opscope   = opscope;
    cache.security  = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(PSTATE.EL);

    if opscope IN {<a href="shared_pseudocode.html#enum_CacheOpScope_ALLU" title="">CacheOpScope_ALLU</a>, <a href="shared_pseudocode.html#enum_CacheOpScope_ALLUIS" title="">CacheOpScope_ALLUIS</a>} then
        if opscope == <a href="shared_pseudocode.html#enum_CacheOpScope_ALLUIS" title="">CacheOpScope_ALLUIS</a> then
            cache.shareability = <a href="shared_pseudocode.html#enum_Shareability_ISH" title="">Shareability_ISH</a>;
        else
            cache.shareability = <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a>;
        end;
        cache.regval = ZeroExtend{64}(regval);
        CACHE_OP(cache);
    else
        assert opscope == <a href="shared_pseudocode.html#enum_CacheOpScope_PoU" title="">CacheOpScope_PoU</a>;

        if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
            if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} then
                cache.is_vmid_valid = TRUE;
                cache.vmid          = <a href="shared_pseudocode.html#func_VMID_0" title="">VMID</a>();
            else
                cache.is_vmid_valid = FALSE;
            end;
        else
            cache.is_vmid_valid = FALSE;
        end;

        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
            cache.is_asid_valid = TRUE;
            cache.asid          = <a href="shared_pseudocode.html#func_ASID_0" title="">ASID</a>();
        else
            cache.is_asid_valid = FALSE;
        end;

        cache.shareability = <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a>;
        cache.vaddress     = ZeroExtend{64}(regval);

        let size : integer    = 0;
        let aligned : boolean = TRUE;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescIC_1" title="">CreateAccDescIC</a>(cache);
        let memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch32_TranslateAddress_4" title="">AArch32_TranslateAddress</a>(regval, accdesc, aligned,
                                                                          size);
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
            AArch32_Abort(memaddrdesc.fault);
        end;

        cache.paddress = memaddrdesc.paddress;
        CACHE_OP(cache);
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.ic.AArch32_TreatICAsNOP"/><h3 class="pseudocode">
            Library pseudocode for aarch32/ic/AArch32_TreatICAsNOP</h3>
      <p class="pseudocode">// AArch32_TreatICAsNOP()
// ======================
// Determines whether the execution of the IC instruction is treated as a NOP.

func <a id="func_AArch32_TreatICAsNOP_2"/>AArch32_TreatICAsNOP(cacheop : <a href="shared_pseudocode.html#type_CacheOp" title="">CacheOp</a>, opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>) =&gt; boolean
begin
    if CTR().DIC == '1' then
        return ImpDefBool("IC is treated as NOP");
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.predictionrestrict.AArch32_RestrictPrediction"/><h3 class="pseudocode">
            Library pseudocode for aarch32/predictionrestrict/AArch32_RestrictPrediction</h3>
      <p class="pseudocode">// AArch32_RestrictPrediction()
// ============================
// Clear all predictions in the context.

func AArch32_RestrictPrediction(val : bits(32), restriction : <a href="shared_pseudocode.html#type_RestrictType" title="">RestrictType</a>)
begin

    var c : <a href="shared_pseudocode.html#type_ExecutionCntxt" title="">ExecutionCntxt</a>;
    let target_el : bits(2) = val[25:24];

    // If the target EL is not implemented or the instruction is executed at an
    // EL lower than the specified level, the instruction is treated as a NOP.
    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(target_el) || UInt(target_el) &gt; UInt(PSTATE.EL) then ExecuteAsNOP(); end;

    let ns : bit  = val[26];
    let nse : bit = ARBITRARY : bit;
    let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_TargetSecurityState_2" title="">TargetSecurityState</a>(ns, nse);

    c.security  = ss;
    c.target_el = target_el;

    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = FALSE;
            c.vmid          = <a href="shared_pseudocode.html#func_VMID_0" title="">VMID</a>();

        elsif target_el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = val[27] == '1';
            c.vmid          = ZeroExtend{16}(val[23:16]);   // Only valid if  val[27] == '0';
        else
            c.is_vmid_valid = FALSE;
        end;
    else
        c.is_vmid_valid = FALSE;
    end;

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = FALSE;
        c.asid          = <a href="shared_pseudocode.html#func_ASID_0" title="">ASID</a>();

    elsif target_el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = val[8] == '1';
        c.asid          = ZeroExtend{16}(val[7:0]);         // Only valid if  val[8] == '0';

    else
        c.is_asid_valid = FALSE;
    end;

    c.restriction = restriction;
    RESTRICT_PREDICTIONS(c);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.attrs.AArch32_DefaultTEXDecode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/attrs/AArch32_DefaultTEXDecode</h3>
      <p class="pseudocode">// AArch32_DefaultTEXDecode()
// ==========================
// Apply short-descriptor format memory region attributes, without TEX remap

func <a id="func_AArch32_DefaultTEXDecode_4"/>AArch32_DefaultTEXDecode(TEX_in : bits(3), c_in : bit, b_in : bit, s : bit) =&gt; MemoryAttributes
begin
    var memattrs : MemoryAttributes;
    var TEX : bits(3) = TEX_in;
    var c : bit = c_in;
    var b : bit = b_in;

    // Reserved values map to allocated values
    if (TEX == '001' &amp;&amp; c::b == '01') || (TEX == '010' &amp;&amp; c::b != '00') || TEX == '011' then
        var texcb : bits(5);
        (-, texcb) = ConstrainUnpredictableBits{5}(<a href="shared_pseudocode.html#enum_Unpredictable_RESTEXCB" title="">Unpredictable_RESTEXCB</a>);
        TEX = texcb[4:2];  c = texcb[1];  b = texcb[0];
    end;

    // Distinction between Inner Shareable and Outer Shareable is not supported in this format
    // A memory region is either Non-shareable or Outer Shareable
    case TEX::c::b of
        when '00000' =&gt;
            // Device-nGnRnE
            memattrs.memtype      = MemType_Device;
            memattrs.device       = <a href="shared_pseudocode.html#enum_DeviceType_nGnRnE" title="">DeviceType_nGnRnE</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
        when '00001', '01000' =&gt;
            // Device-nGnRE
            memattrs.memtype      = MemType_Device;
            memattrs.device       = <a href="shared_pseudocode.html#enum_DeviceType_nGnRE" title="">DeviceType_nGnRE</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
        when '00010' =&gt;
            // Write-through Read allocate
            memattrs.memtype      = MemType_Normal;
            memattrs.inner.attrs  = <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a>;
            memattrs.inner.hints  = <a href="shared_pseudocode.html#global_MemHint_RA" title="">MemHint_RA</a>;
            memattrs.outer.attrs  = <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a>;
            memattrs.outer.hints  = <a href="shared_pseudocode.html#global_MemHint_RA" title="">MemHint_RA</a>;
            memattrs.shareability = if s == '1' then <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a> else <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a>;
        when '00011' =&gt;
            // Write-back Read allocate
            memattrs.memtype      = MemType_Normal;
            memattrs.inner.attrs  = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;
            memattrs.inner.hints  = <a href="shared_pseudocode.html#global_MemHint_RA" title="">MemHint_RA</a>;
            memattrs.outer.attrs  = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;
            memattrs.outer.hints  = <a href="shared_pseudocode.html#global_MemHint_RA" title="">MemHint_RA</a>;
            memattrs.shareability = if s == '1' then <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a> else <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a>;
        when '00100' =&gt;
            // Non-cacheable
            memattrs.memtype      = MemType_Normal;
            memattrs.inner.attrs  = <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>;
            memattrs.outer.attrs  = <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
        when '00110' =&gt;
            memattrs = ImpDefMemoryAttributes("IMPLEMENTATION_DEFINED");
        when '00111' =&gt;
            // Write-back Read and Write allocate
            memattrs.memtype      = MemType_Normal;
            memattrs.inner.attrs  = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;
            memattrs.inner.hints  = <a href="shared_pseudocode.html#global_MemHint_RWA" title="">MemHint_RWA</a>;
            memattrs.outer.attrs  = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;
            memattrs.outer.hints  = <a href="shared_pseudocode.html#global_MemHint_RWA" title="">MemHint_RWA</a>;
            memattrs.shareability = if s == '1' then <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a> else <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a>;
        when '1xxxx' =&gt;
            // Cacheable, TEX[1:0] = Outer attrs, {c,b} = Inner attrs
            memattrs.memtype = MemType_Normal;
            memattrs.inner   = <a href="shared_pseudocode.html#func_DecodeSDFAttr_1" title="">DecodeSDFAttr</a>(c::b);
            memattrs.outer   = <a href="shared_pseudocode.html#func_DecodeSDFAttr_1" title="">DecodeSDFAttr</a>(TEX[1:0]);

            if memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> then
                memattrs.shareability = <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
            else
                memattrs.shareability = if s == '1' then <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a> else <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a>;
            end;
        otherwise =&gt;
            // Reserved, handled above
            unreachable;
    end;

    // The Transient hint is not supported in this format
    memattrs.inner.transient = FALSE;
    memattrs.outer.transient = FALSE;
    memattrs.tags            = <a href="shared_pseudocode.html#enum_MemTag_Untagged" title="">MemTag_Untagged</a>;

    if memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> then
        memattrs.xs = '0';
    else
        memattrs.xs = '1';
    end;

    return memattrs;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.attrs.AArch32_MAIRAttr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/attrs/AArch32_MAIRAttr</h3>
      <p class="pseudocode">// AArch32_MAIRAttr()
// ==================
// Retrieve the memory attribute encoding indexed in the given MAIR

func <a id="func_AArch32_MAIRAttr_2"/>AArch32_MAIRAttr(index : integer, mair : MAIRType) =&gt; bits(8)
begin
    assert (index &lt; 8);
    return mair[index*:8];
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.attrs.AArch32_RemappedTEXDecode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/attrs/AArch32_RemappedTEXDecode</h3>
      <p class="pseudocode">// AArch32_RemappedTEXDecode()
// ===========================
// Apply short-descriptor format memory region attributes, with TEX remap

func <a id="func_AArch32_RemappedTEXDecode_5"/>AArch32_RemappedTEXDecode(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, TEX : bits(3),
                               c : bit, b : bit, s : bit) =&gt; MemoryAttributes
begin

    var memattrs : MemoryAttributes;
    var prrr : PRRR_Type;
    var nmrr : NMRR_Type;

    let region : integer{} = UInt(TEX[0]::c::b);   // TEX[2:1] are ignored in this mapping scheme
    if region == 6 then
        return ImpDefMemoryAttributes("IMPLEMENTATION_DEFINED");
    end;

    if regime == <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> then
        prrr = PRRR_S();
        nmrr = NMRR_S();
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        prrr = PRRR_NS();
        nmrr = NMRR_NS();
    else
        prrr = PRRR();
        nmrr = NMRR();
    end;

    let base : integer{} = 2 * region;
    var attrfield : bits(2) = prrr[region*:2];

    if attrfield == '11' then      // Reserved, maps to allocated value
        (-, attrfield) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_RESPRRR" title="">Unpredictable_RESPRRR</a>);
    end;

    case attrfield of
        when '00' =&gt;                  // Device-nGnRnE
            memattrs.memtype      = MemType_Device;
            memattrs.device       = <a href="shared_pseudocode.html#enum_DeviceType_nGnRnE" title="">DeviceType_nGnRnE</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
        when '01' =&gt;                  // Device-nGnRE
            memattrs.memtype      = MemType_Device;
            memattrs.device       = <a href="shared_pseudocode.html#enum_DeviceType_nGnRE" title="">DeviceType_nGnRE</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
        when '10' =&gt;
            let NSn : bit  = if s == '0' then prrr.NS0 else prrr.NS1;
            let NOSm : bit = prrr[region+24] AND NSn;
            let IRn : bits(2)  = nmrr[base+1:base];
            let ORn : bits(2)  = nmrr[base+17:base+16];

            memattrs.memtype = MemType_Normal;
            memattrs.inner   = <a href="shared_pseudocode.html#func_DecodeSDFAttr_1" title="">DecodeSDFAttr</a>(IRn);
            memattrs.outer   = <a href="shared_pseudocode.html#func_DecodeSDFAttr_1" title="">DecodeSDFAttr</a>(ORn);
            if memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> then
                memattrs.shareability = <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
            else
                let sh : bits(2) = NSn::NOSm;
                memattrs.shareability = <a href="shared_pseudocode.html#func_DecodeShareability_1" title="">DecodeShareability</a>(sh);
            end;
        when '11' =&gt;
            unreachable;
    end;

    // The Transient hint is not supported in this format
    memattrs.inner.transient = FALSE;
    memattrs.outer.transient = FALSE;
    memattrs.tags            = <a href="shared_pseudocode.html#enum_MemTag_Untagged" title="">MemTag_Untagged</a>;

    if memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> then
        memattrs.xs = '0';
    else
        memattrs.xs = '1';
    end;

    return memattrs;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.debug.AArch32_CheckBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/debug/AArch32_CheckBreakpoint</h3>
      <p class="pseudocode">// AArch32_CheckBreakpoint()
// =========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch32
// translation regime, when either debug exceptions are enabled, or halting debug is enabled
// and halting is allowed.

func <a id="func_AArch32_CheckBreakpoint_4"/>AArch32_CheckBreakpoint(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, vaddress : bits(32),
                             accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, size : integer) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    assert <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    assert size IN {2,4};

    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    var match : boolean = FALSE;
    var mismatch : boolean = FALSE;
    var brkptinfo : <a href="shared_pseudocode.html#type_BreakpointInfo" title="">BreakpointInfo</a>;

    for i = 0 to <a href="shared_pseudocode.html#func_NumBreakpointsImplemented_0" title="">NumBreakpointsImplemented</a>() - 1 do
        brkptinfo = <a href="shared_pseudocode.html#func_AArch32_BreakpointMatch_4" title="">AArch32_BreakpointMatch</a>(i, vaddress, accdesc, size);
        match = match || brkptinfo.match;
        mismatch = mismatch || brkptinfo.mismatch;
    end;

    if match &amp;&amp; <a href="shared_pseudocode.html#func_HaltOnBreakpointOrWatchpoint_0" title="">HaltOnBreakpointOrWatchpoint</a>() then
        let reason : bits(6) = <a href="shared_pseudocode.html#global_DebugHalt_Breakpoint" title="">DebugHalt_Breakpoint</a>;
        Halt(reason);
    elsif (match || mismatch) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Debug" title="">Fault_Debug</a>;
        fault.debugmoe   = <a href="shared_pseudocode.html#global_DebugException_Breakpoint" title="">DebugException_Breakpoint</a>;
        fault.vaddress   = ZeroExtend{64}(vaddress);
    end;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.debug.AArch32_CheckDebug"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/debug/AArch32_CheckDebug</h3>
      <p class="pseudocode">// AArch32_CheckDebug()
// ====================
// Called on each access to check for a debug exception or entry to Debug state.

func <a id="func_AArch32_CheckDebug_3"/>AArch32_CheckDebug(vaddress : bits(32), accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                        size : integer) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin

    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, ZeroExtend{64}(vaddress));

    let d_side : boolean = <a href="shared_pseudocode.html#func_IsWatchpointableAccess_1" title="">IsWatchpointableAccess</a>(accdesc);
    let i_side : boolean = (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a>);
    let generate_exception : boolean = (<a href="shared_pseudocode.html#func_AArch32_GenerateDebugExceptions_0" title="">AArch32_GenerateDebugExceptions</a>() &amp;&amp;
                                            DBGDSCRext().MDBGen == '1');
    let halt : boolean = <a href="shared_pseudocode.html#func_HaltOnBreakpointOrWatchpoint_0" title="">HaltOnBreakpointOrWatchpoint</a>();
    // Relative priority of Vector Catch and Breakpoint exceptions not defined in the architecture
    let vector_catch_first : boolean = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BPVECTORCATCHPRI" title="">Unpredictable_BPVECTORCATCHPRI</a>);

    if i_side &amp;&amp; vector_catch_first &amp;&amp; generate_exception then
        fault = <a href="shared_pseudocode.html#func_AArch32_CheckVectorCatch_3" title="">AArch32_CheckVectorCatch</a>(fault, vaddress, size);
    end;

    if fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> &amp;&amp; (generate_exception || halt) then
        if d_side then
            fault = <a href="shared_pseudocode.html#func_AArch32_CheckWatchpoint_4" title="">AArch32_CheckWatchpoint</a>(fault, vaddress, accdesc, size);
        elsif i_side then
            fault = <a href="shared_pseudocode.html#func_AArch32_CheckBreakpoint_4" title="">AArch32_CheckBreakpoint</a>(fault, vaddress, accdesc, size);
        end;
    end;

    if fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> &amp;&amp; i_side &amp;&amp; !vector_catch_first &amp;&amp; generate_exception then
        return <a href="shared_pseudocode.html#func_AArch32_CheckVectorCatch_3" title="">AArch32_CheckVectorCatch</a>(fault, vaddress, size);
    end;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.debug.AArch32_CheckVectorCatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/debug/AArch32_CheckVectorCatch</h3>
      <p class="pseudocode">// AArch32_CheckVectorCatch()
// ==========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch32
// translation regime, when debug exceptions are enabled.

func <a id="func_AArch32_CheckVectorCatch_3"/>AArch32_CheckVectorCatch(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, vaddress : bits(32),
                              size : integer) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    assert <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());

    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    var match : boolean = <a href="shared_pseudocode.html#func_AArch32_VCRMatch_1" title="">AArch32_VCRMatch</a>(vaddress);
    if size == 4 &amp;&amp; !match &amp;&amp; <a href="shared_pseudocode.html#func_AArch32_VCRMatch_1" title="">AArch32_VCRMatch</a>(vaddress + 2) then
        match = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_VCMATCHHALF" title="">Unpredictable_VCMATCHHALF</a>);
    end;

    if match then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Debug" title="">Fault_Debug</a>;
        fault.debugmoe   = <a href="shared_pseudocode.html#global_DebugException_VectorCatch" title="">DebugException_VectorCatch</a>;
    end;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.debug.AArch32_CheckWatchpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/debug/AArch32_CheckWatchpoint</h3>
      <p class="pseudocode">// AArch32_CheckWatchpoint()
// =========================
// Called before accessing the memory location of "size" bytes at "address",
// when either debug exceptions are enabled for the access, or halting debug
// is enabled and halting is allowed.

func <a id="func_AArch32_CheckWatchpoint_4"/>AArch32_CheckWatchpoint(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, vaddress : bits(32),
                             accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, size : integer) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    assert <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    var match : boolean = FALSE;

    if !<a href="shared_pseudocode.html#func_IsWatchpointableAccess_1" title="">IsWatchpointableAccess</a>(accdesc) then
        return fault;
    end;

    for i = 0 to <a href="shared_pseudocode.html#func_NumWatchpointsImplemented_0" title="">NumWatchpointsImplemented</a>() - 1 do
        let watchptinfo : <a href="shared_pseudocode.html#type_WatchpointInfo" title="">WatchpointInfo</a> = <a href="shared_pseudocode.html#func_AArch32_WatchpointMatch_4" title="">AArch32_WatchpointMatch</a>(i, vaddress, size, accdesc);
        match = match || watchptinfo.value_match;
    end;

    if match &amp;&amp; <a href="shared_pseudocode.html#func_HaltOnBreakpointOrWatchpoint_0" title="">HaltOnBreakpointOrWatchpoint</a>() then
        let reason : bits(6) = <a href="shared_pseudocode.html#global_DebugHalt_Watchpoint" title="">DebugHalt_Watchpoint</a>;
        EDWAR()  = ZeroExtend{64}(vaddress);
        Halt(reason);
    elsif match then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Debug" title="">Fault_Debug</a>;
        fault.debugmoe   = <a href="shared_pseudocode.html#global_DebugException_Watchpoint" title="">DebugException_Watchpoint</a>;
        fault.vaddress   = ZeroExtend{64}(vaddress);
    end;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32_IPAIsOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32_IPAIsOutOfRange</h3>
      <p class="pseudocode">// AArch32_IPAIsOutOfRange()
// =========================
// Check intermediate physical address bits not resolved by translation are ZERO

func <a id="func_AArch32_IPAIsOutOfRange_2"/>AArch32_IPAIsOutOfRange(walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>, ipa : bits(40)) =&gt; boolean
begin
    // Input Address size
    let iasize : integer{} = AArch32_S2IASize(walkparams.t0sz);

    return iasize &lt; 40 &amp;&amp; !IsZero(ipa[39:iasize]);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32_S1HasAlignmentFaultDueToMemType"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32_S1HasAlignmentFaultDueToMemType</h3>
      <p class="pseudocode">// AArch32_S1HasAlignmentFaultDueToMemType()
// =========================================
// Returns whether stage 1 output fails alignment requirement on data accesses to memory type

func <a id="func_AArch32_S1HasAlignmentFaultDueToMemType_4"/>AArch32_S1HasAlignmentFaultDueToMemType(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, aligned : boolean,
                                             ntlsmd : bit, memattrs : MemoryAttributes) =&gt; boolean
begin
    if memattrs.memtype != MemType_Device then
        return FALSE;
    elsif accdesc.a32lsmd &amp;&amp; ntlsmd == '0' then
        return memattrs.device != <a href="shared_pseudocode.html#enum_DeviceType_GRE" title="">DeviceType_GRE</a>;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_DCZero" title="">AccessType_DCZero</a> then
        return TRUE;
    elsif !aligned then
        return !(ImpDefBool("Device location supports unaligned access"));
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32_S1LDHasPermissionsFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32_S1LDHasPermissionsFault</h3>
      <p class="pseudocode">// AArch32_S1LDHasPermissionsFault()
// =================================
// Returns whether an access using stage 1 long-descriptor translation
// violates permissions of target memory

func AArch32_S1LDHasPermissionsFault(regime : Regime, walkparams : S1TTWParams,
                                     perms : Permissions, memtype : <a href="shared_pseudocode.html#MemType" title="type MemType">MemType</a>, paspace : PASpace,
                                     accdesc : AccessDescriptor) =&gt; boolean
begin
    var r,  w,  x : bit;
    var pr, pw : bit;
    var ur, uw : bit;
    var xn : bit;
    if HasUnprivileged(regime) then
        // Apply leaf permissions
        case perms.ap[2:1] of
            when '00' =&gt; (pr,pw,ur,uw) = ('1','1','0','0'); // R/W at PL1 only
            when '01' =&gt; (pr,pw,ur,uw) = ('1','1','1','1'); // R/W at any PL
            when '10' =&gt; (pr,pw,ur,uw) = ('1','0','0','0'); // RO at PL1 only
            when '11' =&gt; (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL
        end;

        // Apply hierarchical permissions
        case perms.ap_table of
            when '00' =&gt; (pr,pw,ur,uw) = ( pr, pw, ur, uw); // No effect
            when '01' =&gt; (pr,pw,ur,uw) = ( pr, pw,'0','0'); // Privileged access
            when '10' =&gt; (pr,pw,ur,uw) = ( pr,'0', ur,'0'); // Read-only
            when '11' =&gt; (pr,pw,ur,uw) = ( pr,'0','0','0'); // Read-only, privileged access
        end;

        xn   = perms.xn OR perms.xn_table;
        let pxn : bit  = perms.pxn OR perms.pxn_table;

        let ux : bit = ur AND NOT(xn OR (uw AND walkparams.wxn));
        let px : bit = pr AND NOT(xn OR pxn OR (pw AND walkparams.wxn) OR (uw AND walkparams.uwxn));

        if IsFeatureImplemented(FEAT_PAN) &amp;&amp; accdesc.pan then
            let pan : bit = PSTATE.PAN AND (ur OR uw);
            pr  = pr AND NOT(pan);
            pw  = pw AND NOT(pan);
        end;

        (r,w,x) = if accdesc.el == EL0 then (ur,uw,ux) else (pr,pw,px);

        // Prevent execution from Non-secure space by PE in Secure state if SIF is set
        if accdesc.ss == SS_Secure &amp;&amp; paspace == PAS_NonSecure then
            x = x AND NOT(walkparams.sif);
        end;
    else
        // Apply leaf permissions
        case perms.ap[2] of
            when '0' =&gt; (r,w) = ('1','1'); // No effect
            when '1' =&gt; (r,w) = ('1','0'); // Read-only
        end;

        // Apply hierarchical permissions
        case perms.ap_table[1] of
            when '0' =&gt; (r,w) = ( r, w );  // No effect
            when '1' =&gt; (r,w) = ( r, '0'); // Read-only
        end;

        xn = perms.xn OR perms.xn_table;
        x  = NOT(xn OR (w AND walkparams.wxn));
    end;

    if accdesc.acctype == AccessType_IFETCH then
        let constraint : Constraint = ConstrainUnpredictable(Unpredictable_INSTRDEVICE);
        if constraint == Constraint_FAULT &amp;&amp; memtype == MemType_Device then
            return TRUE;
        else
            return x == '0';
        end;
    elsif accdesc.acctype IN {AccessType_IC, AccessType_DC} then
        return FALSE;
    elsif accdesc.write then
        return w == '0';
    else
        return r == '0';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32_S1SDHasPermissionsFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32_S1SDHasPermissionsFault</h3>
      <p class="pseudocode">// AArch32_S1SDHasPermissionsFault()
// =================================
// Returns whether an access using stage 1 short-descriptor translation
// violates permissions of target memory

func AArch32_S1SDHasPermissionsFault(regime : Regime, perms_in : Permissions, memtype : <a href="shared_pseudocode.html#MemType" title="type MemType">MemType</a>,
                                     paspace : PASpace, accdesc : AccessDescriptor) =&gt; boolean
begin
    var perms : Permissions = perms_in;
    var pr, pw : bit;
    var ur, uw : bit;
    var sctlr : SCTLR_Type;
    if regime == Regime_EL30 then
        sctlr = SCTLR_S();
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        sctlr = SCTLR_NS();
    else
        sctlr = SCTLR();
    end;

    if sctlr.AFE == '0' then
        // Map Reserved encoding '100'
        if perms.ap == '100' then
            perms.ap = ImpDefBits{3}("Reserved short descriptor AP encoding");
        end;

        case perms.ap of
            when '000' =&gt; (pr,pw,ur,uw) = ('0','0','0','0'); // No access
            when '001' =&gt; (pr,pw,ur,uw) = ('1','1','0','0'); // R/W at PL1 only
            when '010' =&gt; (pr,pw,ur,uw) = ('1','1','1','0'); // R/W at PL1, RO at PL0
            when '011' =&gt; (pr,pw,ur,uw) = ('1','1','1','1'); // R/W at any PL
            //   '100' is reserved
            when '101' =&gt; (pr,pw,ur,uw) = ('1','0','0','0'); // RO at PL1 only
            when '110' =&gt; (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL (deprecated)
            when '111' =&gt; (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL
        end;
    else // Simplified access permissions model
        case perms.ap[2:1] of
            when '00' =&gt; (pr,pw,ur,uw) = ('1','1','0','0'); // R/W at PL1 only
            when '01' =&gt; (pr,pw,ur,uw) = ('1','1','1','1'); // R/W at any PL
            when '10' =&gt; (pr,pw,ur,uw) = ('1','0','0','0'); // RO at PL1 only
            when '11' =&gt; (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL
        end;
    end;

    let ux : bit = ur AND NOT(perms.xn OR (uw AND sctlr.WXN));
    let px : bit = pr AND NOT(perms.xn OR perms.pxn OR (pw AND sctlr.WXN) OR (uw AND sctlr.UWXN));

    if IsFeatureImplemented(FEAT_PAN) &amp;&amp; accdesc.pan then
        let pan : bit = PSTATE.PAN AND (ur OR uw);
        pr  = pr AND NOT(pan);
        pw  = pw AND NOT(pan);
    end;

    var (r,w,x) : (bit, bit, bit) = if accdesc.el == EL0 then (ur,uw,ux) else (pr,pw,px);

    // Prevent execution from Non-secure space by PE in Secure state if SIF is set
    if accdesc.ss == SS_Secure &amp;&amp; paspace == PAS_NonSecure then
        x = x AND NOT(if ELUsingAArch32(EL3) then SCR().SIF else SCR_EL3().SIF);
    end;
    if accdesc.acctype == AccessType_IFETCH then
        if (memtype == MemType_Device &amp;&amp;
              ConstrainUnpredictable(Unpredictable_INSTRDEVICE) == Constraint_FAULT) then
            return TRUE;
        else
            return x == '0';
        end;
    elsif accdesc.acctype IN {AccessType_IC, AccessType_DC} then
        return FALSE;
    elsif accdesc.write then
        return w == '0';
    else
        return r == '0';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32_S2HasAlignmentFaultDueToMemType"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32_S2HasAlignmentFaultDueToMemType</h3>
      <p class="pseudocode">// AArch32_S2HasAlignmentFaultDueToMemType()
// =========================================
// Returns whether stage 2 output fails alignment requirement on data accesses due to memory type

func <a id="func_AArch32_S2HasAlignmentFaultDueToMemType_3"/>AArch32_S2HasAlignmentFaultDueToMemType(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, aligned : boolean,
                                             memattrs : MemoryAttributes) =&gt; boolean
begin

    if memattrs.memtype != MemType_Device then
        return FALSE;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_DCZero" title="">AccessType_DCZero</a> then
        return TRUE;
    elsif !aligned then
        return !(ImpDefBool("Device location supports unaligned access"));
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32_S2HasPermissionsFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32_S2HasPermissionsFault</h3>
      <p class="pseudocode">// AArch32_S2HasPermissionsFault()
// ===============================
// Returns whether stage 2 access violates permissions of target memory

func AArch32_S2HasPermissionsFault(walkparams : S2TTWParams, perms : Permissions,
                                   memtype : <a href="shared_pseudocode.html#MemType" title="type MemType">MemType</a>, accdesc : AccessDescriptor) =&gt; boolean
begin
    let r : bit = perms.s2ap[0];
    let w : bit = perms.s2ap[1];
    var x : bit;
    var ux : bit;
    var px : bit;
    if IsFeatureImplemented(FEAT_XNX) then
        case perms.s2xn::perms.s2xnx of
            when '00' =&gt;  (px, ux) = ( r, r );
            when '01' =&gt;  (px, ux) = ('0', r );
            when '10' =&gt;  (px, ux) = ('0', '0');
            when '11' =&gt;  (px, ux) = ( r, '0');
        end;

        x = if accdesc.el == EL0 then ux else px;
    else
        x = r AND NOT(perms.s2xn);
    end;

    if accdesc.acctype == AccessType_TTW then
        return (walkparams.ptw == '1' &amp;&amp; memtype == MemType_Device) || r == '0';

    elsif accdesc.acctype == AccessType_IFETCH then
        let constraint : Constraint = ConstrainUnpredictable(Unpredictable_INSTRDEVICE);
        return (constraint == Constraint_FAULT &amp;&amp; memtype == MemType_Device) || x == '0';

    elsif accdesc.acctype IN {AccessType_IC, AccessType_DC} then
        return FALSE;

    elsif accdesc.write then
        return w == '0';

    else
        return r == '0';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32_S2InconsistentSL"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32_S2InconsistentSL</h3>
      <p class="pseudocode">// AArch32_S2InconsistentSL()
// ==========================
// Detect inconsistent configuration of stage 2 T0SZ and SL fields

func AArch32_S2InconsistentSL(walkparams : S2TTWParams) =&gt; boolean
begin
    let startlevel : integer      = AArch32_S2StartLevel(walkparams.sl0);
    let levels : integer          = FINAL_LEVEL - startlevel;
    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = TGxGranuleBits(walkparams.tgx);
    let stride : integer{}        = granulebits - 3;

    // Input address size must at least be large enough to be resolved from the start level
    let sl_min_iasize : integer = (
        levels * stride // Bits resolved by table walk, except initial level
        + granulebits   // Bits directly mapped to output address
        + 1);           // At least 1 more bit to be decoded by initial level

    // Can accomodate 1 more stride in the level + concatenation of up to 2^4 tables
    let sl_max_iasize : integer = sl_min_iasize + (stride-1) + 4;
    // Configured Input Address size
    let iasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>        = AArch32_S2IASize(walkparams.t0sz);

    return iasize &lt; sl_min_iasize || iasize &gt; sl_max_iasize;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32_VAIsOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32_VAIsOutOfRange</h3>
      <p class="pseudocode">// AArch32_VAIsOutOfRange()
// ========================
// Check virtual address bits not resolved by translation are identical
// and of accepted value

func <a id="func_AArch32_VAIsOutOfRange_3"/>AArch32_VAIsOutOfRange(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>, va : bits(32)) =&gt; boolean
begin
    if regime == <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> then
        // Input Address size
        let iasize : integer{} = AArch32_S1IASize(walkparams.t0sz);
        return walkparams.t0sz != '000' &amp;&amp; !IsZero(va[31:iasize]);
    elsif walkparams.t1sz != '000' &amp;&amp; walkparams.t0sz != '000' then
        // Lower range Input Address size
        let lo_iasize : integer{} = AArch32_S1IASize(walkparams.t0sz);
        // Upper range Input Address size
        let up_iasize : integer{} = AArch32_S1IASize(walkparams.t1sz);
        return !IsZero(va[31:lo_iasize]) &amp;&amp; !IsOnes(va[31:up_iasize]);
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32_GetS1TLBContext"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32_GetS1TLBContext</h3>
      <p class="pseudocode">// AArch32_GetS1TLBContext()
// =========================
// Gather translation context for accesses with VA to match against TLB entries

func <a id="func_AArch32_GetS1TLBContext_3"/>AArch32_GetS1TLBContext(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, va : bits(32)) =&gt; <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>
begin
    var tlbcontext : <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>;

    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>  =&gt; tlbcontext = <a href="shared_pseudocode.html#func_AArch32_TLBContextEL2_1" title="">AArch32_TLBContextEL2</a>(va);
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; tlbcontext = <a href="shared_pseudocode.html#func_AArch32_TLBContextEL10_2" title="">AArch32_TLBContextEL10</a>(ss, va);
        when <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> =&gt; tlbcontext = <a href="shared_pseudocode.html#func_AArch32_TLBContextEL30_1" title="">AArch32_TLBContextEL30</a>(va);
    end;

    tlbcontext.includes_s1 = TRUE;
    // The following may be amended for EL1&amp;0 Regime if caching of stage 2 is successful
    tlbcontext.includes_s2 = FALSE;
    return tlbcontext;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32_GetS2TLBContext"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32_GetS2TLBContext</h3>
      <p class="pseudocode">// AArch32_GetS2TLBContext()
// =========================
// Gather translation context for accesses with IPA to match against TLB entries

func <a id="func_AArch32_GetS2TLBContext_1"/>AArch32_GetS2TLBContext(ipa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>) =&gt; <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>
begin
    assert ipa.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;

    var tlbcontext : <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>;

    tlbcontext.ss          = <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;
    tlbcontext.regime      = <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>;
    tlbcontext.ipaspace    = ipa.paspace;
    tlbcontext.vmid        = ZeroExtend{16}(VTTBR().VMID);
    tlbcontext.tg          = <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
    tlbcontext.includes_s1 = FALSE;
    tlbcontext.includes_s2 = TRUE;
    tlbcontext.ia          = ZeroExtend{64}(ipa.address);
    tlbcontext.cnp         = if IsFeatureImplemented(FEAT_TTCNP) then VTTBR().CnP else '0';

    return tlbcontext;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32_TLBContextEL10"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32_TLBContextEL10</h3>
      <p class="pseudocode">// AArch32_TLBContextEL10()
// ========================
// Gather translation context for accesses under EL10 regime
// (PL10 when EL3 is A64) to match against TLB entries

func <a id="func_AArch32_TLBContextEL10_2"/>AArch32_TLBContextEL10(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, va : bits(32)) =&gt; <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>
begin
    var tlbcontext : <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>;
    var ttbcr : TTBCR_Type;
    var ttbr0 : TTBR0_Type;
    var ttbr1 : TTBR1_Type;
    var contextidr : CONTEXTIDR_Type;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        ttbcr      = TTBCR_NS();
        ttbr0      = TTBR0_NS();
        ttbr1      = TTBR1_NS();
        contextidr = CONTEXTIDR_NS();
    else
        ttbcr      = TTBCR();
        ttbr0      = TTBR0();
        ttbr1      = TTBR1();
        contextidr = CONTEXTIDR();
    end;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>;

    if <a href="shared_pseudocode.html#func_AArch32_EL2Enabled_1" title="">AArch32_EL2Enabled</a>(ss) then
        tlbcontext.vmid = ZeroExtend{16}(VTTBR().VMID);
    end;

    if ttbcr.EAE == '1' then
        tlbcontext.asid = ZeroExtend{16}(if ttbcr.A1 == '0' then ttbr0.ASID else ttbr1.ASID);
    else
        tlbcontext.asid = ZeroExtend{16}(contextidr.ASID);
    end;

    tlbcontext.tg = <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
    tlbcontext.ia = ZeroExtend{64}(va);

    if IsFeatureImplemented(FEAT_TTCNP) &amp;&amp; ttbcr.EAE == '1' then
        if AArch32_GetVARange(va, ttbcr.T0SZ, ttbcr.T1SZ) == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then
            tlbcontext.cnp = ttbr0.CnP;
        else
            tlbcontext.cnp = ttbr1.CnP;
        end;
    else
        tlbcontext.cnp = '0';
    end;

    return tlbcontext;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32_TLBContextEL2"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32_TLBContextEL2</h3>
      <p class="pseudocode">// AArch32_TLBContextEL2()
// =======================
// Gather translation context for accesses under EL2 regime to match against TLB entries

func <a id="func_AArch32_TLBContextEL2_1"/>AArch32_TLBContextEL2(va : bits(32)) =&gt; <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>
begin
    var tlbcontext : <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>;

    tlbcontext.ss     = <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;
    tlbcontext.regime = <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>;
    tlbcontext.ia     = ZeroExtend{64}(va);
    tlbcontext.tg     = <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
    tlbcontext.cnp    = if IsFeatureImplemented(FEAT_TTCNP) then HTTBR().CnP else '0';

    return tlbcontext;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32_TLBContextEL30"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32_TLBContextEL30</h3>
      <p class="pseudocode">// AArch32_TLBContextEL30()
// ========================
// Gather translation context for accesses under EL30 regime
// (PL10 in Secure state and EL3 is A32) to match against TLB entries

func <a id="func_AArch32_TLBContextEL30_1"/>AArch32_TLBContextEL30(va : bits(32)) =&gt; <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>
begin
    var tlbcontext : <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>;

    tlbcontext.ss     = <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
    tlbcontext.regime = <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a>;

    if TTBCR_S().EAE == '1' then
        tlbcontext.asid = ZeroExtend{16}(if TTBCR_S().A1 == '0' then TTBR0_S().ASID
                                                                      else TTBR1_S().ASID);
    else
        tlbcontext.asid = ZeroExtend{16}(CONTEXTIDR_S().ASID);
    end;

    tlbcontext.tg = <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
    tlbcontext.ia = ZeroExtend{64}(va);

    if IsFeatureImplemented(FEAT_TTCNP) &amp;&amp; TTBCR_S().EAE == '1' then
        if AArch32_GetVARange(va, TTBCR_S().T0SZ, TTBCR_S().T1SZ) == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then
            tlbcontext.cnp = TTBR0_S().CnP;
        else
            tlbcontext.cnp = TTBR1_S().CnP;
        end;
    else
        tlbcontext.cnp = '0';
    end;

    return tlbcontext;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32_EL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32_EL2Enabled</h3>
      <p class="pseudocode">// AArch32_EL2Enabled()
// ====================
// Returns whether EL2 is enabled for the given Security State

func <a id="func_AArch32_EL2Enabled_1"/>AArch32_EL2Enabled(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>) =&gt; boolean
begin
    if ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
        if !(<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; IsFeatureImplemented(FEAT_SEL2)) then
            return FALSE;
        elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            return SCR_EL3().EEL2 == '1';
        else
            return ImpDefBool("Secure-only implementation");
        end;
    else
        return <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32_FullTranslate"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32_FullTranslate</h3>
      <p class="pseudocode">// AArch32_FullTranslate()
// =======================
// Perform address translation as specified by VMSA-A32

func <a id="func_AArch32_FullTranslate_3"/>AArch32_FullTranslate(va : bits(32), accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                           aligned : boolean) =&gt; <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>
begin

    // Prepare fault fields in case a fault is detected
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, ZeroExtend{64}(va));
    let regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a> = <a href="shared_pseudocode.html#func_TranslationRegime_1" title="">TranslationRegime</a>(accdesc.el);

    // First Stage Translation
    var ipa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    if regime == <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> || TTBCR().EAE == '1' then
        (fault, ipa)    = <a href="shared_pseudocode.html#func_AArch32_S1TranslateLD_5" title="">AArch32_S1TranslateLD</a>(fault, regime, va, aligned, accdesc);
    else
        (fault, ipa, -) = <a href="shared_pseudocode.html#func_AArch32_S1TranslateSD_5" title="">AArch32_S1TranslateSD</a>(fault, regime, va, aligned, accdesc);
    end;

    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return <a href="shared_pseudocode.html#func_CreateFaultyAddressDescriptor_1" title="">CreateFaultyAddressDescriptor</a>(fault);
    end;

    if regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        ipa.vaddress = ZeroExtend{64}(va);
        var pa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
        (fault, pa) = <a href="shared_pseudocode.html#func_AArch32_S2Translate_4" title="">AArch32_S2Translate</a>(fault, ipa, aligned, accdesc);

        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            return <a href="shared_pseudocode.html#func_CreateFaultyAddressDescriptor_1" title="">CreateFaultyAddressDescriptor</a>(fault);
        else
            return pa;
        end;
    else
        return ipa;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32_OutputDomain"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32_OutputDomain</h3>
      <p class="pseudocode">// AArch32_OutputDomain()
// ======================
// Determine the domain the translated output address

func <a id="func_AArch32_OutputDomain_2"/>AArch32_OutputDomain(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, domain : bits(4)) =&gt; bits(2)
begin
    var Dn : bits(2);
    if regime == <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> then
        Dn = DACR_S()[UInt(domain)*:2];
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        Dn = DACR_NS()[UInt(domain)*:2];
    else
        Dn = DACR()[UInt(domain)*:2];
    end;

    if Dn == '10' then
        // Reserved value maps to an allocated value
        (-, Dn) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_RESDACR" title="">Unpredictable_RESDACR</a>);
    end;

    return Dn;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32_S1DisabledOutput"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32_S1DisabledOutput</h3>
      <p class="pseudocode">// AArch32_S1DisabledOutput()
// ==========================
// Flat map the VA to IPA/PA, depending on the regime, assigning default memory attributes

func <a id="func_AArch32_S1DisabledOutput_5"/>AArch32_S1DisabledOutput(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                              va : bits(32), aligned : boolean,
                              accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; (<a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>)
begin

    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    // No memory page is guarded when stage 1 address translation is disabled
    SetInGuardedPage(FALSE);

    var memattrs : MemoryAttributes;
    var default_cacheable : bit;
    if regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_AArch32_EL2Enabled_1" title="">AArch32_EL2Enabled</a>(accdesc.ss) then
        if <a href="shared_pseudocode.html#func_ELStateUsingAArch32_2" title="">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>) then
            default_cacheable = HCR().DC;
        else
            default_cacheable = HCR_EL2().DC;
        end;
    else
        default_cacheable = '0';
    end;

    if default_cacheable == '1' then
        // Use default cacheable settings
        memattrs.memtype      = MemType_Normal;
        memattrs.inner.attrs  = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;
        memattrs.inner.hints  = <a href="shared_pseudocode.html#global_MemHint_RWA" title="">MemHint_RWA</a>;
        memattrs.outer.attrs  = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;
        memattrs.outer.hints  = <a href="shared_pseudocode.html#global_MemHint_RWA" title="">MemHint_RWA</a>;
        memattrs.shareability = <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a>;
        if (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELStateUsingAArch32_2" title="">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>) &amp;&amp;
              IsFeatureImplemented(FEAT_MTE2) &amp;&amp; HCR_EL2().DCT == '1') then
            memattrs.tags     = <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a>;
        else
            memattrs.tags     = <a href="shared_pseudocode.html#enum_MemTag_Untagged" title="">MemTag_Untagged</a>;
        end;
        memattrs.xs           = '0';
    elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> then
        memattrs.memtype      = MemType_Normal;
        memattrs.shareability = <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
        memattrs.tags         = <a href="shared_pseudocode.html#enum_MemTag_Untagged" title="">MemTag_Untagged</a>;
        if <a href="shared_pseudocode.html#func_AArch32_S1ICacheEnabled_1" title="">AArch32_S1ICacheEnabled</a>(regime) then
            memattrs.inner.attrs = <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a>;
            memattrs.inner.hints = <a href="shared_pseudocode.html#global_MemHint_RA" title="">MemHint_RA</a>;
            memattrs.outer.attrs = <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a>;
            memattrs.outer.hints = <a href="shared_pseudocode.html#global_MemHint_RA" title="">MemHint_RA</a>;
        else
            memattrs.inner.attrs = <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>;
            memattrs.outer.attrs = <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>;
        end;
        memattrs.xs           = '1';
    else
        // Treat memory region as Device
        memattrs.memtype      = MemType_Device;
        memattrs.device       = <a href="shared_pseudocode.html#enum_DeviceType_nGnRnE" title="">DeviceType_nGnRnE</a>;
        memattrs.shareability = <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
        memattrs.tags         = <a href="shared_pseudocode.html#enum_MemTag_Untagged" title="">MemTag_Untagged</a>;
        memattrs.xs           = '1';
    end;

    var ntlsmd : bit;
    if IsFeatureImplemented(FEAT_LSMAOC) then
        case regime of
            when <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> =&gt; ntlsmd = SCTLR_S().nTLSMD;
            when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>  =&gt; ntlsmd = HSCTLR().nTLSMD;
            when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;
                if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
                    ntlsmd = SCTLR_NS().nTLSMD;
                else
                    ntlsmd = SCTLR().nTLSMD;
                end;
        end;
    else
        ntlsmd = '1';
    end;

    if <a href="shared_pseudocode.html#func_AArch32_S1HasAlignmentFaultDueToMemType_4" title="">AArch32_S1HasAlignmentFaultDueToMemType</a>(accdesc, aligned, ntlsmd, memattrs) then
        fault.statuscode  = <a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a>;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    elsif (accdesc.exclusive &amp;&amp;
            !(regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
               ((!<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; HCR_EL2().DC == '1') ||
                  (<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; HCR().DC == '1'))) &amp;&amp;
            <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_Atomic_MMU_IMPDEF_FAULT" title="">Unpredictable_Atomic_MMU_IMPDEF_FAULT</a>)) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a>;
    end;

    var oa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;
    oa.address = ZeroExtend{56}(va);
    oa.paspace = if accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> else <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
    let ipa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAddressDescriptor_4" title="">CreateAddressDescriptor</a>(ZeroExtend{64}(va),
                                                          oa, memattrs, accdesc);

    return (fault, ipa);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32_S1Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32_S1Enabled</h3>
      <p class="pseudocode">// AArch32_S1Enabled()
// ===================
// Returns whether stage 1 translation is enabled for the active translation regime

func <a id="func_AArch32_S1Enabled_2"/>AArch32_S1Enabled(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>) =&gt; boolean
begin
    if regime == <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> then
        return HSCTLR().M == '1';
    elsif regime == <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> then
        return SCTLR_S().M == '1';
    elsif !<a href="shared_pseudocode.html#func_AArch32_EL2Enabled_1" title="">AArch32_EL2Enabled</a>(ss) then
        return (if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then SCTLR_NS().M else SCTLR().M) == '1';
    elsif <a href="shared_pseudocode.html#func_ELStateUsingAArch32_2" title="">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>) then
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            return HCR().[TGE,DC] == '00' &amp;&amp; SCTLR_NS().M == '1';
        else
            return HCR().[TGE,DC] == '00' &amp;&amp; SCTLR().M == '1';
        end;
    else
        return <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().[TGE,DC] == '00' &amp;&amp; SCTLR().M == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32_S1TranslateLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32_S1TranslateLD</h3>
      <p class="pseudocode">// AArch32_S1TranslateLD()
// =======================
// Perform a stage 1 translation using long-descriptor format mapping VA to IPA/PA
// depending on the regime

func <a id="func_AArch32_S1TranslateLD_5"/>AArch32_S1TranslateLD(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                           va : bits(32), aligned : boolean,
                           accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; (<a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>)
begin
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;

    if !<a href="shared_pseudocode.html#func_AArch32_S1Enabled_2" title="">AArch32_S1Enabled</a>(regime, accdesc.ss) then
        return <a href="shared_pseudocode.html#func_AArch32_S1DisabledOutput_5" title="">AArch32_S1DisabledOutput</a>(fault, regime, va, aligned, accdesc);
    end;

    let walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a> = <a href="shared_pseudocode.html#func_AArch32_GetS1TTWParams_2" title="">AArch32_GetS1TTWParams</a>(regime, va);

    if <a href="shared_pseudocode.html#func_AArch32_VAIsOutOfRange_3" title="">AArch32_VAIsOutOfRange</a>(regime, walkparams, va) then
        fault.level      = 1;
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    var walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    (fault, walkstate) = AArch32_S1WalkLD(fault, regime, walkparams, accdesc, va);

    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    SetInGuardedPage(FALSE);  // AArch32-VMSA does not guard any pages

    if <a href="shared_pseudocode.html#func_AArch32_S1HasAlignmentFaultDueToMemType_4" title="">AArch32_S1HasAlignmentFaultDueToMemType</a>(accdesc, aligned, walkparams.ntlsmd,
                                               walkstate.memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a>;
    elsif AArch32_S1LDHasPermissionsFault(regime, walkparams,
                                          walkstate.permissions,
                                          walkstate.memattrs.memtype,
                                          walkstate.baseaddress.paspace,
                                          accdesc) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
    end;

    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    var memattrs : MemoryAttributes;
    if ((accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == MemType_Device || !<a href="shared_pseudocode.html#func_AArch32_S1ICacheEnabled_1" title="">AArch32_S1ICacheEnabled</a>(regime))) ||
        (accdesc.acctype != <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == MemType_Normal &amp;&amp; !<a href="shared_pseudocode.html#func_AArch32_S1DCacheEnabled_1" title="">AArch32_S1DCacheEnabled</a>(regime))) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a href="shared_pseudocode.html#func_NormalNCMemAttr_0" title="">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;
    else
        memattrs = walkstate.memattrs;
    end;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_AArch32_EL2Enabled_1" title="">AArch32_EL2Enabled</a>(accdesc.ss) &amp;&amp;
        (if <a href="shared_pseudocode.html#func_ELStateUsingAArch32_2" title="">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, accdesc.ss==<a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>) then HCR().VM
                                                            else HCR_EL2().VM) == '1' &amp;&amp;
        !(ImpDefBool("Apply effective shareability at stage 1"))) then
        memattrs.shareability = walkstate.memattrs.shareability;
    else
        memattrs.shareability = <a href="shared_pseudocode.html#func_EffectiveShareability_1" title="">EffectiveShareability</a>(memattrs);
    end;

    // Output Address
    let oa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a> = StageOA(ZeroExtend{64}(va), walkparams.d128, walkparams.tgx, walkstate);
    let ipa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAddressDescriptor_4" title="">CreateAddressDescriptor</a>(ZeroExtend{64}(va),
                                                          oa, memattrs, accdesc);

    return (fault, ipa);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32_S1TranslateSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32_S1TranslateSD</h3>
      <p class="pseudocode">// AArch32_S1TranslateSD()
// =======================
// Perform a stage 1 translation using short-descriptor format mapping VA to IPA/PA
// depending on the regime

func <a id="func_AArch32_S1TranslateSD_5"/>AArch32_S1TranslateSD(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                           va : bits(32), aligned : boolean,
                           accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; (<a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, <a href="shared_pseudocode.html#type_SDFType" title="">SDFType</a>)
begin

    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;

    if !<a href="shared_pseudocode.html#func_AArch32_S1Enabled_2" title="">AArch32_S1Enabled</a>(regime, accdesc.ss) then
        var ipa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
        (fault, ipa) = <a href="shared_pseudocode.html#func_AArch32_S1DisabledOutput_5" title="">AArch32_S1DisabledOutput</a>(fault, regime, va, aligned, accdesc);
        return (fault, ipa, ARBITRARY : <a href="shared_pseudocode.html#type_SDFType" title="">SDFType</a>);
    end;

    var walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    (fault, walkstate) = <a href="shared_pseudocode.html#func_AArch32_S1WalkSD_4" title="">AArch32_S1WalkSD</a>(fault, regime, accdesc, va);

    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_SDFType" title="">SDFType</a>);
    end;

    let domain : bits(2) = <a href="shared_pseudocode.html#func_AArch32_OutputDomain_2" title="">AArch32_OutputDomain</a>(regime, walkstate.domain);
    SetInGuardedPage(FALSE);  // AArch32-VMSA does not guard any pages

    var ntlsmd : bit;
    if IsFeatureImplemented(FEAT_LSMAOC) then
        case regime of
            when <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> =&gt; ntlsmd = SCTLR_S().nTLSMD;
            when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;
                if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
                    ntlsmd = SCTLR_NS().nTLSMD;
                else
                    ntlsmd = SCTLR().nTLSMD;
                end;
        end;
    else
        ntlsmd = '1';
    end;

    if <a href="shared_pseudocode.html#func_AArch32_S1HasAlignmentFaultDueToMemType_4" title="">AArch32_S1HasAlignmentFaultDueToMemType</a>(accdesc, aligned, ntlsmd, walkstate.memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a>;
    elsif (! accdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>, <a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>} &amp;&amp;
           domain == <a href="shared_pseudocode.html#global_Domain_NoAccess" title="">Domain_NoAccess</a>) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Domain" title="">Fault_Domain</a>;
    elsif domain == <a href="shared_pseudocode.html#global_Domain_Client" title="">Domain_Client</a> then
        if AArch32_S1SDHasPermissionsFault(regime, walkstate.permissions,
                                           walkstate.memattrs.memtype,
                                           walkstate.baseaddress.paspace,
                                           accdesc) then
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
        end;
    end;

    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        fault.domain = walkstate.domain;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, walkstate.sdftype);
    end;

    var memattrs : MemoryAttributes;
    if ((accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == MemType_Device || !<a href="shared_pseudocode.html#func_AArch32_S1ICacheEnabled_1" title="">AArch32_S1ICacheEnabled</a>(regime))) ||
        (accdesc.acctype != <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == MemType_Normal &amp;&amp; !<a href="shared_pseudocode.html#func_AArch32_S1DCacheEnabled_1" title="">AArch32_S1DCacheEnabled</a>(regime))) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a href="shared_pseudocode.html#func_NormalNCMemAttr_0" title="">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;
    else
        memattrs = walkstate.memattrs;
    end;
    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_AArch32_EL2Enabled_1" title="">AArch32_EL2Enabled</a>(accdesc.ss) &amp;&amp;
        (if <a href="shared_pseudocode.html#func_ELStateUsingAArch32_2" title="">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, accdesc.ss==<a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>) then HCR().VM
                                                            else HCR_EL2().VM) == '1' &amp;&amp;
        !(ImpDefBool("Apply effective shareability at stage 1"))) then
        memattrs.shareability = walkstate.memattrs.shareability;
    else
        memattrs.shareability = <a href="shared_pseudocode.html#func_EffectiveShareability_1" title="">EffectiveShareability</a>(memattrs);
    end;
    // Output Address
    let oa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a> = <a href="shared_pseudocode.html#func_AArch32_SDStageOA_3" title="">AArch32_SDStageOA</a>(walkstate.baseaddress, va, walkstate.sdftype);
    let ipa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAddressDescriptor_4" title="">CreateAddressDescriptor</a>(ZeroExtend{64}(va),
                                                          oa, memattrs, accdesc);

    return (fault, ipa, walkstate.sdftype);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32_S2Translate"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32_S2Translate</h3>
      <p class="pseudocode">// AArch32_S2Translate()
// =====================
// Perform a stage 2 translation mapping an IPA to a PA

func <a id="func_AArch32_S2Translate_4"/>AArch32_S2Translate(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, ipa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                         aligned : boolean, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
                        ) =&gt; (<a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>)
begin

    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    assert IsZero(ipa.paddress.address[55:40]);
    if !<a href="shared_pseudocode.html#func_ELStateUsingAArch32_2" title="">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>) then
        let s1aarch64 : boolean = FALSE;
        return <a href="shared_pseudocode.html#func_AArch64_S2Translate_5" title="">AArch64_S2Translate</a>(fault, ipa, s1aarch64, aligned, accdesc);
    end;
    // Prepare fault fields in case a fault is detected
    fault.statuscode  = <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
    fault.secondstage = TRUE;
    fault.s2fs1walk   = accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_TTW" title="">AccessType_TTW</a>;
    fault.ipaddress   = ipa.paddress;

    let walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a> = <a href="shared_pseudocode.html#func_AArch32_GetS2TTWParams_0" title="">AArch32_GetS2TTWParams</a>();

    if walkparams.vm == '0' then
        // Stage 2 is disabled
        return (fault, ipa);
    end;

    if <a href="shared_pseudocode.html#func_AArch32_IPAIsOutOfRange_2" title="">AArch32_IPAIsOutOfRange</a>(walkparams, ipa.paddress.address[39:0]) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        fault.level      = 1;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    var walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    (fault, walkstate) = AArch32_S2Walk(fault, walkparams, accdesc, ipa);

    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    if <a href="shared_pseudocode.html#func_AArch32_S2HasAlignmentFaultDueToMemType_3" title="">AArch32_S2HasAlignmentFaultDueToMemType</a>(accdesc, aligned, walkstate.memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a>;
    elsif AArch32_S2HasPermissionsFault(walkparams,
                                        walkstate.permissions,
                                        walkstate.memattrs.memtype,
                                        accdesc) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
    end;
    var s2_memattrs : MemoryAttributes;
    if ((accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_TTW" title="">AccessType_TTW</a> &amp;&amp;
             walkstate.memattrs.memtype == MemType_Device) ||
        (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == MemType_Device || HCR2().ID == '1')) ||
        (accdesc.acctype != <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == MemType_Normal &amp;&amp; HCR2().CD == '1')) then
        // Treat memory attributes as Normal Non-Cacheable
        s2_memattrs = <a href="shared_pseudocode.html#func_NormalNCMemAttr_0" title="">NormalNCMemAttr</a>();
        s2_memattrs.xs = walkstate.memattrs.xs;
    else
        s2_memattrs = walkstate.memattrs;
    end;

    let s2aarch64 : boolean = FALSE;
    let memattrs : MemoryAttributes = <a href="shared_pseudocode.html#func_S2CombineS1MemAttrs_3" title="">S2CombineS1MemAttrs</a>(ipa.memattrs, s2_memattrs, s2aarch64);
    let ipa_64 : bits(64) = ZeroExtend{}(ipa.paddress.address[39:0]);
    // Output Address
    let oa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a> = StageOA(ipa_64, walkparams.d128, walkparams.tgx, walkstate);
    let pa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAddressDescriptor_4" title="">CreateAddressDescriptor</a>(ipa.vaddress, oa, memattrs, accdesc);

    return (fault, pa);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32_SDStageOA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32_SDStageOA</h3>
      <p class="pseudocode">// AArch32_SDStageOA()
// ===================
// Given the final walk state of a short-descriptor translation walk,
// map the untranslated input address bits to the base output address

func <a id="func_AArch32_SDStageOA_3"/>AArch32_SDStageOA(baseaddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>, va : bits(32), sdftype : <a href="shared_pseudocode.html#type_SDFType" title="">SDFType</a>) =&gt; <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>
begin
    let tsize : integer{} = SDFSize(sdftype);

    // Output Address
    var oa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;
    oa.address = baseaddress.address[55:tsize] :: va[tsize-1:0];
    oa.paspace = baseaddress.paspace;
    return oa;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32_TranslateAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32_TranslateAddress</h3>
      <p class="pseudocode">// AArch32_TranslateAddress()
// ==========================
// Main entry point for translating an address

func <a id="func_AArch32_TranslateAddress_4"/>AArch32_TranslateAddress(va : bits(32), accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                              aligned : boolean, size : integer) =&gt; <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>
begin

    let regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a> = <a href="shared_pseudocode.html#func_TranslationRegime_1" title="">TranslationRegime</a>(PSTATE.EL);
    if !<a href="shared_pseudocode.html#func_RegimeUsingAArch32_1" title="">RegimeUsingAArch32</a>(regime) then
        return <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(ZeroExtend{64}(va), accdesc, aligned, size);
    end;

    var result : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch32_FullTranslate_3" title="">AArch32_FullTranslate</a>(va, accdesc, aligned);

    if !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(result) &amp;&amp; accdesc.acctype != <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> then
        // For an instruction fetch, CheckDebug will be called
        // after the instruction is read from memory
        result.fault = <a href="shared_pseudocode.html#func_AArch32_CheckDebug_3" title="">AArch32_CheckDebug</a>(va, accdesc, size);
    end;

    // Update virtual address for abort functions
    result.vaddress = ZeroExtend{64}(va);

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.SDFSize"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/SDFSize</h3>
      <p class="pseudocode">// SDFSize()
// =========
// Returns the short-descriptor format translation granule size

func SDFSize(sdftype : SDFType) =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    case sdftype of
        when SDFType_SmallPage =&gt;    return 12;
        when SDFType_LargePage =&gt;    return 16;
        when SDFType_Section =&gt;      return 20;
        when SDFType_Supersection =&gt; return 24;
        otherwise =&gt; unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32_DecodeDescriptorTypeLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32_DecodeDescriptorTypeLD</h3>
      <p class="pseudocode">// AArch32_DecodeDescriptorTypeLD()
// ================================
// Determine whether the long-descriptor is a page, block or table

func <a id="func_AArch32_DecodeDescriptorTypeLD_2"/>AArch32_DecodeDescriptorTypeLD(descriptor : bits(64), level : integer) =&gt; <a href="shared_pseudocode.html#type_DescriptorType" title="">DescriptorType</a>
begin
    if descriptor[1:0] == '11' &amp;&amp; level == <a href="shared_pseudocode.html#global_FINAL_LEVEL" title="">FINAL_LEVEL</a> then
        return <a href="shared_pseudocode.html#enum_DescriptorType_Leaf" title="">DescriptorType_Leaf</a>;
    elsif descriptor[1:0] == '11' then
        return <a href="shared_pseudocode.html#enum_DescriptorType_Table" title="">DescriptorType_Table</a>;
    elsif descriptor[1:0] == '01' &amp;&amp; level != <a href="shared_pseudocode.html#global_FINAL_LEVEL" title="">FINAL_LEVEL</a> then
        return <a href="shared_pseudocode.html#enum_DescriptorType_Leaf" title="">DescriptorType_Leaf</a>;
    else
        return <a href="shared_pseudocode.html#enum_DescriptorType_Invalid" title="">DescriptorType_Invalid</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32_DecodeDescriptorTypeSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32_DecodeDescriptorTypeSD</h3>
      <p class="pseudocode">// AArch32_DecodeDescriptorTypeSD()
// ================================
// Determine the type of the short-descriptor

func <a id="func_AArch32_DecodeDescriptorTypeSD_2"/>AArch32_DecodeDescriptorTypeSD(descriptor : bits(32), level : integer) =&gt; <a href="shared_pseudocode.html#type_SDFType" title="">SDFType</a>
begin
    if level == 1 &amp;&amp; descriptor[1:0] == '01' then
        return <a href="shared_pseudocode.html#enum_SDFType_Table" title="">SDFType_Table</a>;
    elsif level == 1 &amp;&amp; descriptor[18,1] == '01' then
        return <a href="shared_pseudocode.html#enum_SDFType_Section" title="">SDFType_Section</a>;
    elsif level == 1 &amp;&amp; descriptor[18,1] == '11' then
        return <a href="shared_pseudocode.html#enum_SDFType_Supersection" title="">SDFType_Supersection</a>;
    elsif level == 2 &amp;&amp; descriptor[1:0] == '01' then
        return <a href="shared_pseudocode.html#enum_SDFType_LargePage" title="">SDFType_LargePage</a>;
    elsif level == 2 &amp;&amp; descriptor[1:0] == '1x' then
        return <a href="shared_pseudocode.html#enum_SDFType_SmallPage" title="">SDFType_SmallPage</a>;
    else
        return <a href="shared_pseudocode.html#enum_SDFType_Invalid" title="">SDFType_Invalid</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32_S1IASize"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32_S1IASize</h3>
      <p class="pseudocode">// AArch32_S1IASize()
// ==================
// Retrieve the number of bits containing the input address for stage 1 translation

func AArch32_S1IASize(txsz : bits(3)) =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    return 32 - UInt(txsz);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32_S1WalkLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32_S1WalkLD</h3>
      <p class="pseudocode">// AArch32_S1WalkLD()
// ==================
// Traverse stage 1 translation tables in long format to obtain the final descriptor

func AArch32_S1WalkLD(fault_in : FaultRecord, regime : Regime,
                      walkparams : S1TTWParams, accdesc : AccessDescriptor,
                      va : bits(32)) =&gt; (FaultRecord, TTWState)
begin
    var fault : FaultRecord = fault_in;
    var txsz : bits(3);
    var ttbr : bits(64);
    var epd : bit;
    var varange : VARange;
    if regime == Regime_EL2 then
        ttbr = HTTBR();
        txsz = walkparams.t0sz;
        varange = VARange_LOWER;
    else
        varange = AArch32_GetVARange(va, walkparams.t0sz, walkparams.t1sz);
        var ttbr0 : bits(64);
        var ttbr1 : bits(64);
        var ttbcr : TTBCR_Type;
        if regime == Regime_EL30 then
            ttbcr = TTBCR_S();
            ttbr0 = TTBR0_S();
            ttbr1 = TTBR1_S();
        elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
            ttbcr = TTBCR_NS();
            ttbr0 = TTBR0_NS();
            ttbr1 = TTBR1_NS();
        else
            ttbcr = TTBCR();
            ttbr0 = TTBR0();
            ttbr1 = TTBR1();
        end;

        assert ttbcr.EAE == '1';
        if varange == VARange_LOWER then
            txsz = walkparams.t0sz;
            ttbr = ttbr0;
            epd  = ttbcr.EPD0;
        else
            txsz = walkparams.t1sz;
            ttbr = ttbr1;
            epd  = ttbcr.EPD1;
        end;
    end;

    if regime != Regime_EL2 &amp;&amp; epd == '1' then
        fault.level      = 1;
        fault.statuscode = Fault_Translation;
        return (fault, ARBITRARY : TTWState);
    end;

    // Input Address size
    let iasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>      = AArch32_S1IASize(txsz);
    let granulebits : integer{} = TGxGranuleBits(walkparams.tgx) as integer{12, 14, 16};
    let stride : integer{}      = granulebits - 3;
    let startlevel : integer  = FINAL_LEVEL - (((iasize-1) - granulebits) DIVRM stride);
    let levels : integer      = FINAL_LEVEL - startlevel;

    if !IsZero(ttbr[47:40]) then
        fault.statuscode = Fault_AddressSize;
        fault.level      = 0;
        return (fault, ARBITRARY : TTWState);
    end;

    var baseaddress : FullAddress;
    let baselsb = ((iasize - (levels*stride + granulebits)) + 3) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    baseaddress.paspace = if accdesc.ss == SS_Secure then PAS_Secure else PAS_NonSecure;
    baseaddress.address = ZeroExtend{56}(ttbr[39:baselsb]::Zeros{baselsb});

    var walkstate : TTWState;
    walkstate.baseaddress = baseaddress;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    // In regimes that support global and non-global translations, translation
    // table entries from lookup levels other than the final level of lookup
    // are treated as being non-global
    walkstate.nG          = if HasUnprivileged(regime) then '1' else '0';
    walkstate.memattrs    = WalkMemAttrs(walkparams.sh, walkparams.irgn, walkparams.orgn);
    walkstate.permissions.ap_table  = '00';
    walkstate.permissions.xn_table  = '0';
    walkstate.permissions.pxn_table = '0';

    var descriptor : bits(64);
    var walkaddress : AddressDescriptor;

    walkaddress.vaddress = ZeroExtend{64}(va);

    if !AArch32_S1DCacheEnabled(regime) then
        walkaddress.memattrs = NormalNCMemAttr();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;
    end;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == Regime_EL10 &amp;&amp; AArch32_EL2Enabled(accdesc.ss) &amp;&amp;
        (if ELStateUsingAArch32(EL2, accdesc.ss==SS_Secure) then HCR().VM
                                                            else HCR_EL2().VM) == '1' &amp;&amp;
        !(ImpDefBool("Apply effective shareability at stage 1"))) then
        walkaddress.memattrs.shareability = walkstate.memattrs.shareability;
    else
        walkaddress.memattrs.shareability = EffectiveShareability(walkaddress.memattrs);
    end;

    var desctype : DescriptorType;
    var msb_residual : integer = iasize - 1;
    repeat
        fault.level = walkstate.level;
        let indexlsb = ((FINAL_LEVEL - walkstate.level)*stride + granulebits) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
        let indexmsb = msb_residual as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
        let index : bits(40) = ZeroExtend{}(va[indexmsb:indexlsb]::'000');

        walkaddress.paddress.address = (walkstate.baseaddress.address OR
                                            ZeroExtend{56}(index));
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;

        let toplevel : boolean = walkstate.level == startlevel;
        let walkaccess : AccessDescriptor = CreateAccDescS1TTW(toplevel, varange, accdesc);
        // If there are two stages of translation, then the first stage table walk addresses
        // are themselves subject to translation
        if regime == Regime_EL10 &amp;&amp; AArch32_EL2Enabled(accdesc.ss) then
            let s2aligned : boolean = TRUE;
            let (s2fault, s2walkaddress) = AArch32_S2Translate(fault, walkaddress, s2aligned,
                                                               walkaccess);
            // Check for a fault on the stage 2 walk
            if s2fault.statuscode != Fault_None then
                return (s2fault, ARBITRARY : TTWState);
            end;

            (fault, descriptor) = FetchDescriptor{64}(walkparams.ee, s2walkaddress, walkaccess,
                                                      fault);
        else
            (fault, descriptor) = FetchDescriptor{64}(walkparams.ee, walkaddress, walkaccess,
                                                      fault);
        end;

        if fault.statuscode != Fault_None then
            return (fault, ARBITRARY : TTWState);
        end;

        desctype = AArch32_DecodeDescriptorTypeLD(descriptor, walkstate.level);

        case desctype of
            when DescriptorType_Table =&gt;
                if !IsZero(descriptor[47:40]) then
                    fault.statuscode = Fault_AddressSize;
                    return (fault, ARBITRARY : TTWState);
                end;

                walkstate.baseaddress.address = ZeroExtend{56}(descriptor[39:12]::
                                                                       Zeros{12});
                if walkstate.baseaddress.paspace == PAS_Secure &amp;&amp; descriptor[63] == '1' then
                    walkstate.baseaddress.paspace = PAS_NonSecure;
                end;
                if walkparams.hpd == '0' then
                    walkstate.permissions.xn_table  = (walkstate.permissions.xn_table  OR
                                                        descriptor[60]);
                    walkstate.permissions.ap_table  = (walkstate.permissions.ap_table  OR
                                                        descriptor[62:61]);
                    walkstate.permissions.pxn_table = (walkstate.permissions.pxn_table OR
                                                        descriptor[59]);
                end;
                walkstate.level = walkstate.level + 1;
                msb_residual = indexlsb - 1;

            when DescriptorType_Invalid =&gt;
                fault.statuscode = Fault_Translation;
                return (fault, ARBITRARY : TTWState);

            when DescriptorType_Leaf =&gt;
                walkstate.istable = FALSE;
        end;

    until desctype == DescriptorType_Leaf looplimit 3;

    // Check the output address is inside the supported range
    if !IsZero(descriptor[47:40]) then
        fault.statuscode = Fault_AddressSize;
        return (fault, ARBITRARY : TTWState);
    end;

    // Check the access flag
    if descriptor[10] == '0' then
        fault.statuscode = Fault_AccessFlag;
        return (fault, ARBITRARY : TTWState);
    end;

    walkstate.permissions.xn  = descriptor[54];
    walkstate.permissions.pxn = descriptor[53];
    walkstate.permissions.ap  = descriptor[7:6]::'1';
    walkstate.contiguous      = descriptor[52];
    if regime == Regime_EL2 then
        // All EL2 regime accesses are treated as Global
        walkstate.nG = '0';
    elsif accdesc.ss == SS_Secure &amp;&amp; walkstate.baseaddress.paspace == PAS_NonSecure then
        // When a PE is using the Long-descriptor translation table format,
        // and is in Secure state, a translation must be treated as non-global,
        // regardless of the value of the nG bit,
        // if NSTable is set to 1 at any level of the translation table walk.
        walkstate.nG = '1';
    else
        walkstate.nG = descriptor[11];
    end;

    let indexlsb = ((FINAL_LEVEL - walkstate.level)*stride + granulebits) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    walkstate.baseaddress.address = ZeroExtend{56}(descriptor[39:indexlsb]::
                                                           Zeros{indexlsb});
    if walkstate.baseaddress.paspace == PAS_Secure &amp;&amp; descriptor[5] == '1' then
        walkstate.baseaddress.paspace = PAS_NonSecure;
    end;

    let memattr : bits(3) = descriptor[4:2];
    let sh : bits(2)      = descriptor[9:8];
    let attr : bits(8)    = AArch32_MAIRAttr(UInt(memattr), walkparams.mair);
    let s1aarch64 : boolean = FALSE;
    walkstate.memattrs = S1DecodeMemAttrs(attr, sh, s1aarch64);

    return (fault, walkstate);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32_S1WalkSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32_S1WalkSD</h3>
      <p class="pseudocode">// AArch32_S1WalkSD()
// ==================
// Traverse stage 1 translation tables in short format to obtain the final descriptor

func <a id="func_AArch32_S1WalkSD_4"/>AArch32_S1WalkSD(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                      accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, va : bits(32)) =&gt; (<a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>)
begin
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    var sctlr : SCTLR_Type;
    var ttbcr : TTBCR_Type;
    var ttbr0 : TTBR0_Type;
    var ttbr1 : TTBR1_Type;
    // Determine correct translation control registers to use.
    if regime == <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> then
        sctlr = SCTLR_S();
        ttbcr = TTBCR_S();
        ttbr0 = TTBR0_S();
        ttbr1 = TTBR1_S();
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        sctlr = SCTLR_NS();
        ttbcr = TTBCR_NS();
        ttbr0 = TTBR0_NS();
        ttbr1 = TTBR1_NS();
    else
        sctlr = SCTLR();
        ttbcr = TTBCR();
        ttbr0 = TTBR0();
        ttbr1 = TTBR1();
    end;

    assert ttbcr.EAE == '0';
    let ee : bit  = sctlr.EE;
    let afe : bit = sctlr.AFE;
    let tre : bit = sctlr.TRE;
    let ttbcr_n : integer{} = UInt(ttbcr.N);
    let varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a> = (if ttbcr_n == 0 || IsZero(va[31:(32-ttbcr_n)]) then <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a>
                                else <a href="shared_pseudocode.html#enum_VARange_UPPER" title="">VARange_UPPER</a>);
    let n : integer{} = if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then ttbcr_n else 0;
    var ttb : bits(32);
    var pd : bits(1);
    var irgn : bits(2);
    var rgn : bits(2);
    var s : bits(1);
    var nos : bits(1);
    if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then
        ttb  = ttbr0.TTB0::Zeros{7};
        pd   = ttbcr.PD0;
        irgn = ttbr0.IRGN;
        rgn  = ttbr0.RGN;
        s    = ttbr0.S;
        nos  = ttbr0.NOS;
    else
        ttb  = ttbr1.TTB1::Zeros{7};
        pd   = ttbcr.PD1;
        irgn = ttbr1.IRGN;
        rgn  = ttbr1.RGN;
        s    = ttbr1.S;
        nos  = ttbr1.NOS;
    end;

    // Check if Translation table walk disabled for translations with this Base register.
    if pd == '1' then
        fault.level      = 1;
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>);
    end;

    var baseaddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;
    baseaddress.paspace = if accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> else <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
    baseaddress.address = ZeroExtend{56}(ttb[31:14-n]::Zeros{14-n});

    let startlevel : integer = 1;
    var walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    walkstate.baseaddress = baseaddress;
    // In regimes that support global and non-global translations, translation
    // table entries from lookup levels other than the final level of lookup
    // are treated as being non-global. Translations in Short-Descriptor Format
    // always support global &amp; non-global translations.
    walkstate.nG          = '1';
    walkstate.memattrs    = <a href="shared_pseudocode.html#func_WalkMemAttrs_3" title="">WalkMemAttrs</a>(s::nos, irgn, rgn);
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;

    var domain : bits(4);
    var descriptor : bits(32);
    var walkaddress : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;

    walkaddress.vaddress = ZeroExtend{64}(va);

    if !<a href="shared_pseudocode.html#func_AArch32_S1DCacheEnabled_1" title="">AArch32_S1DCacheEnabled</a>(regime) then
        walkaddress.memattrs = <a href="shared_pseudocode.html#func_NormalNCMemAttr_0" title="">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;
    end;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_AArch32_EL2Enabled_1" title="">AArch32_EL2Enabled</a>(accdesc.ss) &amp;&amp;
        (if <a href="shared_pseudocode.html#func_ELStateUsingAArch32_2" title="">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, accdesc.ss==<a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>) then HCR().VM
                                                            else HCR_EL2().VM) == '1' &amp;&amp;
        !(ImpDefBool("Apply effective shareability at stage 1"))) then
        walkaddress.memattrs.shareability = walkstate.memattrs.shareability;
    else
        walkaddress.memattrs.shareability = <a href="shared_pseudocode.html#func_EffectiveShareability_1" title="">EffectiveShareability</a>(walkaddress.memattrs);
    end;

    var nG : bit;
    var ns : bit;
    var pxn : bit;
    var ap : bits(3);
    var tex : bits(3);
    var c : bit;
    var b : bit;
    var xn : bit;
    repeat
        fault.level = walkstate.level;

        var index : bits(32);
        if walkstate.level == 1 then
            index = ZeroExtend{32}(va[31-n:20]::'00');
        else
            index = ZeroExtend{32}(va[19:12]::'00');
        end;

        walkaddress.paddress.address = (walkstate.baseaddress.address OR
                                            ZeroExtend{56}(index));
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;

        let toplevel : boolean = walkstate.level == startlevel;
        let walkaccess : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescS1TTW_3" title="">CreateAccDescS1TTW</a>(toplevel, varange, accdesc);
        if regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_AArch32_EL2Enabled_1" title="">AArch32_EL2Enabled</a>(accdesc.ss) then
            let s2aligned : boolean = TRUE;
            let (s2fault, s2walkaddress) = <a href="shared_pseudocode.html#func_AArch32_S2Translate_4" title="">AArch32_S2Translate</a>(fault, walkaddress, s2aligned,
                                                               walkaccess);

            if s2fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
                return (s2fault, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>);
            end;

            (fault, descriptor) = <a href="shared_pseudocode.html#func_FetchDescriptor_5" title="">FetchDescriptor</a>{32}(ee, s2walkaddress, walkaccess, fault);
        else
            (fault, descriptor) = <a href="shared_pseudocode.html#func_FetchDescriptor_5" title="">FetchDescriptor</a>{32}(ee, walkaddress, walkaccess, fault);
        end;

        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>);
        end;

        walkstate.sdftype = <a href="shared_pseudocode.html#func_AArch32_DecodeDescriptorTypeSD_2" title="">AArch32_DecodeDescriptorTypeSD</a>(descriptor, walkstate.level);

        case walkstate.sdftype of
            when <a href="shared_pseudocode.html#enum_SDFType_Invalid" title="">SDFType_Invalid</a> =&gt;
                fault.domain     = domain;
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
                return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>);

            when <a href="shared_pseudocode.html#enum_SDFType_Table" title="">SDFType_Table</a> =&gt;
                domain = descriptor[8:5];
                ns     = descriptor[3];
                pxn    = descriptor[2];

                walkstate.baseaddress.address = ZeroExtend{56}(descriptor[31:10]::
                                                                       Zeros{10});
                walkstate.level = 2;

            when <a href="shared_pseudocode.html#enum_SDFType_SmallPage" title="">SDFType_SmallPage</a> =&gt;
                nG  = descriptor[11];
                s   = descriptor[10];
                ap  = descriptor[9,5:4];
                tex = descriptor[8:6];
                c   = descriptor[3];
                b   = descriptor[2];
                xn  = descriptor[0];

                walkstate.baseaddress.address = ZeroExtend{56}(descriptor[31:12]::
                                                                       Zeros{12});
                walkstate.istable = FALSE;

            when <a href="shared_pseudocode.html#enum_SDFType_LargePage" title="">SDFType_LargePage</a> =&gt;
                xn  = descriptor[15];
                tex = descriptor[14:12];
                nG  = descriptor[11];
                s   = descriptor[10];
                ap  = descriptor[9,5:4];
                c   = descriptor[3];
                b   = descriptor[2];

                walkstate.baseaddress.address = ZeroExtend{56}(descriptor[31:16]::
                                                                       Zeros{16});
                walkstate.istable = FALSE;

            when <a href="shared_pseudocode.html#enum_SDFType_Section" title="">SDFType_Section</a> =&gt;
                ns     = descriptor[19];
                nG     = descriptor[17];
                s      = descriptor[16];
                ap     = descriptor[15,11:10];
                tex    = descriptor[14:12];
                domain = descriptor[8:5];
                xn     = descriptor[4];
                c      = descriptor[3];
                b      = descriptor[2];
                pxn    = descriptor[0];

                walkstate.baseaddress.address = ZeroExtend{56}(descriptor[31:20]::
                                                                       Zeros{20});
                walkstate.istable = FALSE;

            when <a href="shared_pseudocode.html#enum_SDFType_Supersection" title="">SDFType_Supersection</a> =&gt;
                ns     = descriptor[19];
                nG     = descriptor[17];
                s      = descriptor[16];
                ap     = descriptor[15,11:10];
                tex    = descriptor[14:12];
                xn     = descriptor[4];
                c      = descriptor[3];
                b      = descriptor[2];
                pxn    = descriptor[0];
                domain = '0000';

                walkstate.baseaddress.address = ZeroExtend{56}(descriptor[8:5,23:20,31:24]::
                                                                       Zeros{24});

                walkstate.istable = FALSE;
        end;

    until walkstate.sdftype != <a href="shared_pseudocode.html#enum_SDFType_Table" title="">SDFType_Table</a> looplimit 2;

    if afe == '1' &amp;&amp; ap[0] == '0' then
        fault.domain     = domain;
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AccessFlag" title="">Fault_AccessFlag</a>;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>);
    end;

    // Decode the TEX, C, B and S bits to produce target memory attributes
    if tre == '1' then
        walkstate.memattrs = <a href="shared_pseudocode.html#func_AArch32_RemappedTEXDecode_5" title="">AArch32_RemappedTEXDecode</a>(regime, tex, c, b, s);
    elsif <a href="shared_pseudocode.html#func_RemapRegsHaveResetValues_0" title="">RemapRegsHaveResetValues</a>() then
        walkstate.memattrs = <a href="shared_pseudocode.html#func_AArch32_DefaultTEXDecode_4" title="">AArch32_DefaultTEXDecode</a>(tex, c, b, s);
    else
        walkstate.memattrs = ImpDefMemoryAttributes("IMPLEMENTATION_DEFINED");
    end;

    walkstate.permissions.ap  = ap;
    walkstate.permissions.xn  = xn;
    walkstate.permissions.pxn = pxn;
    walkstate.domain = domain;
    walkstate.nG     = nG;

    if accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> &amp;&amp; ns == '0' then
        walkstate.baseaddress.paspace = <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
    else
        walkstate.baseaddress.paspace = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
    end;

    return (fault, walkstate);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32_S2IASize"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32_S2IASize</h3>
      <p class="pseudocode">// AArch32_S2IASize()
// ==================
// Retrieve the number of bits containing the input address for stage 2 translation

func AArch32_S2IASize(t0sz : bits(4)) =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    return 32 - SInt(t0sz);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32_S2StartLevel"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32_S2StartLevel</h3>
      <p class="pseudocode">// AArch32_S2StartLevel()
// ======================
// Determine the initial lookup level when performing a stage 2 translation
// table walk

func <a id="func_AArch32_S2StartLevel_1"/>AArch32_S2StartLevel(sl0 : bits(2)) =&gt; integer
begin
    return 2 - UInt(sl0);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32_S2Walk"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32_S2Walk</h3>
      <p class="pseudocode">// AArch32_S2Walk()
// ================
// Traverse stage 2 translation tables in long format to obtain the final descriptor

func AArch32_S2Walk(fault_in : FaultRecord, walkparams : S2TTWParams,
                    accdesc : AccessDescriptor, ipa : AddressDescriptor) =&gt; (FaultRecord, TTWState)
begin
    var fault : FaultRecord = fault_in;

    if walkparams.sl0 == '1x' || AArch32_S2InconsistentSL(walkparams) then
        fault.statuscode = Fault_Translation;
        fault.level      = 1;
        return (fault, ARBITRARY : TTWState);
    end;

    // Input Address size
    let iasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>      = AArch32_S2IASize(walkparams.t0sz);
    let startlevel : integer  = AArch32_S2StartLevel(walkparams.sl0);
    let levels : integer      = FINAL_LEVEL - startlevel;
    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = TGxGranuleBits(walkparams.tgx);
    let stride : integer{}      = granulebits - 3;

    if !IsZero(VTTBR()[47:40]) then
        fault.statuscode = Fault_AddressSize;
        fault.level      = 0;
        return (fault, ARBITRARY : TTWState);
    end;

    var baseaddress : FullAddress;
    let baselsb = ((iasize - (levels*stride + granulebits)) + 3) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    baseaddress.paspace = PAS_NonSecure;
    baseaddress.address = ZeroExtend{56}(VTTBR()[39:baselsb]::Zeros{baselsb});

    var walkstate : TTWState;
    walkstate.baseaddress = baseaddress;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    walkstate.memattrs    = WalkMemAttrs(walkparams.sh, walkparams.irgn,
                                         walkparams.orgn);

    var descriptor : bits(64);
    let walkaccess : AccessDescriptor = CreateAccDescS2TTW(accdesc);
    var walkaddress : AddressDescriptor;

    walkaddress.vaddress = ipa.vaddress;

    if HCR2().CD == '1' then
        walkaddress.memattrs = NormalNCMemAttr();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;
    end;

    walkaddress.memattrs.shareability = EffectiveShareability(walkaddress.memattrs);

    var msb_residual : integer = iasize - 1;
    var desctype : DescriptorType;
    repeat
        fault.level = walkstate.level;

        let indexlsb = ((FINAL_LEVEL - walkstate.level)*stride + granulebits) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
        let indexmsb = msb_residual as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
        let index : bits(40) = ZeroExtend{}(ipa.paddress.address[indexmsb:indexlsb]::'000');

        walkaddress.paddress.address = (walkstate.baseaddress.address OR
                                        ZeroExtend{56}(index));
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;

        (fault, descriptor) = FetchDescriptor{64}(walkparams.ee, walkaddress, walkaccess, fault);

        if fault.statuscode != Fault_None then
            return (fault, ARBITRARY : TTWState);
        end;

        desctype = AArch32_DecodeDescriptorTypeLD(descriptor, walkstate.level);

        case desctype of
            when DescriptorType_Table =&gt;
                if !IsZero(descriptor[47:40]) then
                    fault.statuscode = Fault_AddressSize;
                    return (fault, ARBITRARY : TTWState);
                end;

                walkstate.baseaddress.address = ZeroExtend{56}(descriptor[39:12]::
                                                                       Zeros{12});
                walkstate.level = walkstate.level + 1;
                msb_residual = indexlsb - 1;

            when DescriptorType_Invalid =&gt;
                fault.statuscode = Fault_Translation;
                return (fault, ARBITRARY : TTWState);

            when DescriptorType_Leaf =&gt;
                walkstate.istable = FALSE;
        end;

    until desctype == DescriptorType_Leaf looplimit 3;

    // Check the output address is inside the supported range
    if !IsZero(descriptor[47:40]) then
        fault.statuscode = Fault_AddressSize;
        return (fault, ARBITRARY : TTWState);
    end;

    // Check the access flag
    if descriptor[10] == '0' then
        fault.statuscode = Fault_AccessFlag;
        return (fault, ARBITRARY : TTWState);
    end;

    // Unpack the descriptor into address and upper and lower block attributes
    let indexlsb = ((FINAL_LEVEL - walkstate.level)*stride + granulebits) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    walkstate.baseaddress.address = ZeroExtend{56}(descriptor[39:indexlsb]::
                                                           Zeros{indexlsb});

    walkstate.permissions.s2ap = descriptor[7:6];
    walkstate.permissions.s2xn = descriptor[54];
    if IsFeatureImplemented(FEAT_XNX) then
        walkstate.permissions.s2xnx = descriptor[53];
    else
        walkstate.permissions.s2xnx = '0';
    end;

    let memattr : bits(4) = descriptor[5:2];
    let sh : bits(2)      = descriptor[9:8];
    let s2aarch64 : boolean = FALSE;
    walkstate.memattrs   = S2DecodeMemAttrs(memattr, sh, s2aarch64);
    walkstate.contiguous = descriptor[52];

    return (fault, walkstate);
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.RemapRegsHaveResetValues"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/RemapRegsHaveResetValues</h3>
      <p class="pseudocode">// RemapRegsHaveResetValues()
// ==========================

impdef func <a id="func_RemapRegsHaveResetValues_0"/>RemapRegsHaveResetValues() =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32_GetS1TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32_GetS1TTWParams</h3>
      <p class="pseudocode">// AArch32_GetS1TTWParams()
// ========================
// Returns stage 1 translation table walk parameters from respective controlling
// System registers.

func <a id="func_AArch32_GetS1TTWParams_2"/>AArch32_GetS1TTWParams(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, va : bits(32)) =&gt; <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>
begin
    var walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>;

    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;  walkparams = <a href="shared_pseudocode.html#func_AArch32_S1TTWParamsEL2_0" title="">AArch32_S1TTWParamsEL2</a>();
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; walkparams = <a href="shared_pseudocode.html#func_AArch32_S1TTWParamsEL10_1" title="">AArch32_S1TTWParamsEL10</a>(va);
        when <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> =&gt; walkparams = <a href="shared_pseudocode.html#func_AArch32_S1TTWParamsEL30_1" title="">AArch32_S1TTWParamsEL30</a>(va);
    end;

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32_GetS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32_GetS2TTWParams</h3>
      <p class="pseudocode">// AArch32_GetS2TTWParams()
// ========================
// Gather walk parameters for stage 2 translation

func <a id="func_AArch32_GetS2TTWParams_0"/>AArch32_GetS2TTWParams() =&gt; <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>
begin
    var walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>;

    walkparams.tgx  = <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
    walkparams.s    = VTCR().S;
    walkparams.t0sz = VTCR().T0SZ;
    walkparams.sl0  = VTCR().SL0;
    walkparams.irgn = VTCR().IRGN0;
    walkparams.orgn = VTCR().ORGN0;
    walkparams.sh   = VTCR().SH0;
    walkparams.ee   = HSCTLR().EE;
    walkparams.ptw  = HCR().PTW;
    walkparams.vm   = HCR().VM OR HCR().DC;

    // VTCR.S must match VTCR.T0SZ[3]
    if walkparams.s != walkparams.t0sz[3] then
        (-, walkparams.t0sz) = ConstrainUnpredictableBits{4}(<a href="shared_pseudocode.html#enum_Unpredictable_RESVTCRS" title="">Unpredictable_RESVTCRS</a>);
    end;

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32_GetVARange"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32_GetVARange</h3>
      <p class="pseudocode">// AArch32_GetVARange()
// ====================
// Select the translation base address for stage 1 long-descriptor walks

func AArch32_GetVARange(va : bits(32), t0sz : bits(3), t1sz : bits(3)) =&gt; VARange
begin
    // Lower range Input Address size
    let lo_iasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = AArch32_S1IASize(t0sz);
    // Upper range Input Address size
    let up_iasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = AArch32_S1IASize(t1sz);

    if t1sz == '000' &amp;&amp; t0sz == '000' then
        return VARange_LOWER;
    elsif t1sz == '000' then
        return if IsZero(va[31:lo_iasize]) then VARange_LOWER else VARange_UPPER;
    elsif t0sz == '000' then
        return if IsOnes(va[31:up_iasize]) then VARange_UPPER else VARange_LOWER;
    elsif IsZero(va[31:lo_iasize]) then
        return VARange_LOWER;
    elsif IsOnes(va[31:up_iasize]) then
        return VARange_UPPER;
    else
        // Will be reported as a Translation Fault
        return ARBITRARY : VARange;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32_S1DCacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32_S1DCacheEnabled</h3>
      <p class="pseudocode">// AArch32_S1DCacheEnabled()
// =========================
// Determine cacheability of stage 1 data accesses

func <a id="func_AArch32_S1DCacheEnabled_1"/>AArch32_S1DCacheEnabled(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>) =&gt; boolean
begin
    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> =&gt; return SCTLR_S().C == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;  return HSCTLR().C == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;
            return (if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then SCTLR_NS().C else SCTLR().C) == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32_S1ICacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32_S1ICacheEnabled</h3>
      <p class="pseudocode">// AArch32_S1ICacheEnabled()
// =========================
// Determine cacheability of stage 1 instruction fetches

func <a id="func_AArch32_S1ICacheEnabled_1"/>AArch32_S1ICacheEnabled(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>) =&gt; boolean
begin
    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> =&gt; return SCTLR_S().I == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;  return HSCTLR().I == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;
            return (if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then SCTLR_NS().I else SCTLR().I) == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32_S1TTWParamsEL10"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32_S1TTWParamsEL10</h3>
      <p class="pseudocode">// AArch32_S1TTWParamsEL10()
// =========================
// Gather stage 1 translation table walk parameters for EL1&amp;0 regime
// (with EL2 enabled or disabled).

func <a id="func_AArch32_S1TTWParamsEL10_1"/>AArch32_S1TTWParamsEL10(va : bits(32)) =&gt; <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>
begin
    var mair : bits(64);
    var sif : bit;
    var ttbcr : TTBCR_Type;
    var ttbcr2 : TTBCR2_Type;
    var sctlr : SCTLR_Type;

    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        ttbcr  = TTBCR_NS();
        ttbcr2 = TTBCR2_NS();
        sctlr  = SCTLR_NS();
        mair   = MAIR1_NS()::MAIR0_NS();
        sif    = SCR().SIF;
    else
        ttbcr  = TTBCR();
        ttbcr2 = TTBCR2();
        sctlr  = SCTLR();
        mair   = MAIR1()::MAIR0();
        sif    = if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then SCR_EL3().SIF else '0';
    end;

    assert ttbcr.EAE == '1';
    var walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>;

    walkparams.t0sz   = ttbcr.T0SZ;
    walkparams.t1sz   = ttbcr.T1SZ;
    walkparams.ee     = sctlr.EE;
    walkparams.wxn    = sctlr.WXN;
    walkparams.uwxn   = sctlr.UWXN;
    walkparams.ntlsmd = if IsFeatureImplemented(FEAT_LSMAOC) then sctlr.nTLSMD else '1';
    walkparams.mair   = mair;
    walkparams.sif    = sif;

    let varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a> = AArch32_GetVARange(va, walkparams.t0sz, walkparams.t1sz);
    if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then
        walkparams.sh   = ttbcr.SH0;
        walkparams.irgn = ttbcr.IRGN0;
        walkparams.orgn = ttbcr.ORGN0;
        walkparams.hpd  = (if IsFeatureImplemented(FEAT_AA32HPD) then ttbcr.T2E AND ttbcr2.HPD0
                           else '0');
    else
        walkparams.sh   = ttbcr.SH1;
        walkparams.irgn = ttbcr.IRGN1;
        walkparams.orgn = ttbcr.ORGN1;
        walkparams.hpd  = (if IsFeatureImplemented(FEAT_AA32HPD) then ttbcr.T2E AND ttbcr2.HPD1
                           else '0');
    end;

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32_S1TTWParamsEL2"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32_S1TTWParamsEL2</h3>
      <p class="pseudocode">// AArch32_S1TTWParamsEL2()
// ========================
// Gather stage 1 translation table walk parameters for EL2 regime

func <a id="func_AArch32_S1TTWParamsEL2_0"/>AArch32_S1TTWParamsEL2() =&gt; <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>
begin
    var walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>;

    walkparams.tgx  = <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
    walkparams.t0sz = HTCR().T0SZ;
    walkparams.irgn = HTCR().IRGN0;
    walkparams.orgn = HTCR().ORGN0;
    walkparams.sh   = HTCR().SH0;
    walkparams.hpd  = if IsFeatureImplemented(FEAT_AA32HPD) then HTCR().HPD else '0';
    walkparams.ee   = HSCTLR().EE;
    walkparams.wxn  = HSCTLR().WXN;
    if IsFeatureImplemented(FEAT_LSMAOC) then
        walkparams.ntlsmd = HSCTLR().nTLSMD;
    else
        walkparams.ntlsmd = '1';
    end;

    walkparams.mair = HMAIR1()::HMAIR0();

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32_S1TTWParamsEL30"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32_S1TTWParamsEL30</h3>
      <p class="pseudocode">// AArch32_S1TTWParamsEL30()
// =========================
// Gather stage 1 translation table walk parameters for EL3&amp;0 regime

func <a id="func_AArch32_S1TTWParamsEL30_1"/>AArch32_S1TTWParamsEL30(va : bits(32)) =&gt; <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>
begin
    assert TTBCR_S().EAE == '1';
    var walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>;

    walkparams.t0sz   = TTBCR_S().T0SZ;
    walkparams.t1sz   = TTBCR_S().T1SZ;
    walkparams.ee     = SCTLR_S().EE;
    walkparams.wxn    = SCTLR_S().WXN;
    walkparams.uwxn   = SCTLR_S().UWXN;
    walkparams.ntlsmd = if IsFeatureImplemented(FEAT_LSMAOC) then SCTLR_S().nTLSMD else '1';
    walkparams.mair   = MAIR1_S()::MAIR0_S();
    walkparams.sif    = SCR().SIF;

    let varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a> = AArch32_GetVARange(va, walkparams.t0sz, walkparams.t1sz);
    if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then
        walkparams.sh   = TTBCR_S().SH0;
        walkparams.irgn = TTBCR_S().IRGN0;
        walkparams.orgn = TTBCR_S().ORGN0;
        walkparams.hpd  = (if IsFeatureImplemented(FEAT_AA32HPD)
                           then TTBCR_S().T2E AND TTBCR2_S().HPD0
                           else '0');
    else
        walkparams.sh   = TTBCR_S().SH1;
        walkparams.irgn = TTBCR_S().IRGN1;
        walkparams.orgn = TTBCR_S().ORGN1;
        walkparams.hpd  = (if IsFeatureImplemented(FEAT_AA32HPD)
                           then TTBCR_S().T2E AND TTBCR2_S().HPD1
                           else '0');
    end;

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBCycleCountingEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBCycleCountingEnabled</h3>
      <p class="pseudocode">// BRBCycleCountingEnabled()
// =========================
// Returns TRUE if the recording of cycle counts is allowed,
// FALSE otherwise.

func <a id="func_BRBCycleCountingEnabled_0"/>BRBCycleCountingEnabled() =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; BRBCR_EL2().CC == '0' then return FALSE; end;
    if BRBCR_EL1().CC == '0' then return FALSE; end;
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEBranch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEBranch</h3>
      <p class="pseudocode">// BRBEBranch()
// ============
// Called to write branch record for the following branches when BRBE is active:
// direct branches,
// indirect branches,
// direct branches with link,
// indirect branches with link,
// returns from subroutines.

func BRBEBranch(br_type : <a href="shared_pseudocode.html#type_BranchType" title="">BranchType</a>, cond : boolean, target_address : bits(64))
begin
    if <a href="shared_pseudocode.html#func_BranchRecordAllowed_1" title="">BranchRecordAllowed</a>(PSTATE.EL) &amp;&amp; <a href="shared_pseudocode.html#func_FilterBranchRecord_2" title="">FilterBranchRecord</a>(br_type, cond) then
        var branch_type : bits(6);
        case br_type of
            when <a href="shared_pseudocode.html#enum_BranchType_DIR" title="">BranchType_DIR</a> =&gt;
                branch_type = if cond then '001000' else '000000';
            when <a href="shared_pseudocode.html#enum_BranchType_INDIR" title="">BranchType_INDIR</a> =&gt;      branch_type = '000001';
            when <a href="shared_pseudocode.html#enum_BranchType_DIRCALL" title="">BranchType_DIRCALL</a> =&gt;    branch_type = '000010';
            when <a href="shared_pseudocode.html#enum_BranchType_INDCALL" title="">BranchType_INDCALL</a> =&gt;    branch_type = '000011';
            when <a href="shared_pseudocode.html#enum_BranchType_RET" title="">BranchType_RET</a> =&gt;        branch_type = '000101';
            otherwise =&gt;                  unreachable;
        end;

        var ccu : bit;
        var cc : bits(14);
        (ccu, cc) = <a href="shared_pseudocode.html#func_BranchEncCycleCount_0" title="">BranchEncCycleCount</a>();
        let el : bits(2)        = PSTATE.EL;
        let mispredict : bit    = (if <a href="shared_pseudocode.html#func_BRBEMispredictAllowed_0" title="">BRBEMispredictAllowed</a>() &amp;&amp; <a href="shared_pseudocode.html#func_BranchMispredict_0" title="">BranchMispredict</a>() then '1'
                                   else '0');

        UpdateBranchRecordBuffer(ccu, cc, branch_type, el, mispredict,
                                 '11', <a href="shared_pseudocode.html#func_PC64_0" title="">PC64</a>(), target_address);

        PMUEvent(PMU_EVENT_BRB_FILTRATE);
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEBranchOnISB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEBranchOnISB</h3>
      <p class="pseudocode">// BRBEBranchOnISB()
// =================
// Returns TRUE if ISBs generate Branch records, and FALSE otherwise.

func <a id="func_BRBEBranchOnISB_0"/>BRBEBranchOnISB() =&gt; boolean
begin
    return ImpDefBool("ISB generates Branch records");
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEDebugStateEntry"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEDebugStateEntry</h3>
      <p class="pseudocode">// BRBEDebugStateEntry()
// =====================
// Called to write Debug state entry branch record when BRBE is active.

func BRBEDebugStateEntry(source_address : bits(64))
begin
    if <a href="shared_pseudocode.html#func_BranchRecordAllowed_1" title="">BranchRecordAllowed</a>(PSTATE.EL) then
        let branch_type : bits(6) = '100001';
        var ccu : bit;
        var cc : bits(14);
        (ccu, cc) = <a href="shared_pseudocode.html#func_BranchEncCycleCount_0" title="">BranchEncCycleCount</a>();
        let el : bits(2)     = '00';
        let mispredict : bit = '0';

        // Debug state is a prohibited region, therefore target_address=0
        UpdateBranchRecordBuffer(ccu, cc, branch_type, el, mispredict,
                                 '10', source_address, Zeros{64});

        PMUEvent(PMU_EVENT_BRB_FILTRATE);
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEDebugStateExit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEDebugStateExit</h3>
      <p class="pseudocode">// BRBEDebugStateExit()
// ====================
// Called to write Debug state exit branch record when BRBE is active.

func BRBEDebugStateExit(target_address : bits(64))
begin
    if <a href="shared_pseudocode.html#func_BranchRecordAllowed_1" title="">BranchRecordAllowed</a>(PSTATE.EL) then
        // Debug state is a prohibited region, therefore ccu=1, cc=0, source_address=0
        let branch_type : bits(6) = '111001';
        let ccu : bit             = '1';
        let cc : bits(14)         = Zeros{};
        let el : bits(2)          = PSTATE.EL;
        let mispredict : bit      = '0';

        UpdateBranchRecordBuffer(ccu, cc, branch_type, el, mispredict,
                                 '01', Zeros{64}, target_address);

        PMUEvent(PMU_EVENT_BRB_FILTRATE);
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEException</h3>
      <p class="pseudocode">// BRBEException()
// ===============
// Called to write exception branch record when BRBE is active.

func BRBEException(erec : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>, source_valid : boolean,
                   source_address_in : bits(64),
                   target_address_in : bits(64), target_el : bits(2),
                   trappedsyscallinst : boolean)
begin
    var target_address : bits(64) = target_address_in;
    let except : <a href="shared_pseudocode.html#type_Exception" title="">Exception</a> = erec.exceptype;
    let iss : bits(25)     = erec.syndrome.iss;
    case target_el of
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            if !IsFeatureImplemented(FEAT_BRBEv1p1) || (MDCR_EL3().E3BREC == MDCR_EL3().E3BREW) then
                return;
            end;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  if BRBCR_EL2().EXCEPTION == '0' then return; end;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  if BRBCR_EL1().EXCEPTION == '0' then return; end;
    end;

    let target_valid : boolean = <a href="shared_pseudocode.html#func_BranchRecordAllowed_1" title="">BranchRecordAllowed</a>(target_el);

    if source_valid || target_valid then
        var branch_type : bits(6);
        case except of
            when <a href="shared_pseudocode.html#enum_Exception_Uncategorized" title="">Exception_Uncategorized</a> =&gt;         branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_WFxTrap" title="">Exception_WFxTrap</a> =&gt;               branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_CP15RTTrap" title="">Exception_CP15RTTrap</a> =&gt;            branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_CP15RRTTrap" title="">Exception_CP15RRTTrap</a> =&gt;           branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_CP14RTTrap" title="">Exception_CP14RTTrap</a> =&gt;            branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_CP14DTTrap" title="">Exception_CP14DTTrap</a> =&gt;            branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_AdvSIMDFPAccessTrap" title="">Exception_AdvSIMDFPAccessTrap</a> =&gt;   branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_FPIDTrap" title="">Exception_FPIDTrap</a> =&gt;              branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_PACTrap" title="">Exception_PACTrap</a> =&gt;               branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_CP14RRTTrap" title="">Exception_CP14RRTTrap</a> =&gt;           branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_LDST64BTrap" title="">Exception_LDST64BTrap</a> =&gt;           branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_BranchTarget" title="">Exception_BranchTarget</a> =&gt;          branch_type = '101011'; // Inst Fault
            when <a href="shared_pseudocode.html#enum_Exception_IllegalState" title="">Exception_IllegalState</a> =&gt;          branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_SupervisorCall" title="">Exception_SupervisorCall</a> =&gt;
                if !trappedsyscallinst then      branch_type = '100010'; // Call
                else                             branch_type = '100011'; // Trap
                end;
            when <a href="shared_pseudocode.html#enum_Exception_HypervisorCall" title="">Exception_HypervisorCall</a> =&gt;        branch_type = '100010'; // Call
            when <a href="shared_pseudocode.html#enum_Exception_MonitorCall" title="">Exception_MonitorCall</a> =&gt;
                if !trappedsyscallinst then      branch_type = '100010'; // Call
                else                             branch_type = '100011'; // Trap
                end;
            when <a href="shared_pseudocode.html#enum_Exception_SystemRegisterTrap" title="">Exception_SystemRegisterTrap</a> =&gt;    branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_SystemRegister128Trap" title="">Exception_SystemRegister128Trap</a> =&gt; branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_SVEAccessTrap" title="">Exception_SVEAccessTrap</a> =&gt;         branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_SMEAccessTrap" title="">Exception_SMEAccessTrap</a> =&gt;         branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_ERetTrap" title="">Exception_ERetTrap</a> =&gt;              branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_PACFail" title="">Exception_PACFail</a> =&gt;               branch_type = '101100'; // Data Fault
            when <a href="shared_pseudocode.html#enum_Exception_InstructionAbort" title="">Exception_InstructionAbort</a> =&gt;      branch_type = '101011'; // Inst Fault
            when <a href="shared_pseudocode.html#enum_Exception_PCAlignment" title="">Exception_PCAlignment</a> =&gt;           branch_type = '101010'; // Alignment
            when <a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a> =&gt;             branch_type = '101100'; // Data Fault
            when <a href="shared_pseudocode.html#enum_Exception_NV2DataAbort" title="">Exception_NV2DataAbort</a> =&gt;          branch_type = '101100'; // Data Fault
            when <a href="shared_pseudocode.html#enum_Exception_SPAlignment" title="">Exception_SPAlignment</a> =&gt;           branch_type = '101010'; // Alignment
            when <a href="shared_pseudocode.html#enum_Exception_FPTrappedException" title="">Exception_FPTrappedException</a> =&gt;    branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_SError" title="">Exception_SError</a> =&gt;                branch_type = '100100'; // System Error
            when <a href="shared_pseudocode.html#enum_Exception_Breakpoint" title="">Exception_Breakpoint</a> =&gt;            branch_type = '100110'; // Inst debug
            when <a href="shared_pseudocode.html#enum_Exception_SoftwareStep" title="">Exception_SoftwareStep</a> =&gt;          branch_type = '100110'; // Inst debug
            when <a href="shared_pseudocode.html#enum_Exception_Watchpoint" title="">Exception_Watchpoint</a> =&gt;            branch_type = '100111'; // Data debug
            when <a href="shared_pseudocode.html#enum_Exception_NV2Watchpoint" title="">Exception_NV2Watchpoint</a> =&gt;         branch_type = '100111'; // Data debug
            when <a href="shared_pseudocode.html#enum_Exception_SoftwareBreakpoint" title="">Exception_SoftwareBreakpoint</a> =&gt;    branch_type = '100110'; // Inst debug
            when <a href="shared_pseudocode.html#enum_Exception_IRQ" title="">Exception_IRQ</a> =&gt;                   branch_type = '101110'; // IRQ
            when <a href="shared_pseudocode.html#enum_Exception_FIQ" title="">Exception_FIQ</a> =&gt;                   branch_type = '101111'; // FIQ
            when <a href="shared_pseudocode.html#enum_Exception_MemCpyMemSet" title="">Exception_MemCpyMemSet</a> =&gt;          branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#enum_Exception_GCSFail" title="">Exception_GCSFail</a> =&gt;
                if iss[23:20] == '0000' then        branch_type = '101100'; // Data Fault
                elsif iss[23:20] == '0001' then     branch_type = '101011'; // Inst Fault
                elsif iss[23:20] == '0010' then     branch_type = '100011'; // Trap
                else                                unreachable;
                end;
            when <a href="shared_pseudocode.html#enum_Exception_Profiling" title="">Exception_Profiling</a> =&gt;             branch_type = '100110'; // Inst debug
            when <a href="shared_pseudocode.html#enum_Exception_GPC" title="">Exception_GPC</a> =&gt;
                if iss[20] == '1' then              branch_type = '101011'; // Inst fault
                else                                branch_type = '101100'; // Data fault
                end;
            otherwise =&gt;                            unreachable;
        end;

        var ccu : bit;
        var cc : bits(14);
        (ccu, cc) = <a href="shared_pseudocode.html#func_BranchEncCycleCount_0" title="">BranchEncCycleCount</a>();
        let el : bits(2) = if target_valid then target_el else '00';
        let mispredict : bit = '0';
        let sv : bit = if source_valid then '1' else '0';
        let tv : bit = if target_valid then '1' else '0';
        let source_address : bits(64) = if source_valid then source_address_in else Zeros{64};

        if !target_valid then
            target_address = Zeros{64};
        else
            target_address = <a href="shared_pseudocode.html#func_AArch64_BranchAddr_2" title="">AArch64_BranchAddr</a>(target_address, target_el);
        end;

        UpdateBranchRecordBuffer(ccu, cc, branch_type, el, mispredict,
                                 sv::tv, source_address, target_address);

        PMUEvent(PMU_EVENT_BRB_FILTRATE);
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEExceptionReturn</h3>
      <p class="pseudocode">// BRBEExceptionReturn()
// =====================
// Called to write exception return branch record when BRBE is active.

func BRBEExceptionReturn(target_address_in : bits(64), source_el : bits(2),
                         source_valid : boolean, source_address_in : bits(64))
begin
    var target_address : bits(64) = target_address_in;
    case source_el of
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            if !IsFeatureImplemented(FEAT_BRBEv1p1) || (MDCR_EL3().E3BREC == MDCR_EL3().E3BREW) then
                return;
            end;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  if BRBCR_EL2().ERTN == '0' then return; end;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  if BRBCR_EL1().ERTN == '0' then return; end;
    end;

    let target_valid : boolean = <a href="shared_pseudocode.html#func_BranchRecordAllowed_1" title="">BranchRecordAllowed</a>(PSTATE.EL);

    if source_valid || target_valid then
        let branch_type : bits(6) = '000111';
        var ccu : bit;
        var cc : bits(14);
        (ccu, cc) = <a href="shared_pseudocode.html#func_BranchEncCycleCount_0" title="">BranchEncCycleCount</a>();
        let el : bits(2)     = if target_valid then PSTATE.EL else '00';
        let mispredict : bit = (if source_valid &amp;&amp; <a href="shared_pseudocode.html#func_BRBEMispredictAllowed_0" title="">BRBEMispredictAllowed</a>() &amp;&amp;
                                <a href="shared_pseudocode.html#func_BranchMispredict_0" title="">BranchMispredict</a>() then '1' else '0');
        let sv : bit = if source_valid then '1' else '0';
        let tv : bit = if target_valid then '1' else '0';
        let source_address : bits(64) = if source_valid then source_address_in else Zeros{64};
        if !target_valid then
            target_address = Zeros{64};
        end;

        UpdateBranchRecordBuffer(ccu, cc, branch_type, el, mispredict,
                                 sv::tv, source_address, target_address);

        PMUEvent(PMU_EVENT_BRB_FILTRATE);
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEFreeze"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEFreeze</h3>
      <p class="pseudocode">// BRBEFreeze()
// ============
// Generates BRBE freeze event.

func BRBEFreeze()
begin
    BRBFCR_EL1().PAUSED = '1';
    BRBTS_EL1() = <a href="shared_pseudocode.html#func_GetTimestamp_1" title="">GetTimestamp</a>(<a href="shared_pseudocode.html#func_BRBETimeStamp_0" title="">BRBETimeStamp</a>());
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEISB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEISB</h3>
      <p class="pseudocode">// BRBEISB()
// =========
// Handles ISB instruction for BRBE.

func BRBEISB()
begin
    let branch_conditional : boolean = FALSE;
    BRBEBranch(<a href="shared_pseudocode.html#enum_BranchType_DIR" title="">BranchType_DIR</a>, branch_conditional, <a href="shared_pseudocode.html#func_PC64_0" title="">PC64</a>() + 4);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEMispredictAllowed"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEMispredictAllowed</h3>
      <p class="pseudocode">// BRBEMispredictAllowed()
// =======================
// Returns TRUE if the recording of branch misprediction is allowed,
// FALSE otherwise.

func <a id="func_BRBEMispredictAllowed_0"/>BRBEMispredictAllowed() =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; BRBCR_EL2().MPRED == '0' then return FALSE; end;
    if BRBCR_EL1().MPRED == '0' then return FALSE; end;
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBETimeStamp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBETimeStamp</h3>
      <p class="pseudocode">// BRBETimeStamp()
// ===============
// Returns captured timestamp.

func <a id="func_BRBETimeStamp_0"/>BRBETimeStamp() =&gt; <a href="shared_pseudocode.html#type_TimeStamp" title="">TimeStamp</a>
begin
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        var TS_el2 : bits(2) = BRBCR_EL2().TS;
        if !IsFeatureImplemented(FEAT_ECV) &amp;&amp; TS_el2 == '10' then
            // Reserved value
            (-, TS_el2) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_EL2TIMESTAMP" title="">Unpredictable_EL2TIMESTAMP</a>);
        end;
        case TS_el2 of
            when '00' =&gt;
                // Falls out to check BRBCR_EL1.TS
                pass;
            when '01' =&gt;
                return <a href="shared_pseudocode.html#enum_TimeStamp_Virtual" title="">TimeStamp_Virtual</a>;
            when '10' =&gt;
                assert IsFeatureImplemented(FEAT_ECV); // Otherwise ConstrainUnpredictableBits
                                                       // removes this case
                return <a href="shared_pseudocode.html#enum_TimeStamp_OffsetPhysical" title="">TimeStamp_OffsetPhysical</a>;
            when '11' =&gt;
                return <a href="shared_pseudocode.html#enum_TimeStamp_Physical" title="">TimeStamp_Physical</a>;
        end;
    end;

    var TS_el1 : bits(2) = BRBCR_EL1().TS;
    if TS_el1 == '00' || (!IsFeatureImplemented(FEAT_ECV) &amp;&amp; TS_el1 == '10') then
        // Reserved value
        (-, TS_el1) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_EL1TIMESTAMP" title="">Unpredictable_EL1TIMESTAMP</a>);
    end;
    case TS_el1 of
        when '01' =&gt;
            return <a href="shared_pseudocode.html#enum_TimeStamp_Virtual" title="">TimeStamp_Virtual</a>;
        when '10' =&gt;
            return <a href="shared_pseudocode.html#enum_TimeStamp_OffsetPhysical" title="">TimeStamp_OffsetPhysical</a>;
        when '11' =&gt;
            return <a href="shared_pseudocode.html#enum_TimeStamp_Physical" title="">TimeStamp_Physical</a>;
        otherwise =&gt;
            unreachable;           // ConstrainUnpredictableBits removes this case
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRB_IALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRB_IALL</h3>
      <p class="pseudocode">// BRB_IALL()
// ==========
// Called to perform invalidation of branch records

func BRB_IALL()
begin
    let nbrberecords : integer = <a href="shared_pseudocode.html#func_GetBRBENumRecords_0" title="">GetBRBENumRecords</a>();
    for i = 0 to nbrberecords - 1 do
        <a href="shared_pseudocode.html#global_Records_SRC" title="">Records_SRC</a>[[i]] = Zeros{64};
        <a href="shared_pseudocode.html#global_Records_TGT" title="">Records_TGT</a>[[i]] = Zeros{64};
        <a href="shared_pseudocode.html#global_Records_INF" title="">Records_INF</a>[[i]] = Zeros{64};
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRB_INJ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRB_INJ</h3>
      <p class="pseudocode">// BRB_INJ()
// =========
// Called to perform manual injection of branch records.

func BRB_INJ()
begin
    UpdateBranchRecordBuffer(BRBINFINJ_EL1().CCU, BRBINFINJ_EL1().CC,
                             BRBINFINJ_EL1().TYPE, BRBINFINJ_EL1().EL,
                             BRBINFINJ_EL1().MPRED, BRBINFINJ_EL1().VALID, BRBSRCINJ_EL1().ADDRESS,
                             BRBTGTINJ_EL1().ADDRESS);
    BRBINFINJ_EL1() = ARBITRARY : bits(64);
    BRBSRCINJ_EL1() = ARBITRARY : bits(64);
    BRBTGTINJ_EL1() = ARBITRARY : bits(64);

    if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BRBFILTRATE" title="">Unpredictable_BRBFILTRATE</a>) then
        PMUEvent(PMU_EVENT_BRB_FILTRATE);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BranchEncCycleCount"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BranchEncCycleCount</h3>
      <p class="pseudocode">// BranchEncCycleCount()
// =====================

// The first return result is '1' if either of the following is true, and '0' otherwise:
// - This is the first Branch record after the PE exited a Prohibited Region.
// - This is the first Branch record after cycle counting has been enabled.
// If the first return return is '0', the second return result is the encoded cycle count
// since the last branch.
// The format of this field uses a mantissa and exponent to express the cycle count value.
//  - bits[7:0] indicate the mantissa M.
//  - bits[13:8] indicate the exponent E.
// The cycle count is expressed using the following function:
//   cycle_count = (if IsZero(E) then UInt(M) else UInt('1'::M::Zeros(UInt(E)-1)))
// A value of all ones in both the mantissa and exponent indicates the cycle count value
// exceeded the size of the cycle counter.
// If the cycle count is not known, the second return result is zero.

func <a id="func_BranchEncCycleCount_0"/>BranchEncCycleCount() =&gt; (bit, bits(14))
begin
    var cc : integer = <a href="shared_pseudocode.html#func_BranchRawCycleCount_0" title="">BranchRawCycleCount</a>();
    if !<a href="shared_pseudocode.html#func_BRBCycleCountingEnabled_0" title="">BRBCycleCountingEnabled</a>() || <a href="shared_pseudocode.html#func_FirstBranchAfterProhibited_0" title="">FirstBranchAfterProhibited</a>() then
        return ('1', Zeros{14});
    end;

    // The format of this field uses a mantissa and exponent to express the cycle count value.
    //  - bits[7:0] indicate the mantissa M.
    //  - bits[13:8] indicate the exponent E.
    // The cycle count is expressed using the following function:
    //   cycle_count = IsZero(E) then UInt(M) else UInt('1'::M::Zeros(UInt(E)-1))
    // A value of all ones in both the mantissa and exponent indicates the cycle count value
    // exceeded the size of the cycle counter.

    var E : bits(6);
    var M : bits(8);

    if cc &lt; 2^8 then
        E = Zeros{6};
        M = cc[7:0];
    elsif cc &gt;= 2^20 then
        E = Ones{6};
        M = Ones{8};
    else
        E = 1[5:0];
        while cc &gt;= 2^9 looplimit 11 do
            E = E + 1;
            cc = cc DIVRM 2;
        end;
        M = cc[7:0];
    end;

    return ('0', E::M);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BranchMispredict"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BranchMispredict</h3>
      <p class="pseudocode">// BranchMispredict()
// ==================
// Returns TRUE if the branch being executed was mispredicted, FALSE otherwise.

impdef func <a id="func_BranchMispredict_0"/>BranchMispredict() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BranchRawCycleCount"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BranchRawCycleCount</h3>
      <p class="pseudocode">// BranchRawCycleCount()
// =====================
// If the cycle count is known, the return result is the cycle count since the last branch.

impdef func <a id="func_BranchRawCycleCount_0"/>BranchRawCycleCount() =&gt; integer
begin
    return 0;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BranchRecordAllowed"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BranchRecordAllowed</h3>
      <p class="pseudocode">// BranchRecordAllowed()
// =====================
// Returns TRUE if branch recording is allowed, FALSE otherwise.

func <a id="func_BranchRecordAllowed_1"/>BranchRecordAllowed(el : bits(2)) =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(el) then
        return FALSE;
    end;

    if BRBFCR_EL1().PAUSED == '1' then
        return FALSE;
    end;

    if el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; IsFeatureImplemented(FEAT_BRBEv1p1) then
        return (MDCR_EL3().E3BREC != MDCR_EL3().E3BREW);
    end;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; (MDCR_EL3().SBRBE == '00' ||
        (<a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> &amp;&amp; MDCR_EL3().SBRBE == '01')) then
        return FALSE;
    end;

    case el of
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  return FALSE;                // FEAT_BRBEv1p1 not implemented
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  return BRBCR_EL2().E2BRE == '1';
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  return BRBCR_EL1().E1BRE == '1';
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then
                return BRBCR_EL2().E0HBRE == '1';
            else
                return BRBCR_EL1().E0BRE == '1';
            end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.Contents"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/Contents</h3>
      <p class="pseudocode">// Contents of the Branch Record Buffer
//=====================================

var <a id="global_Records_SRC"/>Records_SRC : array [[64]] of BRBSRC_EL1_Type;

var <a id="global_Records_TGT"/>Records_TGT : array [[64]] of BRBTGT_EL1_Type;

var <a id="global_Records_INF"/>Records_INF : array [[64]] of BRBINF_EL1_Type;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.FilterBranchRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/FilterBranchRecord</h3>
      <p class="pseudocode">// FilterBranchRecord()
// ====================
// Returns TRUE if the branch record is not filtered out, FALSE otherwise.

func <a id="func_FilterBranchRecord_2"/>FilterBranchRecord(br : <a href="shared_pseudocode.html#type_BranchType" title="">BranchType</a>, cond : boolean) =&gt; boolean
begin
    case br of
        when <a href="shared_pseudocode.html#enum_BranchType_DIRCALL" title="">BranchType_DIRCALL</a> =&gt;
            return BRBFCR_EL1().DIRCALL != BRBFCR_EL1().EnI;
        when <a href="shared_pseudocode.html#enum_BranchType_INDCALL" title="">BranchType_INDCALL</a> =&gt;
            return BRBFCR_EL1().INDCALL != BRBFCR_EL1().EnI;
        when <a href="shared_pseudocode.html#enum_BranchType_RET" title="">BranchType_RET</a> =&gt;
            return BRBFCR_EL1().RTN != BRBFCR_EL1().EnI;
        when <a href="shared_pseudocode.html#enum_BranchType_DIR" title="">BranchType_DIR</a> =&gt;
            if cond then
                return BRBFCR_EL1().CONDDIR != BRBFCR_EL1().EnI;
            else
                return BRBFCR_EL1().DIRECT != BRBFCR_EL1().EnI;
            end;
        when <a href="shared_pseudocode.html#enum_BranchType_INDIR" title="">BranchType_INDIR</a> =&gt;
            return BRBFCR_EL1().INDIRECT != BRBFCR_EL1().EnI;
        otherwise =&gt;  unreachable;
    end;
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.FirstBranchAfterProhibited"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/FirstBranchAfterProhibited</h3>
      <p class="pseudocode">// FirstBranchAfterProhibited()
// ============================
// Returns TRUE if branch recorded is the first branch after a prohibited region,
// FALSE otherwise.

impdef func <a id="func_FirstBranchAfterProhibited_0"/>FirstBranchAfterProhibited() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.GetBRBENumRecords"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/GetBRBENumRecords</h3>
      <p class="pseudocode">// GetBRBENumRecords()
// ===================
// Returns the number of branch records implemented.

func <a id="func_GetBRBENumRecords_0"/>GetBRBENumRecords() =&gt; integer
begin
    assert UInt(BRBIDR0_EL1().NUMREC) IN {0x08, 0x10, 0x20, 0x40};
    return ImpDefInt("Number of BRBE Branch records");
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.Getter"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/Getter</h3>
      <p class="pseudocode">// Getter functions for branch records
// ===================================
// Functions used by MRS instructions that access branch records

func <a id="func_BRBSRC_EL1_1"/>BRBSRC_EL1(n : integer) =&gt; BRBSRC_EL1_Type
begin
    assert n IN {0..31};
    let record_index : integer = UInt(BRBFCR_EL1().BANK::n[4:0]);
    if record_index &lt; <a href="shared_pseudocode.html#func_GetBRBENumRecords_0" title="">GetBRBENumRecords</a>() then
        return <a href="shared_pseudocode.html#global_Records_SRC" title="">Records_SRC</a>[[record_index]];
    else
        return Zeros{64};
    end;
end;

func <a id="func_BRBTGT_EL1_1"/>BRBTGT_EL1(n : integer) =&gt; BRBTGT_EL1_Type
begin
    assert n IN {0..31};
    let record_index : integer = UInt(BRBFCR_EL1().BANK::n[4:0]);
    if record_index &lt; <a href="shared_pseudocode.html#func_GetBRBENumRecords_0" title="">GetBRBENumRecords</a>() then
        return <a href="shared_pseudocode.html#global_Records_TGT" title="">Records_TGT</a>[[record_index]];
    else
        return Zeros{64};
    end;
end;

func <a id="func_BRBINF_EL1_1"/>BRBINF_EL1(n : integer) =&gt; BRBINF_EL1_Type
begin
    assert n IN {0..31};
    let record_index : integer = UInt(BRBFCR_EL1().BANK::n[4:0]);
    if record_index &lt; <a href="shared_pseudocode.html#func_GetBRBENumRecords_0" title="">GetBRBENumRecords</a>() then
        return <a href="shared_pseudocode.html#global_Records_INF" title="">Records_INF</a>[[record_index]];
    else
        return Zeros{64};
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.ShouldBRBEFreeze"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/ShouldBRBEFreeze</h3>
      <p class="pseudocode">// ShouldBRBEFreeze()
// ==================
// Returns TRUE if the BRBE freeze event conditions have been met, and FALSE otherwise.

func <a id="func_ShouldBRBEFreeze_0"/>ShouldBRBEFreeze() =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_BranchRecordAllowed_1" title="">BranchRecordAllowed</a>(PSTATE.EL) then
        return FALSE;
    end;

    var include_r1 : boolean;
    var include_r2 : boolean;
    let include_r3 : boolean = FALSE;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        include_r1 = (BRBCR_EL1().FZP == '1');
        include_r2 = (BRBCR_EL2().FZP == '1');
    else
        include_r1 = TRUE;
        include_r2 = TRUE;
    end;

    return <a href="shared_pseudocode.html#func_CheckPMUOverflowCondition_4" title="">CheckPMUOverflowCondition</a>(<a href="shared_pseudocode.html#enum_PMUOverflowCondition_BRBEFreeze" title="">PMUOverflowCondition_BRBEFreeze</a>,
                                     include_r1, include_r2, include_r3);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.UpdateBranchRecordBuffer"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/UpdateBranchRecordBuffer</h3>
      <p class="pseudocode">// UpdateBranchRecordBuffer()
// ==========================
// Add a new Branch record to the buffer.

func UpdateBranchRecordBuffer(ccu : bit, cc : bits(14), branch_type : bits(6), el : bits(2),
                              mispredict : bit, valid : bits(2),
                              source_address : bits(64), target_address : bits(64))
begin
    // Shift the Branch Records in the buffer
    let nbrberecords : integer = <a href="shared_pseudocode.html#func_GetBRBENumRecords_0" title="">GetBRBENumRecords</a>();
    for i = nbrberecords - 1 downto 1 do
        <a href="shared_pseudocode.html#global_Records_SRC" title="">Records_SRC</a>[[i]] = <a href="shared_pseudocode.html#global_Records_SRC" title="">Records_SRC</a>[[i - 1]];
        <a href="shared_pseudocode.html#global_Records_TGT" title="">Records_TGT</a>[[i]] = <a href="shared_pseudocode.html#global_Records_TGT" title="">Records_TGT</a>[[i - 1]];
        <a href="shared_pseudocode.html#global_Records_INF" title="">Records_INF</a>[[i]] = <a href="shared_pseudocode.html#global_Records_INF" title="">Records_INF</a>[[i - 1]];
    end;

    <a href="shared_pseudocode.html#global_Records_INF" title="">Records_INF</a>[[0]].CCU        = ccu;
    <a href="shared_pseudocode.html#global_Records_INF" title="">Records_INF</a>[[0]].CC         = cc;

    <a href="shared_pseudocode.html#global_Records_INF" title="">Records_INF</a>[[0]].EL         = el;
    <a href="shared_pseudocode.html#global_Records_INF" title="">Records_INF</a>[[0]].VALID      = valid;
    <a href="shared_pseudocode.html#global_Records_INF" title="">Records_INF</a>[[0]].MPRED      = mispredict;
    <a href="shared_pseudocode.html#global_Records_INF" title="">Records_INF</a>[[0]].TYPE       = branch_type;

    <a href="shared_pseudocode.html#global_Records_SRC" title="">Records_SRC</a>[[0]] = source_address;
    <a href="shared_pseudocode.html#global_Records_TGT" title="">Records_TGT</a>[[0]] = target_address;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.AArch64_BreakpointMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/AArch64_BreakpointMatch</h3>
      <p class="pseudocode">// AArch64_BreakpointMatch()
// =========================
// Breakpoint matching in an AArch64 translation regime.
// Returns BreakpointInfo structure that contains breakpoint type, a boolean to indicate the
// type of breakpoint, matched address and whether the breakpoint is active and matched
// successfully. For Address Mismatch breakpoints, the returned boolean is the inverted result.

func <a id="func_AArch64_BreakpointMatch_4"/>AArch64_BreakpointMatch(n : integer, vaddress : bits(64), accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                             size : integer) =&gt; <a href="shared_pseudocode.html#type_BreakpointInfo" title="">BreakpointInfo</a>
begin
    assert !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    assert n &lt; <a href="shared_pseudocode.html#func_NumBreakpointsImplemented_0" title="">NumBreakpointsImplemented</a>();
    var brkptinfo : <a href="shared_pseudocode.html#type_BreakpointInfo" title="">BreakpointInfo</a>;

    let linking_enabled : boolean = (DBGBCR_EL1(n).BT IN {'0x11', '1xx1'} ||
                                     (IsFeatureImplemented(FEAT_ABLE) &amp;&amp; DBGBCR_EL1(n).BT2 == '1'));

    // A breakpoint that has linking enabled does not generate debug events in isolation
    if linking_enabled then
        brkptinfo.bptype = <a href="shared_pseudocode.html#enum_BreakpointType_Inactive" title="">BreakpointType_Inactive</a>;
        brkptinfo.match = FALSE;
        return brkptinfo;
    end;

    let enabled : boolean    = <a href="shared_pseudocode.html#func_IsBreakpointEnabled_1" title="">IsBreakpointEnabled</a>(n);
    let linked : boolean     = DBGBCR_EL1(n).BT == '0x01';
    let isbreakpnt : boolean = TRUE;
    let linked_to : boolean  = FALSE;
    let from_linking_enabled : boolean = FALSE;
    let lbnx : bits(2) = if IsFeatureImplemented(FEAT_Debugv8p9) then DBGBCR_EL1(n).LBNX else '00';
    let linked_n : integer{} = UInt(lbnx :: DBGBCR_EL1(n).LBN);
    let ssce : bit = if IsFeatureImplemented(FEAT_RME) then DBGBCR_EL1(n).SSCE else '0';
    let state_match = <a href="shared_pseudocode.html#func_AArch64_StateMatch_9" title="">AArch64_StateMatch</a>(DBGBCR_EL1(n).SSC, ssce, DBGBCR_EL1(n).HMC,
                                         DBGBCR_EL1(n).PMC, linked, linked_n, isbreakpnt,
                                         vaddress, accdesc);

    var (bp_type, value_match) = AArch64_BreakpointValueMatch(n, vaddress, linked_to, isbreakpnt,
                                                              from_linking_enabled);

    if <a href="shared_pseudocode.html#func_HaveAArch32_0" title="">HaveAArch32</a>() &amp;&amp; size == 4 then                    // Check second halfword
        // If the breakpoint address and BAS of an Address breakpoint match the address of the
        // second halfword of an instruction, but not the address of the first halfword, it is
        // CONSTRAINED UNPREDICTABLE whether or not this breakpoint generates a Breakpoint debug
        // event.
        let (-, match_i) = AArch64_BreakpointValueMatch(n, vaddress + 2, linked_to, isbreakpnt,
                                                        from_linking_enabled);
        if !value_match &amp;&amp; match_i then
            value_match = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BPMATCHHALF" title="">Unpredictable_BPMATCHHALF</a>);
        end;
    end;

    if vaddress[1] == '1' &amp;&amp; DBGBCR_EL1(n).BAS == '1111' then
        // The above notwithstanding, if DBGBCR_EL1(n).BAS == '1111', then it is CONSTRAINED
        // UNPREDICTABLE whether or not a Breakpoint debug event is generated for an instruction
        // at the address DBGBVR_EL1(n)+2.
        if value_match then
            value_match = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BPMATCHHALF" title="">Unpredictable_BPMATCHHALF</a>);
        end;
    end;

    if !(state_match &amp;&amp; enabled) then
        brkptinfo.bptype = <a href="shared_pseudocode.html#enum_BreakpointType_Inactive" title="">BreakpointType_Inactive</a>;
        brkptinfo.match = FALSE;
    else
        brkptinfo.bptype = bp_type;
        brkptinfo.match = value_match;
    end;
    return brkptinfo;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.AArch64_BreakpointValueMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/AArch64_BreakpointValueMatch</h3>
      <p class="pseudocode">// AArch64_BreakpointValueMatch()
// ==============================
// Returns breakpoint type to indicate the type of breakpoint and a boolean to indicate
// whether the breakpoint matched successfully. For Address Mismatch breakpoints, the
// returned boolean is the inverted result. If the breakpoint type return value is Inactive,
// then the boolean result is FALSE.

func AArch64_BreakpointValueMatch(n_in : integer, vaddress : bits(64),
                                  linked_to : boolean, isbreakpnt : boolean,
                                  from_linking_enabled : boolean
                                 ) =&gt; (BreakpointType, boolean) recurselimit 2
begin

    // "n_in" is the identity of the breakpoint unit to match against.
    // "vaddress" is the current instruction address, ignored if linked_to is TRUE and for Context
    //   matching breakpoints.
    // "linked_to" is TRUE if this is a call from StateMatch for linking.
    // "isbreakpnt"  TRUE is this is a call from BreakpointMatch or from StateMatch for a
    // linked breakpoint or from BreakpointValueMatch for a linked breakpoint with linking enabled.
    // "from_linking_enabled" is TRUE if this is a call from BreakpointValueMatch for a linked
    // breakpoint with linking enabled.
    var n : integer = n_in;
    var c : Constraint;
    var dbgtype : bits(5);

    // If a non-existent breakpoint then it is CONSTRAINED UNPREDICTABLE whether this gives
    // no match or the breakpoint is mapped to another UNKNOWN implemented breakpoint.
    if n &gt;= NumBreakpointsImplemented() then
        (c, n) = ConstrainUnpredictableInteger(0, NumBreakpointsImplemented() - 1,
                                               Unpredictable_BPNOTIMPL);
        assert c IN {Constraint_DISABLED, Constraint_UNKNOWN};
        if c == Constraint_DISABLED then return (BreakpointType_Inactive, FALSE); end;
    end;

    // If this breakpoint is not enabled, it cannot generate a match.
    // (This could also happen on a call from StateMatch for linking).
    if !IsBreakpointEnabled(n) then return (BreakpointType_Inactive, FALSE); end;

    // If BT is set to a reserved type, behaves either as disabled or as a not-reserved type.
    if IsFeatureImplemented(FEAT_ABLE) then
        dbgtype = DBGBCR_EL1(n).[BT2,BT];
    else
        dbgtype = '0' :: DBGBCR_EL1(n).BT;
    end;

    (c, dbgtype) = AArch64_ReservedBreakpointType(n, dbgtype);
    if c == Constraint_DISABLED then return (BreakpointType_Inactive, FALSE); end;
    // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    // Determine what to compare against.
    let match_addr : boolean      = (dbgtype == 'x0x0x');
    let mismatch : boolean        = (dbgtype == 'x010x');
    let match_vmid : boolean      = (dbgtype == 'x10xx');
    let match_cid : boolean       = (dbgtype == 'x001x');
    let match_cid1 : boolean      = (dbgtype IN {'x101x', 'xx11x'});
    let match_cid2 : boolean      = (dbgtype == 'x11xx');
    let linking_enabled : boolean = (dbgtype IN {'xxx11', 'x1xx1', '1xxxx'});

    // If this is a call from StateMatch, return FALSE if the breakpoint is not
    // programmed with linking enabled.
    if linked_to &amp;&amp; !linking_enabled then
        return (BreakpointType_Inactive, FALSE);
    end;

    // If called from BreakpointMatch return FALSE for breakpoint with linking enabled.
    if !linked_to &amp;&amp; linking_enabled then
        return (BreakpointType_Inactive, FALSE);
    end;

    let linked : boolean = (dbgtype == 'x0x01');
    if from_linking_enabled then  // A breakpoint with linking enabled has called this function.
        assert linked_to &amp;&amp; isbreakpnt;
        if linked then
            // A breakpoint with linking enabled is linked to a linked breakpoint. This is
            // architecturally UNPREDICTABLE, but treated as disabled in the pseudo code to
            // avoid potential recursion in BreakpointValueMatch().
            return (BreakpointType_Inactive, FALSE);
        end;
    end;

    // If a linked breakpoint is linked to an address matching breakpoint,
    // the behavior is CONSTRAINED UNPREDICTABLE.
    if linked_to &amp;&amp; match_addr &amp;&amp; isbreakpnt then
        if !ConstrainUnpredictableBool(Unpredictable_BPLINKEDADDRMATCH) then
            return (BreakpointType_Inactive, FALSE);
        end;
    end;

    // A breakpoint programmed for address mismatch does not match in AArch32 state.
    if mismatch &amp;&amp; UsingAArch32() then
        return (BreakpointType_Inactive, FALSE);
    end;

    var bvr_match : boolean  = FALSE;
    var bxvr_match : boolean = FALSE;
    var bp_type : BreakpointType;
    var mask : integer{0..31};

    if IsFeatureImplemented(FEAT_BWE) then
        mask = UInt(DBGBCR_EL1(n).MASK);

        // If the mask is set to a reserved value, the behavior is CONSTRAINED UNPREDICTABLE.
        if mask IN {1, 2} then
            (c, mask) = (ConstrainUnpredictableInteger(3, 31, Unpredictable_RESBPMASK)
                             as (Constraint, integer{3..31}));
            assert c IN {Constraint_DISABLED, Constraint_NONE, Constraint_UNKNOWN};
            case c of
                when Constraint_DISABLED =&gt; return (BreakpointType_Inactive, FALSE);  // Disabled
                when Constraint_NONE =&gt;     mask = 0;                                 // No masking
                // Otherwise the value returned by ConstrainUnpredictableBits must
                // be a not-reserved value.
            end;
        end;

        if mask != 0 then
            // When DBGBCR_EL1(n).MASK is a valid nonzero value, the behavior is
            // CONSTRAINED UNPREDICTABLE if any of the following are true:
            //     - DBGBCR_EL1(n).[BT2,BT] is programmed for a Context matching breakpoint.
            //     - DBGBCR_EL1(n).BAS is not '1111' and AArch32 is supported at EL0.
            if ((match_cid || match_cid1 || match_cid2) ||
                (DBGBCR_EL1(n).BAS != '1111' &amp;&amp; HaveAArch32())) then
                if !ConstrainUnpredictableBool(Unpredictable_BPMASK) then
                    return (BreakpointType_Inactive, FALSE);
                end;
            end;
        else
            // A stand-alone mismatch of a single address is not supported.
            if mismatch then
                return (BreakpointType_Inactive, FALSE);
            end;
        end;

    else
        mask = 0;
    end;

    // Do the comparison.
    if match_addr then
        var byte_select_match : boolean;
        let byte : integer = UInt(vaddress[1:0]);

        if HaveAArch32() then
            // T32 instructions can be executed at EL0 in an AArch64 translation regime.
            assert byte IN {0,2};                       // "vaddress" is halfword aligned
            byte_select_match = (DBGBCR_EL1(n).BAS[byte] == '1');
        else
            assert byte == 0;                           // "vaddress" is word aligned
            byte_select_match = TRUE;                   // DBGBCR_EL1(n).BAS[byte] is RES1
        end;

        // When FEAT_LVA3 is not implemented, if the DBGBVR_EL1(n).RESS field bits are not a
        // sign extension of the MSB of DBGBVR_EL1(n).VA, it is UNPREDICTABLE whether they
        // appear to be included in the match.
        // If 'vaddress' is outside of the current virtual address space, then the access
        // generates a Translation fault.
        let dbgtop : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = DebugAddrTop();
        let unpredictable_ress : boolean = (dbgtop &lt; 55 &amp;&amp; !IsOnes(DBGBVR_EL1(n)[63:dbgtop]) &amp;&amp;
                                            !IsZero(DBGBVR_EL1(n)[63:dbgtop]) &amp;&amp;
                                      ConstrainUnpredictableBool(Unpredictable_DBGxVR_RESS));
        let cmpmsb : integer{} = if unpredictable_ress then 63 else dbgtop;
        let cmplsb : integer{} = if mask &gt; 2 then mask else 2;
        bvr_match = ((vaddress[cmpmsb:cmplsb] == DBGBVR_EL1(n)[cmpmsb:cmplsb]) &amp;&amp;
                     byte_select_match);
        if mask &gt; 2 then
            // If masked bits of DBGBVR_EL1(n) are not zero, the behavior
            // is CONSTRAINED UNPREDICTABLE.
            let masktop : integer{} = mask - 1;
            if bvr_match &amp;&amp; !IsZero(DBGBVR_EL1(n)[masktop:2]) then
                bvr_match = ConstrainUnpredictableBool(Unpredictable_BPMASKEDBITS);
            end;
        end;

    elsif match_cid then
        if IsInHost() then
            bvr_match = (CONTEXTIDR_EL2()[31:0] == DBGBVR_EL1(n)[31:0]);
        else
            bvr_match = (PSTATE.EL IN {EL0, EL1} &amp;&amp; CONTEXTIDR_EL1()[31:0] == DBGBVR_EL1(n)[31:0]);
        end;

    elsif match_cid1 then
        bvr_match = (PSTATE.EL IN {EL0, EL1} &amp;&amp; !IsInHost() &amp;&amp;
                     CONTEXTIDR_EL1()[31:0] == DBGBVR_EL1(n)[31:0]);
    end;

    if match_vmid then
        let vmid : bits(16) = VMID();
        var bvr_vmid : bits(16);

        if !IsFeatureImplemented(FEAT_VMID16) || VTCR_EL2().VS == '0' then
            bvr_vmid = ZeroExtend{16}(DBGBVR_EL1(n)[39:32]);
        else
            bvr_vmid = DBGBVR_EL1(n)[47:32];
        end;

        bxvr_match = (PSTATE.EL IN {EL0, EL1} &amp;&amp; EL2Enabled() &amp;&amp; !IsInHost() &amp;&amp; vmid == bvr_vmid);

    elsif match_cid2 then
        bxvr_match = (PSTATE.EL != EL3 &amp;&amp; EL2Enabled() &amp;&amp;
                      DBGBVR_EL1(n)[63:32] == CONTEXTIDR_EL2()[31:0]);
    end;

    let bvr_match_valid : boolean  = (match_addr || match_cid || match_cid1);
    let bxvr_match_valid : boolean = (match_vmid || match_cid2);

    var value_match : boolean = ((!bxvr_match_valid || bxvr_match) &amp;&amp;
                                 (!bvr_match_valid || bvr_match));

    // A watchpoint might be linked to a linked address matching breakpoint with linking enabled,
    // which is in turn linked to a context matching breakpoint.
    if linked_to &amp;&amp; linked then
        // If called from StateMatch and breakpoint is a linked breakpoint then it must be a
        // watchpoint that is linked to an address matching breakpoint which is linked to a
        // context matching breakpoint.
        assert !isbreakpnt &amp;&amp; match_addr &amp;&amp; IsFeatureImplemented(FEAT_ABLE);
        let lbnx : bits(2) = (if IsFeatureImplemented(FEAT_Debugv8p9) then DBGBCR_EL1(n).LBNX
                                                                      else '00');
        let linked_linked_n : integer{} = UInt(lbnx :: DBGBCR_EL1(n).LBN);
        var linked_value_match : boolean;
        let linked_vaddress = ARBITRARY : bits(64);
        let linked_linked_to = TRUE;
        let linked_isbreakpnt = TRUE;
        let linked_from_linking_enabled = TRUE;
        (bp_type, linked_value_match) = AArch64_BreakpointValueMatch(linked_linked_n,
                                                                     linked_vaddress,
                                                                     linked_linked_to,
                                                                     linked_isbreakpnt,
                                                                     linked_from_linking_enabled);
        value_match = value_match &amp;&amp; linked_value_match;
    end;

    if match_addr &amp;&amp; !mismatch then
        bp_type = BreakpointType_AddrMatch;
    elsif match_addr &amp;&amp; mismatch then
        bp_type = BreakpointType_AddrMismatch;
    elsif match_vmid || match_cid || match_cid1 || match_cid2 then
        bp_type = BreakpointType_CtxtMatch;
    else
        unreachable;
    end;

    return (bp_type, value_match);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.AArch64_ReservedBreakpointType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/AArch64_ReservedBreakpointType</h3>
      <p class="pseudocode">// AArch64_ReservedBreakpointType()
// ================================
// Checks if the given DBGBCR_EL1(n).[BT2,BT] values are reserved and will
// generate Constrained Unpredictable behavior, otherwise returns Constraint_NONE.

func <a id="func_AArch64_ReservedBreakpointType_2"/>AArch64_ReservedBreakpointType(n : integer, bt_in : bits(5)) =&gt; (<a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>, bits(5))
begin
    var bt : bits(5)            = bt_in;
    var reserved : boolean      = FALSE;
    let context_aware : boolean = <a href="shared_pseudocode.html#func_IsContextAwareBreakpoint_1" title="">IsContextAwareBreakpoint</a>(n);

    if bt[4] == '0' then
        // Context matching
        if bt != '00x0x' &amp;&amp; !context_aware then
            reserved = TRUE;
        end;

        // EL2 extension
        if bt == '01xxx' &amp;&amp; !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            reserved = TRUE;
        end;

        // Context matching
        if (bt IN {'0011x','011xx'} &amp;&amp; !IsFeatureImplemented(FEAT_VHE) &amp;&amp;
              !IsFeatureImplemented(FEAT_Debugv8p2)) then
            reserved = TRUE;
        end;

        // Reserved
        if bt == '0010x' &amp;&amp; !IsFeatureImplemented(FEAT_BWE) &amp;&amp; !<a href="shared_pseudocode.html#func_HaveAArch32EL_1" title="">HaveAArch32EL</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
            reserved = TRUE;
        end;
    else
        // Reserved
        if bt != '10x0x' then
            reserved = TRUE;
        end;
    end;

    if reserved then
        var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;
        (c, bt) = ConstrainUnpredictableBits{5}(<a href="shared_pseudocode.html#enum_Unpredictable_RESBPTYPE" title="">Unpredictable_RESBPTYPE</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then
            return (c, ARBITRARY : bits(5));
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value
        end;
    end;

    return (<a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>, bt);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.AArch64_StateMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/AArch64_StateMatch</h3>
      <p class="pseudocode">// AArch64_StateMatch()
// ====================
// Determine whether a breakpoint or watchpoint is enabled in the current mode and state.

func <a id="func_AArch64_StateMatch_9"/>AArch64_StateMatch(ssc_in : bits(2), ssce_in : bit, hmc_in : bit,
                        pxc_in : bits(2), linked_in : boolean, linked_n_in : integer,
                        isbreakpnt : boolean, vaddress : bits(64),
                        accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_RME) then assert ssce_in == '0'; end;

    // "ssc_in","ssce_in","hmc_in","pxc_in" are the control fields from
    // the DBGBCR_EL1(n) or DBGWCR_EL1(n) register.
    // "linked_in" is TRUE if this is a linked breakpoint/watchpoint type.
    // "linked_n_in" is the linked breakpoint number from the DBGBCR_EL1(n) or
    // DBGWCR_EL1(n) register.
    // "isbreakpnt" is TRUE for breakpoints, FALSE for watchpoints.
    // "vaddress" is the program counter for a linked watchpoint or the same value passed to
    // AArch64_CheckBreakpoint for a linked breakpoint.
    // "accdesc" describes the properties of the access being matched.
    var ssc : bits(2)      = ssc_in;
    var ssce : bit         = ssce_in;
    var hmc : bit          = hmc_in;
    var pxc : bits(2)      = pxc_in;
    var linked : boolean   = linked_in;
    var linked_n : integer = linked_n_in;

    // If parameters are set to a reserved type, behaves as either disabled or a defined type
    var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;
    (c, ssc, ssce, hmc, pxc) = <a href="shared_pseudocode.html#func_CheckValidStateMatch_5" title="">CheckValidStateMatch</a>(ssc, ssce, hmc, pxc, isbreakpnt);
    if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then return FALSE; end;
    // Otherwise the hmc,ssc,ssce,pxc values are either valid or the values returned by
    // CheckValidStateMatch are valid.

    let EL3_match : boolean = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; hmc == '1' &amp;&amp; ssc[0] == '0';
    let EL2_match : boolean = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; ((hmc == '1' &amp;&amp; (ssc::pxc != '1000')) || ssc == '11');
    let EL1_match : boolean = pxc[0] == '1';
    let EL0_match : boolean = pxc[1] == '1';

    var priv_match : boolean;
    case accdesc.el of
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  priv_match = EL3_match;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  priv_match = EL2_match;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  priv_match = EL1_match;
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;  priv_match = EL0_match;
    end;

    // Security state match
    var ss_match : boolean;
    case ssce::ssc of
        when '000' =&gt; ss_match = hmc == '1' || accdesc.ss != <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a>;
        when '001' =&gt; ss_match = accdesc.ss == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;
        when '010' =&gt; ss_match = (hmc == '1' &amp;&amp; accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a>) || accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
        when '011' =&gt; ss_match = (hmc == '1' &amp;&amp; accdesc.ss != <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a>) || accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
        when '101' =&gt; ss_match = accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a>;
    end;

    var linked_match : boolean = FALSE;

    if linked then
        // "linked_n" must be an enabled context-aware breakpoint unit. If it is not context-aware
        // then it is CONSTRAINED UNPREDICTABLE whether this gives no match, gives a match without
        // linking, or linked_n is mapped to some UNKNOWN breakpoint that is context-aware.
        if !<a href="shared_pseudocode.html#func_IsContextAwareBreakpoint_1" title="">IsContextAwareBreakpoint</a>(linked_n) then
            let (first_ctx_cmp, last_ctx_cmp) : (integer, integer) = <a href="shared_pseudocode.html#func_ContextAwareBreakpointRange_0" title="">ContextAwareBreakpointRange</a>();
            (c, linked_n) = <a href="shared_pseudocode.html#func_ConstrainUnpredictableInteger_3" title="">ConstrainUnpredictableInteger</a>(first_ctx_cmp, last_ctx_cmp,
                                                          <a href="shared_pseudocode.html#enum_Unpredictable_BPNOTCTXCMP" title="">Unpredictable_BPNOTCTXCMP</a>);
            assert c IN {<a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};

            case c of
                when <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> =&gt; return FALSE;   // Disabled
                when <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>     =&gt; linked = FALSE; // No linking
                // Otherwise ConstrainUnpredictableInteger returned a context-aware breakpoint
            end;
        end;
    end;

    if linked then
        let linked_to : boolean = TRUE;
        var bp_type : <a href="shared_pseudocode.html#type_BreakpointType" title="">BreakpointType</a>;
        let from_linking_enabled : boolean = FALSE;
        (bp_type, linked_match) = AArch64_BreakpointValueMatch(linked_n, vaddress,
                                                               linked_to, isbreakpnt,
                                                               from_linking_enabled);
        if bp_type == <a href="shared_pseudocode.html#enum_BreakpointType_AddrMismatch" title="">BreakpointType_AddrMismatch</a> then
            linked_match = !linked_match;
        end;
    end;

    return priv_match &amp;&amp; ss_match &amp;&amp; (!linked || linked_match);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.DebugAddrTop"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/DebugAddrTop</h3>
      <p class="pseudocode">// DebugAddrTop()
// ==============
// Returns the value for the top bit used in Breakpoint and Watchpoint address comparisons.

func DebugAddrTop() =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    if IsFeatureImplemented(FEAT_LVA3) then
        return 55;
    elsif IsFeatureImplemented(FEAT_LVA) then
        return 52;
    else
        return 48;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.EffectiveMDSELR_EL1_BANK"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/EffectiveMDSELR_EL1_BANK</h3>
      <p class="pseudocode">// EffectiveMDSELR_EL1_BANK()
// ==========================
// Return the effective value of MDSELR_EL1.BANK.

func <a id="func_EffectiveMDSELR_EL1_BANK_0"/>EffectiveMDSELR_EL1_BANK() =&gt; bits(2)
begin
    // If 16 or fewer breakpoints and 16 or fewer watchpoints are implemented,
    // then the field is RES0.
    let num_bp : integer = <a href="shared_pseudocode.html#func_NumBreakpointsImplemented_0" title="">NumBreakpointsImplemented</a>();
    let num_wp : integer = <a href="shared_pseudocode.html#func_NumWatchpointsImplemented_0" title="">NumWatchpointsImplemented</a>();
    if num_bp &lt;= 16 &amp;&amp; num_wp &lt;= 16 then
        return '00';
    end;

    // At EL3, the Effective value of this field is zero if MDCR_EL3.EBWE is 0.
    // At EL2, the Effective value is zero if the Effective value of MDCR_EL2.EBWE is 0.
    // That is, if either MDCR_EL3.EBWE is 0 or MDCR_EL2.EBWE is 0.
    // At EL1, the Effective value is zero if the Effective value of MDSCR_EL2.EMBWE is 0.
    // That is, if any of MDCR_EL3.EBWE, MDCR_EL2.EBWE, or MDSCR_EL1.EMBWE is 0.
    if ((<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; MDCR_EL3().EBWE == '0') ||
          (PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; MDCR_EL2().EBWE == '0') ||
          (PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; MDSCR_EL1().EMBWE == '0')) then
        return '00';
    end;

    var bank : bits(2) = MDSELR_EL1().BANK;

    // Values are reserved depending on the number of breakpoints or watchpoints
    // implemented.
    if ((bank == '11' &amp;&amp; num_bp &lt;= 48 &amp;&amp; num_wp &lt;= 48) ||
          (bank == '10' &amp;&amp; num_bp &lt;= 32 &amp;&amp; num_wp &lt;= 32)) then
        // Reserved value
        (-, bank) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_RESMDSELR" title="">Unpredictable_RESMDSELR</a>);
        // The value returned by ConstrainUnpredictableBits must be a not-reserved value
    end;

    return bank;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.IsBreakpointEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/IsBreakpointEnabled</h3>
      <p class="pseudocode">// IsBreakpointEnabled()
// =====================
// Returns TRUE if the effective value of DBGBCR_EL1(n).E is '1', and FALSE otherwise.

func <a id="func_IsBreakpointEnabled_1"/>IsBreakpointEnabled(n : integer) =&gt; boolean
begin
    if (n &gt; 15 &amp;&amp;
          ((!<a href="shared_pseudocode.html#func_HaltOnBreakpointOrWatchpoint_0" title="">HaltOnBreakpointOrWatchpoint</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_SelfHostedExtendedBPWPEnabled_0" title="">SelfHostedExtendedBPWPEnabled</a>()) ||
          (<a href="shared_pseudocode.html#func_HaltOnBreakpointOrWatchpoint_0" title="">HaltOnBreakpointOrWatchpoint</a>() &amp;&amp; EDSCR2().EHBWE == '0'))) then
        return FALSE;
    end;

    return DBGBCR_EL1(n).E == '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.SelfHostedExtendedBPWPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/SelfHostedExtendedBPWPEnabled</h3>
      <p class="pseudocode">// SelfHostedExtendedBPWPEnabled()
// ===============================
// Returns TRUE if the extended breakpoints and watchpoints are enabled, and FALSE otherwise
// from a self-hosted debug perspective.

func <a id="func_SelfHostedExtendedBPWPEnabled_0"/>SelfHostedExtendedBPWPEnabled() =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_NumBreakpointsImplemented_0" title="">NumBreakpointsImplemented</a>() &lt;= 16 &amp;&amp; <a href="shared_pseudocode.html#func_NumWatchpointsImplemented_0" title="">NumWatchpointsImplemented</a>() &lt;= 16 then
        return FALSE;
    end;

    if ((<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; MDCR_EL3().EBWE == '0') ||
          (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; MDCR_EL2().EBWE == '0')) then
        return FALSE;
    end;

    return MDSCR_EL1().EMBWE == '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.ebep"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/ebep</h3>
      <p class="pseudocode">var <a id="global_sync_counter_overflowed"/>sync_counter_overflowed : boolean;

var <a id="global_inst_addr_executed"/>inst_addr_executed : bits(64);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.ebep.CheckForPMUException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/ebep/CheckForPMUException</h3>
      <p class="pseudocode">// CheckForPMUException()
// ======================
// Take a PMU exception if enabled, permitted, and unmasked.

func CheckForPMUException()
begin
    var enabled : boolean;
    var target_el : bits(2);
    var pmu_exception : boolean;
    var synchronous : boolean;
    (enabled, target_el) = <a href="shared_pseudocode.html#func_PMUExceptionEnabled_0" title="">PMUExceptionEnabled</a>();
    if !enabled || <a href="shared_pseudocode.html#func_PMUExceptionMasked_3" title="">PMUExceptionMasked</a>(target_el, PSTATE.EL, PSTATE.PM) then
        pmu_exception = FALSE;
    elsif IsFeatureImplemented(FEAT_SEBEP) &amp;&amp; PSTATE.PPEND == '1' then
        pmu_exception = TRUE;
        synchronous = TRUE;
    else
        let include_r1 : boolean = TRUE;
        let include_r2 : boolean = TRUE;
        let include_r3 : boolean = TRUE;
        pmu_exception = <a href="shared_pseudocode.html#func_CheckPMUOverflowCondition_4" title="">CheckPMUOverflowCondition</a>(<a href="shared_pseudocode.html#enum_PMUOverflowCondition_PMUException" title="">PMUOverflowCondition_PMUException</a>,
                                                  include_r1, include_r2, include_r3);
        synchronous = FALSE;
    end;
    if pmu_exception then
        let fsc : bits(5) = '00000';
        TakeProfilingException(target_el, fsc, synchronous);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.ebep.EffectivePMEE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/ebep/EffectivePMEE</h3>
      <p class="pseudocode">// EffectivePMEE()
// ===============
// Return the Effective value of PMEE from MDCR_ELx or PMECR_EL1, handling reserved encodings:
// '10' (MDCR_ELx), '10' and '01' (PMECR_EL1).

func <a id="func_EffectivePMEE_2"/>EffectivePMEE(el : bits(2), for_interrupt : boolean) =&gt; bits(2)
begin
    var val : bits(2);
    case el of
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>  =&gt; val = PMECR_EL1().PMEE;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>  =&gt; val = MDCR_EL2().PMEE;
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>  =&gt; val = MDCR_EL3().PMEE;
        otherwise =&gt; unreachable;
    end;

    if (val == '10' || (el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; val == '01')) then
        var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;
        (c, val) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_RESPMEE" title="">Unpredictable_RESPMEE</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then
            val = if for_interrupt then '11' else '00';
            // Otherwise the value returned by ConstrainUnpredictableBits must be
            // a non-reserved value
        end;
    end;
    return val;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.ebep.ExceptionReturnPPEND"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/ebep/ExceptionReturnPPEND</h3>
      <p class="pseudocode">// ExceptionReturnPPEND()
// ======================
// Sets ShouldSetPPEND to the value to write to PSTATE.PPEND
// on an exception return.
// This function is called before any change in Exception level.

func ExceptionReturnPPEND(spsr : bits(64))
begin
    var enabled_at_source : boolean;
    var masked_at_source : boolean;
    if spsr[33] == '1' then                             // SPSR.PPEND
        var target_except : bits(2);
        (enabled_at_source, target_except) = <a href="shared_pseudocode.html#func_PMUExceptionEnabled_0" title="">PMUExceptionEnabled</a>();
        if <a href="shared_pseudocode.html#func_Restarting_0" title="">Restarting</a>() then
            masked_at_source = TRUE;
        else
            masked_at_source = <a href="shared_pseudocode.html#func_PMUExceptionMasked_3" title="">PMUExceptionMasked</a>(target_except, PSTATE.EL, PSTATE.PM);
        end;

        var target_eret : bits(2);
        if <a href="shared_pseudocode.html#func_IllegalExceptionReturn_2" title="">IllegalExceptionReturn</a>{64}(spsr) then
            target_eret = PSTATE.EL;
        else
            var valid : boolean;
            (valid, target_eret) = <a href="shared_pseudocode.html#func_ELFromSPSR_2" title="">ELFromSPSR</a>{64}(spsr);
            assert valid;
        end;

        let target_pm : bit = spsr[32];              // SPSR.PM
        let masked_at_dest : boolean = <a href="shared_pseudocode.html#func_PMUExceptionMasked_3" title="">PMUExceptionMasked</a>(target_except, target_eret, target_pm);
        if enabled_at_source &amp;&amp; masked_at_source &amp;&amp; !masked_at_dest then
            PSTATE.PPEND = '1';
            <a href="shared_pseudocode.html#global_ShouldSetPPEND" title="">ShouldSetPPEND</a> = FALSE;
            // PSTATE.PPEND will not be changed again by this instruction.
        end;
    end;

    // If PSTATE.PPEND has not been set by this function, ShouldSetPPEND is
    // unchanged, meaning PSTATE.PPEND might either be set by the current instruction
    // causing a counter overflow, or cleared to zero at the end of instruction.

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.ebep.IsSupportingPMUSynchronousMode"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/ebep/IsSupportingPMUSynchronousMode</h3>
      <p class="pseudocode">// IsSupportingPMUSynchronousMode()
// ================================
// Returns TRUE if the event support synchronous mode,
// and FALSE otherwise.

impdef func <a id="func_IsSupportingPMUSynchronousMode_1"/>IsSupportingPMUSynchronousMode(pmuevent : bits(16)) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.ebep.PMUExceptionEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/ebep/PMUExceptionEnabled</h3>
      <p class="pseudocode">// PMUExceptionEnabled()
// =====================
// The first return value is TRUE if the PMU exception is enabled, and FALSE otherwise.
// The second return value is the target Exception level for an enabled PMU exception.

func <a id="func_PMUExceptionEnabled_0"/>PMUExceptionEnabled() =&gt; (boolean, bits(2))
begin

    if !IsFeatureImplemented(FEAT_EBEP) then
        return (FALSE, ARBITRARY : bits(2));
    end;

    var enabled : boolean;
    var target : bits(2) = ARBITRARY : bits(2);
    let for_interrupt : boolean = FALSE;
    let pmee_el3 : bits(2) = <a href="shared_pseudocode.html#func_EffectivePMEE_2" title="">EffectivePMEE</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, for_interrupt);
    let pmee_el2 : bits(2) = <a href="shared_pseudocode.html#func_EffectivePMEE_2" title="">EffectivePMEE</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, for_interrupt);
    let pmee_el1 : bits(2) = <a href="shared_pseudocode.html#func_EffectivePMEE_2" title="">EffectivePMEE</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, for_interrupt);

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; pmee_el3 != '01' then
        enabled = pmee_el3 == '11';
        if enabled then target = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>; end;

    elsif <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; pmee_el2 != '01' then
        enabled = pmee_el2 == '11';
        if enabled then target = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>; end;

    else
        enabled = pmee_el1 == '11';
        if enabled then
            target = if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
        end;
    end;

    return (enabled, target);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.ebep.PMUExceptionMasked"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/ebep/PMUExceptionMasked</h3>
      <p class="pseudocode">// PMUExceptionMasked()
// ====================
// Return TRUE if the PMU Exception is masked at the specified target Exception level
// relative to the specified source Exception level, and by the value of PSTATE.PM,
// and FALSE otherwise.

func <a id="func_PMUExceptionMasked_3"/>PMUExceptionMasked(target_el : bits(2), from_el : bits(2), pm : bit) =&gt; boolean
begin
    assert IsFeatureImplemented(FEAT_EBEP);
    let for_interrupt : boolean = FALSE;

    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        return TRUE;
    elsif UInt(target_el) &lt; UInt(from_el) then
        return TRUE;
    elsif (from_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> &amp;&amp;
             <a href="shared_pseudocode.html#func_EffectivePMEE_2" title="">EffectivePMEE</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, for_interrupt) != '11') then
        return TRUE;
    elsif target_el == from_el &amp;&amp; (PMECR_EL1().KPME == '0' || pm == '1') then
        return TRUE;
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.ebep.PMUInterruptEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/ebep/PMUInterruptEnabled</h3>
      <p class="pseudocode">// PMUInterruptEnabled()
// =====================
// Return TRUE if the PMU interrupt request (PMUIRQ) is enabled, FALSE otherwise.

func <a id="func_PMUInterruptEnabled_0"/>PMUInterruptEnabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_EBEP) then
        return TRUE;
    end;

    var enabled : boolean;
    let for_interrupt : boolean = TRUE;
    let pmee_el3 : bits(2) = <a href="shared_pseudocode.html#func_EffectivePMEE_2" title="">EffectivePMEE</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, for_interrupt);
    let pmee_el2 : bits(2) = <a href="shared_pseudocode.html#func_EffectivePMEE_2" title="">EffectivePMEE</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, for_interrupt);
    let pmee_el1 : bits(2) = <a href="shared_pseudocode.html#func_EffectivePMEE_2" title="">EffectivePMEE</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, for_interrupt);

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; pmee_el3 != '01' then
        enabled = pmee_el3 == '00';

    elsif <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; pmee_el2 != '01' then
        enabled = pmee_el2 == '00';

    else
        enabled = pmee_el1 == '00';
    end;

    return enabled;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.enables.AArch64_GenerateDebugExceptions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/enables/AArch64_GenerateDebugExceptions</h3>
      <p class="pseudocode">// AArch64_GenerateDebugExceptions()
// =================================

func <a id="func_AArch64_GenerateDebugExceptions_0"/>AArch64_GenerateDebugExceptions() =&gt; boolean
begin
    let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();
    return <a href="shared_pseudocode.html#func_AArch64_GenerateDebugExceptionsFrom_3" title="">AArch64_GenerateDebugExceptionsFrom</a>(PSTATE.EL, ss, PSTATE.D);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.enables.AArch64_GenerateDebugExceptionsFrom"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/enables/AArch64_GenerateDebugExceptionsFrom</h3>
      <p class="pseudocode">// AArch64_GenerateDebugExceptionsFrom()
// =====================================

func <a id="func_AArch64_GenerateDebugExceptionsFrom_3"/>AArch64_GenerateDebugExceptionsFrom(from_el : bits(2), from_state : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>,
                                         mask : bit) =&gt; boolean
begin

    if OSLSR_EL1().OSLK == '1' || <a href="shared_pseudocode.html#func_DoubleLockStatus_0" title="">DoubleLockStatus</a>() || <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        return FALSE;
    end;

    let route_to_el2 : boolean = (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp;
                                  (from_state != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> || <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>()) &amp;&amp;
                                  (HCR_EL2().TGE == '1' || MDCR_EL2().TDE == '1'));
    let target : bits(2) = (if route_to_el2 then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
    var enabled : boolean;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; from_state == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
        enabled = MDCR_EL3().SDD == '0';
        if from_el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
            enabled = enabled || SDER32_EL3().SUIDEN == '1';
        end;
    else
        enabled = TRUE;
    end;

    if from_el == target then
        enabled = enabled &amp;&amp; MDSCR_EL1().KDE == '1' &amp;&amp; mask == '0';
    else
        enabled = enabled &amp;&amp; UInt(target) &gt; UInt(from_el);
    end;

    return enabled;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.ite.AArch64_TRCIT"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/ite/AArch64_TRCIT</h3>
      <p class="pseudocode">// AArch64_TRCIT()
// ===============
// Determines whether an Instrumentation trace packet should
// be generated and then generates an instrumentation trace packet
// containing the value of the register passed as an argument

func AArch64_TRCIT(Xt : bits(64))
begin
    let ss = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();
    if <a href="shared_pseudocode.html#func_TraceInstrumentationAllowed_2" title="">TraceInstrumentationAllowed</a>(ss, PSTATE.EL) then
        TraceInstrumentation(Xt);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.ite.TraceInstrumentation"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/ite/TraceInstrumentation</h3>
      <p class="pseudocode">// TraceInstrumentation()
// ======================
// Generates an instrumentation trace packet
// containing the value of the register passed as an argument

impdef func TraceInstrumentation(Xt : bits(64))
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64_IncrementCycleCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64_IncrementCycleCounter</h3>
      <p class="pseudocode">// AArch64_IncrementCycleCounter()
// ===============================
// Increment the cycle counter and possibly set overflow bits.

func AArch64_IncrementCycleCounter()
begin
    if !<a href="shared_pseudocode.html#func_CountPMUEvents_1" title="">CountPMUEvents</a>(<a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a>) then return; end;
    var d : bit = PMCR_EL0().D;   // Check divide-by-64
    var lc : bit = PMCR_EL0().LC;
    var lc_enabled : boolean;
    (lc_enabled, -) = <a href="shared_pseudocode.html#func_PMUExceptionEnabled_0" title="">PMUExceptionEnabled</a>();
    lc = if lc_enabled then '1' else lc;
    // Effective value of 'D' bit is 0 when Effective value of LC is '1'
    if lc == '1' then d = '0'; end;
    if d == '1' &amp;&amp; !<a href="shared_pseudocode.html#func_HasElapsed64Cycles_0" title="">HasElapsed64Cycles</a>() then return; end;

    let old_value : integer = UInt(PMCCNTR_EL0());
    let new_value : integer = old_value + 1;
    PMCCNTR_EL0() = new_value[63:0];

    let ovflw : integer{} = if <a href="shared_pseudocode.html#func_HaveAArch32_0" title="">HaveAArch32</a>() &amp;&amp; lc == '0' then 32 else 64;

    if old_value[64:ovflw] != new_value[64:ovflw] then
        PMOVSSET_EL0().C = '1';
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64_IncrementEventCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64_IncrementEventCounter</h3>
      <p class="pseudocode">// AArch64_IncrementEventCounter()
// ===============================
// Increment the specified event counter 'idx' by the specified amount 'increment'.
// 'Vm' is the value event counter 'idx-1' is being incremented by if 'idx' is odd,
// zero otherwise.
// Returns the amount the counter was incremented by.

func <a id="func_AArch64_IncrementEventCounter_3"/>AArch64_IncrementEventCounter(idx : integer, increment_in : integer, Vm : integer) =&gt; integer
begin
    var old_value : integer;
    var new_value : integer;

    old_value = UInt(PMEVCNTR_EL0(idx));
    let increment : integer = <a href="shared_pseudocode.html#func_PMUCountValue_3" title="">PMUCountValue</a>(idx, increment_in, Vm);
    new_value = old_value + increment;

    var lp : bit;
    if IsFeatureImplemented(FEAT_PMUv3p5) then
        PMEVCNTR_EL0(idx) = new_value[63:0];
        var pmuexception_enabled : boolean;
        (pmuexception_enabled, -) = <a href="shared_pseudocode.html#func_PMUExceptionEnabled_0" title="">PMUExceptionEnabled</a>();
        if pmuexception_enabled then
            lp = '1';
        else
            case <a href="shared_pseudocode.html#func_GetPMUCounterRange_1" title="">GetPMUCounterRange</a>(idx) of
                when <a href="shared_pseudocode.html#enum_PMUCounterRange_R1" title="">PMUCounterRange_R1</a> =&gt;
                    lp = PMCR_EL0().LP;
                when <a href="shared_pseudocode.html#enum_PMUCounterRange_R2" title="">PMUCounterRange_R2</a> =&gt;
                    lp = MDCR_EL2().HLP;
                when <a href="shared_pseudocode.html#enum_PMUCounterRange_R3" title="">PMUCounterRange_R3</a> =&gt;
                    lp = '1';
                otherwise =&gt;
                    unreachable;
            end;
        end;
    else
        lp = '0';
        PMEVCNTR_EL0(idx) = ZeroExtend{64}(new_value[31:0]);
    end;
    let ovflw : integer{} = if lp == '1' then 64 else 32;
    if old_value[64:ovflw] != new_value[64:ovflw] then
        PMOVSSET_EL0()[idx] = '1';
        // Check for the CHAIN event from an even counter
        if (idx[0] == '0' &amp;&amp; idx + 1 &lt; NUM_PMU_COUNTERS &amp;&amp; lp == '0' &amp;&amp;
              (<a href="shared_pseudocode.html#func_GetPMUCounterRange_1" title="">GetPMUCounterRange</a>(idx) == <a href="shared_pseudocode.html#func_GetPMUCounterRange_1" title="">GetPMUCounterRange</a>(idx+1) ||
                 <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_COUNT_CHAIN" title="">Unpredictable_COUNT_CHAIN</a>))) then
            // If PMU counters idx and idx+1 are not in same range,
            // it is CONSTRAINED UNPREDICTABLE if CHAIN event is counted
            PMUEvent(PMU_EVENT_CHAIN, 1, idx + 1);
        end;
    end;
    if (IsFeatureImplemented(FEAT_SEBEP) &amp;&amp;
            <a href="shared_pseudocode.html#func_IsSupportingPMUSynchronousMode_1" title="">IsSupportingPMUSynchronousMode</a>(PMEVTYPER_EL0(idx).evtCount) &amp;&amp;
            PMINTENSET_EL1()[idx] == '1' &amp;&amp; PMOVSSET_EL0()[idx] == '1' &amp;&amp; increment != 0) then
        <a href="shared_pseudocode.html#global_SyncCounterOverflowed" title="">SyncCounterOverflowed</a> = TRUE;
    end;

    return increment;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64_PMUCycle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64_PMUCycle</h3>
      <p class="pseudocode">// AArch64_PMUCycle()
// ==================
// Called at the end of each cycle to increment event counters and
// check for PMU overflow. In pseudocode, a cycle ends after the
// execution of the operational pseudocode.

func AArch64_PMUCycle()
begin
    if !IsFeatureImplemented(FEAT_PMUv3) then
        return;
    end;
    PMUEvent(PMU_EVENT_CPU_CYCLES);
    let counters : integer = NUM_PMU_COUNTERS;
    var Vm : integer = 0;
    if counters != 0 then
        for idx = 0 to counters - 1 do
            if <a href="shared_pseudocode.html#func_CountPMUEvents_1" title="">CountPMUEvents</a>(idx) then
                let accumulated : integer = <a href="shared_pseudocode.html#global_PMUEventAccumulator" title="">PMUEventAccumulator</a>[[idx]];
                if (idx MOD 2) == 0 then Vm = 0; end;
                Vm = <a href="shared_pseudocode.html#func_AArch64_IncrementEventCounter_3" title="">AArch64_IncrementEventCounter</a>(idx, accumulated, Vm);
            end;
            <a href="shared_pseudocode.html#global_PMUEventAccumulator" title="">PMUEventAccumulator</a>[[idx]] = 0;
        end;
    end;
    AArch64_IncrementCycleCounter();
    CheckForPMUOverflow();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.profilingexception.TakeProfilingException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/profilingexception/TakeProfilingException</h3>
      <p class="pseudocode">// TakeProfilingException()
// ========================
// Takes a Profiling exception.

func TakeProfilingException(target_el : bits(2), fsc : bits(5), synchronous : boolean)
begin
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_Profiling" title="">Exception_Profiling</a>);
    except.syndrome.iss[5:1] = fsc;
    if synchronous then
        except.syndrome.iss[0] = '1';
    end;

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CheckForSPEException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CheckForSPEException</h3>
      <p class="pseudocode">// CheckForSPEException()
// ======================
// Take an SPE Profiling exception if pending, permitted, and unmasked.

func CheckForSPEException()
begin
    if !IsFeatureImplemented(FEAT_SPE_EXC) then
        return;
    end;

    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() || <a href="shared_pseudocode.html#func_Restarting_0" title="">Restarting</a>() then
        return;
    end;

    var route_to_el3 : boolean = FALSE;
    var route_to_el2 : boolean = FALSE;
    var route_to_el1 : boolean = FALSE;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; MDCR_EL3().PMSEE == '1x' then
        let pending : boolean = PMBSR_EL3().S == '1';
        let masked : boolean = PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
        route_to_el3 = pending &amp;&amp; !masked;
    end;

    var owning_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>;
    var owning_el : bits(2);
    (owning_ss, owning_el) = <a href="shared_pseudocode.html#func_ProfilingBufferOwner_0" title="">ProfilingBufferOwner</a>();
    let in_owning_ss : boolean = <a href="shared_pseudocode.html#func_IsCurrentSecurityState_1" title="">IsCurrentSecurityState</a>(owning_ss);

    if <a href="shared_pseudocode.html#func_EffectivePMSCR_EL2_EE_0" title="">EffectivePMSCR_EL2_EE</a>() == '1x' then
        let pending : boolean = PMBSR_EL2().S == '1';
        let masked : boolean = (!in_owning_ss || PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> ||
                                   (PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> &amp;&amp; (PMSCR_EL2().EE != '11' ||
                                                         PMSCR_EL2().KE == '0' || PSTATE.PM == '1'))
                                );
        route_to_el2 = pending &amp;&amp; !masked;
    end;

    if <a href="shared_pseudocode.html#func_EffectivePMSCR_EL1_EE_0" title="">EffectivePMSCR_EL1_EE</a>() == '11' then
        let pending : boolean = PMBSR_EL1().S == '1';
        let masked : boolean = (!in_owning_ss || PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} ||
                                   (PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; (PMSCR_EL1().KE == '0' || PSTATE.PM == '1'))
                                );
        if <a href="shared_pseudocode.html#func_EffectiveTGE_0" title="">EffectiveTGE</a>() == '1' then
            route_to_el2 = route_to_el2 || (pending &amp;&amp; !masked);
        else
            route_to_el1 = pending &amp;&amp; !masked;
        end;
    end;

    let fsc : bits(5) = '00001';        // SPE exception
    let synchronous : boolean = FALSE;

    // The relative priorities of the following checks is IMPLEMENTATION DEFINED
    if route_to_el3 then
        TakeProfilingException(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, fsc, synchronous);
    end;
    if route_to_el2 then
        TakeProfilingException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, fsc, synchronous);
    end;
    if route_to_el1 then
        TakeProfilingException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, fsc, synchronous);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CheckMDCR_EL3_NSPBTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CheckMDCR_EL3_NSPBTrap</h3>
      <p class="pseudocode">// CheckMDCR_EL3_NSPBTrap()
// ========================
// Check if the register access is trappable by MDCR_EL3().[NSPBE, NSPB]

func <a id="func_CheckMDCR_EL3_NSPBTrap_0"/>CheckMDCR_EL3_NSPBTrap() =&gt; boolean
begin
    var state_bits : bits(3);
    var reserved : boolean;
    (state_bits, reserved) = <a href="shared_pseudocode.html#func_EffectiveMDCR_EL3_NSPB_0" title="">EffectiveMDCR_EL3_NSPB</a>();
    return ((reserved &amp;&amp; <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_RESERVEDNSxB_Trap" title="">Unpredictable_RESERVEDNSxB_Trap</a>)) ||
             state_bits[0] == '0' || state_bits[1] != SCR_EL3().NS ||
             (IsFeatureImplemented(FEAT_RME) &amp;&amp; state_bits[2] != SCR_EL3().NSE));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CollectContextIDR1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CollectContextIDR1</h3>
      <p class="pseudocode">// CollectContextIDR1()
// ====================

func <a id="func_CollectContextIDR1_0"/>CollectContextIDR1() =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_StatisticalProfilingEnabled_0" title="">StatisticalProfilingEnabled</a>() then return FALSE; end;
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then return FALSE; end;
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then return FALSE; end;
    return PMSCR_EL1().CX == '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CollectContextIDR2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CollectContextIDR2</h3>
      <p class="pseudocode">// CollectContextIDR2()
// ====================

func <a id="func_CollectContextIDR2_0"/>CollectContextIDR2() =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_StatisticalProfilingEnabled_0" title="">StatisticalProfilingEnabled</a>() then return FALSE; end;
    if !<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then return FALSE; end;
    return PMSCR_EL2().CX == '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CollectPhysicalAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CollectPhysicalAddress</h3>
      <p class="pseudocode">// CollectPhysicalAddress()
// ========================

func <a id="func_CollectPhysicalAddress_0"/>CollectPhysicalAddress() =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_StatisticalProfilingEnabled_0" title="">StatisticalProfilingEnabled</a>() then return FALSE; end;
    let (owning_ss, owning_el) : (<a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, bits(2)) = <a href="shared_pseudocode.html#func_ProfilingBufferOwner_0" title="">ProfilingBufferOwner</a>();
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; (owning_ss != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> || <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>()) then
        return PMSCR_EL2().PA == '1' &amp;&amp; (owning_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || PMSCR_EL1().PA == '1');
    else
        return PMSCR_EL1().PA == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CollectTimeStamp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CollectTimeStamp</h3>
      <p class="pseudocode">// CollectTimeStamp()
// ==================

func <a id="func_CollectTimeStamp_0"/>CollectTimeStamp() =&gt; <a href="shared_pseudocode.html#type_TimeStamp" title="">TimeStamp</a>
begin
    if !<a href="shared_pseudocode.html#func_StatisticalProfilingEnabled_0" title="">StatisticalProfilingEnabled</a>() then return <a href="shared_pseudocode.html#enum_TimeStamp_None" title="">TimeStamp_None</a>; end;
    let (-, owning_el) = <a href="shared_pseudocode.html#func_ProfilingBufferOwner_0" title="">ProfilingBufferOwner</a>();

    if owning_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        if PMSCR_EL2().TS == '0' then return <a href="shared_pseudocode.html#enum_TimeStamp_None" title="">TimeStamp_None</a>; end;
    else
        if PMSCR_EL1().TS == '0' then return <a href="shared_pseudocode.html#enum_TimeStamp_None" title="">TimeStamp_None</a>; end;
    end;

    var PCT_el1 : bits(2);
    if !IsFeatureImplemented(FEAT_ECV) then
        PCT_el1 = '0'::PMSCR_EL1().PCT[0];                         // PCT[1] is RES0
    else
        PCT_el1 = PMSCR_EL1().PCT;
        if PCT_el1 == '10' then
            // Reserved value
            (-, PCT_el1) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_PMSCR_PCT" title="">Unpredictable_PMSCR_PCT</a>);
        end;
    end;
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        var PCT_el2 : bits(2);
        if !IsFeatureImplemented(FEAT_ECV) then
            PCT_el2 = '0'::PMSCR_EL2().PCT[0];                     // PCT[1] is RES0
        else
            PCT_el2 = PMSCR_EL2().PCT;
            if PCT_el2 == '10' then
                // Reserved value
                (-, PCT_el2) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_PMSCR_PCT" title="">Unpredictable_PMSCR_PCT</a>);
            end;
        end;
        case PCT_el2 of
            when '00' =&gt;
                return if <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then <a href="shared_pseudocode.html#enum_TimeStamp_Physical" title="">TimeStamp_Physical</a> else <a href="shared_pseudocode.html#enum_TimeStamp_Virtual" title="">TimeStamp_Virtual</a>;
            when '01' =&gt;
                if owning_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then return <a href="shared_pseudocode.html#enum_TimeStamp_Physical" title="">TimeStamp_Physical</a>; end;
            when '11' =&gt;
                assert IsFeatureImplemented(FEAT_ECV);          // FEAT_ECV must be implemented
                if owning_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; PCT_el1 == '00' then
                    return if <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then <a href="shared_pseudocode.html#enum_TimeStamp_Physical" title="">TimeStamp_Physical</a> else <a href="shared_pseudocode.html#enum_TimeStamp_Virtual" title="">TimeStamp_Virtual</a>;
                else
                    return <a href="shared_pseudocode.html#enum_TimeStamp_OffsetPhysical" title="">TimeStamp_OffsetPhysical</a>;
                end;
            otherwise =&gt;
                unreachable;
        end;
    end;

    case PCT_el1 of
        when '00' =&gt; return if <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then <a href="shared_pseudocode.html#enum_TimeStamp_Physical" title="">TimeStamp_Physical</a> else <a href="shared_pseudocode.html#enum_TimeStamp_Virtual" title="">TimeStamp_Virtual</a>;
        when '01' =&gt; return <a href="shared_pseudocode.html#enum_TimeStamp_Physical" title="">TimeStamp_Physical</a>;
        when '11' =&gt;
            assert IsFeatureImplemented(FEAT_ECV);              // FEAT_ECV must be implemented
            return <a href="shared_pseudocode.html#enum_TimeStamp_OffsetPhysical" title="">TimeStamp_OffsetPhysical</a>;
        otherwise =&gt; unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.DefaultSPEEvent"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/DefaultSPEEvent</h3>
      <p class="pseudocode">// DefaultSPEEvent()
// =================
// Return the target ELx for an indirect write to PMBSR_ELx for an Other buffer management
// event or anything other than a buffer management event.

func <a id="func_DefaultSPEEvent_0"/>DefaultSPEEvent() =&gt; bits(2)
begin
    return <a href="shared_pseudocode.html#func_ReportSPEEvent_2" title="">ReportSPEEvent</a>(Zeros{6}, ARBITRARY : bits(6));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.EffectiveMDCR_EL3_NSPB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/EffectiveMDCR_EL3_NSPB</h3>
      <p class="pseudocode">// EffectiveMDCR_EL3_NSPB()
// ========================
// Return the Effective value of MDCR_EL3().[NSPBE, NSPB] field and whether it is a reserved value.

readonly func <a id="func_EffectiveMDCR_EL3_NSPB_0"/>EffectiveMDCR_EL3_NSPB() =&gt; (bits(3), boolean)
begin
    var state_bits : bits(3);
    var reserved : boolean = FALSE;

    if IsFeatureImplemented(FEAT_RME) then
        state_bits = MDCR_EL3().[NSPBE, NSPB];
        if state_bits == '10x' || (!IsFeatureImplemented(FEAT_Secure) &amp;&amp; state_bits == '00x') then
            // Reserved value
            reserved = TRUE;
            (-, state_bits) = ConstrainUnpredictableBits{3}(<a href="shared_pseudocode.html#enum_Unpredictable_RESERVEDNSxB" title="">Unpredictable_RESERVEDNSxB</a>);
        end;
    else
        state_bits = '0' :: MDCR_EL3().NSPB;
    end;

    return (state_bits, reserved);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.EffectivePMBLIMITR_EL1_nVM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/EffectivePMBLIMITR_EL1_nVM</h3>
      <p class="pseudocode">// EffectivePMBLIMITR_EL1_nVM()
// ============================

func <a id="func_EffectivePMBLIMITR_EL1_nVM_0"/>EffectivePMBLIMITR_EL1_nVM() =&gt; bit
begin
    if !IsFeatureImplemented(FEAT_SPE_nVM) then
        return '0';
    end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        let (owning_ss, owning_el) : (<a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, bits(2)) = <a href="shared_pseudocode.html#func_ProfilingBufferOwner_0" title="">ProfilingBufferOwner</a>();
        if ((owning_ss != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> || <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>()) &amp;&amp; owning_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp;
              PMSCR_EL2().EnVM == '0') then
            return '0';
        end;
    end;
    return PMBLIMITR_EL1().nVM;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.EffectivePMSCR_EL1_EE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/EffectivePMSCR_EL1_EE</h3>
      <p class="pseudocode">// EffectivePMSCR_EL1_EE()
// =======================
// Return the Effective value of PMSCR_EL1.EE for the purpose of controlling the
// SPE Profiling exception.

func <a id="func_EffectivePMSCR_EL1_EE_0"/>EffectivePMSCR_EL1_EE() =&gt; bits(2)
begin
    if <a href="shared_pseudocode.html#func_EffectivePMSCR_EL2_EE_0" title="">EffectivePMSCR_EL2_EE</a>() == '00' then
        return '00';
    end;

    var ee : bits(2) = PMSCR_EL1().EE;
    if ee IN {'01', '10'} then            // Reserved value
        if IsFeatureImplemented(FEAT_NV) then
            ee[0] = ee[1];
        else
            var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;
            (c, ee) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_RESPMSEE" title="">Unpredictable_RESPMSEE</a>);
            assert c IN {<a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};
            if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then
                ee = '00';
            end;
            // Otherwise the value returned by ConstrainUnpredictableBits must be
            // a non-reserved value
        end;
    end;

    return ee;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.EffectivePMSCR_EL2_EE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/EffectivePMSCR_EL2_EE</h3>
      <p class="pseudocode">// EffectivePMSCR_EL2_EE()
// =======================
// Return the Effective value of PMSCR_EL2.EE.

readonly func <a id="func_EffectivePMSCR_EL2_EE_0"/>EffectivePMSCR_EL2_EE() =&gt; bits(2)
begin
    if !IsFeatureImplemented(FEAT_SPE_EXC) then
        return '00';
    end;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; MDCR_EL3().PMSEE == '00' then
        return '00';
    end;

    let check_el2 : boolean = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; (<a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>() == '1' ||
                                                 <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>());
    return if check_el2 then PMSCR_EL2().EE else '01';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.GetPMBSR_EL1_FSC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/GetPMBSR_EL1_FSC</h3>
      <p class="pseudocode">// GetPMBSR_EL1_FSC()
// ==================
// Query the PMBSR_EL1.FSC field.

func <a id="func_GetPMBSR_EL1_FSC_0"/>GetPMBSR_EL1_FSC() =&gt; bits(6)
begin
    var FSC : bits(6);

    FSC = PMBSR_EL1()[5:0];
    return FSC;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.GetPMBSR_EL2_FSC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/GetPMBSR_EL2_FSC</h3>
      <p class="pseudocode">// GetPMBSR_EL2_FSC()
// ==================
// Query the PMBSR_EL2.FSC field.

func <a id="func_GetPMBSR_EL2_FSC_0"/>GetPMBSR_EL2_FSC() =&gt; bits(6)
begin
    var FSC : bits(6);

    FSC = PMBSR_EL2()[5:0];
    return FSC;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.GetPMBSR_EL3_FSC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/GetPMBSR_EL3_FSC</h3>
      <p class="pseudocode">// GetPMBSR_EL3_FSC()
// ==================
// Query the PMBSR_EL3.FSC field.

func <a id="func_GetPMBSR_EL3_FSC_0"/>GetPMBSR_EL3_FSC() =&gt; bits(6)
begin
    var FSC : bits(6);

    FSC = PMBSR_EL3()[5:0];
    return FSC;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.OtherSPEManagementEvent"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/OtherSPEManagementEvent</h3>
      <p class="pseudocode">// OtherSPEManagementEvent()
// =========================
// Report an Other buffer management event, with the status code 'bsc'

func OtherSPEManagementEvent(bsc : bits(6))
begin
    let target_el : bits(2) = <a href="shared_pseudocode.html#func_DefaultSPEEvent_0" title="">DefaultSPEEvent</a>();
    if <a href="shared_pseudocode.html#accessor_PMBSR_EL_1" title="">PMBSR_EL</a>(target_el).S == '0' then
        <a href="shared_pseudocode.html#accessor_PMBSR_EL_1" title="">PMBSR_EL</a>(target_el).S = '1';        // Assert interrupt or exception
        <a href="shared_pseudocode.html#accessor_PMBSR_EL_1" title="">PMBSR_EL</a>(target_el).EC = '000000';  // Other buffer management event
        <a href="shared_pseudocode.html#accessor_PMBSR_EL_1" title="">PMBSR_EL</a>(target_el).MSS = ZeroExtend{16}(bsc);
        <a href="shared_pseudocode.html#accessor_PMBSR_EL_1" title="">PMBSR_EL</a>(target_el).MSS2 = Zeros{24};
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.PMBSR_EL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/PMBSR_EL</h3>
      <p class="pseudocode">// PMBSR_EL - accessor
// ===================

accessor <a id="accessor_PMBSR_EL_1"/>PMBSR_EL(el : bits(2)) &lt;=&gt; value : PMBSRType
begin
    getter
        var r : bits(64);
        case el of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;   r = PMBSR_EL1();
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;   r = PMBSR_EL2();
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;   r = PMBSR_EL3();
            otherwise =&gt;  unreachable;
        end;
        return r;
    end;
    setter
        let r : bits(64) = value;
        case el of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;   PMBSR_EL1() = r;
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;   PMBSR_EL2() = r;
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;   PMBSR_EL3() = r;
            otherwise =&gt;  unreachable;
        end;
        return;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.ProfilingBufferEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/ProfilingBufferEnabled</h3>
      <p class="pseudocode">// ProfilingBufferEnabled()
// ========================

readonly func <a id="func_ProfilingBufferEnabled_0"/>ProfilingBufferEnabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_SPE) || <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        return FALSE;
    end;

    let (owning_ss, owning_el) : (<a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, bits(2)) = <a href="shared_pseudocode.html#func_ProfilingBufferOwner_0" title="">ProfilingBufferOwner</a>();
    let state_bits : bits(2) = <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NSE_0" title="">EffectiveSCR_EL3_NSE</a>() :: <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>();

    var state_match : boolean;
    case owning_ss of
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;     state_match = state_bits == '00';
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;  state_match = state_bits == '01';
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;      state_match = state_bits == '11';
    end;

    let stopped : boolean = <a href="shared_pseudocode.html#func_SPEProfilingStopped_0" title="">SPEProfilingStopped</a>();

    return (!<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(owning_el) &amp;&amp; state_match &amp;&amp;
            PMBLIMITR_EL1().E == '1' &amp;&amp; !stopped);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.ProfilingBufferOwner"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/ProfilingBufferOwner</h3>
      <p class="pseudocode">// ProfilingBufferOwner()
// ======================

readonly func <a id="func_ProfilingBufferOwner_0"/>ProfilingBufferOwner() =&gt; (<a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, bits(2))
begin
    var owning_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>;

    var state_bits : bits(3);
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        (state_bits, -) = <a href="shared_pseudocode.html#func_EffectiveMDCR_EL3_NSPB_0" title="">EffectiveMDCR_EL3_NSPB</a>();
    else
        state_bits = if <a href="shared_pseudocode.html#func_SecureOnlyImplementation_0" title="">SecureOnlyImplementation</a>() then '001' else '011';
    end;

    case state_bits of
        when '00x' =&gt; owning_ss = <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
        when '01x' =&gt; owning_ss = <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;
        when '11x' =&gt; owning_ss = <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a>;
    end;

    var owning_el : bits(2);
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; (owning_ss != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> || <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>()) then
        owning_el = if MDCR_EL2().E2PB == '00' then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    else
        owning_el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    end;

    return (owning_ss, owning_el);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.ProfilingSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/ProfilingSynchronizationBarrier</h3>
      <p class="pseudocode">// ProfilingSynchronizationBarrier()
// =================================
// Barrier to ensure that all existing profiling data has been formatted, and profiling buffer
// addresses have been translated such that writes to the profiling buffer have been initiated.
// A following DSB completes when writes to the profiling buffer have completed.

impdef func ProfilingSynchronizationBarrier()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.ReportSPEEvent"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/ReportSPEEvent</h3>
      <p class="pseudocode">// ReportSPEEvent()
// ================
// Return the target ELx for an indirect write to PMBSR_ELx.
// When the indirect write is due to a buffer management event:
// 'ec_bits' is the Event Class for the management event.
// 'fsc_bits' is the Fault Status Code when this is a fault, ignored otherwise.
// Otherwise, 'ec_bits' should be Zeros().

func <a id="func_ReportSPEEvent_2"/>ReportSPEEvent(ec_bits : bits(6), fsc_bits : bits(6)) =&gt; bits(2)
begin
    var target_el : bits(2);
    var route_to_el3 : boolean = FALSE;
    var route_to_el2 : boolean = FALSE;

    if IsFeatureImplemented(FEAT_SPE_EXC) then
        let s1fault : boolean = (ec_bits == '100100');   // Stage 1 fault
        let s2fault : boolean = (ec_bits == '100101');   // Stage 2 fault

        var gpcfault, gpfault : boolean;
        if IsFeatureImplemented(FEAT_RME) then
            // Granule Protection Check fault, other than GPF. That is, a GPT address size fault,
            // GPT walk fault, or synchronous External abort on GPT fetch.
            gpcfault = (ec_bits == '011110');
            // Other Granule Protection Fault, reported as Stage 1 or Stage 2 fault.
            gpfault  =  ((s1fault || s2fault) &amp;&amp; fsc_bits IN {'10001x', '1001xx', '101000'});
        else
            gpcfault = FALSE;
            gpfault  = FALSE;
        end;
        let sync_ext_abort : boolean = ((s1fault || s2fault) &amp;&amp;
                                           fsc_bits IN {'010000', '01001x', '0101xx', '011011'});

        var owning_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>;
        var owning_el : bits(2);
        (owning_ss, owning_el) = <a href="shared_pseudocode.html#func_ProfilingBufferOwner_0" title="">ProfilingBufferOwner</a>();

        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; MDCR_EL3().PMSEE == '1x' then
            route_to_el3 = (MDCR_EL3().PMSEE == '11' ||
                            gpcfault || (gpfault &amp;&amp; SCR_EL3().GPF == '1') ||
                            (sync_ext_abort &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveEA_0" title="">EffectiveEA</a>() == '1'));
        end;

        if <a href="shared_pseudocode.html#func_EffectivePMSCR_EL2_EE_0" title="">EffectivePMSCR_EL2_EE</a>() == '1x' then
            route_to_el2 = (PMSCR_EL2().EE == '11' || (s1fault &amp;&amp; owning_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) || s2fault ||
                            gpcfault || (gpfault &amp;&amp; HCR_EL2().GPF == '1') ||
                            (sync_ext_abort &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveHCR_TEA_0" title="">EffectiveHCR_TEA</a>() == '1'));
        end;
    end;

    if route_to_el3 then
        target_el = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
    elsif route_to_el2 then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    else
        target_el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    end;

    return target_el;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPE</h3>
      <p class="pseudocode">// SPE Implementation Constants
// ============================

constant <a id="global_SPEMaxAddrs"/>SPEMaxAddrs : integer{} = 32;

constant <a id="global_SPEMaxCounters"/>SPEMaxCounters : integer{} = 32;

constant <a id="global_SPEMaxRecordSize"/>SPEMaxRecordSize : integer{} = 2048;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEAddByteToRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEAddByteToRecord</h3>
      <p class="pseudocode">// SPEAddByteToRecord()
// ====================
// Add one byte to a record and increase size property appropriately.

func SPEAddByteToRecord(b : bits(8))
begin
    assert <a href="shared_pseudocode.html#global_SPERecordSize" title="">SPERecordSize</a> &lt; <a href="shared_pseudocode.html#global_SPEMaxRecordSize" title="">SPEMaxRecordSize</a>;
    <a href="shared_pseudocode.html#global_SPERecordData" title="">SPERecordData</a>[[<a href="shared_pseudocode.html#global_SPERecordSize" title="">SPERecordSize</a>]] = b;
    <a href="shared_pseudocode.html#global_SPERecordSize" title="">SPERecordSize</a> = <a href="shared_pseudocode.html#global_SPERecordSize" title="">SPERecordSize</a> + 1;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEAddPacketToRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEAddPacketToRecord</h3>
      <p class="pseudocode">// SPEAddPacketToRecord()
// ======================
// Add passed header and payload data to the record.
// Payload must be a multiple of 8.

func SPEAddPacketToRecord{N}(header_hi : bits(2), header_lo : bits(4),
                             payload : bits(N))
begin
    assert N MOD 8 == 0;
    var sz : bits(2);
    case N of
        when 8 =&gt; sz  = '00';
        when 16 =&gt; sz = '01';
        when 32 =&gt; sz = '10';
        when 64 =&gt; sz = '11';
        otherwise =&gt; unreachable;
    end;

    let header : bits(8) = header_hi::sz::header_lo;
    SPEAddByteToRecord(header);
    for i = 0 to (N DIV 8)-1 do
        SPEAddByteToRecord(payload[i*:8]);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEBranch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEBranch</h3>
      <p class="pseudocode">// SPEBranch()
// ===========
// Called on every branch if SPE is present. Maintains previous branch target
// and branch related SPE functionality.

func SPEBranch{N}(target : bits(N), branch_type : <a href="shared_pseudocode.html#type_BranchType" title="">BranchType</a>, conditional : boolean,
                  taken_flag : boolean)
begin
    let is_isb : boolean = FALSE;
    SPEBranch{N}(target, branch_type, conditional, taken_flag, is_isb);
end;

func SPEBranch{N}(target : bits(N), branch_type : <a href="shared_pseudocode.html#type_BranchType" title="">BranchType</a>, conditional : boolean,
                  taken_flag : boolean, is_isb : boolean)
begin
    // If the PE implements branch prediction, data about (mis)prediction is collected
    // through the PMU events.

    var collect_prev_br : boolean;
    let collect_prev_br_eret : boolean = ImpDefBool("SPE prev br on eret");
    let collect_prev_br_exception : boolean = (ImpDefBool(
                                                  "SPE prev br on exception"));
    let collect_prev_br_isb : boolean = ImpDefBool("SPE prev br on isb");
    case branch_type of
        when <a href="shared_pseudocode.html#enum_BranchType_EXCEPTION" title="">BranchType_EXCEPTION</a> =&gt;
            collect_prev_br = collect_prev_br_exception;
        when <a href="shared_pseudocode.html#enum_BranchType_ERET" title="">BranchType_ERET</a> =&gt;
            collect_prev_br = collect_prev_br_eret;
        otherwise =&gt;
            collect_prev_br = !is_isb || collect_prev_br_isb;
    end;

    // Implements previous branch target functionality
    if (taken_flag &amp;&amp; IsFeatureImplemented(FEAT_SPE_PBT) &amp;&amp; <a href="shared_pseudocode.html#func_StatisticalProfilingEnabled_0" title="">StatisticalProfilingEnabled</a>() &amp;&amp;
            collect_prev_br) then

        if <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> then
            let previous_target : bits(64) = <a href="shared_pseudocode.html#global_SPESamplePreviousBranchAddress" title="">SPESamplePreviousBranchAddress</a>;
            <a href="shared_pseudocode.html#global_SPESampleAddress" title="">SPESampleAddress</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosPrevBranchTarget" title="">SPEAddrPosPrevBranchTarget</a>]][63:0] = previous_target[63:0];
            let previous_branch_valid : boolean = <a href="shared_pseudocode.html#global_SPESamplePreviousBranchAddressValid" title="">SPESamplePreviousBranchAddressValid</a>;
            <a href="shared_pseudocode.html#global_SPESampleAddressValid" title="">SPESampleAddressValid</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosPrevBranchTarget" title="">SPEAddrPosPrevBranchTarget</a>]] = previous_branch_valid;
        end;
        // Save the target address for it to be added to a future record.
        <a href="shared_pseudocode.html#global_SPESamplePreviousBranchAddress" title="">SPESamplePreviousBranchAddress</a>[55:0] = target[55:0];

        var ns : bit;
        var nse : bit;
        case <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() of
            when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;
                ns = '0';
                nse = '0';
            when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;
                ns = '1';
                nse = '0';
            when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;
                ns  = '1';
                nse = '1';
            otherwise =&gt; unreachable;
        end;

        <a href="shared_pseudocode.html#global_SPESamplePreviousBranchAddress" title="">SPESamplePreviousBranchAddress</a>[63] = ns;
        <a href="shared_pseudocode.html#global_SPESamplePreviousBranchAddress" title="">SPESamplePreviousBranchAddress</a>[60] = nse;
        <a href="shared_pseudocode.html#global_SPESamplePreviousBranchAddress" title="">SPESamplePreviousBranchAddress</a>[62:61] = PSTATE.EL;
        <a href="shared_pseudocode.html#global_SPESamplePreviousBranchAddressValid" title="">SPESamplePreviousBranchAddressValid</a>   = TRUE;
    end;

    if !<a href="shared_pseudocode.html#func_StatisticalProfilingEnabled_0" title="">StatisticalProfilingEnabled</a>() then
        if taken_flag then
            // Invalidate previous branch address, if profiling is disabled
            // or prohibited.
            <a href="shared_pseudocode.html#global_SPESamplePreviousBranchAddressValid" title="">SPESamplePreviousBranchAddressValid</a> = FALSE;
        end;
        return;
    end;

    if <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> then
        <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.branch_is_direct = branch_type IN {<a href="shared_pseudocode.html#enum_BranchType_DIR" title="">BranchType_DIR</a>, <a href="shared_pseudocode.html#enum_BranchType_DIRCALL" title="">BranchType_DIRCALL</a>};
        <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.branch_has_link  = branch_type IN {<a href="shared_pseudocode.html#enum_BranchType_DIRCALL" title="">BranchType_DIRCALL</a>, <a href="shared_pseudocode.html#enum_BranchType_INDCALL" title="">BranchType_INDCALL</a>};
        <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.procedure_return = branch_type == <a href="shared_pseudocode.html#enum_BranchType_RET" title="">BranchType_RET</a>;
        <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type          = <a href="shared_pseudocode.html#enum_SPEOpType_Branch" title="">SPEOpType_Branch</a>;
        <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_conditional   = conditional;
        <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.cond_pass        = taken_flag;

        // Save the target address.
        if taken_flag then
            var ns : bit;
            var nse : bit;
            case <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() of
                when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;
                    ns = '0';
                    nse = '0';
                when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;
                    ns = '1';
                    nse = '0';
                when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;
                    ns  = '1';
                    nse = '1';
                otherwise =&gt; unreachable;
            end;
            let el : bits(2) = PSTATE.EL;

            <a href="shared_pseudocode.html#global_SPESampleAddress" title="">SPESampleAddress</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosBranchTarget" title="">SPEAddrPosBranchTarget</a>]][55:0]  = target[55:0];
            <a href="shared_pseudocode.html#global_SPESampleAddress" title="">SPESampleAddress</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosBranchTarget" title="">SPEAddrPosBranchTarget</a>]][63:56] = ns::el::nse::Zeros{4};
            <a href="shared_pseudocode.html#global_SPESampleAddressValid" title="">SPESampleAddressValid</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosBranchTarget" title="">SPEAddrPosBranchTarget</a>]]   = TRUE;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEBufferIsFull"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEBufferIsFull</h3>
      <p class="pseudocode">// SPEBufferIsFull()
// =================
// Return true if another full size sample record would not fit in the
// profiling buffer.

func <a id="func_SPEBufferIsFull_0"/>SPEBufferIsFull() =&gt; boolean
begin
    let write_pointer_limit : integer = UInt(PMBLIMITR_EL1().LIMIT::Zeros{12});
    let current_write_pointer : integer = UInt(PMBPTR_EL1());
    let record_max_size : integer = 1&lt;&lt;UInt(PMSIDR_EL1().MaxSize);
    return current_write_pointer &gt; (write_pointer_limit - record_max_size);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPECollectRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPECollectRecord</h3>
      <p class="pseudocode">// SPECollectRecord()
// ==================
// Returns TRUE if the sampled class of instructions or operations, as
// determined by PMSFCR_EL1, are recorded and FALSE otherwise.

func <a id="func_SPECollectRecord_3"/>SPECollectRecord(events : bits(64), total_latency : integer, optype : <a href="shared_pseudocode.html#type_SPEOpType" title="">SPEOpType</a>) =&gt; boolean
begin
    // Filtering by events
    var is_rejected_event : boolean;
    var is_rejected_nevent : boolean;
    (is_rejected_event, is_rejected_nevent) = <a href="shared_pseudocode.html#func_SPEFilterByEvents_1" title="">SPEFilterByEvents</a>(events);

    // Filtering by type
    let is_rejected_type : boolean = <a href="shared_pseudocode.html#func_SPEFilterByType_1" title="">SPEFilterByType</a>(<a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>);

    // Filtering by latency
    let is_rejected_latency : boolean = <a href="shared_pseudocode.html#func_SPEFilterByLatency_1" title="">SPEFilterByLatency</a>(total_latency);

    let is_rejected_data_source : boolean = <a href="shared_pseudocode.html#func_SPEFilterByDataSource_1" title="">SPEFilterByDataSource</a>(optype);

    var return_value : boolean;
    return_value = !(is_rejected_nevent || is_rejected_event ||
                     is_rejected_type || is_rejected_latency ||
                     is_rejected_data_source);

    if return_value then
        PMUEvent(PMU_EVENT_SAMPLE_FILTRATE);
    end;

    return return_value;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPECompleteSample"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPECompleteSample</h3>
      <p class="pseudocode">// SPECompleteSample()
// ===================
// Called to complete the sampling process.

func SPECompleteSample()
begin
    assert <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a>;

    PMUEvent(PMU_EVENT_SAMPLE_FEED);

    // Stop any pending counters
    for counter_index = 0 to (<a href="shared_pseudocode.html#global_SPEMaxCounters" title="">SPEMaxCounters</a> - 1) do
        if <a href="shared_pseudocode.html#global_SPESampleCounterPending" title="">SPESampleCounterPending</a>[[counter_index]] then
            SPEStopCounter(counter_index);
        end;
    end;

    // Record any IMPLEMENTATION DEFINED events
    let impdef_events : bits(64) = ImpDefBits{}("SPE EVENTS");
    <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[63:48] = impdef_events[63:48];
    // The number of bits available for IMPLEMENTATION DEFINED events
    // is reduced by FEAT_SPEv1p4
    if !IsFeatureImplemented(FEAT_SPEv1p4) then
        <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[31:24] = impdef_events[31:24];
    end;
    <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[15:12] = impdef_events[15:12];
    // Bit 24 encodes whether the sample was collected in Streaming SVE mode.
    if IsFeatureImplemented(FEAT_SPE_SME) then
        <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[24] = PSTATE.SM;
    end;
    <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[6] = if (<a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_conditional &amp;&amp;
                                 !<a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.cond_pass) then '1' else '0';

    var collect_record : boolean;
    collect_record = <a href="shared_pseudocode.html#func_SPECollectRecord_3" title="">SPECollectRecord</a>(<a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>,
                                      <a href="shared_pseudocode.html#global_SPESampleCounter" title="">SPESampleCounter</a>[[<a href="shared_pseudocode.html#global_SPECounterPosTotalLatency" title="">SPECounterPosTotalLatency</a>]],
                                      <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type);
    var discard : boolean = FALSE;
    if IsFeatureImplemented(FEAT_SPEv1p2) then
        discard = PMBLIMITR_EL1().FM == '10';
    end;
    if collect_record &amp;&amp; !discard then
        SPEConstructRecord();
        if <a href="shared_pseudocode.html#func_SPEBufferIsFull_0" title="">SPEBufferIsFull</a>() then
            let bsc : bits(6) = '000001';     // Buffer full event
            OtherSPEManagementEvent(bsc);
            PMUEvent(PMU_EVENT_SAMPLE_BUFFER_FULL);
        end;
    end;

    <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> = FALSE;

    SPEResetSampleStorage();
end;

// Order of addresses in sample storage and architectural index values
constant <a id="global_SPEAddrPosPCVirtual"/>SPEAddrPosPCVirtual : integer = 0;

constant <a id="global_SPEAddrPosBranchTarget"/>SPEAddrPosBranchTarget : integer = 1;

constant <a id="global_SPEAddrPosDataVirtual"/>SPEAddrPosDataVirtual : integer = 2;

constant <a id="global_SPEAddrPosDataPhysical"/>SPEAddrPosDataPhysical : integer = 3;

constant <a id="global_SPEAddrPosPrevBranchTarget"/>SPEAddrPosPrevBranchTarget : integer = 4;

// Order of counters in sample storage and architectural index values
constant <a id="global_SPECounterPosTotalLatency"/>SPECounterPosTotalLatency : integer = 0;

constant <a id="global_SPECounterPosIssueLatency"/>SPECounterPosIssueLatency : integer = 1;

constant <a id="global_SPECounterPosTranslationLatency"/>SPECounterPosTranslationLatency : integer = 2;

constant <a id="global_SPECounterPosAltIssueLatency"/>SPECounterPosAltIssueLatency : integer = 4;

// Sample in-flight flag
var <a id="global_SPESampleInFlight"/>SPESampleInFlight : boolean = FALSE;

// Globally declared variables which store data about the sample.

// Context storage
var <a id="global_SPESampleContextEL1"/>SPESampleContextEL1 : bits(32);

var <a id="global_SPESampleContextEL1Valid"/>SPESampleContextEL1Valid : boolean;

var <a id="global_SPESampleContextEL2"/>SPESampleContextEL2 : bits(32);

var <a id="global_SPESampleContextEL2Valid"/>SPESampleContextEL2Valid : boolean;

// Counter storage
var <a id="global_SPESampleCounter"/>SPESampleCounter : array [[<a href="shared_pseudocode.html#global_SPEMaxCounters" title="">SPEMaxCounters</a>]] of integer;

var <a id="global_SPESampleCounterValid"/>SPESampleCounterValid : array [[<a href="shared_pseudocode.html#global_SPEMaxCounters" title="">SPEMaxCounters</a>]] of boolean;

var <a id="global_SPESampleCounterPending"/>SPESampleCounterPending : array [[<a href="shared_pseudocode.html#global_SPEMaxCounters" title="">SPEMaxCounters</a>]] of boolean;

// Address storage
var <a id="global_SPESampleAddress"/>SPESampleAddress : array [[<a href="shared_pseudocode.html#global_SPEMaxAddrs" title="">SPEMaxAddrs</a>]] of bits(64);

var <a id="global_SPESampleAddressValid"/>SPESampleAddressValid : array [[<a href="shared_pseudocode.html#global_SPEMaxAddrs" title="">SPEMaxAddrs</a>]] of boolean;

var <a id="global_SPESamplePreviousBranchAddress"/>SPESamplePreviousBranchAddress : bits(64);

var <a id="global_SPESamplePreviousBranchAddressValid"/>SPESamplePreviousBranchAddressValid : boolean;

// Data source storage
var <a id="global_SPESampleDataSource"/>SPESampleDataSource : bits(16);

var <a id="global_SPESampleDataSourceValid"/>SPESampleDataSourceValid : boolean;

// OpAttr storage
var <a id="global_SPESampleOpAttr"/>SPESampleOpAttr : <a href="shared_pseudocode.html#type_SPEOpAttr" title="">SPEOpAttr</a>;

// Timestamp storage
var <a id="global_SPESampleTimestamp"/>SPESampleTimestamp : bits(64);

var <a id="global_SPESampleTimestampValid"/>SPESampleTimestampValid : boolean;

// Event storage
var <a id="global_SPESampleEvents"/>SPESampleEvents : bits(64);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEConstructClass"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEConstructClass</h3>
      <p class="pseudocode">// SPEConstructClass()
// ===================
// Constructs the encodings for the class and subclass fields.

func <a id="func_SPEConstructClass_0"/>SPEConstructClass() =&gt; (bits(2), bits(8))
begin
    var op_class : bits(2);
    var op_subclass : bits(8);
    let cond : bit = if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_conditional then '1' else '0';
    let fp : bit = if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_floating_point then '1' else '0';
    let ldst : bit = if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type == <a href="shared_pseudocode.html#enum_SPEOpType_Store" title="">SPEOpType_Store</a> then '1' else '0';
    let ar : bit = if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_acquire_release then '1' else '0';
    let excl : bit = if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_exclusive then '1' else '0';
    let at : bit = if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.at then '1' else '0';
    let indirect : bit = if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.branch_is_direct then '0' else '1';
    let pred : bit = if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_predicated then '1' else '0';
    let sg : bit = if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_gather_scatter then '1' else '0';
    let evl : bits(3) = <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.evl;
    let simd : bit = if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_simd then '1' else '0';
    let ets : bits(4) = <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ets;
    // Since this implementation of SPE samples instruction instead of micro-operations, a
    // Branch with link or Procedure return instruction will never be recorded as a "Load/store,
    // GCS" format Operation Type packet. Therefore the COMMON bit is hard-wired to '1'.
    let common : bit = '1';
    if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type == <a href="shared_pseudocode.html#enum_SPEOpType_Other" title="">SPEOpType_Other</a> then
        op_class = '00';
        op_subclass = Zeros{5}::simd::fp::cond;
    elsif <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type == <a href="shared_pseudocode.html#enum_SPEOpType_OtherSVE" title="">SPEOpType_OtherSVE</a> then
        op_class = '00';
        op_subclass = '0'::evl::'1'::pred::fp::'0';
    elsif <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type == <a href="shared_pseudocode.html#enum_SPEOpType_OtherSME" title="">SPEOpType_OtherSME</a> then
        op_class = '00';
        op_subclass = '1'::ets[3:1]::'1'::ets[0]::fp::'0';
    elsif <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type == <a href="shared_pseudocode.html#enum_SPEOpType_Branch" title="">SPEOpType_Branch</a> then
        op_class = '10';
        var cr : bits(2) = '00';
        var gcs : bit = '0';
        if IsFeatureImplemented(FEAT_SPE_CRR) then
            if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.branch_has_link then
                cr = '01';
            elsif <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.procedure_return then
                cr = '10';
            else
                cr = '11';
            end;
        end;
        if IsFeatureImplemented(FEAT_GCS) then
            if (<a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type == <a href="shared_pseudocode.html#enum_SPELDSTType_GCS" title="">SPELDSTType_GCS</a> &amp;&amp;
               (<a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.branch_has_link || <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.procedure_return)) then
                gcs = '1';
            end;
        end;
        op_subclass = Zeros{3}::cr::gcs::indirect::cond;
    elsif <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type IN {<a href="shared_pseudocode.html#enum_SPEOpType_Load" title="">SPEOpType_Load</a>, <a href="shared_pseudocode.html#enum_SPEOpType_Store" title="">SPEOpType_Store</a>, <a href="shared_pseudocode.html#enum_SPEOpType_LoadAtomic" title="">SPEOpType_LoadAtomic</a>} then
        op_class = '01';
        case <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type of
            when <a href="shared_pseudocode.html#enum_SPELDSTType_NV2" title="">SPELDSTType_NV2</a> =&gt;
                op_subclass = '0011000'::ldst;
            when <a href="shared_pseudocode.html#enum_SPELDSTType_Extended" title="">SPELDSTType_Extended</a> =&gt;
                op_subclass = '000'::ar::excl::at::'1'::ldst;
            when <a href="shared_pseudocode.html#enum_SPELDSTType_General" title="">SPELDSTType_General</a> =&gt;
                op_subclass = Zeros{7}::ldst;
            when <a href="shared_pseudocode.html#enum_SPELDSTType_SIMDFP" title="">SPELDSTType_SIMDFP</a> =&gt;
                op_subclass = '0000010'::ldst;
            when <a href="shared_pseudocode.html#enum_SPELDSTType_SVESME" title="">SPELDSTType_SVESME</a> =&gt;
                op_subclass = sg::evl::'1'::pred::'0'::ldst;
            when <a href="shared_pseudocode.html#enum_SPELDSTType_Unspecified" title="">SPELDSTType_Unspecified</a> =&gt;
                op_subclass = '0001000'::ldst;
            when <a href="shared_pseudocode.html#enum_SPELDSTType_Tags" title="">SPELDSTType_Tags</a> =&gt;
                op_subclass = '0001010'::ldst;
            when <a href="shared_pseudocode.html#enum_SPELDSTType_MemCopy" title="">SPELDSTType_MemCopy</a> =&gt;
                op_subclass = '0010000'::ldst;
            when <a href="shared_pseudocode.html#enum_SPELDSTType_MemSet" title="">SPELDSTType_MemSet</a> =&gt;
                op_subclass = '00100101';
            when <a href="shared_pseudocode.html#enum_SPELDSTType_GCS" title="">SPELDSTType_GCS</a> =&gt;
                op_subclass = '01000'::common::'0'::ldst;
            when <a href="shared_pseudocode.html#enum_SPELDSTType_GCSSS2" title="">SPELDSTType_GCSSS2</a> =&gt;
                // GCSSS2 is converted to GCS, should not appear here
                unreachable;
            otherwise =&gt;
                unreachable;
        end;
    else
        unreachable;
    end;
    return (op_class, op_subclass);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEConstructRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEConstructRecord</h3>
      <p class="pseudocode">// SPEConstructRecord()
// ====================
// Create new record and populate it with packets using sample storage data.
// This is an example implementation, packets may appear in
// any order as long as the record ends with an End or Timestamp packet.

func SPEConstructRecord()
begin
    // Empty the record.
    SPEEmptyRecord();

    // Add contextEL1 if available
    if <a href="shared_pseudocode.html#global_SPESampleContextEL1Valid" title="">SPESampleContextEL1Valid</a> then
        SPEAddPacketToRecord{32}('01', '0100', <a href="shared_pseudocode.html#global_SPESampleContextEL1" title="">SPESampleContextEL1</a>);
    end;

     // Add contextEL2 if available
    if <a href="shared_pseudocode.html#global_SPESampleContextEL2Valid" title="">SPESampleContextEL2Valid</a> then
        SPEAddPacketToRecord{32}('01', '0101', <a href="shared_pseudocode.html#global_SPESampleContextEL2" title="">SPESampleContextEL2</a>);
    end;

    // Add valid counters
    for counter_index = 0 to (<a href="shared_pseudocode.html#global_SPEMaxCounters" title="">SPEMaxCounters</a> - 1) do
        if <a href="shared_pseudocode.html#global_SPESampleCounterValid" title="">SPESampleCounterValid</a>[[counter_index]] then
            if counter_index &gt;= 8 then
                // Need extended format
                SPEAddByteToRecord('001000'::counter_index[4:3]);
            end;
            // Check for overflow
            let large_counters : boolean = ImpDefBool("SPE 16bit counters");
            if large_counters then
                if <a href="shared_pseudocode.html#global_SPESampleCounter" title="">SPESampleCounter</a>[[counter_index]] &gt; 0xFFFF then
                    <a href="shared_pseudocode.html#global_SPESampleCounter" title="">SPESampleCounter</a>[[counter_index]] = 0xFFFF;
                end;
            else
                if <a href="shared_pseudocode.html#global_SPESampleCounter" title="">SPESampleCounter</a>[[counter_index]] &gt; 0xFFF then
                    <a href="shared_pseudocode.html#global_SPESampleCounter" title="">SPESampleCounter</a>[[counter_index]] = 0xFFF;
                end;
            end;

            // Add byte0 for short format (byte1 for extended format)
            SPEAddPacketToRecord{16}('10', '1'::counter_index[2:0],
                                     <a href="shared_pseudocode.html#global_SPESampleCounter" title="">SPESampleCounter</a>[[counter_index]][15:0]);
        end;
    end;

    // Add valid addresses
    if IsFeatureImplemented(FEAT_SPE_PBT) then
        // Under the some conditions, it is IMPLEMENTATION_DEFINED whether
        // previous branch packet is present.
        let include_prev_br : boolean = (ImpDefBool(
                                            "SPE get prev br if not br"));
        if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type != <a href="shared_pseudocode.html#enum_SPEOpType_Branch" title="">SPEOpType_Branch</a> &amp;&amp; !include_prev_br then
            <a href="shared_pseudocode.html#global_SPESampleAddressValid" title="">SPESampleAddressValid</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosPrevBranchTarget" title="">SPEAddrPosPrevBranchTarget</a>]] = FALSE;
        end;
    end;

    // Data Virtual address should not be collected if this was an NV2 access and Statistical
    // Profiling is disabled at EL2.
    if !<a href="shared_pseudocode.html#func_StatisticalProfilingEnabled_1" title="">StatisticalProfilingEnabled</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type == <a href="shared_pseudocode.html#enum_SPELDSTType_NV2" title="">SPELDSTType_NV2</a> then
        <a href="shared_pseudocode.html#global_SPESampleAddressValid" title="">SPESampleAddressValid</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosDataVirtual" title="">SPEAddrPosDataVirtual</a>]] = FALSE;
    end;

    for address_index = 0 to (<a href="shared_pseudocode.html#global_SPEMaxAddrs" title="">SPEMaxAddrs</a> - 1) do
        if <a href="shared_pseudocode.html#global_SPESampleAddressValid" title="">SPESampleAddressValid</a>[[address_index]] then
            if address_index &gt;= 8 then
                // Need extended format
                SPEAddByteToRecord('001000'::address_index[4:3]);
            end;
            // Add byte0 for short format (byte1 for extended format)
            SPEAddPacketToRecord{64}('10', '0'::address_index[2:0],
                                     <a href="shared_pseudocode.html#global_SPESampleAddress" title="">SPESampleAddress</a>[[address_index]]);
        end;
    end;

    // Add Data Source
    if <a href="shared_pseudocode.html#global_SPESampleDataSourceValid" title="">SPESampleDataSourceValid</a> then
        let ds_payload_size : integer{} = <a href="shared_pseudocode.html#func_SPEGetDataSourcePayloadSize_0" title="">SPEGetDataSourcePayloadSize</a>();
        SPEAddPacketToRecord{8 * ds_payload_size}('01', '0011',
                                                  <a href="shared_pseudocode.html#global_SPESampleDataSource" title="">SPESampleDataSource</a>[8*ds_payload_size-1:0]);
    end;

    var op_class : bits(2);
    var op_subclass : bits(8);
    (op_class, op_subclass) = <a href="shared_pseudocode.html#func_SPEConstructClass_0" title="">SPEConstructClass</a>();
    // Add operation details
    SPEAddPacketToRecord{8}('01', '10'::op_class, op_subclass);

    // Add events
    // Get size of payload in bytes.
    let payload_size : integer{} = <a href="shared_pseudocode.html#func_SPEGetEventsPayloadSize_0" title="">SPEGetEventsPayloadSize</a>();
    SPEAddPacketToRecord{8 * payload_size}('01', '0010', <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[8*payload_size-1:0]);

    // Add Timestamp to end the record if one is available.
    // Otherwise end with an End packet.
    if <a href="shared_pseudocode.html#global_SPESampleTimestampValid" title="">SPESampleTimestampValid</a> then
        SPEAddPacketToRecord{64}('01', '0001', <a href="shared_pseudocode.html#global_SPESampleTimestamp" title="">SPESampleTimestamp</a>);
    else
        SPEAddByteToRecord('00000001');
    end;

    // Add padding
    while <a href="shared_pseudocode.html#global_SPERecordSize" title="">SPERecordSize</a> MOD (1&lt;&lt;UInt(PMBIDR_EL1().Align)) != 0 looplimit 2048 do
        SPEAddByteToRecord(Zeros{8});
    end;
    SPEWriteToBuffer();
    CTI_SignalEvent(<a href="shared_pseudocode.html#enum_CrossTriggerIn_SPESample" title="">CrossTriggerIn_SPESample</a>);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPECycle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPECycle</h3>
      <p class="pseudocode">// SPECycle()
// ==========
// Function called at the end of every cycle. Responsible for asserting interrupts
// and advancing counters.

func SPECycle()
begin
    if !IsFeatureImplemented(FEAT_SPE) then
        return;
    end;

    // Increment pending counters
    if <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> then
        for i = 0 to (<a href="shared_pseudocode.html#global_SPEMaxCounters" title="">SPEMaxCounters</a> - 1) do
            if <a href="shared_pseudocode.html#global_SPESampleCounterPending" title="">SPESampleCounterPending</a>[[i]] then
                <a href="shared_pseudocode.html#global_SPESampleCounter" title="">SPESampleCounter</a>[[i]] = <a href="shared_pseudocode.html#global_SPESampleCounter" title="">SPESampleCounter</a>[[i]] + 1;
            end;
        end;
    end;

    // Assert PMBIRQ if appropriate.
    if <a href="shared_pseudocode.html#func_SPEInterruptEnabled_0" title="">SPEInterruptEnabled</a>() &amp;&amp; PMBSR_EL1().S == '1' then
        SetInterruptRequestLevel(<a href="shared_pseudocode.html#enum_InterruptID_PMBIRQ" title="">InterruptID_PMBIRQ</a>, HIGH);
    else
        SetInterruptRequestLevel(<a href="shared_pseudocode.html#enum_InterruptID_PMBIRQ" title="">InterruptID_PMBIRQ</a>, LOW);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEEmptyRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEEmptyRecord</h3>
      <p class="pseudocode">// SPEEmptyRecord()
// ================
// Reset record data.

func SPEEmptyRecord()
begin
    <a href="shared_pseudocode.html#global_SPERecordSize" title="">SPERecordSize</a> = 0;
    for i = 0 to (<a href="shared_pseudocode.html#global_SPEMaxRecordSize" title="">SPEMaxRecordSize</a> - 1) do
        <a href="shared_pseudocode.html#global_SPERecordData" title="">SPERecordData</a>[[i]] = Zeros{8};
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEEncodeETS"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEEncodeETS</h3>
      <p class="pseudocode">// SPEEncodeETS()
// ==============
// Encodes an integer tile size length into the ets field for the SPE operation type packet.

func <a id="func_SPEEncodeETS_1"/>SPEEncodeETS(size : integer) =&gt; bits(4)
begin
    var ets : bits(4);
    if size &lt;= 128 then
        ets = '0000';
    elsif size &lt;= 256 then
        ets = '0001';
    elsif size &lt;= 512 then
        ets = '0010';
    elsif size &lt;= 1024 then
        ets = '0011';
    elsif size &lt;= 2048 then
        ets = '0100';
    elsif size &lt;= 4096 then
        ets = '0101';
    elsif size &lt;= 8192 then
        ets = '0110';
    elsif size &lt;= 16384 then
        ets = '0111';
    elsif size &lt;= 32768 then
        ets = '1000';
    elsif size &lt;= 65536 then
        ets = '1001';
    elsif size &lt;= 131072 then
        ets = '1010';
    elsif size &lt;= 262144 then
        ets = '1011';
    else
        ets = '1111';
    end;
    return ets;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEEncodeEVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEEncodeEVL</h3>
      <p class="pseudocode">// SPEEncodeEVL()
// ==============
// Encodes an integer vector length into the evl field for the SPE operation type packet.

func <a id="func_SPEEncodeEVL_1"/>SPEEncodeEVL(vl : integer) =&gt; bits(3)
begin
    var evl : bits(3);
    if vl &lt;= 32 then
        evl = '000';
    elsif vl &lt;= 64 then
        evl = '001';
    elsif vl &lt;= 128 then
        evl = '010';
    elsif vl &lt;= 256 then
        evl = '011';
    elsif vl &lt;= 512 then
        evl = '100';
    elsif vl &lt;= 1024 then
        evl = '101';
    elsif vl &lt;= 2048 then
        evl = '110';
    else
        if IsFeatureImplemented(FEAT_SPE_SME) then
            evl = '111';
        else
            unreachable;
        end;
    end;
    return evl;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEEvent"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEEvent</h3>
      <p class="pseudocode">// SPEEvent()
// ==========
// Called when a PMU event is generated by the sampled structure.
// Sets appropriate bit in SPESampleStorage.events.

func SPEEvent(pmuevent : bits(16))
begin
    if !<a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> then
        return;
    end;
    case pmuevent of
        when PMU_EVENT_DSNP_HIT_RD =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[23] = '1';                                  // Snoop hit
            end;
        when PMU_EVENT_L1D_LFB_HIT_RD =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[22] = '1';                                  // Recent fetch
            end;
        when PMU_EVENT_L2D_LFB_HIT_RD =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[22] = '1';                                  // Recent fetch
            end;
        when PMU_EVENT_L3D_LFB_HIT_RD =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[22] = '1';                                  // Recent fetch
            end;
        when PMU_EVENT_LL_LFB_HIT_RD =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[22] = '1';                                  // Recent fetch
            end;
        when PMU_EVENT_L1D_CACHE_HITM_RD =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[21] = '1';                                  // Modified
            end;
        when PMU_EVENT_L2D_CACHE_HITM_RD =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[21] = '1';                                  // Modified
            end;
        when PMU_EVENT_L3D_CACHE_HITM_RD =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[21] = '1';                                  // Modified
            end;
        when PMU_EVENT_LL_CACHE_HITM_RD =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[21] = '1';                                  // Modified
            end;
        when PMU_EVENT_L2D_CACHE_LMISS_RD =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[20] = '1';                                  // L2 miss
            end;
        when PMU_EVENT_L2D_CACHE_RD =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[19] = '1';                                  // L2 access
            end;
        when PMU_EVENT_SVE_PRED_EMPTY_SPEC =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p1) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[18] = '1';                                  // Empty predicate
            end;
        when PMU_EVENT_SVE_PRED_NOT_FULL_SPEC =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p1) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[17] = '1';                                  // Partial predicate
            end;
        when PMU_EVENT_LDST_ALIGN_LAT =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p1) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[11] = '1';                                  // Misaligned
            end;
        when PMU_EVENT_REMOTE_ACCESS =&gt;         <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[10]  = '1';    // Remote access
        when PMU_EVENT_LL_CACHE_MISS =&gt;         <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[9]   = '1';    // LLC miss
        when PMU_EVENT_LL_CACHE =&gt;              <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[8]   = '1';    // LLC access
        when PMU_EVENT_BR_MIS_PRED =&gt;           <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[7]   = '1';    // Mispredicted
        when PMU_EVENT_BR_MIS_PRED_RETIRED =&gt;   <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[7]   = '1';    // Not taken
        when PMU_EVENT_DTLB_WALK =&gt;             <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[5]   = '1';    // TLB walk
        when PMU_EVENT_L1D_TLB =&gt;               <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[4]   = '1';    // TLB access
        when PMU_EVENT_L1D_CACHE_REFILL =&gt;
            if !IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[3] = '1';                                   // L1 refill
            end;
        when PMU_EVENT_L1D_CACHE_LMISS_RD =&gt;
            if IsFeatureImplemented(FEAT_SPEv1p4) then
                <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[3] = '1';                                   // L1 miss
            end;
        when PMU_EVENT_L1D_CACHE =&gt;             <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[2]   = '1';    // L1 access
        when PMU_EVENT_INST_RETIRED =&gt;          <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[1]   = '1';    // Retire
        when PMU_EVENT_EXC_TAKEN =&gt;             <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[0]   = '1';    // Exception
        otherwise =&gt; return;
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEFilterByDataSource"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEFilterByDataSource</h3>
      <p class="pseudocode">// SPEFilterByDataSource()
// =======================
// Carry out filtering by data source.

func <a id="func_SPEFilterByDataSource_1"/>SPEFilterByDataSource(optype : <a href="shared_pseudocode.html#type_SPEOpType" title="">SPEOpType</a>) =&gt; boolean
begin
    // Filtering by Data Source
    var is_rejected_data_source : boolean = FALSE;
    if (IsFeatureImplemented(FEAT_SPE_FDS) &amp;&amp; <a href="shared_pseudocode.html#global_SPESampleDataSourceValid" title="">SPESampleDataSourceValid</a> &amp;&amp;
       (optype IN {<a href="shared_pseudocode.html#enum_SPEOpType_Load" title="">SPEOpType_Load</a>, <a href="shared_pseudocode.html#enum_SPEOpType_LoadAtomic" title="">SPEOpType_LoadAtomic</a>})) then
        let data_source : bits(16) = <a href="shared_pseudocode.html#global_SPESampleDataSource" title="">SPESampleDataSource</a>;
        let index : integer = UInt(data_source[5:0]);
        let is_ds : boolean = PMSDSFR_EL1()[index] == '1';
        if is_ds then PMUEvent(PMU_EVENT_SAMPLE_FEED_DS); end;
        if PMSFCR_EL1().FDS == '1' then
            // Filtering by Data Source is enabled
            is_rejected_data_source = !is_ds;
        end;
    end;
    return is_rejected_data_source;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEFilterByEvents"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEFilterByEvents</h3>
      <p class="pseudocode">// SPEFilterByEvents()
// ===================
// Carries out filtering by the event bits.

func <a id="func_SPEFilterByEvents_1"/>SPEFilterByEvents(events : bits(64)) =&gt; (boolean, boolean)
begin
    // "mask" defines which Events packet bits are checked by the filter
    var mask : bits(64) = Zeros{};
    let impdef_mask : bits(64) = ImpDefBits{}("SPE mask");

    mask[63:48] = impdef_mask[63:48];
    if IsFeatureImplemented(FEAT_SPE_SME) &amp;&amp; IsFeatureImplemented(FEAT_SPEv1p4) then
        mask[25:24] = '11';                 // Streaming mode, SMCU
    end;
    if IsFeatureImplemented(FEAT_SPEv1p4) then
        mask[23:19] = '11111';              // Snoop hit, recent fetch, modified,
                                            // L2 miss, L2 access
    else
        mask[31:24] = impdef_mask[31:24];
    end;
    if IsFeatureImplemented(FEAT_SPEv1p1) &amp;&amp; IsFeatureImplemented(FEAT_SVE) then
        mask[18:17] = '11';                 // Predicates
    end;
    mask[15:12] = impdef_mask[15:12];
    if IsFeatureImplemented(FEAT_SPEv1p1) then
        mask[11] = '1';                     // Data alignment
    end;
    if IsFeatureImplemented(FEAT_SPEv1p4) then
        mask[10:8] = '111';                 // Remote access, LLC access, LLC miss
    else
        mask[10:8] = impdef_mask[10:8];
    end;
    mask[7] = '1';                          // Mispredicted
    if IsFeatureImplemented(FEAT_SPE_FnE) then
        mask[6] = '1';                      // Not taken
    end;
    mask[5,3,1] = '111';                    // TLB walk, L1 miss, retired
    if IsFeatureImplemented(FEAT_SPEv1p4) then
        mask[4,2] = '11';                   // TLB access, L1 access
    else
        mask[4,2] = impdef_mask[4,2];
    end;

    let e : bits(64) = events AND mask;

    // Filtering by event
    let evfr : bits(64) = PMSEVFR_EL1() AND mask;
    var is_rejected_event : boolean = FALSE;
    let is_evt : boolean = IsZero(NOT(e) AND evfr);
    if PMSFCR_EL1().FE == '1' then
        // Filtering by event is enabled
        if !IsZero(evfr) then
            // Not a CONSTRAINED UNPREDICTABLE case
            is_rejected_event = !is_evt;
        else
            is_rejected_event = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BADPMSFCR" title="">Unpredictable_BADPMSFCR</a>);
        end;
    end;

    // Filtering by inverse event
    var is_rejected_nevent : boolean = FALSE;
    var is_nevt : boolean;
    if IsFeatureImplemented(FEAT_SPE_FnE) then
        let nevfr : bits(64) = PMSNEVFR_EL1() AND mask;
        is_nevt = IsZero(e AND nevfr);
        if PMSFCR_EL1().FnE == '1' then
            // Inverse filtering by event is enabled
            if !IsZero(nevfr) then
                // Not a CONSTRAINED UNPREDICTABLE case
                is_rejected_nevent = !is_nevt;
            else
                is_rejected_nevent = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BADPMSFCR" title="">Unpredictable_BADPMSFCR</a>);
            end;
        end;
    else
        is_nevt = TRUE; // not implemented
    end;
    if is_evt &amp;&amp; is_nevt then
        PMUEvent(PMU_EVENT_SAMPLE_FEED_EVENT);
    end;
    if (IsFeatureImplemented(FEAT_SPE_FnE) &amp;&amp; PMSFCR_EL1().[FnE,FE]== '11' &amp;&amp;
          !IsZero(PMSEVFR_EL1() AND PMSNEVFR_EL1() AND mask)) then
        // CONSTRAINED UNPREDICTABLE case due to combination of filter and inverse filter
        is_rejected_nevent = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BADPMSFCR" title="">Unpredictable_BADPMSFCR</a>);
        is_rejected_event = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BADPMSFCR" title="">Unpredictable_BADPMSFCR</a>);
    end;

    return (is_rejected_event, is_rejected_nevent);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEFilterByLatency"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEFilterByLatency</h3>
      <p class="pseudocode">// SPEFilterByLatency()
// ====================
// Carries out filtering by latency.

func <a id="func_SPEFilterByLatency_1"/>SPEFilterByLatency(total_latency : integer) =&gt; boolean
begin

    let is_lat : boolean = (total_latency &gt;= UInt(PMSLATFR_EL1().MINLAT));
    if is_lat then PMUEvent(PMU_EVENT_SAMPLE_FEED_LAT); end;

    var is_rejected_latency : boolean = FALSE;
    if PMSFCR_EL1().FL == '1' then
        // Filtering by latency is enabled
        if !IsZero(PMSLATFR_EL1().MINLAT) then
            // Not a CONSTRAINED UNPREDICTABLE case
            is_rejected_latency = is_rejected_latency || !is_lat;
        else
            is_rejected_latency = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BADPMSFCR" title="">Unpredictable_BADPMSFCR</a>);
        end;
    end;

    return is_rejected_latency;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEFilterByType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEFilterByType</h3>
      <p class="pseudocode">// SPEFilterByType()
// =================
// Returns TRUE if the operation is to be discarded because of its OpAttrs, and FALSE otherwise.

func <a id="func_SPEFilterByType_1"/>SPEFilterByType(opattr : <a href="shared_pseudocode.html#type_SPEOpAttr" title="">SPEOpAttr</a>) =&gt; boolean
begin
    // Bit positions in the PMSFCR_EL1().[TYPE, TYPEm] fields
    let B : integer    = 0;
    let LD : integer   = 1;
    let ST : integer   = 2;
    let FP : integer   = 3;
    let SIMD : integer = 4;

    var flags : bits(5) = Zeros{};
    var ctrl : bits(5)  = Zeros{};
    // With GCS, Branch Link and Procedure Return instructions write and read the GCS.
    // BL and RET instructions with GCS enabled call SPESampleLoadStore() before
    // branch/packet construction, setting ldst_type to indicate a GCS access.
    let is_gcs_ldst : boolean = (opattr.op_type == <a href="shared_pseudocode.html#enum_SPEOpType_Branch" title="">SPEOpType_Branch</a> &amp;&amp;
                                 opattr.ldst_type == <a href="shared_pseudocode.html#enum_SPELDSTType_GCS" title="">SPELDSTType_GCS</a>);
    let is_load : boolean     = (opattr.op_type IN {<a href="shared_pseudocode.html#enum_SPEOpType_Load" title="">SPEOpType_Load</a>, <a href="shared_pseudocode.html#enum_SPEOpType_LoadAtomic" title="">SPEOpType_LoadAtomic</a>}
                                || (is_gcs_ldst &amp;&amp; opattr.procedure_return));
    let is_store : boolean    = (opattr.op_type IN {<a href="shared_pseudocode.html#enum_SPEOpType_Store" title="">SPEOpType_Store</a>, <a href="shared_pseudocode.html#enum_SPEOpType_LoadAtomic" title="">SPEOpType_LoadAtomic</a>}
                                 || (is_gcs_ldst &amp;&amp; opattr.branch_has_link));
    flags[B]    = (if opattr.op_type == <a href="shared_pseudocode.html#enum_SPEOpType_Branch" title="">SPEOpType_Branch</a> then '1' else '0');
    flags[LD]   = (if is_load then '1' else '0');
    flags[ST]   = (if is_store then '1' else '0');
    flags[FP]   = (if opattr.is_floating_point then '1' else '0');
    flags[SIMD] = (if opattr.is_simd then '1' else '0');
    ctrl[2:0]   = PMSFCR_EL1().TYPE[2:0];
    var mask : bits(5) = Zeros{};
    if IsFeatureImplemented(FEAT_SPE_EFT) then
        ctrl[4:3] = PMSFCR_EL1().TYPE[4:3];
        mask[4:0] = PMSFCR_EL1().TYPEm;
    end;

    let ctrl_or : bits(5)  = (ctrl AND (NOT mask));
    let ctrl_and : bits(5) = (ctrl AND mask);

    let is_op : boolean = ((IsZero(ctrl_or) || !IsZero(flags AND ctrl_or)) &amp;&amp;
                               ((flags AND mask) == ctrl_and));

    if flags[B]    == '1' then PMUEvent(PMU_EVENT_SAMPLE_FEED_BR); end;
    if flags[LD]   == '1' then PMUEvent(PMU_EVENT_SAMPLE_FEED_LD); end;
    if flags[ST]   == '1' then PMUEvent(PMU_EVENT_SAMPLE_FEED_ST); end;
    if flags[FP]   == '1' then PMUEvent(PMU_EVENT_SAMPLE_FEED_FP); end;
    if flags[SIMD] == '1' then PMUEvent(PMU_EVENT_SAMPLE_FEED_SIMD); end;

    var is_rejected_type : boolean = FALSE;
    if PMSFCR_EL1().FT == '1' then
        // Filtering by type is enabled
        if IsFeatureImplemented(FEAT_SPE_EFT) || !IsZero(ctrl) then
            is_rejected_type = !is_op;
        else
            is_rejected_type = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_BADPMSFCR" title="">Unpredictable_BADPMSFCR</a>);
        end;
    end;
    if is_op &amp;&amp; (!IsZero(ctrl) || !IsZero(mask)) then PMUEvent(PMU_EVENT_SAMPLE_FEED_OP); end;

    return is_rejected_type;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEFreezeOnEvent"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEFreezeOnEvent</h3>
      <p class="pseudocode">// SPEFreezeOnEvent()
// ==================
// Returns TRUE if PMU event counter idx should be frozen due to an SPE event, and FALSE otherwise.

func <a id="func_SPEFreezeOnEvent_1"/>SPEFreezeOnEvent(idx : integer) =&gt; boolean
begin
    let counters : integer = NUM_PMU_COUNTERS;
    assert (idx &gt;= 0 &amp;&amp;
            (idx &lt; counters || idx == <a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a> ||
             (idx == <a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a> &amp;&amp; IsFeatureImplemented(FEAT_PMUv3_ICNTR))));

    if !IsFeatureImplemented(FEAT_SPEv1p2) || !IsFeatureImplemented(FEAT_PMUv3p7) then
        return FALSE;
    end;
    if idx == <a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a> &amp;&amp; !IsFeatureImplemented(FEAT_SPE_DPFZS) then
        // FZS does not affect the cycle counter when FEAT_SPE_DPFZS is not implemented
        return FALSE;
    end;

    let freeze_on_event : boolean = PMBLIMITR_EL1().[E,PMFZ] == '11';
    let stopped : boolean = <a href="shared_pseudocode.html#func_SPEProfilingStopped_0" title="">SPEProfilingStopped</a>();

    case <a href="shared_pseudocode.html#func_GetPMUCounterRange_1" title="">GetPMUCounterRange</a>(idx) of
        when <a href="shared_pseudocode.html#enum_PMUCounterRange_R1" title="">PMUCounterRange_R1</a> =&gt;
            return freeze_on_event &amp;&amp; stopped &amp;&amp; PMCR_EL0().FZS == '1';
        when <a href="shared_pseudocode.html#enum_PMUCounterRange_R2" title="">PMUCounterRange_R2</a> =&gt;
            return freeze_on_event &amp;&amp; stopped &amp;&amp; MDCR_EL2().HPMFZS == '1';
        otherwise =&gt;
            return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEGetDataSource"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEGetDataSource</h3>
      <p class="pseudocode">// SPEGetDataSource()
// ==================
// Returns a tuple indicating the data source for an access passed to SPESampleLoadStore, and
// whether the data source is valid.

impdef func <a id="func_SPEGetDataSource_3"/>SPEGetDataSource(is_load : boolean,
                             accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                             addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; (boolean, bits(16))
begin
    return (TRUE, Zeros{16});
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEGetDataSourcePayloadSize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEGetDataSourcePayloadSize</h3>
      <p class="pseudocode">// SPEGetDataSourcePayloadSize()
// =============================
// Returns the size of the Data Source payload in bytes.

func <a id="func_SPEGetDataSourcePayloadSize_0"/>SPEGetDataSourcePayloadSize() =&gt; integer{1..2}
begin
    return ImpDefInt("SPE Data Source packet payload size") as integer{1..2};
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEGetEventsPayloadSize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEGetEventsPayloadSize</h3>
      <p class="pseudocode">// SPEGetEventsPayloadSize()
// =========================
// Returns the size in bytes of the Events packet payload as an integer.

func <a id="func_SPEGetEventsPayloadSize_0"/>SPEGetEventsPayloadSize() =&gt; integer{1..4}
begin
    return ImpDefInt("SPE Events packet payload size") as integer{1..4};
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEGetRandomBoolean"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEGetRandomBoolean</h3>
      <p class="pseudocode">// SPEGetRandomBoolean()
// =====================
// Returns a random or pseudo-random boolean value.

impdef func <a id="func_SPEGetRandomBoolean_0"/>SPEGetRandomBoolean() =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_SPEGetRandomInterval_0" title="">SPEGetRandomInterval</a>()[0] == '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEGetRandomInterval"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEGetRandomInterval</h3>
      <p class="pseudocode">// SPEGetRandomInterval()
// ======================
// Returns a random or pseudo-random byte for resetting COUNT or ECOUNT.

impdef func <a id="func_SPEGetRandomInterval_0"/>SPEGetRandomInterval() =&gt; bits(8)
begin
    return <a href="shared_pseudocode.html#global__PC" title="">_PC</a>[0+:8];
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEISB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEISB</h3>
      <p class="pseudocode">// SPEISB()
// ========
// Called by ISB instruction, correctly calls SPEBranch to save previous branches.

func SPEISB()
begin
    let address : bits(64)           = <a href="shared_pseudocode.html#func_PC64_0" title="">PC64</a>() + 4;
    let branch_type : <a href="shared_pseudocode.html#type_BranchType" title="">BranchType</a>     = <a href="shared_pseudocode.html#enum_BranchType_DIR" title="">BranchType_DIR</a>;
    let branch_conditional : boolean = FALSE;
    let taken : boolean              = FALSE;
    let is_isb : boolean             = TRUE;

    SPEBranch{64}(address, branch_type, branch_conditional, taken, is_isb);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEInterruptEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEInterruptEnabled</h3>
      <p class="pseudocode">// SPEInterruptEnabled()
// =====================
// Return TRUE if the SPE interrupt request (PMBIRQ) is enabled, FALSE otherwise.

func <a id="func_SPEInterruptEnabled_0"/>SPEInterruptEnabled() =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_EffectivePMSCR_EL1_EE_0" title="">EffectivePMSCR_EL1_EE</a>() == '00';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPELDSTType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPELDSTType</h3>
      <p class="pseudocode">// SPELDSTType
// ===========
// Type of a load or store operation.

type <a id="type_SPELDSTType"/>SPELDSTType of enumeration {
    <a id="enum_SPELDSTType_NV2"/>SPELDSTType_NV2,
    <a id="enum_SPELDSTType_Extended"/>SPELDSTType_Extended,
    <a id="enum_SPELDSTType_General"/>SPELDSTType_General,
    <a id="enum_SPELDSTType_SIMDFP"/>SPELDSTType_SIMDFP,
    <a id="enum_SPELDSTType_SVESME"/>SPELDSTType_SVESME,
    <a id="enum_SPELDSTType_Tags"/>SPELDSTType_Tags,
    <a id="enum_SPELDSTType_MemCopy"/>SPELDSTType_MemCopy,
    <a id="enum_SPELDSTType_MemSet"/>SPELDSTType_MemSet,
    <a id="enum_SPELDSTType_GCS"/>SPELDSTType_GCS,
    <a id="enum_SPELDSTType_GCSSS2"/>SPELDSTType_GCSSS2,
    <a id="enum_SPELDSTType_Unspecified"/>SPELDSTType_Unspecified
};</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEMultiAccessSample"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEMultiAccessSample</h3>
      <p class="pseudocode">// SPEMultiAccessSample()
// ======================
// Called by instructions which make at least one store and one load access, where the configuration
// of the operation type filter affects which access is sampled.

func <a id="func_SPEMultiAccessSample_0"/>SPEMultiAccessSample() =&gt; boolean
begin
    // If loads or stores are filtered out, the other should be recorded.
    // If neither or both are filtered out, pick one in an unbiased way.

    // Bit positions in the PMSFCR().[TYPE, TYPEm] fields.
    let LD : integer = 1;
    let ST : integer = 2;

    // Are loads allowed by filter?
    let loads_pass_filter : boolean  = PMSFCR_EL1().FT == '1' &amp;&amp; PMSFCR_EL1().TYPE[LD] == '1';
    // Are stores allowed by filter?
    let stores_pass_filter : boolean = PMSFCR_EL1().FT == '1' &amp;&amp; PMSFCR_EL1().TYPE[ST] == '1';

    var record_load : boolean;
    if loads_pass_filter &amp;&amp; !stores_pass_filter then
        // Only loads pass filter
        record_load = TRUE;
    elsif !loads_pass_filter &amp;&amp; stores_pass_filter then
        // Only stores pass filter
        record_load = FALSE;
    else
        // Both loads and stores pass the filter or neither pass the filter.
        // Pick between the load or the store access (pseudo-)randomly.
        record_load = <a href="shared_pseudocode.html#func_SPEGetRandomBoolean_0" title="">SPEGetRandomBoolean</a>();
    end;
    return record_load;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEOpAttr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEOpAttr</h3>
      <p class="pseudocode">// SPEOpAttr
// =========
// Attributes of sampled operation filtered by SPECollectRecord().

type <a id="type_SPEOpAttr"/>SPEOpAttr of record {
    op_type : <a href="shared_pseudocode.html#type_SPEOpType" title="">SPEOpType</a>,
    ldst_type : <a href="shared_pseudocode.html#type_SPELDSTType" title="">SPELDSTType</a>,
    branch_is_direct : boolean,
    branch_has_link : boolean,
    procedure_return : boolean,
    is_conditional : boolean,
    is_floating_point : boolean,
    is_simd : boolean,
    cond_pass : boolean,
    at : boolean,
    is_acquire_release : boolean,
    is_predicated : boolean,
    evl : bits(3),
    is_gather_scatter : boolean,
    is_exclusive : boolean,
    ets : bits(4),
    addr_valid : boolean
};</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEOpType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEOpType</h3>
      <p class="pseudocode">// SPEOpType
// =========
// Types of operation filtered by SPECollectRecord().

type <a id="type_SPEOpType"/>SPEOpType of enumeration {
    <a id="enum_SPEOpType_Load"/>SPEOpType_Load,        // Any memory-read operation other than atomics, compare-and-swap,
                           // and swap
    <a id="enum_SPEOpType_Store"/>SPEOpType_Store,       // Any memory-write operation, including atomics without return
    <a id="enum_SPEOpType_LoadAtomic"/>SPEOpType_LoadAtomic,  // Atomics with return, compare-and-swap and swap
    <a id="enum_SPEOpType_Branch"/>SPEOpType_Branch,      // Software write to the PC
    <a id="enum_SPEOpType_OtherSVE"/>SPEOpType_OtherSVE,    // Other SVE operation
    <a id="enum_SPEOpType_OtherSME"/>SPEOpType_OtherSME,    // Other SME operation
    <a id="enum_SPEOpType_Other"/>SPEOpType_Other,       // Any other class of operation
    <a id="enum_SPEOpType_Invalid"/>SPEOpType_Invalid
};</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEProfilingStopped"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEProfilingStopped</h3>
      <p class="pseudocode">// SPEProfilingStopped()
// =====================

readonly func <a id="func_SPEProfilingStopped_0"/>SPEProfilingStopped() =&gt; boolean
begin
    var stopped : boolean = (PMBSR_EL1().S == '1');
    if IsFeatureImplemented(FEAT_SPE_EXC) then
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; MDCR_EL3().PMSEE == '1x' then
            stopped = stopped || (PMBSR_EL3().S == '1');
        end;
        if <a href="shared_pseudocode.html#func_EffectivePMSCR_EL2_EE_0" title="">EffectivePMSCR_EL2_EE</a>() == '1x' then
            stopped = stopped || (PMBSR_EL2().S == '1');
        end;
    end;
    return stopped;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEResetSampleCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEResetSampleCounter</h3>
      <p class="pseudocode">// SPEResetSampleCounter()
// =======================
// Reset PMSICR_EL1.Counter

func SPEResetSampleCounter()
begin
    PMSICR_EL1().COUNT[31:8] = PMSIRR_EL1().INTERVAL;
    if PMSIRR_EL1().RND == '1' &amp;&amp; !IsFeatureImplemented(FEAT_SPE_ERnd) then
        PMSICR_EL1().COUNT[7:0] = <a href="shared_pseudocode.html#func_SPEGetRandomInterval_0" title="">SPEGetRandomInterval</a>();
    else
        PMSICR_EL1().COUNT[7:0] = Zeros{8};
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEResetSampleStorage"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEResetSampleStorage</h3>
      <p class="pseudocode">// SPEResetSampleStorage()
// =======================
// Reset all variables inside sample storage.

func SPEResetSampleStorage()
begin
    // Context values
    <a href="shared_pseudocode.html#global_SPESampleContextEL1" title="">SPESampleContextEL1</a>      = Zeros{32};
    <a href="shared_pseudocode.html#global_SPESampleContextEL1Valid" title="">SPESampleContextEL1Valid</a> = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleContextEL2" title="">SPESampleContextEL2</a>      = Zeros{32};
    <a href="shared_pseudocode.html#global_SPESampleContextEL2Valid" title="">SPESampleContextEL2Valid</a> = FALSE;

    // Counter values
    for i = 0 to (<a href="shared_pseudocode.html#global_SPEMaxCounters" title="">SPEMaxCounters</a> - 1) do
        <a href="shared_pseudocode.html#global_SPESampleCounter" title="">SPESampleCounter</a>[[i]]        = 0;
        <a href="shared_pseudocode.html#global_SPESampleCounterValid" title="">SPESampleCounterValid</a>[[i]]   = FALSE;
        <a href="shared_pseudocode.html#global_SPESampleCounterPending" title="">SPESampleCounterPending</a>[[i]] = FALSE;
    end;

    // Address values
    for i = 0 to (<a href="shared_pseudocode.html#global_SPEMaxAddrs" title="">SPEMaxAddrs</a> - 1) do
        <a href="shared_pseudocode.html#global_SPESampleAddressValid" title="">SPESampleAddressValid</a>[[i]] = FALSE;
        <a href="shared_pseudocode.html#global_SPESampleAddress" title="">SPESampleAddress</a>[[i]]      = Zeros{64};
    end;

    // Data source values
    <a href="shared_pseudocode.html#global_SPESampleDataSource" title="">SPESampleDataSource</a>      = Zeros{16};
    <a href="shared_pseudocode.html#global_SPESampleDataSourceValid" title="">SPESampleDataSourceValid</a> = FALSE;

    // Timestamp values
    <a href="shared_pseudocode.html#global_SPESampleTimestamp" title="">SPESampleTimestamp</a>      = Zeros{64};
    <a href="shared_pseudocode.html#global_SPESampleTimestampValid" title="">SPESampleTimestampValid</a> = FALSE;

    // Event values
    <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a> = Zeros{64};

    // Operation attributes
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type = <a href="shared_pseudocode.html#enum_SPEOpType_Invalid" title="">SPEOpType_Invalid</a>;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type          = <a href="shared_pseudocode.html#enum_SPELDSTType_Unspecified" title="">SPELDSTType_Unspecified</a>;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.branch_is_direct   = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.branch_has_link    = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.procedure_return   = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_conditional     = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_floating_point  = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_simd            = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.cond_pass          = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.at                 = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_acquire_release = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_exclusive       = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_predicated      = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.evl                = '000';
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_gather_scatter  = FALSE;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.addr_valid         = FALSE;
end;

var <a id="global_SPERecordData"/>SPERecordData : array [[<a href="shared_pseudocode.html#global_SPEMaxRecordSize" title="">SPEMaxRecordSize</a>]] of bits(8);

var <a id="global_SPERecordSize"/>SPERecordSize : integer;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleAddAddressPCVirtual"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleAddAddressPCVirtual</h3>
      <p class="pseudocode">// SPESampleAddAddressPCVirtual()
// ==============================
// Save the current PC address to sample storage.

func SPESampleAddAddressPCVirtual()
begin
    var ns : bit;
    var nse : bit;
    case <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() of
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;
            ns = '0';
            nse = '0';
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;
            ns = '1';
            nse = '0';
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;
            ns = '1';
            nse = '1';
        otherwise =&gt; unreachable;
    end;
    let el : bits(2) = PSTATE.EL;

    let pc : bits(64) = ThisInstrAddr{}();
    <a href="shared_pseudocode.html#global_SPESampleAddress" title="">SPESampleAddress</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosPCVirtual" title="">SPEAddrPosPCVirtual</a>]][55:0] = pc[55:0];
    <a href="shared_pseudocode.html#global_SPESampleAddress" title="">SPESampleAddress</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosPCVirtual" title="">SPEAddrPosPCVirtual</a>]][63:56] = ns::el::nse::Zeros{4};
    <a href="shared_pseudocode.html#global_SPESampleAddressValid" title="">SPESampleAddressValid</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosPCVirtual" title="">SPEAddrPosPCVirtual</a>]]   = TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleAddContext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleAddContext</h3>
      <p class="pseudocode">// SPESampleAddContext()
// =====================
// Save contexts to sample storage if appropriate.

func SPESampleAddContext()
begin
    if <a href="shared_pseudocode.html#func_CollectContextIDR1_0" title="">CollectContextIDR1</a>() then
        <a href="shared_pseudocode.html#global_SPESampleContextEL1" title="">SPESampleContextEL1</a> = CONTEXTIDR_EL1()[31:0];
        <a href="shared_pseudocode.html#global_SPESampleContextEL1Valid" title="">SPESampleContextEL1Valid</a> = TRUE;
    end;
    if <a href="shared_pseudocode.html#func_CollectContextIDR2_0" title="">CollectContextIDR2</a>() then
        <a href="shared_pseudocode.html#global_SPESampleContextEL2" title="">SPESampleContextEL2</a> = CONTEXTIDR_EL2()[31:0];
        <a href="shared_pseudocode.html#global_SPESampleContextEL2Valid" title="">SPESampleContextEL2Valid</a> = TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleAddTimeStamp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleAddTimeStamp</h3>
      <p class="pseudocode">// SPESampleAddTimeStamp()
// =======================
// Save the appropriate type of timestamp to sample storage.

func SPESampleAddTimeStamp()
begin
    let timestamp : <a href="shared_pseudocode.html#type_TimeStamp" title="">TimeStamp</a> = <a href="shared_pseudocode.html#func_CollectTimeStamp_0" title="">CollectTimeStamp</a>();
    case timestamp of
        when <a href="shared_pseudocode.html#enum_TimeStamp_None" title="">TimeStamp_None</a> =&gt;
            <a href="shared_pseudocode.html#global_SPESampleTimestampValid" title="">SPESampleTimestampValid</a> = FALSE;
        otherwise =&gt;
            <a href="shared_pseudocode.html#global_SPESampleTimestampValid" title="">SPESampleTimestampValid</a> = TRUE;
            <a href="shared_pseudocode.html#global_SPESampleTimestamp" title="">SPESampleTimestamp</a> = <a href="shared_pseudocode.html#func_GetTimestamp_1" title="">GetTimestamp</a>(timestamp);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleCollision"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleCollision</h3>
      <p class="pseudocode">// SPESampleCollision()
// ====================
// Called when there is an SPE sample collision.

func SPESampleCollision()
begin
    // Sample collision with the previous sample
    PMUEvent(PMU_EVENT_SAMPLE_COLLISION);
    let target_el : bits(2)  = <a href="shared_pseudocode.html#func_DefaultSPEEvent_0" title="">DefaultSPEEvent</a>();
    <a href="shared_pseudocode.html#accessor_PMBSR_EL_1" title="">PMBSR_EL</a>(target_el).COLL = '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleExtendedLoadStore"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleExtendedLoadStore</h3>
      <p class="pseudocode">// SPESampleExtendedLoadStore()
// ============================
// Sets the subclass of the operation type packet for
// extended load/store operations.

func SPESampleExtendedLoadStore(ar : boolean, excl : boolean, at : boolean, is_load : boolean)
begin
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_acquire_release = ar;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_exclusive       = excl;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type          = <a href="shared_pseudocode.html#enum_SPELDSTType_Extended" title="">SPELDSTType_Extended</a>;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.at                 = at;
    if is_load then
        if at then
            <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type = <a href="shared_pseudocode.html#enum_SPEOpType_LoadAtomic" title="">SPEOpType_LoadAtomic</a>;
        else
            <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type = <a href="shared_pseudocode.html#enum_SPEOpType_Load" title="">SPEOpType_Load</a>;
        end;
    else
        <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type = <a href="shared_pseudocode.html#enum_SPEOpType_Store" title="">SPEOpType_Store</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleGCSSS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleGCSSS2</h3>
      <p class="pseudocode">// SPESampleGCSSS2()
// =================
// Sets the subclass of the operation type packet for GCSSS2 load/store operations.

func SPESampleGCSSS2()
begin
    // GCSSS2 does a read and a write.
    let record_load : boolean = <a href="shared_pseudocode.html#func_SPEMultiAccessSample_0" title="">SPEMultiAccessSample</a>();
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type = if record_load then <a href="shared_pseudocode.html#enum_SPEOpType_Load" title="">SPEOpType_Load</a> else <a href="shared_pseudocode.html#enum_SPEOpType_Store" title="">SPEOpType_Store</a>;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type = <a href="shared_pseudocode.html#enum_SPELDSTType_GCSSS2" title="">SPELDSTType_GCSSS2</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleGeneralPurposeLoadStore"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleGeneralPurposeLoadStore</h3>
      <p class="pseudocode">// SPESampleGeneralPurposeLoadStore()
// ==================================
// Sets the subclass of the operation type packet for general
// purpose load/store operations.

func SPESampleGeneralPurposeLoadStore(is_load : boolean)
begin
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type = <a href="shared_pseudocode.html#enum_SPELDSTType_General" title="">SPELDSTType_General</a>;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type = if is_load then <a href="shared_pseudocode.html#enum_SPEOpType_Load" title="">SPEOpType_Load</a> else <a href="shared_pseudocode.html#enum_SPEOpType_Store" title="">SPEOpType_Store</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleLoadStore"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleLoadStore</h3>
      <p class="pseudocode">// SPESampleLoadStore()
// ====================
// Called if a sample is in flight when writing or reading memory,
// indicating that the operation being sampled is in the Load, Store or atomic category.

func SPESampleLoadStore(is_load : boolean, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                        addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>)
begin
    // Check if this access type is suitable to be sampled.
    // This implementation of SPE always samples the first access made by a suitable instruction.
    // FEAT_MOPS instructions are an exception, where the first load or first store access may be
    // selected based on the configuration of the sample filters.
    if accdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a>,
                           <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a>,
                           <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a>,
                           <a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>,
                           <a href="shared_pseudocode.html#enum_AccessType_TTW" title="">AccessType_TTW</a>,
                           <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>} then
        return;
    end;

    var sample_access : boolean = FALSE;
    // For FEAT_MOPS and FEAT_GCS GCSSS2 instructions which perform both loads and stores, the
    // filter configuration will influence which part of the access is chosen to be sampled.
    if (<a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type IN
          {<a href="shared_pseudocode.html#enum_SPELDSTType_MemCopy" title="">SPELDSTType_MemCopy</a>, <a href="shared_pseudocode.html#enum_SPELDSTType_MemSet" title="">SPELDSTType_MemSet</a>, <a href="shared_pseudocode.html#enum_SPELDSTType_GCSSS2" title="">SPELDSTType_GCSSS2</a>}) then
        // SPEMultiAccessSample() will have been called before this function,
        //and chooses whether to sample a load or a store.
        var sample_load : boolean;
        sample_load = <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type IN {<a href="shared_pseudocode.html#enum_SPEOpType_Load" title="">SPEOpType_Load</a>, <a href="shared_pseudocode.html#enum_SPEOpType_LoadAtomic" title="">SPEOpType_LoadAtomic</a>};

        // If no valid data has been collected, and this operation is acceptable for sampling.
        if !<a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.addr_valid &amp;&amp; (is_load == sample_load) then
            sample_access = TRUE;
        end;
    else
        if !<a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.addr_valid then
            sample_access = TRUE;
        end;
    end;

    if sample_access then
        // Data access virtual address
        SPESetDataVirtualAddress(addrdesc.vaddress);

        // Data access physical address
        if <a href="shared_pseudocode.html#func_CollectPhysicalAddress_0" title="">CollectPhysicalAddress</a>() then
            SPESetDataPhysicalAddress(addrdesc, accdesc);
        end;

        <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.addr_valid = TRUE;
    end;

    if <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type == <a href="shared_pseudocode.html#enum_SPEOpType_Invalid" title="">SPEOpType_Invalid</a> then
        // Set as unspecified load/store by default, instructions will overwrite this if it does not
        // apply to them.
        <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type = if is_load then <a href="shared_pseudocode.html#enum_SPEOpType_Load" title="">SPEOpType_Load</a> else <a href="shared_pseudocode.html#enum_SPEOpType_Store" title="">SPEOpType_Store</a>;

        if accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_NV2" title="">AccessType_NV2</a> then
            // NV2 register load/store
            <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type = <a href="shared_pseudocode.html#enum_SPELDSTType_NV2" title="">SPELDSTType_NV2</a>;
        end;
    end;

    // Set SPELDSTType to GCS for all GCS instruction, overwriting type GCSSS2.
    // After selection of which operation of a GCSSS2 instruction to sample, GCSSS2 is treated the
    // same as other GCS instructions.
    if accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_GCS" title="">AccessType_GCS</a> then
        <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type = <a href="shared_pseudocode.html#enum_SPELDSTType_GCS" title="">SPELDSTType_GCS</a>;
        // If the GCS access is from a BL or RET, this will get overwritten to SPEOpType_Branch.
        <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type = if is_load then <a href="shared_pseudocode.html#enum_SPEOpType_Load" title="">SPEOpType_Load</a> else <a href="shared_pseudocode.html#enum_SPEOpType_Store" title="">SPEOpType_Store</a>;
    end;
    (<a href="shared_pseudocode.html#global_SPESampleDataSourceValid" title="">SPESampleDataSourceValid</a>, <a href="shared_pseudocode.html#global_SPESampleDataSource" title="">SPESampleDataSource</a>) = <a href="shared_pseudocode.html#func_SPEGetDataSource_3" title="">SPEGetDataSource</a>(is_load, accdesc, addrdesc);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleMemCopy"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleMemCopy</h3>
      <p class="pseudocode">// SPESampleMemCopy()
// ==================
// Sets the subclass of the operation type packet for Memory Copy load/store
// operations.

func SPESampleMemCopy()
begin
    // MemCopy does a read and a write.
    let record_load : boolean = <a href="shared_pseudocode.html#func_SPEMultiAccessSample_0" title="">SPEMultiAccessSample</a>();
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type   = if record_load then <a href="shared_pseudocode.html#enum_SPEOpType_Load" title="">SPEOpType_Load</a> else <a href="shared_pseudocode.html#enum_SPEOpType_Store" title="">SPEOpType_Store</a>;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type = <a href="shared_pseudocode.html#enum_SPELDSTType_MemCopy" title="">SPELDSTType_MemCopy</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleMemSet"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleMemSet</h3>
      <p class="pseudocode">// SPESampleMemSet()
// =================
// Callback used by memory set instructions to pass data back to the SPU.

func SPESampleMemSet()
begin
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type   = <a href="shared_pseudocode.html#enum_SPEOpType_Store" title="">SPEOpType_Store</a>;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type = <a href="shared_pseudocode.html#enum_SPELDSTType_MemSet" title="">SPELDSTType_MemSet</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleOnSharedResource"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleOnSharedResource</h3>
      <p class="pseudocode">// SPESampleOnSharedResource()
// ===========================
// Called when the sampled instruction is executed on an SMCU or other shared resource, sets bit 25
// of the events packet to 0b1.

func SPESampleOnSharedResource()
begin
    <a href="shared_pseudocode.html#global_SPESampleEvents" title="">SPESampleEvents</a>[25] = '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleOpOther"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleOpOther</h3>
      <p class="pseudocode">// SPESampleOpOther()
// ==================
// Add other operation to sample storage.

func SPESampleOpOther(conditional : boolean, cond_pass : boolean,
                      is_fp : boolean, is_simd : boolean)
begin
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_simd = is_simd;
    SPESampleOpOther(conditional, cond_pass, is_fp);
end;

func SPESampleOpOther(conditional : boolean, cond_pass : boolean, is_fp : boolean)
begin
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.cond_pass = cond_pass;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_floating_point = is_fp;
    SPESampleOpOther(conditional);
end;

func SPESampleOpOther(conditional : boolean)
begin
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_conditional = conditional;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type = <a href="shared_pseudocode.html#enum_SPEOpType_Other" title="">SPEOpType_Other</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleOpSMEArrayOther"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleOpSMEArrayOther</h3>
      <p class="pseudocode">// SPESampleOpSMEArrayOther()
// ==========================
// Sets the subclass of the operation type packet to Other, SME array.

func SPESampleOpSMEArrayOther(floating_point : boolean, size : integer)
begin
    // If the sampled effective vector or tile size is not a power of two, or is less than 128 bits,
    // the value is rounded up before it is encoded in the ets field.

    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_floating_point = floating_point;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ets               = <a href="shared_pseudocode.html#func_SPEEncodeETS_1" title="">SPEEncodeETS</a>(size);
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type           = <a href="shared_pseudocode.html#enum_SPEOpType_OtherSME" title="">SPEOpType_OtherSME</a>;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_simd           = TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleOpSVEOther"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleOpSVEOther</h3>
      <p class="pseudocode">// SPESampleOpSVEOther()
// =====================
// Callback used by SVE, Other operations to pass data back to the SPU.

func SPESampleOpSVEOther(vl : integer, predicated : boolean, floating_point : boolean)
begin
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_predicated     = predicated;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_floating_point = floating_point;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.evl               = <a href="shared_pseudocode.html#func_SPEEncodeEVL_1" title="">SPEEncodeEVL</a>(vl);
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type           = <a href="shared_pseudocode.html#enum_SPEOpType_OtherSVE" title="">SPEOpType_OtherSVE</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleOpSVESMELoadStore"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleOpSVESMELoadStore</h3>
      <p class="pseudocode">// SPESampleOpSVESMELoadStore()
// ============================
// Callback used by SVE or SME loads and stores to pass data to SPE.

func SPESampleOpSVESMELoadStore(is_gather_scatter : boolean, vl : integer, predicated : boolean,
                                is_load : boolean)
begin
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_gather_scatter = is_gather_scatter;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_predicated     = predicated;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.evl               = <a href="shared_pseudocode.html#func_SPEEncodeEVL_1" title="">SPEEncodeEVL</a>(vl);
    assert <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.evl != '111';
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type = if is_load then <a href="shared_pseudocode.html#enum_SPEOpType_Load" title="">SPEOpType_Load</a> else <a href="shared_pseudocode.html#enum_SPEOpType_Store" title="">SPEOpType_Store</a>;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type = <a href="shared_pseudocode.html#enum_SPELDSTType_SVESME" title="">SPELDSTType_SVESME</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESampleSIMDFPLoadStore"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESampleSIMDFPLoadStore</h3>
      <p class="pseudocode">// SPESampleSIMDFPLoadStore()
// ==========================
// Sets the subclass of the operation type packet for SIMD &amp; FP
// load store operations.

func SPESampleSIMDFPLoadStore(is_load : boolean, scalar : boolean)
begin
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.ldst_type = <a href="shared_pseudocode.html#enum_SPELDSTType_SIMDFP" title="">SPELDSTType_SIMDFP</a>;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.op_type   = if is_load then <a href="shared_pseudocode.html#enum_SPEOpType_Load" title="">SPEOpType_Load</a> else <a href="shared_pseudocode.html#enum_SPEOpType_Store" title="">SPEOpType_Store</a>;
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_simd   = !scalar;
    // Scalar operations in SIMD&amp;FP are treated as floating point.
    <a href="shared_pseudocode.html#global_SPESampleOpAttr" title="">SPESampleOpAttr</a>.is_floating_point = scalar;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESetDataPhysicalAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESetDataPhysicalAddress</h3>
      <p class="pseudocode">// SPESetDataPhysicalAddress()
// ===========================
// Called from SampleLoadStore() to save data physical packet.

func SPESetDataPhysicalAddress(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>)
begin
    var ns : bit;
    var nse : bit;
    var ch : bit;
    var lat : bits(4);
    case addrdesc.paddress.paspace of
        when <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> =&gt;
            ns = '0';
            nse = '0';
        when <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> =&gt;
            ns = '1';
            nse = '0';
        when <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> =&gt;
            ns  = '1';
            nse = '1';
        otherwise =&gt; unreachable;
    end;

    if IsFeatureImplemented(FEAT_MTE2) then
        if accdesc.tagchecked then
            ch = '1';
            lat = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(addrdesc.vaddress);
        else
            ch = '0';
            // If the access is Unchecked, this is an IMPLEMENTATION_DEFINED choice
            // between 0b0000 and the Logical Address Tag
            var zero_unchecked : boolean;
            zero_unchecked = ImpDefBool("SPE PAT for tag unchecked access zero");
            if !zero_unchecked then
                lat = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(addrdesc.vaddress);
            else
                lat = Zeros{4};
            end;
        end;
    else
        ch = '0';
        lat = '0000';
    end;

    let paddr : bits(56) = addrdesc.paddress.address;
    <a href="shared_pseudocode.html#global_SPESampleAddress" title="">SPESampleAddress</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosDataPhysical" title="">SPEAddrPosDataPhysical</a>]][55:0] = ZeroExtend{56}(paddr);
    <a href="shared_pseudocode.html#global_SPESampleAddress" title="">SPESampleAddress</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosDataPhysical" title="">SPEAddrPosDataPhysical</a>]][63:56] = ns::ch::'0'::nse::lat;
    <a href="shared_pseudocode.html#global_SPESampleAddressValid" title="">SPESampleAddressValid</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosDataPhysical" title="">SPEAddrPosDataPhysical</a>]] = TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPESetDataVirtualAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPESetDataVirtualAddress</h3>
      <p class="pseudocode">// SPESetDataVirtualAddress()
// ==========================
// Called from SampleLoadStore() to save data virtual packet.
// Also used by exclusive load/stores to save virtual addresses if exclusive monitor is lost
// before a read/write is completed.

func SPESetDataVirtualAddress(vaddress : bits(64))
begin
    var tbi : bit;
    tbi = <a href="shared_pseudocode.html#func_EffectiveTBI_3" title="">EffectiveTBI</a>(vaddress, FALSE, PSTATE.EL);
    var non_tbi_is_zeros : boolean;
    non_tbi_is_zeros = ImpDefBool("SPE non-tbi tag is zero");
    if tbi == '1' || !non_tbi_is_zeros then
        <a href="shared_pseudocode.html#global_SPESampleAddress" title="">SPESampleAddress</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosDataVirtual" title="">SPEAddrPosDataVirtual</a>]][63:0] = vaddress[63:0];
    else
        <a href="shared_pseudocode.html#global_SPESampleAddress" title="">SPESampleAddress</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosDataVirtual" title="">SPEAddrPosDataVirtual</a>]][55:0] = vaddress[55:0];
        <a href="shared_pseudocode.html#global_SPESampleAddress" title="">SPESampleAddress</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosDataVirtual" title="">SPEAddrPosDataVirtual</a>]][63:56] = Zeros{8};
    end;
    <a href="shared_pseudocode.html#global_SPESampleAddressValid" title="">SPESampleAddressValid</a>[[<a href="shared_pseudocode.html#global_SPEAddrPosDataVirtual" title="">SPEAddrPosDataVirtual</a>]] = TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEStartCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEStartCounter</h3>
      <p class="pseudocode">// SPEStartCounter()
// =================
// Enables incrementing of the counter at the passed index when SPECycle is called.

func SPEStartCounter(counter_index : integer)
begin
    assert counter_index &lt; <a href="shared_pseudocode.html#global_SPEMaxCounters" title="">SPEMaxCounters</a>;
    <a href="shared_pseudocode.html#global_SPESampleCounterPending" title="">SPESampleCounterPending</a>[[counter_index]] = TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEStartSample"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEStartSample</h3>
      <p class="pseudocode">// SPEStartSample()
// ================
// Called to start the sampling process. Returns TRUE if a new sample is to be collected, and
// FALSE otherwise.

func <a id="func_SPEStartSample_0"/>SPEStartSample() =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_StatisticalProfilingEnabled_0" title="">StatisticalProfilingEnabled</a>() then
        return FALSE;
    end;
    PMUEvent(PMU_EVENT_SAMPLE_POP);
    if !<a href="shared_pseudocode.html#func_SPEToCollectSample_0" title="">SPEToCollectSample</a>() then
        return FALSE;
    end;

    if <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> then
        SPESampleCollision();
        return FALSE;
    end;

    <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> = TRUE;

    SPEStartCounter(<a href="shared_pseudocode.html#global_SPECounterPosTotalLatency" title="">SPECounterPosTotalLatency</a>);
    SPEStartCounter(<a href="shared_pseudocode.html#global_SPECounterPosIssueLatency" title="">SPECounterPosIssueLatency</a>);
    SPESampleAddAddressPCVirtual();

    // Many operations are type other and not conditional, can save footprint
    // and overhead by having this as the default and not calling SPESampleOpOther
    // if conditional == FALSE
    SPESampleOpOther(FALSE);

    SPESampleAddContext();

    // Timestamp may be collected at any point in the sampling operation.
    // Collecting prior to execution is one possible choice.
    // This choice is IMPLEMENTATION DEFINED.
    SPESampleAddTimeStamp();

    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEStopCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEStopCounter</h3>
      <p class="pseudocode">// SPEStopCounter()
// ================
// Disables incrementing of the counter at the passed index when SPECycle is called.

func SPEStopCounter(counter_index : integer)
begin
    <a href="shared_pseudocode.html#global_SPESampleCounterValid" title="">SPESampleCounterValid</a>[[counter_index]] = TRUE;
    <a href="shared_pseudocode.html#global_SPESampleCounterPending" title="">SPESampleCounterPending</a>[[counter_index]] = FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEToCollectSample"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEToCollectSample</h3>
      <p class="pseudocode">// SPEToCollectSample()
// ====================
// Returns TRUE if the instruction which is about the executed should be sampled, and FALSE
// otherwise.

func <a id="func_SPEToCollectSample_0"/>SPEToCollectSample() =&gt; boolean
begin
    if IsZero(PMSICR_EL1().COUNT) then
        SPEResetSampleCounter();
    else
        PMSICR_EL1().COUNT = PMSICR_EL1().COUNT - 1;
        if IsZero(PMSICR_EL1().COUNT) then
            if PMSIRR_EL1().RND == '1' &amp;&amp; IsFeatureImplemented(FEAT_SPE_ERnd) then
                PMSICR_EL1().ECOUNT = <a href="shared_pseudocode.html#func_SPEGetRandomInterval_0" title="">SPEGetRandomInterval</a>();
                return IsZero(PMSICR_EL1().ECOUNT);
            else
                return TRUE;
            end;
        end;
    end;
    if (PMSIRR_EL1().RND == '1' &amp;&amp; IsFeatureImplemented(FEAT_SPE_ERnd) &amp;&amp;
          !IsZero(PMSICR_EL1().ECOUNT)) then
        PMSICR_EL1().ECOUNT = PMSICR_EL1().ECOUNT - 1;
        if IsZero(PMSICR_EL1().ECOUNT) then
            return TRUE;
        end;
    end;
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPEWriteToBuffer"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPEWriteToBuffer</h3>
      <p class="pseudocode">// SPEWriteToBuffer()
// ==================
// Write the active record to the Profiling Buffer.

func SPEWriteToBuffer()
begin
    assert <a href="shared_pseudocode.html#func_ProfilingBufferEnabled_0" title="">ProfilingBufferEnabled</a>();

    // Check alignment
    let align : integer{} = UInt(PMBIDR_EL1().Align);
    let aligned : boolean = IsAlignedP2(PMBPTR_EL1().PTR, align);

    let ttw_abort_as_fault : boolean = (ImpDefBool(
                                           "Report SPE ExtAbort on TTW as fault"));

    var owning_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>;
    var owning_el : bits(2);
    (owning_ss, owning_el) = <a href="shared_pseudocode.html#func_ProfilingBufferOwner_0" title="">ProfilingBufferOwner</a>();
    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescSPE_2" title="">CreateAccDescSPE</a>(owning_ss, owning_el);

    let start_vaddr : bits(64) = PMBPTR_EL1();
    for i = 0 to <a href="shared_pseudocode.html#global_SPERecordSize" title="">SPERecordSize</a> - 1 do
        // If a previous write did not cause an issue
        if !<a href="shared_pseudocode.html#func_SPEProfilingStopped_0" title="">SPEProfilingStopped</a>() then
            let address : bits(64) = PMBPTR_EL1();
            var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
            var addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
            (memstatus, addrdesc) = <a href="shared_pseudocode.html#func_DebugMemWrite_4" title="">DebugMemWrite</a>(address, accdesc, aligned,
                                                  <a href="shared_pseudocode.html#global_SPERecordData" title="">SPERecordData</a>[[i]]);

            let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = addrdesc.fault;
            let ttw_abort : boolean = fault.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_SyncExternalOnWalk" title="">Fault_SyncExternalOnWalk</a>,
                                                           <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a>};

            if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(fault.statuscode) &amp;&amp; (!ttw_abort || ttw_abort_as_fault) then
                DebugWriteFault(address, fault);
            elsif <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) || (ttw_abort &amp;&amp; !ttw_abort_as_fault) then
                DebugWriteExternalAbort(memstatus, addrdesc, start_vaddr);
            end;

            // Move pointer if no Buffer Management Event has been caused.
            if !<a href="shared_pseudocode.html#func_SPEProfilingStopped_0" title="">SPEProfilingStopped</a>() then
                PMBPTR_EL1() = PMBPTR_EL1() + 1;
            end;
        end;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.StatisticalProfilingEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/StatisticalProfilingEnabled</h3>
      <p class="pseudocode">// StatisticalProfilingEnabled()
// =============================
// Return TRUE if Statistical Profiling is Enabled in the current EL, FALSE otherwise.

func <a id="func_StatisticalProfilingEnabled_0"/>StatisticalProfilingEnabled() =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_StatisticalProfilingEnabled_1" title="">StatisticalProfilingEnabled</a>(PSTATE.EL);
end;

// StatisticalProfilingEnabled()
// =============================
// Return TRUE if Statistical Profiling is Enabled in the specified EL, FALSE otherwise.

func <a id="func_StatisticalProfilingEnabled_1"/>StatisticalProfilingEnabled(el : bits(2)) =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_SPE) || <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() || !<a href="shared_pseudocode.html#func_ProfilingBufferEnabled_0" title="">ProfilingBufferEnabled</a>() then
        return FALSE;
    end;

    let tge_set : boolean = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1';
    let (owning_ss, owning_el) : (<a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, bits(2)) = <a href="shared_pseudocode.html#func_ProfilingBufferOwner_0" title="">ProfilingBufferOwner</a>();
    if (UInt(owning_el) &lt;  UInt(el) || (tge_set &amp;&amp; owning_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) ||
            owning_ss != <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(el))  then
        return FALSE;
    end;
    var spe_bit : bit;
    case el of
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  unreachable;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  spe_bit = PMSCR_EL2().E2SPE;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  spe_bit = PMSCR_EL1().E1SPE;
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;  spe_bit = (if tge_set then PMSCR_EL2().E0HSPE else PMSCR_EL1().E0SPE);
    end;

    return spe_bit == '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.TimeStamp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/TimeStamp</h3>
      <p class="pseudocode">// TimeStamp
// =========

type <a id="type_TimeStamp"/>TimeStamp of enumeration {
    <a id="enum_TimeStamp_None"/>TimeStamp_None,              // No timestamp
    <a id="enum_TimeStamp_CoreSight"/>TimeStamp_CoreSight,         // CoreSight time (IMPLEMENTATION DEFINED)
    <a id="enum_TimeStamp_Physical"/>TimeStamp_Physical,          // Physical counter value with no offset
    <a id="enum_TimeStamp_OffsetPhysical"/>TimeStamp_OffsetPhysical,    // Physical counter value minus CNTPOFF_EL2
    <a id="enum_TimeStamp_Virtual"/>TimeStamp_Virtual  };        // Physical counter value minus CNTVOFF_EL2</p>
    </div>
    <div class="ps"><a id="aarch64.debug.takeexceptiondbg.AArch64_TakeExceptionInDebugState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/takeexceptiondbg/AArch64_TakeExceptionInDebugState</h3>
      <p class="pseudocode">// AArch64_TakeExceptionInDebugState()
// ===================================
// Take an exception in Debug state to an Exception level using AArch64.

noreturn func AArch64_TakeExceptionInDebugState(target_el : bits(2), exception_in : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>)
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(target_el) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(target_el) &amp;&amp; UInt(target_el) &gt;= UInt(PSTATE.EL);
    assert target_el != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> || EDSCR().SDD == '0';
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = exception_in;
    var sync_errors : boolean;
    if IsFeatureImplemented(FEAT_IESB) then
        sync_errors = <a href="shared_pseudocode.html#accessor_SCTLR_EL_1" title="">SCTLR_EL</a>(target_el).IESB == '1';
        if IsFeatureImplemented(FEAT_DoubleFault) then
            sync_errors = sync_errors || (SCR_EL3().[EA,NMEA] == '11' &amp;&amp; target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;
        // The Effective value of SCTLR[].IESB might be zero in Debug state.
        if !<a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_IESBinDebug" title="">Unpredictable_IESBinDebug</a>) then
            sync_errors = FALSE;
        end;
    else
        sync_errors = FALSE;
    end;

    if !IsFeatureImplemented(FEAT_ExS) || <a href="shared_pseudocode.html#accessor_SCTLR_EL_1" title="">SCTLR_EL</a>(target_el).EIS == '1' then
        // Synchronize the context, including Instruction Fetch Barrier effect
        SynchronizeContext();
    end;

    // If coming from AArch32 state, the top parts of the X[] registers might be set to zero
    let from_32 : boolean = <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
    if from_32 then AArch64_MaybeZeroRegisterUppers(); end;
    if from_32 &amp;&amp; IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.SM == '1' then
        ResetSVEState();
    else
        MaybeZeroSVEUppers(target_el);
    end;

    AArch64_ReportException(except, target_el);

    if IsFeatureImplemented(FEAT_GCS) then
        PSTATE.EXLOCK = '0';  // Effective value of GCSCR_ELx.EXLOCKEN is 0 in Debug state
    end;

    PSTATE.EL  = target_el;
    PSTATE.nRW = '0';
    PSTATE.SP  = '1';

    <a href="shared_pseudocode.html#accessor_SPSR_ELx_0" title="">SPSR_ELx</a>() = ARBITRARY : bits(64);
    <a href="shared_pseudocode.html#accessor_ELR_ELx_0" title="">ELR_ELx</a>() = ARBITRARY : bits(64);
    // PSTATE.[SS,D,A,I,F] are not observable and ignored in Debug state, so behave as if UNKNOWN.
    PSTATE.[SS,D,A,I,F] = ARBITRARY : bits(5);
    if IsFeatureImplemented(FEAT_SSBS) then PSTATE.SSBS = ARBITRARY : bit; end;
    if IsFeatureImplemented(FEAT_EBEP) then PSTATE.PM = ARBITRARY : bit; end;
    if IsFeatureImplemented(FEAT_SEBEP) then PSTATE.PPEND = '0'; end;
    if IsFeatureImplemented(FEAT_MTE) then PSTATE.TCO = '1'; end;
    PSTATE.IL = '0';
    if IsFeatureImplemented(FEAT_UAO) then PSTATE.UAO = '0'; end;
    if IsFeatureImplemented(FEAT_UINJ) then PSTATE.UINJ = '0'; end;
    if IsFeatureImplemented(FEAT_PAuth_LR) then PSTATE.PACM = '0'; end;
    if (IsFeatureImplemented(FEAT_PAN) &amp;&amp; (PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> ||
          (PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>))) &amp;&amp;
          <a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().SPAN == '0') then
        PSTATE.PAN = '1';
    end;
    if from_32 then                             // Coming from AArch32
        PSTATE.IT = '00000000';
        PSTATE.T = '0';                         // PSTATE.J is RES0
    end;
    if IsFeatureImplemented(FEAT_BTI) then PSTATE.BTYPE = '00'; end;
    DLR_EL0() = ARBITRARY : bits(64);
    DSPSR_EL0() = ARBITRARY : bits(64);

    EDSCR().ERR = '1';
    UpdateEDSCRFields();                        // Update EDSCR PE state flags.

    if sync_errors then
        SynchronizeErrors();
    end;

    EndOfInstruction();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.watchpoint.AArch64_WatchpointByteMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/watchpoint/AArch64_WatchpointByteMatch</h3>
      <p class="pseudocode">// AArch64_WatchpointByteMatch()
// =============================

func AArch64_WatchpointByteMatch(n : integer, vaddress : bits(64)) =&gt; boolean
begin
    let dbgtop : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>        = DebugAddrTop();
    let cmpbottom : integer{}       = if DBGWVR_EL1(n)[2] == '1' then 2 else 3;// Word or doubleword
    var bottom : integer{}          = cmpbottom;
    let select : integer{}          = UInt(vaddress[cmpbottom-1:0]);
    var byte_select_match : boolean = (DBGWCR_EL1(n).BAS[select] != '0');
    var mask : integer{}            = UInt(DBGWCR_EL1(n).MASK);

    // If DBGWCR_EL1(n).MASK is a nonzero value and DBGWCR_EL1(n).BAS is not set to '11111111', or
    // DBGWCR_EL1(n).BAS specifies a non-contiguous set of bytes behavior is CONSTRAINED
    // UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; !IsOnes(DBGWCR_EL1(n).BAS) then
        byte_select_match = ConstrainUnpredictableBool(Unpredictable_WPMASKANDBAS);
    else
        let LSB : bits(8) = (DBGWCR_EL1(n).BAS AND NOT(DBGWCR_EL1(n).BAS - 1));
        let MSB : bits(8) = (DBGWCR_EL1(n).BAS + LSB);
        if !IsZero(MSB AND (MSB - 1)) then          // Not contiguous
            byte_select_match = ConstrainUnpredictableBool(Unpredictable_WPBASCONTIGUOUS);
            bottom            = 3;                  // For the whole doubleword
        end;
    end;

    // If the address mask is set to a reserved value, the behavior is CONSTRAINED UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; mask &lt;= 2 then
        var c : Constraint;
        (c, mask) = (ConstrainUnpredictableInteger(3, 31, Unpredictable_RESWPMASK)
                        as (Constraint, integer{0..31}));
        assert c IN {Constraint_DISABLED, Constraint_NONE, Constraint_UNKNOWN};
        case c of
            when Constraint_DISABLED =&gt;  return FALSE; // Disabled
            when Constraint_NONE =&gt;      mask = 0;     // No masking
            // Otherwise the value returned by ConstrainUnpredictableInteger is a not-reserved value
        end;
    end;

    // When FEAT_LVA3 is not implemented, if the DBGWVR_EL1(n).RESS field bits are not a
    // sign extension of the MSB of DBGWVR_EL1(n).VA, it is UNPREDICTABLE whether they
    // appear to be included in the match.
    let unpredictable_ress : boolean = (dbgtop &lt; 55 &amp;&amp; !IsOnes(DBGWVR_EL1(n)[63:dbgtop]) &amp;&amp;
                                        !IsZero(DBGWVR_EL1(n)[63:dbgtop]) &amp;&amp;
                                        ConstrainUnpredictableBool(Unpredictable_DBGxVR_RESS));
    let cmpmsb : integer{}    = if unpredictable_ress then 63 else dbgtop;
    let cmplsb : integer{}    = if mask &gt; bottom then mask else bottom;
    let bottombit : integer{} = bottom;
    var WVR_match : boolean   = (vaddress[cmpmsb:cmplsb] == DBGWVR_EL1(n)[cmpmsb:cmplsb]);
    if mask &gt; bottom then
        // If masked bits of DBGWVR_EL1(n) are not zero, the behavior is CONSTRAINED UNPREDICTABLE.
        if WVR_match &amp;&amp; !IsZero(DBGWVR_EL1(n)[cmplsb-1:bottombit]) then
            WVR_match = ConstrainUnpredictableBool(Unpredictable_WPMASKEDBITS);
        end;
    end;

    return (WVR_match &amp;&amp; byte_select_match);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.watchpoint.AArch64_WatchpointMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/watchpoint/AArch64_WatchpointMatch</h3>
      <p class="pseudocode">// AArch64_WatchpointMatch()
// =========================
// Watchpoint matching in an AArch64 translation regime.

func <a id="func_AArch64_WatchpointMatch_4"/>AArch64_WatchpointMatch(n : integer, vaddress : bits(64), size : integer,
                             accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_WatchpointInfo" title="">WatchpointInfo</a>
begin
    assert !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    assert n &lt; <a href="shared_pseudocode.html#func_NumWatchpointsImplemented_0" title="">NumWatchpointsImplemented</a>();

    let enabled : boolean    = <a href="shared_pseudocode.html#func_IsWatchpointEnabled_1" title="">IsWatchpointEnabled</a>(n);
    let linked : boolean     = DBGWCR_EL1(n).WT == '1';
    let isbreakpnt : boolean = FALSE;
    let lbnx : bits(2) = if IsFeatureImplemented(FEAT_Debugv8p9) then DBGWCR_EL1(n).LBNX else '00';
    let linked_n : integer{}  = UInt(lbnx :: DBGWCR_EL1(n).LBN);
    let ssce : bit            = if IsFeatureImplemented(FEAT_RME) then DBGWCR_EL1(n).SSCE else '0';
    let mismatch : boolean    = IsFeatureImplemented(FEAT_BWE2) &amp;&amp; DBGWCR_EL1(n).WT2 == '1';
    let state_match : boolean = <a href="shared_pseudocode.html#func_AArch64_StateMatch_9" title="">AArch64_StateMatch</a>(DBGWCR_EL1(n).SSC, ssce, DBGWCR_EL1(n).HMC,
                                                   DBGWCR_EL1(n).PAC,
                                                   linked, linked_n, isbreakpnt, <a href="shared_pseudocode.html#func_PC64_0" title="">PC64</a>(), accdesc);

    var watchptinfo : <a href="shared_pseudocode.html#type_WatchpointInfo" title="">WatchpointInfo</a>;
    var ls_match : boolean;
    case DBGWCR_EL1(n).LSC[1:0] of
        when '00' =&gt; ls_match = FALSE;
        when '01' =&gt; ls_match = accdesc.read;
        when '10' =&gt; ls_match = accdesc.write || accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>;
        when '11' =&gt; ls_match = TRUE;
    end;

    var value_match : boolean = FALSE;
    watchptinfo.vaddress = vaddress;
    for byte = 0 to size - 1 do
        if (!value_match &amp;&amp;
              !<a href="shared_pseudocode.html#func_AddressInNaturallyAlignedBlock_2" title="">AddressInNaturallyAlignedBlock</a>(watchptinfo.vaddress, vaddress + byte)) then
            // Watchpoint should report an address which is in
            // the naturally aligned block of the matched address.
            watchptinfo.vaddress = vaddress + byte;
        end;
        value_match = value_match || AArch64_WatchpointByteMatch(n, vaddress + byte);
    end;

    watchptinfo.watchpt_num = n;
    watchptinfo.value_match = value_match;
    if !(state_match &amp;&amp; ls_match &amp;&amp; enabled) then
        watchptinfo.wptype = <a href="shared_pseudocode.html#enum_WatchpointType_Inactive" title="">WatchpointType_Inactive</a>;
        watchptinfo.value_match = FALSE;
    elsif mismatch then
        watchptinfo.wptype = <a href="shared_pseudocode.html#enum_WatchpointType_AddrMismatch" title="">WatchpointType_AddrMismatch</a>;
    else
        watchptinfo.wptype = <a href="shared_pseudocode.html#enum_WatchpointType_AddrMatch" title="">WatchpointType_AddrMatch</a>;
    end;
    return watchptinfo;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.watchpoint.IsWatchpointEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/watchpoint/IsWatchpointEnabled</h3>
      <p class="pseudocode">// IsWatchpointEnabled()
// =====================
// Returns TRUE if the effective value of DBGWCR_EL1(n).E is '1', and FALSE otherwise.

func <a id="func_IsWatchpointEnabled_1"/>IsWatchpointEnabled(n : integer) =&gt; boolean
begin
    if (n &gt; 15 &amp;&amp;
          ((!<a href="shared_pseudocode.html#func_HaltOnBreakpointOrWatchpoint_0" title="">HaltOnBreakpointOrWatchpoint</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_SelfHostedExtendedBPWPEnabled_0" title="">SelfHostedExtendedBPWPEnabled</a>()) ||
           (<a href="shared_pseudocode.html#func_HaltOnBreakpointOrWatchpoint_0" title="">HaltOnBreakpointOrWatchpoint</a>() &amp;&amp; EDSCR2().EHBWE == '0'))) then
        return FALSE;
    end;
    return DBGWCR_EL1(n).E == '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64_Abort"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64_Abort</h3>
      <p class="pseudocode">// AArch64_Abort()
// ===============
// Abort and Debug exception handling in an AArch64 translation regime.

func AArch64_Abort(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    if <a href="shared_pseudocode.html#func_IsDebugException_1" title="">IsDebugException</a>(fault) then
        if fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> then
            if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fault.debugmoe == <a href="shared_pseudocode.html#global_DebugException_VectorCatch" title="">DebugException_VectorCatch</a> then
                AArch64_VectorCatchException(fault);
            else
                AArch64_BreakpointException(fault);
            end;
        else
            AArch64_WatchpointException(fault);
        end;
    elsif fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> &amp;&amp; <a href="shared_pseudocode.html#func_ReportAsGPCException_1" title="">ReportAsGPCException</a>(fault) then
        TakeGPCException(fault);
    elsif fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_TagCheck" title="">Fault_TagCheck</a> then
        AArch64_RaiseTagCheckFault(fault);
    elsif <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) &amp;&amp; !<a href="shared_pseudocode.html#func_IsExternalSyncAbort_1" title="">IsExternalSyncAbort</a>(fault) then
        PendSErrorInterrupt(fault);
    elsif fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> then
        AArch64_InstructionAbort(fault);
    else
        AArch64_DataAbort(fault);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64_AbortSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64_AbortSyndrome</h3>
      <p class="pseudocode">// AArch64_AbortSyndrome()
// =======================
// Creates an exception syndrome record for Abort and Watchpoint exceptions
// from an AArch64 translation regime.

func <a id="func_AArch64_AbortSyndrome_3"/>AArch64_AbortSyndrome(exceptype : <a href="shared_pseudocode.html#type_Exception" title="">Exception</a>, fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>,
                           target_el : bits(2)) =&gt; <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>
begin
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(exceptype);

    except.syndrome = <a href="shared_pseudocode.html#func_AArch64_FaultSyndrome_3" title="">AArch64_FaultSyndrome</a>(exceptype, fault, target_el);
    if exceptype IN {<a href="shared_pseudocode.html#enum_Exception_NV2Watchpoint" title="">Exception_NV2Watchpoint</a>, <a href="shared_pseudocode.html#enum_Exception_Watchpoint" title="">Exception_Watchpoint</a>} then
        except.vaddress = fault.watchptinfo.vaddress;
    elsif fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_TagCheck" title="">Fault_TagCheck</a> then
        if IsFeatureImplemented(FEAT_MTE_TAGGED_FAR) then
            except.vaddress = ZeroExtend{64}(fault.vaddress);
        else
            except.vaddress = ARBITRARY : bits(4) :: fault.vaddress[59:0];
        end;
    else
        except.vaddress = ZeroExtend{64}(fault.vaddress);
    end;

    if <a href="shared_pseudocode.html#func_IPAValid_1" title="">IPAValid</a>(fault) then
        except.ipavalid = TRUE;
        except.NS = if fault.ipaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> then '1' else '0';
        except.ipaddress = fault.ipaddress.address;
    else
        except.ipavalid = FALSE;
    end;

    if except.syndrome.iss[14] == '1' then
        except.pavalid  = TRUE;
        except.paddress = fault.paddress;
    else
        except.pavalid  = FALSE;
        except.paddress = ARBITRARY : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;
    end;

    return except;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64_CheckPCAlignment"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64_CheckPCAlignment</h3>
      <p class="pseudocode">// AArch64_CheckPCAlignment()
// ==========================

func AArch64_CheckPCAlignment()
begin
    let pc : bits(64) = ThisInstrAddr{}();

    if pc[1:0] != '00' then
        AArch64_PCAlignmentFault();
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64_DataAbort"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64_DataAbort</h3>
      <p class="pseudocode">// AArch64_DataAbort()
// ===================

func AArch64_DataAbort(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    var target_el : bits(2);
    if <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) then
        target_el = <a href="shared_pseudocode.html#func_SyncExternalAbortTarget_1" title="">SyncExternalAbortTarget</a>(fault);
    else
        let route_to_el2 = (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp;
                            (HCR_EL2().TGE == '1' ||
                            (IsFeatureImplemented(FEAT_RME) &amp;&amp; fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> &amp;&amp;
                             HCR_EL2().GPF == '1') ||
                             (IsFeatureImplemented(FEAT_NV2) &amp;&amp;
                              fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_NV2" title="">AccessType_NV2</a>) ||
                             <a href="shared_pseudocode.html#func_IsSecondStage_1" title="">IsSecondStage</a>(fault)));

        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
            target_el = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
        elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_el2 then
            target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
        else
            target_el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
        end;
    end;

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let route_to_serr : boolean = (<a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) &amp;&amp;
                                      <a href="shared_pseudocode.html#func_AArch64_RouteToSErrorOffset_1" title="">AArch64_RouteToSErrorOffset</a>(target_el));
    let vect_offset : integer = if route_to_serr then 0x180 else 0x0;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>;
    if IsFeatureImplemented(FEAT_NV2) &amp;&amp; fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_NV2" title="">AccessType_NV2</a> then
        except = <a href="shared_pseudocode.html#func_AArch64_AbortSyndrome_3" title="">AArch64_AbortSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_NV2DataAbort" title="">Exception_NV2DataAbort</a>, fault, target_el);
    else
        except = <a href="shared_pseudocode.html#func_AArch64_AbortSyndrome_3" title="">AArch64_AbortSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a>, fault, target_el);
    end;
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64_EffectiveTCF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64_EffectiveTCF</h3>
      <p class="pseudocode">// AArch64_EffectiveTCF()
// ======================
// Indicate if a Tag Check Fault should cause a synchronous exception,
// be asynchronously accumulated, or have no effect on the PE.

func AArch64_EffectiveTCF(el : bits(2), read : boolean) =&gt; <a href="shared_pseudocode.html#TCFType" title="type TCFType">TCFType</a>
begin
    var tcf : bits(2);

    let regime : Regime = TranslationRegime(el);

    case regime of
        when Regime_EL3 =&gt;  tcf = SCTLR_EL3().TCF;
        when Regime_EL2 =&gt;  tcf = SCTLR_EL2().TCF;
        when Regime_EL20 =&gt; tcf = if el == EL0 then SCTLR_EL2().TCF0 else SCTLR_EL2().TCF;
        when Regime_EL10 =&gt; tcf = if el == EL0 then SCTLR_EL1().TCF0 else SCTLR_EL1().TCF;
        otherwise =&gt;        unreachable;
    end;

    if tcf == '11' then        // Reserved value
        if !IsFeatureImplemented(FEAT_MTE_ASYM_FAULT) then
            (-,tcf) = ConstrainUnpredictableBits{2}(Unpredictable_RESTCF);
        end;
    end;

    case tcf of
        when '00' =&gt;   // Tag Check Faults have no effect on the PE
            return TCFType_Ignore;
        when '01' =&gt;   // Tag Check Faults cause a synchronous exception
            return TCFType_Sync;
        when '10' =&gt;
            if IsFeatureImplemented(FEAT_MTE_ASYNC) then
                // If asynchronous faults are implemented,
                // Tag Check Faults are asynchronously accumulated
                return TCFType_Async;
            else
                // Otherwise, Tag Check Faults have no effect on the PE
                return TCFType_Ignore;
            end;
        when '11' =&gt;
            if IsFeatureImplemented(FEAT_MTE_ASYM_FAULT) then
                // Tag Check Faults cause a synchronous exception on reads or on
                // a read/write access, and are asynchronously accumulated on writes
                if read then
                    return TCFType_Sync;
                else
                    return TCFType_Async;
                end;
            else
                // Otherwise, Tag Check Faults have no effect on the PE
                return TCFType_Ignore;
            end;
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64_InstructionAbort"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64_InstructionAbort</h3>
      <p class="pseudocode">// AArch64_InstructionAbort()
// ==========================

func AArch64_InstructionAbort(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    // External aborts on instruction fetch must be taken synchronously
    if IsFeatureImplemented(FEAT_DoubleFault) then
        assert fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a>;
    end;

    var target_el : bits(2);
    if <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) then
        target_el = <a href="shared_pseudocode.html#func_SyncExternalAbortTarget_1" title="">SyncExternalAbortTarget</a>(fault);
    else
        let route_to_el2 : boolean = (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp;
                                      (HCR_EL2().TGE == '1' ||
                                      (IsFeatureImplemented(FEAT_RME) &amp;&amp;
                                       fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> &amp;&amp;
                                       HCR_EL2().GPF == '1') ||
                                       <a href="shared_pseudocode.html#func_IsSecondStage_1" title="">IsSecondStage</a>(fault)));

        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
            target_el = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
        elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_el2 then
            target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
        else
            target_el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
        end;
    end;

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    var vect_offset : integer;

    if <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_RouteToSErrorOffset_1" title="">AArch64_RouteToSErrorOffset</a>(target_el) then
        vect_offset = 0x180;
    else
        vect_offset = 0x0;
    end;

    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_AArch64_AbortSyndrome_3" title="">AArch64_AbortSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_InstructionAbort" title="">Exception_InstructionAbort</a>, fault,
                                                            target_el);
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64_PCAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64_PCAlignmentFault</h3>
      <p class="pseudocode">// AArch64_PCAlignmentFault()
// ==========================
// Called on unaligned program counter in AArch64 state.

func AArch64_PCAlignmentFault()
begin

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_PCAlignment" title="">Exception_PCAlignment</a>);
    except.vaddress = <a href="shared_pseudocode.html#func_ThisInstrAddr_1" title="">ThisInstrAddr</a>{64}();
    var target_el : bits(2) = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    if UInt(PSTATE.EL) &gt; UInt(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        target_el = PSTATE.EL;
    elsif <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    end;
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64_RaiseTagCheckFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64_RaiseTagCheckFault</h3>
      <p class="pseudocode">// AArch64_RaiseTagCheckFault()
// ============================
// Raise a Tag Check Fault exception.

func AArch64_RaiseTagCheckFault(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;
    var target_el : bits(2) = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    if UInt(PSTATE.EL) &gt; UInt(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        target_el = PSTATE.EL;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    end;

    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_AArch64_AbortSyndrome_3" title="">AArch64_AbortSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a>, fault, target_el);
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64_ReportTagCheckFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64_ReportTagCheckFault</h3>
      <p class="pseudocode">// AArch64_ReportTagCheckFault()
// =============================
// Records a Tag Check Fault exception into the appropriate TFSR_ELx.

func AArch64_ReportTagCheckFault(el : bits(2), ttbr : bit)
begin
    case el of
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; assert ttbr == '0'; TFSR_EL3().TF0   = '1';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; if ttbr == '0' then TFSR_EL2().TF0   = '1'; else TFSR_EL2().TF1   = '1'; end;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; if ttbr == '0' then TFSR_EL1().TF0   = '1'; else TFSR_EL1().TF1   = '1'; end;
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt; if ttbr == '0' then TFSRE0_EL1().TF0 = '1'; else TFSRE0_EL1().TF1 = '1'; end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64_RouteToSErrorOffset"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64_RouteToSErrorOffset</h3>
      <p class="pseudocode">// AArch64_RouteToSErrorOffset()
// =============================
// Returns TRUE if synchronous External abort exceptions are taken to the
// appropriate SError vector offset, and FALSE otherwise.

func <a id="func_AArch64_RouteToSErrorOffset_1"/>AArch64_RouteToSErrorOffset(target_el : bits(2)) =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_DoubleFault) then return FALSE; end;

    var ease_bit : bit;
    case target_el of
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            ease_bit = SCR_EL3().EASE;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            if IsFeatureImplemented(FEAT_DoubleFault2) &amp;&amp; <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then
                ease_bit = SCTLR2_EL2().EASE;
            else
                ease_bit = '0';
            end;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            if IsFeatureImplemented(FEAT_DoubleFault2) &amp;&amp; <a href="shared_pseudocode.html#func_IsSCTLR2EL1Enabled_0" title="">IsSCTLR2EL1Enabled</a>() then
                ease_bit = SCTLR2_EL1().EASE;
            else
                ease_bit = '0';
            end;
    end;
    return (ease_bit == '1');
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64_SPAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64_SPAlignmentFault</h3>
      <p class="pseudocode">// AArch64_SPAlignmentFault()
// ==========================
// Called on an unaligned stack pointer in AArch64 state.

func AArch64_SPAlignmentFault()
begin

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SPAlignment" title="">Exception_SPAlignment</a>);

    var target_el : bits(2) = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    if UInt(PSTATE.EL) &gt; UInt(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        target_el = PSTATE.EL;
    elsif <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    end;
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.BranchTargetException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/BranchTargetException</h3>
      <p class="pseudocode">// BranchTargetException()
// =======================
// Raise branch target exception.

func AArch64_BranchTargetException(vaddress : bits(52))
begin
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_BranchTarget" title="">Exception_BranchTarget</a>);
    except.syndrome.iss[1:0]   = PSTATE.BTYPE;
    except.syndrome.iss[24:2]  = Zeros{23};         // RES0

    var target_el : bits(2) = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    if UInt(PSTATE.EL) &gt; UInt(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        target_el = PSTATE.EL;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    end;
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.TCFType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/TCFType</h3>
      <p class="pseudocode">// TCFType
// =======

type <a id="TCFType"/>TCFType of enumeration { TCFType_Sync, TCFType_Async, TCFType_Ignore };</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.TakeGPCException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/TakeGPCException</h3>
      <p class="pseudocode">// TakeGPCException()
// ==================
// Report Granule Protection Exception faults

func TakeGPCException(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    assert IsFeatureImplemented(FEAT_RME);
    assert IsFeatureImplemented(FEAT_LSE);
    assert IsFeatureImplemented(FEAT_HAFDBS);
    assert IsFeatureImplemented(FEAT_DoubleFault);

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>;

    except.exceptype = <a href="shared_pseudocode.html#enum_Exception_GPC" title="">Exception_GPC</a>;
    except.vaddress  = ZeroExtend{64}(fault.vaddress);
    except.paddress  = fault.paddress;
    except.pavalid   = TRUE;

    if <a href="shared_pseudocode.html#func_IPAValid_1" title="">IPAValid</a>(fault) then
        except.ipavalid  = TRUE;
        except.NS        = if fault.ipaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> then '1' else '0';
        except.ipaddress = fault.ipaddress.address;
    else
        except.ipavalid  = FALSE;
    end;

    except.syndrome.iss2[11] = if fault.hdbssf then '1' else '0';   // HDBSSF
    if fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_GCS" title="">AccessType_GCS</a> then
        except.syndrome.iss2[8] = '1'; //GCS
    end;

    // Populate the fields grouped in ISS
    except.syndrome.iss[24:22] = Zeros{3}; // RES0
    except.syndrome.iss[21]    = if fault.gpcfs2walk then '1' else '0';  // S2PTW
    if fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> then
        except.syndrome.iss[20] = '1';     // InD
    else
        except.syndrome.iss[20] = '0';     // InD
    end;
    except.syndrome.iss[19:14] = <a href="shared_pseudocode.html#func_EncodeGPCSC_1" title="">EncodeGPCSC</a>(fault.gpcf); // GPCSC
    if IsFeatureImplemented(FEAT_NV2) &amp;&amp; fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_NV2" title="">AccessType_NV2</a> then
        except.syndrome.iss[13] = '1';     // VNCR
    else
        except.syndrome.iss[13] = '0';     // VNCR
    end;
    except.syndrome.iss[12:11]  = '00';     // RES0
    except.syndrome.iss[10:9]   = '00';     // RES0

    if fault.accessdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>, <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>} then
        except.syndrome.iss[8] = '1'; // CM
    else
        except.syndrome.iss[8] = '0'; // CM
    end;

    except.syndrome.iss[7] = if fault.s2fs1walk then '1' else '0'; // S1PTW

    if fault.accessdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>, <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>} then
        except.syndrome.iss[6] = '1';                              // WnR
    elsif fault.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_HWUpdateAccessFlag" title="">Fault_HWUpdateAccessFlag</a>, <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a>} then
        except.syndrome.iss[6] = ARBITRARY : bit;                      // WnR
    elsif fault.accessdesc.atomicop &amp;&amp; <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) then
        except.syndrome.iss[6] = ARBITRARY : bit;                      // WnR
    else
        except.syndrome.iss[6] = if fault.write then '1' else '0'; // WnR
    end;

    except.syndrome.iss[5:0] = <a href="shared_pseudocode.html#func_EncodeLDFSC_2" title="">EncodeLDFSC</a>(fault.statuscode, fault.level); // xFSC

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let target_el : bits(2) = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;

    var vect_offset : integer;
    if <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_RouteToSErrorOffset_1" title="">AArch64_RouteToSErrorOffset</a>(target_el) then
        vect_offset = 0x180;
    else
        vect_offset = 0x0;
    end;

    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64_TakeDelegatedSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64_TakeDelegatedSErrorException</h3>
      <p class="pseudocode">// AArch64_TakeDelegatedSErrorException()
// ======================================

func AArch64_TakeDelegatedSErrorException()
begin
    assert IsFeatureImplemented(FEAT_E3DSE) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; SCR_EL3().[EnDSE,DSE] == '11';

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset = 0x180;
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SError" title="">Exception_SError</a>);

    var target_el : bits(2);
    var dsei_masked : boolean;
    (dsei_masked, target_el)  = <a href="shared_pseudocode.html#func_AArch64_DelegatedSErrorTarget_0" title="">AArch64_DelegatedSErrorTarget</a>();
    assert !dsei_masked;
    except.syndrome.iss[24]   = VSESR_EL3().IDS;
    except.syndrome.iss[23:0] = VSESR_EL3().ISS;
    ClearPendingDelegatedSError();

    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64_TakePhysicalFIQException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64_TakePhysicalFIQException</h3>
      <p class="pseudocode">// AArch64_TakePhysicalFIQException()
// ==================================

func AArch64_TakePhysicalFIQException()
begin

    let route_to_el3 : boolean = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().FIQ == '1';
    let route_to_el2 : boolean = (PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
                                  (HCR_EL2().TGE == '1' || HCR_EL2().FMO == '1'));
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x100;
    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_FIQ" title="">Exception_FIQ</a>);

    if route_to_el3 then
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, except, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_el2 then
        assert PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    else
        assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64_TakePhysicalIRQException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64_TakePhysicalIRQException</h3>
      <p class="pseudocode">// AArch64_TakePhysicalIRQException()
// ==================================
// Take an enabled physical IRQ exception.

func AArch64_TakePhysicalIRQException()
begin

    let route_to_el3 : boolean = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().IRQ == '1';
    let route_to_el2 : boolean = (PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
                                 (HCR_EL2().TGE == '1' || HCR_EL2().IMO == '1'));
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x80;

    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_IRQ" title="">Exception_IRQ</a>);

    if route_to_el3 then
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, except, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_el2 then
        assert PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    else
        assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64_TakePhysicalSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64_TakePhysicalSErrorException</h3>
      <p class="pseudocode">// AArch64_TakePhysicalSErrorException()
// =====================================

func AArch64_TakePhysicalSErrorException(implicit_esb : boolean)
begin
    var masked : boolean;
    var target_el : bits(2);

    (masked, target_el) = <a href="shared_pseudocode.html#func_PhysicalSErrorTarget_0" title="">PhysicalSErrorTarget</a>();
    assert !masked;

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer    = 0x180;
    let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>      = <a href="shared_pseudocode.html#func_GetPendingPhysicalSError_0" title="">GetPendingPhysicalSError</a>();
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SError" title="">Exception_SError</a>);
    let is_esb : boolean         = FALSE;
    let syndrome : bits(25)      = <a href="shared_pseudocode.html#func_AArch64_PhysicalSErrorSyndrome_2" title="">AArch64_PhysicalSErrorSyndrome</a>(is_esb, implicit_esb);

    if <a href="shared_pseudocode.html#func_IsSErrorEdgeTriggered_0" title="">IsSErrorEdgeTriggered</a>() then
        ClearPendingPhysicalSError();
    end;

    if except.syndrome.iss[14] == '1' then
        except.pavalid  = TRUE;
        except.paddress = fault.paddress;
    else
        except.pavalid  = FALSE;
        except.paddress = ARBITRARY : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;
    end;
    except.syndrome.iss = syndrome;
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64_TakeVirtualFIQException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64_TakeVirtualFIQException</h3>
      <p class="pseudocode">// AArch64_TakeVirtualFIQException()
// =================================

func AArch64_TakeVirtualFIQException()
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
    // Virtual IRQ enabled if TGE==0 and FMO==1
    assert HCR_EL2().TGE == '0' &amp;&amp; HCR_EL2().FMO == '1';

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x100;

    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_FIQ" title="">Exception_FIQ</a>);

    AArch64_TakeException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64_TakeVirtualIRQException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64_TakeVirtualIRQException</h3>
      <p class="pseudocode">// AArch64_TakeVirtualIRQException()
// =================================

func AArch64_TakeVirtualIRQException()
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
    // Virtual IRQ enabled if TGE==0 and IMO==1
    assert HCR_EL2().TGE == '0' &amp;&amp; HCR_EL2().IMO == '1';

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x80;

    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_IRQ" title="">Exception_IRQ</a>);

    AArch64_TakeException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64_TakeVirtualSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64_TakeVirtualSErrorException</h3>
      <p class="pseudocode">// AArch64_TakeVirtualSErrorException()
// ====================================

func AArch64_TakeVirtualSErrorException()
begin

    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
    // Virtual SError enabled if TGE==0 and AMO==1 or TMEA==1
    assert (HCR_EL2().TGE == '0' &amp;&amp;
            (HCR_EL2().AMO == '1' || (<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() &amp;&amp; HCRX_EL2().TMEA == '1')));

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer                 = 0x180;
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>              = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SError" title="">Exception_SError</a>);

    if IsFeatureImplemented(FEAT_RAS) then
        except.syndrome.iss[24]   = VSESR_EL2().IDS;
        except.syndrome.iss[23:0] = VSESR_EL2().ISS;
    else
        let syndrome : bits(25)       = ImpDefBits{}("Virtual SError syndrome");
        let impdef_syndrome : boolean = syndrome[24] == '1';
        if impdef_syndrome then except.syndrome.iss = syndrome; end;
    end;

    ClearPendingVirtualSError();
    AArch64_TakeException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64_BreakpointException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64_BreakpointException</h3>
      <p class="pseudocode">// AArch64_BreakpointException()
// =============================

func AArch64_BreakpointException(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    assert PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;

    let route_to_el2 : boolean = (PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
                                  (HCR_EL2().TGE == '1' || MDCR_EL2().TDE == '1'));

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    var target_el : bits(2);
    let vect_offset : integer = 0x0;
    target_el = if (PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_el2) then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;

    let vaddress : bits(64)      = ARBITRARY : bits(64);
    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_AArch64_AbortSyndrome_3" title="">AArch64_AbortSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_Breakpoint" title="">Exception_Breakpoint</a>, fault, target_el);
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64_SoftwareBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64_SoftwareBreakpoint</h3>
      <p class="pseudocode">// AArch64_SoftwareBreakpoint()
// ============================

func AArch64_SoftwareBreakpoint(immediate : bits(16))
begin

    let route_to_el2 : boolean = (PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp;
                                  <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; (HCR_EL2().TGE == '1' || MDCR_EL2().TDE == '1'));

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SoftwareBreakpoint" title="">Exception_SoftwareBreakpoint</a>);
    except.syndrome.iss[15:0]    = immediate;

    if UInt(PSTATE.EL) &gt; UInt(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    else
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64_SoftwareStepException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64_SoftwareStepException</h3>
      <p class="pseudocode">// AArch64_SoftwareStepException()
// ===============================

func AArch64_SoftwareStepException()
begin
    assert PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;

    let route_to_el2 : boolean = (PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
                                  (HCR_EL2().TGE == '1' || MDCR_EL2().TDE == '1'));

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SoftwareStep" title="">Exception_SoftwareStep</a>);
    if <a href="shared_pseudocode.html#func_SoftwareStep_DidNotStep_0" title="">SoftwareStep_DidNotStep</a>() then
        except.syndrome.iss[24] = '0';
    else
        except.syndrome.iss[24] = '1';
        except.syndrome.iss[6] = if <a href="shared_pseudocode.html#func_SoftwareStep_SteppedEX_0" title="">SoftwareStep_SteppedEX</a>() then '1' else '0';
    end;
    except.syndrome.iss[5:0] = '100010';                // IFSC = Debug Exception

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_el2 then
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    else
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64_VectorCatchException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64_VectorCatchException</h3>
      <p class="pseudocode">// AArch64_VectorCatchException()
// ==============================
// Vector Catch taken from EL0 or EL1 to EL2. This can only be called when debug exceptions are
// being routed to EL2, as Vector Catch is a legacy debug event.

func AArch64_VectorCatchException(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    assert PSTATE.EL != <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    assert <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; (HCR_EL2().TGE == '1' || MDCR_EL2().TDE == '1');

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    let vaddress : bits(64)      = ARBITRARY : bits(64);
    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_AArch64_AbortSyndrome_3" title="">AArch64_AbortSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_VectorCatch" title="">Exception_VectorCatch</a>, fault, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);

    AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64_WatchpointException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64_WatchpointException</h3>
      <p class="pseudocode">// AArch64_WatchpointException()
// =============================

func AArch64_WatchpointException(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    assert PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;

    let route_to_el2 : boolean = (PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
                                  (HCR_EL2().TGE == '1' || MDCR_EL2().TDE == '1'));

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    var target_el : bits(2);
    let vect_offset : integer = 0x0;
    target_el = if (PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || route_to_el2) then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>;
    if IsFeatureImplemented(FEAT_NV2) &amp;&amp; fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_NV2" title="">AccessType_NV2</a> then
        except = <a href="shared_pseudocode.html#func_AArch64_AbortSyndrome_3" title="">AArch64_AbortSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_NV2Watchpoint" title="">Exception_NV2Watchpoint</a>, fault, target_el);
    else
        except = <a href="shared_pseudocode.html#func_AArch64_AbortSyndrome_3" title="">AArch64_AbortSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_Watchpoint" title="">Exception_Watchpoint</a>, fault, target_el);
    end;
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.exceptions.AArch64_ExceptionClass"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/exceptions/AArch64_ExceptionClass</h3>
      <p class="pseudocode">// AArch64_ExceptionClass()
// ========================
// Returns the Exception Class and Instruction Length fields to be reported in ESR

func <a id="func_AArch64_ExceptionClass_2"/>AArch64_ExceptionClass(exceptype : <a href="shared_pseudocode.html#type_Exception" title="">Exception</a>, target_el : bits(2)) =&gt; (integer,bit)
begin

    var il_is_valid : boolean = TRUE;
    let from_32 : boolean = <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
    var ec : integer;
    case exceptype of
        when <a href="shared_pseudocode.html#enum_Exception_Uncategorized" title="">Exception_Uncategorized</a> =&gt;         ec = 0x00; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_WFxTrap" title="">Exception_WFxTrap</a>       =&gt;         ec = 0x01;
        when <a href="shared_pseudocode.html#enum_Exception_CP15RTTrap" title="">Exception_CP15RTTrap</a>    =&gt;         ec = 0x03; assert from_32;
        when <a href="shared_pseudocode.html#enum_Exception_CP15RRTTrap" title="">Exception_CP15RRTTrap</a>   =&gt;         ec = 0x04; assert from_32;
        when <a href="shared_pseudocode.html#enum_Exception_CP14RTTrap" title="">Exception_CP14RTTrap</a>    =&gt;         ec = 0x05; assert from_32;
        when <a href="shared_pseudocode.html#enum_Exception_CP14DTTrap" title="">Exception_CP14DTTrap</a>    =&gt;         ec = 0x06; assert from_32;
        when <a href="shared_pseudocode.html#enum_Exception_AdvSIMDFPAccessTrap" title="">Exception_AdvSIMDFPAccessTrap</a> =&gt;   ec = 0x07;
        when <a href="shared_pseudocode.html#enum_Exception_FPIDTrap" title="">Exception_FPIDTrap</a>      =&gt;         ec = 0x08;
        when <a href="shared_pseudocode.html#enum_Exception_PACTrap" title="">Exception_PACTrap</a>       =&gt;         ec = 0x09;
        when <a href="shared_pseudocode.html#enum_Exception_LDST64BTrap" title="">Exception_LDST64BTrap</a>   =&gt;         ec = 0x0A;
        when <a href="shared_pseudocode.html#enum_Exception_GPC" title="">Exception_GPC</a>           =&gt;         ec = 0x1E;
        when <a href="shared_pseudocode.html#enum_Exception_CP14RRTTrap" title="">Exception_CP14RRTTrap</a>   =&gt;         ec = 0x0C; assert from_32;
        when <a href="shared_pseudocode.html#enum_Exception_BranchTarget" title="">Exception_BranchTarget</a>  =&gt;         ec = 0x0D;
        when <a href="shared_pseudocode.html#enum_Exception_IllegalState" title="">Exception_IllegalState</a>  =&gt;         ec = 0x0E; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_SupervisorCall" title="">Exception_SupervisorCall</a> =&gt;        ec = if from_32 then 0x11 else 0x15;
        when <a href="shared_pseudocode.html#enum_Exception_HypervisorCall" title="">Exception_HypervisorCall</a> =&gt;        ec = if from_32 then 0x12 else 0x16;
        when <a href="shared_pseudocode.html#enum_Exception_MonitorCall" title="">Exception_MonitorCall</a> =&gt;           ec = if from_32 then 0x13 else 0x17;
        when <a href="shared_pseudocode.html#enum_Exception_SystemRegisterTrap" title="">Exception_SystemRegisterTrap</a> =&gt;    ec = 0x18; assert !from_32;
        when <a href="shared_pseudocode.html#enum_Exception_SystemRegister128Trap" title="">Exception_SystemRegister128Trap</a> =&gt; ec = 0x14; assert !from_32;
        when <a href="shared_pseudocode.html#enum_Exception_SVEAccessTrap" title="">Exception_SVEAccessTrap</a> =&gt;         ec = 0x19; assert !from_32;
        when <a href="shared_pseudocode.html#enum_Exception_ERetTrap" title="">Exception_ERetTrap</a> =&gt;              ec = 0x1A; assert !from_32;
        when <a href="shared_pseudocode.html#enum_Exception_PACFail" title="">Exception_PACFail</a> =&gt;               ec = 0x1C; assert !from_32;
        when <a href="shared_pseudocode.html#enum_Exception_SMEAccessTrap" title="">Exception_SMEAccessTrap</a> =&gt;         ec = 0x1D; assert !from_32;
        when <a href="shared_pseudocode.html#enum_Exception_InstructionAbort" title="">Exception_InstructionAbort</a> =&gt;
            ec = if target_el == PSTATE.EL then 0x21 else 0x20;
            il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_PCAlignment" title="">Exception_PCAlignment</a> =&gt;           ec = 0x22; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a> =&gt;             ec = if target_el == PSTATE.EL then 0x25 else 0x24;
        when <a href="shared_pseudocode.html#enum_Exception_NV2DataAbort" title="">Exception_NV2DataAbort</a> =&gt;          ec = 0x25;
        when <a href="shared_pseudocode.html#enum_Exception_SPAlignment" title="">Exception_SPAlignment</a> =&gt;           ec = 0x26; il_is_valid = FALSE; assert !from_32;
        when <a href="shared_pseudocode.html#enum_Exception_MemCpyMemSet" title="">Exception_MemCpyMemSet</a> =&gt;          ec = 0x27;
        when <a href="shared_pseudocode.html#enum_Exception_GCSFail" title="">Exception_GCSFail</a> =&gt;               ec = 0x2D; assert !from_32;
        when <a href="shared_pseudocode.html#enum_Exception_FPTrappedException" title="">Exception_FPTrappedException</a> =&gt;    ec = if from_32 then 0x28 else 0x2C;
        when <a href="shared_pseudocode.html#enum_Exception_SError" title="">Exception_SError</a> =&gt;                ec = 0x2F; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_Breakpoint" title="">Exception_Breakpoint</a> =&gt;
            ec = if target_el == PSTATE.EL then 0x31 else 0x30;
            il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_SoftwareStep" title="">Exception_SoftwareStep</a> =&gt;
            ec = if target_el == PSTATE.EL then 0x33 else 0x32;
            il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_Watchpoint" title="">Exception_Watchpoint</a> =&gt;
            ec = if target_el == PSTATE.EL then 0x35 else 0x34;
            il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_NV2Watchpoint" title="">Exception_NV2Watchpoint</a> =&gt;         ec = 0x35; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#enum_Exception_SoftwareBreakpoint" title="">Exception_SoftwareBreakpoint</a> =&gt;    ec = if from_32 then 0x38 else 0x3C;
        when <a href="shared_pseudocode.html#enum_Exception_VectorCatch" title="">Exception_VectorCatch</a> =&gt;           ec = 0x3A; il_is_valid = FALSE; assert from_32;
        when <a href="shared_pseudocode.html#enum_Exception_Profiling" title="">Exception_Profiling</a> =&gt;             ec = 0x3D;
        otherwise =&gt;                            unreachable;
    end;

    var il : bit;
    if il_is_valid then
        il = if <a href="shared_pseudocode.html#func_ThisInstrLength_0" title="">ThisInstrLength</a>() == 32 then '1' else '0';
    else
        il = '1';
    end;
    assert from_32 || il == '1';            // AArch64 instructions always 32-bit

    return (ec,il);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.exceptions.AArch64_ReportException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/exceptions/AArch64_ReportException</h3>
      <p class="pseudocode">// AArch64_ReportException()
// =========================
// Report syndrome information for exception taken to AArch64 state.

func AArch64_ReportException(except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>, target_el : bits(2))
begin

    let exceptype : <a href="shared_pseudocode.html#type_Exception" title="">Exception</a> = except.exceptype;

    var (ec,il) = <a href="shared_pseudocode.html#func_AArch64_ExceptionClass_2" title="">AArch64_ExceptionClass</a>(exceptype, target_el);
    let iss : bits(25)  = except.syndrome.iss;
    let iss2 : bits(24) = except.syndrome.iss2;

    // IL is not valid for Data Abort exceptions without valid instruction syndrome information
    if ec IN {0x24,0x25} &amp;&amp; iss[24] == '0' then
        il = '1';
    end;

    <a href="shared_pseudocode.html#accessor_ESR_EL_1" title="">ESR_EL</a>(target_el) = (Zeros{8}  ::   // [63:56]
                         iss2      ::   // [55:32]
                         ec[5:0]   ::   // [31:26]
                         il        ::   // [25]
                         iss);          // [24:0]

    if exceptype IN {
        <a href="shared_pseudocode.html#enum_Exception_InstructionAbort" title="">Exception_InstructionAbort</a>,
        <a href="shared_pseudocode.html#enum_Exception_PCAlignment" title="">Exception_PCAlignment</a>,
        <a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a>,
        <a href="shared_pseudocode.html#enum_Exception_NV2DataAbort" title="">Exception_NV2DataAbort</a>,
        <a href="shared_pseudocode.html#enum_Exception_NV2Watchpoint" title="">Exception_NV2Watchpoint</a>,
        <a href="shared_pseudocode.html#enum_Exception_GPC" title="">Exception_GPC</a>,
        <a href="shared_pseudocode.html#enum_Exception_Watchpoint" title="">Exception_Watchpoint</a>
    } then
        <a href="shared_pseudocode.html#accessor_FAR_EL_1" title="">FAR_EL</a>(target_el) = except.vaddress;
    else
        <a href="shared_pseudocode.html#accessor_FAR_EL_1" title="">FAR_EL</a>(target_el) = ARBITRARY : bits(64);
    end;

    if except.ipavalid then
        HPFAR_EL2()[47:4] = except.ipaddress[55:12];
        if <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
            HPFAR_EL2().NS = except.NS;
        else
            HPFAR_EL2().NS = '0';
        end;
    elsif target_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        HPFAR_EL2()[47:4] = ARBITRARY : bits(44);
    end;

    if except.pavalid then
        var faultaddr : bits(64) = ZeroExtend{}(except.paddress.address);
        if IsFeatureImplemented(FEAT_RME) then
            case except.paddress.paspace of
                when <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> =&gt;     faultaddr[63:62] = '00';
                when <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> =&gt;  faultaddr[63:62] = '10';
                when <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a> =&gt;       faultaddr[63:62] = '01';
                when <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> =&gt;      faultaddr[63:62] = '11';
            end;
            if exceptype == <a href="shared_pseudocode.html#enum_Exception_GPC" title="">Exception_GPC</a> then
                faultaddr[11:0] = Zeros{12};
            end;
        else
            faultaddr[63] = if except.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> then '1' else '0';
        end;
        <a href="shared_pseudocode.html#accessor_PFAR_EL_1" title="">PFAR_EL</a>(target_el) = faultaddr;
    elsif (IsFeatureImplemented(FEAT_PFAR) ||
             (IsFeatureImplemented(FEAT_RME) &amp;&amp; target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>)) then
        <a href="shared_pseudocode.html#accessor_PFAR_EL_1" title="">PFAR_EL</a>(target_el) = ARBITRARY : bits(64);
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.exceptions.AArch64_ResetControlRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/exceptions/AArch64_ResetControlRegisters</h3>
      <p class="pseudocode">// AArch64_ResetControlRegisters()
// ===============================
// Resets System registers and memory-mapped control registers that have architecturally-defined
// reset values to those values.

impdef func AArch64_ResetControlRegisters(cold_reset : boolean)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.exceptions.AArch64_TakeReset"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/exceptions/AArch64_TakeReset</h3>
      <p class="pseudocode">// AArch64_TakeReset()
// ===================
// Reset into AArch64 state

func AArch64_TakeReset(cold_reset : boolean)
begin
    assert HaveAArch64();

    // Enter the highest implemented Exception level in AArch64 state
    PSTATE.nRW = '0';
    if HaveEL(EL3) then
        PSTATE.EL = EL3;
    elsif HaveEL(EL2) then
        PSTATE.EL = EL2;
    else
        PSTATE.EL = EL1;
    end;

    // Reset System registers and other system components
    AArch64_ResetControlRegisters(cold_reset);

    // Reset all other PSTATE fields
    PSTATE.SP = '1';                    // Select stack pointer
    PSTATE.[D,A,I,F]  = '1111';         // All asynchronous exceptions masked
    PSTATE.SS = '0';                    // Clear software step bit
    PSTATE.DIT = '0';                   // PSTATE.DIT is reset to 0 when resetting into AArch64
    if IsFeatureImplemented(FEAT_PAuth_LR) then
        PSTATE.PACM = '0';              // PAC modifier
    end;
    if IsFeatureImplemented(FEAT_SME) then
        PSTATE.[SM,ZA] = '00';          // Disable Streaming SVE mode &amp; ZA storage
        ResetSMEState('0');
    end;
    if IsFeatureImplemented(FEAT_SSBS) then
        PSTATE.SSBS = ImpDefBit("PSTATE.SSBS bit at reset");
    end;
    if IsFeatureImplemented(FEAT_GCS) then
        PSTATE.EXLOCK = '0';            // PSTATE.EXLOCK is reset to 0 when resetting into AArch64
    end;
    if IsFeatureImplemented(FEAT_UINJ) then
        PSTATE.UINJ = '0';              // PSTATE.UINJ is reset to 0 when resetting into AArch64
    end;
    PSTATE.IL = '0';                    // Clear Illegal Execution state bit

    // All registers, bits and fields not reset by the above pseudocode or by the BranchTo() call
    // below are UNKNOWN bitstrings after reset. In particular, the return information registers
    // ELR_ELx and SPSR_ELx have UNKNOWN values, so that it
    // is impossible to return from a reset in an architecturally defined way.
    AArch64_ResetGeneralRegisters();
    if IsFeatureImplemented(FEAT_SME) || IsFeatureImplemented(FEAT_SVE) then
        ResetSVERegisters();
    else
        AArch64_ResetSIMDFPRegisters();
    end;
    AArch64_ResetSpecialRegisters();
    ResetExternalDebugRegisters(cold_reset);

    var rv : bits(64);                      // IMPLEMENTATION DEFINED reset vector

    if HaveEL(EL3) then
        rv = RVBAR_EL3();
    elsif HaveEL(EL2) then
        rv = RVBAR_EL2();
    else
        rv = RVBAR_EL1();
    end;

    // The reset vector must be correctly aligned
    let pamax : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = AArch64_PAMax();
    assert IsZero(rv[63:pamax]) &amp;&amp; IsZero(rv[1:0]);

    let branch_conditional : boolean = FALSE;
    EDPRSR().R = '0';                 // Leaving Reset State.
    BranchTo{64}(rv, BranchType_RESET, branch_conditional);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.ieeefp.AArch64_FPTrappedException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/ieeefp/AArch64_FPTrappedException</h3>
      <p class="pseudocode">// AArch64_FPTrappedException()
// ============================

func AArch64_FPTrappedException(is_ase : boolean, accumulated_exceptions : bits(8))
begin
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_FPTrappedException" title="">Exception_FPTrappedException</a>);
    if is_ase then
        if ImpDefBool("vector instructions set TFV to 1") then
            except.syndrome.iss[23] = '1';                          // TFV
        else
            except.syndrome.iss[23] = '0';                          // TFV
        end;
    else
        except.syndrome.iss[23]     = '1';                          // TFV
    end;
    except.syndrome.iss[10:8] = ARBITRARY : bits(3);                // VECITR
    if except.syndrome.iss[23] == '1' then
        except.syndrome.iss[7,4:0] = accumulated_exceptions[7,4:0]; // IDF,IXF,UFF,OFF,DZF,IOF
    else
        except.syndrome.iss[7,4:0] = ARBITRARY : bits(6);
    end;

    let route_to_el2 : boolean = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1';

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    if UInt(PSTATE.EL) &gt; UInt(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    else
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.syscalls.AArch64_CallHypervisor"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/syscalls/AArch64_CallHypervisor</h3>
      <p class="pseudocode">// AArch64_CallHypervisor()
// ========================
// Performs a HVC call

func AArch64_CallHypervisor(immediate : bits(16))
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);

    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then AArch32_ITAdvance(); end;
    SSAdvance();
    let preferred_exception_return : bits(64) = NextInstrAddr{}();
    let vect_offset : integer{} = 0x0;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_HypervisorCall" title="">Exception_HypervisorCall</a>);
    except.syndrome.iss[15:0] = immediate;

    if IsFeatureImplemented(FEAT_PAuth_LR) then PSTATE.PACM = '0'; end;
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, except, preferred_exception_return, vect_offset);
    else
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.syscalls.AArch64_CallSecureMonitor"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/syscalls/AArch64_CallSecureMonitor</h3>
      <p class="pseudocode">// AArch64_CallSecureMonitor()
// ===========================

func AArch64_CallSecureMonitor(immediate : bits(16))
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then AArch32_ITAdvance(); end;
    HSAdvance();
    SSAdvance();
    let preferred_exception_return : bits(64) = NextInstrAddr{}();
    let vect_offset : integer{} = 0x0;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_MonitorCall" title="">Exception_MonitorCall</a>);
    except.syndrome.iss[15:0] = immediate;
    if IsFeatureImplemented(FEAT_PAuth_LR) then PSTATE.PACM = '0'; end;
    AArch64_TakeException(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.syscalls.AArch64_CallSupervisor"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/syscalls/AArch64_CallSupervisor</h3>
      <p class="pseudocode">// AArch64_CallSupervisor()
// ========================
// Calls the Supervisor

func AArch64_CallSupervisor(immediate : bits(16))
begin
    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then AArch32_ITAdvance(); end;
    SSAdvance();
    let route_to_el2 : boolean = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1';

    let preferred_exception_return : bits(64) = NextInstrAddr{}();
    let vect_offset : integer{} = 0x0;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SupervisorCall" title="">Exception_SupervisorCall</a>);
    except.syndrome.iss[15:0] = immediate;
    if IsFeatureImplemented(FEAT_PAuth_LR) then PSTATE.PACM = '0'; end;
    if UInt(PSTATE.EL) &gt; UInt(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    else
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.takeexception.AArch64_TakeException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/takeexception/AArch64_TakeException</h3>
      <p class="pseudocode">// AArch64_TakeException()
// =======================
// Take an exception to an Exception level using AArch64.

noreturn func AArch64_TakeException(target_el : bits(2), exception_in : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>,
                                    preferred_exception_return : bits(64), vect_offset_in : integer)
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(target_el) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(target_el) &amp;&amp; UInt(target_el) &gt;= UInt(PSTATE.EL);
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        AArch64_TakeExceptionInDebugState(target_el, exception_in);
    end;
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = exception_in;
    var sync_errors : boolean;
    var iesb_req : boolean;
    if IsFeatureImplemented(FEAT_IESB) then
        sync_errors = <a href="shared_pseudocode.html#accessor_SCTLR_EL_1" title="">SCTLR_EL</a>(target_el).IESB == '1';
        if IsFeatureImplemented(FEAT_DoubleFault) then
            sync_errors = sync_errors || (SCR_EL3().[EA,NMEA] == '11' &amp;&amp; target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;
        if sync_errors &amp;&amp; <a href="shared_pseudocode.html#func_InsertIESBBeforeException_1" title="">InsertIESBBeforeException</a>(target_el) then
            SynchronizeErrors();
            if except.exceptype != <a href="shared_pseudocode.html#enum_Exception_SError" title="">Exception_SError</a> then
                iesb_req = FALSE;
                sync_errors = FALSE;
                TakeUnmaskedPhysicalSErrorInterrupts(iesb_req);
            end;
        end;
    else
        sync_errors = FALSE;
    end;

    var brbe_source_allowed : boolean = FALSE;
    var brbe_source_address : bits(64) = Zeros{};
    if IsFeatureImplemented(FEAT_BRBE) then
        brbe_source_allowed = <a href="shared_pseudocode.html#func_BranchRecordAllowed_1" title="">BranchRecordAllowed</a>(PSTATE.EL);
        brbe_source_address = preferred_exception_return;
    end;

    if !IsFeatureImplemented(FEAT_ExS) || <a href="shared_pseudocode.html#accessor_SCTLR_EL_1" title="">SCTLR_EL</a>(target_el).EIS == '1' then
        // Synchronize the context, including Instruction Fetch Barrier effect
        SynchronizeContext();
    elsif !(except.exceptype == <a href="shared_pseudocode.html#enum_Exception_SoftwareBreakpoint" title="">Exception_SoftwareBreakpoint</a> ||
             (except.exceptype IN {<a href="shared_pseudocode.html#enum_Exception_SupervisorCall" title="">Exception_SupervisorCall</a>,
                                   <a href="shared_pseudocode.html#enum_Exception_HypervisorCall" title="">Exception_HypervisorCall</a>,
                                   <a href="shared_pseudocode.html#enum_Exception_MonitorCall" title="">Exception_MonitorCall</a>} &amp;&amp;
              !except.trappedsyscallinst)) then
        InstructionFetchBarrier();
    end;

    // If coming from AArch32 state, the top parts of the X[] registers might be set to zero
    let from_32 : boolean = <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
    if from_32 then AArch64_MaybeZeroRegisterUppers(); end;
    if from_32 &amp;&amp; IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.SM == '1' then
        ResetSVEState();
    else
        MaybeZeroSVEUppers(target_el);
    end;

    var vect_offset : integer = vect_offset_in;
    if UInt(target_el) &gt; UInt(PSTATE.EL) then
        var lower_32 : boolean;
        if target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
            if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
                lower_32 = <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
            else
                lower_32 = <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
            end;
        elsif <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
            lower_32 = <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>);
        else
            lower_32 = <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(target_el - 1);
        end;
        vect_offset = vect_offset + (if lower_32 then 0x600 else 0x400);

    elsif PSTATE.SP == '1' then
        vect_offset = vect_offset + 0x200;
    end;

    var spsr : bits(64) = GetPSRFromPSTATE{}(<a href="shared_pseudocode.html#enum_AArch64_NonDebugState" title="">AArch64_NonDebugState</a>);

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#func_EffectiveHCR_EL2_NVx_0" title="">EffectiveHCR_EL2_NVx</a>() IN {'x01', '111'} then
            spsr[3:2] = '10';
        end;
    end;

    if IsFeatureImplemented(FEAT_BTI) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        var zero_btype : boolean;
        // SPSR_ELx[].BTYPE is only guaranteed valid for these exception types
        if except.exceptype IN {<a href="shared_pseudocode.html#enum_Exception_SError" title="">Exception_SError</a>, <a href="shared_pseudocode.html#enum_Exception_IRQ" title="">Exception_IRQ</a>, <a href="shared_pseudocode.html#enum_Exception_FIQ" title="">Exception_FIQ</a>,
                                <a href="shared_pseudocode.html#enum_Exception_SoftwareStep" title="">Exception_SoftwareStep</a>, <a href="shared_pseudocode.html#enum_Exception_PCAlignment" title="">Exception_PCAlignment</a>,
                                <a href="shared_pseudocode.html#enum_Exception_InstructionAbort" title="">Exception_InstructionAbort</a>, <a href="shared_pseudocode.html#enum_Exception_Breakpoint" title="">Exception_Breakpoint</a>,
                                <a href="shared_pseudocode.html#enum_Exception_VectorCatch" title="">Exception_VectorCatch</a>, <a href="shared_pseudocode.html#enum_Exception_SoftwareBreakpoint" title="">Exception_SoftwareBreakpoint</a>,
                                <a href="shared_pseudocode.html#enum_Exception_IllegalState" title="">Exception_IllegalState</a>, <a href="shared_pseudocode.html#enum_Exception_BranchTarget" title="">Exception_BranchTarget</a>} then
            zero_btype = FALSE;
        else
            zero_btype = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_ZEROBTYPE" title="">Unpredictable_ZEROBTYPE</a>);
        end;
        if zero_btype then spsr[11:10] = '00'; end;
    end;

    if (IsFeatureImplemented(FEAT_NV2) &amp;&amp;
          except.exceptype == <a href="shared_pseudocode.html#enum_Exception_NV2DataAbort" title="">Exception_NV2DataAbort</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        // External aborts are configured to be taken to EL3
        except.exceptype = <a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a>;
    end;
    if ! except.exceptype IN {<a href="shared_pseudocode.html#enum_Exception_IRQ" title="">Exception_IRQ</a>, <a href="shared_pseudocode.html#enum_Exception_FIQ" title="">Exception_FIQ</a>} then
        AArch64_ReportException(except, target_el);
    end;

    if IsFeatureImplemented(FEAT_BRBE) then
        let brbe_target_address : bits(64) = <a href="shared_pseudocode.html#accessor_VBAR_EL_1" title="">VBAR_EL</a>(target_el)[63:11]::vect_offset[10:0];
        BRBEException(except, brbe_source_allowed, brbe_source_address,
                      brbe_target_address, target_el,
                      except.trappedsyscallinst);
    end;

    if IsFeatureImplemented(FEAT_GCS) then
        if PSTATE.EL == target_el then
            if <a href="shared_pseudocode.html#func_GetCurrentEXLOCKEN_0" title="">GetCurrentEXLOCKEN</a>() then
                PSTATE.EXLOCK = '1';
            else
                PSTATE.EXLOCK = '0';
            end;
        else
            PSTATE.EXLOCK = '0';
        end;
    end;

    PSTATE.EL = target_el;
    PSTATE.nRW = '0';
    PSTATE.SP = '1';

    <a href="shared_pseudocode.html#accessor_SPSR_ELx_0" title="">SPSR_ELx</a>() = spsr;
    <a href="shared_pseudocode.html#accessor_ELR_ELx_0" title="">ELR_ELx</a>() = preferred_exception_return;
    PSTATE.SS = '0';
    if IsFeatureImplemented(FEAT_SSBS) then PSTATE.SSBS = <a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().DSSBS; end;
    if IsFeatureImplemented(FEAT_EBEP) then PSTATE.PM = '1'; end;
    if IsFeatureImplemented(FEAT_SEBEP) then
        PSTATE.PPEND = '0';
        <a href="shared_pseudocode.html#global_ShouldSetPPEND" title="">ShouldSetPPEND</a> = FALSE;
    end;
    if IsFeatureImplemented(FEAT_NMI) then
        PSTATE.ALLINT = NOT <a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().SPINTMASK;
    end;
    PSTATE.[D,A,I,F] = '1111';
    if IsFeatureImplemented(FEAT_MTE) then PSTATE.TCO = '1'; end;
    PSTATE.IL = '0';
    if IsFeatureImplemented(FEAT_UAO) then PSTATE.UAO = '0'; end;
    if IsFeatureImplemented(FEAT_UINJ) then PSTATE.UINJ = '0'; end;
    if IsFeatureImplemented(FEAT_PAuth_LR) then PSTATE.PACM = '0'; end;
    if (IsFeatureImplemented(FEAT_PAN) &amp;&amp; (PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> ||
          (PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>))) &amp;&amp;
          <a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().SPAN == '0') then
        PSTATE.PAN = '1';
    end;
    if from_32 then                             // Coming from AArch32
        PSTATE.IT = '00000000';
        PSTATE.T = '0';                         // PSTATE.J is RES0
    end;
    if IsFeatureImplemented(FEAT_BTI) then PSTATE.BTYPE = '00'; end;
    let branch_conditional : boolean = FALSE;
    BranchTo{64}(<a href="shared_pseudocode.html#accessor_VBAR_ELx_0" title="">VBAR_ELx</a>()[63:11]::vect_offset[10:0], <a href="shared_pseudocode.html#enum_BranchType_EXCEPTION" title="">BranchType_EXCEPTION</a>, branch_conditional);
    CheckExceptionCatch(TRUE);                  // Check for debug event on exception entry

    if sync_errors then
        SynchronizeErrors();
        iesb_req = TRUE;
        TakeUnmaskedPhysicalSErrorInterrupts(iesb_req);
    end;

    EndOfInstruction();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_AArch32SystemAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_AArch32SystemAccessTrap</h3>
      <p class="pseudocode">// AArch64_AArch32SystemAccessTrap()
// =================================
// Trapped AArch32 System register access.

func AArch64_AArch32SystemAccessTrap(target_el : bits(2), ec : integer)
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(target_el) &amp;&amp; target_el != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; UInt(target_el) &gt;= UInt(PSTATE.EL);

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_AArch64_AArch32SystemAccessTrapSyndrome_2" title="">AArch64_AArch32SystemAccessTrapSyndrome</a>(<a href="shared_pseudocode.html#func_ThisInstr_0" title="">ThisInstr</a>(), ec);
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_AArch32SystemAccessTrapSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_AArch32SystemAccessTrapSyndrome</h3>
      <p class="pseudocode">// AArch64_AArch32SystemAccessTrapSyndrome()
// =========================================
// Returns the syndrome information for traps on AArch32 MCR, MCRR, MRC, MRRC, and VMRS,
// VMSR instructions, other than traps that are due to HCPTR or CPACR.

func <a id="func_AArch64_AArch32SystemAccessTrapSyndrome_2"/>AArch64_AArch32SystemAccessTrapSyndrome(instr : bits(32), ec : integer) =&gt; <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>
begin
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>;

    case ec of
        when 0x0 =&gt;    except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_Uncategorized" title="">Exception_Uncategorized</a>);
        when 0x3 =&gt;    except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_CP15RTTrap" title="">Exception_CP15RTTrap</a>);
        when 0x4 =&gt;    except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_CP15RRTTrap" title="">Exception_CP15RRTTrap</a>);
        when 0x5 =&gt;    except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_CP14RTTrap" title="">Exception_CP14RTTrap</a>);
        when 0x6 =&gt;    except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_CP14DTTrap" title="">Exception_CP14DTTrap</a>);
        when 0x7 =&gt;    except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_AdvSIMDFPAccessTrap" title="">Exception_AdvSIMDFPAccessTrap</a>);
        when 0x8 =&gt;    except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_FPIDTrap" title="">Exception_FPIDTrap</a>);
        when 0xC =&gt;    except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_CP14RRTTrap" title="">Exception_CP14RRTTrap</a>);
        otherwise =&gt;   unreachable;
    end;

    var iss : bits(20) = Zeros{};

    if except.exceptype == <a href="shared_pseudocode.html#enum_Exception_Uncategorized" title="">Exception_Uncategorized</a> then
        return except;
    elsif except.exceptype IN {<a href="shared_pseudocode.html#enum_Exception_FPIDTrap" title="">Exception_FPIDTrap</a>, <a href="shared_pseudocode.html#enum_Exception_CP14RTTrap" title="">Exception_CP14RTTrap</a>,
                               <a href="shared_pseudocode.html#enum_Exception_CP15RTTrap" title="">Exception_CP15RTTrap</a>} then
        // Trapped MRC/MCR, VMRS on FPSID
        if except.exceptype != <a href="shared_pseudocode.html#enum_Exception_FPIDTrap" title="">Exception_FPIDTrap</a> then    // When trap is not for VMRS
            iss[19:17] = instr[7:5];           // opc2
            iss[16:14] = instr[23:21];         // opc1
            iss[13:10] = instr[19:16];         // CRn
            iss[4:1]   = instr[3:0];           // CRm
        else
            iss[19:17] = '000';
            iss[16:14] = '111';
            iss[13:10] = instr[19:16];         // reg
            iss[4:1]   = '0000';
        end;

        if instr[20] == '1' &amp;&amp; instr[15:12] == '1111' then    // MRC, Rt==15
            iss[9:5] = '11111';
        elsif instr[20] == '0' &amp;&amp; instr[15:12] == '1111' then // MCR, Rt==15
            iss[9:5] = ARBITRARY : bits(5);
        else
            iss[9:5] = <a href="shared_pseudocode.html#func_LookUpRIndex_2" title="">LookUpRIndex</a>(UInt(instr[15:12]), PSTATE.M)[4:0];
        end;
    elsif except.exceptype IN {<a href="shared_pseudocode.html#enum_Exception_CP14RRTTrap" title="">Exception_CP14RRTTrap</a>, <a href="shared_pseudocode.html#enum_Exception_AdvSIMDFPAccessTrap" title="">Exception_AdvSIMDFPAccessTrap</a>,
                               <a href="shared_pseudocode.html#enum_Exception_CP15RRTTrap" title="">Exception_CP15RRTTrap</a>} then
        // Trapped MRRC/MCRR, VMRS/VMSR
        iss[19:16] = instr[7:4];          // opc1
        if instr[19:16] == '1111' then    // Rt2==15
            iss[14:10] = ARBITRARY : bits(5);
        else
            iss[14:10] = <a href="shared_pseudocode.html#func_LookUpRIndex_2" title="">LookUpRIndex</a>(UInt(instr[19:16]), PSTATE.M)[4:0];
        end;

        if instr[15:12] == '1111' then    // Rt==15
            iss[9:5] = ARBITRARY : bits(5);
        else
            iss[9:5] = <a href="shared_pseudocode.html#func_LookUpRIndex_2" title="">LookUpRIndex</a>(UInt(instr[15:12]), PSTATE.M)[4:0];
        end;
        iss[4:1]   = instr[3:0];         // CRm
    elsif except.exceptype == <a href="shared_pseudocode.html#enum_Exception_CP14DTTrap" title="">Exception_CP14DTTrap</a> then
        // Trapped LDC/STC
        iss[19:12] = instr[7:0];         // imm8
        iss[4]     = instr[23];          // U
        iss[2:1]   = instr[24,21];       // P,W
        if instr[19:16] == '1111' then   // Rn==15, LDC(Literal addressing)/STC
            iss[9:5] = ARBITRARY : bits(5);
            iss[3]   = '1';
        end;
    end;
    iss[0] = instr[20];                  // Direction

    except.syndrome.iss[24:20] = <a href="shared_pseudocode.html#func_ConditionSyndrome_0" title="">ConditionSyndrome</a>();
    except.syndrome.iss[19:0]  = iss;

    return except;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_AdvSIMDFPAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_AdvSIMDFPAccessTrap</h3>
      <p class="pseudocode">// AArch64_AdvSIMDFPAccessTrap()
// =============================
// Trapped access to Advanced SIMD or FP registers due to CPACR.

func AArch64_AdvSIMDFPAccessTrap(target_el : bits(2))
begin
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>;
    let vect_offset : integer = 0x0;

    let route_to_el2 : boolean = (target_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1');

    if route_to_el2 then
        except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_Uncategorized" title="">Exception_Uncategorized</a>);
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    else
        except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_AdvSIMDFPAccessTrap" title="">Exception_AdvSIMDFPAccessTrap</a>);
        except.syndrome.iss[24:20] = <a href="shared_pseudocode.html#func_ConditionSyndrome_0" title="">ConditionSyndrome</a>();
        AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_CheckCP15InstrCoarseTraps"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_CheckCP15InstrCoarseTraps</h3>
      <p class="pseudocode">// AArch64_CheckCP15InstrCoarseTraps()
// ===================================
// Check for coarse-grained AArch32 traps to System registers in the
// coproc=0b1111 encoding space by HSTR_EL2, HCR_EL2, and SCTLR_ELx.

func AArch64_CheckCP15InstrCoarseTraps(CRn : integer, nreg : integer, CRm : integer)
begin
    let trapped_encoding : boolean = ((CRn == 9  &amp;&amp; CRm IN {0,1,2,    5,6,7,8   }) ||
                                      (CRn == 10 &amp;&amp; CRm IN {0,1,    4,      8   }) ||
                                      (CRn == 11 &amp;&amp; CRm IN {0,1,2,3,4,5,6,7,8,15}));

    // Check for MRC and MCR disabled by SCTLR_EL1.TIDCP.
    if (IsFeatureImplemented(FEAT_TIDCP1) &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() &amp;&amp;
           !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) &amp;&amp; SCTLR_EL1().TIDCP == '1' &amp;&amp; trapped_encoding) then
        if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then
            AArch64_AArch32SystemAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, 0x3);
        else
            AArch64_AArch32SystemAccessTrap(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, 0x3);
        end;
    end;

    // Check for coarse-grained Hyp traps
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        // Check for MRC and MCR disabled by SCTLR_EL2.TIDCP.
        if (IsFeatureImplemented(FEAT_TIDCP1) &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() &amp;&amp;
              SCTLR_EL2().TIDCP == '1' &amp;&amp; trapped_encoding) then
            AArch64_AArch32SystemAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, 0x3);
        end;

        let major : integer = if nreg == 1 then CRn else CRm;
        // Check for MCR, MRC, MCRR, and MRRC disabled by HSTR_EL2().CRn/HSTR().CRm
        // and MRC and MCR disabled by HCR_EL2.TIDCP.
        if ((!<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() &amp;&amp; ! major IN {4,14} &amp;&amp; HSTR_EL2()[major] == '1') ||
                (HCR_EL2().TIDCP == '1' &amp;&amp; nreg == 1 &amp;&amp; trapped_encoding)) then
            if (PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp;
                    ImpDefBool("UNDEF unallocated CP15 access at EL0")) then
                Undefined();
            end;
            AArch64_AArch32SystemAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, 0x3);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_CheckFPAdvSIMDEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_CheckFPAdvSIMDEnabled</h3>
      <p class="pseudocode">// AArch64_CheckFPAdvSIMDEnabled()
// ===============================

func AArch64_CheckFPAdvSIMDEnabled()
begin
    AArch64_CheckFPEnabled();
    // Check for illegal use of Advanced
    // SIMD in Streaming SVE Mode
    if IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.SM == '1' &amp;&amp; !<a href="shared_pseudocode.html#func_IsFullA64Enabled_0" title="">IsFullA64Enabled</a>() then
        SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_Streaming" title="">SMEExceptionType_Streaming</a>, PSTATE.EL);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_CheckFPAdvSIMDTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_CheckFPAdvSIMDTrap</h3>
      <p class="pseudocode">// AArch64_CheckFPAdvSIMDTrap()
// ============================
// Check against CPTR_EL2 and CPTR_EL3.

func AArch64_CheckFPAdvSIMDTrap()
begin
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; CPTR_EL3().TFP == '1' &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndefPriority_0" title="">EL3SDDUndefPriority</a>() then
        Undefined();
    end;

    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        // Check if access disabled in CPTR_EL2
        if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            var disabled : boolean;
            case CPTR_EL2().FPEN of
                when 'x0' =&gt; disabled = TRUE;
                when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; HCR_EL2().TGE == '1';
                when '11' =&gt; disabled = FALSE;
            end;
            if disabled then AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>); end;
        else
            if CPTR_EL2().TFP == '1' then AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>); end;
        end;
    end;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        // Check if access disabled in CPTR_EL3
        if CPTR_EL3().TFP == '1' then
            if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then
                Undefined();
            else
                AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
            end;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_CheckFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_CheckFPEnabled</h3>
      <p class="pseudocode">// AArch64_CheckFPEnabled()
// ========================
// Check against CPACR

func AArch64_CheckFPEnabled()
begin
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        // Check if access disabled in CPACR_EL1
        var disabled : boolean;
        case CPACR_EL1().FPEN of
            when 'x0' =&gt; disabled = TRUE;
            when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
            when '11' =&gt; disabled = FALSE;
        end;
        if disabled then AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>); end;
    end;

    AArch64_CheckFPAdvSIMDTrap();               // Also check against CPTR_EL2 and CPTR_EL3
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_CheckForERetTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_CheckForERetTrap</h3>
      <p class="pseudocode">// AArch64_CheckForERetTrap()
// ==========================
// Check for trap on ERET, ERETAA, ERETAB instruction

func AArch64_CheckForERetTrap(eret_with_pac : boolean, pac_uses_key_a : boolean)
begin
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        var route_to_el2 : boolean = FALSE;

        // Check for a fine-grained trap by the hypervisor.
        if (IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || SCR_EL3().FGTEn == '1') &amp;&amp;
              HFGITR_EL2().ERET == '1') then
            route_to_el2 = TRUE;
        // Check for a trap by the Effective value of the HCR_EL2.NV bit
        elsif <a href="shared_pseudocode.html#func_EffectiveHCR_EL2_NVx_0" title="">EffectiveHCR_EL2_NVx</a>()[0] == '1' then
            // Check for a trap by NVHCR_EL2.TGE based on the SPSR_EL1().M[3:2] value
            if <a href="shared_pseudocode.html#func_EffectiveHCRX_EL2_NVTGE_0" title="">EffectiveHCRX_EL2_NVTGE</a>() == '1' then
                route_to_el2 = NVHCR_EL2().TGE == '0' &amp;&amp; SPSR_EL1().M[3:2] == '0x';
            else
                route_to_el2 = TRUE;
            end;
        end;

        if route_to_el2 then
            let preferred_exception_return : bits(64) = ThisInstrAddr{}();
            let vect_offset : integer = 0x0;
            var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_ERetTrap" title="">Exception_ERetTrap</a>);

            if !eret_with_pac then                             // ERET
                except.syndrome.iss[1] = '0';
                except.syndrome.iss[0] = '0';                  // RES0
            else
                except.syndrome.iss[1] = '1';
                except.syndrome.iss[0] = if pac_uses_key_a then '0' else '1';
            end;

            AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
        end;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_CheckForSMCUndefOrTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_CheckForSMCUndefOrTrap</h3>
      <p class="pseudocode">// AArch64_CheckForSMCUndefOrTrap()
// ================================
// Check for UNDEFINED or trap on SMC instruction

func AArch64_CheckForSMCUndefOrTrap(imm : bits(16))
begin
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then Undefined(); end;
    if (!(PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TSC == '1') &amp;&amp;
        <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SMD == '1') then
        Undefined();
    end;
    var route_to_el2 : boolean = FALSE;
    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if (PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TSC == '1' &amp;&amp;
              (<a href="shared_pseudocode.html#func_EffectiveHCR_EL2_NVx_0" title="">EffectiveHCR_EL2_NVx</a>() == 'xx1' ||
              (ImpDefBool("Trap SMC execution at EL1 to EL2")))) then
            route_to_el2 = TRUE;
        else
            Undefined();
        end;
    else
        route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TSC == '1';
    end;
    if route_to_el2 then
        let preferred_exception_return : bits(64) = ThisInstrAddr{}();
        let vect_offset : integer = 0x0;
        var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_MonitorCall" title="">Exception_MonitorCall</a>);
        except.syndrome.iss[15:0] = imm;
        except.trappedsyscallinst = TRUE;
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_CheckForSVCTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_CheckForSVCTrap</h3>
      <p class="pseudocode">// AArch64_CheckForSVCTrap()
// =========================
// Check for trap on SVC instruction

func AArch64_CheckForSVCTrap(immediate : bits(16))
begin
    if IsFeatureImplemented(FEAT_FGT) then
        var route_to_el2 : boolean = FALSE;
        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
            route_to_el2 = (!<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) &amp;&amp;
                           <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HFGITR_EL2().SVC_EL0 == '1' &amp;&amp;
                           (!<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() &amp;&amp; (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || SCR_EL3().FGTEn == '1')));

        elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> then
            route_to_el2 = (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HFGITR_EL2().SVC_EL1 == '1' &amp;&amp;
                           (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || SCR_EL3().FGTEn == '1'));
        end;

        if route_to_el2 then
            var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SupervisorCall" title="">Exception_SupervisorCall</a>);
            except.syndrome.iss[15:0] = immediate;
            except.trappedsyscallinst = TRUE;
            let preferred_exception_return : bits(64) = ThisInstrAddr{}();
            let vect_offset : integer = 0x0;

            AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_CheckForWFxTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_CheckForWFxTrap</h3>
      <p class="pseudocode">// AArch64_CheckForWFxTrap()
// =========================
// Checks for a trap on a WFE, WFET, WFI or WFIT instruction.

func AArch64_CheckForWFxTrap(wfxtype : <a href="shared_pseudocode.html#WFxType" title="type WFxType">WFxType</a>) =&gt; (boolean, bits(2))
begin
    let is_wfe : boolean = wfxtype IN {WFxType_WFE, WFxType_WFET};
    var target_el : bits(2);
    var trap : boolean = FALSE;

    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; PSTATE.EL != EL3 then
        // Check for traps described by the Secure Monitor.
        // If the trap is enabled, the instruction will be UNDEFINED because EDSCR.SDD is 1.
        trap      = (if is_wfe then SCR_EL3().TWE else SCR_EL3().TWI) == '1';
        target_el = EL3;
    end;

    if !trap &amp;&amp; PSTATE.EL == EL0 then
        // Check for traps described by the OS which may be EL1 or EL2.
        trap      = (if is_wfe then SCTLR_ELx().nTWE else SCTLR_ELx().nTWI) == '0';
        target_el = EL1;
    end;

    if !trap &amp;&amp; PSTATE.EL IN {EL0, EL1} &amp;&amp; EL2Enabled() &amp;&amp; !IsInHost() then
        // Check for traps described by the Hypervisor.
        trap      = (if is_wfe then HCR_EL2().TWE else HCR_EL2().TWI) == '1';
        target_el = EL2;
    end;

    if !trap &amp;&amp; HaveEL(EL3) &amp;&amp; PSTATE.EL != EL3 then
        // Check for traps described by the Secure Monitor.
        trap      = (if is_wfe then SCR_EL3().TWE else SCR_EL3().TWI) == '1';
        target_el = EL3;
    end;
    return (trap, target_el);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_CheckIllegalState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_CheckIllegalState</h3>
      <p class="pseudocode">// AArch64_CheckIllegalState()
// ===========================
// Check PSTATE.IL bit and generate Illegal Execution state exception if set.

func AArch64_CheckIllegalState()
begin
    if PSTATE.IL == '1' then
        let route_to_el2 : boolean = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1';

        let preferred_exception_return : bits(64) = ThisInstrAddr{}();
        let vect_offset : integer = 0x0;

        let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_IllegalState" title="">Exception_IllegalState</a>);

        if UInt(PSTATE.EL) &gt; UInt(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
            AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset);
        elsif route_to_el2 then
            AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
        else
            AArch64_TakeException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, except, preferred_exception_return, vect_offset);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_MonitorModeTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_MonitorModeTrap</h3>
      <p class="pseudocode">// AArch64_MonitorModeTrap()
// =========================
// Trapped use of Monitor mode features in a Secure EL1 AArch32 mode

func AArch64_MonitorModeTrap()
begin
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer                 = 0x0;

    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>              = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_Uncategorized" title="">Exception_Uncategorized</a>);

    if <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>() then
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    end;
    AArch64_TakeException(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_SystemAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_SystemAccessTrap</h3>
      <p class="pseudocode">// AArch64_SystemAccessTrap()
// ==========================
// Trapped access to AArch64 System register or system instruction.

func AArch64_SystemAccessTrap(target_el : bits(2), ec : integer)
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(target_el) &amp;&amp; target_el != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; UInt(target_el) &gt;= UInt(PSTATE.EL);

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_AArch64_SystemAccessTrapSyndrome_2" title="">AArch64_SystemAccessTrapSyndrome</a>(<a href="shared_pseudocode.html#func_ThisInstr_0" title="">ThisInstr</a>(), ec);
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_SystemAccessTrapSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_SystemAccessTrapSyndrome</h3>
      <p class="pseudocode">// AArch64_SystemAccessTrapSyndrome()
// ==================================
// Returns the syndrome information for traps on AArch64 MSR/MRS instructions.

func <a id="func_AArch64_SystemAccessTrapSyndrome_2"/>AArch64_SystemAccessTrapSyndrome(instr_in : bits(32), ec : integer) =&gt; <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>
begin
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>;
    var instr : bits(32) = instr_in;
    case ec of
        when 0x0 =&gt;                      // Trapped access due to unknown reason.
            except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_Uncategorized" title="">Exception_Uncategorized</a>);
        when 0x7 =&gt;                      // Trapped access to SVE, Advance SIMD&amp;FP System register.
            except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_AdvSIMDFPAccessTrap" title="">Exception_AdvSIMDFPAccessTrap</a>);
            except.syndrome.iss[24:20] = <a href="shared_pseudocode.html#func_ConditionSyndrome_0" title="">ConditionSyndrome</a>();
        when 0x14 =&gt;                     // Trapped access to 128-bit System register or
                                         // 128-bit System instruction.
            except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SystemRegister128Trap" title="">Exception_SystemRegister128Trap</a>);
            instr = <a href="shared_pseudocode.html#func_ThisInstr_0" title="">ThisInstr</a>();
            except.syndrome.iss[21:20] = instr[20:19]; // Op0
            except.syndrome.iss[19:17] = instr[7:5];   // Op2
            except.syndrome.iss[16:14] = instr[18:16]; // Op1
            except.syndrome.iss[13:10] = instr[15:12]; // CRn
            except.syndrome.iss[9:6]   = instr[4:1];   // Rt
            except.syndrome.iss[4:1]   = instr[11:8];  // CRm
            except.syndrome.iss[0]     = instr[21];    // Direction
        when 0x18 =&gt;                     // Trapped access to System register or system instruction.
            except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SystemRegisterTrap" title="">Exception_SystemRegisterTrap</a>);
            instr = <a href="shared_pseudocode.html#func_ThisInstr_0" title="">ThisInstr</a>();
            except.syndrome.iss[21:20] = instr[20:19]; // Op0
            except.syndrome.iss[19:17] = instr[7:5];   // Op2
            except.syndrome.iss[16:14] = instr[18:16]; // Op1
            except.syndrome.iss[13:10] = instr[15:12]; // CRn
            except.syndrome.iss[9:5]   = instr[4:0];   // Rt
            except.syndrome.iss[4:1]   = instr[11:8];  // CRm
            except.syndrome.iss[0]     = instr[21];    // Direction
        when 0x19 =&gt;                        // Trapped access to SVE System register
            except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SVEAccessTrap" title="">Exception_SVEAccessTrap</a>);
        when 0x1D =&gt;                        // Trapped access to SME System register
            except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SMEAccessTrap" title="">Exception_SMEAccessTrap</a>);
        otherwise =&gt;
            unreachable;
    end;

    return except;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_Undefined"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_Undefined</h3>
      <p class="pseudocode">// AArch64_Undefined()
// ===================

noreturn func AArch64_Undefined()
begin

    let route_to_el2 : boolean = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1';
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_Uncategorized" title="">Exception_Uncategorized</a>);

    if UInt(PSTATE.EL) &gt; UInt(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    else
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64_WFxTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64_WFxTrap</h3>
      <p class="pseudocode">// AArch64_WFxTrap()
// =================
// Generate an exception for a trapped WFE, WFI, WFET or WFIT instruction.

func AArch64_WFxTrap(wfxtype : <a href="shared_pseudocode.html#WFxType" title="type WFxType">WFxType</a>, target_el : bits(2))
begin
    assert UInt(target_el) &gt; UInt(PSTATE.EL);
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;
    var except : ExceptionRecord = ExceptionSyndrome(Exception_WFxTrap);
    except.syndrome.iss[24:20] = ConditionSyndrome();
    case wfxtype of
        when WFxType_WFI =&gt;
            except.syndrome.iss[1:0] = '00';
        when WFxType_WFE =&gt;
            except.syndrome.iss[1:0] = '01';
        when WFxType_WFIT =&gt;
            except.syndrome.iss[1:0] = '10';
            except.syndrome.iss[2]   = '1';   // Register field is valid
            except.syndrome.iss[9:5] = ThisInstr()[4:0];
        when WFxType_WFET =&gt;
            except.syndrome.iss[1:0] = '11';
            except.syndrome.iss[2]   = '1';   // Register field is valid
            except.syndrome.iss[9:5] = ThisInstr()[4:0];
    end;

    if target_el == EL1 &amp;&amp; EL2Enabled() &amp;&amp; HCR_EL2().TGE == '1' then
        AArch64_TakeException(EL2, except, preferred_exception_return, vect_offset);
    else
        AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckLDST64BEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckLDST64BEnabled</h3>
      <p class="pseudocode">// CheckLDST64BEnabled()
// =====================
// Checks for trap on ST64B and LD64B instructions

func CheckLDST64BEnabled()
begin
    var trap : boolean = FALSE;
    let iss : bits(25) = ZeroExtend{}('10');  // 0x2
    var target_el : bits(2);

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        if !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
            trap = SCTLR_EL1().EnALS == '0';
            target_el = if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
        else
            trap = SCTLR_EL2().EnALS == '0';
            target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
        end;
    else
        target_el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    end;

    if (!trap &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
        ((PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>()) || PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>)) then
        trap = !<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().EnALS == '0';
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    end;

    if trap then LDST64BTrap(target_el, iss); end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckST64BV0Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckST64BV0Enabled</h3>
      <p class="pseudocode">// CheckST64BV0Enabled()
// =====================
// Checks for trap on ST64BV0 instruction

func CheckST64BV0Enabled()
begin
    var trap : boolean = FALSE;
    let iss : bits(25) = ZeroExtend{}('1');  // 0x1
    var target_el : bits(2);

    if (PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp;
        SCR_EL3().EnAS0 == '0' &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndefPriority_0" title="">EL3SDDUndefPriority</a>()) then
        Undefined();
    end;

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        if !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
            trap = SCTLR_EL1().EnAS0 == '0';
            target_el = if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
        else
            trap = SCTLR_EL2().EnAS0 == '0';
            target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
        end;
    end;

    if (!trap &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
        ((PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>()) || PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>)) then
        trap = !<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().EnAS0 == '0';
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    end;

    if !trap &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
        trap = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().EnAS0 == '0';
        target_el = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
    end;

    if trap then
        if target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then
            Undefined();
        else
            LDST64BTrap(target_el, iss);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckST64BVEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckST64BVEnabled</h3>
      <p class="pseudocode">// CheckST64BVEnabled()
// ====================
// Checks for trap on ST64BV instruction

func CheckST64BVEnabled()
begin
    var trap : boolean = FALSE;
    let iss : bits(25) = Zeros{};
    var target_el : bits(2);

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        if !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
            trap = SCTLR_EL1().EnASR == '0';
            target_el = if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
        else
            trap = SCTLR_EL2().EnASR == '0';
            target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
        end;
    end;

    if (!trap &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
        ((PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>()) || PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>)) then
        trap = !<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().EnASR == '0';
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    end;

    if trap then LDST64BTrap(target_el, iss); end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.LDST64BTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/LDST64BTrap</h3>
      <p class="pseudocode">// LDST64BTrap()
// =============
// Trapped access to LD64B, ST64B, ST64BV and ST64BV0 instructions

func LDST64BTrap(target_el : bits(2), iss : bits(25))
begin
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_LDST64BTrap" title="">Exception_LDST64BTrap</a>);
    except.syndrome.iss = iss;
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.WFETrapDelay"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/WFETrapDelay</h3>
      <p class="pseudocode">// WFETrapDelay()
// ==============
// Returns TRUE when delay in trap to WFE is enabled with value to amount of delay,
// FALSE otherwise.

func <a id="func_WFETrapDelay_1"/>WFETrapDelay(target_el : bits(2)) =&gt; (boolean, integer)
begin
    var delay_enabled : boolean;
    var delay : integer;
    case target_el of
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            if !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
                delay_enabled = SCTLR_EL1().TWEDEn == '1';
                delay         = 1 &lt;&lt; (UInt(SCTLR_EL1().TWEDEL) + 8);
            else
                delay_enabled = SCTLR_EL2().TWEDEn == '1';
                delay         = 1 &lt;&lt; (UInt(SCTLR_EL2().TWEDEL) + 8);
            end;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            assert <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
            delay_enabled = HCR_EL2().TWEDEn == '1';
            delay         = 1 &lt;&lt; (UInt(HCR_EL2().TWEDEL) + 8);
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            delay_enabled = SCR_EL3().TWEDEn == '1';
            delay         = 1 &lt;&lt; (UInt(SCR_EL3().TWEDEL) + 8);
    end;
    return (delay_enabled, delay);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.WaitForEventUntilDelay"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/WaitForEventUntilDelay</h3>
      <p class="pseudocode">// WaitForEventUntilDelay()
// ========================
// Returns TRUE if WaitForEvent() returns before WFE trap delay expires,
// FALSE otherwise.

impdef func <a id="func_WaitForEventUntilDelay_2"/>WaitForEventUntilDelay(delay_enabled : boolean, delay : integer) =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.aborts.AArch64_FaultSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/aborts/AArch64_FaultSyndrome</h3>
      <p class="pseudocode">// AArch64_FaultSyndrome()
// =======================
// Creates an exception syndrome value and updates the virtual address for Abort and Watchpoint
// exceptions taken to an Exception level using AArch64.

func <a id="func_AArch64_FaultSyndrome_3"/>AArch64_FaultSyndrome(exceptype : <a href="shared_pseudocode.html#type_Exception" title="">Exception</a>, fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>,
                           target_el : bits(2)) =&gt; <a href="shared_pseudocode.html#type_IssType" title="">IssType</a>
begin
    assert fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;

    var isstype : <a href="shared_pseudocode.html#type_IssType" title="">IssType</a>;
    isstype.iss  = Zeros{25};
    isstype.iss2 = Zeros{24};

    let d_side : boolean = exceptype IN {<a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a>, <a href="shared_pseudocode.html#enum_Exception_NV2DataAbort" title="">Exception_NV2DataAbort</a>,
                                         <a href="shared_pseudocode.html#enum_Exception_Watchpoint" title="">Exception_Watchpoint</a>, <a href="shared_pseudocode.html#enum_Exception_NV2Watchpoint" title="">Exception_NV2Watchpoint</a>};
    if IsFeatureImplemented(FEAT_RAS) &amp;&amp; fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_SyncExternal" title="">Fault_SyncExternal</a> then
        let errstate : <a href="shared_pseudocode.html#type_ErrorState" title="">ErrorState</a> = <a href="shared_pseudocode.html#func_PEErrorState_1" title="">PEErrorState</a>(fault);
        isstype.iss[12:11] = <a href="shared_pseudocode.html#func_AArch64_EncodeSyncErrorSyndrome_1" title="">AArch64_EncodeSyncErrorSyndrome</a>(errstate);  // SET
    end;

    if d_side then
        if (IsFeatureImplemented(FEAT_EAESR) &amp;&amp; exceptype == <a href="shared_pseudocode.html#enum_Exception_DataAbort" title="">Exception_DataAbort</a> &amp;&amp;
              !fault.s2fs1walk &amp;&amp; ! fault.accessdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>,
                                                                 <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>,
                                                                 <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>,
                                                                 <a href="shared_pseudocode.html#enum_AccessType_NV2" title="">AccessType_NV2</a>}) then
            // LST2 field
            if fault.accessdesc.atomicop then
                isstype.iss2[15:13] = '001';    // Data Abort is from an Atomic instruction
            elsif (fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_DCZero" title="">AccessType_DCZero</a> &amp;&amp;
                     fault.accessdesc.cachetype IN {<a href="shared_pseudocode.html#enum_CacheType_Data" title="">CacheType_Data</a>, <a href="shared_pseudocode.html#enum_CacheType_Data_Tag" title="">CacheType_Data_Tag</a>}) then
                isstype.iss2[15:13] = '010';    // Data Abort is from a DC ZVA or DC GZVA
            end;

            // Unpriv field
            if (fault.accessdesc.el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp;
                  fault.accessdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_GPR" title="">AccessType_GPR</a>,
                                               <a href="shared_pseudocode.html#enum_AccessType_GCS" title="">AccessType_GCS</a>,
                                               <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a>}) then
                isstype.iss2[12] = '1';         // Data Abort is from an unprivileged load or store
            end;
        end;

        if fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_GCS" title="">AccessType_GCS</a> then
            isstype.iss2[8] = '1';
        end;
        if exceptype IN {<a href="shared_pseudocode.html#enum_Exception_Watchpoint" title="">Exception_Watchpoint</a>, <a href="shared_pseudocode.html#enum_Exception_NV2Watchpoint" title="">Exception_NV2Watchpoint</a>} then
            isstype.iss[23:0] = <a href="shared_pseudocode.html#func_WatchpointRelatedSyndrome_1" title="">WatchpointRelatedSyndrome</a>(fault);
        end;

        if <a href="shared_pseudocode.html#func_AArch64_InstructionSyndromeValid_1" title="">AArch64_InstructionSyndromeValid</a>(fault) then
            if fault.accessdesc.ls64 then
                (isstype.iss2, isstype.iss[24:14]) = <a href="shared_pseudocode.html#func_LS64InstructionSyndrome_0" title="">LS64InstructionSyndrome</a>();
            else
                isstype.iss[24:14] = <a href="shared_pseudocode.html#func_LSInstructionSyndrome_0" title="">LSInstructionSyndrome</a>();
            end;
        end;

        if IsFeatureImplemented(FEAT_NV2) &amp;&amp; fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_NV2" title="">AccessType_NV2</a> then
            isstype.iss[13] = '1';   // Fault is generated by use of VNCR_EL2
        end;

        if (IsFeatureImplemented(FEAT_LS64) &amp;&amp;
              fault.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_AccessFlag" title="">Fault_AccessFlag</a>, <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>, <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>}) then
            isstype.iss[12:11] = <a href="shared_pseudocode.html#func_GetLoadStoreType_0" title="">GetLoadStoreType</a>();
        end;

        if fault.accessdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>, <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>} then
            isstype.iss[8] = '1';
        end;

        if fault.accessdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>, <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>} then
            isstype.iss[6] = '1';
        elsif fault.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_HWUpdateAccessFlag" title="">Fault_HWUpdateAccessFlag</a>, <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a>} then
            isstype.iss[6] = ARBITRARY : bit;
        elsif fault.accessdesc.atomicop &amp;&amp; <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) then
            isstype.iss[6] = ARBITRARY : bit;
        else
            isstype.iss[6] = if fault.write then '1' else '0';
        end;
        isstype.iss2[9] = if fault.tagaccess then '1' else '0';
        if fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a> then
            isstype.iss2[5] = if fault.dirtybit then '1' else '0';
            isstype.iss2[6] = if fault.overlay then '1' else '0';
            if isstype.iss[24] == '0' then
                isstype.iss[21] = if fault.toplevel then '1' else '0';
            end;
            isstype.iss2[7] = if fault.assuredonly then '1' else '0';
            isstype.iss2[10] = if fault.s1tagnotdata then '1' else '0';
        end;

    else
        if (fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> &amp;&amp;
              fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>) then
            isstype.iss2[5] = if fault.dirtybit then '1' else '0';
            isstype.iss[21] = if fault.toplevel then '1' else '0';
            isstype.iss2[7] = if fault.assuredonly then '1' else '0';
            isstype.iss2[6] = if fault.overlay then '1' else '0';
        end;
    end;
    if fault.hdbssf then
        isstype.iss2[11] = '1';
    end;

    if (IsFeatureImplemented(FEAT_PFAR) &amp;&amp; <a href="shared_pseudocode.html#func_IsExternalSyncAbort_1" title="">IsExternalSyncAbort</a>(fault) &amp;&amp;
          !(<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; (HCR_EL2().VM == '1' || HCR_EL2().DC == '1') &amp;&amp; target_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>)) then
        isstype.iss[14] = if <a href="shared_pseudocode.html#func_IsPFARValid_1" title="">IsPFARValid</a>(fault) then '1' else '0';
    end;

    if <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) then isstype.iss[9] = fault.extflag; end;
    isstype.iss[7] = if fault.s2fs1walk then '1' else '0';
    isstype.iss[5:0] = <a href="shared_pseudocode.html#func_EncodeLDFSC_2" title="">EncodeLDFSC</a>(fault.statuscode, fault.level);

    return isstype;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.aborts.AArch64_InstructionSyndromeValid"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/aborts/AArch64_InstructionSyndromeValid</h3>
      <p class="pseudocode">// AArch64_InstructionSyndromeValid()
// ==================================
// Returns TRUE if ESR_ELx.ISV is '1' for the given Fault.

func <a id="func_AArch64_InstructionSyndromeValid_1"/>AArch64_InstructionSyndromeValid(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    if !fault.accessdesc.lowestaddress then
        return FALSE;
    end;

    if fault.accessdesc.ls64 then
        return fault.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_AccessFlag" title="">Fault_AccessFlag</a>, <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>, <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>};
    end;

    if fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_GCS" title="">AccessType_GCS</a> then
        return FALSE;
    end;

    if (IsFeatureImplemented(FEAT_EAESR) &amp;&amp; !<a href="shared_pseudocode.html#func_IsSecondStage_1" title="">IsSecondStage</a>(fault) &amp;&amp;
          fault.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_AccessFlag" title="">Fault_AccessFlag</a>, <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>, <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>}) then
        return TRUE;
    end;

    if <a href="shared_pseudocode.html#func_IsSecondStage_1" title="">IsSecondStage</a>(fault) &amp;&amp; !fault.s2fs1walk then
        return (!<a href="shared_pseudocode.html#func_IsExternalSyncAbort_1" title="">IsExternalSyncAbort</a>(fault) ||
                (!IsFeatureImplemented(FEAT_RAS) &amp;&amp; <a href="shared_pseudocode.html#func_IsExternalAbortOnWalk_1" title="">IsExternalAbortOnWalk</a>(fault) &amp;&amp;
                  ImpDefBool("ISV on second stage translation table walk")));
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.aborts.EncodeGPCSC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/aborts/EncodeGPCSC</h3>
      <p class="pseudocode">// EncodeGPCSC()
// =============
// Function that gives the GPCSC code for types of GPT Fault

func <a id="func_EncodeGPCSC_1"/>EncodeGPCSC(gpcf : <a href="shared_pseudocode.html#type_GPCFRecord" title="">GPCFRecord</a>) =&gt; bits(6)
begin
    assert gpcf.level IN {0,1};

    case gpcf.gpf of
        when <a href="shared_pseudocode.html#enum_GPCF_AddressSize" title="">GPCF_AddressSize</a> =&gt; return '00000'::gpcf.level[0];
        when <a href="shared_pseudocode.html#enum_GPCF_Walk" title="">GPCF_Walk</a> =&gt;        return '00010'::gpcf.level[0];
        when <a href="shared_pseudocode.html#enum_GPCF_Fail" title="">GPCF_Fail</a> =&gt;        return '00110'::gpcf.level[0];
        when <a href="shared_pseudocode.html#enum_GPCF_EABT" title="">GPCF_EABT</a> =&gt;        return '01010'::gpcf.level[0];
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.aborts.LS64InstructionSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/aborts/LS64InstructionSyndrome</h3>
      <p class="pseudocode">// LS64InstructionSyndrome()
// =========================
// Returns the syndrome information and LST for a Data Abort by a
// ST64B, ST64BV, ST64BV0, or LD64B instruction. The syndrome information
// includes the ISS2, extended syndrome field.

impdef func <a id="func_LS64InstructionSyndrome_0"/>LS64InstructionSyndrome() =&gt; (bits(24), bits(11))
begin
    return (Zeros{24}, <a href="shared_pseudocode.html#func_LSInstructionSyndrome_0" title="">LSInstructionSyndrome</a>());
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.aborts.WatchpointFARNotPrecise"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/aborts/WatchpointFARNotPrecise</h3>
      <p class="pseudocode">// WatchpointFARNotPrecise()
// =========================
// Returns TRUE If the lowest watchpointed address that is higher than or equal to the address
// recorded in EDWAR might not have been accessed by the instruction, other than the CONSTRAINED
// UNPREDICTABLE condition of watchpoint matching a range of addresses with lowest address 16 bytes
// rounded down and upper address rounded up to nearest 16 byte multiple,
// FALSE otherwise.

impdef func <a id="func_WatchpointFARNotPrecise_1"/>WatchpointFARNotPrecise(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    if IsFeatureImplemented(FEAT_SVE) || IsFeatureImplemented(FEAT_SME) then
        return fault.watchptinfo.maybe_false_match;
    end;
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.apas.AArch64_APAS"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/apas/AArch64_APAS</h3>
      <p class="pseudocode">// AArch64_APAS()
// ==============
// Decode Xt and perform an APAS operation for the decoded record.

func AArch64_APAS(Xt : bits(64))
begin
    var apas : <a href="shared_pseudocode.html#type_APASRecord" title="">APASRecord</a>;
    let nse2 : bit = '0';
    apas.paspace = <a href="shared_pseudocode.html#func_DecodePASpace_3" title="">DecodePASpace</a>(nse2, Xt[62], Xt[63]);

    apas.pa = Xt[55:6] :: '000000';
    apas.target_attributes = Xt[2:0];

    if <a href="shared_pseudocode.html#func_AArch64_LocationSupportsAPAS_1" title="">AArch64_LocationSupportsAPAS</a>(apas) then
        APAS_OP(apas);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.apas.AArch64_LocationSupportsAPAS"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/apas/AArch64_LocationSupportsAPAS</h3>
      <p class="pseudocode">// AArch64_LocationSupportsAPAS()
// ==============================
// Returns TRUE if the given memory location supports the APAS instruction.

impdef func <a id="func_AArch64_LocationSupportsAPAS_1"/>AArch64_LocationSupportsAPAS(apas : <a href="shared_pseudocode.html#type_APASRecord" title="">APASRecord</a>) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.apas.APASRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/apas/APASRecord</h3>
      <p class="pseudocode">// APASRecord
// ==========
// Details related to an APAS operation.

type <a id="type_APASRecord"/>APASRecord of record {
    pa : bits(56),
    paspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>,
    target_attributes : bits(3)

};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.apas.APAS_OP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/apas/APAS_OP</h3>
      <p class="pseudocode">// APAS_OP()
// =========
// Sets the PA Space of the address in the APASRecord to the target PA space. If the location
// does not support the APAS instruction or cannot be associated with the indicated PASpace,
// then the instruction has no effect on the location and does not generate an External abort.

impdef func APAS_OP(apas : <a href="shared_pseudocode.html#type_APASRecord" title="">APASRecord</a>)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.at.AArch64_AT"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/at/AArch64_AT</h3>
      <p class="pseudocode">// AArch64_AT()
// ============
// Perform address translation as per AT instructions.

func AArch64_AT(address : bits(64), stage : <a href="shared_pseudocode.html#type_TranslationStage" title="">TranslationStage</a>, el_in : bits(2), ataccess : <a href="shared_pseudocode.html#type_ATAccess" title="">ATAccess</a>)
begin
    var el : bits(2) = el_in;
    let effective_nse_ns : bits(2) = <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NSE_0" title="">EffectiveSCR_EL3_NSE</a>() :: <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>();
    if (IsFeatureImplemented(FEAT_RME) &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp;
          effective_nse_ns == '10' &amp;&amp; el != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        Undefined();
    end;
    // For stage 1 translation, when HCR_EL2().[E2H, TGE] is {1,1} and requested EL is EL1,
    // the EL2&amp;0 translation regime is used.
    if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) &amp;&amp; el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; stage == <a href="shared_pseudocode.html#enum_TranslationStage_1" title="">TranslationStage_1</a> then
        el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    end;

    let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(el);

    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescAT_3" title="">CreateAccDescAT</a>(ss, el, ataccess);
    let aligned : boolean = TRUE;

    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, address);
    var regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>;
    if stage == <a href="shared_pseudocode.html#enum_TranslationStage_12" title="">TranslationStage_12</a> then
        regime = <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>;
    else
        regime = <a href="shared_pseudocode.html#func_TranslationRegime_1" title="">TranslationRegime</a>(el);
    end;

    var addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    if (el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>)) || (el != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(el)) then
        if regime == <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> || TTBCR().EAE == '1' then
            (fault, addrdesc) = <a href="shared_pseudocode.html#func_AArch32_S1TranslateLD_5" title="">AArch32_S1TranslateLD</a>(fault, regime, address[31:0], aligned,
                                                      accdesc);
        else
            (fault, addrdesc, -) = <a href="shared_pseudocode.html#func_AArch32_S1TranslateSD_5" title="">AArch32_S1TranslateSD</a>(fault, regime, address[31:0], aligned,
                                                         accdesc);
        end;
    else
        let size : integer = 1;
        (fault, addrdesc) = <a href="shared_pseudocode.html#func_AArch64_S1Translate_6" title="">AArch64_S1Translate</a>(fault, regime, address, size, aligned, accdesc);
    end;

    if stage == <a href="shared_pseudocode.html#enum_TranslationStage_12" title="">TranslationStage_12</a> &amp;&amp; fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        let s1aarch64 : boolean = TRUE;
        if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) &amp;&amp; regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
            addrdesc.vaddress = ZeroExtend{64}(address);
            (fault, addrdesc) = <a href="shared_pseudocode.html#func_AArch32_S2Translate_4" title="">AArch32_S2Translate</a>(fault, addrdesc, aligned, accdesc);
        elsif regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
            (fault, addrdesc) = <a href="shared_pseudocode.html#func_AArch64_S2Translate_5" title="">AArch64_S2Translate</a>(fault, addrdesc, s1aarch64, aligned, accdesc);
        end;
    end;

    let is_ATS1Ex : boolean = stage != <a href="shared_pseudocode.html#enum_TranslationStage_12" title="">TranslationStage_12</a>;
    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        addrdesc = <a href="shared_pseudocode.html#func_CreateFaultyAddressDescriptor_1" title="">CreateFaultyAddressDescriptor</a>(fault);
        // Take an exception on:
        // * A Synchronous External abort occurs on translation table walk
        // * A stage 2 fault occurs on a stage 1 walk
        // * A GPC Exception (FEAT_RME)
        // * A GPF from ATS1E{1,0}* when executed from EL1 and HCR_EL2.GPF == '1' (FEAT_RME)
        if (<a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault) ||
              (PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; fault.s2fs1walk) ||
               (IsFeatureImplemented(FEAT_RME) &amp;&amp; fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> &amp;&amp; (
                <a href="shared_pseudocode.html#func_ReportAsGPCException_1" title="">ReportAsGPCException</a>(fault) ||
                (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().GPF == '1' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; el IN {<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>} &amp;&amp;
                 is_ATS1Ex)
                ))) then
            if IsFeatureImplemented(FEAT_D128) then
                PAR_EL1()       = ARBITRARY : bits(128);
            else
                PAR_EL1()[63:0] = ARBITRARY : bits(64);
            end;
            AArch64_Abort(addrdesc.fault);
        end;
    end;

    AArch64_EncodePAR(regime, el, is_ATS1Ex, addrdesc);
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.at.AArch64_EncodePAR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/at/AArch64_EncodePAR</h3>
      <p class="pseudocode">// AArch64_EncodePAR()
// ===================
// Encode PAR register with result of translation.

func AArch64_EncodePAR(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, el : bits(2), is_ATS1Ex : boolean,
                       addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>)
begin
    let paspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a> = addrdesc.paddress.paspace;
    if IsFeatureImplemented(FEAT_D128) then
        PAR_EL1() = Zeros{128};
        if <a href="shared_pseudocode.html#func_AArch64_isPARFormatD128_2" title="">AArch64_isPARFormatD128</a>(regime, is_ATS1Ex) then
            PAR_EL1().D128 = '1';
        else
            PAR_EL1().D128 = '0';
        end;
    else
        PAR_EL1()[63:0] = Zeros{64};
    end;

    if !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(addrdesc) then
        PAR_EL1().F = '0';
        if IsFeatureImplemented(FEAT_RME) then
            if regime == <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> then
                case paspace of
                    when <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> =&gt;     PAR_EL1().[NSE,NS] = '00';
                    when <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> =&gt;  PAR_EL1().[NSE,NS] = '01';
                    when <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a> =&gt;       PAR_EL1().[NSE,NS] = '10';
                    when <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> =&gt;      PAR_EL1().[NSE,NS] = '11';
                end;

            elsif <a href="shared_pseudocode.html#func_SecurityStateForRegime_1" title="">SecurityStateForRegime</a>(regime) == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>  then
                PAR_EL1().NSE = ARBITRARY : bit;
                PAR_EL1().NS = if paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then '0' else '1';

            elsif <a href="shared_pseudocode.html#func_SecurityStateForRegime_1" title="">SecurityStateForRegime</a>(regime) == <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> then
                if regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; is_ATS1Ex then
                    PAR_EL1().NSE = ARBITRARY : bit;
                    PAR_EL1().NS  = ARBITRARY : bit;
                else
                    PAR_EL1().NSE = ARBITRARY : bit;
                    PAR_EL1().NS  = if paspace == <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> then '0' else '1';
                end;

            else
                PAR_EL1().NSE = ARBITRARY : bit;
                PAR_EL1().NS  = ARBITRARY : bit;
            end;
        else
            PAR_EL1()[11] = '1'; // RES1
            if <a href="shared_pseudocode.html#func_SecurityStateForRegime_1" title="">SecurityStateForRegime</a>(regime) == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
                PAR_EL1().NS = if paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then '0' else '1';
            else
                PAR_EL1().NS = ARBITRARY : bit;
            end;
        end;
        PAR_EL1().SH   = <a href="shared_pseudocode.html#func_ReportedPARShareability_1" title="">ReportedPARShareability</a>(<a href="shared_pseudocode.html#func_PAREncodeShareability_1" title="">PAREncodeShareability</a>(addrdesc.memattrs));
        if IsFeatureImplemented(FEAT_D128) &amp;&amp; PAR_EL1().D128 == '1' then
            PAR_EL1()[119:76] = addrdesc.paddress.address[55:12];
        else
            PAR_EL1()[55:12] = addrdesc.paddress.address[55:12];
        end;
        PAR_EL1().ATTR = <a href="shared_pseudocode.html#func_ReportedPARAttrs_1" title="">ReportedPARAttrs</a>(<a href="shared_pseudocode.html#func_EncodePARAttrs_1" title="">EncodePARAttrs</a>(addrdesc.memattrs));
        PAR_EL1()[10] = ImpDefBit("Non-Faulting PAR");
    else
        PAR_EL1().F   = '1';
        PAR_EL1().DirtyBit    = if addrdesc.fault.dirtybit then '1' else '0';
        PAR_EL1().Overlay     = if addrdesc.fault.overlay then '1' else '0';
        PAR_EL1().TopLevel    = if addrdesc.fault.toplevel then '1' else '0';
        PAR_EL1().AssuredOnly = if addrdesc.fault.assuredonly then '1' else '0';
        PAR_EL1().FST = <a href="shared_pseudocode.html#func_AArch64_PARFaultStatus_1" title="">AArch64_PARFaultStatus</a>(addrdesc.fault);
        PAR_EL1().PTW = if addrdesc.fault.s2fs1walk then '1' else '0';
        PAR_EL1().S   = if addrdesc.fault.secondstage then '1' else '0';
        PAR_EL1()[11] = '1'; // RES1
        PAR_EL1()[63:48] = ImpDefBits{16}("Faulting PAR");
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.at.AArch64_PARFaultStatus"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/at/AArch64_PARFaultStatus</h3>
      <p class="pseudocode">// AArch64_PARFaultStatus()
// ========================
// Fault status field decoding of 64-bit PAR.

func <a id="func_AArch64_PARFaultStatus_1"/>AArch64_PARFaultStatus(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; bits(6)
begin
    var fst : bits(6);

    if fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_Domain" title="">Fault_Domain</a> then
        // Report Domain fault
        assert fault.level IN {1,2};
        fst[1:0] = if fault.level == 1 then '01' else '10';
        fst[5:2] = '1111';
    else
        fst = <a href="shared_pseudocode.html#func_EncodeLDFSC_2" title="">EncodeLDFSC</a>(fault.statuscode, fault.level);
    end;
    return fst;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.at.AArch64_isPARFormatD128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/at/AArch64_isPARFormatD128</h3>
      <p class="pseudocode">// AArch64_isPARFormatD128()
// =========================
// Check if last stage of translation uses VMSAv9-128.
// Last stage of translation is stage 2 if enabled, else it is stage 1.

func <a id="func_AArch64_isPARFormatD128_2"/>AArch64_isPARFormatD128(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, is_ATS1Ex : boolean) =&gt; boolean
begin
    var isPARFormatD128 : boolean;
    // Regime_EL2 does not support VMSAv9-128
    if regime == <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> || !IsFeatureImplemented(FEAT_D128) then
        isPARFormatD128 = FALSE;
    else
        isPARFormatD128 = FALSE;
        case regime of
            when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> =&gt;
                isPARFormatD128 = TCR_EL3().D128 == '1';
            when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt;
                isPARFormatD128 = <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() &amp;&amp; TCR2_EL2().D128 == '1';
            when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;
                if is_ATS1Ex || !<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() || HCR_EL2().[VM,DC] == '00' then
                    isPARFormatD128 = <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() &amp;&amp; TCR2_EL1().D128 == '1';
                else
                    isPARFormatD128 = VTCR_EL2().D128 == '1';
                end;
        end;
    end;

    return isPARFormatD128;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.at.GetPAR_EL1_D128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/at/GetPAR_EL1_D128</h3>
      <p class="pseudocode">// GetPAR_EL1_D128()
// =================
// Query the PAR_EL1.D128 field

func <a id="func_GetPAR_EL1_D128_0"/>GetPAR_EL1_D128() =&gt; bit
begin
    return if IsFeatureImplemented(FEAT_D128) then PAR_EL1().D128 else '0';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.at.GetPAR_EL1_F"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/at/GetPAR_EL1_F</h3>
      <p class="pseudocode">// GetPAR_EL1_F()
// ==============
// Query the PAR_EL1.F field.

func <a id="func_GetPAR_EL1_F_0"/>GetPAR_EL1_F() =&gt; bit
begin
    var F : bit;

    F = PAR_EL1().F;
    return F;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.barrierop.MemBarrierOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/barrierop/MemBarrierOp</h3>
      <p class="pseudocode">// MemBarrierOp
// ============
// Memory barrier instruction types.

type <a id="type_MemBarrierOp"/>MemBarrierOp of enumeration {
                                  <a id="enum_MemBarrierOp_DSB"/>MemBarrierOp_DSB,     // Data Synchronization Barrier
                                  <a id="enum_MemBarrierOp_DMB"/>MemBarrierOp_DMB,     // Data Memory Barrier
                                  <a id="enum_MemBarrierOp_ISB"/>MemBarrierOp_ISB,     // Instruction Synchronization Barrier
                                  <a id="enum_MemBarrierOp_SSBB"/>MemBarrierOp_SSBB,    // Speculative Synchronization Barrier to VA
                                  <a id="enum_MemBarrierOp_PSSBB"/>MemBarrierOp_PSSBB,   // Speculative Synchronization Barrier to PA
                                  <a id="enum_MemBarrierOp_SB"/>MemBarrierOp_SB       // Speculation Barrier
                           };</p>
    </div>
    <div class="ps"><a id="aarch64.functions.bfxpreferred.BFXPreferred"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/bfxpreferred/BFXPreferred</h3>
      <p class="pseudocode">// BFXPreferred()
// ==============
//
// Return TRUE if UBFX or SBFX is the preferred disassembly of a
// UBFM or SBFM bitfield instruction. Must exclude more specific
// aliases UBFIZ, SBFIZ, UXT[BH], SXT[BHW], LSL, LSR and ASR.

func <a id="func_BFXPreferred_4"/>BFXPreferred(sf : bit, uns : bit, imms : bits(6), immr : bits(6)) =&gt; boolean
begin

    // must not match UBFIZ/SBFIX alias
    if UInt(imms) &lt; UInt(immr) then
        return FALSE;
    end;

    // must not match LSR/ASR/LSL alias (imms == 31 or 63)
    if imms == sf::'11111' then
        return FALSE;
    end;

    // must not match UXTx/SXTx alias
    if immr == '000000' then
        // must not match 32-bit UXT[BH] or SXT[BH]
        if sf == '0' &amp;&amp; imms IN {'000111', '001111'} then
            return FALSE;
        end;
        // must not match 64-bit SXT[BHW]
        if sf::uns == '10' &amp;&amp; imms IN {'000111', '001111', '011111'} then
            return FALSE;
        end;
    end;

    // must be UBFX/SBFX alias
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.bitmasks.AltDecodeBitMasks"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/bitmasks/AltDecodeBitMasks</h3>
      <p class="pseudocode">// AltDecodeBitMasks()
// ===================
// Alternative but logically equivalent implementation of DecodeBitMasks() that
// uses simpler primitives to compute tmask and wmask.

func <a id="func_AltDecodeBitMasks_5"/>AltDecodeBitMasks{M}(immN : bit, imms : bits(6), immr : bits(6),
                          immediate : boolean) =&gt; (bits(M), bits(M))
begin
    var tmask, wmask : bits(64);
    var tmask_and, wmask_and : bits(6);
    var tmask_or, wmask_or : bits(6);
    var levels : bits(6);

    // Compute log2 of element size
    // 2^len must be in range [2, M]
    if immN::NOT(imms) == '000000x' then Undefined(); end;
    let len : integer{} = HighestSetBitNZ(immN::NOT(imms));
    assert 2 &lt;= (2^len) &amp;&amp; (2^len) &lt;= M;

    // Determine s, r and s - r parameters
    levels = ZeroExtend{6}(Ones{len});

    // For logical immediates an all-ones value of s is reserved
    // since it would generate a useless all-ones result (many times)
    if immediate &amp;&amp; (imms AND levels) == levels then Undefined(); end;

    let s : integer{} = UInt(imms AND levels);
    let r : integer{} = UInt(immr AND levels);
    let diff : integer{} = s - r;    // 6-bit subtract with borrow

    // Compute "top mask"
    tmask_and = diff[5:0] OR NOT(levels);
    tmask_or  = diff[5:0] AND levels;

    tmask = Ones{64};
    tmask = ((tmask
              AND Replicate{64, 2}(Replicate{1}(tmask_and[0]) :: Ones{1}))
               OR  Replicate{64, 2}(Zeros{1} :: Replicate{1}(tmask_or[0])));
    // optimization of first step:
    // tmask = Replicate{64}(tmask_and[0] :: '1');
    tmask = ((tmask
              AND Replicate{64, 4}(Replicate{2}(tmask_and[1]) :: Ones{2}))
               OR  Replicate{64, 4}(Zeros{2} :: Replicate{2}(tmask_or[1])));
    tmask = ((tmask
              AND Replicate{64, 8}(Replicate{4}(tmask_and[2]) :: Ones{4}))
               OR  Replicate{64, 8}(Zeros{4} :: Replicate{4}(tmask_or[2])));
    tmask = ((tmask
              AND Replicate{64, 16}(Replicate{8}(tmask_and[3]) :: Ones{8}))
               OR  Replicate{64, 16}(Zeros{8} :: Replicate{8}(tmask_or[3])));
    tmask = ((tmask
              AND Replicate{64, 32}(Replicate{16}(tmask_and[4]) :: Ones{16}))
               OR  Replicate{64, 32}(Zeros{16} :: Replicate{16}(tmask_or[4])));
    tmask = ((tmask
              AND Replicate{64, 64}(Replicate{32}(tmask_and[5]) :: Ones{32}))
               OR  Replicate{64, 64}(Zeros{32} :: Replicate{32}(tmask_or[5])));

    // Compute "wraparound mask"
    wmask_and = immr OR NOT(levels);
    wmask_or  = immr AND levels;

    wmask = Zeros{64};
    wmask = ((wmask
              AND Replicate{64, 2}(Ones{1} :: Replicate{1}(wmask_and[0])))
               OR  Replicate{64, 2}(Replicate{1}(wmask_or[0]) :: Zeros{1}));
    // wmask = Replicate(wmask_or[0] : '0', 32);
    wmask = ((wmask
              AND Replicate{64, 4}(Ones{2} :: Replicate{2}(wmask_and[1])))
               OR  Replicate{64, 4}(Replicate{2}(wmask_or[1]) :: Zeros{2}));
    wmask = ((wmask
              AND Replicate{64, 8}(Ones{4} :: Replicate{4}(wmask_and[2])))
               OR  Replicate{64, 8}(Replicate{4}(wmask_or[2]) :: Zeros{4}));
    wmask = ((wmask
              AND Replicate{64, 16}(Ones{8} :: Replicate{8}(wmask_and[3])))
               OR  Replicate{64, 16}(Replicate{8}(wmask_or[3]) :: Zeros{8}));
    wmask = ((wmask
              AND Replicate{64, 32}(Ones{16} :: Replicate{16}(wmask_and[4])))
               OR  Replicate{64, 32}(Replicate{16}(wmask_or[4]) :: Zeros{16}));
    wmask = ((wmask
              AND Replicate{64, 64}(Ones{32} :: Replicate{32}(wmask_and[5])))
               OR  Replicate{64, 64}(Replicate{32}(wmask_or[5]) :: Zeros{32}));

    if diff[6] != '0' then // borrow from s - r
        wmask = wmask AND tmask;
    else
        wmask = wmask OR tmask;
    end;

    return (wmask[M-1:0], tmask[M-1:0]);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.bitmasks.DecodeBitMasks"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/bitmasks/DecodeBitMasks</h3>
      <p class="pseudocode">// DecodeBitMasks()
// ================
// Decode AArch64 bitfield and logical immediate masks which use a similar encoding structure

func <a id="func_DecodeBitMasks_5"/>DecodeBitMasks{M}(immN : bit, imms : bits(6), immr : bits(6),
                       immediate : boolean) =&gt; (bits(M), bits(M))
begin
    var levels : bits(6);

    // Compute log2 of element size
    // 2^len must be in range [2, M]
    if immN::NOT(imms) == '000000x' then Undefined(); end;
    let len : integer{} = HighestSetBitNZ(immN::NOT(imms));
    assert 2 &lt;= (2^len) &amp;&amp; (2^len) &lt;= M;

    // Determine s, r and s - r parameters
    levels = ZeroExtend{6}(Ones{len});

    // For logical immediates an all-ones value of s is reserved
    // since it would generate a useless all-ones result (many times)
    if immediate &amp;&amp; (imms AND levels) == levels then Undefined(); end;

    let s : integer{} = UInt(imms AND levels);
    let r : integer{} = UInt(immr AND levels);
    let diff : integer{}  = s - r;    // 6-bit subtract with borrow

    let esize : integer{} = 1 &lt;&lt; len;
    let d : integer{}     = UInt(diff[len-1:0]);
    let welem : bits(esize) = ZeroExtend{}(Ones{s + 1});
    let telem : bits(esize) = ZeroExtend{}(Ones{d + 1});
    let wmask : bits(M) = Replicate{}(ROR(welem, r));
    let tmask : bits(M) = Replicate{}(telem);
    return (wmask, tmask);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.cache.AArch64_DataMemZero"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/cache/AArch64_DataMemZero</h3>
      <p class="pseudocode">// AArch64_DataMemZero()
// =====================
// Write Zero to data memory.

func AArch64_DataMemZero(regval : bits(64), vaddress : bits(64),
                         accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, size : integer)
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;

    // If the instruction targets tags as a payload, confer with system register configuration
    // which may override this.
    if accdesc.tagaccess then
        accdesc.tagaccess = <a href="shared_pseudocode.html#func_IsMTEEnabled_1" title="">IsMTEEnabled</a>(accdesc.el);
    end;

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#func_AArch64_AccessIsTagChecked_2" title="">AArch64_AccessIsTagChecked</a>(vaddress, accdesc);
    end;

    let aligned : boolean = TRUE;
    var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(vaddress,
                                                                   accdesc, aligned, size);

    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        if !<a href="shared_pseudocode.html#func_IsDebugException_1" title="">IsDebugException</a>(memaddrdesc.fault) then
            memaddrdesc.fault.vaddress = regval;
        end;
        AArch64_Abort(memaddrdesc.fault);
    end;

    for i = 0 to size-1 do
        if accdesc.tagchecked then
            let ltag : bits(4)      = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(vaddress);
            var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = AArch64_CheckTag(memaddrdesc, accdesc, 1, ltag);
            if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
                if ImpDefBool(
                      "DC_ZVA tag fault reported with lowest faulting address") then
                    AArch64_Abort(fault);
                else
                    fault.vaddress = regval;
                    AArch64_Abort(fault);
                end;
            end;
        end;
        let memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a> = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{8}(memaddrdesc, accdesc, Zeros{8});
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            HandleExternalWriteAbort(memstatus, memaddrdesc, 1, accdesc);
        end;

        memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.cache.AArch64_WriteTagMem"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/cache/AArch64_WriteTagMem</h3>
      <p class="pseudocode">// AArch64_WriteTagMem()
// =====================
// Write to tag memory.

func AArch64_WriteTagMem(regval : bits(64), vaddress : bits(64),
                         accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, size : integer)
begin
    assert accdesc_in.tagaccess &amp;&amp; !accdesc_in.tagchecked;

    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;

    let count : integer   = size &gt;&gt; <a href="shared_pseudocode.html#global_LOG2_TAG_GRANULE" title="">LOG2_TAG_GRANULE</a>;
    let tag : bits(4)     = <a href="shared_pseudocode.html#func_AArch64_AllocationTagFromAddress_1" title="">AArch64_AllocationTagFromAddress</a>(vaddress);
    let aligned : boolean = IsAlignedSize{64}(vaddress, <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a>);
    assert aligned;

    accdesc.tagaccess = <a href="shared_pseudocode.html#func_IsMTEEnabled_1" title="">IsMTEEnabled</a>(accdesc.el);

    var (memtagtype, memaddrdesc) = <a href="shared_pseudocode.html#func_AArch64_TranslateTagAddress_4" title="">AArch64_TranslateTagAddress</a>(vaddress, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        if <a href="shared_pseudocode.html#func_IsDebugException_1" title="">IsDebugException</a>(memaddrdesc.fault) then
            AArch64_Abort(memaddrdesc.fault);
        else
            memaddrdesc.fault.vaddress = regval;
            AArch64_Abort(memaddrdesc.fault);
        end;
    end;

    if !accdesc.tagaccess || memtagtype != <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a> then
        return;
    end;

    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;

    for i = 0 to count-1 do
        memstatus = <a href="shared_pseudocode.html#func_PhysMemTagWrite_3" title="">PhysMemTagWrite</a>(memaddrdesc, accdesc, tag);
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            HandleExternalWriteAbort(memstatus, memaddrdesc, 1, accdesc);
        end;

        memaddrdesc.paddress.address = memaddrdesc.paddress.address + <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a>;
        memaddrdesc.vaddress         = memaddrdesc.vaddress + <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a>;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.compareop.CompareOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/compareop/CompareOp</h3>
      <p class="pseudocode">// CompareOp
// =========
// Vector compare instruction types.

type <a id="type_CompareOp"/>CompareOp of enumeration {<a id="enum_CompareOp_GT"/>CompareOp_GT, <a id="enum_CompareOp_GE"/>CompareOp_GE, <a id="enum_CompareOp_EQ"/>CompareOp_EQ,
                               <a id="enum_CompareOp_LE"/>CompareOp_LE, <a id="enum_CompareOp_LT"/>CompareOp_LT};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.countop.CountOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/countop/CountOp</h3>
      <p class="pseudocode">// CountOp
// =======
// Bit counting instruction types.

type <a id="CountOp"/>CountOp of enumeration {CountOp_CLZ, CountOp_CLS, CountOp_CNT};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.cpa.EffectiveCPTA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/cpa/EffectiveCPTA</h3>
      <p class="pseudocode">// EffectiveCPTA()
// ===============
// Returns the CPTA bit applied to Checked Pointer Arithmetic for Addition in the given EL.

func <a id="func_EffectiveCPTA_1"/>EffectiveCPTA(el : bits(2)) =&gt; bit
begin
    if !IsFeatureImplemented(FEAT_CPA2) then
        return '0';
    end;

    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        return '0';
    end;

    var cpta : bits(1);
    let regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a> = <a href="shared_pseudocode.html#func_TranslationRegime_1" title="">TranslationRegime</a>(el);

    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> =&gt;
            cpta = SCTLR2_EL3().CPTA;
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;
            if <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then
                cpta = SCTLR2_EL2().CPTA;
            else
                cpta = '0';
            end;
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt;
            if <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then
                cpta = if el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then SCTLR2_EL2().CPTA0 else SCTLR2_EL2().CPTA;
            else
                cpta = '0';
            end;
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;
            if <a href="shared_pseudocode.html#func_IsSCTLR2EL1Enabled_0" title="">IsSCTLR2EL1Enabled</a>() then
                cpta = if el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then SCTLR2_EL1().CPTA0 else SCTLR2_EL1().CPTA;
            else
                cpta = '0';
            end;
        otherwise =&gt;
            unreachable;
    end;

    return cpta;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.cpa.EffectiveCPTM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/cpa/EffectiveCPTM</h3>
      <p class="pseudocode">// EffectiveCPTM()
// ===============
// Returns the CPTM bit applied to Checked Pointer Arithmetic for Multiplication in the given EL.

func <a id="func_EffectiveCPTM_1"/>EffectiveCPTM(el : bits(2)) =&gt; bit
begin
    if !IsFeatureImplemented(FEAT_CPA2) then
        return '0';
    end;

    if <a href="shared_pseudocode.html#func_EffectiveCPTA_1" title="">EffectiveCPTA</a>(el) == '0' then
        return '0';
    end;

    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        return '0';
    end;

    var cptm : bits(1);
    let regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a> = <a href="shared_pseudocode.html#func_TranslationRegime_1" title="">TranslationRegime</a>(el);

    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> =&gt;
            cptm = SCTLR2_EL3().CPTM;
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;
            if <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then
                cptm = SCTLR2_EL2().CPTM;
            else
                cptm = '0';
            end;
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt;
            if <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then
                cptm = if el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then SCTLR2_EL2().CPTM0 else SCTLR2_EL2().CPTM;
            else
                cptm = '0';
            end;
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;
            if <a href="shared_pseudocode.html#func_IsSCTLR2EL1Enabled_0" title="">IsSCTLR2EL1Enabled</a>() then
                cptm = if el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then SCTLR2_EL1().CPTM0 else SCTLR2_EL1().CPTM;
            else
                cptm = '0';
            end;
        otherwise =&gt;
            unreachable;
    end;

    return cptm;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.cpa.PointerAddCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/cpa/PointerAddCheck</h3>
      <p class="pseudocode">// PointerAddCheck()
// =================
// Apply Checked Pointer Arithmetic for addition.

func <a id="func_PointerAddCheck_2"/>PointerAddCheck(result : bits(64), base : bits(64)) =&gt; bits(64)
begin
    return <a href="shared_pseudocode.html#func_PointerCheckAtEL_4" title="">PointerCheckAtEL</a>(PSTATE.EL, result, base, FALSE);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.cpa.PointerAddCheckAtEL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/cpa/PointerAddCheckAtEL</h3>
      <p class="pseudocode">// PointerAddCheckAtEL()
// =====================
// Apply Checked Pointer Arithmetic for addition at the specified EL.

func <a id="func_PointerAddCheckAtEL_3"/>PointerAddCheckAtEL(el : bits(2), result : bits(64), base : bits(64)) =&gt; bits(64)
begin
    return <a href="shared_pseudocode.html#func_PointerCheckAtEL_4" title="">PointerCheckAtEL</a>(el, result, base, FALSE);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.cpa.PointerCheckAtEL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/cpa/PointerCheckAtEL</h3>
      <p class="pseudocode">// PointerCheckAtEL()
// ==================
// Apply Checked Pointer Arithmetic at the specified EL.

func <a id="func_PointerCheckAtEL_4"/>PointerCheckAtEL(el : bits(2), result : bits(64), base : bits(64),
                      cptm_detected : boolean) =&gt; bits(64)
begin
    var rv : bits(64)  = result;

    let previous_detection : boolean = (base[55] != base[54]);
    let cpta_detected : boolean = (result[63:56] != base[63:56] || previous_detection);

    if ((cpta_detected &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveCPTA_1" title="">EffectiveCPTA</a>(el) == '1') ||
          (cptm_detected &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveCPTM_1" title="">EffectiveCPTM</a>(el) == '1')) then
        rv[63:55] = base[63:55];
        rv[54] = NOT(rv[55]);
    end;

    return rv;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.cpa.PointerMultiplyAddCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/cpa/PointerMultiplyAddCheck</h3>
      <p class="pseudocode">// PointerMultiplyAddCheck()
// =========================
// Apply Checked Pointer Arithmetic for multiplication.

func <a id="func_PointerMultiplyAddCheck_3"/>PointerMultiplyAddCheck(result : bits(64), base : bits(64),
                             cptm_detected : boolean) =&gt; bits(64)
begin
    return <a href="shared_pseudocode.html#func_PointerCheckAtEL_4" title="">PointerCheckAtEL</a>(PSTATE.EL, result, base, cptm_detected);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.d128.IsD128Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/d128/IsD128Enabled</h3>
      <p class="pseudocode">// IsD128Enabled()
// ===============
// Returns true if 128-bit page descriptor is enabled

func <a id="func_IsD128Enabled_1"/>IsD128Enabled(el : bits(2)) =&gt; boolean
begin
    var d128enabled : boolean;
    if IsFeatureImplemented(FEAT_D128) then
        case el of
            when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
                if !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) then
                    d128enabled = <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() &amp;&amp; TCR2_EL1().D128 == '1';
                else
                    d128enabled = <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() &amp;&amp; TCR2_EL2().D128 == '1';
                end;
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
                d128enabled = <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() &amp;&amp; TCR2_EL1().D128 == '1';
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
                d128enabled = <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() &amp;&amp; TCR2_EL2().D128 == '1';
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
                d128enabled = TCR_EL3().D128 == '1';
        end;
    else
        d128enabled = FALSE;
    end;

    return d128enabled;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.dc.AArch64_CanTrapDC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/dc/AArch64_CanTrapDC</h3>
      <p class="pseudocode">// AArch64_CanTrapDC()
// ===================
// Determines whether the execution of the DC instruction can be trapped.

func <a id="func_AArch64_CanTrapDC_3"/>AArch64_CanTrapDC(cachetype : <a href="shared_pseudocode.html#type_CacheType" title="">CacheType</a>, cacheop : <a href="shared_pseudocode.html#type_CacheOp" title="">CacheOp</a>, opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>) =&gt; boolean
begin
    return (!<a href="shared_pseudocode.html#func_AArch64_TreatDCAsNOP_3" title="">AArch64_TreatDCAsNOP</a>(cachetype, cacheop, opscope) || ImpDefBool(
            "When DC is treated as NOP, data cache maintenance operations are trapped"));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.dc.AArch64_DC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/dc/AArch64_DC</h3>
      <p class="pseudocode">// AArch64_DC()
// ============
// Perform Data Cache Operation.

func AArch64_DC(regval : bits(64), cachetype : CacheType,
                cacheop : CacheOp, opscope_in : CacheOpScope)
begin
    var opscope : CacheOpScope = opscope_in;
    var cache : CacheRecord;

    cache.acctype   = AccessType_DC;
    cache.cachetype = cachetype;
    cache.cacheop   = cacheop;
    cache.opscope   = opscope;

    if opscope == CacheOpScope_SetWay then
        let ss : SecurityState = SecurityStateAtEL(PSTATE.EL);
        cache.cpas = CPASAtSecurityState(ss);
        cache.shareability = Shareability_NSH;
        cache.(setnum, waynum, level) = DecodeSW(regval, cachetype);
        if (cacheop == CacheOp_Invalidate &amp;&amp; PSTATE.EL == EL1 &amp;&amp; EL2Enabled() &amp;&amp;
          (HCR_EL2().SWIO == '1' || HCR_EL2().[DC,VM] != '00')) then
            cache.cacheop = CacheOp_CleanInvalidate;
        end;

        CACHE_OP(cache);
        return;
    end;

    if EL2Enabled() &amp;&amp; !IsInHost() then
        if PSTATE.EL IN {EL0, EL1} then
            cache.is_vmid_valid = TRUE;
            cache.vmid          = VMID();
        else
            cache.is_vmid_valid = FALSE;
        end;
    else
        cache.is_vmid_valid = FALSE;
    end;

    if PSTATE.EL == EL0 then
        cache.is_asid_valid = TRUE;
        cache.asid          = ASID();
    else
        cache.is_asid_valid = FALSE;
    end;

    if (opscope == CacheOpScope_PoPS &amp;&amp;
          ImpDefBool("Memory system does not support PoPS")) then
        opscope = CacheOpScope_PoC;
    end;
    if (opscope == CacheOpScope_PoDP &amp;&amp;
          ImpDefBool("Memory system does not support PoDP")) then
        opscope = CacheOpScope_PoP;
    end;
    if (opscope == CacheOpScope_PoP &amp;&amp;
          ImpDefBool("Memory system does not support PoP")) then
        opscope = CacheOpScope_PoC;
    end;
    var vaddress : bits(64) = regval;

    var size : integer = 0;        // by default no watchpoint address
    if cacheop == CacheOp_Invalidate then
        size = DataCacheWatchpointSize();
        vaddress = AlignDownSize{64}(regval, size as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>);
    end;

    if opscope == CacheOpScope_PoE then
        cache.shareability     = Shareability_OSH;
        cache.paddress.address = regval[55:0];
        let nse2 : bit = if IsFeatureImplemented(FEAT_RME_GDI) then regval[61] else '0';
        cache.paddress.paspace = DecodePASpace(nse2, regval[62], regval[63]);
        cache.cpas             = CPASAtPAS(cache.paddress.paspace);

        // If a Reserved encoding is selected, the instruction is permitted to be treated as a NOP.
        if cache.paddress.paspace != PAS_Realm then
            ExecuteAsNOP();
        end;

        if ImpDefBool("Apply granule protection check on DC to PoE") then
            var memaddrdesc : AddressDescriptor;
            let accdesc : AccessDescriptor = CreateAccDescDC(cache);
            memaddrdesc.paddress     = cache.paddress;
            memaddrdesc.fault.gpcf   = GranuleProtectionCheck(memaddrdesc, accdesc);

            if memaddrdesc.fault.gpcf.gpf != GPCF_None then
                memaddrdesc.fault.statuscode = Fault_GPCFOnOutput;
                memaddrdesc.fault.paddress   = memaddrdesc.paddress;
                memaddrdesc.fault.vaddress   = ARBITRARY : bits(64);
                AArch64_Abort(memaddrdesc.fault);
            end;
        end;
    elsif opscope == CacheOpScope_PoPA then
        cache.shareability = Shareability_OSH;
        cache.paddress.address = regval[55:0];
        let nse2 : bit = if IsFeatureImplemented(FEAT_RME_GDI) then regval[61] else '0';
        cache.paddress.paspace = DecodePASpace(nse2, regval[62], regval[63]);

        // If {NSE2, NSE, NS} is reserved, then no cache entries are required
        // to be cleaned or invalidated.
        if cache.paddress.paspace IN {PAS_NA6, PAS_NA7} then
            ExecuteAsNOP();
        end;
        cache.cpas = CPASAtPAS(cache.paddress.paspace);
    else
        cache.vaddress  = vaddress;
        let aligned : boolean = TRUE;
        let accdesc : AccessDescriptor = CreateAccDescDC(cache);
        var memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(vaddress, accdesc,
                                                                       aligned, size);
        if IsFault(memaddrdesc) then
            memaddrdesc.fault.vaddress = regval;
            AArch64_Abort(memaddrdesc.fault);
        end;

        cache.paddress   = memaddrdesc.paddress;
        cache.cpas       = CPASAtPAS(memaddrdesc.paddress.paspace);

        if (opscope IN {
                         CacheOpScope_PoDP,
                         CacheOpScope_PoP,
                         CacheOpScope_PoC,
                         CacheOpScope_PoU
                      }) then
            cache.shareability = memaddrdesc.memattrs.shareability;
        else
            cache.shareability = Shareability_NSH;
        end;
    end;

    if (cacheop == CacheOp_Invalidate &amp;&amp; PSTATE.EL == EL1 &amp;&amp; EL2Enabled() &amp;&amp;
            HCR_EL2().[DC,VM] != '00') then
        cache.cacheop = CacheOp_CleanInvalidate;
    end;

    // If Secure state is not implemented, but RME is, the instruction acts as a NOP
    if cache.cpas == CPAS_Secure &amp;&amp; !HaveSecureState() then
        return;
    end;

    CACHE_OP(cache);
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.dc.AArch64_MemZero"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/dc/AArch64_MemZero</h3>
      <p class="pseudocode">// AArch64_MemZero()
// =================

func AArch64_MemZero(regval : bits(64), cachetype : <a href="shared_pseudocode.html#type_CacheType" title="">CacheType</a>)
begin
    let size : integer{} = (if cachetype IN {<a href="shared_pseudocode.html#enum_CacheType_TagWrite" title="">CacheType_TagWrite</a>, <a href="shared_pseudocode.html#enum_CacheType_TagZero" title="">CacheType_TagZero</a>}
                            then 4*(2^(UInt(DCZID_EL0().TBS)))
                            else 4*(2^(UInt(DCZID_EL0().BS))));
    assert size &lt;= <a href="shared_pseudocode.html#global_MAX_ZERO_BLOCK_SIZE" title="">MAX_ZERO_BLOCK_SIZE</a>;
    if IsFeatureImplemented(FEAT_MTE2) then
        assert size &gt;= <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a>;
    end;
    let vaddress : bits(64) = AlignDownSize{}(regval, size);

    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescDCZero_1" title="">CreateAccDescDCZero</a>(cachetype);

    if cachetype IN {<a href="shared_pseudocode.html#enum_CacheType_TagZero" title="">CacheType_TagZero</a>} then
        AArch64_WriteTagMem(Zeros{64}, vaddress, accdesc, size);
    end;

    if cachetype IN {<a href="shared_pseudocode.html#enum_CacheType_Tag" title="">CacheType_Tag</a>, <a href="shared_pseudocode.html#enum_CacheType_TagWrite" title="">CacheType_TagWrite</a>, <a href="shared_pseudocode.html#enum_CacheType_Data_Tag" title="">CacheType_Data_Tag</a>} then
        AArch64_WriteTagMem(regval, vaddress, accdesc, size);
    end;

    if cachetype IN {<a href="shared_pseudocode.html#enum_CacheType_Data" title="">CacheType_Data</a>, <a href="shared_pseudocode.html#enum_CacheType_Data_Tag" title="">CacheType_Data_Tag</a>} then
        AArch64_DataMemZero(regval, vaddress, accdesc, size);
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.dc.AArch64_TreatDCAsNOP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/dc/AArch64_TreatDCAsNOP</h3>
      <p class="pseudocode">// AArch64_TreatDCAsNOP()
// ======================
// Determines whether the execution of the DC instruction is treated as a NOP.

func <a id="func_AArch64_TreatDCAsNOP_3"/>AArch64_TreatDCAsNOP(cachetype : <a href="shared_pseudocode.html#type_CacheType" title="">CacheType</a>, cacheop : <a href="shared_pseudocode.html#type_CacheOp" title="">CacheOp</a>,
                          opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>) =&gt; boolean
begin
    // DC to PoU: IMPLEMENTATION DEFINED - treated as NOP if LoUU and LoUIS are 0
    if opscope == <a href="shared_pseudocode.html#enum_CacheOpScope_PoU" title="">CacheOpScope_PoU</a> &amp;&amp; CLIDR_EL1().LoUU == '000' &amp;&amp; CLIDR_EL1().LoUIS == '000' then
        return ImpDefBool("DC to PoU is treated as a NOP");
    end;

    // DC to PoC: IMPLEMENTATION DEFINED - treated as NOP if LoC is 0
    if opscope == <a href="shared_pseudocode.html#enum_CacheOpScope_PoC" title="">CacheOpScope_PoC</a> &amp;&amp; CLIDR_EL1().LoC == '000' then
        return ImpDefBool("DC to PoC is treated as a NOP");
    end;

    // DC to PoP: IMPLEMENTATION DEFINED - treated as NOP if LoC is 0 and PoP unsupported
    if (opscope == <a href="shared_pseudocode.html#enum_CacheOpScope_PoP" title="">CacheOpScope_PoP</a> &amp;&amp; CLIDR_EL1().LoC == '000' &amp;&amp;
          !ImpDefBool("Memory system supports PoP")) then
        return ImpDefBool("DC to PoP is treated as a NOP");
    end;

    // DC to PoDP: IMPLEMENTATION DEFINED - treated as NOP if LoC is 0 and PoP/PoDP unsupported
    if (opscope == <a href="shared_pseudocode.html#enum_CacheOpScope_PoDP" title="">CacheOpScope_PoDP</a> &amp;&amp; CLIDR_EL1().LoC == '000' &amp;&amp;
          !ImpDefBool("Memory system supports PoP") &amp;&amp;
          !ImpDefBool("Memory system supports PoDP")) then
        return ImpDefBool("DC to PoDP is treated as a NOP");
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.dc.MemZero"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/dc/MemZero</h3>
      <p class="pseudocode">// MemZero block size
// ==================

constant <a id="global_MAX_ZERO_BLOCK_SIZE"/>MAX_ZERO_BLOCK_SIZE : integer = 2048;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.eret.AArch64_ExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/eret/AArch64_ExceptionReturn</h3>
      <p class="pseudocode">// AArch64_ExceptionReturn()
// =========================

func AArch64_ExceptionReturn(new_pc_in : bits(64), spsr : bits(64))
begin
    var new_pc : bits(64) = new_pc_in;

    if IsFeatureImplemented(FEAT_IESB) then
        var sync_errors : boolean = <a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().IESB == '1';
        if IsFeatureImplemented(FEAT_DoubleFault) then
            sync_errors = sync_errors || (SCR_EL3().[EA,NMEA] == '11' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;
        if sync_errors then
            SynchronizeErrors();
            let iesb_req : boolean = TRUE;
            TakeUnmaskedPhysicalSErrorInterrupts(iesb_req);
        end;
    end;

    var brbe_source_allowed : boolean = FALSE;
    var brbe_source_address : bits(64) = Zeros{};
    if IsFeatureImplemented(FEAT_BRBE) then
        brbe_source_allowed = <a href="shared_pseudocode.html#func_BranchRecordAllowed_1" title="">BranchRecordAllowed</a>(PSTATE.EL);
        brbe_source_address = <a href="shared_pseudocode.html#func_PC64_0" title="">PC64</a>();
    end;

    if !IsFeatureImplemented(FEAT_ExS) || <a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().EOS == '1' then
        SynchronizeContext();
    end;

    // Attempts to change to an illegal state will invoke the Illegal Execution state mechanism
    let source_el : bits(2) = PSTATE.EL;
    let illegal_psr_state : boolean = <a href="shared_pseudocode.html#func_IllegalExceptionReturn_2" title="">IllegalExceptionReturn</a>{64}(spsr);
    SetPSTATEFromPSR{64}(spsr, illegal_psr_state);
    ClearExclusiveLocal(<a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>());
    SendEventLocal();

    if illegal_psr_state &amp;&amp; spsr[4] == '1' then
        // If the exception return is illegal, PC[63:32,1:0] are UNKNOWN
        new_pc[63:32] = ARBITRARY : bits(32);
        new_pc[1:0] = ARBITRARY : bits(2);
    elsif <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then                // Return to AArch32
        // ELR_ELx[1:0] or ELR_ELx[0] are treated as being 0, depending on the
        // target instruction set state
        if PSTATE.T == '1' then
            new_pc[0] = '0';                 // T32
        else
            new_pc[1:0] = '00';              // A32
        end;
    else                                     // Return to AArch64
        // ELR_ELx[63:56] might include a tag
        new_pc = <a href="shared_pseudocode.html#func_AArch64_BranchAddr_2" title="">AArch64_BranchAddr</a>(new_pc, PSTATE.EL);
    end;

    if IsFeatureImplemented(FEAT_BRBE) then
        BRBEExceptionReturn(new_pc, source_el,
                            brbe_source_allowed, brbe_source_address);
    end;

    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        if IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.SM == '1' then ResetSVEState(); end;

        // 32 most significant bits are ignored.
        let branch_conditional : boolean = FALSE;
        BranchTo{32}(new_pc[31:0], <a href="shared_pseudocode.html#enum_BranchType_ERET" title="">BranchType_ERET</a>, branch_conditional);
    else
        BranchToAddr{64}(new_pc, <a href="shared_pseudocode.html#enum_BranchType_ERET" title="">BranchType_ERET</a>);
    end;

    CheckExceptionCatch(FALSE);              // Check for debug event on exception return
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.exclusive.AArch64_ExclusiveMonitorsPass"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/exclusive/AArch64_ExclusiveMonitorsPass</h3>
      <p class="pseudocode">// AArch64_ExclusiveMonitorsPass()
// ===============================
// Return TRUE if the Exclusives monitors for the current PE include all of the addresses
// associated with the virtual address region of size bytes starting at address.
// The immediately following memory write must be to the same addresses.

// It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
// before or after the check on the local Exclusives monitor. As a result a failure
// of the local monitor can occur on some implementations even if the memory
// access would give an memory abort.

func <a id="func_AArch64_ExclusiveMonitorsPass_3"/>AArch64_ExclusiveMonitorsPass(address : bits(64), size : integer{1, 2, 4, 8, 16, 32},
                                   accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    let aligned : boolean = IsAlignedSize(address, size);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_UnalignedAccessFaults_3" title="">AArch64_UnalignedAccessFaults</a>(accdesc, address, size) then
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, address);
        AArch64_Abort(fault);
    end;

    if !<a href="shared_pseudocode.html#func_AArch64_IsExclusiveVA_3" title="">AArch64_IsExclusiveVA</a>(address, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), size) then
        return FALSE;
    end;

    let memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        AArch64_Abort(memaddrdesc.fault);
    end;

    var passed : boolean = <a href="shared_pseudocode.html#func_IsExclusiveLocal_3" title="">IsExclusiveLocal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), size);
    ClearExclusiveLocal(<a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>());

    if passed &amp;&amp; memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> then
        passed = <a href="shared_pseudocode.html#func_IsExclusiveGlobal_3" title="">IsExclusiveGlobal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), size);
    end;

    return passed;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.exclusive.AArch64_IsExclusiveVA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/exclusive/AArch64_IsExclusiveVA</h3>
      <p class="pseudocode">// AArch64_IsExclusiveVA()
// =======================
// An optional IMPLEMENTATION DEFINED test for an exclusive access to a virtual
// address region of size bytes starting at address.
//
// It is permitted (but not required) for this function to return FALSE and
// cause a store exclusive to fail if the virtual address region is not
// totally included within the region recorded by MarkExclusiveVA().
//
// It is always safe to return TRUE which will check the physical address only.

impdef func <a id="func_AArch64_IsExclusiveVA_3"/>AArch64_IsExclusiveVA(address : bits(64),
                                  processorid : integer,
                                  size : integer) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.exclusive.AArch64_MarkExclusiveVA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/exclusive/AArch64_MarkExclusiveVA</h3>
      <p class="pseudocode">// AArch64_MarkExclusiveVA()
// =========================
// Optionally record an exclusive access to the virtual address region of size bytes
// starting at address for processorid.

func AArch64_MarkExclusiveVA(address : bits(64), processorid : integer, size : integer)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.exclusive.AArch64_SetExclusiveMonitors"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/exclusive/AArch64_SetExclusiveMonitors</h3>
      <p class="pseudocode">// AArch64_SetExclusiveMonitors()
// ==============================
// Sets the Exclusives monitors for the current PE to record the addresses associated
// with the virtual address region of size bytes starting at address.

func AArch64_SetExclusiveMonitors(address : bits(64), size : integer{1, 2, 4, 8, 16, 32},
                                  accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>)
begin
    let aligned : boolean = IsAlignedSize(address, size);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_UnalignedAccessFaults_3" title="">AArch64_UnalignedAccessFaults</a>(accdesc, address, size) then
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, address);
        AArch64_Abort(fault);
    end;

    let memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(address, accdesc, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        return;
    end;

    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> then
        MarkExclusiveGlobal(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), size);
    end;

    MarkExclusiveLocal(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), size);

    AArch64_MarkExclusiveVA(address, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), size);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.extendreg.DecodeRegExtend"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/extendreg/DecodeRegExtend</h3>
      <p class="pseudocode">// DecodeRegExtend()
// =================
// Decode a register extension option

func <a id="func_DecodeRegExtend_1"/>DecodeRegExtend(op : bits(3)) =&gt; <a href="shared_pseudocode.html#type_ExtendType" title="">ExtendType</a>
begin
    case op of
        when '000' =&gt; return <a href="shared_pseudocode.html#enum_ExtendType_UXTB" title="">ExtendType_UXTB</a>;
        when '001' =&gt; return <a href="shared_pseudocode.html#enum_ExtendType_UXTH" title="">ExtendType_UXTH</a>;
        when '010' =&gt; return <a href="shared_pseudocode.html#enum_ExtendType_UXTW" title="">ExtendType_UXTW</a>;
        when '011' =&gt; return <a href="shared_pseudocode.html#enum_ExtendType_UXTX" title="">ExtendType_UXTX</a>;
        when '100' =&gt; return <a href="shared_pseudocode.html#enum_ExtendType_SXTB" title="">ExtendType_SXTB</a>;
        when '101' =&gt; return <a href="shared_pseudocode.html#enum_ExtendType_SXTH" title="">ExtendType_SXTH</a>;
        when '110' =&gt; return <a href="shared_pseudocode.html#enum_ExtendType_SXTW" title="">ExtendType_SXTW</a>;
        when '111' =&gt; return <a href="shared_pseudocode.html#enum_ExtendType_SXTX" title="">ExtendType_SXTX</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.extendreg.ExtendReg"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/extendreg/ExtendReg</h3>
      <p class="pseudocode">// ExtendReg()
// ===========
// Perform a register extension and shift

func ExtendReg{N}(reg : integer, exttype : ExtendType, shift : integer{0..4}) =&gt; bits(N)
begin
    let val : bits(N) = X{}(reg);
    var unsigned : boolean;
    var len : <a href="shared_pseudocode.html#ESize" title="type ESize">ESize</a>;

    case exttype of
        when ExtendType_SXTB =&gt; unsigned = FALSE; len = 8;
        when ExtendType_SXTH =&gt; unsigned = FALSE; len = 16;
        when ExtendType_SXTW =&gt; unsigned = FALSE; len = 32;
        when ExtendType_SXTX =&gt; unsigned = FALSE; len = 64;
        when ExtendType_UXTB =&gt; unsigned = TRUE;  len = 8;
        when ExtendType_UXTH =&gt; unsigned = TRUE;  len = 16;
        when ExtendType_UXTW =&gt; unsigned = TRUE;  len = 32;
        when ExtendType_UXTX =&gt; unsigned = TRUE;  len = 64;
    end;

    // Sign or zero extend bottom LEN bits of register and shift left by SHIFT
    let nbits : integer{} = Min(len, N) as integer{8..N};
    let extval : bits(N) = Extend{}(val[nbits-1:0], unsigned);
    return LSL(extval, shift);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.extendreg.ExtendType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/extendreg/ExtendType</h3>
      <p class="pseudocode">// ExtendType
// ==========
// AArch64 register extend and shift.

type <a id="type_ExtendType"/>ExtendType of enumeration {<a id="enum_ExtendType_SXTB"/>ExtendType_SXTB, <a id="enum_ExtendType_SXTH"/>ExtendType_SXTH, <a id="enum_ExtendType_SXTW"/>ExtendType_SXTW, <a id="enum_ExtendType_SXTX"/>ExtendType_SXTX,
                                <a id="enum_ExtendType_UXTB"/>ExtendType_UXTB, <a id="enum_ExtendType_UXTH"/>ExtendType_UXTH, <a id="enum_ExtendType_UXTW"/>ExtendType_UXTW, <a id="enum_ExtendType_UXTX"/>ExtendType_UXTX};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.fpconvop.FPConvOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/fpconvop/FPConvOp</h3>
      <p class="pseudocode">// FPConvOp
// ========
// Floating-point convert/move instruction types.

type <a id="type_FPConvOp"/>FPConvOp of enumeration {<a id="enum_FPConvOp_CVT_FtoI"/>FPConvOp_CVT_FtoI, <a id="enum_FPConvOp_CVT_ItoF"/>FPConvOp_CVT_ItoF,
                              <a id="enum_FPConvOp_MOV_FtoI"/>FPConvOp_MOV_FtoI, <a id="enum_FPConvOp_MOV_ItoF"/>FPConvOp_MOV_ItoF,
                              <a id="enum_FPConvOp_CVT_FtoI_JS"/>FPConvOp_CVT_FtoI_JS
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.fpmaxminop.FPMaxMinOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/fpmaxminop/FPMaxMinOp</h3>
      <p class="pseudocode">// FPMaxMinOp
// ==========
// Floating-point min/max instruction types.

type <a id="type_FPMaxMinOp"/>FPMaxMinOp of enumeration {<a id="enum_FPMaxMinOp_MAX"/>FPMaxMinOp_MAX, <a id="enum_FPMaxMinOp_MIN"/>FPMaxMinOp_MIN,
                                <a id="enum_FPMaxMinOp_MAXNUM"/>FPMaxMinOp_MAXNUM, <a id="enum_FPMaxMinOp_MINNUM"/>FPMaxMinOp_MINNUM};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.fpmr.CheckFPMREnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/fpmr/CheckFPMREnabled</h3>
      <p class="pseudocode">// CheckFPMREnabled()
// ==================
// Check for Undefined instruction exception on indirect FPMR accesses.

func CheckFPMREnabled()
begin
    assert IsFeatureImplemented(FEAT_FPMR);

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        if !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
            if SCTLR_EL1().EnFPM == '0' then Undefined(); end;
        else
            if SCTLR_EL2().EnFPM == '0' then Undefined(); end;
        end;
    end;

    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        if !<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().EnFPM == '0' then Undefined(); end;
    end;

    if PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if SCR_EL3().EnFPM == '0' then Undefined(); end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.fpscale.FPScale"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/fpscale/FPScale</h3>
      <p class="pseudocode">// FPScale()
// =========

func <a id="func_FPScale_4"/>FPScale{N}(op : bits(N), scale : integer, fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var result : bits(N);
    let (fptype,sign,value) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op, fpcr);

    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#func_FPProcessNaN_4" title="">FPProcessNaN</a>{N}(fptype, op, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign);
    else
        result = <a href="shared_pseudocode.html#func_FPRound_3" title="">FPRound</a>{N}(value * (2.0^scale), fpcr);
        FPProcessDenorm(fptype, N, fpcr);
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.fpunaryop.FPUnaryOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/fpunaryop/FPUnaryOp</h3>
      <p class="pseudocode">// FPUnaryOp
// =========
// Floating-point unary instruction types.

type <a id="type_FPUnaryOp"/>FPUnaryOp of enumeration {<a id="enum_FPUnaryOp_ABS"/>FPUnaryOp_ABS, <a id="enum_FPUnaryOp_MOV"/>FPUnaryOp_MOV,
                               <a id="enum_FPUnaryOp_NEG"/>FPUnaryOp_NEG, <a id="enum_FPUnaryOp_SQRT"/>FPUnaryOp_SQRT};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.fusedrstep.FPRSqrtStepFused"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/fusedrstep/FPRSqrtStepFused</h3>
      <p class="pseudocode">// FPRSqrtStepFused()
// ==================

func <a id="func_FPRSqrtStepFused_4"/>FPRSqrtStepFused{N}(op1_in : bits(N), op2 : bits(N), fpcr_in : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16, 32, 64};
    var fpcr : FPCR_Type = fpcr_in;
    var result : bits(N);
    var op1 : bits(N) = op1_in;
    var done : boolean;
    op1 = <a href="shared_pseudocode.html#func_FPNeg_3" title="">FPNeg</a>{N}(op1, fpcr);
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; fpcr.AH == '1';
    let fpexc : boolean = !altfp;                    // Generate no floating-point exceptions
    if altfp then fpcr.[FIZ,FZ] = '11'; end;         // Flush denormal input and output to zero
    if altfp then fpcr.RMode = '00'; end;            // Use RNE rounding mode

    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op1, fpcr, fpexc);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op2, fpcr, fpexc);
    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_7" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr, fpexc);
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);

    if !done then
        let inf1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#func_FPOnePointFive_2" title="">FPOnePointFive</a>{N}('0');
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign1 XOR sign2);
        else
            // Fully fused multiply-add and halve
            let result_value : real = (3.0 + (value1 * value2)) / 2.0;
            if result_value == 0.0 then
                // Sign of exact zero result depends on rounding mode
                let sign : bit = if rounding == <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
            else
                result = <a href="shared_pseudocode.html#func_FPRound_5" title="">FPRound</a>{N}(result_value, fpcr, rounding, fpexc);
            end;
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.fusedrstep.FPRecipStepFused"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/fusedrstep/FPRecipStepFused</h3>
      <p class="pseudocode">// FPRecipStepFused()
// ==================

func <a id="func_FPRecipStepFused_4"/>FPRecipStepFused{N}(op1_in : bits(N), op2 : bits(N), fpcr_in : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16, 32, 64};
    var fpcr : FPCR_Type = fpcr_in;
    var op1 : bits(N)    = op1_in;
    var result : bits(N);
    var done : boolean;
    op1 = <a href="shared_pseudocode.html#func_FPNeg_3" title="">FPNeg</a>{N}(op1, fpcr);

    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; fpcr.AH == '1';
    let fpexc : boolean = !altfp;                    // Generate no floating-point exceptions
    if altfp then fpcr.[FIZ,FZ] = '11'; end;         // Flush denormal input and output to zero
    if altfp then fpcr.RMode    = '00'; end;         // Use RNE rounding mode

    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op1, fpcr, fpexc);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op2, fpcr, fpexc);
    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_7" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr, fpexc);
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);

    if !done then
        let inf1 : boolean  = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2 : boolean  = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#func_FPTwo_2" title="">FPTwo</a>{N}('0');
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign1 XOR sign2);
        else
            // Fully fused multiply-add
            let result_value : real = 2.0 + (value1 * value2);
            if result_value == 0.0 then
                // Sign of exact zero result depends on rounding mode
                let sign : bit = if rounding == <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
            else
                result = <a href="shared_pseudocode.html#func_FPRound_5" title="">FPRound</a>{N}(result_value, fpcr, rounding, fpexc);
            end;
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.AddGCSExRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/AddGCSExRecord</h3>
      <p class="pseudocode">// AddGCSExRecord()
// ================
// Generates and then writes an exception record to the
// current Guarded control stack.

func AddGCSExRecord(elr : bits(64), spsr : bits(64), lr : bits(64))
begin
    var ptr : bits(64);
    let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescGCS(MemOp_STORE, privileged);

    ptr = <a href="shared_pseudocode.html#func_GetCurrentGCSPointer_0" title="">GetCurrentGCSPointer</a>();

    // Store the record
    <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr-8, accdesc) = lr;
    <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr-16, accdesc) = spsr;
    <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr-24, accdesc) = elr;
    <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr-32, accdesc) = Zeros{60}::'1001';

    // Decrement the pointer value
    ptr = ptr - 32;

    SetCurrentGCSPointer(ptr);
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.AddGCSRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/AddGCSRecord</h3>
      <p class="pseudocode">// AddGCSRecord()
// ==============
// Generates and then writes a record to the current Guarded
// control stack.

func AddGCSRecord(vaddress : bits(64))
begin
    var ptr : bits(64);
    let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescGCS(MemOp_STORE, privileged);

    ptr = <a href="shared_pseudocode.html#func_GetCurrentGCSPointer_0" title="">GetCurrentGCSPointer</a>();

    // Store the record
    <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr-8, accdesc) = vaddress;

    // Decrement the pointer value
    ptr = ptr - 8;

    SetCurrentGCSPointer(ptr);
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.CheckGCSExRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/CheckGCSExRecord</h3>
      <p class="pseudocode">// CheckGCSExRecord()
// ==================
// Validates the provided values against the top entry of the
// current Guarded control stack.

func CheckGCSExRecord(elr : bits(64), spsr : bits(64), lr : bits(64), gcsinst_type : <a href="shared_pseudocode.html#type_GCSInstruction" title="">GCSInstruction</a>)
begin
    var ptr : bits(64);
    let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescGCS(MemOp_LOAD, privileged);
    ptr = <a href="shared_pseudocode.html#func_GetCurrentGCSPointer_0" title="">GetCurrentGCSPointer</a>();

    // Check the lowest doubleword is correctly formatted
    let recorded_first_dword : bits(64) = <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr, accdesc);
    if recorded_first_dword != Zeros{60}::'1001' then
        GCSDataCheckException(gcsinst_type);
    end;

    // Check the ELR matches the recorded value
    let recorded_elr : bits(64) = <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr+8, accdesc);
    if recorded_elr != elr then
        GCSDataCheckException(gcsinst_type);
    end;

    // Check the SPSR matches the recorded value
    let recorded_spsr : bits(64) = <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr+16, accdesc);
    if recorded_spsr != spsr then
        GCSDataCheckException(gcsinst_type);
    end;

    // Check the LR matches the recorded value
    let recorded_lr : bits(64) = <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr+24, accdesc);
    if recorded_lr != lr then
        GCSDataCheckException(gcsinst_type);
    end;

    // Increment the pointer value
    ptr = ptr + 32;

    SetCurrentGCSPointer(ptr);
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.CheckGCSSTREnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/CheckGCSSTREnabled</h3>
      <p class="pseudocode">// CheckGCSSTREnabled()
// ====================
// Trap GCSSTR or GCSSTTR instruction if trapping is enabled.

func CheckGCSSTREnabled()
begin
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            if GCSCRE0_EL1().STREn == '0' then
                if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then
                    GCSSTRTrapException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
                else
                    GCSSTRTrapException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
                end;
            end;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            if GCSCR_EL1().STREn == '0' then
                GCSSTRTrapException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
            elsif (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || SCR_EL3().FGTEn == '1') &amp;&amp;
                    HFGITR_EL2().nGCSSTR_EL1 == '0') then
                GCSSTRTrapException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
            end;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            if GCSCR_EL2().STREn == '0' then
                GCSSTRTrapException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
            end;
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            if GCSCR_EL3().STREn == '0' then
                GCSSTRTrapException(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
            end;
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.EXLOCKException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/EXLOCKException</h3>
      <p class="pseudocode">// EXLOCKException()
// =================
// Handle an EXLOCK exception condition.

func EXLOCKException()
begin
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_GCSFail" title="">Exception_GCSFail</a>);
    except.syndrome.iss[24] = '0';
    except.syndrome.iss[23:20] = '0001';
    except.syndrome.iss[19:0] = Zeros{20};
    AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSDataCheckException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSDataCheckException</h3>
      <p class="pseudocode">// GCSDataCheckException()
// =======================
// Handle a Guarded Control Stack data check fault condition.

func GCSDataCheckException(gcsinst_type : <a href="shared_pseudocode.html#type_GCSInstruction" title="">GCSInstruction</a>)
begin
    var target_el : bits(2);
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;
    var rn_unknown : boolean  = FALSE;
    var is_ret : boolean      = FALSE;
    var is_reta : boolean     = FALSE;

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        target_el = if (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1') then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    else
        target_el = PSTATE.EL;
    end;
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_GCSFail" title="">Exception_GCSFail</a>);
    case gcsinst_type of
        when <a href="shared_pseudocode.html#enum_GCSInstType_PRET" title="">GCSInstType_PRET</a> =&gt;
            except.syndrome.iss[4:0] = '00000';
            is_ret = TRUE;
        when <a href="shared_pseudocode.html#enum_GCSInstType_POPM" title="">GCSInstType_POPM</a> =&gt;
            except.syndrome.iss[4:0] = '00001';
        when <a href="shared_pseudocode.html#enum_GCSInstType_PRETAA" title="">GCSInstType_PRETAA</a> =&gt;
            except.syndrome.iss[4:0] = '00010';
            is_reta = TRUE;
        when <a href="shared_pseudocode.html#enum_GCSInstType_PRETAB" title="">GCSInstType_PRETAB</a> =&gt;
            except.syndrome.iss[4:0] = '00011';
            is_reta = TRUE;
        when <a href="shared_pseudocode.html#enum_GCSInstType_SS1" title="">GCSInstType_SS1</a> =&gt;
            except.syndrome.iss[4:0] = '00100';
        when <a href="shared_pseudocode.html#enum_GCSInstType_SS2" title="">GCSInstType_SS2</a> =&gt;
            except.syndrome.iss[4:0] = '00101';
            rn_unknown = TRUE;
        when <a href="shared_pseudocode.html#enum_GCSInstType_POPCX" title="">GCSInstType_POPCX</a> =&gt;
            rn_unknown = TRUE;
            except.syndrome.iss[4:0] = '01000';
        when <a href="shared_pseudocode.html#enum_GCSInstType_POPX" title="">GCSInstType_POPX</a> =&gt;
            except.syndrome.iss[4:0] = '01001';
    end;
    if rn_unknown == TRUE then
        except.syndrome.iss[9:5] = ARBITRARY : bits(5);
    elsif is_ret == TRUE then
        except.syndrome.iss[9:5] = <a href="shared_pseudocode.html#func_ThisInstr_0" title="">ThisInstr</a>()[9:5];
    elsif is_reta == TRUE then
        except.syndrome.iss[9:5] = '11110';
    else
        except.syndrome.iss[9:5] = <a href="shared_pseudocode.html#func_ThisInstr_0" title="">ThisInstr</a>()[4:0];
    end;
    except.syndrome.iss[24:10] = Zeros{15};
    except.vaddress = ARBITRARY : bits(64);
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSEnabled</h3>
      <p class="pseudocode">// GCSEnabled()
// ============
// Returns TRUE if the Guarded control stack is enabled at
// the provided Exception level.

func <a id="func_GCSEnabled_1"/>GCSEnabled(el : bits(2)) =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        return FALSE;
    end;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; el != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; SCR_EL3().GCSEn == '0' then
        return FALSE;
    end;

    if (el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) &amp;&amp;
        (!<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().GCSEn == '0')) then
        return FALSE;
    end;

    return <a href="shared_pseudocode.html#func_GCSPCRSelected_1" title="">GCSPCRSelected</a>(el);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSInstruction"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSInstruction</h3>
      <p class="pseudocode">// GCSInstruction
// ==============

type <a id="type_GCSInstruction"/>GCSInstruction of enumeration {
    <a id="enum_GCSInstType_PRET"/>GCSInstType_PRET,    // Procedure return without Pointer authentication
    <a id="enum_GCSInstType_POPM"/>GCSInstType_POPM,    // GCSPOPM instruction
    <a id="enum_GCSInstType_PRETAA"/>GCSInstType_PRETAA,  // Procedure return with Pointer authentication that used key A
    <a id="enum_GCSInstType_PRETAB"/>GCSInstType_PRETAB,  // Procedure return with Pointer authentication that used key B
    <a id="enum_GCSInstType_SS1"/>GCSInstType_SS1,     // GCSSS1 instruction
    <a id="enum_GCSInstType_SS2"/>GCSInstType_SS2,     // GCSSS2 instruction
    <a id="enum_GCSInstType_POPCX"/>GCSInstType_POPCX,   // GCSPOPCX instruction
    <a id="enum_GCSInstType_POPX"/>GCSInstType_POPX     // GCSPOPX instruction
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSPCREnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSPCREnabled</h3>
      <p class="pseudocode">// GCSPCREnabled()
// ===============
// Returns TRUE if the Guarded control stack is PCR enabled
// at the provided Exception level.

func <a id="func_GCSPCREnabled_1"/>GCSPCREnabled(el : bits(2)) =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_GCSPCRSelected_1" title="">GCSPCRSelected</a>(el) &amp;&amp; <a href="shared_pseudocode.html#func_GCSEnabled_1" title="">GCSEnabled</a>(el);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSPCRSelected"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSPCRSelected</h3>
      <p class="pseudocode">// GCSPCRSelected()
// ================
// Returns TRUE if the Guarded control stack is PCR selected
// at the provided Exception level.

func <a id="func_GCSPCRSelected_1"/>GCSPCRSelected(el : bits(2)) =&gt; boolean
begin
    case el of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt; return GCSCRE0_EL1().PCRSEL == '1';
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; return GCSCR_EL1().PCRSEL == '1';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; return GCSCR_EL2().PCRSEL == '1';
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; return GCSCR_EL3().PCRSEL == '1';
    end;
    unreachable;
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSPOPCX"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSPOPCX</h3>
      <p class="pseudocode">// GCSPOPCX()
// ==========
// Called to pop and compare a Guarded control stack exception return record.

func GCSPOPCX()
begin
    let spsr : bits(64) = <a href="shared_pseudocode.html#accessor_SPSR_ELx_0" title="">SPSR_ELx</a>();
    CheckGCSExRecord(<a href="shared_pseudocode.html#accessor_ELR_ELx_0" title="">ELR_ELx</a>(), spsr, <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(30), <a href="shared_pseudocode.html#enum_GCSInstType_POPCX" title="">GCSInstType_POPCX</a>);
    PSTATE.EXLOCK = if <a href="shared_pseudocode.html#func_GetCurrentEXLOCKEN_0" title="">GetCurrentEXLOCKEN</a>() then '1' else '0';
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSPOPM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSPOPM</h3>
      <p class="pseudocode">// GCSPOPM()
// =========
// Called to pop a Guarded control stack procedure return record.

func <a id="func_GCSPOPM_0"/>GCSPOPM() =&gt; bits(64)
begin
    var ptr : bits(64);
    let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescGCS(MemOp_LOAD, privileged);

    ptr = <a href="shared_pseudocode.html#func_GetCurrentGCSPointer_0" title="">GetCurrentGCSPointer</a>();
    let gcs_entry : bits(64) = <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr, accdesc);

    if gcs_entry[1:0] != '00' then
        GCSDataCheckException(<a href="shared_pseudocode.html#enum_GCSInstType_POPM" title="">GCSInstType_POPM</a>);
    end;

    ptr = ptr + 8;
    SetCurrentGCSPointer(ptr);
    return gcs_entry;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSPOPX"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSPOPX</h3>
      <p class="pseudocode">// GCSPOPX()
// =========
// Called to pop a Guarded control stack exception return record.

func GCSPOPX()
begin
    var ptr : bits(64);
    let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescGCS(MemOp_LOAD, privileged);
    ptr = <a href="shared_pseudocode.html#func_GetCurrentGCSPointer_0" title="">GetCurrentGCSPointer</a>();

    // Check the lowest doubleword is correctly formatted
    let recorded_first_dword : bits(64) = <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr, accdesc);
    if recorded_first_dword != Zeros{60}::'1001' then
        GCSDataCheckException(<a href="shared_pseudocode.html#enum_GCSInstType_POPX" title="">GCSInstType_POPX</a>);
    end;

    // Ignore these loaded values, however they might have
    // faulted which is why we load them anyway
    let recorded_elr : bits(64) = <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr+8, accdesc);
    let recorded_spsr : bits(64) = <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr+16, accdesc);
    let recorded_lr : bits(64) = <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr+24, accdesc);

    // Increment the pointer value
    ptr = ptr + 32;

    SetCurrentGCSPointer(ptr);
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSPUSHM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSPUSHM</h3>
      <p class="pseudocode">// GCSPUSHM()
// ==========
// Called to push a Guarded control stack procedure return record.

func GCSPUSHM(value : bits(64))
begin
    AddGCSRecord(value);
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSPUSHX"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSPUSHX</h3>
      <p class="pseudocode">// GCSPUSHX()
// ==========
// Called to push a Guarded control stack exception return record.

func GCSPUSHX()
begin
    let spsr : bits(64) = <a href="shared_pseudocode.html#accessor_SPSR_ELx_0" title="">SPSR_ELx</a>();
    AddGCSExRecord(<a href="shared_pseudocode.html#accessor_ELR_ELx_0" title="">ELR_ELx</a>(), spsr, <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(30));
    PSTATE.EXLOCK = '0';
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSReturnValueCheckEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSReturnValueCheckEnabled</h3>
      <p class="pseudocode">// GCSReturnValueCheckEnabled()
// ============================
// Returns TRUE if the Guarded control stack has return value
// checking enabled at the current Exception level.

func <a id="func_GCSReturnValueCheckEnabled_1"/>GCSReturnValueCheckEnabled(el : bits(2)) =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        return FALSE;
    end;
    case el of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt; return GCSCRE0_EL1().RVCHKEN == '1';
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; return GCSCR_EL1().RVCHKEN == '1';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; return GCSCR_EL2().RVCHKEN == '1';
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; return GCSCR_EL3().RVCHKEN == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSSS1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSSS1</h3>
      <p class="pseudocode">// GCSSS1()
// ========
// Operational pseudocode for GCSSS1 instruction.

func GCSSS1(incoming_pointer : bits(64))
begin
    var outgoing_pointer, cmpoperand, operand, data : bits(64);
    let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescGCSSS1_1" title="">CreateAccDescGCSSS1</a>(privileged);
    outgoing_pointer = <a href="shared_pseudocode.html#func_GetCurrentGCSPointer_0" title="">GetCurrentGCSPointer</a>();
    // Valid cap entry is expected
    cmpoperand = incoming_pointer[63:12]::'000000000001';
    // In-progress cap entry should be stored if the comparison is successful
    operand = outgoing_pointer[63:3]::'101';

    data = <a href="shared_pseudocode.html#func_MemAtomic_5" title="">MemAtomic</a>{64}(incoming_pointer, cmpoperand, operand, accdesc);
    if data == cmpoperand then
        SetCurrentGCSPointer(incoming_pointer[63:3]::'000');
    else
        GCSDataCheckException(<a href="shared_pseudocode.html#enum_GCSInstType_SS1" title="">GCSInstType_SS1</a>);
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSSS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSSS2</h3>
      <p class="pseudocode">// GCSSS2()
// ========
// Operational pseudocode for GCSSS2 instruction.

func <a id="func_GCSSS2_0"/>GCSSS2() =&gt; bits(64)
begin
    var outgoing_pointer, incoming_pointer, outgoing_value : bits(64);
    let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
    let accdesc_ld : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescGCS(MemOp_LOAD, privileged);
    let accdesc_st : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescGCS(MemOp_STORE, privileged);
    incoming_pointer = <a href="shared_pseudocode.html#func_GetCurrentGCSPointer_0" title="">GetCurrentGCSPointer</a>();
    outgoing_value = <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(incoming_pointer, accdesc_ld);

    if outgoing_value[2:0] == '101' then  //in_progress token
        outgoing_pointer[63:3] = (outgoing_value[63:3]) - 1;
        outgoing_pointer[2:0] = '000';
        outgoing_value = outgoing_pointer[63:12]::'000000000001';
        <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(outgoing_pointer, accdesc_st) = outgoing_value;
        SetCurrentGCSPointer(incoming_pointer + 8);
        GCSSynchronizationBarrier();
    else
        GCSDataCheckException(<a href="shared_pseudocode.html#enum_GCSInstType_SS2" title="">GCSInstType_SS2</a>);
    end;
    return outgoing_pointer;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSSTRTrapException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSSTRTrapException</h3>
      <p class="pseudocode">// GCSSTRTrapException()
// =====================
// Handle a trap on GCSSTR instruction condition.

func GCSSTRTrapException(target_el : bits(2))
begin
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_GCSFail" title="">Exception_GCSFail</a>);
    except.syndrome.iss[24]      = '0';
    except.syndrome.iss[23:20]   = '0010';
    except.syndrome.iss[19:15]   = '00000';
    except.syndrome.iss[14:10]   = <a href="shared_pseudocode.html#func_ThisInstr_0" title="">ThisInstr</a>()[9:5];
    except.syndrome.iss[9:5]     = <a href="shared_pseudocode.html#func_ThisInstr_0" title="">ThisInstr</a>()[4:0];
    except.syndrome.iss[4:0]     = '00000';
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GCSSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GCSSynchronizationBarrier</h3>
      <p class="pseudocode">// GCSSynchronizationBarrier()
// ===========================
// Barrier instruction that synchronizes Guarded Control Stack
// accesses in relation to other load and store accesses

impdef func GCSSynchronizationBarrier()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GetCurrentEXLOCKEN"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GetCurrentEXLOCKEN</h3>
      <p class="pseudocode">// GetCurrentEXLOCKEN()
// ====================

func <a id="func_GetCurrentEXLOCKEN_0"/>GetCurrentEXLOCKEN() =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() || <a href="shared_pseudocode.html#func_Restarting_0" title="">Restarting</a>() then
        return FALSE;
    end;

    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            unreachable;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            return GCSCR_EL1().EXLOCKEN == '1';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            return GCSCR_EL2().EXLOCKEN == '1';
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            return GCSCR_EL3().EXLOCKEN == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.GetCurrentGCSPointer"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/GetCurrentGCSPointer</h3>
      <p class="pseudocode">// GetCurrentGCSPointer()
// ======================
// Returns the value of the current Guarded control stack
// pointer register.

func <a id="func_GetCurrentGCSPointer_0"/>GetCurrentGCSPointer() =&gt; bits(64)
begin
    var ptr : bits(64);

    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            ptr = GCSPR_EL0().PTR::'000';
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            ptr = GCSPR_EL1().PTR::'000';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            ptr = GCSPR_EL2().PTR::'000';
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            ptr = GCSPR_EL3().PTR::'000';
    end;
    return ptr;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.LoadCheckGCSRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/LoadCheckGCSRecord</h3>
      <p class="pseudocode">// LoadCheckGCSRecord()
// ====================
// Validates the provided address against the top entry of the
// current Guarded control stack.

func <a id="func_LoadCheckGCSRecord_2"/>LoadCheckGCSRecord(vaddress : bits(64), gcsinst_type : <a href="shared_pseudocode.html#type_GCSInstruction" title="">GCSInstruction</a>) =&gt; bits(64)
begin
    var ptr : bits(64);
    var recorded_va : bits(64);
    let privileged : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescGCS(MemOp_LOAD, privileged);

    ptr = <a href="shared_pseudocode.html#func_GetCurrentGCSPointer_0" title="">GetCurrentGCSPointer</a>();
    recorded_va = <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(ptr, accdesc);
    if <a href="shared_pseudocode.html#func_GCSReturnValueCheckEnabled_1" title="">GCSReturnValueCheckEnabled</a>(PSTATE.EL) &amp;&amp; (recorded_va != vaddress) then
        GCSDataCheckException(gcsinst_type);
    end;

    return recorded_va;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.gcs.SetCurrentGCSPointer"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/gcs/SetCurrentGCSPointer</h3>
      <p class="pseudocode">// SetCurrentGCSPointer()
// ======================
// Writes a value to the current Guarded control stack pointer register.

func SetCurrentGCSPointer(ptr : bits(64))
begin
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            GCSPR_EL0().PTR = ptr[63:3];
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            GCSPR_EL1().PTR = ptr[63:3];
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            GCSPR_EL2().PTR = ptr[63:3];
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            GCSPR_EL3().PTR = ptr[63:3];
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.hacdbs"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/hacdbs</h3>
      <p class="pseudocode">constant <a id="global_HACDBS_ERR_REASON_STRUCTF"/>HACDBS_ERR_REASON_STRUCTF : bits(2) = '01';

constant <a id="global_HACDBS_ERR_REASON_IPAF"/>HACDBS_ERR_REASON_IPAF : bits(2)    = '10';

constant <a id="global_HACDBS_ERR_REASON_IPHACF"/>HACDBS_ERR_REASON_IPHACF : bits(2)  = '11';</p>
    </div>
    <div class="ps"><a id="aarch64.functions.hacdbs.IsHACDBSIRQAsserted"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/hacdbs/IsHACDBSIRQAsserted</h3>
      <p class="pseudocode">// IsHACDBSIRQAsserted()
// =====================
// Returns TRUE if HACDBSIRQ is asserted, and FALSE otherwise.

impdef func <a id="func_IsHACDBSIRQAsserted_0"/>IsHACDBSIRQAsserted() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.hacdbs.ProcessHACDBSEntry"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/hacdbs/ProcessHACDBSEntry</h3>
      <p class="pseudocode">// ProcessHACDBSEntry()
// ====================
// Process a single entry entry from the HACDBS.

func ProcessHACDBSEntry()
begin
    if !IsFeatureImplemented(FEAT_HACDBS) then return; end;

    if (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().HACDBSEn == '0') || HACDBSBR_EL2().EN == '0' then
        SetInterruptRequestLevel(<a href="shared_pseudocode.html#enum_InterruptID_HACDBSIRQ" title="">InterruptID_HACDBSIRQ</a>, LOW);
        return;
    end;

    if HCR_EL2().VM == '0' then return; end;

    if (UInt(HACDBSCONS_EL2().INDEX) &gt;= (2 ^ (UInt(HACDBSBR_EL2().SZ) + 12)) DIVRM 8 ||
          HACDBSCONS_EL2().ERR_REASON != '00') then
        SetInterruptRequestLevel(<a href="shared_pseudocode.html#enum_InterruptID_HACDBSIRQ" title="">InterruptID_HACDBSIRQ</a>, HIGH);
        return;
    elsif <a href="shared_pseudocode.html#func_IsHACDBSIRQAsserted_0" title="">IsHACDBSIRQAsserted</a>() then
        SetInterruptRequestLevel(<a href="shared_pseudocode.html#enum_InterruptID_HACDBSIRQ" title="">InterruptID_HACDBSIRQ</a>, LOW);
    end;

    let hacdbs_size : integer{} = UInt(HACDBSBR_EL2().SZ);
    var baddr : bits(56) = HACDBSBR_EL2().BADDR[43 : 0] :: Zeros{12};
    baddr[11 + hacdbs_size : 12] = Zeros{hacdbs_size};

    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescHACDBS_0" title="">CreateAccDescHACDBS</a>();

    var addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    addrdesc.paddress.address = baddr + (8 * UInt(HACDBSCONS_EL2().INDEX));
    let nse2 : bit = '0';     // NSE2 has the Effective value of 0 within a PE.
    addrdesc.paddress.paspace = <a href="shared_pseudocode.html#func_DecodePASpace_3" title="">DecodePASpace</a>(nse2, <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NSE_0" title="">EffectiveSCR_EL3_NSE</a>(), <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>());

    // Accesses to the HACDBS use the same memory attributes as used for stage 2 translation walks.
    addrdesc.memattrs = <a href="shared_pseudocode.html#func_WalkMemAttrs_3" title="">WalkMemAttrs</a>(VTCR_EL2().SH0, VTCR_EL2().IRGN0, VTCR_EL2().ORGN0);
    let emec : bit = (if IsFeatureImplemented(FEAT_MEC) &amp;&amp;
                         <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then SCTLR2_EL2().EMEC else '0');
    addrdesc.mecid = <a href="shared_pseudocode.html#func_AArch64_S2TTWalkMECID_2" title="">AArch64_S2TTWalkMECID</a>(emec, accdesc.ss);

    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_1" title="">NoFault</a>(accdesc);

    if IsFeatureImplemented(FEAT_RME) then
        fault.gpcf = <a href="shared_pseudocode.html#func_GranuleProtectionCheck_2" title="">GranuleProtectionCheck</a>(addrdesc, accdesc);

        if fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> then
            HACDBSCONS_EL2().ERR_REASON = <a href="shared_pseudocode.html#global_HACDBS_ERR_REASON_STRUCTF" title="">HACDBS_ERR_REASON_STRUCTF</a>;
            return;
        end;
    end;

    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    var hacdbs_entry : bits(64);
    (memstatus, hacdbs_entry) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{64}(addrdesc, accdesc);

    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
        HACDBSCONS_EL2().ERR_REASON = <a href="shared_pseudocode.html#global_HACDBS_ERR_REASON_STRUCTF" title="">HACDBS_ERR_REASON_STRUCTF</a>;
        return;
    end;

    if <a href="shared_pseudocode.html#func_BigEndian_1" title="">BigEndian</a>(accdesc.acctype) then
        hacdbs_entry = <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{64}(hacdbs_entry);
    end;

    // If the Valid field is clear, do not perform any cleaning operation
    // and increment HACDBSCONS_EL2.INDEX.
    if hacdbs_entry[0] == '0' then
        HACDBSCONS_EL2().INDEX = HACDBSCONS_EL2().INDEX + 1;
        return;
    end;

    accdesc = <a href="shared_pseudocode.html#func_CreateAccDescTTEUpdate_1" title="">CreateAccDescTTEUpdate</a>(accdesc);
    var ipa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    ipa.paddress.address = hacdbs_entry[55:12] :: Zeros{12};

    let nsipa : bit       = hacdbs_entry[11];
    let paspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a> = <a href="shared_pseudocode.html#func_DecodePASpace_3" title="">DecodePASpace</a>(nse2, <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NSE_0" title="">EffectiveSCR_EL3_NSE</a>(), <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>());
    ipa.paddress.paspace = (if accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> &amp;&amp; nsipa == '1' then <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>
                                                                       else paspace);

    let s1aarch64 : boolean = TRUE;
    let walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a> = <a href="shared_pseudocode.html#func_AArch64_GetS2TTWParams_3" title="">AArch64_GetS2TTWParams</a>(accdesc.ss, ipa.paddress.paspace,
                                                             s1aarch64);

    var descpaddr : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    var walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    var descriptor : bits(128);
    if walkparams.d128 == '1' then
        (fault, descpaddr, walkstate, descriptor) = <a href="shared_pseudocode.html#func_AArch64_S2Walk_5" title="">AArch64_S2Walk</a>{128}(fault, ipa, walkparams,
                                                                        accdesc);
    else
        (fault, descpaddr, walkstate, descriptor[63:0]) = <a href="shared_pseudocode.html#func_AArch64_S2Walk_5" title="">AArch64_S2Walk</a>{64}(fault, ipa, walkparams,
                                                                             accdesc);
    end;

    // If the Access flag on the Block or Page descriptor is set to 0, this does not generate
    // an Access flag fault and the PE can still perform the cleaning operation on that descriptor.
    if fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_AccessFlag" title="">Fault_AccessFlag</a> then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
    elsif fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        HACDBSCONS_EL2().ERR_REASON = <a href="shared_pseudocode.html#global_HACDBS_ERR_REASON_IPAF" title="">HACDBS_ERR_REASON_IPAF</a>;
        return;
    end;

    let hacdbs_level : integer = SInt(hacdbs_entry[3:1]);
    if walkstate.level != hacdbs_level || walkstate.contiguous == '1' then
        HACDBSCONS_EL2().ERR_REASON = <a href="shared_pseudocode.html#global_HACDBS_ERR_REASON_IPHACF" title="">HACDBS_ERR_REASON_IPHACF</a>;
        return;
    end;

    // For the purpose of cleaning HACDBS entries, it is not required that HW update of dirty bit
    // is enabled for a descriptor to be qualified as writeable-clean or writeable-dirty.

    // Check if the descriptor is neither writeable-clean nor writeable-dirty.
    if walkparams.s2pie == '1' then
        let perms : <a href="shared_pseudocode.html#type_S2AccessControls" title="">S2AccessControls</a> = <a href="shared_pseudocode.html#func_AArch64_S2ComputePermissions_3" title="">AArch64_S2ComputePermissions</a>(walkstate.permissions,
                                                                       walkparams, accdesc);
        if perms.w == '0' &amp;&amp; perms.w_mmu == '0' then
            HACDBSCONS_EL2().ERR_REASON = <a href="shared_pseudocode.html#global_HACDBS_ERR_REASON_IPHACF" title="">HACDBS_ERR_REASON_IPHACF</a>;
            return;
        end;

    // If DBM is 0, the descriptor is not writeable-clean or writeable-dirty.
    elsif descriptor[51] == '0' then
        HACDBSCONS_EL2().ERR_REASON = <a href="shared_pseudocode.html#global_HACDBS_ERR_REASON_IPHACF" title="">HACDBS_ERR_REASON_IPHACF</a>;
        return;
    end;

    // If the descriptor is writeable-clean, do not perform any cleaning
    // operation and increment HACDBSCONS_EL2.INDEX.
    if descriptor[7] == '0' then
        HACDBSCONS_EL2().INDEX = HACDBSCONS_EL2().INDEX + 1;
        return;
    end;

    var new_descriptor : bits(128) = descriptor;
    new_descriptor[7] = '0';

    let descaccess : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescTTEUpdate_1" title="">CreateAccDescTTEUpdate</a>(accdesc);
    if walkparams.d128 == '1' then
        (fault, -) = <a href="shared_pseudocode.html#func_AArch64_MemSwapTableDesc_7" title="">AArch64_MemSwapTableDesc</a>{128}(fault, descriptor, new_descriptor, walkparams.ee,
                                                   descaccess, descpaddr);
    else
        (fault, -) = <a href="shared_pseudocode.html#func_AArch64_MemSwapTableDesc_7" title="">AArch64_MemSwapTableDesc</a>{64}(fault, descriptor[63:0], new_descriptor[63:0],
                                                  walkparams.ee, descaccess, descpaddr);
    end;

    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        HACDBSCONS_EL2().ERR_REASON = <a href="shared_pseudocode.html#global_HACDBS_ERR_REASON_IPAF" title="">HACDBS_ERR_REASON_IPAF</a>;
    else
        HACDBSCONS_EL2().INDEX = HACDBSCONS_EL2().INDEX + 1;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ic.AArch64_CanTrapIC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ic/AArch64_CanTrapIC</h3>
      <p class="pseudocode">// AArch64_CanTrapIC()
// ===================
// Determines whether the execution of the IC instruction can be trapped.

func <a id="func_AArch64_CanTrapIC_3"/>AArch64_CanTrapIC(cachetype : <a href="shared_pseudocode.html#type_CacheType" title="">CacheType</a>, cacheop : <a href="shared_pseudocode.html#type_CacheOp" title="">CacheOp</a>, opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>) =&gt; boolean
begin
    return (!<a href="shared_pseudocode.html#func_AArch64_TreatICAsNOP_3" title="">AArch64_TreatICAsNOP</a>(cachetype, cacheop, opscope) || ImpDefBool(
            "When IC is treated as NOP, data cache maintenance operations are trapped"));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ic.AArch64_IC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ic/AArch64_IC</h3>
      <p class="pseudocode">// AArch64_IC()
// ============
// Perform Instruction Cache Operation.

func AArch64_IC(opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>)
begin
    let regval : bits(64) = ARBITRARY : bits(64);
    AArch64_IC(regval, opscope);
end;

// AArch64_IC()
// ============
// Perform Instruction Cache Operation.

func AArch64_IC(regval : bits(64), opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>)
begin
    var cache : <a href="shared_pseudocode.html#type_CacheRecord" title="">CacheRecord</a>;

    cache.acctype   = <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>;
    cache.cachetype = <a href="shared_pseudocode.html#enum_CacheType_Instruction" title="">CacheType_Instruction</a>;
    cache.cacheop   = <a href="shared_pseudocode.html#enum_CacheOp_Invalidate" title="">CacheOp_Invalidate</a>;
    cache.opscope   = opscope;

    if opscope IN {<a href="shared_pseudocode.html#enum_CacheOpScope_ALLU" title="">CacheOpScope_ALLU</a>,
                   <a href="shared_pseudocode.html#enum_CacheOpScope_ALLUIS_CnP" title="">CacheOpScope_ALLUIS_CnP</a>,
                   <a href="shared_pseudocode.html#enum_CacheOpScope_ALLUIS" title="">CacheOpScope_ALLUIS</a>} then
        let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(PSTATE.EL);
        cache.cpas = <a href="shared_pseudocode.html#func_CPASAtSecurityState_1" title="">CPASAtSecurityState</a>(ss);

        case opscope of
            when <a href="shared_pseudocode.html#enum_CacheOpScope_ALLU" title="">CacheOpScope_ALLU</a> =&gt;
                cache.shareability = <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a>;
            when <a href="shared_pseudocode.html#enum_CacheOpScope_ALLUIS" title="">CacheOpScope_ALLUIS</a> =&gt;
                cache.shareability = <a href="shared_pseudocode.html#enum_Shareability_ISH" title="">Shareability_ISH</a>;
                // When executed at EL1, if the Effective value of HCRX_EL2.VTLBIDEn is '1',
                // then the operation is broadcast to the set of PEs selected by VTLBID0_EL2.TD0.
                // Otherwise, the operation is broadcast to all PEs in the Shareability domain.
                cache.domains = <a href="shared_pseudocode.html#func_TLBIDomains_2" title="">TLBIDomains</a>(<a href="shared_pseudocode.html#enum_Broadcast_ISH" title="">Broadcast_ISH</a>, Zeros{16});
            when <a href="shared_pseudocode.html#enum_CacheOpScope_ALLUIS_CnP" title="">CacheOpScope_ALLUIS_CnP</a> =&gt;
                cache.shareability = <a href="shared_pseudocode.html#enum_Shareability_ISH" title="">Shareability_ISH</a>;
                cache.domains = <a href="shared_pseudocode.html#global_DEFAULT_TLBI_DOMAIN" title="">DEFAULT_TLBI_DOMAIN</a>;
            otherwise =&gt;
                unreachable;
        end;

        cache.regval = regval;
        CACHE_OP(cache);
    else
        assert opscope == <a href="shared_pseudocode.html#enum_CacheOpScope_PoU" title="">CacheOpScope_PoU</a>;

        if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
            if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} then
                cache.is_vmid_valid = TRUE;
                cache.vmid          = <a href="shared_pseudocode.html#func_VMID_0" title="">VMID</a>();
            else
                cache.is_vmid_valid = FALSE;
            end;
        else
            cache.is_vmid_valid = FALSE;
        end;

        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
            cache.is_asid_valid = TRUE;
            cache.asid          = <a href="shared_pseudocode.html#func_ASID_0" title="">ASID</a>();
        else
            cache.is_asid_valid = FALSE;
        end;

        let vaddress : bits(64) = regval;
        cache.vaddress     = regval;

        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescIC_1" title="">CreateAccDescIC</a>(cache);
        let aligned : boolean = TRUE;
        let size : integer = 0;
        var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(vaddress, accdesc,
                                                                       aligned, size);

        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
            memaddrdesc.fault.vaddress = regval;
            AArch64_Abort(memaddrdesc.fault);
        end;

        cache.cpas         = <a href="shared_pseudocode.html#func_CPASAtPAS_1" title="">CPASAtPAS</a>(memaddrdesc.paddress.paspace);
        cache.paddress     = memaddrdesc.paddress;
        cache.shareability = memaddrdesc.memattrs.shareability;
        if memaddrdesc.memattrs.shareability == <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a> then
            cache.shareability = <a href="shared_pseudocode.html#enum_Shareability_ISH" title="">Shareability_ISH</a>;
        end;
        CACHE_OP(cache);
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ic.AArch64_TreatICAsNOP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ic/AArch64_TreatICAsNOP</h3>
      <p class="pseudocode">// AArch64_TreatICAsNOP()
// ======================
// Determines whether the execution of the IC instruction is treated as a NOP.

func <a id="func_AArch64_TreatICAsNOP_3"/>AArch64_TreatICAsNOP(cachetype : <a href="shared_pseudocode.html#type_CacheType" title="">CacheType</a>, cacheop : <a href="shared_pseudocode.html#type_CacheOp" title="">CacheOp</a>,
                          opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>) =&gt; boolean
begin
    if CTR_EL0().DIC == '1' then
        return ImpDefBool("IC is treated as NOP");
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.immediateop.ImmediateOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/immediateop/ImmediateOp</h3>
      <p class="pseudocode">// ImmediateOp
// ===========
// Vector logical immediate instruction types.

type <a id="type_ImmediateOp"/>ImmediateOp of enumeration {<a id="enum_ImmediateOp_MOVI"/>ImmediateOp_MOVI, <a id="enum_ImmediateOp_MVNI"/>ImmediateOp_MVNI,
                                 <a id="enum_ImmediateOp_ORR"/>ImmediateOp_ORR, <a id="enum_ImmediateOp_BIC"/>ImmediateOp_BIC};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.logicalop.LogicalOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/logicalop/LogicalOp</h3>
      <p class="pseudocode">// LogicalOp
// =========
// Logical instruction types.

type <a id="LogicalOp"/>LogicalOp of enumeration {LogicalOp_AND, LogicalOp_EOR, LogicalOp_ORR};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec</h3>
      <p class="pseudocode">constant <a id="global_DEFAULT_MECID"/>DEFAULT_MECID : bits(16) = Zeros{};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec.AArch64_S1AMECFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec/AArch64_S1AMECFault</h3>
      <p class="pseudocode">// AArch64_S1AMECFault()
// =====================
// Returns TRUE if a Translation fault should occur for Realm EL2 and Realm EL2&amp;0
// stage 1 translated addresses to Realm PA space.

func <a id="func_AArch64_S1AMECFault_5"/>AArch64_S1AMECFault{N}(walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>, paspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                            descriptor : bits(N)) =&gt; boolean
begin
    assert N IN {64,128};
    let descriptor_amec : bit = (if walkparams.d128 == '1' then descriptor[108]
                                    else descriptor[63]);

    return (walkparams.[emec,amec] == '10' &amp;&amp;
            regime IN {<a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>, <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>} &amp;&amp;
            paspace == <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> &amp;&amp;
            descriptor_amec == '1');
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec.AArch64_S1DisabledOutputMECID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec/AArch64_S1DisabledOutputMECID</h3>
      <p class="pseudocode">// AArch64_S1DisabledOutputMECID()
// ===============================
// Returns the output MECID when stage 1 address translation is disabled.

func <a id="func_AArch64_S1DisabledOutputMECID_3"/>AArch64_S1DisabledOutputMECID(walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                                   paspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>) =&gt; bits(16)
begin
    if walkparams.emec == '0' then
        return <a href="shared_pseudocode.html#global_DEFAULT_MECID" title="">DEFAULT_MECID</a>;
    end;

    if ! regime IN {<a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>, <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>, <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>} then
        return <a href="shared_pseudocode.html#global_DEFAULT_MECID" title="">DEFAULT_MECID</a>;
    end;

    if paspace != <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> then
        return <a href="shared_pseudocode.html#global_DEFAULT_MECID" title="">DEFAULT_MECID</a>;
    end;

    if regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> then
        return VMECID_P_EL2().MECID;
    else
        return MECID_P0_EL2().MECID;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec.AArch64_S1OutputMECID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec/AArch64_S1OutputMECID</h3>
      <p class="pseudocode">// AArch64_S1OutputMECID()
// =======================
// Returns the output MECID when stage 1 address translation is enabled.

func <a id="func_AArch64_S1OutputMECID_6"/>AArch64_S1OutputMECID{N}(walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a>,
                              paspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>, descriptor : bits(N)) =&gt; bits(16)
begin
    assert N IN {64,128};

    if walkparams.emec == '0' then
        return <a href="shared_pseudocode.html#global_DEFAULT_MECID" title="">DEFAULT_MECID</a>;
    end;

    if paspace != <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> then
        return <a href="shared_pseudocode.html#global_DEFAULT_MECID" title="">DEFAULT_MECID</a>;
    end;

    let descriptor_amec : bit = (if walkparams.d128 == '1' then descriptor[108]
                                    else descriptor[63]);
    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> =&gt;
            return MECID_RL_A_EL3().MECID;
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;
            if descriptor_amec == '0' then
                return MECID_P0_EL2().MECID;
            else
                return MECID_A0_EL2().MECID;
            end;
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt;
            if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then
                if descriptor_amec == '0' then
                    return MECID_P0_EL2().MECID;
                else
                    return MECID_A0_EL2().MECID;
                end;
            else
                if descriptor_amec == '0' then
                    return MECID_P1_EL2().MECID;
                else
                    return MECID_A1_EL2().MECID;
                end;
            end;
        // Stage 2 translation might later override the MECID according to AMEC configuration.
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;
            return VMECID_P_EL2().MECID;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec.AArch64_S1TTWalkMECID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec/AArch64_S1TTWalkMECID</h3>
      <p class="pseudocode">// AArch64_S1TTWalkMECID()
// =======================
// Returns the associated MECID for the stage 1 translation table walk of the given
// translation regime and Security state.

func <a id="func_AArch64_S1TTWalkMECID_3"/>AArch64_S1TTWalkMECID(emec : bit, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>) =&gt; bits(16)
begin
    if emec == '0' then
        return <a href="shared_pseudocode.html#global_DEFAULT_MECID" title="">DEFAULT_MECID</a>;
    end;

    if ss != <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> then
        return <a href="shared_pseudocode.html#global_DEFAULT_MECID" title="">DEFAULT_MECID</a>;
    end;

    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;
            return MECID_P0_EL2().MECID;
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt;
            if TCR_EL2().A1 == '0' then
                return MECID_P1_EL2().MECID;
            else
                return MECID_P0_EL2().MECID;
            end;
        // Stage 2 translation for a stage 1 walk might later override the
        // MECID according to AMEC configuration.
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;
            return VMECID_P_EL2().MECID;
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec.AArch64_S2OutputMECID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec/AArch64_S2OutputMECID</h3>
      <p class="pseudocode">// AArch64_S2OutputMECID()
// =======================
// Returns the output MECID for stage 2 address translation.

func <a id="func_AArch64_S2OutputMECID_4"/>AArch64_S2OutputMECID{N}(walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>, paspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>,
                              descriptor : bits(N)) =&gt; bits(16)
begin
    assert N IN {64,128};

    if walkparams.emec == '0' then
        return <a href="shared_pseudocode.html#global_DEFAULT_MECID" title="">DEFAULT_MECID</a>;
    end;

    if paspace != <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> then
        return <a href="shared_pseudocode.html#global_DEFAULT_MECID" title="">DEFAULT_MECID</a>;
    end;

    let descriptor_amec : bit = (if walkparams.d128 == '1' then descriptor[108]
                                    else descriptor[63]);
    if descriptor_amec == '0' then
        return VMECID_P_EL2().MECID;
    else
        return VMECID_A_EL2().MECID;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mec.AArch64_S2TTWalkMECID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mec/AArch64_S2TTWalkMECID</h3>
      <p class="pseudocode">// AArch64_S2TTWalkMECID()
// =======================
// Returns the associated MECID for the stage 2 translation table walk of the
// given Security state.

func <a id="func_AArch64_S2TTWalkMECID_2"/>AArch64_S2TTWalkMECID(emec : bit, ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>) =&gt; bits(16)
begin
    if emec == '0' then
        return <a href="shared_pseudocode.html#global_DEFAULT_MECID" title="">DEFAULT_MECID</a>;
    end;

    if ss != <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> then
        return <a href="shared_pseudocode.html#global_DEFAULT_MECID" title="">DEFAULT_MECID</a>;
    end;

    //Stage 2 translation might later override the MECID according to AMEC configuration
    return VMECID_P_EL2().MECID;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_AccessIsTagChecked"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_AccessIsTagChecked</h3>
      <p class="pseudocode">// AArch64_AccessIsTagChecked()
// ============================
// TRUE if a given access is tag-checked, FALSE otherwise.

func <a id="func_AArch64_AccessIsTagChecked_2"/>AArch64_AccessIsTagChecked(vaddr : bits(64), accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    assert accdesc.tagchecked;

    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        return FALSE;
    end;

    if !<a href="shared_pseudocode.html#func_IsMTEEnabled_1" title="">IsMTEEnabled</a>(accdesc.el) then
        return FALSE;
    end;

    if PSTATE.TCO == '1' then
        return FALSE;
    end;

    if (<a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() &amp;&amp; EDSCR().MA == '1' &amp;&amp;
          <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_NODTRTAGCHK" title="">Unpredictable_NODTRTAGCHK</a>)) then
        return FALSE;
    end;

    if (IsFeatureImplemented(FEAT_MTE_STORE_ONLY) &amp;&amp; !accdesc.write &amp;&amp;
          <a href="shared_pseudocode.html#func_StoreOnlyTagCheckingEnabled_1" title="">StoreOnlyTagCheckingEnabled</a>(accdesc.el)) then
        return FALSE;
    end;

    let is_instr : boolean = FALSE;
    if (<a href="shared_pseudocode.html#func_EffectiveMTX_3" title="">EffectiveMTX</a>(vaddr, is_instr, PSTATE.EL) == '0' &amp;&amp;
          <a href="shared_pseudocode.html#func_EffectiveTBI_3" title="">EffectiveTBI</a>(vaddr, is_instr, PSTATE.EL) == '0') then
        return FALSE;
    end;

    if (<a href="shared_pseudocode.html#func_EffectiveTCMA_2" title="">EffectiveTCMA</a>(vaddr, PSTATE.EL) == '1' &amp;&amp;
          (vaddr[59:55] == '00000' || vaddr[59:55] == '11111')) then
        return FALSE;
    end;

    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_AddressWithAllocationTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_AddressWithAllocationTag</h3>
      <p class="pseudocode">// AArch64_AddressWithAllocationTag()
// ==================================
// Generate a 64-bit value containing a Logical Address Tag from a 64-bit
// virtual address and an Allocation Tag.

func <a id="func_AArch64_AddressWithAllocationTag_2"/>AArch64_AddressWithAllocationTag(address : bits(64), allocation_tag : bits(4)) =&gt; bits(64)
begin
    return address[63:60]::allocation_tag::address[55:0];
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_AllocationTagCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_AllocationTagCheck</h3>
      <p class="pseudocode">// AArch64_AllocationTagCheck()
// ============================
// Performs an Allocation Tag Check operation for a memory access and
// returns whether the check passed.

func <a id="func_AArch64_AllocationTagCheck_3"/>AArch64_AllocationTagCheck(memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                ltag : bits(4)) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, memaddrdesc.vaddress);
    if memaddrdesc.memattrs.tags == <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a> then
        var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
        var readtag : bits(4);

        // Physical tagging needs no further translation, use the data PA to read the tag
        (memstatus, readtag) = <a href="shared_pseudocode.html#func_PhysMemTagRead_2" title="">PhysMemTagRead</a>(memaddrdesc, accdesc);
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            let iswrite : boolean = FALSE;
            return <a href="shared_pseudocode.html#func_ExternalFault_5" title="">ExternalFault</a>(memstatus, iswrite, memaddrdesc, 1, accdesc);
        end;

        if ltag != readtag then
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_TagCheck" title="">Fault_TagCheck</a>;
        end;
    end;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_AllocationTagFromAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_AllocationTagFromAddress</h3>
      <p class="pseudocode">// AArch64_AllocationTagFromAddress()
// ==================================
// Generate an Allocation Tag from a 64-bit value containing a Logical Address Tag.

func <a id="func_AArch64_AllocationTagFromAddress_1"/>AArch64_AllocationTagFromAddress(tagged_address : bits(64)) =&gt; bits(4)
begin
    return tagged_address[59:56];
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_CanonicalTagCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_CanonicalTagCheck</h3>
      <p class="pseudocode">// AArch64_CanonicalTagCheck()
// ===========================
// Performs a Canonical Tag Check operation for a memory access and
// returns whether the check passed.

func <a id="func_AArch64_CanonicalTagCheck_2"/>AArch64_CanonicalTagCheck(memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ltag : bits(4)) =&gt; boolean
begin
    let expected_tag : bits(4) = if memaddrdesc.vaddress[55] == '0' then '0000' else '1111';
    return ltag == expected_tag;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_CheckTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_CheckTag</h3>
      <p class="pseudocode">// AArch64_CheckTag()
// ==================
// Performs a Tag Check operation for a memory access and returns a FaultRecord indicating if
// the check passed. If Tag Check Faults are asynchronously accumulated, a Tag Check Fault
// exception is recorded in TFSR_ELx.

func AArch64_CheckTag(memaddrdesc_in : AddressDescriptor, accdesc : AccessDescriptor,
                      size : integer, ltag : bits(4)) =&gt; FaultRecord
begin
    var memaddrdesc : AddressDescriptor = memaddrdesc_in;
    // NoFault() will set fault.write to FALSE to accesses that perform both a read and a write.
    var fault : FaultRecord             = NoFault(accdesc, memaddrdesc.vaddress);
    let granules : integer              = Max(size DIVRM TAG_GRANULE, 1);
    let forcesync : boolean             = accdesc.nonfault || (accdesc.firstfault &amp;&amp;
                                                              !accdesc.first);
    let tcf : <a href="shared_pseudocode.html#TCFType" title="type TCFType">TCFType</a>                   = AArch64_EffectiveTCF(accdesc.el, accdesc.read);

    for i = 0 to granules - 1 do
        case memaddrdesc.memattrs.tags of
            when MemTag_AllocationTagged =&gt;
                fault = AArch64_AllocationTagCheck(memaddrdesc, accdesc, ltag);
                if fault.statuscode == Fault_TagCheck then
                    if tcf == TCFType_Sync || forcesync then
                        fault.statuscode = Fault_TagCheck;
                        return fault;
                    elsif tcf == TCFType_Async then
                        AArch64_ReportTagCheckFault(accdesc.el, memaddrdesc.vaddress[55]);
                        fault.statuscode = Fault_None;
                        return fault;
                    else
                        // Tag Check Faults have no effect on the PE.
                        fault.statuscode = Fault_None;
                    end;
                elsif fault.statuscode != Fault_None then
                    return fault;
                end;
            when MemTag_CanonicallyTagged =&gt;
                if !AArch64_CanonicalTagCheck(memaddrdesc, ltag) then
                    if tcf == TCFType_Sync || forcesync then
                        fault.statuscode = Fault_TagCheck;
                        return fault;
                    elsif tcf == TCFType_Async then
                        AArch64_ReportTagCheckFault(accdesc.el, memaddrdesc.vaddress[55]);
                        return fault;
                    else
                        // Tag Check Faults have no effect on the PE.
                        pass;
                    end;
                end;
            when MemTag_Untagged =&gt;
                pass;
            otherwise =&gt;
                unreachable;
        end;

        memaddrdesc.paddress.address = memaddrdesc.paddress.address + TAG_GRANULE;
        memaddrdesc.vaddress         = memaddrdesc.vaddress + TAG_GRANULE;
    end;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_IsUnprivAccessPriv"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_IsUnprivAccessPriv</h3>
      <p class="pseudocode">// AArch64_IsUnprivAccessPriv()
// ============================
// Returns TRUE if an unprivileged access is privileged, and FALSE otherwise.

func <a id="func_AArch64_IsUnprivAccessPriv_0"/>AArch64_IsUnprivAccessPriv() =&gt; boolean
begin
    var privileged : boolean;

    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            privileged = FALSE;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; privileged = <a href="shared_pseudocode.html#func_EffectiveHCR_EL2_NVx_0" title="">EffectiveHCR_EL2_NVx</a>()[1:0] == '11';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; privileged = !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>);
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            privileged = TRUE;
    end;

    if IsFeatureImplemented(FEAT_UAO) &amp;&amp; PSTATE.UAO == '1' then
        privileged = PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
    end;

    return privileged;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_LogicalAddressTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_LogicalAddressTag</h3>
      <p class="pseudocode">// AArch64_LogicalAddressTag()
// ===========================
// Extract the Logical Address Tag from an address

func <a id="func_AArch64_LogicalAddressTag_1"/>AArch64_LogicalAddressTag(vaddr : bits(64)) =&gt; bits(4)
begin
    return vaddr[59:56];
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_MemSingle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_MemSingle</h3>
      <p class="pseudocode">// AArch64_MemSingle - accessor
// ============================

accessor <a id="accessor_AArch64_MemSingle_4"/>AArch64_MemSingle{size : integer{8, 16, 32, 64, 128, 256}}(address : bits(64),
                                                                    accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                                                    aligned : boolean
                                                                    ) &lt;=&gt; value : bits(size)
begin
    // Perform an atomic, little-endian read of 'size' bits.
    getter
        let bytes : integer{} = size DIV 8;
        var value : bits(size);
        var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
        var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;

        (value, memaddrdesc, memstatus) = <a href="shared_pseudocode.html#func_AArch64_MemSingleRead_4" title="">AArch64_MemSingleRead</a>{size}(address, accdesc, aligned);

        // Check for a fault from translation or the output of translation.
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
            AArch64_Abort(memaddrdesc.fault);
        end;

        // Check for external aborts.
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            HandleExternalAbort(memstatus, accdesc.write, memaddrdesc, bytes, accdesc);
        end;

        return value;
    end;

    // Perform an atomic, little-endian write of 'size' bits.
    setter
        let bytes : integer{} = size DIV 8;
        var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
        var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;

        (memaddrdesc, memstatus) = <a href="shared_pseudocode.html#func_AArch64_MemSingleWrite_5" title="">AArch64_MemSingleWrite</a>{size}(address, accdesc, aligned, value);

        // Check for a fault from translation or the output of translation.
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
            AArch64_Abort(memaddrdesc.fault);
        end;

        // Check for external aborts.
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            HandleExternalWriteAbort(memstatus, memaddrdesc, bytes, accdesc);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_MemSingleRead"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_MemSingleRead</h3>
      <p class="pseudocode">// AArch64_MemSingleRead()
// =======================
// Perform an atomic, little-endian read of 'size' bits.

func <a id="func_AArch64_MemSingleRead_4"/>AArch64_MemSingleRead{size : integer{8, 16, 32, 64, 128, 256}}(address : bits(64),
                                                                    accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                                                    aligned : boolean
                                                                   ) =&gt; (bits(size),
                                                                         <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                                                                         <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>)
begin
    var value : bits(size) = ARBITRARY : bits(size);
    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a> = ARBITRARY : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    let bytes : integer{} = size DIV 8;
    memstatus.statuscode = <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
    if IsFeatureImplemented(FEAT_LSE2) then
        let quantity : integer = <a href="shared_pseudocode.html#func_MemSingleGranule_0" title="">MemSingleGranule</a>();
        assert ((IsFeatureImplemented(FEAT_LS64WB) &amp;&amp;
                   bytes == 32 &amp;&amp; accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a>) ||
                  AllInAlignedQuantity(address, bytes, quantity));
    else
        assert IsAlignedSize(address, bytes);
    end;

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#func_AArch64_AccessIsTagChecked_2" title="">AArch64_AccessIsTagChecked</a>(address, accdesc);
    end;

    var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    memaddrdesc = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(address, accdesc, aligned, bytes);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        return (value, memaddrdesc, memstatus);
    end;

    // Memory array access
    if accdesc.tagchecked then
        let ltag : bits(4) = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(address);
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = AArch64_CheckTag(memaddrdesc, accdesc, bytes, ltag);
        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            memaddrdesc.fault = fault;
            return (value, memaddrdesc, memstatus);
        end;
    end;

    if accdesc.acctype != <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> &amp;&amp; <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> then
        let is_load : boolean = TRUE;
        SPESampleLoadStore(is_load, accdesc, memaddrdesc);
    end;
    var atomic : boolean;
    if <a href="shared_pseudocode.html#func_IsWBShareable_1" title="">IsWBShareable</a>(memaddrdesc.memattrs) then
        atomic = TRUE;
    elsif accdesc.exclusive then
        atomic = TRUE;
    elsif (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_SVE" title="">AccessType_SVE</a> &amp;&amp; accdesc.predicated &amp;&amp;
            bytes == 8 &amp;&amp; IsAlignedSize(address, 8)) then
        // An SVE predicated load of a 128-bit element that is 64-bit aligned
        // is treated as a pair of 64-bit single-copy atomic accesses.
        // This is one of the 64-bit single-copy atomic access.
        atomic = TRUE;
    elsif aligned then
        atomic = !accdesc.ispair;
    else
        // Misaligned accesses within MemSingleGranule() byte aligned memory but
        // not Normal Cacheable Writeback are Atomic
        atomic = ImpDefBool("FEAT_LSE2: access is atomic");
    end;

    if atomic then
        (memstatus, value) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{size}(memaddrdesc, accdesc);

    elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a> &amp;&amp; bytes == 32 &amp;&amp; accdesc.ispair then
        // A 32 byte LDP (SIMD&amp;FP) that does not target Normal Inner Write-Back, Outer
        // Write-Back cacheable, Shareable memory is treated as four 8 byte atomic accesses.
        // As this access was not split in Mem(), it must be aligned to 32 bytes.
        assert IsAlignedSize(address, 32);
        accdesc.ispair = FALSE;
        for i = 0 to 3 do
            if !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then     // Do not continue past a fault
                (memstatus, value[i*64+:64]) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{64}(memaddrdesc, accdesc);
            end;

            if !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
                memaddrdesc.paddress.address = memaddrdesc.paddress.address + 8;
                memaddrdesc.vaddress         = memaddrdesc.vaddress + 8;
            end;
        end;

    elsif aligned &amp;&amp; accdesc.ispair then
        let half : integer{} = (size DIV 2) as integer{32, 64, 128};
        (memstatus, value[0*:half]) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{half}(memaddrdesc, accdesc);

        if !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + (bytes DIV 2);
            memaddrdesc.vaddress         = memaddrdesc.vaddress + (bytes DIV 2);
            (memstatus, value[1*:half]) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{half}(memaddrdesc, accdesc);
        end;

    else
        for i = 0 to bytes-1 do
            if !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then     // Do not continue past a fault
                (memstatus, value[i*:8]) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{8}(memaddrdesc, accdesc);
            end;

            if !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
                memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
                memaddrdesc.vaddress         = memaddrdesc.vaddress + 1;
            end;

        end;
    end;

    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
        return (value, memaddrdesc, memstatus);
    end;

    if accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> then
        memaddrdesc.fault = <a href="shared_pseudocode.html#func_AArch64_CheckDebug_3" title="">AArch64_CheckDebug</a>(address, accdesc, bytes);
    end;

    return (value, memaddrdesc, memstatus);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_MemSingleWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_MemSingleWrite</h3>
      <p class="pseudocode">// AArch64_MemSingleWrite()
// ========================
// Perform an atomic, little-endian write of 'size' bits.

func <a id="func_AArch64_MemSingleWrite_5"/>AArch64_MemSingleWrite{size : integer{8, 16, 32, 64, 128, 256}}(address : bits(64),
                                                                     accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                                                     aligned : boolean,
                                                                     value : bits(size)
                                                         ) =&gt; (<a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>)
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
    let bytes : integer{} = size DIV 8;
    if IsFeatureImplemented(FEAT_LSE2) then
        let quantity : integer = <a href="shared_pseudocode.html#func_MemSingleGranule_0" title="">MemSingleGranule</a>();
        assert ((IsFeatureImplemented(FEAT_LS64WB) &amp;&amp;
                 bytes == 32 &amp;&amp; accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a>) ||
                 AllInAlignedQuantity(address, bytes, quantity));
    else
        assert IsAlignedSize(address, bytes);
    end;

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#func_AArch64_AccessIsTagChecked_2" title="">AArch64_AccessIsTagChecked</a>(address, accdesc);
    end;

    var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a> = ARBITRARY : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    memaddrdesc = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(address, accdesc, aligned, bytes);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        return (memaddrdesc, memstatus);
    end;

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> then
        ClearExclusiveByAddress(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), bytes);
    end;

    if accdesc.tagchecked then
        let ltag : bits(4) = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(address);
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = AArch64_CheckTag(memaddrdesc, accdesc, bytes, ltag);
        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            memaddrdesc.fault = fault;
            return (memaddrdesc, memstatus);
        end;
    end;

    if <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> then
        let is_load : boolean = FALSE;
        SPESampleLoadStore(is_load, accdesc, memaddrdesc);
    end;

    var atomic : boolean;
    if <a href="shared_pseudocode.html#func_IsWBShareable_1" title="">IsWBShareable</a>(memaddrdesc.memattrs) then
        atomic = TRUE;
    elsif accdesc.exclusive then
        atomic = TRUE;
    elsif (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_SVE" title="">AccessType_SVE</a> &amp;&amp; accdesc.predicated &amp;&amp;
            bytes == 8 &amp;&amp; IsAlignedSize(address, 8)) then
        // An SVE predicated load of a 128-bit element that is 64-bit aligned
        // is treated as a pair of 64-bit single-copy atomic accesses.
        // This is one of the 64-bit single-copy atomic access.
        atomic = TRUE;
    elsif aligned then
        atomic = !accdesc.ispair;
    else
        // Misaligned accesses within MemSingleGranule() byte aligned memory but
        // not Normal Cacheable Writeback are Atomic
        atomic = ImpDefBool("FEAT_LSE2: access is atomic");
    end;
    if atomic then
        memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{size}(memaddrdesc, accdesc, value);
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            return (memaddrdesc, memstatus);
        end;

    elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a> &amp;&amp; bytes == 32 &amp;&amp; accdesc.ispair then
        // A 32 byte STP (SIMD&amp;FP) that does not target Normal Inner Write-Back, Outer
        // Write-Back cacheable, Shareable memory is treated as four 8 byte atomic accesses.
        // As this access was not split in Mem(), it must be aligned to 32 bytes.
        assert IsAlignedSize(address, 32);
        accdesc.ispair = FALSE;
        for i = 0 to 3 do
            memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{64}(memaddrdesc, accdesc, value[64*i+:64]);
            if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
                return (memaddrdesc, memstatus);
            end;
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + 8;
            memaddrdesc.vaddress         = memaddrdesc.vaddress + 8;
        end;

    elsif aligned &amp;&amp; accdesc.ispair then
        let half : integer{} = (size DIV 2) as integer{32, 64};
        memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{half}(memaddrdesc, accdesc, value[0*:half]);
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            return (memaddrdesc, memstatus);
        end;

        memaddrdesc.paddress.address = memaddrdesc.paddress.address + (bytes DIV 2);
        memaddrdesc.vaddress         = memaddrdesc.vaddress + (bytes DIV 2);
        memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{half}(memaddrdesc, accdesc, value[1*:half]);
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            return (memaddrdesc, memstatus);
        end;

    else
        for i = 0 to bytes-1 do
            memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{8}(memaddrdesc, accdesc, value[i*:8]);
            if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
                return (memaddrdesc, memstatus);
            end;
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
            memaddrdesc.vaddress         = memaddrdesc.vaddress + 1;
        end;
    end;

    return (memaddrdesc, memstatus);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_MemTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_MemTag</h3>
      <p class="pseudocode">// AArch64_MemTag - accessor
// =========================

accessor <a id="accessor_AArch64_MemTag_2"/>AArch64_MemTag(address : bits(64), accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) &lt;=&gt; value : bits(4)
begin
    // Load an Allocation Tag from memory.
    getter
        var value : bits(4);
        var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
        var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
        (value, memaddrdesc, memstatus) = <a href="shared_pseudocode.html#func_AArch64_MemTagRead_2" title="">AArch64_MemTagRead</a>(address, accdesc);

        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
            AArch64_Abort(memaddrdesc.fault);
        end;

        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            HandleExternalReadAbort(memstatus, memaddrdesc, 1, accdesc);
        end;

        return value;
    end;

    // Store an Allocation Tag to memory.
    setter
        var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
        var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
        (memaddrdesc, memstatus) = <a href="shared_pseudocode.html#func_AArch64_MemTagWrite_3" title="">AArch64_MemTagWrite</a>(address, accdesc, value);

        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
            AArch64_Abort(memaddrdesc.fault);
        end;

        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            HandleExternalWriteAbort(memstatus, memaddrdesc, 1, accdesc);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_MemTagRead"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_MemTagRead</h3>
      <p class="pseudocode">// AArch64_MemTagRead()
// ====================
// Load an Allocation Tag from memory.

func <a id="func_AArch64_MemTagRead_2"/>AArch64_MemTagRead(address : bits(64),
                        accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
                       ) =&gt; (bits(4), <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>)
begin
    assert accdesc_in.tagaccess &amp;&amp; !accdesc_in.tagchecked;

    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>      = accdesc_in;
    var tag : bits(4)                   = ARBITRARY : bits(4);
    var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    var memtagtype : <a href="shared_pseudocode.html#type_MemTagType" title="">MemTagType</a>  = ARBITRARY : <a href="shared_pseudocode.html#type_MemTagType" title="">MemTagType</a>;
    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>   = ARBITRARY : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;

    let aligned : boolean = TRUE;

    accdesc.tagaccess = <a href="shared_pseudocode.html#func_IsMTEEnabled_1" title="">IsMTEEnabled</a>(accdesc.el);

    (memtagtype, memaddrdesc) = <a href="shared_pseudocode.html#func_AArch64_TranslateTagAddress_4" title="">AArch64_TranslateTagAddress</a>(address, accdesc, aligned, <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a>);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        return (tag, memaddrdesc, memstatus);
    end;

    if accdesc.tagaccess &amp;&amp; memtagtype == <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a> then
        (memstatus, tag) = <a href="shared_pseudocode.html#func_PhysMemTagRead_2" title="">PhysMemTagRead</a>(memaddrdesc, accdesc);
        return (tag, memaddrdesc, memstatus);
    elsif (IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS) &amp;&amp;
             accdesc.tagaccess &amp;&amp; memtagtype == <a href="shared_pseudocode.html#enum_MemTag_CanonicallyTagged" title="">MemTag_CanonicallyTagged</a>) then
        tag = if address[55] == '0' then '0000' else '1111';
        return (tag, memaddrdesc, memstatus);
    else
        // Otherwise read the tag as zero
        tag = '0000';
        return (tag, memaddrdesc, memstatus);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_MemTagWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_MemTagWrite</h3>
      <p class="pseudocode">// AArch64_MemTagWrite()
// =====================
// Store an Allocation Tag to memory.

func <a id="func_AArch64_MemTagWrite_3"/>AArch64_MemTagWrite(address : bits(64),
                         accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                         value : bits(4)) =&gt; (<a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>)
begin
    assert accdesc_in.tagaccess &amp;&amp; !accdesc_in.tagchecked;

    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>     = accdesc_in;
    var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    var memtagtype : <a href="shared_pseudocode.html#type_MemTagType" title="">MemTagType</a>  = ARBITRARY : <a href="shared_pseudocode.html#type_MemTagType" title="">MemTagType</a>;
    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>   = ARBITRARY : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;

    let aligned : boolean = IsAlignedSize(address, <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a>);

    // Stores of allocation tags must be aligned
    if !aligned then
        memaddrdesc.fault = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, address);
        return (memaddrdesc, memstatus);
    end;

    accdesc.tagaccess = <a href="shared_pseudocode.html#func_IsMTEEnabled_1" title="">IsMTEEnabled</a>(accdesc.el);

    (memtagtype, memaddrdesc) = <a href="shared_pseudocode.html#func_AArch64_TranslateTagAddress_4" title="">AArch64_TranslateTagAddress</a>(address, accdesc, aligned, <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a>);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        memaddrdesc.fault.vaddress = memaddrdesc.vaddress;
        return (memaddrdesc, memstatus);
    end;

    if accdesc.tagaccess &amp;&amp; memtagtype == <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a> then
        memstatus = <a href="shared_pseudocode.html#func_PhysMemTagWrite_3" title="">PhysMemTagWrite</a>(memaddrdesc, accdesc, value);
    end;
    return (memaddrdesc, memstatus);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64_UnalignedAccessFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64_UnalignedAccessFaults</h3>
      <p class="pseudocode">// AArch64_UnalignedAccessFaults()
// ===============================
// Determine whether the unaligned access generates an Alignment fault

func <a id="func_AArch64_UnalignedAccessFaults_3"/>AArch64_UnalignedAccessFaults(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                   address : bits(64),
                                   size : integer) =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_AlignmentEnforced_0" title="">AlignmentEnforced</a>() then
        return TRUE;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_GCS" title="">AccessType_GCS</a> then
        return TRUE;
    elsif accdesc.rcw then
        return TRUE;
    elsif accdesc.ls64 then
        return TRUE;
    elsif (accdesc.exclusive || accdesc.atomicop)  then
        let quantity : integer = <a href="shared_pseudocode.html#func_MemSingleGranule_0" title="">MemSingleGranule</a>();
        return (!IsFeatureImplemented(FEAT_LSE2) ||
                  !AllInAlignedQuantity(address, size, quantity));
    elsif (accdesc.acqsc || accdesc.acqpc || accdesc.relsc) then
        // If nAA is 0, the address accessed by each register in the pair
        // must lie within a single 16-byte aligned block
        if accdesc.ispair then
            return  (<a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().nAA == '0' &amp;&amp;
                       (!AllInAlignedQuantity(address, size DIV 2, 16) ||
                        !AllInAlignedQuantity(address + size DIV 2, size DIV 2, 16)));
        else
            return  (<a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().nAA == '0' &amp;&amp;
                       !AllInAlignedQuantity(address, size, 16));
        end;
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AddressSupportsLS64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AddressSupportsLS64</h3>
      <p class="pseudocode">// AddressSupportsLS64()
// =====================
// Returns TRUE if the 64-byte block following the given address supports the
// LD64B and ST64B instructions, and FALSE otherwise.

impdef func <a id="func_AddressSupportsLS64_1"/>AddressSupportsLS64(paddress : bits(56)) =&gt; boolean
begin
    return ImpDefBool("Memory location supports ST64B and LD64B");
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AllInAlignedQuantity"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AllInAlignedQuantity</h3>
      <p class="pseudocode">// AllInAlignedQuantity()
// ======================
// Returns TRUE if all accessed bytes are within one aligned quantity, FALSE otherwise.

readonly func AllInAlignedQuantity(address : bits(64),
                                   size : integer, alignment : integer) =&gt; boolean
begin
    return (AlignDownSize(address+(size-1), alignment as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>) ==
            AlignDownSize(address, alignment as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.CASCompare"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/CASCompare</h3>
      <p class="pseudocode">// CASCompare()
// ============
// Performs a comparison for CAS

func <a id="func_CASCompare_4"/>CASCompare{N}(oldvalue : bits(N),
                   comparevalue : bits(N),
                   newvalue : bits(N)) =&gt; (bits(N), boolean, bits(N))
begin
    var memresult : bits(N);
    var cmpfail : boolean;
    var regresult : bits(N) = oldvalue;

    if oldvalue == comparevalue then
        cmpfail = FALSE;
        memresult = newvalue;
        if !<a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_CASRETURNOLDVALUE" title="">Unpredictable_CASRETURNOLDVALUE</a>) then
            regresult = comparevalue;
        end;
    else
        cmpfail = TRUE;
        memresult = oldvalue;
    end;

    return (memresult, cmpfail, regresult);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.CheckSPAlignment"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/CheckSPAlignment</h3>
      <p class="pseudocode">// CheckSPAlignment()
// ==================
// Check correct stack pointer alignment for AArch64 state.

func CheckSPAlignment()
begin
    let sp : bits(64) = SP{}();
    var stack_align_check : boolean;
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        stack_align_check = (<a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().SA0 != '0');
    else
        stack_align_check = (<a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().SA != '0');
    end;

    if stack_align_check &amp;&amp; sp != AlignDownSize(sp, 16) then
        AArch64_SPAlignmentFault();
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.IsConventionalMemory"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/IsConventionalMemory</h3>
      <p class="pseudocode">// IsConventionalMemory()
// ======================
// Returns TRUE if the memory location is in Conventional memory, and FALSE otherwise.

impdef func <a id="func_IsConventionalMemory_1"/>IsConventionalMemory(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.Mem"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/Mem</h3>
      <p class="pseudocode">// Mem - accessor
// ==============

accessor <a id="accessor_Mem_3"/>Mem{size : integer{8, 16, 32, 64, 128, 256}}(address : bits(64),
                                                      accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
                                                ) &lt;=&gt;  value_in : bits(size)
begin
    // Perform a read of 'size' bits. The access byte order is reversed for a big-endian access.
    // Instruction fetches would call AArch64_MemSingle directly.
    getter
        var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
        let bytes : integer{} = size DIV 8;
        var value : bits(size);
        // Check alignment on size of element accessed, not overall access size
        let alignment : integer{} = (if accdesc.ispair &amp;&amp; !accdesc.exclusive then bytes DIV 2
                                                                             else bytes);
        var aligned : boolean   = IsAlignedSize(address, alignment);
        let quantity : integer = <a href="shared_pseudocode.html#func_MemSingleGranule_0" title="">MemSingleGranule</a>();

        if !aligned &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_UnalignedAccessFaults_3" title="">AArch64_UnalignedAccessFaults</a>(accdesc, address, bytes) then
            let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, address);
            AArch64_Abort(fault);
        end;
        if accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a> &amp;&amp; bytes == 16 &amp;&amp; IsAlignedSize(address, 8) then
            // If 128-bit SIMD&amp;FP ordered access are treated as a pair of
            // 64-bit single-copy atomic accesses, then these single copy atomic
            // access can be observed in any order.
            let half : integer{} = (size DIV 2) as integer{64};
            let highaddress : bits(64) = <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(address, bytes DIV 2, accdesc);
            value[0*:half] = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{half}(address, accdesc, aligned);
            value[1*:half] = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{half}(highaddress, accdesc, aligned);
        elsif (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a> &amp;&amp; bytes == 32 &amp;&amp;
                accdesc.ispair &amp;&amp; IsAlignedSize(address, 32)) then
            value = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{size}(address, accdesc, aligned);
        elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a> &amp;&amp; bytes == 32 &amp;&amp; IsAlignedSize(address, 8) then
            // If a 32 byte LDP (SIMD&amp;FP) access is not aligned to 32 bytes but aligned to
            // 8 bytes, it is treated as four 8 byte single-copy atomic accesses.
            accdesc.ispair = FALSE;
            aligned        = TRUE;
            for i = 0 to 3 do
                let blockaddress : bits(64) = <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(address, i*8, accdesc);
                value[64*i+:64] = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{64}(blockaddress, accdesc, aligned);
            end;
        elsif (IsFeatureImplemented(FEAT_LSE2) &amp;&amp;
            AllInAlignedQuantity(address, bytes, quantity)) then
            value = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{size}(address, accdesc, aligned);
        elsif ((aligned &amp;&amp; accdesc.ispair) ||
                  (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_SVE" title="">AccessType_SVE</a> &amp;&amp; accdesc.predicated &amp;&amp;
                     bytes == 16 &amp;&amp; IsAlignedSize(address, 8))) then
            // Either: an aligned pair access, OR
            // an SVE predicated load of a 128-bit element that is 64-bit aligned,
            // which is treated as two 64-bit single-copy atomic accesses.
            accdesc.ispair = FALSE;
            let half : integer{} = (size DIV 2) as integer{32, 64, 128};
            let highaddress : bits(64) = <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(address, bytes DIV 2, accdesc);
            if IsFeatureImplemented(FEAT_LRCPC3) &amp;&amp; accdesc.highestaddressfirst then
                value[1*:half] = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{half}(highaddress, accdesc, aligned);
                value[0*:half] = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{half}(address, accdesc, aligned);
            else
                value[0*:half] = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{half}(address, accdesc, aligned);
                value[1*:half] = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{half}(highaddress, accdesc, aligned);
            end;
        elsif aligned then
            value = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{size}(address, accdesc, aligned);
        else
            assert bytes &gt; 1;
            if (IsFeatureImplemented(FEAT_LRCPC3) &amp;&amp; accdesc.ispair &amp;&amp;
                    accdesc.highestaddressfirst) then
                let half : integer{} = (size DIV 2) as integer{32, 64, 128};
                var lowhalf, highhalf : bits(half);

                for i = 0 to (bytes DIV 2)-1 do
                    let byteaddress : bits(64) = <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(address,
                                                                  (bytes DIV 2) + i, accdesc);
                    // Individual byte access can be observed in any order
                    highhalf[i*:8] = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{8}(byteaddress, accdesc, aligned);
                end;
                for i = 0 to (bytes DIV 2)-1 do
                    let byteaddress : bits(64) = <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(address, i, accdesc);
                    // Individual byte access can be observed in any order
                    lowhalf[i*:8] = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{8}(byteaddress, accdesc, aligned);
                end;

                value = highhalf::lowhalf;

            else
                value[7:0] = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{8}(address, accdesc, aligned);
                accdesc.lowestaddress = FALSE;

                // For subsequent bytes, if they cross to a new translation page which assigns
                // Device memory type, it is CONSTRAINED UNPREDICTABLE whether an unaligned access
                // will generate an Alignment Fault.
                let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_DEVPAGE2" title="">Unpredictable_DEVPAGE2</a>);
                assert c IN {<a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a>, <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>};
                if c == <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a> then aligned = TRUE; end;

                for i = 1 to bytes-1 do
                    let byteaddress : bits(64) = <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(address, i, accdesc);
                    value[i*:8] = <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{8}(byteaddress, accdesc, aligned);
                end;
            end;
        end;

        if <a href="shared_pseudocode.html#func_BigEndian_1" title="">BigEndian</a>(accdesc.acctype) then
            value = <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{size}(value);
        end;

        return value;
    end;

    // Perform a write of 'size' bits. The byte order is reversed for a big-endian access.
    setter
        var value : bits(size) = value_in;
        let bytes : integer{} = size DIV 8;
        var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;

        // Check alignment on size of element accessed, not overall access size
        let alignment : integer{} = (if accdesc.ispair &amp;&amp; !accdesc.exclusive then bytes DIV 2
                                                                              else bytes);
        var aligned : boolean   = IsAlignedSize(address, alignment);
        let quantity : integer = <a href="shared_pseudocode.html#func_MemSingleGranule_0" title="">MemSingleGranule</a>();

        if !aligned &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_UnalignedAccessFaults_3" title="">AArch64_UnalignedAccessFaults</a>(accdesc, address, bytes) then
            let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, address);
            AArch64_Abort(fault);
        end;

        if <a href="shared_pseudocode.html#func_BigEndian_1" title="">BigEndian</a>(accdesc.acctype) then
            value = <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{size}(value);
        end;
        if accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a> &amp;&amp; bytes == 16 &amp;&amp; IsAlignedSize(address, 8) then
            let half : integer{} = (size DIV 2) as integer{64};
            // 128-bit SIMD&amp;FP stores are treated as a pair of 64-bit single-copy atomic accesses
            // 64-bit aligned.
            let highaddress : bits(64) = <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(address, (bytes DIV 2), accdesc);
            <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{half}(address, accdesc, aligned) = value[0+:half];
            <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{half}(highaddress, accdesc, aligned) = value[half+:half];
        elsif (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a> &amp;&amp; bytes == 32 &amp;&amp;
                accdesc.ispair &amp;&amp; IsAlignedSize(address, 32)) then
            <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{size}(address, accdesc, aligned) = value;
        elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a> &amp;&amp; bytes == 32 &amp;&amp; IsAlignedSize(address, 8) then
            // If a 32 byte STP (SIMD&amp;FP) access is not aligned to 32 bytes but aligned to
            // 8 bytes, it is treated as four 8 byte single-copy atomic accesses.
            accdesc.ispair = FALSE;
            aligned        = TRUE;
            for i = 0 to 3 do
                let blockaddress : bits(64) = <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(address, i*8, accdesc);
                <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{64}(blockaddress, accdesc, aligned) = value[64*i+:64];
            end;
        elsif (IsFeatureImplemented(FEAT_LSE2) &amp;&amp;
            AllInAlignedQuantity(address, bytes, quantity)) then
            <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{size}(address, accdesc, aligned) = value;
        elsif ((aligned &amp;&amp; accdesc.ispair) ||
                  (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_SVE" title="">AccessType_SVE</a> &amp;&amp; accdesc.predicated &amp;&amp;
                     bytes == 16 &amp;&amp; IsAlignedSize(address, 8))) then
            // Either: an aligned pair access, OR
            // an SVE predicated load of a 128-bit element that is 64-bit aligned,
            // which is treated as two 64-bit single-copy atomic accesses.
            let half : integer{} = (size DIV 2) as integer{32, 64, 128};
            accdesc.ispair = FALSE;
            let highaddress : bits(64) = <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(address, (bytes DIV 2), accdesc);
            if IsFeatureImplemented(FEAT_LRCPC3) &amp;&amp; accdesc.highestaddressfirst then
                <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{half}(highaddress, accdesc, aligned) = value[half+:half];
                <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{half}(address, accdesc, aligned) = value[0+:half];
            else
                <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{half}(address, accdesc, aligned) = value[0+:half];
                <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{half}(highaddress, accdesc, aligned) = value[half+:half];
            end;
        elsif aligned then
            <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{size}(address, accdesc, aligned) = value;
        else
            assert bytes &gt; 1;
            if (IsFeatureImplemented(FEAT_LRCPC3) &amp;&amp; accdesc.ispair &amp;&amp;
                    accdesc.highestaddressfirst) then
                let half : integer{} = (size DIV 2) as integer{32, 64};
                var lowhalf, highhalf : bits(half);
                (highhalf, lowhalf) = (value[half+:half], value[0+:half]);
                for i = 0 to (bytes DIV 2)-1 do
                    let byteaddress : bits(64) = <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(address,
                                                                  (bytes DIV 2) + i, accdesc);
                    // Individual byte access can be observed in any order
                    <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{8}(byteaddress, accdesc, aligned) = highhalf[i*:8];
                end;
                for i = 0 to (bytes DIV 2)-1 do
                    let byteaddress : bits(64) = <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(address,
                                                                  (bytes DIV 2) + i, accdesc);
                    // Individual byte access can be observed in any order,
                    // but implies observability of highhalf
                    <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{8}(byteaddress, accdesc, aligned) = lowhalf[i*:8];
                end;
            else
                <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{8}(address, accdesc, aligned) = value[7:0];
                accdesc.lowestaddress = FALSE;

                // For subsequent bytes, if they cross to a new translation page which assigns
                // Device memory type, it is CONSTRAINED UNPREDICTABLE whether an unaligned access
                // will generate an Alignment Fault.

                let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_DEVPAGE2" title="">Unpredictable_DEVPAGE2</a>);
                assert c IN {<a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a>, <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>};
                if c == <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a> then aligned = TRUE; end;

                for i = 1 to bytes-1 do
                    let byteaddress : bits(64) = <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(address, i, accdesc);
                    <a href="shared_pseudocode.html#accessor_AArch64_MemSingle_4" title="">AArch64_MemSingle</a>{8}(byteaddress, accdesc, aligned) = value[i*:8];
                end;
            end;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemAtomic"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemAtomic</h3>
      <p class="pseudocode">// MemAtomic()
// ===========
// Performs load and store memory operations for a given virtual address.

func <a id="func_MemAtomic_5"/>MemAtomic{size : integer{8, 16, 32, 64, 128}}(address : bits(64),
                                                   cmpoperand : bits(size),
                                                   operand : bits(size),
                                                   accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
                                                  ) =&gt; bits(size)
begin
    assert accdesc_in.atomicop;

    let bytes : integer{} = (size DIV 8) as integer{1, 2, 4, 8, 16};

    var newvalue : bits(size);
    var oldvalue : bits(size);
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
    let aligned : boolean = IsAlignedSize(address, bytes);

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#func_AArch64_AccessIsTagChecked_2" title="">AArch64_AccessIsTagChecked</a>(address, accdesc);
    end;

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_UnalignedAccessFaults_3" title="">AArch64_UnalignedAccessFaults</a>(accdesc, address, bytes) then
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, address);
        AArch64_Abort(fault);
    end;

    // MMU or MPU lookup
    let memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(address, accdesc,
                                                                      aligned, bytes);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        AArch64_Abort(memaddrdesc.fault);
    end;

    if (!<a href="shared_pseudocode.html#func_IsWBShareable_1" title="">IsWBShareable</a>(memaddrdesc.memattrs) &amp;&amp;
            <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_Atomic_NOP" title="">Unpredictable_Atomic_NOP</a>)) then
        return ARBITRARY : bits(size);
    end;

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> then
        ClearExclusiveByAddress(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), bytes);
    end;

    // For Store-only Tag checking, the tag check is performed on the store.
    if (accdesc.tagchecked &amp;&amp;
          (!IsFeatureImplemented(FEAT_MTE_STORE_ONLY) ||
           !<a href="shared_pseudocode.html#func_StoreOnlyTagCheckingEnabled_1" title="">StoreOnlyTagCheckingEnabled</a>(accdesc.el))) then
        let ltag : bits(4) = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(address);
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = AArch64_CheckTag(memaddrdesc, accdesc, bytes, ltag);
        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            AArch64_Abort(fault);
        end;
    end;

    // All observers in the shareability domain observe the following load and store atomically.
    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    (memstatus, oldvalue) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{size}(memaddrdesc, accdesc);
    // Depending on the memory type of the physical address, the access might generate
    // either a synchronous External abort or an SError exception
    // among other CONSTRAINED UNPREDICTABLE choices.

    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
        HandleExternalReadAbort(memstatus, memaddrdesc, bytes, accdesc);
    end;
    if <a href="shared_pseudocode.html#func_BigEndian_1" title="">BigEndian</a>(accdesc.acctype) then
        oldvalue = <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{size}(oldvalue);
    end;

    var cmpfail : boolean = FALSE;
    var retvalue : bits(size) = oldvalue;
    if accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_FP" title="">AccessType_FP</a> then
        newvalue = <a href="shared_pseudocode.html#func_MemAtomicFP_4" title="">MemAtomicFP</a>{size}(accdesc.modop, oldvalue, operand);
    else
        (newvalue, cmpfail, retvalue) = <a href="shared_pseudocode.html#func_MemAtomicInt_5" title="">MemAtomicInt</a>{size}(accdesc.modop, oldvalue,
                                                           operand, cmpoperand);
    end;

    let requirewrite : boolean = (!cmpfail ||
                                     <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_WRITEFAILEDCAS" title="">Unpredictable_WRITEFAILEDCAS</a>));

    if IsFeatureImplemented(FEAT_MTE_STORE_ONLY) &amp;&amp; <a href="shared_pseudocode.html#func_StoreOnlyTagCheckingEnabled_1" title="">StoreOnlyTagCheckingEnabled</a>(accdesc.el) then
        // If the compare on a CAS fails, then it is CONSTRAINED UNPREDICTABLE whether the
        // Tag check is performed.
        if accdesc.tagchecked &amp;&amp; !requirewrite then
            accdesc.tagchecked = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_STRONLYTAGCHECKEDCAS" title="">Unpredictable_STRONLYTAGCHECKEDCAS</a>);
        end;

        if accdesc.tagchecked then
            let ltag : bits(4) = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(address);
            var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = AArch64_CheckTag(memaddrdesc, accdesc, bytes, ltag);
            if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
                // For a synchronous Tag Check Fault due to FEAT_MTE_STORE_ONLY, set WnR.
                fault.write = TRUE;
                AArch64_Abort(fault);
            end;
        end;
    end;

    if requirewrite then
        if <a href="shared_pseudocode.html#func_BigEndian_1" title="">BigEndian</a>(accdesc.acctype) then
            newvalue = <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{size}(newvalue);
        end;
        memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{size}(memaddrdesc, accdesc, newvalue);
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            HandleExternalWriteAbort(memstatus, memaddrdesc, bytes, accdesc);
        end;
    end;

    if <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> then
        let is_load : boolean = FALSE;
        SPESampleLoadStore(is_load, accdesc, memaddrdesc);
    end;

    // Load operations return the old (pre-operation) value.
    // Compare and Swap operations return the old (pre-operation) value. For a successful CAS,
    // this might be the value from the compare operand or from memory.
    return retvalue;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemAtomicFP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemAtomicFP</h3>
      <p class="pseudocode">// MemAtomicFP()
// =============
// Performs FP Atomic operation

func <a id="func_MemAtomicFP_4"/>MemAtomicFP{N}(modop : <a href="shared_pseudocode.html#type_MemAtomicOp" title="">MemAtomicOp</a>, op1 : bits(N), op2 : bits(N)) =&gt; bits(N)
begin
    var fpcr : FPCR_Type = FPCR();
    let altfp : boolean  = FALSE;
    let fpexc : boolean  = FALSE;
    fpcr.[AH,DN]   = '01';
    fpcr.FZ        = fpcr.FZ OR fpcr.FIZ; // Treat FPCR.FIZ as equivalent to FPCR.FZ
    var result : bits(N);

    case modop of
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_FPADD" title="">MemAtomicOp_FPADD</a> =&gt;    result = <a href="shared_pseudocode.html#func_FPAdd_5" title="">FPAdd</a>{N}(op1, op2, fpcr, fpexc);
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_FPMAX" title="">MemAtomicOp_FPMAX</a> =&gt;    result = <a href="shared_pseudocode.html#func_FPMax_6" title="">FPMax</a>{N}(op1, op2, fpcr, altfp, fpexc);
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_FPMIN" title="">MemAtomicOp_FPMIN</a> =&gt;    result = <a href="shared_pseudocode.html#func_FPMin_6" title="">FPMin</a>{N}(op1, op2, fpcr, altfp, fpexc);
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_FPMAXNM" title="">MemAtomicOp_FPMAXNM</a> =&gt;  result = <a href="shared_pseudocode.html#func_FPMaxNum_5" title="">FPMaxNum</a>{N}(op1, op2, fpcr, fpexc);
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_FPMINNM" title="">MemAtomicOp_FPMINNM</a> =&gt;  result = <a href="shared_pseudocode.html#func_FPMinNum_5" title="">FPMinNum</a>{N}(op1, op2, fpcr, fpexc);
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_BFADD" title="">MemAtomicOp_BFADD</a> =&gt;    result = <a href="shared_pseudocode.html#func_BFAdd_5" title="">BFAdd</a>{N}(op1, op2, fpcr, fpexc);
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_BFMAX" title="">MemAtomicOp_BFMAX</a> =&gt;    result = <a href="shared_pseudocode.html#func_BFMax_6" title="">BFMax</a>{N}(op1, op2, fpcr, altfp, fpexc);
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_BFMIN" title="">MemAtomicOp_BFMIN</a> =&gt;    result = <a href="shared_pseudocode.html#func_BFMin_6" title="">BFMin</a>{N}(op1, op2, fpcr, altfp, fpexc);
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_BFMAXNM" title="">MemAtomicOp_BFMAXNM</a> =&gt;  result = <a href="shared_pseudocode.html#func_BFMaxNum_5" title="">BFMaxNum</a>{N}(op1, op2, fpcr, fpexc);
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_BFMINNM" title="">MemAtomicOp_BFMINNM</a> =&gt;  result = <a href="shared_pseudocode.html#func_BFMinNum_5" title="">BFMinNum</a>{N}(op1, op2, fpcr, fpexc);
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemAtomicInt"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemAtomicInt</h3>
      <p class="pseudocode">// MemAtomicInt()
// ==============
// Performs Integer Atomic operation

func <a id="func_MemAtomicInt_5"/>MemAtomicInt{N}(modop : <a href="shared_pseudocode.html#type_MemAtomicOp" title="">MemAtomicOp</a>, op1 : bits(N), op2 : bits(N), cmpop : bits(N)
                    ) =&gt; (bits(N), boolean, bits(N))
begin
    var result : bits(N);
    var cmpfail : boolean = FALSE;
    var retvalue : bits(N) = op1;

    case modop of
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_ADD" title="">MemAtomicOp_ADD</a> =&gt;      result = op1 + op2;
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_BIC" title="">MemAtomicOp_BIC</a> =&gt;      result = op1 AND NOT(op2);
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_EOR" title="">MemAtomicOp_EOR</a> =&gt;      result = op1 XOR op2;
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_ORR" title="">MemAtomicOp_ORR</a> =&gt;      result = op1 OR op2;
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_SMAX" title="">MemAtomicOp_SMAX</a> =&gt;     result = Max(SInt(op1), SInt(op2))[N-1:0];
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_SMIN" title="">MemAtomicOp_SMIN</a> =&gt;     result = Min(SInt(op1), SInt(op2))[N-1:0];
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_UMAX" title="">MemAtomicOp_UMAX</a> =&gt;     result = Max(UInt(op1), UInt(op2))[N-1:0];
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_UMIN" title="">MemAtomicOp_UMIN</a> =&gt;     result = Min(UInt(op1), UInt(op2))[N-1:0];
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_SWP" title="">MemAtomicOp_SWP</a> =&gt;      result = op2;
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_CAS" title="">MemAtomicOp_CAS</a> =&gt;      (result, cmpfail, retvalue) = <a href="shared_pseudocode.html#func_CASCompare_4" title="">CASCompare</a>{N}(op1, cmpop, op2);
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_GCSSS1" title="">MemAtomicOp_GCSSS1</a> =&gt;   (result, cmpfail, retvalue) = <a href="shared_pseudocode.html#func_CASCompare_4" title="">CASCompare</a>{N}(op1, cmpop, op2);
    end;
    return (result, cmpfail, retvalue);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemAtomicRCW"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemAtomicRCW</h3>
      <p class="pseudocode">// MemAtomicRCW()
// ==============
// Perform a single-copy-atomic access with Read-Check-Write operation

func <a id="func_MemAtomicRCW_5"/>MemAtomicRCW{size : integer{64, 128}}(address : bits(64), cmpoperand : bits(size),
                                           operand : bits(size), accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
                                  ) =&gt; (bits(4), bits(size))
begin
    assert accdesc_in.atomicop;
    assert accdesc_in.rcw;

    let bytes : integer{} = (size DIV 8) as integer{8, 16};

    var nzcv : bits(4);
    var oldvalue : bits(size);
    var newvalue : bits(size);
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
    let aligned : boolean = IsAlignedSize(address, bytes);

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#func_AArch64_AccessIsTagChecked_2" title="">AArch64_AccessIsTagChecked</a>(address, accdesc);
    end;

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_UnalignedAccessFaults_3" title="">AArch64_UnalignedAccessFaults</a>(accdesc, address, bytes) then
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, address);
        AArch64_Abort(fault);
    end;

    // MMU or MPU lookup
    let memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(address, accdesc,
                                                                      aligned, bytes);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        AArch64_Abort(memaddrdesc.fault);
    end;

    if (!<a href="shared_pseudocode.html#func_IsWBShareable_1" title="">IsWBShareable</a>(memaddrdesc.memattrs) &amp;&amp;
            <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_Atomic_NOP" title="">Unpredictable_Atomic_NOP</a>)) then
        return (ARBITRARY : bits(4), ARBITRARY : bits(size));
    end;

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> then
        ClearExclusiveByAddress(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), bytes);
    end;

    // For Store-only Tag checking, the tag check is performed on the store.
    if (accdesc.tagchecked &amp;&amp;
          (!IsFeatureImplemented(FEAT_MTE_STORE_ONLY) ||
           !<a href="shared_pseudocode.html#func_StoreOnlyTagCheckingEnabled_1" title="">StoreOnlyTagCheckingEnabled</a>(accdesc.el))) then
        let ltag : bits(4) = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(address);
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = AArch64_CheckTag(memaddrdesc, accdesc, bytes, ltag);
        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            AArch64_Abort(fault);
        end;
    end;

    // All observers in the shareability domain observe the following load and store atomically.
    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    (memstatus, oldvalue) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{size}(memaddrdesc, accdesc);
    // Depending on the memory type of the physical address, the access might generate
    // either a synchronous External abort or an SError exception
    // among other CONSTRAINED UNPREDICTABLE choices.

    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
        HandleExternalReadAbort(memstatus, memaddrdesc, bytes, accdesc);
    end;
    if <a href="shared_pseudocode.html#func_BigEndian_1" title="">BigEndian</a>(accdesc.acctype) then
        oldvalue = <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{size}(oldvalue);
    end;

    var cmpfail : boolean = FALSE;
    var retvalue : bits(size) = oldvalue;
    case accdesc.modop of
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_BIC" title="">MemAtomicOp_BIC</a> =&gt; newvalue = oldvalue AND NOT(operand);
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_ORR" title="">MemAtomicOp_ORR</a> =&gt; newvalue = oldvalue OR operand;
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_SWP" title="">MemAtomicOp_SWP</a> =&gt; newvalue = operand;
        when <a href="shared_pseudocode.html#enum_MemAtomicOp_CAS" title="">MemAtomicOp_CAS</a> =&gt;
            (newvalue, cmpfail, retvalue) = <a href="shared_pseudocode.html#func_CASCompare_4" title="">CASCompare</a>{size}(oldvalue, cmpoperand, operand);
    end;

    if cmpfail then
        nzcv = '1010'; // N = 1 indicates compare failure
    else
        nzcv = <a href="shared_pseudocode.html#func_RCWCheck_4" title="">RCWCheck</a>{size}(retvalue, newvalue, accdesc.rcws);
    end;

    // If RCWCheck() passes, it returns nzcv == '0010'
    let requirewrite : boolean = ((nzcv == '0010') ||
                                     (accdesc.modop == <a href="shared_pseudocode.html#enum_MemAtomicOp_CAS" title="">MemAtomicOp_CAS</a> &amp;&amp;
                                      <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_WRITEFAILEDCAS" title="">Unpredictable_WRITEFAILEDCAS</a>)));

    if IsFeatureImplemented(FEAT_MTE_STORE_ONLY) &amp;&amp; <a href="shared_pseudocode.html#func_StoreOnlyTagCheckingEnabled_1" title="">StoreOnlyTagCheckingEnabled</a>(accdesc.el) then
        // If the RCW(S) check fails, or if the compare on a RCW(S)CAS fails,
        // then it is CONSTRAINED UNPREDICTABLE whether the Tag check is performed.
        if accdesc.tagchecked &amp;&amp; !requirewrite then
            accdesc.tagchecked = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_STRONLYTAGCHECKEDRCWSCAS" title="">Unpredictable_STRONLYTAGCHECKEDRCWSCAS</a>);
        end;

        if accdesc.tagchecked then
            let ltag : bits(4) = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(address);
            var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = AArch64_CheckTag(memaddrdesc, accdesc, bytes, ltag);
            if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
                // For a synchronous Tag Check Fault due to FEAT_MTE_STORE_ONLY, set WnR.
                fault.write = TRUE;
                AArch64_Abort(fault);
            end;
        end;
    end;

    if requirewrite then
        if <a href="shared_pseudocode.html#func_BigEndian_1" title="">BigEndian</a>(accdesc.acctype) then
            newvalue = <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{size}(newvalue);
        end;

        memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{size}(memaddrdesc, accdesc, newvalue);

        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            HandleExternalWriteAbort(memstatus, memaddrdesc, bytes, accdesc);
        end;
    end;

    if <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> then
        let is_load : boolean = TRUE;
        SPESampleLoadStore(is_load, accdesc, memaddrdesc);
    end;

    // Load operations return the old (pre-operation) value.
    // Compare and Swap operations return the old (pre-operation) value. For a successful CAS,
    // this might be the value from the compare operand or from memory.
    return (nzcv, retvalue);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemLoad64B"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemLoad64B</h3>
      <p class="pseudocode">// MemLoad64B()
// ============
// Performs an atomic 64-byte read from a given virtual address.

func <a id="func_MemLoad64B_2"/>MemLoad64B(address : bits(64), accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; bits(512)
begin
    let size : integer{} = 512;
    let bytes : integer{} = size DIV 8;
    var data : bits(size);
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
    let aligned : boolean = IsAlignedSize(address, bytes);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_UnalignedAccessFaults_3" title="">AArch64_UnalignedAccessFaults</a>(accdesc, address, bytes) then
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, address);
        AArch64_Abort(fault);
    end;

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#func_AArch64_AccessIsTagChecked_2" title="">AArch64_AccessIsTagChecked</a>(address, accdesc);
    end;

    var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(address, accdesc,
                                                                   aligned, bytes);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        AArch64_Abort(memaddrdesc.fault);
    end;

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> then
        ClearExclusiveByAddress(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), bytes);
    end;

    if accdesc.tagchecked then
        let ltag : bits(4)      = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(address);
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = AArch64_CheckTag(memaddrdesc, accdesc, bytes, ltag);
        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            AArch64_Abort(fault);
        end;
    end;

    var byte_atomic : boolean = FALSE;
    if ((memaddrdesc.memattrs.memtype == MemType_Device ||
          (memaddrdesc.memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp;
             memaddrdesc.memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>)) &amp;&amp;
          !<a href="shared_pseudocode.html#func_AddressSupportsLS64_1" title="">AddressSupportsLS64</a>(memaddrdesc.paddress.address)) then
        let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_LS64UNSUPPORTED" title="">Unpredictable_LS64UNSUPPORTED</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_LIMITED_ATOMICITY" title="">Constraint_LIMITED_ATOMICITY</a>, <a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a>};
        if c == <a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a> then
            // Generate a stage 1 Data Abort reported using the DFSC code of 110101.
            let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_ExclusiveFault_2" title="">ExclusiveFault</a>(accdesc, address);
            AArch64_Abort(fault);
        else
            byte_atomic = TRUE;
        end;
    elsif <a href="shared_pseudocode.html#func_IsWBShareable_1" title="">IsWBShareable</a>(memaddrdesc.memattrs) &amp;&amp; !<a href="shared_pseudocode.html#func_IsConventionalMemory_1" title="">IsConventionalMemory</a>(memaddrdesc) then
        if ImpDefBool("LD64B faults to iWBoWB non-Conventional memory") then
            // Generate a Data Abort reported using the DFSC code of 110101.
            let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_ExclusiveFault_2" title="">ExclusiveFault</a>(accdesc, address);
            AArch64_Abort(fault);
        else
            byte_atomic = TRUE;
        end;
    end;

    if <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> then
        let is_load : boolean = TRUE;
        SPESampleLoadStore(is_load, accdesc, memaddrdesc);
    end;

    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    if byte_atomic then
        // Accesses are not single-copy atomic above the byte level.
        for i = 0 to bytes-1 do
            (memstatus, data[i*:8]) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{8}(memaddrdesc, accdesc);
            if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
                HandleExternalReadAbort(memstatus, memaddrdesc, 1, accdesc);
            end;
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
            memaddrdesc.vaddress         = memaddrdesc.vaddress + 1;
        end;
    else
        (memstatus, data) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{size}(memaddrdesc, accdesc);
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            HandleExternalReadAbort(memstatus, memaddrdesc, bytes, accdesc);
        end;
    end;

    return data;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemSingleGranule"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemSingleGranule</h3>
      <p class="pseudocode">// MemSingleGranule()
// ==================
// When FEAT_LSE2 is implemented, for some memory accesses if all bytes
// of the accesses are within 16-byte quantity aligned to 16-bytes and
// satisfy additional requirements - then the access is guaranteed to
// be single copy atomic.
// However, when the accesses do not all lie within such a boundary, it
// is CONSTRAINED UNPREDICTABLE if the access is single copy atomic.
// In the pseudocode, this CONSTRAINED UNPREDICTABLE aspect is modeled via
// MemSingleGranule() which is IMPLEMENTATION DEFINED and, is at least 16 bytes
// and at most 4096 bytes.
// This is a limitation of the pseudocode.

func <a id="func_MemSingleGranule_0"/>MemSingleGranule() =&gt; integer
begin
    let size : integer = ImpDefInt("Aligned quantity for atomic access");
    // access is assumed to be within 4096 byte aligned quantity to
    // avoid multiple translations for a single copy atomic access.
    assert (size &gt;= 16) &amp;&amp; (size &lt;= 4096);
    return size;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemStore64B"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemStore64B</h3>
      <p class="pseudocode">// MemStore64B()
// =============
// Performs an atomic 64-byte store to a given virtual address. Function does
// not return the status of the store.

func MemStore64B(address : bits(64), value : bits(512), accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>)
begin
    let size : integer{} = 512;
    let bytes : integer{} = size DIV 8;
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
    let aligned : boolean = IsAlignedSize(address, bytes);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_UnalignedAccessFaults_3" title="">AArch64_UnalignedAccessFaults</a>(accdesc, address, bytes) then
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, address);
        AArch64_Abort(fault);
    end;

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#func_AArch64_AccessIsTagChecked_2" title="">AArch64_AccessIsTagChecked</a>(address, accdesc);
    end;

    var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(address, accdesc,
                                                                   aligned, bytes);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        AArch64_Abort(memaddrdesc.fault);
    end;

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> then
        ClearExclusiveByAddress(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), 64);
    end;

    if accdesc.tagchecked then
        let ltag : bits(4)      = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(address);
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = AArch64_CheckTag(memaddrdesc, accdesc, bytes, ltag);
        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            AArch64_Abort(fault);
        end;
    end;

    var byte_atomic : boolean = FALSE;
    if ((memaddrdesc.memattrs.memtype == MemType_Device ||
          (memaddrdesc.memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp;
             memaddrdesc.memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>)) &amp;&amp;
          !<a href="shared_pseudocode.html#func_AddressSupportsLS64_1" title="">AddressSupportsLS64</a>(memaddrdesc.paddress.address)) then
        let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_LS64UNSUPPORTED" title="">Unpredictable_LS64UNSUPPORTED</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_LIMITED_ATOMICITY" title="">Constraint_LIMITED_ATOMICITY</a>, <a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a>};
        if c == <a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a> then
            // Generate a Data Abort reported using the DFSC code of 110101.
            let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_ExclusiveFault_2" title="">ExclusiveFault</a>(accdesc, address);
            AArch64_Abort(fault);
        else
            byte_atomic = TRUE;
        end;
    elsif <a href="shared_pseudocode.html#func_IsWBShareable_1" title="">IsWBShareable</a>(memaddrdesc.memattrs) &amp;&amp; !<a href="shared_pseudocode.html#func_IsConventionalMemory_1" title="">IsConventionalMemory</a>(memaddrdesc) then
        if ImpDefBool("ST64B faults to iWBoWB non-Conventional memory") then
            // Generate a Data Abort reported using the DFSC code of 110101.
            let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_ExclusiveFault_2" title="">ExclusiveFault</a>(accdesc, address);
            AArch64_Abort(fault);
        else
            byte_atomic = TRUE;
        end;
    end;

    if <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> then
        let is_load : boolean = FALSE;
        SPESampleLoadStore(is_load, accdesc, memaddrdesc);
    end;

    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    if byte_atomic then
        // Accesses are not single-copy atomic above the byte level.
        for i = 0 to bytes-1 do
            memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{8}(memaddrdesc, accdesc, value[i*:8]);
            if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
                HandleExternalWriteAbort(memstatus, memaddrdesc, 1, accdesc);
            end;
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
            memaddrdesc.vaddress         = memaddrdesc.vaddress + 1;
        end;
    else
        memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{size}(memaddrdesc, accdesc, value);
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            HandleExternalWriteAbort(memstatus, memaddrdesc, bytes, accdesc);
        end;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemStore64BWithRet"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemStore64BWithRet</h3>
      <p class="pseudocode">// MemStore64BWithRet()
// ====================
// Performs an atomic 64-byte store to a given virtual address returning
// the status value of the operation.

func <a id="func_MemStore64BWithRet_3"/>MemStore64BWithRet(address : bits(64), value : bits(512),
                        accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; bits(64)
begin
    let size : integer{} = 512;
    let bytes : integer{} = size DIV 8;
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
    let aligned : boolean = IsAlignedSize(address, bytes);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_UnalignedAccessFaults_3" title="">AArch64_UnalignedAccessFaults</a>(accdesc, address, bytes) then
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AlignmentFault_2" title="">AlignmentFault</a>(accdesc, address);
        AArch64_Abort(fault);
    end;

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#func_AArch64_AccessIsTagChecked_2" title="">AArch64_AccessIsTagChecked</a>(address, accdesc);
    end;

    let memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(address, accdesc,
                                                                    aligned, bytes);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        AArch64_Abort(memaddrdesc.fault);
    end;

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> then
        ClearExclusiveByAddress(memaddrdesc.paddress, <a href="shared_pseudocode.html#func_ProcessorID_0" title="">ProcessorID</a>(), 64);
    end;

    if accdesc.tagchecked then
        let ltag : bits(4)      = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(address);
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = AArch64_CheckTag(memaddrdesc, accdesc, bytes, ltag);
        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            AArch64_Abort(fault);
        end;
    end;

    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{size}(memaddrdesc, accdesc, value);

    // If an access generated by ST64BV or ST64BV0 fails solely because the memory location
    // does not support 64-byte access, then memstatus does not indicate a fault,
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
        HandleExternalWriteAbort(memstatus, memaddrdesc, bytes, accdesc);
    end;

    if <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> then
        let is_load : boolean = FALSE;
        SPESampleLoadStore(is_load, accdesc, memaddrdesc);
    end;

    return memstatus.store64bstatus;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemStore64BWithRetStatus"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemStore64BWithRetStatus</h3>
      <p class="pseudocode">// MemStore64BWithRetStatus()
// ==========================
// Generates the return status of memory write with ST64BV or ST64BV0
// instructions. The status indicates if the operation succeeded, failed,
// or was not supported at this memory location.

impdef func <a id="func_MemStore64BWithRetStatus_0"/>MemStore64BWithRetStatus() =&gt; bits(64)
begin
    return Zeros{64};
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.NVMem"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/NVMem</h3>
      <p class="pseudocode">// NVMem - accessor
// ================

accessor <a id="accessor_NVMem_1"/>NVMem(offset : integer) &lt;=&gt; value : bits(64)
begin
    // This function is the load memory access for the transformed System register read access
    // when Enhanced Nested Virtualization is enabled with HCR_EL2.NV2 = 1.
    // The address for the load memory access is calculated using
    // the formula SignExtend(VNCR_EL2.BADDR : Offset[11:0], 64) where,
    //  * VNCR_EL2.BADDR holds the base address of the memory location, and
    //  * Offset is the unique offset value defined architecturally for each System register that
    //    supports transformation of register access to memory access.
    getter
        assert offset &gt; 0 &amp;&amp; offset MOD 8 == 0;
        let directread : boolean = FALSE;
        let baddr : bits(64)     = <a href="shared_pseudocode.html#func_EffectiveBADDR_2" title="">EffectiveBADDR</a>(VNCR_EL2().BADDR :: Zeros{12}, directread);
        let address : bits(64)   = baddr + offset;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescNV2(MemOp_LOAD);
        return <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(address, accdesc);
    end;

    // This function is the store memory access for the transformed System register write access
    // when Enhanced Nested Virtualization is enabled with HCR_EL2.NV2 = 1.
    // The address for the store memory access is calculated using
    // the formula SignExtend(VNCR_EL2.BADDR : Offset[11:0], 64) where,
    //  * VNCR_EL2.BADDR holds the base address of the memory location, and
    //  * Offset is the unique offset value defined architecturally for each System register that
    //    supports transformation of register access to memory access.
    setter
        assert offset &gt; 0 &amp;&amp; offset MOD 8 == 0;
        let directread : boolean = FALSE;
        let baddr : bits(64)     = <a href="shared_pseudocode.html#func_EffectiveBADDR_2" title="">EffectiveBADDR</a>(VNCR_EL2().BADDR :: Zeros{12}, directread);
        let address : bits(64)   = baddr + offset;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescNV2(MemOp_STORE);
        <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{64}(address, accdesc) = value;
        return;
    end;
end;

accessor <a id="accessor_NVMem128_1"/>NVMem128(offset : integer) &lt;=&gt; value : bits(128)
begin
    getter
        assert offset &gt; 0 &amp;&amp; offset MOD 16 == 0;
        let directread : boolean = FALSE;
        let baddr : bits(64)     = <a href="shared_pseudocode.html#func_EffectiveBADDR_2" title="">EffectiveBADDR</a>(VNCR_EL2().BADDR :: Zeros{12}, directread);
        let address : bits(64)   = baddr + offset;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescNV2(MemOp_LOAD);
        return <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{128}(address, accdesc);
    end;

    setter
        assert offset &gt; 0 &amp;&amp; offset MOD 16 == 0;
        let directread : boolean = FALSE;
        let baddr : bits(64)     = <a href="shared_pseudocode.html#func_EffectiveBADDR_2" title="">EffectiveBADDR</a>(VNCR_EL2().BADDR :: Zeros{12}, directread);
        let address : bits(64)   = baddr + offset;
        let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescNV2(MemOp_STORE);
        <a href="shared_pseudocode.html#accessor_Mem_3" title="">Mem</a>{128}(address, accdesc) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.PhysMemTagRead"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/PhysMemTagRead</h3>
      <p class="pseudocode">// PhysMemTagRead()
// ================
// This is the hardware operation which perform a single-copy atomic,
// Allocation Tag granule aligned, memory access from the tag in PA space.
//
// The function address the array using desc.paddress which supplies:
// * A 52-bit physical address
// * A single NS bit to select between Secure and Non-secure parts of the array.
//
// The accdesc descriptor describes the access type: normal, exclusive, ordered, streaming,
// etc and other parameters required to access the physical memory or for setting syndrome
// register in the event of an External abort.

impdef func <a id="func_PhysMemTagRead_2"/>PhysMemTagRead(desc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                           accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; (<a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>, bits(4))
begin
    return (ARBITRARY : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>, Zeros{4});
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.PhysMemTagWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/PhysMemTagWrite</h3>
      <p class="pseudocode">// PhysMemTagWrite()
// =================
// This is the hardware operation which perform a single-copy atomic,
// Allocation Tag granule aligned, memory access to the tag in PA space.
//
// The function address the array using desc.paddress which supplies:
// * A 52-bit physical address
// * A single NS bit to select between Secure and Non-secure parts of the array.
//
// The accdesc descriptor describes the access type: normal, exclusive, ordered, streaming,
// etc and other parameters required to access the physical memory or for setting syndrome
// register in the event of an External abort.

impdef func <a id="func_PhysMemTagWrite_3"/>PhysMemTagWrite(desc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                            accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                            value : bits(4)) =&gt; <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>
begin
    return ARBITRARY : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.StoreOnlyTagCheckingEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/StoreOnlyTagCheckingEnabled</h3>
      <p class="pseudocode">// StoreOnlyTagCheckingEnabled()
// =============================
// Returns TRUE if loads executed at the given Exception level are Tag unchecked.

func <a id="func_StoreOnlyTagCheckingEnabled_1"/>StoreOnlyTagCheckingEnabled(el : bits(2)) =&gt; boolean
begin
    assert IsFeatureImplemented(FEAT_MTE_STORE_ONLY);
    var tcso : bit;

    case el of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            if !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(el) then
                tcso = SCTLR_EL1().TCSO0;
            else
                tcso = SCTLR_EL2().TCSO0;
            end;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            tcso = SCTLR_EL1().TCSO;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            tcso = SCTLR_EL2().TCSO;
        otherwise =&gt;
            tcso = SCTLR_EL3().TCSO;
    end;

    return tcso == '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mlbi.AArch64_MLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mlbi/AArch64_MLBI_ALL</h3>
      <p class="pseudocode">// AArch64_MLBI_ALL()
// ==================
// Invalidate MLB entries associated with the current Security state.

func AArch64_MLBI_ALL(el : bits(2))
begin
    var r : <a href="shared_pseudocode.html#type_MLBIRecord" title="">MLBIRecord</a> = <a href="shared_pseudocode.html#func_NewMLBIRecord_1" title="">NewMLBIRecord</a>(<a href="shared_pseudocode.html#enum_MLBIOp_ALL" title="">MLBIOp_ALL</a>);
    r.security   = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(el);

    MLBI(r);

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mlbi.AArch64_MLBI_VMALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mlbi/AArch64_MLBI_VMALL</h3>
      <p class="pseudocode">// AArch64_MLBI_VMALL()
// ====================
// Invalidated MLB entries associated with the current Security state that match the
// indicated VMID (where applicable).

func AArch64_MLBI_VMALL(el : bits(2), vmid : bits(16))
begin
    var r : <a href="shared_pseudocode.html#type_MLBIRecord" title="">MLBIRecord</a> = <a href="shared_pseudocode.html#func_NewMLBIRecord_1" title="">NewMLBIRecord</a>(<a href="shared_pseudocode.html#enum_MLBIOp_VMALL" title="">MLBIOp_VMALL</a>);
    r.security   = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(el);
    r.vmid       = vmid;

    MLBI(r);

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mlbi.AArch64_MLBI_VPID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mlbi/AArch64_MLBI_VPID</h3>
      <p class="pseudocode">// AArch64_MLBI_VPID()
// ===================
// Invalidated MLB entries associated with the current Security state that match the
// indicated vPID in the parameter Xt.

func AArch64_MLBI_VPID(el : bits(2), vmid : bits(16), Xt : bits(64))
begin
    var r : <a href="shared_pseudocode.html#type_MLBIRecord" title="">MLBIRecord</a> = <a href="shared_pseudocode.html#func_NewMLBIRecord_1" title="">NewMLBIRecord</a>(<a href="shared_pseudocode.html#enum_MLBIOp_VPID" title="">MLBIOp_VPID</a>);
    r.security   = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(el);
    r.vmid       = vmid;
    r.vpid       = Xt[11:0];

    MLBI(r);

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mlbi.AArch64_MLBI_VPMG"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mlbi/AArch64_MLBI_VPMG</h3>
      <p class="pseudocode">// AArch64_MLBI_VPMG()
// ===================
// Invalidated MLB entries associated with the current Security state that match the
// indicated vPMG in the parameter Xt.

func AArch64_MLBI_VPMG(el : bits(2), vmid : bits(16), Xt : bits(64))
begin
    var r : <a href="shared_pseudocode.html#type_MLBIRecord" title="">MLBIRecord</a> = <a href="shared_pseudocode.html#func_NewMLBIRecord_1" title="">NewMLBIRecord</a>(<a href="shared_pseudocode.html#enum_MLBIOp_VPMG" title="">MLBIOp_VPMG</a>);
    r.security   = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(el);
    r.vmid       = vmid;
    r.vpmg       = Xt[11:0];

    MLBI(r);

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mlbi.MLBI"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mlbi/MLBI</h3>
      <p class="pseudocode">// MLBI()
// ======
// Invalidates MLB entries.

impdef func MLBI(r : <a href="shared_pseudocode.html#type_MLBIRecord" title="">MLBIRecord</a>)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mlbi.MLBIOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mlbi/MLBIOp</h3>
      <p class="pseudocode">// MLBIOp
// ======

type <a id="type_MLBIOp"/>MLBIOp of enumeration {
    <a id="enum_MLBIOp_ALL"/>MLBIOp_ALL,
    <a id="enum_MLBIOp_VMALL"/>MLBIOp_VMALL,
    <a id="enum_MLBIOp_VPID"/>MLBIOp_VPID,
    <a id="enum_MLBIOp_VPMG"/>MLBIOp_VPMG,
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mlbi.MLBRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mlbi/MLBRecord</h3>
      <p class="pseudocode">// MLBRecord
// =========

type <a id="type_MLBIRecord"/>MLBIRecord of record {
    op : <a href="shared_pseudocode.html#type_MLBIOp" title="">MLBIOp</a>,
    security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>,
    vmid : bits(16),
    use_vmid : boolean,
    vpid : bits(12),
    vpmg : bits(12)

};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mlbi.NewMLBIRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mlbi/NewMLBIRecord</h3>
      <p class="pseudocode">// NewMLBIRecord()
// ===============

func <a id="func_NewMLBIRecord_1"/>NewMLBIRecord(op : <a href="shared_pseudocode.html#type_MLBIOp" title="">MLBIOp</a>) =&gt; <a href="shared_pseudocode.html#type_MLBIRecord" title="">MLBIRecord</a>
begin
    var r : <a href="shared_pseudocode.html#type_MLBIRecord" title="">MLBIRecord</a>;
    r.op         = op;
    r.use_vmid   = FALSE;
    r.vmid       = Zeros{16};
    r.vpid       = Zeros{12};
    r.vpmg       = Zeros{12};

    return r;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.ArchMaxMOPSBlockSize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/ArchMaxMOPSBlockSize</h3>
      <p class="pseudocode">// ArchMaxMOPSBlockSize
// ====================
// Maximum number of bytes CPY/SET instructions can use

constant <a id="global_ArchMaxMOPSBlockSize"/>ArchMaxMOPSBlockSize : integer{} = 0x7FFF_FFFF_FFFF_FFFF;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.ArchMaxMOPSCPYSize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/ArchMaxMOPSCPYSize</h3>
      <p class="pseudocode">// ArchMaxMOPSCPYSize
// ==================
// Maximum number of bytes CPY instructions can use

constant <a id="global_ArchMaxMOPSCPYSize"/>ArchMaxMOPSCPYSize : integer{} = 0x007F_FFFF_FFFF_FFFF;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.ArchMaxMOPSSETGSize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/ArchMaxMOPSSETGSize</h3>
      <p class="pseudocode">// ArchMaxMOPSSETGSize
// ===================
// Maximum number of bytes SETG instructions can use

constant <a id="global_ArchMaxMOPSSETGSize"/>ArchMaxMOPSSETGSize : integer{} = 0x7FFF_FFFF_FFFF_FFF0;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYFOptionA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYFOptionA</h3>
      <p class="pseudocode">// CPYFOptionA()
// =============
// Returns TRUE if the implementation uses Option A for the
// CPYF* instructions, and FALSE otherwise.

func <a id="func_CPYFOptionA_0"/>CPYFOptionA() =&gt; boolean
begin
    return ImpDefBool("CPYF* instructions use Option A");
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYOptionA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYOptionA</h3>
      <p class="pseudocode">// CPYOptionA()
// ============
// Returns TRUE if the implementation uses Option A for the
// CPY* instructions, and FALSE otherwise.

func <a id="func_CPYOptionA_0"/>CPYOptionA() =&gt; boolean
begin
    return ImpDefBool("CPY* instructions use Option A");
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYParams</h3>
      <p class="pseudocode">// CPYParams
// =========

type CPYParams of record {
    stage : <a href="shared_pseudocode.html#MOPSStage" title="type MOPSStage">MOPSStage</a>,
    implements_option_a : boolean,
    forward : boolean,
    cpysize : integer,
    stagecpysize : integer,
    toaddress : bits(64),
    fromaddress : bits(64),
    nzcv : bits(4),
    n : integer,
    d : integer,
    s : integer
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYPostSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYPostSizeChoice</h3>
      <p class="pseudocode">// CPYPostSizeChoice()
// ===================
// Returns the size of the copy that is performed by the CPYE* instructions for this
// implementation given the parameters of the destination, source and size of the copy.

impdef func <a id="func_CPYPostSizeChoice_1"/>CPYPostSizeChoice(memcpy : CPYParams) =&gt; integer
begin
    return ARBITRARY : integer;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYPreSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYPreSizeChoice</h3>
      <p class="pseudocode">// CPYPreSizeChoice()
// ==================
// Returns the size of the copy that is performed by the CPYP* instructions for this
// implementation given the parameters of the destination, source and size of the copy.

impdef func <a id="func_CPYPreSizeChoice_1"/>CPYPreSizeChoice(memcpy : CPYParams) =&gt; integer
begin
    return ARBITRARY : integer;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYSizeChoice</h3>
      <p class="pseudocode">// CPYSizeChoice()
// ===============
// Returns the size of the block this performed for an iteration of the copy given the
// parameters of the destination, source and size of the copy.

impdef func CPYSizeChoice(memcpy : CPYParams) =&gt; <a href="shared_pseudocode.html#MOPSBlockSize" title="type MOPSBlockSize">MOPSBlockSize</a>
begin
    return ARBITRARY : <a href="shared_pseudocode.html#MOPSBlockSize" title="type MOPSBlockSize">MOPSBlockSize</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CheckCPYConstrainedUnpredictable"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CheckCPYConstrainedUnpredictable</h3>
      <p class="pseudocode">// CheckCPYConstrainedUnpredictable()
// ==================================
// Check for CONSTRAINED UNPREDICTABLE behaviour in the CPY* and CPYF* instructions.

func CheckCPYConstrainedUnpredictable(n : integer, d : integer, s : integer)
begin
    if (s == n || s == d || n == d) then
        let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_MOPSOVERLAP" title="">Unpredictable_MOPSOVERLAP</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>, <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a>};
        case c of
            when <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a> =&gt;      Undefined();
            when <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a> =&gt;        ExecuteAsNOP();
        end;
    end;

    if (d == 31 || s == 31 || n == 31) then
        let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_MOPS_R31" title="">Unpredictable_MOPS_R31</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>, <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a>};
        case c of
            when <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a> =&gt;      Undefined();
            when <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a> =&gt;        ExecuteAsNOP();
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CheckMOPSEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CheckMOPSEnabled</h3>
      <p class="pseudocode">// CheckMOPSEnabled()
// ==================
// Check for EL0 and EL1 access to the CPY* and SET* instructions.

func CheckMOPSEnabled()
begin
    if (PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) &amp;&amp;
        (!<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().MSCEn == '0')) then
        Undefined();
    end;

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() &amp;&amp; SCTLR_EL1().MSCEn == '0' then
        Undefined();
    end;

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() &amp;&amp; SCTLR_EL2().MSCEn == '0' then
        Undefined();
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CheckMemCpyParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CheckMemCpyParams</h3>
      <p class="pseudocode">// CheckMemCpyParams()
// ===================
// Check if the parameters to a CPY* or CPYF* instruction are consistent with the
// PE state and well-formed.

func CheckMemCpyParams(memcpy : CPYParams, options : bits(4))
begin
    let from_epilogue : boolean = memcpy.stage == MOPSStage_Epilogue;

    // Check if this version is consistent with the state of the call.
    if ((memcpy.stagecpysize != 0 || <a href="shared_pseudocode.html#func_MemStageCpyZeroSizeCheck_0" title="">MemStageCpyZeroSizeCheck</a>()) &amp;&amp;
          (memcpy.cpysize != 0 || <a href="shared_pseudocode.html#func_MemCpyZeroSizeCheck_0" title="">MemCpyZeroSizeCheck</a>())) then
        let using_option_a : boolean = memcpy.nzcv[1] == '0';
        if memcpy.implements_option_a != using_option_a then
            let formatoption : bits(2) = '1':: (if memcpy.implements_option_a then '1' else '0');
            MismatchedMemCpyException(memcpy, options, formatoption);
        end;
    end;

    // Check if the parameters to this instruction are valid.
    if memcpy.stage == MOPSStage_Main then
        if <a href="shared_pseudocode.html#func_MemCpyParametersIllformedM_1" title="">MemCpyParametersIllformedM</a>(memcpy) then
            let formatoption : bits(2) = '0':: (if memcpy.implements_option_a then '1' else '0');
            MismatchedMemCpyException(memcpy, options, formatoption);
        end;
    else
        let postsize : integer = <a href="shared_pseudocode.html#func_CPYPostSizeChoice_1" title="">CPYPostSizeChoice</a>(memcpy);
        if memcpy.cpysize != postsize || <a href="shared_pseudocode.html#func_MemCpyParametersIllformedE_1" title="">MemCpyParametersIllformedE</a>(memcpy) then
            let formatoption : bits(2) = '0':: (if memcpy.implements_option_a then '1' else '0');
            MismatchedMemCpyException(memcpy, options, formatoption);
        end;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CheckMemSetParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CheckMemSetParams</h3>
      <p class="pseudocode">// CheckMemSetParams()
// ===================
// Check if the parameters to a SET* or SETG* instruction are consistent with the
// PE state and well-formed.

func CheckMemSetParams(memset : SETParams, options : bits(2))
begin
    let from_epilogue : boolean = memset.stage == MOPSStage_Epilogue;

    // Check if this version is consistent with the state of the call.
    if ((memset.stagesetsize != 0 || <a href="shared_pseudocode.html#func_MemStageSetZeroSizeCheck_0" title="">MemStageSetZeroSizeCheck</a>()) &amp;&amp;
          (memset.setsize != 0 || <a href="shared_pseudocode.html#func_MemSetZeroSizeCheck_0" title="">MemSetZeroSizeCheck</a>())) then
        let using_option_a : boolean = memset.nzcv[1] == '0';
        if memset.implements_option_a != using_option_a then
            let formatoption : bits(2) = '1':: (if memset.implements_option_a then '1' else '0');
            MismatchedMemSetException(memset, options, formatoption);
        end;
    end;

    // Check if the parameters to this instruction are valid.
    if memset.stage == MOPSStage_Main then
        if <a href="shared_pseudocode.html#func_MemSetParametersIllformedM_1" title="">MemSetParametersIllformedM</a>(memset) then
            let formatoption : bits(2) = '0':: (if memset.implements_option_a then '1' else '0');
            MismatchedMemSetException(memset, options, formatoption);
        end;
    else
        let postsize : integer = <a href="shared_pseudocode.html#func_SETPostSizeChoice_1" title="">SETPostSizeChoice</a>(memset);
        if memset.setsize != postsize || <a href="shared_pseudocode.html#func_MemSetParametersIllformedE_1" title="">MemSetParametersIllformedE</a>(memset) then
            let formatoption : bits(2) = '0':: (if memset.implements_option_a then '1' else '0');
            MismatchedMemSetException(memset, options, formatoption);
        end;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CheckSETConstrainedUnpredictable"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CheckSETConstrainedUnpredictable</h3>
      <p class="pseudocode">// CheckSETConstrainedUnpredictable()
// ==================================
// Check for CONSTRAINED UNPREDICTABLE behaviour in the SET* and SETG* instructions.

func CheckSETConstrainedUnpredictable(n : integer, d : integer, s : integer)
begin
    if (s == n || s == d || n == d) then
        let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_MOPSOVERLAP" title="">Unpredictable_MOPSOVERLAP</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>, <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a>};
        case c of
            when <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a> =&gt;      Undefined();
            when <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a> =&gt;        ExecuteAsNOP();
        end;
    end;

    if (d == 31 || n == 31) then
        let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_MOPS_R31" title="">Unpredictable_MOPS_R31</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>, <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a>};
        case c of
            when <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a> =&gt;      Undefined();
            when <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a> =&gt;        ExecuteAsNOP();
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.IsMemCpyForward"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/IsMemCpyForward</h3>
      <p class="pseudocode">// IsMemCpyForward()
// =================
// Returns TRUE if in a memcpy of size cpysize bytes from the source address fromaddress
// to destination address toaddress is done in the forward direction on this implementation.

func <a id="func_IsMemCpyForward_1"/>IsMemCpyForward(memcpy : CPYParams) =&gt; boolean
begin
    var forward : boolean;

    // Check for overlapping cases
    if ((UInt(memcpy.fromaddress[55:0]) &gt; UInt(memcpy.toaddress[55:0])) &amp;&amp;
          (UInt(memcpy.fromaddress[55:0]) &lt; UInt(ZeroExtend{64}(memcpy.toaddress[55:0]) +
             memcpy.cpysize))) then
        forward = TRUE;

    elsif ((UInt(memcpy.fromaddress[55:0]) &lt; UInt(memcpy.toaddress[55:0])) &amp;&amp;
             (UInt(ZeroExtend{64}(memcpy.fromaddress[55:0]) + memcpy.cpysize) &gt;
                UInt(memcpy.toaddress[55:0]))) then
        forward = FALSE;

    // Non-overlapping case
    else
        forward = ImpDefBool("CPY in the forward direction");
    end;

    return forward;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MOPSBlockSize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MOPSBlockSize</h3>
      <p class="pseudocode">// MOPSBlockSize
// ================

type <a id="MOPSBlockSize"/>MOPSBlockSize of integer{0..MaxMOPSBlockSize};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MOPSStage"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MOPSStage</h3>
      <p class="pseudocode">// MOPSStage
// =========

type <a id="MOPSStage"/>MOPSStage of enumeration { MOPSStage_Prologue, MOPSStage_Main, MOPSStage_Epilogue };</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MaxBlockSizeCopiedBytes"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MaxBlockSizeCopiedBytes</h3>
      <p class="pseudocode">// MaxBlockSizeCopiedBytes()
// =========================
// Returns the maximum number of bytes that can used in a single block of the copy.

func <a id="func_MaxBlockSizeCopiedBytes_0"/>MaxBlockSizeCopiedBytes() =&gt; integer
begin
    return ImpDefInt("Maximum bytes used in a single block of a copy");
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MaxMOPSBlockSize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MaxMOPSBlockSize</h3>
      <p class="pseudocode">// MaxMOPSBlockSize
// ================
// Maximum number of bytes CPY/SET instructions can use

config MaxMOPSBlockSize : integer{1..<a href="shared_pseudocode.html#global_ArchMaxMOPSBlockSize" title="">ArchMaxMOPSBlockSize</a>} = 64;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyBytes"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyBytes</h3>
      <p class="pseudocode">// MemCpyBytes()
// =============
// Copies 'bytes' bytes of memory from fromaddress to toaddress.
// The integer return parameter indicates the number of bytes copied. The boolean return parameter
// indicates if a Fault or Abort occurred on the write. The AddressDescriptor and PhysMemRetStatus
// parameters contain Fault or Abort information for the caller to handle.

func MemCpyBytes(toaddress : bits(64),
                 fromaddress : bits(64),
                 forward : boolean,
                 bytes : <a href="shared_pseudocode.html#MOPSBlockSize" title="type MOPSBlockSize">MOPSBlockSize</a>,
                 raccdesc : AccessDescriptor,
                 waccdesc : AccessDescriptor
                ) =&gt; (integer, boolean, AddressDescriptor, PhysMemRetStatus)
begin
    var rmemaddrdesc : AddressDescriptor;                 // AddressDescriptor for reads
    var rmemstatus : PhysMemRetStatus;                   // PhysMemRetStatus  for writes
    rmemaddrdesc.fault    = NoFault();
    rmemstatus.statuscode = Fault_None;

    var wmemaddrdesc : AddressDescriptor;                 // AddressDescriptor for writes
    var wmemstatus : PhysMemRetStatus;                   // PhysMemRetStatus  for writes
    wmemaddrdesc.fault    = NoFault();
    wmemstatus.statuscode = Fault_None;

    var value : bits(8*bytes);
    let aligned : boolean = TRUE;

    if forward then
        var read : integer  = 0;                          // Bytes read
        var write : integer = 0;                          // Bytes written

        // Read until all bytes are read or until a fault is encountered.
        while (read &lt; bytes &amp;&amp; !IsFault(rmemaddrdesc) &amp;&amp; !IsFault(rmemstatus))
                                            looplimit MaxMOPSBlockSize do
            (value[8 * read +:8], rmemaddrdesc, rmemstatus) = AArch64_MemSingleRead{8}(
                                                                            fromaddress + read,
                                                                            raccdesc, aligned);
            read = read + 1;
        end;

        // Ensure no UNKNOWN data is written.
        if IsFault(rmemaddrdesc) || IsFault(rmemstatus) then
            read = read - 1;
        end;

        // Write all bytes that were read or until a fault is encountered.
        while write &lt; read &amp;&amp; !IsFault(wmemaddrdesc) &amp;&amp; !IsFault(wmemstatus)
                                        looplimit MaxMOPSBlockSize  do
            (wmemaddrdesc, wmemstatus) = AArch64_MemSingleWrite{8}(toaddress + write,
                                                                waccdesc, aligned,
                                                                value[8 * write +:8]);
            write = write + 1;
        end;

        // Check all bytes were written.
        if IsFault(wmemaddrdesc) || IsFault(wmemstatus) then
            let fault_on_write : boolean = TRUE;
            return (write - 1, fault_on_write, wmemaddrdesc, wmemstatus);
        end;

        // Check all bytes were read.
        if IsFault(rmemaddrdesc) || IsFault(rmemstatus) then
            let fault_on_write : boolean = FALSE;
            return (read, fault_on_write, rmemaddrdesc, rmemstatus);
        end;

    else
        var read : integer  = bytes;                      // Bytes to read
        var write : integer = bytes;                      // Bytes to write

        // Read until all bytes are read or until a fault is encountered.
        while read &gt; 0 &amp;&amp; !IsFault(rmemaddrdesc) &amp;&amp; !IsFault(rmemstatus)
                                            looplimit MaxMOPSBlockSize do
            read = read - 1;
            (value[8 * read +:8], rmemaddrdesc, rmemstatus) = AArch64_MemSingleRead{8}(
                                                                            fromaddress + read,
                                                                            raccdesc, aligned);
        end;

        // Ensure no UNKNOWN data is written.
        if IsFault(rmemaddrdesc) || IsFault(rmemstatus) then
            read = read + 1;
        end;

        // Write all bytes that were read or until a fault is encountered.
        while write &gt; read &amp;&amp; !IsFault(wmemaddrdesc) &amp;&amp; !IsFault(wmemstatus)
                                                looplimit MaxMOPSBlockSize do
            write = write - 1;
            (wmemaddrdesc, wmemstatus) = AArch64_MemSingleWrite{8}(toaddress + write,
                                                                waccdesc, aligned,
                                                                value[8 * write +:8]);
        end;

        // Check all bytes were written.
        if IsFault(wmemaddrdesc) || IsFault(wmemstatus) then
            let fault_on_write : boolean = TRUE;
            return (bytes - (write + 1), fault_on_write, wmemaddrdesc, wmemstatus);
        end;

        // Check all bytes were read.
        if IsFault(rmemaddrdesc) || IsFault(rmemstatus) then
            let fault_on_write : boolean = FALSE;
            return (bytes - read, fault_on_write, rmemaddrdesc, rmemstatus);
        end;
    end;

    // Return any AddressDescriptor and PhysMemRetStatus.
    return (bytes, FALSE, wmemaddrdesc, wmemstatus);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyParametersIllformedE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyParametersIllformedE</h3>
      <p class="pseudocode">// MemCpyParametersIllformedE()
// ============================
// Returns TRUE if the inputs are not well formed (in terms of their size and/or alignment)
// for a CPYE* instruction for this implementation given the parameters of the destination,
// source and size of the copy.

impdef func <a id="func_MemCpyParametersIllformedE_1"/>MemCpyParametersIllformedE(memcpy : CPYParams) =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyParametersIllformedM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyParametersIllformedM</h3>
      <p class="pseudocode">// MemCpyParametersIllformedM()
// ============================
// Returns TRUE if the inputs are not well formed (in terms of their size and/or alignment)
// for a CPYM* instruction for this implementation given the parameters of the destination,
// source and size of the copy.

impdef func <a id="func_MemCpyParametersIllformedM_1"/>MemCpyParametersIllformedM(memcpy : CPYParams) =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyStageSize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyStageSize</h3>
      <p class="pseudocode">// MemCpyStageSize()
// =================
// Returns the number of bytes copied by the given stage of a CPY* or CPYF* instruction.

func <a id="func_MemCpyStageSize_1"/>MemCpyStageSize(memcpy : CPYParams) =&gt; integer
begin
    var stagecpysize : integer;

    if memcpy.stage == MOPSStage_Prologue then
        // IMP DEF selection of the amount covered by pre-processing.
        stagecpysize = <a href="shared_pseudocode.html#func_CPYPreSizeChoice_1" title="">CPYPreSizeChoice</a>(memcpy);
        assert stagecpysize == 0 || (stagecpysize &lt; 0) == (memcpy.cpysize &lt; 0);

        if memcpy.cpysize &gt; 0 then
            assert stagecpysize &lt;= memcpy.cpysize;
        else
            assert stagecpysize &gt;= memcpy.cpysize;
        end;

    else
        let postsize : integer = <a href="shared_pseudocode.html#func_CPYPostSizeChoice_1" title="">CPYPostSizeChoice</a>(memcpy);
        assert postsize == 0 || (postsize &lt; 0) == (memcpy.cpysize &lt; 0);

        if memcpy.stage == MOPSStage_Main then
            stagecpysize = memcpy.cpysize - postsize;
        else
            stagecpysize = postsize;
        end;
    end;

    return stagecpysize;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyZeroSizeCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyZeroSizeCheck</h3>
      <p class="pseudocode">// MemCpyZeroSizeCheck()
// =====================
// Returns TRUE if the implementation option is checked on a copy of size zero remaining.

func <a id="func_MemCpyZeroSizeCheck_0"/>MemCpyZeroSizeCheck() =&gt; boolean
begin
    return ImpDefBool("Implementation option is checked with a cpysize of 0");
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetBytes"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetBytes</h3>
      <p class="pseudocode">// MemSetBytes()
// =============
// Writes a byte of data to the given address 'bytes' times.
// The integer return parameter indicates the number of bytes set. The AddressDescriptor and
// PhysMemRetStatus parameters contain Fault or Abort information for the caller to handle.

func MemSetBytes(toaddress : bits(64), data : bits(8),
                 bytes : <a href="shared_pseudocode.html#MOPSBlockSize" title="type MOPSBlockSize">MOPSBlockSize</a>,
                 accdesc : AccessDescriptor) =&gt; (integer, AddressDescriptor, PhysMemRetStatus)
begin
    var memaddrdesc : AddressDescriptor;
    var memstatus : PhysMemRetStatus;
    memaddrdesc.fault    = NoFault();
    memstatus.statuscode = Fault_None;

    let aligned : boolean = TRUE;
    var write : integer   = 0;                            // Bytes written

    // Write until all bytes are written or a fault is encountered.
    while write &lt; bytes &amp;&amp; !IsFault(memaddrdesc) &amp;&amp; !IsFault(memstatus)
                                                looplimit MaxMOPSBlockSize do
        (memaddrdesc, memstatus) = AArch64_MemSingleWrite{8}(toaddress + write, accdesc,
                                                             aligned, data);
        write = write + 1;
    end;

    // Check all bytes were written.
    if IsFault(memaddrdesc) || IsFault(memstatus) then
        return (write - 1, memaddrdesc, memstatus);
    end;

    return (bytes, memaddrdesc, memstatus);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetParametersIllformedE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetParametersIllformedE</h3>
      <p class="pseudocode">// MemSetParametersIllformedE()
// ============================
// Returns TRUE if the inputs are not well formed (in terms of their size and/or
// alignment) for a SETE* or SETGE* instruction for this implementation given the
// parameters of the destination and size of the set.

impdef func <a id="func_MemSetParametersIllformedE_1"/>MemSetParametersIllformedE(memset : SETParams) =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetParametersIllformedM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetParametersIllformedM</h3>
      <p class="pseudocode">// MemSetParametersIllformedM()
// ============================
// Returns TRUE if the inputs are not well formed (in terms of their size and/or
// alignment) for a SETM* or SETGM* instruction for this implementation given the
// parameters of the destination and size of the copy.

impdef func <a id="func_MemSetParametersIllformedM_1"/>MemSetParametersIllformedM(memset : SETParams) =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetStageSize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetStageSize</h3>
      <p class="pseudocode">// MemSetStageSize()
// =================
// Returns the number of bytes set by the given stage of a SET* or SETG* instruction.

func <a id="func_MemSetStageSize_1"/>MemSetStageSize(memset : SETParams) =&gt; integer
begin
    var stagesetsize : integer;

    if memset.stage == MOPSStage_Prologue then
        // IMP DEF selection of the amount covered by pre-processing.
        stagesetsize = <a href="shared_pseudocode.html#func_SETPreSizeChoice_1" title="">SETPreSizeChoice</a>(memset);
        assert stagesetsize == 0 || (stagesetsize &lt; 0) == (memset.setsize &lt; 0);

        if memset.is_setg then assert stagesetsize[3:0] == '0000'; end;

        if memset.setsize &gt; 0 then
            assert stagesetsize &lt;= memset.setsize;
        else
            assert stagesetsize &gt;= memset.setsize;
        end;

    else
        let postsize : integer = <a href="shared_pseudocode.html#func_SETPostSizeChoice_1" title="">SETPostSizeChoice</a>(memset);
        assert postsize == 0 || (postsize &lt; 0) == (memset.setsize &lt; 0);
        if memset.is_setg then assert postsize[3:0] == '0000'; end;

        if memset.stage == MOPSStage_Main then
            stagesetsize = memset.setsize - postsize;
        else
            stagesetsize = postsize;
        end;
    end;

    return stagesetsize;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetTags"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetTags</h3>
      <p class="pseudocode">// MemSetTags()
// ============
// Write Allocation Tags for each Tag Granule in 'size'.
// The integer return parameter indicates the number of Tag Granules written. The
// AddressDescriptor and PhysMemRetStatus parameters contain Fault or Abort information for
// the caller to handle.

func <a id="func_MemSetTags_4"/>MemSetTags(toaddress : bits(64), tag : bits(4),
                size : integer, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
            ) =&gt; (integer, <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>)
begin
    assert IsAlignedSize{64}(toaddress, <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a>) &amp;&amp; size MOD <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a> == 0;

    var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    memaddrdesc.fault     = <a href="shared_pseudocode.html#func_NoFault_0" title="">NoFault</a>();
    memstatus.statuscode  = <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
    var tagstep : integer = size DIV <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a>;

    // Write until all tags are written or a fault is encountered.
    while tagstep &gt; 0 &amp;&amp; !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) &amp;&amp; !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus)
                                                looplimit <a href="shared_pseudocode.html#global_ArchMaxMOPSSETGSize" title="">ArchMaxMOPSSETGSize</a> DIV <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a> do
        let tagaddr : bits(64) = toaddress + (tagstep - 1) * <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a>;
        (memaddrdesc, memstatus) = <a href="shared_pseudocode.html#func_AArch64_MemTagWrite_3" title="">AArch64_MemTagWrite</a>(tagaddr, accdesc, tag);
        tagstep = tagstep - 1;
    end;

    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) || <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
        tagstep = tagstep + 1;
    end;

    let tags_written : integer = (size DIV <a href="shared_pseudocode.html#global_TAG_GRANULE" title="">TAG_GRANULE</a>) - tagstep;
    return (tags_written, memaddrdesc, memstatus);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetZeroSizeCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetZeroSizeCheck</h3>
      <p class="pseudocode">// MemSetZeroSizeCheck()
// =====================
// Returns TRUE if the implementation option is checked on a set of size zero remaining.

func <a id="func_MemSetZeroSizeCheck_0"/>MemSetZeroSizeCheck() =&gt; boolean
begin
    return ImpDefBool("Implementation option is checked with a setsize of 0");
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemStageCpyZeroSizeCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemStageCpyZeroSizeCheck</h3>
      <p class="pseudocode">// MemStageCpyZeroSizeCheck()
// ==========================
// Returns TRUE if the implementation option is checked on a stage copy of size zero remaining.

func <a id="func_MemStageCpyZeroSizeCheck_0"/>MemStageCpyZeroSizeCheck() =&gt; boolean
begin
    return (ImpDefBool(
            "Implementation option is checked with a stage cpysize of 0"));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemStageSetZeroSizeCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemStageSetZeroSizeCheck</h3>
      <p class="pseudocode">// MemStageSetZeroSizeCheck()
// ==========================
// Returns TRUE if the implementation option is checked on a stage set of size zero remaining.

func <a id="func_MemStageSetZeroSizeCheck_0"/>MemStageSetZeroSizeCheck() =&gt; boolean
begin
    return (ImpDefBool(
            "Implementation option is checked with a stage setsize of 0"));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MismatchedCpySetTargetEL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MismatchedCpySetTargetEL</h3>
      <p class="pseudocode">// MismatchedCpySetTargetEL()
// ==========================
// Return the target exception level for an Exception_MemCpyMemSet.

func <a id="func_MismatchedCpySetTargetEL_0"/>MismatchedCpySetTargetEL() =&gt; bits(2)
begin
    var target_el : bits(2);

    if UInt(PSTATE.EL) &gt; UInt(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        target_el = PSTATE.EL;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    elsif (PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
        <a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() &amp;&amp; HCRX_EL2().MCE2 == '1') then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    else
        target_el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    end;

    return target_el;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MismatchedMemCpyException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MismatchedMemCpyException</h3>
      <p class="pseudocode">// MismatchedMemCpyException()
// ===========================
// Generates an exception for a CPY* instruction if the version
// is inconsistent with the state of the call.

func MismatchedMemCpyException(memcpy : CPYParams, options : bits(4), formatoption : bits(2))
begin
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer                 = 0x0;
    let target_el : bits(2)                   = <a href="shared_pseudocode.html#func_MismatchedCpySetTargetEL_0" title="">MismatchedCpySetTargetEL</a>();

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_MemCpyMemSet" title="">Exception_MemCpyMemSet</a>);
    except.syndrome.iss[24]    = '0';
    except.syndrome.iss[23]    = '0';
    except.syndrome.iss[22:19] = options;
    except.syndrome.iss[18]    = if memcpy.stage == MOPSStage_Epilogue then '1' else '0';
    except.syndrome.iss[17:16] = formatoption;
    // exception.syndrome[15] is RES0.
    except.syndrome.iss[14:10] = memcpy.d[4:0];
    except.syndrome.iss[9:5]   = memcpy.s[4:0];
    except.syndrome.iss[4:0]   = memcpy.n[4:0];

    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MismatchedMemSetException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MismatchedMemSetException</h3>
      <p class="pseudocode">// MismatchedMemSetException()
// ===========================
// Generates an exception for a SET* instruction if the version
// is inconsistent with the state of the call.

func MismatchedMemSetException(memset : SETParams, options : bits(2), formatoption : bits(2))
begin
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;
    let target_el : bits(2) = <a href="shared_pseudocode.html#func_MismatchedCpySetTargetEL_0" title="">MismatchedCpySetTargetEL</a>();

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_MemCpyMemSet" title="">Exception_MemCpyMemSet</a>);
    except.syndrome.iss[24]    = '1';
    except.syndrome.iss[23]    = if memset.is_setg then '1' else '0';
    // exception.syndrome[22:21] is RES0.
    except.syndrome.iss[20:19] = options;
    except.syndrome.iss[18]    = if memset.stage == MOPSStage_Epilogue then '1' else '0';
    except.syndrome.iss[17:16] = formatoption;
    // exception.syndrome[15] is RES0.
    except.syndrome.iss[14:10] = memset.d[4:0];
    except.syndrome.iss[9:5]   = memset.s[4:0];
    except.syndrome.iss[4:0]   = memset.n[4:0];

    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETGOptionA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETGOptionA</h3>
      <p class="pseudocode">// SETGOptionA()
// =============
// Returns TRUE if the implementation uses Option A for the
// SETG* instructions, and FALSE otherwise.

func <a id="func_SETGOptionA_0"/>SETGOptionA() =&gt; boolean
begin
    return ImpDefBool("SETG* instructions use Option A");
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETOptionA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETOptionA</h3>
      <p class="pseudocode">// SETOptionA()
// ============
// Returns TRUE if the implementation uses Option A for the
// SET* instructions, and FALSE otherwise.

func <a id="func_SETOptionA_0"/>SETOptionA() =&gt; boolean
begin
    return ImpDefBool("SET* instructions use Option A");
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETParams</h3>
      <p class="pseudocode">// SETParams
// =========

type SETParams of record {
    stage : <a href="shared_pseudocode.html#MOPSStage" title="type MOPSStage">MOPSStage</a>,
    implements_option_a : boolean,
    is_setg : boolean,
    setsize : integer,
    stagesetsize : integer,
    toaddress : bits(64),
    nzcv : bits(4),
    n : integer,
    d : integer,
    s : integer
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETPostSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETPostSizeChoice</h3>
      <p class="pseudocode">// SETPostSizeChoice()
// ===================
// Returns the size of the set that is performed by the SETE* or SETGE* instructions
// for this implementation, given the parameters of the destination and size of the set.

impdef func <a id="func_SETPostSizeChoice_1"/>SETPostSizeChoice(memset : SETParams) =&gt; integer
begin
    return ARBITRARY : integer;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETPreSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETPreSizeChoice</h3>
      <p class="pseudocode">// SETPreSizeChoice()
// ==================
// Returns the size of the set that is performed by the SETP* or SETGP* instructions
// for this implementation, given the parameters of the destination and size of the set.

impdef func <a id="func_SETPreSizeChoice_1"/>SETPreSizeChoice(memset : SETParams) =&gt; integer
begin
    return ARBITRARY : integer;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETSizeChoice</h3>
      <p class="pseudocode">// SETSizeChoice()
// ===============
// Returns the size of the block this performed for an iteration of the set given
// the parameters of the destination and size of the set. The size of the block
// is an integer multiple of alignsize.

impdef func SETSizeChoice(memset : SETParams, alignsize : integer) =&gt; <a href="shared_pseudocode.html#MOPSBlockSize" title="type MOPSBlockSize">MOPSBlockSize</a>
begin
    return ARBITRARY : <a href="shared_pseudocode.html#MOPSBlockSize" title="type MOPSBlockSize">MOPSBlockSize</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.UpdateCpyRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/UpdateCpyRegisters</h3>
      <p class="pseudocode">// UpdateCpyRegisters()
// ====================
// Performs updates to the X[n], X[d], and X[s] registers, as appropriate, for the CPY* and CPYF*
// instructions. When fault is TRUE, the values correspond to the first element not copied,
// such that a return to the instruction will enable a resumption of the copy.

func UpdateCpyRegisters(memcpy : CPYParams, fault : boolean, copied : integer)
begin
    if fault then
        if memcpy.stage == MOPSStage_Prologue then
            // Undo any formatting of the input parameters performed in the prologue.
            if memcpy.implements_option_a then
                if memcpy.forward then
                    // cpysize is negative.
                    let cpysize : integer  = memcpy.cpysize + copied;
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.n)  = (0 - cpysize)[63:0];
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.d)  = memcpy.toaddress   + cpysize;
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.s)  = memcpy.fromaddress + cpysize;

                else
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.n) = (memcpy.cpysize - copied)[63:0];
                end;

            else
                if memcpy.forward then
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.n) = (memcpy.cpysize - copied)[63:0];
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.d) = memcpy.toaddress   + copied;
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.s) = memcpy.fromaddress + copied;

                else
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.n)  = (memcpy.cpysize - copied)[63:0];
                end;
            end;

        else
            if memcpy.implements_option_a then
                if memcpy.forward then
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.n) = (memcpy.cpysize + copied)[63:0];
                else
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.n) = (memcpy.cpysize - copied)[63:0];
                end;

            else
                <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.n) = (memcpy.cpysize - copied)[63:0];

                if memcpy.forward then
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.d) = memcpy.toaddress   + copied;
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.s) = memcpy.fromaddress + copied;
                else
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.d) = memcpy.toaddress   - copied;
                    <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.s) = memcpy.fromaddress - copied;
                end;
            end;
        end;
    else
        <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.n) = memcpy.cpysize[63:0];
        if memcpy.stage == MOPSStage_Prologue || !memcpy.implements_option_a then
            <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.d) = memcpy.toaddress;
            <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memcpy.s) = memcpy.fromaddress;
        end;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.UpdateSetRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/UpdateSetRegisters</h3>
      <p class="pseudocode">// UpdateSetRegisters()
// ====================
// Performs updates to the X[n] and X[d] registers, as appropriate, for the SET* and SETG*
// instructions. When fault is TRUE, the values correspond to the first element not set, such
// that a return to the instruction will enable a resumption of the memory set.

func UpdateSetRegisters(memset : SETParams, fault : boolean, memory_set : integer)
begin
    if fault then
        // Undo any formatting of the input parameters performed in the prologue.
        if memset.stage == MOPSStage_Prologue then
            if memset.implements_option_a then
                // setsize is negative.
                let setsize : integer = memset.setsize   + memory_set;
                <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memset.n) = (0 - setsize)[63:0];
                <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memset.d) = memset.toaddress + setsize;
            else
                <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memset.n) = (memset.setsize - memory_set)[63:0];
                <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memset.d) = memset.toaddress + memory_set;
            end;

        else
            if memset.implements_option_a then
                <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memset.n) = (memset.setsize + memory_set)[63:0];
            else
                <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memset.n) = (memset.setsize - memory_set)[63:0];
                <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memset.d) = memset.toaddress + memory_set;
            end;
        end;
    else
        <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memset.n) = memset.setsize[63:0];
        if memset.stage == MOPSStage_Prologue || !memset.implements_option_a then
            <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memset.d) = memset.toaddress;
        end;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.movewideop.MoveWideOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/movewideop/MoveWideOp</h3>
      <p class="pseudocode">// MoveWideOp
// ==========
// Move wide 16-bit immediate instruction types.

type <a id="MoveWideOp"/>MoveWideOp of enumeration {MoveWideOp_N, MoveWideOp_Z, MoveWideOp_K};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.movwpreferred.MoveWidePreferred"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/movwpreferred/MoveWidePreferred</h3>
      <p class="pseudocode">// MoveWidePreferred()
// ===================
//
// Return TRUE if a bitmask immediate encoding would generate an immediate
// value that could also be represented by a single MOVZ or MOVN instruction.
// Used as a condition for the preferred MOV&lt;-ORR alias.

func <a id="func_MoveWidePreferred_4"/>MoveWidePreferred(sf : bit, immN : bit, imms : bits(6), immr : bits(6)) =&gt; boolean
begin
    let s : integer = UInt(imms);
    let r : integer = UInt(immr);
    let width : integer = if sf == '1' then 64 else 32;

    // element size must equal total immediate size
    if sf == '1' &amp;&amp; (immN::imms) != '1xxxxxx' then
        return FALSE;
    end;
    if sf == '0' &amp;&amp; (immN::imms) != '00xxxxx' then
        return FALSE;
    end;

    // for MOVZ must contain no more than 16 ones
    if s &lt; 16 then
        // ones must not span halfword boundary when rotated
        return (-r MOD 16) &lt;= (15 - s);
    end;

    // for MOVN must contain no more than 16 zeros
    if s &gt;= width - 15 then
        // zeros must not span halfword boundary when rotated
        return (r MOD 16) &lt;= (s - (width - 15));
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpac.AddPAC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpac/AddPAC</h3>
      <p class="pseudocode">// AddPAC()
// ========
// Calculates the pointer authentication code for a 64-bit quantity and then
// inserts that into pointer authentication code field of that 64-bit quantity.

func <a id="func_AddPAC_4"/>AddPAC(ptr : bits(64), modifier : bits(64), K : bits(128), data : boolean) =&gt; bits(64)
begin
    let use_modifier2 : boolean = FALSE;
    return InsertPAC(ptr, modifier, Zeros{64}, use_modifier2, K, data);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpac.AddPAC2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpac/AddPAC2</h3>
      <p class="pseudocode">// AddPAC2()
// =========
// Calculates the pointer authentication code for a 64-bit quantity and then
// inserts that into pointer authentication code field of that 64-bit quantity.

func <a id="func_AddPAC2_5"/>AddPAC2(ptr : bits(64), modifier1 : bits(64), modifier2 : bits(64),
             K : bits(128), data : boolean) =&gt; bits(64)
begin
    let use_modifier2 : boolean = TRUE;
    return InsertPAC(ptr, modifier1, modifier2, use_modifier2, K, data);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpac.InsertPAC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpac/InsertPAC</h3>
      <p class="pseudocode">// InsertPAC()
// ===========
// Calculates the pointer authentication code for a 64-bit quantity and then
// inserts that into pointer authentication code field of that 64-bit quantity.

func InsertPAC(ptr : bits(64), modifier : bits(64), modifier2 : bits(64), use_modifier2 : boolean,
               K : bits(128), data : boolean) =&gt; bits(64)
begin
    var PAC : bits(64);
    var result : bits(64);
    var ext_ptr : bits(64);
    var extfield : bits(64);
    var selbit : bit;
    var bit55 : bit;
    let tbi : boolean = EffectiveTBI(ptr, !data, PSTATE.EL) == '1';
    let mtx : boolean = (IsFeatureImplemented(FEAT_MTE_NO_ADDRESS_TAGS) &amp;&amp;
                         EffectiveMTX(ptr, !data, PSTATE.EL) == '1');
    let top_bit : integer{} = if tbi then 55 else 63;
    let EL3_using_lva3 : boolean = (IsFeatureImplemented(FEAT_LVA3) &amp;&amp;
                                    TranslationRegime(PSTATE.EL) == Regime_EL3 &amp;&amp;
                                    AArch64_IASize(TCR_EL3().T0SZ) &gt; 52);
    let is_VA_56bit : boolean = (TranslationRegime(PSTATE.EL) == Regime_EL3 &amp;&amp;
                                 AArch64_IASize(TCR_EL3().T0SZ) == 56);

    // If tagged pointers are in use for a regime with two TTBRs, use bit[55] of
    // the pointer to select between upper and lower ranges, and preserve this.
    // This handles the awkward case where there is apparently no correct choice between
    // the upper and lower address range - ie an addr of 1xxxxxxx0... with TBI0=0 and TBI1=1
    // and 0xxxxxxx1 with TBI1=0 and TBI0=1:
    if PtrHasUpperAndLowerAddRanges() then
        assert S1TranslationRegime() IN {EL1, EL2};
        if S1TranslationRegime() == EL1 then
            // EL1 translation regime registers
            if data then
                if TCR_EL1().TBI1 == '1' || TCR_EL1().TBI0 == '1' then
                    selbit = ptr[55];
                else
                    selbit = ptr[63];
                end;
            else
                if ((TCR_EL1().TBI1 == '1' &amp;&amp; TCR_EL1().TBID1 == '0') ||
                    (TCR_EL1().TBI0 == '1' &amp;&amp; TCR_EL1().TBID0 == '0')) then
                    selbit = ptr[55];
                else
                    selbit = ptr[63];
                end;
            end;
        else
            // EL2 translation regime registers
            if data then
                if TCR_EL2().TBI1 == '1' || TCR_EL2().TBI0 == '1' then
                    selbit = ptr[55];
                else
                    selbit = ptr[63];
                end;
            else
                if ((TCR_EL2().TBI1 == '1' &amp;&amp; TCR_EL2().TBID1 == '0') ||
                    (TCR_EL2().TBI0 == '1' &amp;&amp; TCR_EL2().TBID0 == '0')) then
                    selbit = ptr[55];
                else
                    selbit = ptr[63];
                end;
            end;
        end;
    else selbit = if tbi then ptr[55] else ptr[63];
    end;

    if IsFeatureImplemented(FEAT_PAuth2) &amp;&amp; IsFeatureImplemented(FEAT_CONSTPACFIELD) then
        selbit = ptr[55];
    end;
    let bottom_PAC_bit : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = CalculateBottomPACBit(selbit);

    if EL3_using_lva3 then
        extfield = Replicate{64}('0');
    else
        extfield = Replicate{64}(selbit);
    end;

    // Compute the pointer authentication code for a ptr with good extension bits
    if tbi then
        if bottom_PAC_bit &lt;= 55 then
            ext_ptr = (ptr[63:56] ::
                   extfield[55:bottom_PAC_bit] :: ptr[bottom_PAC_bit-1:0]);
        else
            ext_ptr = ptr[63:56] :: ptr[55:0];
        end;
    elsif mtx then
        if bottom_PAC_bit &lt;= 55 then
            ext_ptr = (extfield[63:60] :: ptr[59:56] ::
                       extfield[55:bottom_PAC_bit] :: ptr[bottom_PAC_bit-1:0]);
        else
            ext_ptr = extfield[63:60] :: ptr[59:56] :: ptr[55:0];
        end;
    else
        ext_ptr =  extfield[63:bottom_PAC_bit] :: ptr[bottom_PAC_bit-1:0];
    end;

    if use_modifier2 then
        assert IsFeatureImplemented(FEAT_PAuth_LR);
        PAC = ComputePAC2(ext_ptr, modifier, modifier2, K[127:64], K[63:0]);
    else
        PAC = ComputePAC(ext_ptr, modifier, K[127:64], K[63:0]);
    end;

    if !IsFeatureImplemented(FEAT_PAuth2) then
        // If FEAT_PAuth2 is not implemented, the PAC is corrupted if the pointer does not have
        // a canonical VA.
        assert bottom_PAC_bit &lt;= 52;
        if !IsZero(ptr[top_bit:bottom_PAC_bit]) &amp;&amp; !IsOnes(ptr[top_bit:bottom_PAC_bit]) then
            if IsFeatureImplemented(FEAT_EPAC) then
                PAC = 0x0000000000000000[63:0];
            else
                PAC[top_bit-1] = NOT(PAC[top_bit-1]);
            end;
        end;
    end;

    // Preserve the determination between upper and lower address at bit[55] and insert PAC into
    // bits that are not used for the address or the tag(s).
    if !IsFeatureImplemented(FEAT_PAuth2) then
        assert (bottom_PAC_bit &lt;= 52);
        if tbi then
            result = ptr[63:56]::selbit::PAC[54:bottom_PAC_bit]::ptr[bottom_PAC_bit-1:0];
        else
            result = PAC[63:56]::selbit::PAC[54:bottom_PAC_bit]::ptr[bottom_PAC_bit-1:0];
        end;
    else
        if EL3_using_lva3 then
            // Bit 55 is an address bit (when VA size is 56-bits) or
            // used to store PAC (when VA size is less than 56-bits)
            if is_VA_56bit then
                bit55 = ptr[55];
            else
                bit55 = ptr[55] XOR PAC[55];
            end;
        else
            bit55 = selbit;
        end;
        if tbi then
            if bottom_PAC_bit &lt; 55 then
                result = (ptr[63:56]                               :: bit55 ::
                          (ptr[54:bottom_PAC_bit] XOR PAC[54:bottom_PAC_bit]) ::
                          ptr[bottom_PAC_bit-1:0]);
            else
                result = (ptr[63:56] :: bit55 :: ptr[54:0]);
            end;
        elsif mtx then
            if bottom_PAC_bit &lt; 55 then
                result = ((ptr[63:60] XOR PAC[63:60]) :: ptr[59:56] :: bit55 ::
                          (ptr[54:bottom_PAC_bit] XOR PAC[54:bottom_PAC_bit]) ::
                          ptr[bottom_PAC_bit-1:0]);
            else
                result = ((ptr[63:60] XOR PAC[63:60]) :: ptr[59:56] :: bit55 ::
                           ptr[54:0]);
            end;
        else
            if bottom_PAC_bit &lt; 55 then
                result = ((ptr[63:56] XOR PAC[63:56])              :: bit55 ::
                          (ptr[54:bottom_PAC_bit] XOR PAC[54:bottom_PAC_bit]) ::
                          ptr[bottom_PAC_bit-1:0]);
            else
                result = ((ptr[63:56] XOR PAC[63:56])              :: bit55 ::
                           ptr[54:0]);
            end;
        end;
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacda.AddPACDA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacda/AddPACDA</h3>
      <p class="pseudocode">// AddPACDA()
// ==========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of x, y and the
// APDAKey_EL1.

func <a id="func_AddPACDA_2"/>AddPACDA(x : bits(64), y : bits(64)) =&gt; bits(64)
begin
    let APDAKey_EL1 : bits(128) = APDAKeyHi_EL1()[63:0] :: APDAKeyLo_EL1()[63:0];
    if !<a href="shared_pseudocode.html#func_IsAPDAKeyEnabled_0" title="">IsAPDAKeyEnabled</a>() then
        return x;
    else
        return <a href="shared_pseudocode.html#func_AddPAC_4" title="">AddPAC</a>(x, y, APDAKey_EL1, TRUE);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacdb.AddPACDB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacdb/AddPACDB</h3>
      <p class="pseudocode">// AddPACDB()
// ==========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of x, y and the
// APDBKey_EL1.

func <a id="func_AddPACDB_2"/>AddPACDB(x : bits(64), y : bits(64)) =&gt; bits(64)
begin
    let APDBKey_EL1 : bits(128) = APDBKeyHi_EL1()[63:0] :: APDBKeyLo_EL1()[63:0];
    if !<a href="shared_pseudocode.html#func_IsAPDBKeyEnabled_0" title="">IsAPDBKeyEnabled</a>() then
        return x;
    else
        return <a href="shared_pseudocode.html#func_AddPAC_4" title="">AddPAC</a>(x, y, APDBKey_EL1, TRUE);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacga.AddPACGA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacga/AddPACGA</h3>
      <p class="pseudocode">// AddPACGA()
// ==========
// Returns a 64-bit value where the lower 32 bits are 0, and the upper 32 bits contain
// a 32-bit pointer authentication code which is derived using a cryptographic
// algorithm as a combination of x, y and the APGAKey_EL1.

func <a id="func_AddPACGA_2"/>AddPACGA(x : bits(64), y : bits(64)) =&gt; bits(64)
begin
    var TrapEL2 : boolean;
    let APGAKey_EL1 : bits(128) = APGAKeyHi_EL1()[63:0] :: APGAKeyLo_EL1()[63:0];

    var TrapEL3 : boolean;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            TrapEL2 = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().API == '0' &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>();
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            TrapEL2 = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;
    end;

    if TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndefPriority_0" title="">EL3SDDUndefPriority</a>() then
        Undefined();
    elsif TrapEL2 then
        TrapPACUse(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then
            Undefined();
        else
            TrapPACUse(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;
    else
        return <a href="shared_pseudocode.html#func_ComputePAC_4" title="">ComputePAC</a>(x, y, APGAKey_EL1[127:64], APGAKey_EL1[63:0])[63:32]::Zeros{32};
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacia.AddPACIA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacia/AddPACIA</h3>
      <p class="pseudocode">// AddPACIA()
// ==========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of x, y, and the
// APIAKey_EL1.

func <a id="func_AddPACIA_2"/>AddPACIA(x : bits(64), y : bits(64)) =&gt; bits(64)
begin
    let APIAKey_EL1 : bits(128) = APIAKeyHi_EL1()[63:0]::APIAKeyLo_EL1()[63:0];
    if !<a href="shared_pseudocode.html#func_IsAPIAKeyEnabled_0" title="">IsAPIAKeyEnabled</a>() then
        return x;
    else
        return <a href="shared_pseudocode.html#func_AddPAC_4" title="">AddPAC</a>(x, y, APIAKey_EL1, FALSE);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacia.AddPACIA2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacia/AddPACIA2</h3>
      <p class="pseudocode">// AddPACIA2()
// ===========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of x, y, z, and
// the APIAKey_EL1.

func <a id="func_AddPACIA2_3"/>AddPACIA2(x : bits(64), y : bits(64), z : bits(64)) =&gt; bits(64)
begin
    let APIAKey_EL1 : bits(128) = APIAKeyHi_EL1()[63:0]::APIAKeyLo_EL1()[63:0];
    if !<a href="shared_pseudocode.html#func_IsAPIAKeyEnabled_0" title="">IsAPIAKeyEnabled</a>() then
        return x;
    else
        return <a href="shared_pseudocode.html#func_AddPAC2_5" title="">AddPAC2</a>(x, y, z, APIAKey_EL1, FALSE);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacib.AddPACIB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacib/AddPACIB</h3>
      <p class="pseudocode">// AddPACIB()
// ==========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of x, y and the
// APIBKey_EL1.

func <a id="func_AddPACIB_2"/>AddPACIB(x : bits(64), y : bits(64)) =&gt; bits(64)
begin
    let APIBKey_EL1 : bits(128) = APIBKeyHi_EL1()[63:0] :: APIBKeyLo_EL1()[63:0];
    if !<a href="shared_pseudocode.html#func_IsAPIBKeyEnabled_0" title="">IsAPIBKeyEnabled</a>() then
        return x;
    else
        return <a href="shared_pseudocode.html#func_AddPAC_4" title="">AddPAC</a>(x, y, APIBKey_EL1, FALSE);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacib.AddPACIB2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacib/AddPACIB2</h3>
      <p class="pseudocode">// AddPACIB2()
// ===========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of x, y, z, and
// the APIBKey_EL1.

func <a id="func_AddPACIB2_3"/>AddPACIB2(x : bits(64), y : bits(64), z : bits(64)) =&gt; bits(64)
begin
    let APIBKey_EL1 : bits(128) = APIBKeyHi_EL1()[63:0] :: APIBKeyLo_EL1()[63:0];
    if !<a href="shared_pseudocode.html#func_IsAPIBKeyEnabled_0" title="">IsAPIBKeyEnabled</a>() then
        return x;
    else
        return <a href="shared_pseudocode.html#func_AddPAC2_5" title="">AddPAC2</a>(x, y, z, APIBKey_EL1, FALSE);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.auth.AArch64_PACFailException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/auth/AArch64_PACFailException</h3>
      <p class="pseudocode">// AArch64_PACFailException()
// ==========================
// Generates a PAC Fail Exception

func AArch64_PACFailException(syndrome : bits(2))
begin
    let route_to_el2 : boolean = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1';
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer = 0x0;

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a> = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_PACFail" title="">Exception_PACFail</a>);
    except.syndrome.iss[1:0]     = syndrome;
    except.syndrome.iss[24:2]    = Zeros{23};                // RES0

    if UInt(PSTATE.EL) &gt; UInt(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) then
        AArch64_TakeException(PSTATE.EL, except, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    else
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.auth.Auth"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/auth/Auth</h3>
      <p class="pseudocode">// Auth()
// ======
// Restores the upper bits of the address to be all zeros or all ones (based on the
// value of bit[55]) and computes and checks the pointer authentication code. If the
// check passes, then the restored address is returned. If the check fails, the
// second-top and third-top bits of the extension bits in the pointer authentication code
// field are corrupted to ensure that accessing the address will give a translation fault.

func <a id="func_Auth_6"/>Auth(ptr : bits(64), modifier : bits(64), K : bits(128), data : boolean, key_number : bit,
          is_combined : boolean) =&gt; bits(64)
begin
    let use_modifier2 : boolean = FALSE;
    return Authenticate(ptr, modifier, Zeros{64}, use_modifier2,
                        K, data, key_number, is_combined);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.auth.Auth2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/auth/Auth2</h3>
      <p class="pseudocode">// Auth2()
// =======
// Restores the upper bits of the address to be all zeros or all ones (based on the
// value of bit[55]) and computes and checks the pointer authentication code. If the
// check passes, then the restored address is returned. If the check fails, the
// second-top and third-top bits of the extension bits in the pointer authentication code
// field are corrupted to ensure that accessing the address will give a translation fault.

func <a id="func_Auth2_7"/>Auth2(ptr : bits(64), modifier1 : bits(64), modifier2 : bits(64), K : bits(128),
           data : boolean, key_number : bit, is_combined : boolean) =&gt; bits(64)
begin
    let use_modifier2 : boolean = TRUE;
    return Authenticate(ptr, modifier1, modifier2, use_modifier2, K, data, key_number, is_combined);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.auth.Authenticate"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/auth/Authenticate</h3>
      <p class="pseudocode">// Authenticate()
// ==============
// Restores the upper bits of the address to be all zeros or all ones (based on the
// value of bit[55]) and computes and checks the pointer authentication code. If the
// check passes, then the restored address is returned. If the check fails, the
// second-top and third-top bits of the extension bits in the pointer authentication code
// field are corrupted to ensure that accessing the address will give a translation fault.

func Authenticate(ptr : bits(64), modifier : bits(64), modifier2 : bits(64),
                  use_modifier2 : boolean, K : bits(128), data : boolean, key_number : bit,
                  is_combined : boolean) =&gt; bits(64)
begin
    var PAC : bits(64);
    var result : bits(64);
    var original_ptr : bits(64);
    var error_code : bits(2);
    var extfield : bits(64);

    // Reconstruct the extension field used of adding the PAC to the pointer
    let tbi : boolean = EffectiveTBI(ptr, !data, PSTATE.EL) == '1';
    let mtx : boolean = (IsFeatureImplemented(FEAT_MTE_NO_ADDRESS_TAGS) &amp;&amp;
                         EffectiveMTX(ptr, !data, PSTATE.EL) == '1');
    let bottom_PAC_bit : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = CalculateBottomPACBit(ptr[55]);
    let EL3_using_lva3 : boolean = (IsFeatureImplemented(FEAT_LVA3) &amp;&amp;
                                    TranslationRegime(PSTATE.EL) == Regime_EL3 &amp;&amp;
                                    AArch64_IASize(TCR_EL3().T0SZ) &gt; 52);
    let is_VA_56bit : boolean = (TranslationRegime(PSTATE.EL) == Regime_EL3 &amp;&amp;
                                 AArch64_IASize(TCR_EL3().T0SZ) == 56);
    if EL3_using_lva3 then
        extfield = Replicate{64}('0');
    else
        extfield = Replicate{64}(ptr[55]);
    end;

    if tbi then
        if bottom_PAC_bit &lt;= 55 then
            original_ptr = (ptr[63:56] ::
                            extfield[55:bottom_PAC_bit] :: ptr[bottom_PAC_bit-1:0]);
        else
            original_ptr = ptr[63:56] :: ptr[55:0];
        end;
    elsif mtx then
        if bottom_PAC_bit &lt;= 55 then
            original_ptr = (extfield[63:60] :: ptr[59:56] ::
                            extfield[55:bottom_PAC_bit] :: ptr[bottom_PAC_bit-1:0]);
        else
            original_ptr = extfield[63:60] :: ptr[59:56] :: ptr[55:0];
        end;
    else
        original_ptr =  extfield[63:bottom_PAC_bit] :: ptr[bottom_PAC_bit-1:0];
    end;

    if use_modifier2 then
        assert IsFeatureImplemented(FEAT_PAuth_LR);
        PAC = ComputePAC2(original_ptr, modifier, modifier2, K[127:64], K[63:0]);
    else
        PAC = ComputePAC(original_ptr, modifier, K[127:64], K[63:0]);
    end;
    // Check pointer authentication code
    if tbi then
        if !IsFeatureImplemented(FEAT_PAuth2) then
            assert (bottom_PAC_bit &lt;= 52);
            if PAC[54:bottom_PAC_bit] == ptr[54:bottom_PAC_bit] then
                result = original_ptr;
            else
                error_code = key_number::NOT(key_number);
                result = original_ptr[63:55]::error_code::original_ptr[52:0];
            end;
        else
            result = ptr;
            if EL3_using_lva3 &amp;&amp; !is_VA_56bit then
                result[55] = result[55] XOR PAC[55];
            end;
            if (bottom_PAC_bit &lt; 55) then
                result[54:bottom_PAC_bit] = result[54:bottom_PAC_bit] XOR PAC[54:bottom_PAC_bit];
            end;
            if (IsFeatureImplemented(FEAT_FPACCOMBINE) ||
                  (IsFeatureImplemented(FEAT_FPAC) &amp;&amp; !is_combined)) then
                if (EL3_using_lva3 &amp;&amp; !is_VA_56bit &amp;&amp; !IsZero(result[55:bottom_PAC_bit])) then
                    error_code = (if data then '1' else '0')::key_number;
                    AArch64_PACFailException(error_code);
                elsif (!EL3_using_lva3 &amp;&amp; (bottom_PAC_bit &lt; 55) &amp;&amp;
                         result[54:bottom_PAC_bit] !=
                         Replicate{55-bottom_PAC_bit}(result[55])) then
                    error_code = (if data then '1' else '0')::key_number;
                    AArch64_PACFailException(error_code);
                end;
            end;
        end;
    elsif mtx then
        assert IsFeatureImplemented(FEAT_PAuth2);
        result = ptr;
        if EL3_using_lva3 &amp;&amp; !is_VA_56bit then
            result[55] = result[55] XOR PAC[55];
        end;
        if (bottom_PAC_bit &lt; 55) then
            result[54:bottom_PAC_bit] = result[54:bottom_PAC_bit] XOR PAC[54:bottom_PAC_bit];
        end;
        result[63:60] = result[63:60] XOR PAC[63:60];
        if (IsFeatureImplemented(FEAT_FPACCOMBINE) ||
              (IsFeatureImplemented(FEAT_FPAC) &amp;&amp; !is_combined)) then
            if (EL3_using_lva3 &amp;&amp; !is_VA_56bit &amp;&amp;
                  (!IsZero(result[55:bottom_PAC_bit]) || !IsZero(result[63:60]))) then
                error_code = (if data then '1' else '0')::key_number;
                AArch64_PACFailException(error_code);
            elsif (!EL3_using_lva3 &amp;&amp; (bottom_PAC_bit &lt; 55) &amp;&amp;
                     (((result[54:bottom_PAC_bit] !=
                        Replicate{55-bottom_PAC_bit}(result[55]))) ||
                      (result[63:60] != Replicate{4}(result[55])))) then
                error_code = (if data then '1' else '0')::key_number;
                AArch64_PACFailException(error_code);
            end;
        end;
    else
        if !IsFeatureImplemented(FEAT_PAuth2) then
            assert (bottom_PAC_bit &lt;= 52);
            if PAC[54:bottom_PAC_bit] == ptr[54:bottom_PAC_bit] &amp;&amp; PAC[63:56] == ptr[63:56] then
                result = original_ptr;
            else
                error_code = key_number::NOT(key_number);
                result     = original_ptr[63]::error_code::original_ptr[60:0];
            end;
        else
            result = ptr;
            if EL3_using_lva3 &amp;&amp; !is_VA_56bit then
                result[55] = result[55] XOR PAC[55];
            end;
            if bottom_PAC_bit &lt; 55 then
                result[54:bottom_PAC_bit] = result[54:bottom_PAC_bit] XOR PAC[54:bottom_PAC_bit];
            end;
            result[63:56] = result[63:56] XOR PAC[63:56];
            if (IsFeatureImplemented(FEAT_FPACCOMBINE) ||
                  (IsFeatureImplemented(FEAT_FPAC) &amp;&amp; !is_combined)) then
                if (EL3_using_lva3 &amp;&amp; !IsZero(result[63:bottom_PAC_bit])) then
                    error_code = (if data then '1' else '0')::key_number;
                    AArch64_PACFailException(error_code);
                elsif (!EL3_using_lva3 &amp;&amp;
                         result[63:bottom_PAC_bit] !=
                         Replicate{64-bottom_PAC_bit}(result[55])) then
                    error_code = (if data then '1' else '0')::key_number;
                    AArch64_PACFailException(error_code);
                end;
            end;
        end;
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authda.AuthDA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authda/AuthDA</h3>
      <p class="pseudocode">// AuthDA()
// ========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of x, using the same
// algorithm and key as AddPACDA().

func <a id="func_AuthDA_3"/>AuthDA(x : bits(64), y : bits(64), is_combined : boolean) =&gt; bits(64)
begin
    let APDAKey_EL1 : bits(128) = APDAKeyHi_EL1()[63:0] :: APDAKeyLo_EL1()[63:0];
    if !<a href="shared_pseudocode.html#func_IsAPDAKeyEnabled_0" title="">IsAPDAKeyEnabled</a>() then
        return x;
    else
        return <a href="shared_pseudocode.html#func_Auth_6" title="">Auth</a>(x, y, APDAKey_EL1, TRUE, '0', is_combined);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authdb.AuthDB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authdb/AuthDB</h3>
      <p class="pseudocode">// AuthDB()
// ========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a
// pointer authentication code in the pointer authentication code field bits of x, using
// the same algorithm and key as AddPACDB().

func <a id="func_AuthDB_3"/>AuthDB(x : bits(64), y : bits(64), is_combined : boolean) =&gt; bits(64)
begin
    let APDBKey_EL1 : bits(128) = APDBKeyHi_EL1()[63:0] :: APDBKeyLo_EL1()[63:0];
    if !<a href="shared_pseudocode.html#func_IsAPDBKeyEnabled_0" title="">IsAPDBKeyEnabled</a>() then
        return x;
    else
        return <a href="shared_pseudocode.html#func_Auth_6" title="">Auth</a>(x, y, APDBKey_EL1, TRUE, '1', is_combined);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authia.AuthIA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authia/AuthIA</h3>
      <p class="pseudocode">// AuthIA()
// ========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of x, using the same
// algorithm and key as AddPACIA().

func <a id="func_AuthIA_3"/>AuthIA(x : bits(64), y : bits(64), is_combined : boolean) =&gt; bits(64)
begin
    let APIAKey_EL1 : bits(128) = APIAKeyHi_EL1()[63:0] :: APIAKeyLo_EL1()[63:0];
    if !<a href="shared_pseudocode.html#func_IsAPIAKeyEnabled_0" title="">IsAPIAKeyEnabled</a>() then
        return x;
    else
        return <a href="shared_pseudocode.html#func_Auth_6" title="">Auth</a>(x, y, APIAKey_EL1, FALSE, '0', is_combined);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authia.AuthIA2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authia/AuthIA2</h3>
      <p class="pseudocode">// AuthIA2()
// =========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of x, using the same
// algorithm and key as AddPACIA2().

func <a id="func_AuthIA2_4"/>AuthIA2(x : bits(64), y : bits(64), z : bits(64), is_combined : boolean) =&gt; bits(64)
begin
    let APIAKey_EL1 : bits(128) = APIAKeyHi_EL1()[63:0] :: APIAKeyLo_EL1()[63:0];
    if !<a href="shared_pseudocode.html#func_IsAPIAKeyEnabled_0" title="">IsAPIAKeyEnabled</a>() then
        return x;
    else
        return <a href="shared_pseudocode.html#func_Auth2_7" title="">Auth2</a>(x, y, z, APIAKey_EL1, FALSE, '0', is_combined);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authib.AuthIB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authib/AuthIB</h3>
      <p class="pseudocode">// AuthIB()
// ========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of x, using the same
// algorithm and key as AddPACIB().

func <a id="func_AuthIB_3"/>AuthIB(x : bits(64), y : bits(64), is_combined : boolean) =&gt; bits(64)
begin
    let APIBKey_EL1 : bits(128) = APIBKeyHi_EL1()[63:0] :: APIBKeyLo_EL1()[63:0];
    if !<a href="shared_pseudocode.html#func_IsAPIBKeyEnabled_0" title="">IsAPIBKeyEnabled</a>() then
        return x;
    else
        return <a href="shared_pseudocode.html#func_Auth_6" title="">Auth</a>(x, y, APIBKey_EL1, FALSE, '1', is_combined);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authib.AuthIB2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authib/AuthIB2</h3>
      <p class="pseudocode">// AuthIB2()
// =========
// Returns a 64-bit value containing x, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of x, using the same
// algorithm and key as AddPACIB2().

func <a id="func_AuthIB2_4"/>AuthIB2(x : bits(64), y : bits(64), z : bits(64), is_combined : boolean) =&gt; bits(64)
begin
    let APIBKey_EL1 : bits(128) = APIBKeyHi_EL1()[63:0] :: APIBKeyLo_EL1()[63:0];
    if !<a href="shared_pseudocode.html#func_IsAPIBKeyEnabled_0" title="">IsAPIBKeyEnabled</a>() then
        return x;
    else
        return <a href="shared_pseudocode.html#func_Auth2_7" title="">Auth2</a>(x, y, z, APIBKey_EL1, FALSE, '1', is_combined);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.calcbottompacbit.AArch64_PACEffectiveTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/calcbottompacbit/AArch64_PACEffectiveTxSZ</h3>
      <p class="pseudocode">// AArch64_PACEffectiveTxSZ()
// ==========================
// Compute the effective value for TxSZ used to determine the placement of the PAC field

func <a id="func_AArch64_PACEffectiveTxSZ_2"/>AArch64_PACEffectiveTxSZ(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>) =&gt; bits(6)
begin
    let s1maxtxsz : integer = <a href="shared_pseudocode.html#func_AArch64_MaxTxSZ_1" title="">AArch64_MaxTxSZ</a>(walkparams.tgx);
    let s1mintxsz : integer = <a href="shared_pseudocode.html#func_AArch64_S1MinTxSZ_2" title="">AArch64_S1MinTxSZ</a>(regime, walkparams);

    if <a href="shared_pseudocode.html#func_AArch64_S1TxSZFaults_2" title="">AArch64_S1TxSZFaults</a>(regime, walkparams) then
        if ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_RESTnSZ" title="">Unpredictable_RESTnSZ</a>) == <a href="shared_pseudocode.html#enum_Constraint_FORCE" title="">Constraint_FORCE</a> then
            if UInt(walkparams.txsz) &lt; s1mintxsz then
                return s1mintxsz[5:0];
            end;
            if UInt(walkparams.txsz) &gt; s1maxtxsz then
                return s1maxtxsz[5:0];
            end;
        end;
    elsif UInt(walkparams.txsz) &lt; s1mintxsz then
        return s1mintxsz[5:0];
    elsif UInt(walkparams.txsz) &gt; s1maxtxsz then
        return s1maxtxsz[5:0];
    end;

    return walkparams.txsz;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.calcbottompacbit.CalculateBottomPACBit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/calcbottompacbit/CalculateBottomPACBit</h3>
      <p class="pseudocode">// CalculateBottomPACBit()
// =======================

func CalculateBottomPACBit(top_bit : bit) =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    var regime : Regime;
    var walkparams : S1TTWParams;
    var bottom_PAC_bit : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;

    regime = TranslationRegime(PSTATE.EL);
    let ss : SecurityState = CurrentSecurityState();
    walkparams             = AArch64_GetS1TTWParams(regime, PSTATE.EL, ss, Replicate{64}(top_bit));
    bottom_PAC_bit         = ((64 - UInt(AArch64_PACEffectiveTxSZ(regime, walkparams)))
                               as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>);

    return bottom_PAC_bit;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.ComputePAC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/ComputePAC</h3>
      <p class="pseudocode">// ComputePAC()
// ============

func <a id="func_ComputePAC_4"/>ComputePAC(data : bits(64), modifier : bits(64), key0 : bits(64), key1 : bits(64)) =&gt; bits(64)
begin
    if IsFeatureImplemented(FEAT_PACIMP) then
        return <a href="shared_pseudocode.html#func_ComputePACIMPDEF_4" title="">ComputePACIMPDEF</a>(data, modifier, key0, key1);
    end;
    if IsFeatureImplemented(FEAT_PACQARMA3) then
        let isqarma3 : boolean = TRUE;
        return <a href="shared_pseudocode.html#func_ComputePACQARMA_5" title="">ComputePACQARMA</a>(data, modifier, key0, key1, isqarma3);
    end;
    if IsFeatureImplemented(FEAT_PACQARMA5) then
        let isqarma3 : boolean = FALSE;
        return <a href="shared_pseudocode.html#func_ComputePACQARMA_5" title="">ComputePACQARMA</a>(data, modifier, key0, key1, isqarma3);
    end;
    unreachable;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.ComputePAC2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/ComputePAC2</h3>
      <p class="pseudocode">// ComputePAC2()
// =============

func <a id="func_ComputePAC2_5"/>ComputePAC2(data : bits(64), modifier1 : bits(64), modifier2 : bits(64),
                 key0 : bits(64), key1 : bits(64)) =&gt; bits(64)
begin
    if IsFeatureImplemented(FEAT_PACIMP) then
        return <a href="shared_pseudocode.html#func_ComputePAC2IMPDEF_5" title="">ComputePAC2IMPDEF</a>(data, modifier1, modifier2, key0, key1);
    end;
    if IsFeatureImplemented(FEAT_PACQARMA3) then
        let isqarma3 : boolean = TRUE;
        return <a href="shared_pseudocode.html#func_ComputePAC2QARMA_6" title="">ComputePAC2QARMA</a>(data, modifier1, modifier2, key0, key1, isqarma3);
    end;
    if IsFeatureImplemented(FEAT_PACQARMA5) then
        let isqarma3 : boolean = FALSE;
        return <a href="shared_pseudocode.html#func_ComputePAC2QARMA_6" title="">ComputePAC2QARMA</a>(data, modifier1, modifier2, key0, key1, isqarma3);
    end;
    unreachable;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.ComputePAC2IMPDEF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/ComputePAC2IMPDEF</h3>
      <p class="pseudocode">// ComputePAC2IMPDEF()
// ===================
// Compute IMPLEMENTATION DEFINED cryptographic algorithm to be used for PAC calculation.

impdef func <a id="func_ComputePAC2IMPDEF_5"/>ComputePAC2IMPDEF(data : bits(64),
                              modifier1 : bits(64),
                              modifier2 : bits(64),
                              key0 : bits(64),
                              key1 : bits(64)) =&gt; bits(64)
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.ComputePAC2QARMA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/ComputePAC2QARMA</h3>
      <p class="pseudocode">// ComputePAC2QARMA()
// ==================

func <a id="func_ComputePAC2QARMA_6"/>ComputePAC2QARMA(data : bits(64),
                      modifier1 : bits(64),
                      modifier2 : bits(64),
                      key0 : bits(64),
                      key1 : bits(64),
                      isqarma3 : boolean) =&gt; bits(64)
begin
    let concat_modifiers : bits(64) = modifier2[36:5]::modifier1[35:4];
    return <a href="shared_pseudocode.html#func_ComputePACQARMA_5" title="">ComputePACQARMA</a>(data, concat_modifiers, key0, key1, isqarma3);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.ComputePACIMPDEF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/ComputePACIMPDEF</h3>
      <p class="pseudocode">// ComputePACIMPDEF()
// ==================
// Compute IMPLEMENTATION DEFINED cryptographic algorithm to be used for PAC calculation.

impdef func <a id="func_ComputePACIMPDEF_4"/>ComputePACIMPDEF(data : bits(64), modifier : bits(64),
                             key0 : bits(64), key1 : bits(64)) =&gt; bits(64)
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.ComputePACQARMA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/ComputePACQARMA</h3>
      <p class="pseudocode">// ComputePACQARMA()
// =================
// Compute QARMA3 or QARMA5 cryptographic algorithm for PAC calculation

func <a id="func_ComputePACQARMA_5"/>ComputePACQARMA(data : bits(64),
                     modifier : bits(64),
                     key0 : bits(64),
                     key1 : bits(64),
                     isqarma3 : boolean) =&gt; bits(64)
begin
    var workingval : bits(64);
    var runningmod : bits(64);
    var roundkey : bits(64);
    var modk0 : bits(64);
    let Alpha : bits(64) = 0xC0AC29B7C97C50DD[63:0];

    var iterations : integer;
    <a href="shared_pseudocode.html#global_RC" title="">RC</a>[[0]] = 0x0000000000000000[63:0];
    <a href="shared_pseudocode.html#global_RC" title="">RC</a>[[1]] = 0x13198A2E03707344[63:0];
    <a href="shared_pseudocode.html#global_RC" title="">RC</a>[[2]] = 0xA4093822299F31D0[63:0];

    if isqarma3 then
        iterations = 2;
    else // QARMA5
        iterations = 4;
        <a href="shared_pseudocode.html#global_RC" title="">RC</a>[[3]] = 0x082EFA98EC4E6C89[63:0];
        <a href="shared_pseudocode.html#global_RC" title="">RC</a>[[4]] = 0x452821E638D01377[63:0];
    end;

    modk0 = key0[0]::key0[63:2]::(key0[63] XOR key0[1]);
    runningmod = modifier;
    workingval = data XOR key0;

    for i = 0 to iterations do
        roundkey   = key1 XOR runningmod;
        workingval = workingval XOR roundkey;
        workingval = workingval XOR <a href="shared_pseudocode.html#global_RC" title="">RC</a>[[i]];
        if i &gt; 0 then
            workingval = <a href="shared_pseudocode.html#func_PACCellShuffle_1" title="">PACCellShuffle</a>(workingval);
            workingval = <a href="shared_pseudocode.html#func_PACMult_1" title="">PACMult</a>(workingval);
        end;
        if isqarma3 then
            workingval = <a href="shared_pseudocode.html#func_PACSub1_1" title="">PACSub1</a>(workingval);
        else
            workingval = <a href="shared_pseudocode.html#func_PACSub_1" title="">PACSub</a>(workingval);
        end;
        runningmod = <a href="shared_pseudocode.html#func_TweakShuffle_1" title="">TweakShuffle</a>(runningmod[63:0]);
    end;
    roundkey   = modk0 XOR runningmod;
    workingval = workingval XOR roundkey;
    workingval = <a href="shared_pseudocode.html#func_PACCellShuffle_1" title="">PACCellShuffle</a>(workingval);
    workingval = <a href="shared_pseudocode.html#func_PACMult_1" title="">PACMult</a>(workingval);
    if isqarma3 then
        workingval = <a href="shared_pseudocode.html#func_PACSub1_1" title="">PACSub1</a>(workingval);
    else
        workingval = <a href="shared_pseudocode.html#func_PACSub_1" title="">PACSub</a>(workingval);
    end;
    workingval = <a href="shared_pseudocode.html#func_PACCellShuffle_1" title="">PACCellShuffle</a>(workingval);
    workingval = <a href="shared_pseudocode.html#func_PACMult_1" title="">PACMult</a>(workingval);
    workingval = key1 XOR workingval;
    workingval = <a href="shared_pseudocode.html#func_PACCellInvShuffle_1" title="">PACCellInvShuffle</a>(workingval);
    if isqarma3 then
        workingval = <a href="shared_pseudocode.html#func_PACSub1_1" title="">PACSub1</a>(workingval);
    else
        workingval = <a href="shared_pseudocode.html#func_PACInvSub_1" title="">PACInvSub</a>(workingval);
    end;
    workingval = <a href="shared_pseudocode.html#func_PACMult_1" title="">PACMult</a>(workingval);
    workingval = <a href="shared_pseudocode.html#func_PACCellInvShuffle_1" title="">PACCellInvShuffle</a>(workingval);
    workingval = workingval XOR key0;
    workingval = workingval XOR runningmod;
    for i = 0 to iterations do
        if isqarma3 then
            workingval = <a href="shared_pseudocode.html#func_PACSub1_1" title="">PACSub1</a>(workingval);
        else
            workingval = <a href="shared_pseudocode.html#func_PACInvSub_1" title="">PACInvSub</a>(workingval);
        end;
        if i &lt; iterations then
            workingval = <a href="shared_pseudocode.html#func_PACMult_1" title="">PACMult</a>(workingval);
            workingval = <a href="shared_pseudocode.html#func_PACCellInvShuffle_1" title="">PACCellInvShuffle</a>(workingval);
        end;
        runningmod = <a href="shared_pseudocode.html#func_TweakInvShuffle_1" title="">TweakInvShuffle</a>(runningmod[63:0]);
        roundkey = key1 XOR runningmod;
        workingval = workingval XOR <a href="shared_pseudocode.html#global_RC" title="">RC</a>[[iterations-i]];
        workingval = workingval XOR roundkey;
        workingval = workingval XOR Alpha;
    end;
    workingval = workingval XOR modk0;

    return workingval;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACCellInvShuffle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACCellInvShuffle</h3>
      <p class="pseudocode">// PACCellInvShuffle()
// ===================

func <a id="func_PACCellInvShuffle_1"/>PACCellInvShuffle(indata : bits(64)) =&gt; bits(64)
begin
    var outdata : bits(64);
    outdata[3:0]   = indata[15:12];
    outdata[7:4]   = indata[27:24];
    outdata[11:8]  = indata[51:48];
    outdata[15:12] = indata[39:36];
    outdata[19:16] = indata[59:56];
    outdata[23:20] = indata[47:44];
    outdata[27:24] = indata[7:4];
    outdata[31:28] = indata[19:16];
    outdata[35:32] = indata[35:32];
    outdata[39:36] = indata[55:52];
    outdata[43:40] = indata[31:28];
    outdata[47:44] = indata[11:8];
    outdata[51:48] = indata[23:20];
    outdata[55:52] = indata[3:0];
    outdata[59:56] = indata[43:40];
    outdata[63:60] = indata[63:60];
    return outdata;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACCellShuffle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACCellShuffle</h3>
      <p class="pseudocode">// PACCellShuffle()
// ================

func <a id="func_PACCellShuffle_1"/>PACCellShuffle(indata : bits(64)) =&gt; bits(64)
begin
    var outdata : bits(64);
    outdata[3:0]   = indata[55:52];
    outdata[7:4]   = indata[27:24];
    outdata[11:8]  = indata[47:44];
    outdata[15:12] = indata[3:0];
    outdata[19:16] = indata[31:28];
    outdata[23:20] = indata[51:48];
    outdata[27:24] = indata[7:4];
    outdata[31:28] = indata[43:40];
    outdata[35:32] = indata[35:32];
    outdata[39:36] = indata[15:12];
    outdata[43:40] = indata[59:56];
    outdata[47:44] = indata[23:20];
    outdata[51:48] = indata[11:8];
    outdata[55:52] = indata[39:36];
    outdata[59:56] = indata[19:16];
    outdata[63:60] = indata[63:60];
    return outdata;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACInvSub"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACInvSub</h3>
      <p class="pseudocode">// PACInvSub()
// ===========

func <a id="func_PACInvSub_1"/>PACInvSub(Tinput : bits(64)) =&gt; bits(64)
begin
    // This is a 4-bit substitution from the PRINCE-family cipher
    var Toutput : bits(64);
    for i = 0 to 15 do
        case Tinput[i*:4] of
            when '0000' =&gt;  Toutput[i*:4] = '0101';
            when '0001' =&gt;  Toutput[i*:4] = '1110';
            when '0010' =&gt;  Toutput[i*:4] = '1101';
            when '0011' =&gt;  Toutput[i*:4] = '1000';
            when '0100' =&gt;  Toutput[i*:4] = '1010';
            when '0101' =&gt;  Toutput[i*:4] = '1011';
            when '0110' =&gt;  Toutput[i*:4] = '0001';
            when '0111' =&gt;  Toutput[i*:4] = '1001';
            when '1000' =&gt;  Toutput[i*:4] = '0010';
            when '1001' =&gt;  Toutput[i*:4] = '0110';
            when '1010' =&gt;  Toutput[i*:4] = '1111';
            when '1011' =&gt;  Toutput[i*:4] = '0000';
            when '1100' =&gt;  Toutput[i*:4] = '0100';
            when '1101' =&gt;  Toutput[i*:4] = '1100';
            when '1110' =&gt;  Toutput[i*:4] = '0111';
            when '1111' =&gt;  Toutput[i*:4] = '0011';
        end;
    end;
    return Toutput;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACMult"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACMult</h3>
      <p class="pseudocode">// PACMult()
// =========

func <a id="func_PACMult_1"/>PACMult(Sinput : bits(64)) =&gt; bits(64)
begin
    var t0 : bits(4);
    var t1 : bits(4);
    var t2 : bits(4);
    var t3 : bits(4);
    var Soutput : bits(64);

    for i = 0 to 3 do
        t0[3:0] = ROL(Sinput[((i+8))*:4], 1) XOR ROL(Sinput[((i+4))*:4], 2);
        t0[3:0] = t0[3:0] XOR ROL(Sinput[i*:4], 1);
        t1[3:0] = ROL(Sinput[((i+12))*:4], 1) XOR ROL(Sinput[((i+4))*:4], 1);
        t1[3:0] = t1[3:0] XOR ROL(Sinput[i*:4], 2);
        t2[3:0] = ROL(Sinput[((i+12))*:4], 2) XOR ROL(Sinput[((i+8))*:4], 1);
        t2[3:0] = t2[3:0] XOR ROL(Sinput[i*:4], 1);
        t3[3:0] = ROL(Sinput[((i+12))*:4], 1) XOR ROL(Sinput[((i+8))*:4], 2);
        t3[3:0] = t3[3:0] XOR ROL(Sinput[((i+4))*:4], 1);
        Soutput[i*:4] = t3[3:0];
        Soutput[((i+4))*:4] = t2[3:0];
        Soutput[((i+8))*:4] = t1[3:0];
        Soutput[((i+12))*:4] = t0[3:0];
    end;
    return Soutput;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACSub"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACSub</h3>
      <p class="pseudocode">// PACSub()
// ========

func <a id="func_PACSub_1"/>PACSub(Tinput : bits(64)) =&gt; bits(64)
begin
    // This is a 4-bit substitution from the PRINCE-family cipher
    var Toutput : bits(64);
    for i = 0 to 15 do
        case Tinput[i*:4] of
            when '0000' =&gt;  Toutput[i*:4] = '1011';
            when '0001' =&gt;  Toutput[i*:4] = '0110';
            when '0010' =&gt;  Toutput[i*:4] = '1000';
            when '0011' =&gt;  Toutput[i*:4] = '1111';
            when '0100' =&gt;  Toutput[i*:4] = '1100';
            when '0101' =&gt;  Toutput[i*:4] = '0000';
            when '0110' =&gt;  Toutput[i*:4] = '1001';
            when '0111' =&gt;  Toutput[i*:4] = '1110';
            when '1000' =&gt;  Toutput[i*:4] = '0011';
            when '1001' =&gt;  Toutput[i*:4] = '0111';
            when '1010' =&gt;  Toutput[i*:4] = '0100';
            when '1011' =&gt;  Toutput[i*:4] = '0101';
            when '1100' =&gt;  Toutput[i*:4] = '1101';
            when '1101' =&gt;  Toutput[i*:4] = '0010';
            when '1110' =&gt;  Toutput[i*:4] = '0001';
            when '1111' =&gt;  Toutput[i*:4] = '1010';
        end;
    end;
    return Toutput;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PacSub1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PacSub1</h3>
      <p class="pseudocode">// PacSub1()
// =========

func <a id="func_PACSub1_1"/>PACSub1(Tinput : bits(64)) =&gt; bits(64)
begin
    // This is a 4-bit substitution from Qarma sigma1
    var Toutput : bits(64);
    for i = 0 to 15 do
        case Tinput[i*:4] of
            when '0000' =&gt; Toutput[i*:4] = '1010';
            when '0001' =&gt; Toutput[i*:4] = '1101';
            when '0010' =&gt; Toutput[i*:4] = '1110';
            when '0011' =&gt; Toutput[i*:4] = '0110';
            when '0100' =&gt; Toutput[i*:4] = '1111';
            when '0101' =&gt; Toutput[i*:4] = '0111';
            when '0110' =&gt; Toutput[i*:4] = '0011';
            when '0111' =&gt; Toutput[i*:4] = '0101';
            when '1000' =&gt; Toutput[i*:4] = '1001';
            when '1001' =&gt; Toutput[i*:4] = '1000';
            when '1010' =&gt; Toutput[i*:4] = '0000';
            when '1011' =&gt; Toutput[i*:4] = '1100';
            when '1100' =&gt; Toutput[i*:4] = '1011';
            when '1101' =&gt; Toutput[i*:4] = '0001';
            when '1110' =&gt; Toutput[i*:4] = '0010';
            when '1111' =&gt; Toutput[i*:4] = '0100';
        end;
    end;
    return Toutput;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.RC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/RC</h3>
      <p class="pseudocode">// RC[]
// ====

var <a id="global_RC"/>RC : array [[5]] of bits(64);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.TweakCellInvRot"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/TweakCellInvRot</h3>
      <p class="pseudocode">// TweakCellInvRot()
// =================

func <a id="func_TweakCellInvRot_1"/>TweakCellInvRot(incell : bits(4)) =&gt; bits(4)
begin
    var outcell : bits(4);
    outcell[3] = incell[2];
    outcell[2] = incell[1];
    outcell[1] = incell[0];
    outcell[0] = incell[0] XOR incell[3];
    return outcell;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.TweakCellRot"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/TweakCellRot</h3>
      <p class="pseudocode">// TweakCellRot()
// ==============

func <a id="func_TweakCellRot_1"/>TweakCellRot(incell : bits(4)) =&gt; bits(4)
begin
    var outcell : bits(4);
    outcell[3] = incell[0] XOR incell[1];
    outcell[2] = incell[3];
    outcell[1] = incell[2];
    outcell[0] = incell[1];
    return outcell;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.TweakInvShuffle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/TweakInvShuffle</h3>
      <p class="pseudocode">// TweakInvShuffle()
// =================

func <a id="func_TweakInvShuffle_1"/>TweakInvShuffle(indata : bits(64)) =&gt; bits(64)
begin
    var outdata : bits(64);
    outdata[3:0]   = <a href="shared_pseudocode.html#func_TweakCellInvRot_1" title="">TweakCellInvRot</a>(indata[51:48]);
    outdata[7:4]   = indata[55:52];
    outdata[11:8]  = indata[23:20];
    outdata[15:12] = indata[27:24];
    outdata[19:16] = indata[3:0];
    outdata[23:20] = indata[7:4];
    outdata[27:24] = <a href="shared_pseudocode.html#func_TweakCellInvRot_1" title="">TweakCellInvRot</a>(indata[11:8]);
    outdata[31:28] = indata[15:12];
    outdata[35:32] = <a href="shared_pseudocode.html#func_TweakCellInvRot_1" title="">TweakCellInvRot</a>(indata[31:28]);
    outdata[39:36] = <a href="shared_pseudocode.html#func_TweakCellInvRot_1" title="">TweakCellInvRot</a>(indata[63:60]);
    outdata[43:40] = <a href="shared_pseudocode.html#func_TweakCellInvRot_1" title="">TweakCellInvRot</a>(indata[59:56]);
    outdata[47:44] = <a href="shared_pseudocode.html#func_TweakCellInvRot_1" title="">TweakCellInvRot</a>(indata[19:16]);
    outdata[51:48] = indata[35:32];
    outdata[55:52] = indata[39:36];
    outdata[59:56] = indata[43:40];
    outdata[63:60] = <a href="shared_pseudocode.html#func_TweakCellInvRot_1" title="">TweakCellInvRot</a>(indata[47:44]);
    return outdata;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.TweakShuffle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/TweakShuffle</h3>
      <p class="pseudocode">// TweakShuffle()
// ==============

func <a id="func_TweakShuffle_1"/>TweakShuffle(indata : bits(64)) =&gt; bits(64)
begin
    var outdata : bits(64);
    outdata[3:0]   = indata[19:16];
    outdata[7:4]   = indata[23:20];
    outdata[11:8]  = <a href="shared_pseudocode.html#func_TweakCellRot_1" title="">TweakCellRot</a>(indata[27:24]);
    outdata[15:12] = indata[31:28];
    outdata[19:16] = <a href="shared_pseudocode.html#func_TweakCellRot_1" title="">TweakCellRot</a>(indata[47:44]);
    outdata[23:20] = indata[11:8];
    outdata[27:24] = indata[15:12];
    outdata[31:28] = <a href="shared_pseudocode.html#func_TweakCellRot_1" title="">TweakCellRot</a>(indata[35:32]);
    outdata[35:32] = indata[51:48];
    outdata[39:36] = indata[55:52];
    outdata[43:40] = indata[59:56];
    outdata[47:44] = <a href="shared_pseudocode.html#func_TweakCellRot_1" title="">TweakCellRot</a>(indata[63:60]);
    outdata[51:48] = <a href="shared_pseudocode.html#func_TweakCellRot_1" title="">TweakCellRot</a>(indata[3:0]);
    outdata[55:52] = indata[7:4];
    outdata[59:56] = <a href="shared_pseudocode.html#func_TweakCellRot_1" title="">TweakCellRot</a>(indata[43:40]);
    outdata[63:60] = <a href="shared_pseudocode.html#func_TweakCellRot_1" title="">TweakCellRot</a>(indata[39:36]);
    return outdata;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.IsAPDAKeyEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/IsAPDAKeyEnabled</h3>
      <p class="pseudocode">// IsAPDAKeyEnabled()
// ==================
// Returns TRUE if authentication using the APDAKey_EL1 key is enabled.
// Otherwise, depending on the state of the PE, generate a trap, or return FALSE.

func <a id="func_IsAPDAKeyEnabled_0"/>IsAPDAKeyEnabled() =&gt; boolean
begin
    var TrapEL2 : boolean;
    var TrapEL3 : boolean;
    var Enable : bits(1);

    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            let IsEL1Regime : boolean = <a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1().EnDA else SCTLR_EL2().EnDA;
            if IsFeatureImplemented(FEAT_PAuth_EnhCtl) then
                Enable = Enable XOR (if IsEL1Regime then SCTLR2_EL1().EnDA2
                                                    else SCTLR2_EL2().EnDA2);
            end;
            TrapEL2 = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().API == '0' &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>();
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            Enable  = SCTLR_EL1().EnDA;
            TrapEL2 = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            Enable  = SCTLR_EL2().EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            Enable  = SCTLR_EL3().EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;
    end;

    if Enable == '0' then
        return FALSE;
    elsif TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndefPriority_0" title="">EL3SDDUndefPriority</a>() then
        Undefined();
    elsif TrapEL2 then
        TrapPACUse(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then
            Undefined();
        else
            TrapPACUse(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;
    else
        return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.IsAPDBKeyEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/IsAPDBKeyEnabled</h3>
      <p class="pseudocode">// IsAPDBKeyEnabled()
// ==================
// Returns TRUE if authentication using the APDBKey_EL1 key is enabled.
// Otherwise, depending on the state of the PE, generate a trap, or return FALSE.

func <a id="func_IsAPDBKeyEnabled_0"/>IsAPDBKeyEnabled() =&gt; boolean
begin
    var TrapEL2 : boolean;
    var TrapEL3 : boolean;
    var Enable : bits(1);

    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            let IsEL1Regime : boolean = <a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1().EnDB else SCTLR_EL2().EnDB;
            if IsFeatureImplemented(FEAT_PAuth_EnhCtl) then
                Enable = Enable XOR (if IsEL1Regime then SCTLR2_EL1().EnDB2
                                                    else SCTLR2_EL2().EnDB2);
            end;
            TrapEL2 = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().API == '0' &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>();
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            Enable  = SCTLR_EL1().EnDB;
            TrapEL2 = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            Enable  = SCTLR_EL2().EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            Enable  = SCTLR_EL3().EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;
    end;

    if Enable == '0' then
        return FALSE;
    elsif TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndefPriority_0" title="">EL3SDDUndefPriority</a>() then
        Undefined();
    elsif TrapEL2 then
        TrapPACUse(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then
            Undefined();
        else
            TrapPACUse(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;
    else
        return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.IsAPIAKeyEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/IsAPIAKeyEnabled</h3>
      <p class="pseudocode">// IsAPIAKeyEnabled()
// ==================
// Returns TRUE if authentication using the APIAKey_EL1 key is enabled.
// Otherwise, depending on the state of the PE, generate a trap, or return FALSE.

func <a id="func_IsAPIAKeyEnabled_0"/>IsAPIAKeyEnabled() =&gt; boolean
begin
    var TrapEL2 : boolean;
    var TrapEL3 : boolean;
    var Enable : bits(1);

    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            let IsEL1Regime : boolean = <a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1().EnIA else SCTLR_EL2().EnIA;
            if IsFeatureImplemented(FEAT_PAuth_EnhCtl) then
                Enable = Enable XOR (if IsEL1Regime then SCTLR2_EL1().EnIA2
                                                    else SCTLR2_EL2().EnIA2);
            end;
            TrapEL2 = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().API == '0' &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>();
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            Enable  = SCTLR_EL1().EnIA;
            TrapEL2 = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            Enable  = SCTLR_EL2().EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            Enable  = SCTLR_EL3().EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;
    end;

    if Enable == '0' then
        return FALSE;
    elsif TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndefPriority_0" title="">EL3SDDUndefPriority</a>() then
        Undefined();
    elsif TrapEL2 then
        TrapPACUse(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then
            Undefined();
        else
            TrapPACUse(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;
    else
        return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.IsAPIBKeyEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/IsAPIBKeyEnabled</h3>
      <p class="pseudocode">// IsAPIBKeyEnabled()
// ==================
// Returns TRUE if authentication using the APIBKey_EL1 key is enabled.
// Otherwise, depending on the state of the PE, generate a trap, or return FALSE.

func <a id="func_IsAPIBKeyEnabled_0"/>IsAPIBKeyEnabled() =&gt; boolean
begin
    var TrapEL2 : boolean;
    var TrapEL3 : boolean;
    var Enable : bits(1);

    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            let IsEL1Regime : boolean = <a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1().EnIB else SCTLR_EL2().EnIB;
            if IsFeatureImplemented(FEAT_PAuth_EnhCtl) then
                Enable = Enable XOR (if IsEL1Regime then SCTLR2_EL1().EnIB2
                                                    else SCTLR2_EL2().EnIB2);
            end;
            TrapEL2 = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().API == '0' &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>();
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            Enable  = SCTLR_EL1().EnIB;
            TrapEL2 = <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            Enable  = SCTLR_EL2().EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().API == '0';
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            Enable  = SCTLR_EL3().EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;
    end;

    if Enable == '0' then
        return FALSE;
    elsif TrapEL3 &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndefPriority_0" title="">EL3SDDUndefPriority</a>() then
        Undefined();
    elsif TrapEL2 then
        TrapPACUse(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
    elsif TrapEL3 then
        if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then
            Undefined();
        else
            TrapPACUse(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;
    else
        return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.IsPACMEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/IsPACMEnabled</h3>
      <p class="pseudocode">// IsPACMEnabled()
// ===============
// Returns TRUE if the effects of the PACM instruction are enabled, otherwise FALSE.

func <a id="func_IsPACMEnabled_0"/>IsPACMEnabled() =&gt; boolean
begin
    assert IsFeatureImplemented(FEAT_PAuth) &amp;&amp; IsFeatureImplemented(FEAT_PAuth_LR);

    if <a href="shared_pseudocode.html#func_IsTrivialPACMImplementation_0" title="">IsTrivialPACMImplementation</a>() then
        return FALSE;
    end;

    var enabled : boolean;

    // EL2 could force the behavior at EL1 and EL0 to NOP.
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        enabled = <a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() &amp;&amp; HCRX_EL2().PACMEn == '1';
    else
        enabled = TRUE;
    end;

    // Otherwise, the SCTLR2_ELx bit determines the behavior.
    if enabled then
        var enpacm_bit : bit;
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
                enpacm_bit = SCTLR2_EL3().EnPACM;
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
                enpacm_bit = if <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then SCTLR2_EL2().EnPACM else '0';
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
                enpacm_bit = if <a href="shared_pseudocode.html#func_IsSCTLR2EL1Enabled_0" title="">IsSCTLR2EL1Enabled</a>() then SCTLR2_EL1().EnPACM else '0';
            when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
                if <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
                    enpacm_bit = if <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then SCTLR2_EL2().EnPACM0 else '0';
                else
                    enpacm_bit = if <a href="shared_pseudocode.html#func_IsSCTLR2EL1Enabled_0" title="">IsSCTLR2EL1Enabled</a>() then SCTLR2_EL1().EnPACM0 else '0';
                end;
        end;
        enabled = enpacm_bit == '1';
    end;

    return enabled;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.IsTrivialPACMImplementation"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/IsTrivialPACMImplementation</h3>
      <p class="pseudocode">// IsTrivialPACMImplementation()
// =============================
// Returns TRUE if the PE has a trivial implementation of PACM.

func <a id="func_IsTrivialPACMImplementation_0"/>IsTrivialPACMImplementation() =&gt; boolean
begin
    return (IsFeatureImplemented(FEAT_PACIMP) &amp;&amp;
              ImpDefBool("Trivial PSTATE.PACM implementation"));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.PtrHasUpperAndLowerAddRanges"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/PtrHasUpperAndLowerAddRanges</h3>
      <p class="pseudocode">// PtrHasUpperAndLowerAddRanges()
// ==============================
// Returns TRUE if the pointer has upper and lower address ranges, FALSE otherwise.

func <a id="func_PtrHasUpperAndLowerAddRanges_0"/>PtrHasUpperAndLowerAddRanges() =&gt; boolean
begin
    let regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a> = <a href="shared_pseudocode.html#func_TranslationRegime_1" title="">TranslationRegime</a>(PSTATE.EL);

    return <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.strip.Strip"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/strip/Strip</h3>
      <p class="pseudocode">// Strip()
// =======
// Strip() returns a 64-bit value containing A, but replacing the pointer authentication
// code field bits with the extension of the address bits. This can apply to either
// instructions or data, where, as the use of tagged pointers is distinct, it might be
// handled differently.

func Strip(A : bits(64), data : boolean) =&gt; bits(64)
begin
    var original_ptr : bits(64);
    var extfield : bits(64);
    let tbi : boolean = EffectiveTBI(A, !data, PSTATE.EL) == '1';
    let mtx : boolean = (IsFeatureImplemented(FEAT_MTE_NO_ADDRESS_TAGS) &amp;&amp;
                            EffectiveMTX(A, !data, PSTATE.EL) == '1');
    let bottom_PAC_bit : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = CalculateBottomPACBit(A[55]);
    let EL3_using_lva3 : boolean = (IsFeatureImplemented(FEAT_LVA3) &amp;&amp;
                                       TranslationRegime(PSTATE.EL) == Regime_EL3 &amp;&amp;
                                       AArch64_IASize(TCR_EL3().T0SZ) &gt; 52);
    if EL3_using_lva3 then
        extfield = Replicate{64}('0');
    else
        extfield = Replicate{64}(A[55]);
    end;

    if tbi then
        if (bottom_PAC_bit &lt;= 55) then
            original_ptr = (A[63:56] ::
                            extfield[55:bottom_PAC_bit] :: A[bottom_PAC_bit-1:0]);
        else
            original_ptr = A[63:56] :: A[55:0];
        end;
    elsif mtx then
        if (bottom_PAC_bit &lt;= 55) then
            original_ptr = (extfield[63:60] :: A[59:56] ::
                            extfield[55:bottom_PAC_bit] :: A[bottom_PAC_bit-1:0]);
        else
            original_ptr = extfield[63:60] :: A[59:56] :: A[55:0];
        end;
    else
        original_ptr =  extfield[63:bottom_PAC_bit] :: A[bottom_PAC_bit-1:0];
    end;

    return original_ptr;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.trappacuse.TrapPACUse"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/trappacuse/TrapPACUse</h3>
      <p class="pseudocode">// TrapPACUse()
// ============
// Used for the trapping of the pointer authentication functions by higher exception
// levels.

noreturn func TrapPACUse(target_el : bits(2))
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(target_el) &amp;&amp; target_el !=  <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; UInt(target_el) &gt;= UInt(PSTATE.EL);

    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>;
    let vect_offset : integer = 0;
    except = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_PACTrap" title="">Exception_PACTrap</a>);
    AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.predictionrestrict.AArch64_RestrictPrediction"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/predictionrestrict/AArch64_RestrictPrediction</h3>
      <p class="pseudocode">// AArch64_RestrictPrediction()
// ============================
// Clear all predictions in the context.

func AArch64_RestrictPrediction(val : bits(64), restriction : <a href="shared_pseudocode.html#type_RestrictType" title="">RestrictType</a>)
begin

    var c : <a href="shared_pseudocode.html#type_ExecutionCntxt" title="">ExecutionCntxt</a>;
    let target_el : bits(2)    = val[25:24];

    // If the target EL is not implemented or the instruction is executed at an
    // EL lower than the specified level, the instruction is treated as a NOP.
    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(target_el) || UInt(target_el) &gt; UInt(PSTATE.EL) then ExecuteAsNOP(); end;

    let ns : bit  = val[26];
    let nse : bit = val[27];
    let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_TargetSecurityState_2" title="">TargetSecurityState</a>(ns, nse);

    // If the combination of Security state and Exception level is not implemented,
    // the instruction is treated as a NOP.
    if ss == <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> &amp;&amp; target_el != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then ExecuteAsNOP(); end;
    if !IsFeatureImplemented(FEAT_RME) &amp;&amp; target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; ss != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
        ExecuteAsNOP();
    end;

    c.security  = ss;
    c.target_el = target_el;

    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if (PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>()) || PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = FALSE;
            c.vmid          = <a href="shared_pseudocode.html#func_VMID_0" title="">VMID</a>();

        elsif (target_el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(target_el)) || target_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = val[48] == '1';
            c.vmid          = val[47:32];       // Only valid if  val[48] == '0';

        else
            c.is_vmid_valid = FALSE;
        end;
    else
        c.is_vmid_valid = FALSE;
    end;

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = FALSE;
        c.asid          = <a href="shared_pseudocode.html#func_ASID_0" title="">ASID</a>();

    elsif target_el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = val[16] == '1';
        c.asid          = val[15:0];            // Only valid if  val[16] == '0';

    else
        c.is_asid_valid = FALSE;
    end;

    c.restriction = restriction;
    RESTRICT_PREDICTIONS(c);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.prefetch.Prefetch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/prefetch/Prefetch</h3>
      <p class="pseudocode">// Prefetch()
// ==========

// Decode and execute the prefetch hint on ADDRESS specified by PRFOP

func Prefetch(address : bits(64), prfop : bits(5))
begin
    var hint : <a href="shared_pseudocode.html#PrefetchHint" title="type PrefetchHint">PrefetchHint</a>;
    var target : integer;
    var stream : boolean;

    case prfop[4:3] of
        when '00' =&gt; hint = Prefetch_READ;      // PLD: prefetch for load
        when '01' =&gt; hint = Prefetch_EXEC;      // PLI: preload instructions
        when '10' =&gt; hint = Prefetch_WRITE;     // PST: prepare for store
        when '11' =&gt; return;                    // unallocated hint
    end;
    target = UInt(prfop[2:1]);                  // target cache level
    stream = (prfop[0] != '0');                 // streaming (non-temporal)
    Hint_Prefetch(address, hint, target, stream);
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pstatefield.PSTATEField"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pstatefield/PSTATEField</h3>
      <p class="pseudocode">// PSTATEField
// ===========
// MSR (immediate) instruction destinations.

type <a id="type_PSTATEField"/>PSTATEField of enumeration {
                         <a id="enum_PSTATEField_DAIFSet"/>PSTATEField_DAIFSet, <a id="enum_PSTATEField_DAIFClr"/>PSTATEField_DAIFClr,
                         <a id="enum_PSTATEField_PAN"/>PSTATEField_PAN, // Armv8.1
                         <a id="enum_PSTATEField_UAO"/>PSTATEField_UAO, // Armv8.2
                         <a id="enum_PSTATEField_DIT"/>PSTATEField_DIT, // Armv8.4
                         <a id="enum_PSTATEField_SSBS"/>PSTATEField_SSBS,
                         <a id="enum_PSTATEField_TCO"/>PSTATEField_TCO, // Armv8.5
                         <a id="enum_PSTATEField_SVCRSM"/>PSTATEField_SVCRSM,
                         <a id="enum_PSTATEField_SVCRZA"/>PSTATEField_SVCRZA,
                         <a id="enum_PSTATEField_SVCRSMZA"/>PSTATEField_SVCRSMZA,
                         <a id="enum_PSTATEField_ALLINT"/>PSTATEField_ALLINT,
                         <a id="enum_PSTATEField_PM"/>PSTATEField_PM,
                         <a id="enum_PSTATEField_SP"/>PSTATEField_SP
                         };</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64_DelegatedSErrorTarget"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64_DelegatedSErrorTarget</h3>
      <p class="pseudocode">// AArch64_DelegatedSErrorTarget()
// ===============================
// Returns whether a delegated SError exception pended by SCR_EL3.VSE is masked,
// and the target Exception level of the delegated SError exception.

func <a id="func_AArch64_DelegatedSErrorTarget_0"/>AArch64_DelegatedSErrorTarget() =&gt; (boolean, bits(2))
begin
    assert IsFeatureImplemented(FEAT_E3DSE);
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() || PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
        return (TRUE, ARBITRARY : bits(2));
    end;

    let effective_amo : bit = <a href="shared_pseudocode.html#func_EffectiveHCR_AMO_0" title="">EffectiveHCR_AMO</a>();
    let effective_tge : bit = <a href="shared_pseudocode.html#func_EffectiveTGE_0" title="">EffectiveTGE</a>();

    // The exception is masked by software.
    var masked : boolean;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            masked = ((effective_tge == '0' &amp;&amp; effective_amo == '0') || PSTATE.A == '1');
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            masked = (effective_amo == '0' &amp;&amp; PSTATE.A == '1');
        otherwise =&gt;
            unreachable;
    end;

    // The exception might be disabled debug in the Security state indicated by
    // SCR_EL3().[NS, NSE] by external debug.
    let intdis : boolean = <a href="shared_pseudocode.html#func_ExternalDebugInterruptsDisabled_1" title="">ExternalDebugInterruptsDisabled</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);

    var target_el : bits(2) = ARBITRARY : bits(2);
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; effective_amo == '1' &amp;&amp; !intdis &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
        masked = FALSE;

    elsif (<a href="shared_pseudocode.html#func_EffectiveHCRX_EL2_TMEA_0" title="">EffectiveHCRX_EL2_TMEA</a>() == '1' &amp;&amp; !intdis &amp;&amp;
             ((PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; PSTATE.A == '1') ||
              (PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; masked &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>()))) then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
        masked = FALSE;

    elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        if !masked then target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>; end;

    else
        assert (PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> || (PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>()));
        if !masked then target_el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>; end;
    end;

    // External debug might disable the delegated exception for the target Exception level.
    if <a href="shared_pseudocode.html#func_ExternalDebugInterruptsDisabled_1" title="">ExternalDebugInterruptsDisabled</a>(target_el) then
        masked = TRUE;
        target_el = ARBITRARY : bits(2);
    end;

    return (masked, target_el);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64_ESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64_ESBOperation</h3>
      <p class="pseudocode">// AArch64_ESBOperation()
// ======================
// Perform the AArch64 ESB operation, either for ESB executed in AArch64 state, or for
// ESB in AArch32 state when SError interrupts are routed to an Exception level using
// AArch64

func AArch64_ESBOperation()
begin
    var target_el : bits(2);
    var masked : boolean;

    (masked, target_el) = <a href="shared_pseudocode.html#func_PhysicalSErrorTarget_0" title="">PhysicalSErrorTarget</a>();

    // Check for a masked Physical SError pending that can be synchronized
    // by an Error synchronization event.
    if masked &amp;&amp; <a href="shared_pseudocode.html#func_IsSynchronizablePhysicalSErrorPending_0" title="">IsSynchronizablePhysicalSErrorPending</a>() then
        // This function might be called for an interprocessing case, and INTdis is masking
        // the SError interrupt.
        if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>()) then
            var syndrome : bits(32) = Zeros{};
            syndrome[31]      = '1'; // A
            syndrome[15:0]    = <a href="shared_pseudocode.html#func_AArch32_PhysicalSErrorSyndrome_0" title="">AArch32_PhysicalSErrorSyndrome</a>();
            DISR()            = syndrome;
        else
            let implicit_esb : boolean = FALSE;
            let is_esb : boolean       = TRUE;
            var syndrome : bits(64)    = Zeros{};

            syndrome[31]   = '1'; // A
            syndrome[24:0] = <a href="shared_pseudocode.html#func_AArch64_PhysicalSErrorSyndrome_2" title="">AArch64_PhysicalSErrorSyndrome</a>(is_esb, implicit_esb);
            DISR_EL1()     = syndrome;
        end;
        ClearPendingPhysicalSError();               // Set ISR_EL1.A to 0
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64_EncodeAsyncErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64_EncodeAsyncErrorSyndrome</h3>
      <p class="pseudocode">// AArch64_EncodeAsyncErrorSyndrome()
// ==================================
// Return the encoding for specified ErrorState for an SError exception taken
// to AArch64 state.

func <a id="func_AArch64_EncodeAsyncErrorSyndrome_1"/>AArch64_EncodeAsyncErrorSyndrome(errorstate : <a href="shared_pseudocode.html#type_ErrorState" title="">ErrorState</a>) =&gt; bits(3)
begin
    case errorstate of
        when <a href="shared_pseudocode.html#enum_ErrorState_UC" title="">ErrorState_UC</a>  =&gt; return '000';
        when <a href="shared_pseudocode.html#enum_ErrorState_UEU" title="">ErrorState_UEU</a> =&gt; return '001';
        when <a href="shared_pseudocode.html#enum_ErrorState_UEO" title="">ErrorState_UEO</a> =&gt; return '010';
        when <a href="shared_pseudocode.html#enum_ErrorState_UER" title="">ErrorState_UER</a> =&gt; return '011';
        when <a href="shared_pseudocode.html#enum_ErrorState_CE" title="">ErrorState_CE</a>  =&gt; return '110';
        otherwise =&gt; unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64_EncodeSyncErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64_EncodeSyncErrorSyndrome</h3>
      <p class="pseudocode">// AArch64_EncodeSyncErrorSyndrome()
// =================================
// Return the encoding for specified ErrorState for a synchronous Abort
// exception taken to AArch64 state.

func <a id="func_AArch64_EncodeSyncErrorSyndrome_1"/>AArch64_EncodeSyncErrorSyndrome(errorstate : <a href="shared_pseudocode.html#type_ErrorState" title="">ErrorState</a>) =&gt; bits(2)
begin
    case errorstate of
        when <a href="shared_pseudocode.html#enum_ErrorState_UC" title="">ErrorState_UC</a>  =&gt; return '10';
        when <a href="shared_pseudocode.html#enum_ErrorState_UEU" title="">ErrorState_UEU</a> =&gt; return '10';    // UEU is reported as UC
        when <a href="shared_pseudocode.html#enum_ErrorState_UEO" title="">ErrorState_UEO</a> =&gt; return '11';
        when <a href="shared_pseudocode.html#enum_ErrorState_UER" title="">ErrorState_UER</a> =&gt; return '00';
        otherwise =&gt; unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64_PhysicalSErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64_PhysicalSErrorSyndrome</h3>
      <p class="pseudocode">// AArch64_PhysicalSErrorSyndrome()
// ================================
// Generate SError syndrome.

func <a id="func_AArch64_PhysicalSErrorSyndrome_2"/>AArch64_PhysicalSErrorSyndrome(is_esb : boolean, implicit_esb : boolean) =&gt; bits(25)
begin
    var syndrome : bits(25) = Zeros{};
    var target_el : bits(2);
    (-, target_el) = <a href="shared_pseudocode.html#func_PhysicalSErrorTarget_0" title="">PhysicalSErrorTarget</a>();

    if <a href="shared_pseudocode.html#func_ReportErrorAsUncategorized_0" title="">ReportErrorAsUncategorized</a>() then
        syndrome = Zeros{25};
    elsif <a href="shared_pseudocode.html#func_ReportErrorAsIMPDEF_0" title="">ReportErrorAsIMPDEF</a>() then
        syndrome[24]   = '1';                                             // IDS
        syndrome[23:0] = ImpDefBits{24}("IMPDEF ErrorState");
    else
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_GetPendingPhysicalSError_0" title="">GetPendingPhysicalSError</a>();
        let errorstate : <a href="shared_pseudocode.html#type_ErrorState" title="">ErrorState</a> = <a href="shared_pseudocode.html#func_PEErrorState_1" title="">PEErrorState</a>(fault);
        syndrome[24]    = '0';                                            // IDS
        if (!is_esb &amp;&amp; IsFeatureImplemented(FEAT_PFAR) &amp;&amp;
              !(<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
              (HCR_EL2().VM == '1' || HCR_EL2().DC == '1') &amp;&amp; target_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>)) then
            syndrome[14] = if <a href="shared_pseudocode.html#func_IsPFARValid_1" title="">IsPFARValid</a>(fault) then '1' else '0';
        end;
        syndrome[13]    = if implicit_esb then '1' else '0';              // IESB
        syndrome[12:10] = <a href="shared_pseudocode.html#func_AArch64_EncodeAsyncErrorSyndrome_1" title="">AArch64_EncodeAsyncErrorSyndrome</a>(errorstate);   // AET
        syndrome[9]     = fault.extflag;                                  // EA
        syndrome[5:0]   = '010001';                                       // DFSC
    end;

    return syndrome;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64_dESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64_dESBOperation</h3>
      <p class="pseudocode">// AArch64_dESBOperation()
// =======================
// Perform the AArch64 ESB operation for a pending delegated SError exception.

func AArch64_dESBOperation()
begin
    assert (IsFeatureImplemented(FEAT_E3DSE) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
    // When FEAT_E3DSE is implemented, SCR_EL3.DSE might inject a delegated SError exception.
    var dsei_pending, dsei_masked : boolean;
    dsei_pending = SCR_EL3().[EnDSE,DSE] == '11';
    (dsei_masked, -) = <a href="shared_pseudocode.html#func_AArch64_DelegatedSErrorTarget_0" title="">AArch64_DelegatedSErrorTarget</a>();
    if dsei_pending &amp;&amp; dsei_masked then
        var target : bits(64) = Zeros{};
        target[31] = '1';                  // A
        target[24:0] = VSESR_EL3()[24:0];
        VDISR_EL3() = target;
        ClearPendingDelegatedSError();
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64_vESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64_vESBOperation</h3>
      <p class="pseudocode">// AArch64_vESBOperation()
// =======================
// Perform the AArch64 ESB operation for an unmasked pending virtual SError exception.
// If FEAT_E3DSE is implemented and there is no unmasked virtual SError exception
// pending, then AArch64_dESBOperation() is called to perform the AArch64 ESB operation
// for a pending delegated SError exception.

func AArch64_vESBOperation()
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);

    // If physical SError exceptions are routed to EL2, and TGE is not set, then a virtual
    // SError exception might be pending.
    let vsei_pending : boolean = (<a href="shared_pseudocode.html#func_IsVirtualSErrorPending_0" title="">IsVirtualSErrorPending</a>() &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveTGE_0" title="">EffectiveTGE</a>() == '0' &amp;&amp;
                                 (<a href="shared_pseudocode.html#func_EffectiveHCR_AMO_0" title="">EffectiveHCR_AMO</a>() == '1' || <a href="shared_pseudocode.html#func_EffectiveHCRX_EL2_TMEA_0" title="">EffectiveHCRX_EL2_TMEA</a>() == '1'));
    let vsei_masked : boolean = PSTATE.A == '1' || <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() || <a href="shared_pseudocode.html#func_ExternalDebugInterruptsDisabled_1" title="">ExternalDebugInterruptsDisabled</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);

    // Check for a masked virtual SError pending
    if vsei_pending &amp;&amp; vsei_masked then
        // This function might be called for the interprocessing case, and INTdis is masking
        // the virtual SError exception.
        if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
            var target : bits(32) = Zeros{};
            target[31]    = '1';             // A
            target[15:14] = VDFSR()[15:14];  // AET
            target[12]    = VDFSR()[12];     // ExT
            target[9]     = TTBCR().EAE;     // LPAE
            if TTBCR().EAE == '1' then       // Long-descriptor format
                target[5:0]    = '010001'; // STATUS
            else                           // Short-descriptor format
                target[10,3:0] = '10110';  // FS
            end;
            VDISR() = target;
        else
            var target : bits(64) = Zeros{};
            target[31]   = '1';            // A
            target[24:0] = VSESR_EL2()[24:0];
            VDISR_EL2() = target;
        end;
        ClearPendingVirtualSError();
    elsif IsFeatureImplemented(FEAT_E3DSE) then
        AArch64_dESBOperation();
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.FirstRecordOfNode"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/FirstRecordOfNode</h3>
      <p class="pseudocode">// FirstRecordOfNode()
// ===================
// Return the first record in the node that contains the record n.

func <a id="func_FirstRecordOfNode_1"/>FirstRecordOfNode(n : integer) =&gt; integer
begin
    for q = n downto 0 do
        if <a href="shared_pseudocode.html#func_IsFirstRecordOfNode_1" title="">IsFirstRecordOfNode</a>(q) then return q; end;
    end;
    unreachable;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.IsCommonFaultInjectionImplemented"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/IsCommonFaultInjectionImplemented</h3>
      <p class="pseudocode">// IsCommonFaultInjectionImplemented()
// ===================================
// Check if the Common Fault Injection Model Extension is implemented by the node that owns this
// error record.

impdef func <a id="func_IsCommonFaultInjectionImplemented_1"/>IsCommonFaultInjectionImplemented(n : integer) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.IsCountableErrorsRecorded"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/IsCountableErrorsRecorded</h3>
      <p class="pseudocode">// IsCountableErrorsRecorded()
// ===========================
// Check whether Error record n records countable errors.

impdef func <a id="func_IsCountableErrorsRecorded_1"/>IsCountableErrorsRecorded(n : integer) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.IsErrorAddressIncluded"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/IsErrorAddressIncluded</h3>
      <p class="pseudocode">// IsErrorAddressIncluded()
// ========================
// Check whether Error record n includes an address associated with an error.

impdef func <a id="func_IsErrorAddressIncluded_1"/>IsErrorAddressIncluded(n : integer) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.IsErrorRecordImplemented"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/IsErrorRecordImplemented</h3>
      <p class="pseudocode">// IsErrorRecordImplemented()
// ==========================
// Is the error record n implemented

impdef func <a id="func_IsErrorRecordImplemented_1"/>IsErrorRecordImplemented(n : integer) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.IsFirstRecordOfNode"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/IsFirstRecordOfNode</h3>
      <p class="pseudocode">// IsFirstRecordOfNode()
// =====================
// Check if the record q is the first error record in its node.

impdef func <a id="func_IsFirstRecordOfNode_1"/>IsFirstRecordOfNode(q : integer) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.IsPFARValid"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/IsPFARValid</h3>
      <p class="pseudocode">// IsPFARValid()
// =============
// Determine if faulting PA can be reported.

impdef func <a id="func_IsPFARValid_1"/>IsPFARValid(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    return !<a href="shared_pseudocode.html#func_IsAsyncAbort_1" title="">IsAsyncAbort</a>(fault);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.IsSPMUCounterImplemented"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/IsSPMUCounterImplemented</h3>
      <p class="pseudocode">// IsSPMUCounterImplemented()
// ==========================
// Does the System PMU s implement the counter n.

impdef func <a id="func_IsSPMUCounterImplemented_2"/>IsSPMUCounterImplemented(s : integer, n : integer) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.rcw"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/rcw</h3>
      <p class="pseudocode">constant <a id="global_RCW64_PROTECTED_BIT"/>RCW64_PROTECTED_BIT : integer = 52;

constant <a id="global_RCW128_PROTECTED_BIT"/>RCW128_PROTECTED_BIT : integer = 114;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.rcw.ProtectionEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/rcw/ProtectionEnabled</h3>
      <p class="pseudocode">// ProtectionEnabled()
// ===================
// Returns TRUE if the ProtectedBit is
// enabled in the current Exception level.

func <a id="func_ProtectionEnabled_1"/>ProtectionEnabled(el : bits(2)) =&gt; boolean
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(el);
    let regime : bits(2) = <a href="shared_pseudocode.html#func_S1TranslationRegime_1" title="">S1TranslationRegime</a>(el);
    assert(!<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(regime));
    if (!<a href="shared_pseudocode.html#func_IsD128Enabled_1" title="">IsD128Enabled</a>(el)) then
        case regime of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
                return <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() &amp;&amp; TCR2_EL1().PnCH == '1';
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
                return <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() &amp;&amp; TCR2_EL2().PnCH == '1';
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
                return TCR_EL3().PnCH == '1';
        end;
    else
        return TRUE;
    end;
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.rcw.RCWCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/rcw/RCWCheck</h3>
      <p class="pseudocode">// RCWCheck()
// ==========
// Returns nzcv based on : if the new value for RCW/RCWS instructions satisfy RCW and/or RCWS checks
// Z is set to 1 if RCW checks fail
// C is set to 0 if RCWS checks fail

func <a id="func_RCWCheck_4"/>RCWCheck{N}(old : bits(N), new : bits(N), soft : boolean) =&gt; bits(4)
begin
    assert N IN {64,128};
    let protectedbit : integer = if N == 128 then <a href="shared_pseudocode.html#global_RCW128_PROTECTED_BIT" title="">RCW128_PROTECTED_BIT</a> else <a href="shared_pseudocode.html#global_RCW64_PROTECTED_BIT" title="">RCW64_PROTECTED_BIT</a>;
    var rcw_fail : boolean        = FALSE;
    var rcws_fail : boolean       = FALSE;
    var rcw_state_fail : boolean  = FALSE;
    var rcws_state_fail : boolean = FALSE;
    var rcw_mask_fail : boolean   = FALSE;
    var rcws_mask_fail : boolean  = FALSE;

    //Effective RCWMask calculation
    var rcwmask : bits(N) = RCWMASK_EL1()[N-1:0];
    if N == 64 then
        rcwmask[49:18] = Replicate{32}(rcwmask[17]);
        rcwmask[0] = '0';
    else
        rcwmask[55:17] = Replicate{39}(rcwmask[16]);
        rcwmask[126:125,120:119,107:101,90:56,1:0] = Zeros{48};
    end;

    //Effective RCWSMask calculation
    var rcwsoftmask : bits(N) = RCWSMASK_EL1()[N-1:0];
    if N == 64 then
        rcwsoftmask[49:18] = Replicate{32}(rcwsoftmask[17]);
        rcwsoftmask[0] = '0';
        if(<a href="shared_pseudocode.html#func_ProtectionEnabled_1" title="">ProtectionEnabled</a>(PSTATE.EL)) then
            rcwsoftmask[52] = '0';
        end;
    else
        rcwsoftmask[55:17] = Replicate{39}(rcwsoftmask[16]);
        rcwsoftmask[126:125,120:119,107:101,90:56,1:0] = Zeros{48};
        rcwsoftmask[114] = '0';
    end;

    //RCW Checks
    //State Check
    if (<a href="shared_pseudocode.html#func_ProtectionEnabled_1" title="">ProtectionEnabled</a>(PSTATE.EL)) then
        if old[protectedbit] == '1' then
            rcw_state_fail = new[protectedbit,0] != old[protectedbit,0];
        elsif old[protectedbit] == '0' then
            rcw_state_fail = new[protectedbit] != old[protectedbit];
        end;
    end;

    //Mask Check
    if (<a href="shared_pseudocode.html#func_ProtectionEnabled_1" title="">ProtectionEnabled</a>(PSTATE.EL)) then
        if old[protectedbit,0] == '11' then
            rcw_mask_fail = !IsZero((new XOR old) AND NOT(rcwmask));
        end;
    end;

    //RCWS Checks
    if soft then
        //State Check
        if old[0] == '1' then
            rcws_state_fail = new[0] != old[0];
        elsif (!<a href="shared_pseudocode.html#func_ProtectionEnabled_1" title="">ProtectionEnabled</a>(PSTATE.EL) ||
              (<a href="shared_pseudocode.html#func_ProtectionEnabled_1" title="">ProtectionEnabled</a>(PSTATE.EL) &amp;&amp; old[protectedbit] == '0')) then
            rcws_state_fail = new[0] != old[0] ;
        end;
        //Mask Check
        if old[0] == '1' then
            rcws_mask_fail = !IsZero((new XOR old) AND NOT(rcwsoftmask));
        end;
    end;

    rcw_fail = rcw_state_fail  || rcw_mask_fail ;
    rcws_fail = rcws_state_fail || rcws_mask_fail;

    let n : bit = '0';
    let z : bit = if rcw_fail then '1' else '0';
    let c : bit = if rcws_fail then '0' else '1';
    let v : bit = '0';
    return n::z::c::v;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.reduceop.FPReduce"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/reduceop/FPReduce</h3>
      <p class="pseudocode">// FPReduce()
// ==========
// Perform the floating-point operation 'op' on pairs of elements from the input vector,
// reducing the vector to a scalar result.

func <a id="func_FPReduce_5"/>FPReduce{esize, N}(op : <a href="shared_pseudocode.html#type_ReduceOp" title="">ReduceOp</a>, input : bits(N),
                        fpcr : FPCR_Type) =&gt; bits(esize) recurselimit 8
begin
    var hi : bits(esize);
    var lo : bits(esize);
    var result : bits(esize);
    let half : integer{} = N DIV 2;

    if N == esize then
        return input[esize-1:0];
    end;

    hi = <a href="shared_pseudocode.html#func_FPReduce_5" title="">FPReduce</a>{esize, (N - N DIV 2)}(op, input[N-1:half], fpcr);
    lo = <a href="shared_pseudocode.html#func_FPReduce_5" title="">FPReduce</a>{esize, N DIV 2}(op, input[half-1:0], fpcr);
    case op of
        when <a href="shared_pseudocode.html#enum_ReduceOp_FMINNUM" title="">ReduceOp_FMINNUM</a> =&gt;
            result = <a href="shared_pseudocode.html#func_FPMinNum_4" title="">FPMinNum</a>{esize}(lo, hi, fpcr);
        when <a href="shared_pseudocode.html#enum_ReduceOp_FMAXNUM" title="">ReduceOp_FMAXNUM</a> =&gt;
            result = <a href="shared_pseudocode.html#func_FPMaxNum_4" title="">FPMaxNum</a>{esize}(lo, hi, fpcr);
        when <a href="shared_pseudocode.html#enum_ReduceOp_FMIN" title="">ReduceOp_FMIN</a> =&gt;
            result = <a href="shared_pseudocode.html#func_FPMin_4" title="">FPMin</a>{esize}(lo, hi, fpcr);
        when <a href="shared_pseudocode.html#enum_ReduceOp_FMAX" title="">ReduceOp_FMAX</a> =&gt;
            result = <a href="shared_pseudocode.html#func_FPMax_4" title="">FPMax</a>{esize}(lo, hi, fpcr);
        when <a href="shared_pseudocode.html#enum_ReduceOp_FADD" title="">ReduceOp_FADD</a> =&gt;
            result = <a href="shared_pseudocode.html#func_FPAdd_4" title="">FPAdd</a>{esize}(lo, hi, fpcr);
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.reduceop.IntReduce"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/reduceop/IntReduce</h3>
      <p class="pseudocode">// IntReduce()
// ===========
// Perform the integer operation 'op' on pairs of elements from the input vector,
// reducing the vector to a scalar result.

func <a id="func_IntReduce_4"/>IntReduce{esize, N}(op : <a href="shared_pseudocode.html#type_ReduceOp" title="">ReduceOp</a>, input : bits(N)) =&gt; bits(esize) recurselimit 8
begin
    var hi : bits(esize);
    var lo : bits(esize);
    var result : bits(esize);
    let half : integer{} = N DIV 2;
    if N == esize then
        return input[esize-1:0];
    end;

    hi = <a href="shared_pseudocode.html#func_IntReduce_4" title="">IntReduce</a>{esize, (N - N DIV 2)}(op, input[N-1:half]);
    lo = <a href="shared_pseudocode.html#func_IntReduce_4" title="">IntReduce</a>{esize, N DIV 2}(op, input[half-1:0]);
    case op of
        when <a href="shared_pseudocode.html#enum_ReduceOp_ADD" title="">ReduceOp_ADD</a> =&gt;
            result = lo + hi;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.reduceop.ReduceOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/reduceop/ReduceOp</h3>
      <p class="pseudocode">// ReduceOp
// ========
// Vector reduce instruction types.

type <a id="type_ReduceOp"/>ReduceOp of enumeration {<a id="enum_ReduceOp_FMINNUM"/>ReduceOp_FMINNUM, <a id="enum_ReduceOp_FMAXNUM"/>ReduceOp_FMAXNUM,
                              <a id="enum_ReduceOp_FMIN"/>ReduceOp_FMIN, <a id="enum_ReduceOp_FMAX"/>ReduceOp_FMAX,
                              <a id="enum_ReduceOp_FADD"/>ReduceOp_FADD, <a id="enum_ReduceOp_ADD"/>ReduceOp_ADD};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64_MaybeZeroRegisterUppers"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64_MaybeZeroRegisterUppers</h3>
      <p class="pseudocode">// AArch64_MaybeZeroRegisterUppers()
// =================================
// On taking an exception to  AArch64 from AArch32, it is CONSTRAINED UNPREDICTABLE whether the top
// 32 bits of registers visible at any lower Exception level using AArch32 are set to zero.

func AArch64_MaybeZeroRegisterUppers()
begin
    assert <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();         // Always called from AArch32 state before entering AArch64 state

    var first : integer;
    var last : integer;
    var include_R15 : boolean;
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        first = 0;  last = 14;  include_R15 = FALSE;
    elsif PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        first = 0;  last = 30;  include_R15 = FALSE;
    else
        first = 0;  last = 30;  include_R15 = TRUE;
    end;

    for n = first to last do
        if (n != 15 || include_R15) &amp;&amp; <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_ZEROUPPER" title="">Unpredictable_ZEROUPPER</a>) then
            <a href="shared_pseudocode.html#global__R" title="">_R</a>[[n]][63:32] = Zeros{32};
        end;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64_ResetGeneralRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64_ResetGeneralRegisters</h3>
      <p class="pseudocode">// AArch64_ResetGeneralRegisters()
// ===============================

func AArch64_ResetGeneralRegisters()
begin

    for i = 0 to 30 do
        <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(i) = ARBITRARY : bits(64);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64_ResetSIMDFPRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64_ResetSIMDFPRegisters</h3>
      <p class="pseudocode">// AArch64_ResetSIMDFPRegisters()
// ==============================

func AArch64_ResetSIMDFPRegisters()
begin

    for i = 0 to 31 do
        V{128}(i) = ARBITRARY : bits(128);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64_ResetSpecialRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64_ResetSpecialRegisters</h3>
      <p class="pseudocode">// AArch64_ResetSpecialRegisters()
// ===============================

func AArch64_ResetSpecialRegisters()
begin

    // AArch64 special registers
    SP_EL0()       = ARBITRARY : bits(64);
    SP_EL1()       = ARBITRARY : bits(64);

    SPSR_EL1()     = ARBITRARY : bits(64);
    ELR_EL1()      = ARBITRARY : bits(64);
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        SP_EL2()   = ARBITRARY : bits(64);
        SPSR_EL2() = ARBITRARY : bits(64);
        ELR_EL2()  = ARBITRARY : bits(64);
    end;

    // AArch32 special registers that are not architecturally mapped to AArch64 registers
    if <a href="shared_pseudocode.html#func_HaveAArch32EL_1" title="">HaveAArch32EL</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        SPSR_fiq()[31:0] = ARBITRARY : bits(32);
        SPSR_irq()[31:0] = ARBITRARY : bits(32);
        SPSR_abt()[31:0] = ARBITRARY : bits(32);
        SPSR_und()[31:0] = ARBITRARY : bits(32);
    end;

    // External debug special registers
    DLR_EL0()   = ARBITRARY : bits(64);
    DSPSR_EL0() = ARBITRARY : bits(64);

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64_ResetSystemRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64_ResetSystemRegisters</h3>
      <p class="pseudocode">// AArch64_ResetSystemRegisters()
// ==============================

impdef func AArch64_ResetSystemRegisters(cold_reset : boolean)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.PC64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/PC64</h3>
      <p class="pseudocode">// PC64 - getter
// =============
// Read 64-bit program counter.

func <a id="func_PC64_0"/>PC64() =&gt; bits(64)
begin
    return <a href="shared_pseudocode.html#global__PC" title="">_PC</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SP</h3>
      <p class="pseudocode">// SP - accessor
// =============

accessor <a id="accessor_SP_1"/>SP{width}() &lt;=&gt; value : bits(width)
begin
    // Write a 32-bit or 64-bit value to the current stack pointer.
    setter
        assert width IN {64, 32};
        if PSTATE.SP == '0' then
            SP_EL0() = ZeroExtend{64}(value);
        else
            case PSTATE.EL of
                when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;  SP_EL0() = ZeroExtend{64}(value);
                when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  SP_EL1() = ZeroExtend{64}(value);
                when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  SP_EL2() = ZeroExtend{64}(value);
                when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  SP_EL3() = ZeroExtend{64}(value);
            end;
        end;
    end;

    // Read the least-significant 32 or 64 bits from the current stack pointer.
    getter
        assert width IN {64, 32};
        if PSTATE.SP == '0' then
            return SP_EL0()[width-1:0];
        else
            case PSTATE.EL of
                when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;  return SP_EL0()[width-1:0];
                when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  return SP_EL1()[width-1:0];
                when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  return SP_EL2()[width-1:0];
                when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  return SP_EL3()[width-1:0];
            end;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.X"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/X</h3>
      <p class="pseudocode">// X - accessor
// ============

accessor <a id="accessor_X_2"/>X{width}(n : integer) &lt;=&gt; value : bits(width)
begin
    // Write a 32-bit or 64-bit value to a general-purpose register.
    setter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        assert width IN {32,64};
        if n != 31 then
            <a href="shared_pseudocode.html#global__R" title="">_R</a>[[n]] = ZeroExtend{64}(value);
        end;
        return;
    end;

    // Read the least-significant 8, 16, 32, or 64 bits from a general-purpose register.
    getter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        let rw : integer{} = width as integer{8, 16, 32, 64};
        if n != 31 then
            return <a href="shared_pseudocode.html#global__R" title="">_R</a>[[n]][rw-1:0];
        else
            return Zeros{rw};
        end;
    end;
end;

// X - accessor
// ============

accessor <a id="accessor_X_3"/>X{width}(lr : integer, hr : integer) &lt;=&gt; value : bits(width)
begin
    // Write a 128-bit value to two general-purpose registers.
    setter
        assert width == 128;
        let half : integer{} = width DIV 2;
        <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{half}(lr)          = value[0+:half];
        <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{half}(hr)          = value[half+:half];
        return;
    end;

    // Read 128 bits from two separate general-purpose registers.
    getter
        assert width == 128;
        let half : integer{} = width DIV 2;
        return <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{half}(hr) :: <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{half}(lr);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.shiftreg.DecodeShift"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/shiftreg/DecodeShift</h3>
      <p class="pseudocode">// DecodeShift()
// =============
// Decode shift encodings

func DecodeShift(op : bits(2)) =&gt; <a href="shared_pseudocode.html#ShiftType" title="type ShiftType">ShiftType</a>
begin
    case op of
        when '00' =&gt;  return ShiftType_LSL;
        when '01' =&gt;  return ShiftType_LSR;
        when '10' =&gt;  return ShiftType_ASR;
        when '11' =&gt;  return ShiftType_ROR;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.shiftreg.ShiftReg"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/shiftreg/ShiftReg</h3>
      <p class="pseudocode">// ShiftReg()
// ==========
// Perform shift of a register operand

func ShiftReg{N}(reg : integer, shiftype : <a href="shared_pseudocode.html#ShiftType" title="type ShiftType">ShiftType</a>, amount : integer) =&gt; bits(N)
begin
    var result : bits(N) = X{}(reg);
    case shiftype of
        when ShiftType_LSL =&gt; result = LSL(result, amount);
        when ShiftType_LSR =&gt; result = LSR(result, amount);
        when ShiftType_ASR =&gt; result = ASR(result, amount);
        when ShiftType_ROR =&gt; result = ROR(result, amount);
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.shiftreg.ShiftType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/shiftreg/ShiftType</h3>
      <p class="pseudocode">// ShiftType
// =========
// AArch64 register shifts.

type <a id="ShiftType"/>ShiftType of enumeration {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.CounterToPredicate"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/CounterToPredicate</h3>
      <p class="pseudocode">// CounterToPredicate()
// ====================

func CounterToPredicate{width}(pred : bits(16)) =&gt; bits(width)
begin
    var count : integer;
    var esize : <a href="shared_pseudocode.html#ESize" title="type ESize">ESize</a>;
    var elements : integer;
    let VL : <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a>  = CurrentVL();
    let PL : <a href="shared_pseudocode.html#PredLen" title="type PredLen">PredLen</a> = VL DIV 8;
    let maxbit : integer{} = FloorLog2(PL * 4) as integer{0..14};
    var result : bits(PL*4);
    let invert : boolean = pred[15] == '1';

    assert width == PL || width == PL*2 || width == PL*3 || width == PL*4;

    case pred[3:0] of
        when '0000' =&gt;
            return Zeros{width};
        when 'xxx1' =&gt;
            count = UInt(pred[maxbit:1]);
            esize = 8;
        when 'xx10' =&gt;
            count = UInt(pred[maxbit:2]);
            esize = 16;
        when 'x100' =&gt;
            count = UInt(pred[maxbit:3]);
            esize = 32;
        when '1000' =&gt;
            count = UInt(pred[maxbit:4]);
            esize = 64;
    end;

    elements = (VL * 4) DIV esize;
    result = Zeros{PL*4};
    let psize : integer{} = esize DIV 8;
    for e = 0 to elements-1 do
        var pbit : bit = if e &lt; count then '1' else '0';
        if invert then
            pbit = NOT(pbit);
        end;
        result[e*:psize] = ZeroExtend{psize}(pbit);
    end;

    return result[width-1:0];
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.EncodePredCount"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/EncodePredCount</h3>
      <p class="pseudocode">// EncodePredCount()
// =================

func EncodePredCount{width}(esize : <a href="shared_pseudocode.html#ESize" title="type ESize">ESize</a>, elements : integer,
                            count_in : integer, invert_in : boolean) =&gt; bits(width)
begin
    var count : integer  = count_in;
    var invert : boolean = invert_in;
    let PL : <a href="shared_pseudocode.html#PredLen" title="type PredLen">PredLen</a> = CurrentVL() DIV 8;
    assert width == PL;
    assert count &gt;=0 &amp;&amp; count &lt;= elements;
    var pred : bits(16);

    if count == 0 then
        return Zeros{width};
    end;

    if invert then
        count = elements - count;
    elsif count == elements then
        count = 0;
        invert = TRUE;
    end;

    let inv : bit = (if invert then '1' else '0');
    case esize of
        when 8 =&gt;  pred = inv :: count[13:0] ::    '1';
        when 16 =&gt; pred = inv :: count[12:0] ::   '10';
        when 32 =&gt; pred = inv :: count[11:0] ::  '100';
        when 64 =&gt; pred = inv :: count[10:0] :: '1000';
    end;

    return ZeroExtend{width}(pred);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.Lookup"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/Lookup</h3>
      <p class="pseudocode">// Lookup Table
// ============

var <a id="global__ZT0"/>_ZT0 : bits(ZT0_LEN);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.PredCountTest"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/PredCountTest</h3>
      <p class="pseudocode">// PredCountTest()
// ===============

func <a id="func_PredCountTest_3"/>PredCountTest(elements : integer, count : integer, invert : boolean) =&gt; bits(4)
begin
    var n, z, c, v : bit;
    z = (if count == 0 then '1' else '0');              // none active
    if !invert then
        n = (if count != 0 then '1' else '0');          // first active
        c = (if count == elements then '0' else '1');   // NOT last active
    else
        n = (if count == elements then '1' else '0');   // first active
        c = (if count != 0 then '0' else '1');          // NOT last active
    end;
    v = '0';

    return n::z::c::v;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.System"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/System</h3>
      <p class="pseudocode">// System Registers
// ================

var <a id="global__ZA"/>_ZA : array [[256]] of bits(MAX_VL);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAhslice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAhslice</h3>
      <p class="pseudocode">// ZAhslice - accessor
// ===================

accessor ZAhslice{width}(tile : integer, esize : <a href="shared_pseudocode.html#ESize" title="type ESize">ESize</a>, slice : integer) &lt;=&gt; value : bits(width)
begin
    getter
        let tiles : integer = esize DIV 8;
        assert tile &gt;= 0 &amp;&amp; tile &lt; tiles;
        let slices : integer = CurrentSVL() DIV esize;
        assert slice &gt;= 0 &amp;&amp; slice &lt; slices;

        return ZAvector{width}(tile + slice * tiles);
    end;
    setter
        let tiles : integer = esize DIV 8;
        assert tile &gt;= 0 &amp;&amp; tile &lt; tiles;
        let slices : integer = CurrentSVL() DIV esize;
        assert slice &gt;= 0 &amp;&amp; slice &lt; slices;

        ZAvector{width}(tile + slice * tiles) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAslice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAslice</h3>
      <p class="pseudocode">// ZAslice - accessor
// ==================

accessor ZAslice{width}(tile : integer, esize : <a href="shared_pseudocode.html#ESize" title="type ESize">ESize</a>,
                        vertical : boolean, slice : integer) &lt;=&gt; value : bits(width)
begin
    getter
        var result : bits(width);

        if vertical then
            result = ZAvslice{width}(tile, esize, slice);
        else
            result = ZAhslice{width}(tile, esize, slice);
        end;

        return result;
    end;
    setter
        if vertical then
            ZAvslice{width}(tile, esize, slice) = value;
        else
            ZAhslice{width}(tile, esize, slice) = value;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAtile"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAtile</h3>
      <p class="pseudocode">// ZAtile - accessor
// =================

accessor ZAtile{width}(tile : integer, esize : <a href="shared_pseudocode.html#ESize" title="type ESize">ESize</a>) &lt;=&gt; value : bits(width)
begin
    getter
        let SVL : <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a> = CurrentSVL();
        let slices : integer = SVL DIV esize;
        assert width == SVL * slices;
        var result : bits(width);

        for slice = 0 to slices-1 do
            result[slice*:SVL] = ZAhslice{SVL}(tile, esize, slice);
        end;

        return result;
    end;
    setter
        let SVL : <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a> = CurrentSVL();
        let slices : integer = SVL DIV esize;
        assert width == SVL * slices;

        for slice = 0 to slices-1 do
            ZAhslice{SVL}(tile, esize, slice) = value[slice*:SVL];
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAvector"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAvector</h3>
      <p class="pseudocode">// ZAvector - accessor
// ===================

accessor <a id="accessor_ZAvector_2"/>ZAvector{width}(index : integer) &lt;=&gt; value : bits(width)
begin
    getter
        assert width == CurrentSVL();
        assert index &gt;= 0 &amp;&amp; index &lt; (width DIV 8);

        return <a href="shared_pseudocode.html#global__ZA" title="">_ZA</a>[[index]][width-1:0];
    end;

    setter
        assert width == CurrentSVL();
        assert index &gt;= 0 &amp;&amp; index &lt; (width DIV 8);

        if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_SMEZEROUPPER" title="">Unpredictable_SMEZEROUPPER</a>) then
            <a href="shared_pseudocode.html#global__ZA" title="">_ZA</a>[[index]] = ZeroExtend{MAX_VL}(value);
        else
            <a href="shared_pseudocode.html#global__ZA" title="">_ZA</a>[[index]][width-1:0] = value;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAvslice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAvslice</h3>
      <p class="pseudocode">// ZAvslice - accessor
// ===================

accessor ZAvslice{width}(tile : integer, esize : <a href="shared_pseudocode.html#ESize" title="type ESize">ESize</a>, slice : integer) &lt;=&gt; value : bits(width)
begin
    getter
        let slices : integer = CurrentSVL() DIV esize;
        var result : bits(width);

        for s = 0 to slices-1 do
            let hslice : bits(width) = ZAhslice{}(tile, esize, s);
            result[s*:esize] = hslice[slice*:esize];
        end;

        return result;
    end;

    setter
        let slices : integer = CurrentSVL() DIV esize;

        for s = 0 to slices-1 do
            var hslice : bits(width) = ZAhslice{}(tile, esize, s);
            hslice[slice*:esize] = value[s*:esize];
            ZAhslice{width}(tile, esize, s) = hslice;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZT0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZT0</h3>
      <p class="pseudocode">// ZT0 - accessor
// ==============

accessor <a id="accessor_ZT0_1"/>ZT0{width}() &lt;=&gt; value : bits(width)
begin
    getter
        assert width == ZT0_LEN;
        return <a href="shared_pseudocode.html#global__ZT0" title="">_ZT0</a>[width-1:0];
    end;
    setter
        assert width == ZT0_LEN;
        <a href="shared_pseudocode.html#global__ZT0" title="">_ZT0</a>[width-1:0] = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.AArch32_IsFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/AArch32_IsFPEnabled</h3>
      <p class="pseudocode">// AArch32_IsFPEnabled()
// =====================
// Returns TRUE if access to the SIMD&amp;FP instructions or System registers are
// enabled at the target exception level in AArch32 state and FALSE otherwise.

func <a id="func_AArch32_IsFPEnabled_1"/>AArch32_IsFPEnabled(el : bits(2)) =&gt; boolean
begin
    if el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        return <a href="shared_pseudocode.html#func_AArch64_IsFPEnabled_1" title="">AArch64_IsFPEnabled</a>(el);
    end;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> then
        // Check if access disabled in NSACR
        if NSACR().cp10 == '0' then return FALSE; end;
    end;

    if el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} then
        // Check if access disabled in CPACR
        var disabled : boolean;
        case CPACR().cp10 of
            when '00' =&gt; disabled = TRUE;
            when '01' =&gt; disabled = el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
            when '10' =&gt; disabled = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_RESCPACR" title="">Unpredictable_RESCPACR</a>);
            when '11' =&gt; disabled = FALSE;
        end;
        if disabled then return FALSE; end;
    end;

    if el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            return <a href="shared_pseudocode.html#func_AArch64_IsFPEnabled_1" title="">AArch64_IsFPEnabled</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
        end;
        if HCPTR().TCP10 == '1' then return FALSE; end;
    end;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        // Check if access disabled in CPTR_EL3
        if CPTR_EL3().TFP == '1' then return FALSE; end;
    end;

    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.AArch64_IsFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/AArch64_IsFPEnabled</h3>
      <p class="pseudocode">// AArch64_IsFPEnabled()
// =====================
// Returns TRUE if access to the SIMD&amp;FP instructions or System registers are
// enabled at the target exception level in AArch64 state and FALSE otherwise.

func <a id="func_AArch64_IsFPEnabled_1"/>AArch64_IsFPEnabled(el : bits(2)) =&gt; boolean
begin
    // Check if access disabled in CPACR_EL1
    if el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        // Check SIMD&amp;FP at EL0/EL1
        var disabled : boolean;
        case CPACR_EL1().FPEN of
            when 'x0' =&gt; disabled = TRUE;
            when '01' =&gt; disabled = el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
            when '11' =&gt; disabled = FALSE;
        end;
        if disabled then return FALSE; end;
    end;

    // Check if access disabled in CPTR_EL2
    if el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            var disabled : boolean;
            case CPTR_EL2().FPEN of
                when 'x0' =&gt; disabled = TRUE;
                when '01' =&gt; disabled = el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; HCR_EL2().TGE == '1';
                when '11' =&gt; disabled = FALSE;
            end;
            if disabled then return FALSE; end;
        else
            if CPTR_EL2().TFP == '1' then return FALSE; end;
        end;
    end;

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if CPTR_EL3().TFP == '1' then return FALSE; end;
    end;

    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ActivePredicateElement"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ActivePredicateElement</h3>
      <p class="pseudocode">// ActivePredicateElement()
// ========================
// Returns TRUE if the predicate bit is 1 and FALSE otherwise

func <a id="func_ActivePredicateElement_4"/>ActivePredicateElement{N}(pred : bits(N), e : integer, esize : integer) =&gt; boolean
begin
    assert esize IN {8, 16, 32, 64, 128};
    let n : integer = e * (esize DIV 8);
    assert n &gt;= 0 &amp;&amp; n &lt; N;
    return pred[n] == '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.AllElementsActive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/AllElementsActive</h3>
      <p class="pseudocode">// AllElementsActive()
// ===================
// Return TRUE if all the elements are active in the mask. Otherwise,
// return FALSE.

func <a id="func_AllElementsActive_3"/>AllElementsActive{N}(mask : bits(N), esize : integer) =&gt; boolean
begin
    let elements : integer = N DIV (esize DIV 8);
    var active : integer = 0;
    for e = 0 to elements-1 do
        if <a href="shared_pseudocode.html#func_ActivePredicateElement_4" title="">ActivePredicateElement</a>{N}(mask, e, esize) then active = active + 1; end;
    end;
    return active == elements;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.AnyActiveElement"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/AnyActiveElement</h3>
      <p class="pseudocode">// AnyActiveElement()
// ==================
// Return TRUE if there is at least one active element in mask. Otherwise,
// return FALSE.

func <a id="func_AnyActiveElement_3"/>AnyActiveElement{N}(mask : bits(N), esize : integer) =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_LastActiveElement_3" title="">LastActiveElement</a>{N}(mask, esize) &gt;= 0;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.BitDeposit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/BitDeposit</h3>
      <p class="pseudocode">// BitDeposit()
// ============
// Deposit the least significant bits from DATA into result positions
// selected by nonzero bits in MASK, setting other result bits to zero.

func <a id="func_BitDeposit_3"/>BitDeposit{N}(data : bits(N), mask : bits(N)) =&gt; bits(N)
begin
    var res : bits(N) = Zeros{};
    var db : integer = 0;
    for rb = 0 to N-1 do
        if mask[rb] == '1' then
            res[rb] = data[db];
            db      = db + 1;
        end;
    end;
    return res;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.BitExtract"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/BitExtract</h3>
      <p class="pseudocode">// BitExtract()
// ============
// Extract and pack DATA bits selected by the nonzero bits in MASK into
// the least significant result bits, setting other result bits to zero.

func <a id="func_BitExtract_3"/>BitExtract{N}(data : bits(N), mask : bits(N)) =&gt; bits(N)
begin
    var res : bits(N) = Zeros{};
    var rb : integer = 0;
    for db = 0 to N-1 do
        if mask[db] == '1' then
            res[rb] = data[db];
            rb      = rb + 1;
        end;
    end;
    return res;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.BitGroup"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/BitGroup</h3>
      <p class="pseudocode">// BitGroup()
// ==========
// Extract and pack DATA bits selected by the nonzero bits in MASK into
// the least significant result bits, and pack unselected bits into the
// most significant result bits.

func <a id="func_BitGroup_3"/>BitGroup{N}(data : bits(N), mask : bits(N)) =&gt; bits(N)
begin
    var res : bits(N);
    var rb : integer = 0;

    // compress masked bits to right
    for db = 0 to N-1 do
        if mask[db] == '1' then
            res[rb] = data[db];
            rb      = rb + 1;
        end;
    end;
    // compress unmasked bits to left
    for db = 0 to N-1 do
        if mask[db] == '0' then
            res[rb] = data[db];
            rb      = rb + 1;
        end;
    end;
    return res;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckNonStreamingSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckNonStreamingSVEEnabled</h3>
      <p class="pseudocode">// CheckNonStreamingSVEEnabled()
// =============================
// Checks for traps on SVE instructions that are not legal when executed in Streaming mode.

func CheckNonStreamingSVEEnabled()
begin
    CheckSVEEnabled();

    if IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.SM == '1' &amp;&amp; !<a href="shared_pseudocode.html#func_IsFullA64Enabled_0" title="">IsFullA64Enabled</a>() then
        SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_Streaming" title="">SMEExceptionType_Streaming</a>, PSTATE.EL);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckOriginalSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckOriginalSVEEnabled</h3>
      <p class="pseudocode">// CheckOriginalSVEEnabled()
// =========================
// Checks for traps on SVE instructions and instructions that access SVE System
// registers.

func CheckOriginalSVEEnabled()
begin
    assert IsFeatureImplemented(FEAT_SVE);
    var disabled : boolean;

    if (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; (CPTR_EL3().EZ == '0' || CPTR_EL3().TFP == '1') &amp;&amp;
          <a href="shared_pseudocode.html#func_EL3SDDUndefPriority_0" title="">EL3SDDUndefPriority</a>()) then
        Undefined();
    end;

    // Check if access disabled in CPACR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        // Check SVE at EL0/EL1
        case CPACR_EL1().ZEN of
            when 'x0' =&gt; disabled = TRUE;
            when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
            when '11' =&gt; disabled = FALSE;
        end;
        if disabled then SVEAccessTrap(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>); end;

        // Check SIMD&amp;FP at EL0/EL1
        case CPACR_EL1().FPEN of
            when 'x0' =&gt; disabled = TRUE;
            when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
            when '11' =&gt; disabled = FALSE;
        end;
        if disabled then AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>); end;
    end;

    // Check if access disabled in CPTR_EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            // Check SVE at EL2
            case CPTR_EL2().ZEN of
                when 'x0' =&gt; disabled = TRUE;
                when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; HCR_EL2().TGE == '1';
                when '11' =&gt; disabled = FALSE;
            end;
            if disabled then SVEAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>); end;

            // Check SIMD&amp;FP at EL2
            case CPTR_EL2().FPEN of
                when 'x0' =&gt; disabled = TRUE;
                when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; HCR_EL2().TGE == '1';
                when '11' =&gt; disabled = FALSE;
            end;
            if disabled then AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>); end;
        else
            if CPTR_EL2().TZ == '1'  then SVEAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>); end;
            if CPTR_EL2().TFP == '1' then AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>); end;
        end;
    end;

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if CPTR_EL3().EZ == '0' then
            if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then Undefined(); end;
            SVEAccessTrap(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;

        if CPTR_EL3().TFP == '1' then
            if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then Undefined(); end;
            AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSMEAccess"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSMEAccess</h3>
      <p class="pseudocode">// CheckSMEAccess()
// ================
// Check that access to SME System registers is enabled.

func CheckSMEAccess()
begin
    var disabled : boolean;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; CPTR_EL3().ESM == '0' &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndefPriority_0" title="">EL3SDDUndefPriority</a>() then
        Undefined();
    end;

    // Check if access disabled in CPACR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        // Check SME at EL0/EL1
        case CPACR_EL1().SMEN of
            when 'x0' =&gt; disabled = TRUE;
            when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
            when '11' =&gt; disabled = FALSE;
        end;
        if disabled then SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_AccessTrap" title="">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>); end;
    end;

    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            // Check SME at EL2
            case CPTR_EL2().SMEN of
                when 'x0' =&gt; disabled = TRUE;
                when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; HCR_EL2().TGE == '1';
                when '11' =&gt; disabled = FALSE;
            end;
            if disabled then SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_AccessTrap" title="">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>); end;
        else
            if CPTR_EL2().TSM == '1' then SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_AccessTrap" title="">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>); end;
        end;
    end;

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if CPTR_EL3().ESM == '0' then
            if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then Undefined(); end;
            SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_AccessTrap" title="">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSMEAndZAEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSMEAndZAEnabled</h3>
      <p class="pseudocode">// CheckSMEAndZAEnabled()
// ======================

func CheckSMEAndZAEnabled()
begin
    CheckSMEEnabled();

    if PSTATE.ZA == '0' then
        SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_InactiveZA" title="">SMEExceptionType_InactiveZA</a>, PSTATE.EL);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSMEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSMEEnabled</h3>
      <p class="pseudocode">// CheckSMEEnabled()
// =================

func CheckSMEEnabled()
begin
    var disabled : boolean;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; CPTR_EL3().[ESM,TFP] != '10' &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndefPriority_0" title="">EL3SDDUndefPriority</a>() then
        Undefined();
    end;

    // Check if access disabled in CPACR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        // Check SME at EL0/EL1
        case CPACR_EL1().SMEN of
            when 'x0' =&gt; disabled = TRUE;
            when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
            when '11' =&gt; disabled = FALSE;
        end;
        if disabled then SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_AccessTrap" title="">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>); end;

        // Check SIMD&amp;FP at EL0/EL1
        case CPACR_EL1().FPEN of
            when 'x0' =&gt; disabled = TRUE;
            when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
            when '11' =&gt; disabled = FALSE;
        end;
        if disabled then AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>); end;
    end;

    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            // Check SME at EL2
            case CPTR_EL2().SMEN of
                when 'x0' =&gt; disabled = TRUE;
                when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; HCR_EL2().TGE == '1';
                when '11' =&gt; disabled = FALSE;
            end;
            if disabled then SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_AccessTrap" title="">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>); end;

            // Check SIMD&amp;FP at EL2
            case CPTR_EL2().FPEN of
                when 'x0' =&gt; disabled = TRUE;
                when '01' =&gt; disabled = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; HCR_EL2().TGE == '1';
                when '11' =&gt; disabled = FALSE;
            end;
            if disabled then AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>); end;
        else
            if CPTR_EL2().TSM == '1' then SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_AccessTrap" title="">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>); end;
            if CPTR_EL2().TFP == '1' then AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>); end;
        end;
    end;

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if CPTR_EL3().ESM == '0' then
            if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then Undefined(); end;
            SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_AccessTrap" title="">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;

        if CPTR_EL3().TFP == '1' then
            if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then Undefined(); end;
            AArch64_AdvSIMDFPAccessTrap(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSMEZT0Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSMEZT0Enabled</h3>
      <p class="pseudocode">// CheckSMEZT0Enabled()
// ====================
// Checks for ZT0 enabled.

func CheckSMEZT0Enabled()
begin
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SMCR_EL3().EZT0 == '0' &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndefPriority_0" title="">EL3SDDUndefPriority</a>() then
        Undefined();
    end;

    // Check if ZA and ZT0 are inactive in PSTATE
    if PSTATE.ZA == '0' then
        SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_InactiveZA" title="">SMEExceptionType_InactiveZA</a>, PSTATE.EL);
    end;

    // Check if EL0/EL1 accesses to ZT0 are disabled in SMCR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        if SMCR_EL1().EZT0 == '0' then
            SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_InaccessibleZT0" title="">SMEExceptionType_InaccessibleZT0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
        end;
    end;

    // Check if EL0/EL1/EL2 accesses to ZT0 are disabled in SMCR_EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if SMCR_EL2().EZT0 == '0' then
            SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_InaccessibleZT0" title="">SMEExceptionType_InaccessibleZT0</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
        end;
    end;

    // Check if all accesses to ZT0 are disabled in SMCR_EL3
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if SMCR_EL3().EZT0 == '0' then
            if <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then Undefined(); end;
            SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_InaccessibleZT0" title="">SMEExceptionType_InaccessibleZT0</a>, <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSVEEnabled</h3>
      <p class="pseudocode">// CheckSVEEnabled()
// =================
// Checks for traps on SVE instructions and instructions that
// access SVE System registers.

func CheckSVEEnabled()
begin
    if IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.SM == '1' then
        CheckSMEEnabled();
    elsif IsFeatureImplemented(FEAT_SME) &amp;&amp; !IsFeatureImplemented(FEAT_SVE) then
        CheckStreamingSVEEnabled();
    else
        CheckOriginalSVEEnabled();
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckStreamingSVEAndZAEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckStreamingSVEAndZAEnabled</h3>
      <p class="pseudocode">// CheckStreamingSVEAndZAEnabled()
// ===============================

func CheckStreamingSVEAndZAEnabled()
begin
    CheckStreamingSVEEnabled();

    if PSTATE.ZA == '0' then
        SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_InactiveZA" title="">SMEExceptionType_InactiveZA</a>, PSTATE.EL);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckStreamingSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckStreamingSVEEnabled</h3>
      <p class="pseudocode">// CheckStreamingSVEEnabled()
// ==========================

func CheckStreamingSVEEnabled()
begin
    CheckSMEEnabled();

    if PSTATE.SM == '0' then
        SMEAccessTrap(<a href="shared_pseudocode.html#enum_SMEExceptionType_NotStreaming" title="">SMEExceptionType_NotStreaming</a>, PSTATE.EL);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CmpOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CmpOp</h3>
      <p class="pseudocode">// CmpOp
// =====

type <a id="CmpOp"/>CmpOp of enumeration { Cmp_EQ, Cmp_NE, Cmp_GE, Cmp_GT, Cmp_LT, Cmp_LE, Cmp_UN };</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CurrentNSVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CurrentNSVL</h3>
      <p class="pseudocode">// CurrentNSVL
// ===========
// Non-Streaming VL

readonly func CurrentNSVL() =&gt; <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a>
begin
    var vl : integer;

    if PSTATE.EL == EL1 || (PSTATE.EL == EL0 &amp;&amp; !IsInHost()) then
        vl = UInt(ZCR_EL1().LEN);
    end;

    if PSTATE.EL == EL2 || (PSTATE.EL == EL0 &amp;&amp; IsInHost()) then
        vl = UInt(ZCR_EL2().LEN);
    elsif PSTATE.EL IN {EL0, EL1} &amp;&amp; EL2Enabled() then
        vl = Min(vl, UInt(ZCR_EL2().LEN));
    end;

    if PSTATE.EL == EL3 then
        vl = UInt(ZCR_EL3().LEN);
    elsif HaveEL(EL3) then
        vl = Min(vl, UInt(ZCR_EL3().LEN));
    end;

    return ImplementedSVEVectorLength((vl + 1) * 128);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CurrentSVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CurrentSVL</h3>
      <p class="pseudocode">// CurrentSVL
// ==========
// Streaming SVL

readonly func CurrentSVL() =&gt; <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a>
begin
    var vl : integer;

    if PSTATE.EL == EL1 || (PSTATE.EL == EL0 &amp;&amp; !IsInHost()) then
        vl = UInt(SMCR_EL1().LEN);
    end;

    if PSTATE.EL == EL2 || (PSTATE.EL == EL0 &amp;&amp; IsInHost()) then
        vl = UInt(SMCR_EL2().LEN);
    elsif PSTATE.EL IN {EL0, EL1} &amp;&amp; EL2Enabled() then
        vl = Min(vl, UInt(SMCR_EL2().LEN));
    end;

    if PSTATE.EL == EL3 then
        vl = UInt(SMCR_EL3().LEN);
    elsif HaveEL(EL3) then
        vl = Min(vl, UInt(SMCR_EL3().LEN));
    end;

    return ImplementedSMEVectorLength((vl + 1) * 128);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CurrentVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CurrentVL</h3>
      <p class="pseudocode">// CurrentVL
// =========

readonly func CurrentVL() =&gt; <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a>
begin
    return (if IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.SM == '1' then CurrentSVL()
                                                                  else CurrentNSVL());
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.DecodePredCount"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/DecodePredCount</h3>
      <p class="pseudocode">// DecodePredCount()
// =================

func <a id="func_DecodePredCount_2"/>DecodePredCount(bitpattern : bits(5), esize : integer) =&gt; integer
begin
    let elements : integer = CurrentVL() DIV esize;
    var numElem : integer;
    case bitpattern of
        when '00000' =&gt; numElem = FloorPow2(elements);
        when '00001' =&gt; numElem = if elements &gt;= 1 then 1 else 0;
        when '00010' =&gt; numElem = if elements &gt;= 2 then 2 else 0;
        when '00011' =&gt; numElem = if elements &gt;= 3 then 3 else 0;
        when '00100' =&gt; numElem = if elements &gt;= 4 then 4 else 0;
        when '00101' =&gt; numElem = if elements &gt;= 5 then 5 else 0;
        when '00110' =&gt; numElem = if elements &gt;= 6 then 6 else 0;
        when '00111' =&gt; numElem = if elements &gt;= 7 then 7 else 0;
        when '01000' =&gt; numElem = if elements &gt;= 8 then 8 else 0;
        when '01001' =&gt; numElem = if elements &gt;= 16 then 16 else 0;
        when '01010' =&gt; numElem = if elements &gt;= 32 then 32 else 0;
        when '01011' =&gt; numElem = if elements &gt;= 64 then 64 else 0;
        when '01100' =&gt; numElem = if elements &gt;= 128 then 128 else 0;
        when '01101' =&gt; numElem = if elements &gt;= 256 then 256 else 0;
        when '11101' =&gt; numElem = elements - (elements MOD 4);
        when '11110' =&gt; numElem = elements - (elements MOD 3);
        when '11111' =&gt; numElem = elements;
        otherwise    =&gt; numElem = 0;
    end;
    return numElem;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ElemFFR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ElemFFR</h3>
      <p class="pseudocode">// ElemFFR - accessor
// ==================

accessor ElemFFR(e : integer, esize : <a href="shared_pseudocode.html#ESize" title="type ESize">ESize</a>) &lt;=&gt; value : bit
begin
    getter
        return PredicateElement{MAX_PL}(_FFR, e, esize);
    end;
    setter
        let psize : integer{} = esize DIV 8;
        _FFR[e*:psize] = ZeroExtend{psize}(value);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FFR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FFR</h3>
      <p class="pseudocode">// FFR - accessor
// ==============

accessor <a id="accessor_FFR_1"/>FFR{width}() &lt;=&gt; value : bits(width)
begin
    getter
        assert width == CurrentVL() DIV 8;
        return _FFR[width-1:0];
    end;

    setter
        assert width == CurrentVL() DIV 8;
        if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_SVEZEROUPPER" title="">Unpredictable_SVEZEROUPPER</a>) then
            _FFR = ZeroExtend{MAX_PL}(value);
        else
            _FFR[width-1:0] = value;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPCompareNE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPCompareNE</h3>
      <p class="pseudocode">// FPCompareNE()
// =============

func <a id="func_FPCompareNE_4"/>FPCompareNE{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; boolean
begin
    assert N IN {16,32,64};
    var result : boolean;
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);
    let op1_nan : boolean = type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>};
    let op2_nan : boolean = type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>};

    if op1_nan || op2_nan then
        result = TRUE;
        if type1 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
        end;
    else // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 != value2);
        FPProcessDenorms(type1, type2, N, fpcr);
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPCompareUN"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPCompareUN</h3>
      <p class="pseudocode">// FPCompareUN()
// =============

func <a id="func_FPCompareUN_4"/>FPCompareUN{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; boolean
begin
    assert N IN {16,32,64};
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);

    if type1 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
    end;

    let result : boolean = (type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} ||
                                type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>});
    if !result then
        FPProcessDenorms(type1, type2, N, fpcr);
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPConvertSVE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPConvertSVE</h3>
      <p class="pseudocode">// FPConvertSVE()
// ==============

func <a id="func_FPConvertSVE_5"/>FPConvertSVE{M, N}(op : bits(N), fpcr_in : FPCR_Type, rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>) =&gt; bits(M)
begin
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.AHP = '0';
    return <a href="shared_pseudocode.html#func_FPConvert_5" title="">FPConvert</a>{M, N}(op, fpcr, rounding);
end;

// FPConvertSVE()
// ==============

func <a id="func_FPConvertSVE_4"/>FPConvertSVE{M, N}(op : bits(N), fpcr_in : FPCR_Type) =&gt; bits(M)
begin
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.AHP = '0';
    return <a href="shared_pseudocode.html#func_FPConvert_5" title="">FPConvert</a>{M, N}(op, fpcr, <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPExpA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPExpA</h3>
      <p class="pseudocode">// FPExpA()
// ========

func <a id="func_FPExpA_2"/>FPExpA{N}(op : bits(N)) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var result : bits(N);
    var coeff : bits(N);
    let idx : integer = if N == 16 then UInt(op[4:0]) else UInt(op[5:0]);
    coeff = <a href="shared_pseudocode.html#func_FPExpCoefficient_2" title="">FPExpCoefficient</a>{N}(idx);
    if N == 16 then
        result[15:0] = '0'::op[9:5]::coeff[9:0];
    elsif N == 32 then
        result[31:0] = '0'::op[13:6]::coeff[22:0];
    else // N == 64
        result[63:0] = '0'::op[16:6]::coeff[51:0];
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPExpCoefficient"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPExpCoefficient</h3>
      <p class="pseudocode">// FPExpCoefficient()
// ==================

func <a id="func_FPExpCoefficient_2"/>FPExpCoefficient{N}(index : integer) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var result : integer;

    if N == 16 then
        case index of
            when  0 =&gt; result = 0x000;
            when  1 =&gt; result = 0x016;
            when  2 =&gt; result = 0x02d;
            when  3 =&gt; result = 0x045;
            when  4 =&gt; result = 0x05d;
            when  5 =&gt; result = 0x075;
            when  6 =&gt; result = 0x08e;
            when  7 =&gt; result = 0x0a8;
            when  8 =&gt; result = 0x0c2;
            when  9 =&gt; result = 0x0dc;
            when 10 =&gt; result = 0x0f8;
            when 11 =&gt; result = 0x114;
            when 12 =&gt; result = 0x130;
            when 13 =&gt; result = 0x14d;
            when 14 =&gt; result = 0x16b;
            when 15 =&gt; result = 0x189;
            when 16 =&gt; result = 0x1a8;
            when 17 =&gt; result = 0x1c8;
            when 18 =&gt; result = 0x1e8;
            when 19 =&gt; result = 0x209;
            when 20 =&gt; result = 0x22b;
            when 21 =&gt; result = 0x24e;
            when 22 =&gt; result = 0x271;
            when 23 =&gt; result = 0x295;
            when 24 =&gt; result = 0x2ba;
            when 25 =&gt; result = 0x2e0;
            when 26 =&gt; result = 0x306;
            when 27 =&gt; result = 0x32e;
            when 28 =&gt; result = 0x356;
            when 29 =&gt; result = 0x37f;
            when 30 =&gt; result = 0x3a9;
            when 31 =&gt; result = 0x3d4;
        end;

    elsif N == 32 then
        case index of
            when  0 =&gt; result = 0x000000;
            when  1 =&gt; result = 0x0164d2;
            when  2 =&gt; result = 0x02cd87;
            when  3 =&gt; result = 0x043a29;
            when  4 =&gt; result = 0x05aac3;
            when  5 =&gt; result = 0x071f62;
            when  6 =&gt; result = 0x08980f;
            when  7 =&gt; result = 0x0a14d5;
            when  8 =&gt; result = 0x0b95c2;
            when  9 =&gt; result = 0x0d1adf;
            when 10 =&gt; result = 0x0ea43a;
            when 11 =&gt; result = 0x1031dc;
            when 12 =&gt; result = 0x11c3d3;
            when 13 =&gt; result = 0x135a2b;
            when 14 =&gt; result = 0x14f4f0;
            when 15 =&gt; result = 0x16942d;
            when 16 =&gt; result = 0x1837f0;
            when 17 =&gt; result = 0x19e046;
            when 18 =&gt; result = 0x1b8d3a;
            when 19 =&gt; result = 0x1d3eda;
            when 20 =&gt; result = 0x1ef532;
            when 21 =&gt; result = 0x20b051;
            when 22 =&gt; result = 0x227043;
            when 23 =&gt; result = 0x243516;
            when 24 =&gt; result = 0x25fed7;
            when 25 =&gt; result = 0x27cd94;
            when 26 =&gt; result = 0x29a15b;
            when 27 =&gt; result = 0x2b7a3a;
            when 28 =&gt; result = 0x2d583f;
            when 29 =&gt; result = 0x2f3b79;
            when 30 =&gt; result = 0x3123f6;
            when 31 =&gt; result = 0x3311c4;
            when 32 =&gt; result = 0x3504f3;
            when 33 =&gt; result = 0x36fd92;
            when 34 =&gt; result = 0x38fbaf;
            when 35 =&gt; result = 0x3aff5b;
            when 36 =&gt; result = 0x3d08a4;
            when 37 =&gt; result = 0x3f179a;
            when 38 =&gt; result = 0x412c4d;
            when 39 =&gt; result = 0x4346cd;
            when 40 =&gt; result = 0x45672a;
            when 41 =&gt; result = 0x478d75;
            when 42 =&gt; result = 0x49b9be;
            when 43 =&gt; result = 0x4bec15;
            when 44 =&gt; result = 0x4e248c;
            when 45 =&gt; result = 0x506334;
            when 46 =&gt; result = 0x52a81e;
            when 47 =&gt; result = 0x54f35b;
            when 48 =&gt; result = 0x5744fd;
            when 49 =&gt; result = 0x599d16;
            when 50 =&gt; result = 0x5bfbb8;
            when 51 =&gt; result = 0x5e60f5;
            when 52 =&gt; result = 0x60ccdf;
            when 53 =&gt; result = 0x633f89;
            when 54 =&gt; result = 0x65b907;
            when 55 =&gt; result = 0x68396a;
            when 56 =&gt; result = 0x6ac0c7;
            when 57 =&gt; result = 0x6d4f30;
            when 58 =&gt; result = 0x6fe4ba;
            when 59 =&gt; result = 0x728177;
            when 60 =&gt; result = 0x75257d;
            when 61 =&gt; result = 0x77d0df;
            when 62 =&gt; result = 0x7a83b3;
            when 63 =&gt; result = 0x7d3e0c;
        end;

    else // N == 64
        case index of
            when  0 =&gt; result = 0x0000000000000;
            when  1 =&gt; result = 0x02C9A3E778061;
            when  2 =&gt; result = 0x059B0D3158574;
            when  3 =&gt; result = 0x0874518759BC8;
            when  4 =&gt; result = 0x0B5586CF9890F;
            when  5 =&gt; result = 0x0E3EC32D3D1A2;
            when  6 =&gt; result = 0x11301D0125B51;
            when  7 =&gt; result = 0x1429AAEA92DE0;
            when  8 =&gt; result = 0x172B83C7D517B;
            when  9 =&gt; result = 0x1A35BEB6FCB75;
            when 10 =&gt; result = 0x1D4873168B9AA;
            when 11 =&gt; result = 0x2063B88628CD6;
            when 12 =&gt; result = 0x2387A6E756238;
            when 13 =&gt; result = 0x26B4565E27CDD;
            when 14 =&gt; result = 0x29E9DF51FDEE1;
            when 15 =&gt; result = 0x2D285A6E4030B;
            when 16 =&gt; result = 0x306FE0A31B715;
            when 17 =&gt; result = 0x33C08B26416FF;
            when 18 =&gt; result = 0x371A7373AA9CB;
            when 19 =&gt; result = 0x3A7DB34E59FF7;
            when 20 =&gt; result = 0x3DEA64C123422;
            when 21 =&gt; result = 0x4160A21F72E2A;
            when 22 =&gt; result = 0x44E086061892D;
            when 23 =&gt; result = 0x486A2B5C13CD0;
            when 24 =&gt; result = 0x4BFDAD5362A27;
            when 25 =&gt; result = 0x4F9B2769D2CA7;
            when 26 =&gt; result = 0x5342B569D4F82;
            when 27 =&gt; result = 0x56F4736B527DA;
            when 28 =&gt; result = 0x5AB07DD485429;
            when 29 =&gt; result = 0x5E76F15AD2148;
            when 30 =&gt; result = 0x6247EB03A5585;
            when 31 =&gt; result = 0x6623882552225;
            when 32 =&gt; result = 0x6A09E667F3BCD;
            when 33 =&gt; result = 0x6DFB23C651A2F;
            when 34 =&gt; result = 0x71F75E8EC5F74;
            when 35 =&gt; result = 0x75FEB564267C9;
            when 36 =&gt; result = 0x7A11473EB0187;
            when 37 =&gt; result = 0x7E2F336CF4E62;
            when 38 =&gt; result = 0x82589994CCE13;
            when 39 =&gt; result = 0x868D99B4492ED;
            when 40 =&gt; result = 0x8ACE5422AA0DB;
            when 41 =&gt; result = 0x8F1AE99157736;
            when 42 =&gt; result = 0x93737B0CDC5E5;
            when 43 =&gt; result = 0x97D829FDE4E50;
            when 44 =&gt; result = 0x9C49182A3F090;
            when 45 =&gt; result = 0xA0C667B5DE565;
            when 46 =&gt; result = 0xA5503B23E255D;
            when 47 =&gt; result = 0xA9E6B5579FDBF;
            when 48 =&gt; result = 0xAE89F995AD3AD;
            when 49 =&gt; result = 0xB33A2B84F15FB;
            when 50 =&gt; result = 0xB7F76F2FB5E47;
            when 51 =&gt; result = 0xBCC1E904BC1D2;
            when 52 =&gt; result = 0xC199BDD85529C;
            when 53 =&gt; result = 0xC67F12E57D14B;
            when 54 =&gt; result = 0xCB720DCEF9069;
            when 55 =&gt; result = 0xD072D4A07897C;
            when 56 =&gt; result = 0xD5818DCFBA487;
            when 57 =&gt; result = 0xDA9E603DB3285;
            when 58 =&gt; result = 0xDFC97337B9B5F;
            when 59 =&gt; result = 0xE502EE78B3FF6;
            when 60 =&gt; result = 0xEA4AFA2A490DA;
            when 61 =&gt; result = 0xEFA1BEE615A27;
            when 62 =&gt; result = 0xF50765B6E4540;
            when 63 =&gt; result = 0xFA7C1819E90D8;
        end;
    end;

    return result[N-1:0];
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPLogB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPLogB</h3>
      <p class="pseudocode">// FPLogB()
// ========

func <a id="func_FPLogB_3"/>FPLogB{N}(op : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var result : integer;
    var (fptype,sign,value) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op, fpcr);

    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
        result = -(2^(N-1));            // MinInt, 100..00
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then
        result = 2^(N-1) - 1;           // MaxInt, 011..11
    else
        // FPUnpack has already scaled a subnormal input
        value = Abs(value);
        (value, result) = <a href="shared_pseudocode.html#func_NormalizeReal_1" title="">NormalizeReal</a>(value);

        FPProcessDenorm(fptype, N, fpcr);
    end;
    return result[N-1:0];
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPMinNormal"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPMinNormal</h3>
      <p class="pseudocode">// FPMinNormal()
// =============

func <a id="func_FPMinNormal_2"/>FPMinNormal{N}(sign : bit) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let E : integer{}  = (if N == 16 then 5 else (if N == 32 then 8 else 11));
    let F : integer{}  = N - (E + 1);
    let exp : bits(E)  = Zeros{E-1}::'1';
    let frac : bits(F) = Zeros{};
    return sign :: exp :: frac;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPOne"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPOne</h3>
      <p class="pseudocode">// FPOne()
// =======

func <a id="func_FPOne_2"/>FPOne{N}(sign : bit) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let E : integer{}  = (if N == 16 then 5 else (if N == 32 then 8 else 11));
    let F : integer{}  = N - (E + 1);
    let exp : bits(E)  = '0'::Ones{E-1};
    let frac : bits(F) = Zeros{};
    return sign :: exp :: frac;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPPointFive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPPointFive</h3>
      <p class="pseudocode">// FPPointFive()
// =============

func <a id="func_FPPointFive_2"/>FPPointFive{N}(sign : bit) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let E : integer{}  = (if N == 16 then 5 else (if N == 32 then 8 else 11));
    let F : integer{}  = N - (E + 1);
    let exp : bits(E)  = '0'::Ones{E-2}::'0';
    let frac : bits(F) = Zeros{};
    return sign :: exp :: frac;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPReducePredicated"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPReducePredicated</h3>
      <p class="pseudocode">// FPReducePredicated()
// ====================

func <a id="func_FPReducePredicated_8"/>FPReducePredicated{esize, N, M}(op : <a href="shared_pseudocode.html#type_ReduceOp" title="">ReduceOp</a>, input : bits(N), mask : bits(M),
                                     identity : bits(esize), fpcr : FPCR_Type) =&gt; bits(esize)
begin
    assert(N == M * 8);
    assert IsPow2(N);
    var operand : bits(N);
    let elements : integer = N DIV esize;

    for e = 0 to elements-1 do
        if e * esize &lt; N &amp;&amp; <a href="shared_pseudocode.html#func_ActivePredicateElement_4" title="">ActivePredicateElement</a>{M}(mask, e, esize) then
            operand[e*:esize] = input[e*:esize];
        else
            operand[e*:esize] = identity;
        end;
    end;

    return <a href="shared_pseudocode.html#func_FPReduce_5" title="">FPReduce</a>{esize, N}(op, operand, fpcr);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPTrigMAdd"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPTrigMAdd</h3>
      <p class="pseudocode">// FPTrigMAdd()
// ============

func <a id="func_FPTrigMAdd_5"/>FPTrigMAdd{N}(x_in : integer, op1 : bits(N), op2_in : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var coeff : bits(N);
    var op2 : bits(N) = op2_in;
    var x : integer = x_in;
    assert x &gt;= 0;
    assert x &lt; 8;

    if op2[N-1] == '1' then
        x = x + 8;
    end;

    coeff = <a href="shared_pseudocode.html#func_FPTrigMAddCoefficient_2" title="">FPTrigMAddCoefficient</a>{N}(x);
    // Safer to use EffectiveFPCR() in case the input fpcr argument
    // is modified as opposed to actual value of FPCR

    op2                    = <a href="shared_pseudocode.html#func_FPAbs_3" title="">FPAbs</a>{N}(op2, <a href="shared_pseudocode.html#func_EffectiveFPCR_0" title="">EffectiveFPCR</a>());
    let result : bits(N)   = FPMulAdd{}(coeff, op1, op2, fpcr);
    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPTrigMAddCoefficient"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPTrigMAddCoefficient</h3>
      <p class="pseudocode">// FPTrigMAddCoefficient()
// =======================

func <a id="func_FPTrigMAddCoefficient_2"/>FPTrigMAddCoefficient{N}(index : integer) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var result : integer;

    if N == 16 then
        case index of
            when  0 =&gt; result = 0x3c00;
            when  1 =&gt; result = 0xb155;
            when  2 =&gt; result = 0x2030;
            when  3 =&gt; result = 0x0000;
            when  4 =&gt; result = 0x0000;
            when  5 =&gt; result = 0x0000;
            when  6 =&gt; result = 0x0000;
            when  7 =&gt; result = 0x0000;
            when  8 =&gt; result = 0x3c00;
            when  9 =&gt; result = 0xb800;
            when 10 =&gt; result = 0x293a;
            when 11 =&gt; result = 0x0000;
            when 12 =&gt; result = 0x0000;
            when 13 =&gt; result = 0x0000;
            when 14 =&gt; result = 0x0000;
            when 15 =&gt; result = 0x0000;
        end;
    elsif N == 32 then
        case index of
            when  0 =&gt; result = 0x3f800000;
            when  1 =&gt; result = 0xbe2aaaab;
            when  2 =&gt; result = 0x3c088886;
            when  3 =&gt; result = 0xb95008b9;
            when  4 =&gt; result = 0x36369d6d;
            when  5 =&gt; result = 0x00000000;
            when  6 =&gt; result = 0x00000000;
            when  7 =&gt; result = 0x00000000;
            when  8 =&gt; result = 0x3f800000;
            when  9 =&gt; result = 0xbf000000;
            when 10 =&gt; result = 0x3d2aaaa6;
            when 11 =&gt; result = 0xbab60705;
            when 12 =&gt; result = 0x37cd37cc;
            when 13 =&gt; result = 0x00000000;
            when 14 =&gt; result = 0x00000000;
            when 15 =&gt; result = 0x00000000;
        end;
    else // N == 64
        case index of
            when  0 =&gt; result = 0x3ff0000000000000;
            when  1 =&gt; result = 0xbfc5555555555543;
            when  2 =&gt; result = 0x3f8111111110f30c;
            when  3 =&gt; result = 0xbf2a01a019b92fc6;
            when  4 =&gt; result = 0x3ec71de351f3d22b;
            when  5 =&gt; result = 0xbe5ae5e2b60f7b91;
            when  6 =&gt; result = 0x3de5d8408868552f;
            when  7 =&gt; result = 0x0000000000000000;
            when  8 =&gt; result = 0x3ff0000000000000;
            when  9 =&gt; result = 0xbfe0000000000000;
            when 10 =&gt; result = 0x3fa5555555555536;
            when 11 =&gt; result = 0xbf56c16c16c13a0b;
            when 12 =&gt; result = 0x3efa01a019b1e8d8;
            when 13 =&gt; result = 0xbe927e4f7282f468;
            when 14 =&gt; result = 0x3e21ee96d2641b13;
            when 15 =&gt; result = 0xbda8f76380fbb401;
        end;
    end;

    return result[N-1:0];
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPTrigSMul"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPTrigSMul</h3>
      <p class="pseudocode">// FPTrigSMul()
// ============

func <a id="func_FPTrigSMul_4"/>FPTrigSMul{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var result : bits(N) = FPMul{}(op1, op1, fpcr);
    let fpexc = FALSE;
    let (fptype, sign, value) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(result, fpcr, fpexc);

    if ! fptype IN {<a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>, <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>} then
        result[N-1] = op2[0];
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPTrigSSel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPTrigSSel</h3>
      <p class="pseudocode">// FPTrigSSel()
// ============

func <a id="func_FPTrigSSel_3"/>FPTrigSSel{N}(op1 : bits(N), op2 : bits(N)) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var result : bits(N);

    if op2[0] == '1' then
        result = <a href="shared_pseudocode.html#func_FPOne_2" title="">FPOne</a>{N}(op2[1]);
    elsif op2[1] == '1' then
        result = <a href="shared_pseudocode.html#func_FPNeg_3" title="">FPNeg</a>{N}(op1, <a href="shared_pseudocode.html#func_EffectiveFPCR_0" title="">EffectiveFPCR</a>());
    else
        result = op1;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FirstActive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FirstActive</h3>
      <p class="pseudocode">// FirstActive()
// =============

func <a id="func_FirstActive_4"/>FirstActive{N}(mask : bits(N), x : bits(N), esize : integer) =&gt; bit
begin
    let elements : integer = N DIV (esize DIV 8);
    for e = 0 to elements-1 do
        if <a href="shared_pseudocode.html#func_ActivePredicateElement_4" title="">ActivePredicateElement</a>{N}(mask, e, esize) then
            return <a href="shared_pseudocode.html#func_PredicateElement_4" title="">PredicateElement</a>{N}(x, e, esize);
        end;
    end;
    return '0';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2FP8DOT2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2FP8DOT2</h3>
      <p class="pseudocode">// HaveSVE2FP8DOT2()
// =================
// Returns TRUE if SVE2 FP8 dot product to half-precision instructions
// are implemented, FALSE otherwise.

func <a id="func_HaveSVE2FP8DOT2_0"/>HaveSVE2FP8DOT2() =&gt; boolean
begin
    return ((IsFeatureImplemented(FEAT_SVE2) &amp;&amp; IsFeatureImplemented(FEAT_FP8DOT2)) ||
            IsFeatureImplemented(FEAT_SSVE_FP8DOT2));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2FP8DOT4"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2FP8DOT4</h3>
      <p class="pseudocode">// HaveSVE2FP8DOT4()
// =================
// Returns TRUE if SVE2 FP8 dot product to single-precision instructions
// are implemented, FALSE otherwise.

func <a id="func_HaveSVE2FP8DOT4_0"/>HaveSVE2FP8DOT4() =&gt; boolean
begin
    return ((IsFeatureImplemented(FEAT_SVE2) &amp;&amp; IsFeatureImplemented(FEAT_FP8DOT4)) ||
            IsFeatureImplemented(FEAT_SSVE_FP8DOT4));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2FP8FMA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2FP8FMA</h3>
      <p class="pseudocode">// HaveSVE2FP8FMA()
// ================
// Returns TRUE if SVE2 FP8 multiply-accumulate to half-precision and single-precision
// instructions are implemented, FALSE otherwise.

func <a id="func_HaveSVE2FP8FMA_0"/>HaveSVE2FP8FMA() =&gt; boolean
begin
    return ((IsFeatureImplemented(FEAT_SVE2) &amp;&amp; IsFeatureImplemented(FEAT_FP8FMA)) ||
            IsFeatureImplemented(FEAT_SSVE_FP8FMA));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ImplementedSMEVectorLength"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ImplementedSMEVectorLength</h3>
      <p class="pseudocode">// ImplementedSMEVectorLength()
// ============================
// Reduce SVE/SME vector length to a supported value (power of two)

readonly func ImplementedSMEVectorLength(nbits_in : integer) =&gt; <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a>
begin
    let maxbits : <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a> = MaxImplementedSVL();
    assert 128 &lt;= maxbits &amp;&amp; maxbits &lt;= 2048 &amp;&amp; IsPow2(maxbits);
    var nbits : integer = Min(nbits_in, maxbits);
    assert 128 &lt;= nbits &amp;&amp; nbits &lt;= 2048 &amp;&amp; AlignDownSize(nbits, 128) == nbits;

    // Search for a supported power-of-two VL less than or equal to nbits
    while nbits &gt; 128 &amp;&amp; !SupportedPowerTwoSVL(nbits) looplimit 7 do
        nbits = nbits - 128;
    end;

    // Return the smallest supported power-of-two VL
    while nbits &lt; maxbits &amp;&amp; !SupportedPowerTwoSVL(nbits) looplimit 7 do
        nbits = nbits * 2;
    end;

    return nbits as <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ImplementedSVEVectorLength"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ImplementedSVEVectorLength</h3>
      <p class="pseudocode">// ImplementedSVEVectorLength()
// ============================
// Reduce SVE vector length to a supported value (power of two)

readonly func ImplementedSVEVectorLength(nbits_in : integer) =&gt; <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a>
begin
    let maxbits : integer = MaxImplementedVL();
    assert 128 &lt;= maxbits &amp;&amp; maxbits &lt;= 2048 &amp;&amp; IsPow2(maxbits);
    var nbits : integer = Min(nbits_in, maxbits);
    assert 128 &lt;= nbits &amp;&amp; nbits &lt;= 2048 &amp;&amp; AlignDownSize(nbits, 128) == nbits;

    while !IsPow2(nbits) looplimit 7 do
        nbits = nbits - 128;
    end;
    return nbits as <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.InStreamingMode"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/InStreamingMode</h3>
      <p class="pseudocode">// InStreamingMode()
// =================

func <a id="func_InStreamingMode_0"/>InStreamingMode() =&gt; boolean
begin
    return IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.SM == '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IntReducePredicated"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IntReducePredicated</h3>
      <p class="pseudocode">// IntReducePredicated()
// =====================

func <a id="func_IntReducePredicated_7"/>IntReducePredicated{esize, N, M}(op : <a href="shared_pseudocode.html#type_ReduceOp" title="">ReduceOp</a>, input : bits(N),
                                      mask : bits(M), identity : bits(esize)) =&gt; bits(esize)
begin
    assert(N == M * 8);
    assert IsPow2(N);
    var operand : bits(N);
    let elements : integer = N DIV esize;

    for e = 0 to elements-1 do
        if e * esize &lt; N &amp;&amp; <a href="shared_pseudocode.html#func_ActivePredicateElement_4" title="">ActivePredicateElement</a>{M}(mask, e, esize) then
            operand[e*:esize] = input[e*:esize];
        else
            operand[e*:esize] = identity;
        end;
    end;

    return <a href="shared_pseudocode.html#func_IntReduce_4" title="">IntReduce</a>{esize, N}(op, operand);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsFPEnabled</h3>
      <p class="pseudocode">// IsFPEnabled()
// =============
// Returns TRUE if accesses to the Advanced SIMD and floating-point
// registers are enabled at the target exception level in the current
// execution state and FALSE otherwise.

func <a id="func_IsFPEnabled_1"/>IsFPEnabled(el : bits(2)) =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(el) then
        return <a href="shared_pseudocode.html#func_AArch32_IsFPEnabled_1" title="">AArch32_IsFPEnabled</a>(el);
    else
        return <a href="shared_pseudocode.html#func_AArch64_IsFPEnabled_1" title="">AArch64_IsFPEnabled</a>(el);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsFullA64Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsFullA64Enabled</h3>
      <p class="pseudocode">// IsFullA64Enabled()
// ==================
// Returns TRUE if full A64 is enabled in Streaming mode and FALSE othersise.

func <a id="func_IsFullA64Enabled_0"/>IsFullA64Enabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_SME_FA64) then return FALSE; end;

    // Check if full A64 disabled in SMCR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        // Check full A64 at EL0/EL1
        if SMCR_EL1().FA64 == '0' then return FALSE; end;
    end;

    // Check if full A64 disabled in SMCR_EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if SMCR_EL2().FA64 == '0' then return FALSE; end;
    end;

    // Check if full A64 disabled in SMCR_EL3
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if SMCR_EL3().FA64 == '0' then return FALSE; end;
    end;

    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsOriginalSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsOriginalSVEEnabled</h3>
      <p class="pseudocode">// IsOriginalSVEEnabled()
// ======================
// Returns TRUE if access to SVE functionality is enabled at the target
// exception level and FALSE otherwise.

func <a id="func_IsOriginalSVEEnabled_1"/>IsOriginalSVEEnabled(el : bits(2)) =&gt; boolean
begin
    var disabled : boolean;
    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(el) then
        return FALSE;
    end;

    // Check if access disabled in CPACR_EL1
    if el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        // Check SVE at EL0/EL1
        case CPACR_EL1().ZEN of
            when 'x0' =&gt; disabled = TRUE;
            when '01' =&gt; disabled = el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
            when '11' =&gt; disabled = FALSE;
        end;
        if disabled then return FALSE; end;
    end;

    // Check if access disabled in CPTR_EL2
    if el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            case CPTR_EL2().ZEN of
                when 'x0' =&gt; disabled = TRUE;
                when '01' =&gt; disabled = el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; HCR_EL2().TGE == '1';
                when '11' =&gt; disabled = FALSE;
            end;
            if disabled then return FALSE; end;
        else
            if CPTR_EL2().TZ == '1' then return FALSE; end;
        end;
    end;

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if CPTR_EL3().EZ == '0' then return FALSE; end;
    end;

    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsSMEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsSMEEnabled</h3>
      <p class="pseudocode">// IsSMEEnabled()
// ==============
// Returns TRUE if access to SME functionality is enabled at the target
// exception level and FALSE otherwise.

func <a id="func_IsSMEEnabled_1"/>IsSMEEnabled(el : bits(2)) =&gt; boolean
begin
    var disabled : boolean;
    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(el) then
        return FALSE;
    end;

    // Check if access disabled in CPACR_EL1
    if el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        // Check SME at EL0/EL1
        case CPACR_EL1().SMEN of
            when 'x0' =&gt; disabled = TRUE;
            when '01' =&gt; disabled = el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
            when '11' =&gt; disabled = FALSE;
        end;
        if disabled then return FALSE; end;
    end;

    // Check if access disabled in CPTR_EL2
    if el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            case CPTR_EL2().SMEN of
                when 'x0' =&gt; disabled = TRUE;
                when '01' =&gt; disabled = el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; HCR_EL2().TGE == '1';
                when '11' =&gt; disabled = FALSE;
            end;
            if disabled then return FALSE; end;
        else
            if CPTR_EL2().TSM == '1' then return FALSE; end;
        end;
    end;

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if CPTR_EL3().ESM == '0' then return FALSE; end;
    end;

    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsSVEEnabled</h3>
      <p class="pseudocode">// IsSVEEnabled()
// ==============
// Returns TRUE if access to SVE registers is enabled at the target exception
// level and FALSE otherwise.

func <a id="func_IsSVEEnabled_1"/>IsSVEEnabled(el : bits(2)) =&gt; boolean
begin
    if IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.SM == '1' then
        return <a href="shared_pseudocode.html#func_IsSMEEnabled_1" title="">IsSMEEnabled</a>(el);
    elsif IsFeatureImplemented(FEAT_SVE) then
        return <a href="shared_pseudocode.html#func_IsOriginalSVEEnabled_1" title="">IsOriginalSVEEnabled</a>(el);
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.LastActive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/LastActive</h3>
      <p class="pseudocode">// LastActive()
// ============

func <a id="func_LastActive_4"/>LastActive{N}(mask : bits(N), x : bits(N), esize : integer) =&gt; bit
begin
    let elements : integer = N DIV (esize DIV 8);
    for e = elements-1 downto 0 do
        if <a href="shared_pseudocode.html#func_ActivePredicateElement_4" title="">ActivePredicateElement</a>{N}(mask, e, esize) then
            return <a href="shared_pseudocode.html#func_PredicateElement_4" title="">PredicateElement</a>{N}(x, e, esize);
        end;
    end;
    return '0';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.LastActiveElement"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/LastActiveElement</h3>
      <p class="pseudocode">// LastActiveElement()
// ===================

func <a id="func_LastActiveElement_3"/>LastActiveElement{N}(mask : bits(N), esize : integer) =&gt; integer
begin
    let elements : integer = N DIV (esize DIV 8);
    for e = elements-1 downto 0 do
        if <a href="shared_pseudocode.html#func_ActivePredicateElement_4" title="">ActivePredicateElement</a>{N}(mask, e, esize) then return e; end;
    end;
    return -1;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MaxImplementedAnyVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MaxImplementedAnyVL</h3>
      <p class="pseudocode">// MaxImplementedAnyVL()
// =====================

readonly func <a id="func_MaxImplementedAnyVL_0"/>MaxImplementedAnyVL() =&gt; integer
begin
    if IsFeatureImplemented(FEAT_SME) &amp;&amp; IsFeatureImplemented(FEAT_SVE) then
        return Max(<a href="shared_pseudocode.html#func_MaxImplementedVL_0" title="">MaxImplementedVL</a>(), MaxImplementedSVL());
    end;
    if IsFeatureImplemented(FEAT_SME) then
        return MaxImplementedSVL();
    end;
    return <a href="shared_pseudocode.html#func_MaxImplementedVL_0" title="">MaxImplementedVL</a>();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MaxImplementedSVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MaxImplementedSVL</h3>
      <p class="pseudocode">// MaxImplementedSVL()
// ===================

readonly func MaxImplementedSVL() =&gt; <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a>
begin
    return ImpDefInt("Max implemented SVL") as <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MaxImplementedVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MaxImplementedVL</h3>
      <p class="pseudocode">// MaxImplementedVL()
// ==================

readonly func <a id="func_MaxImplementedVL_0"/>MaxImplementedVL() =&gt; integer
begin
    return ImpDefInt("Max implemented VL");
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MaybeZeroSVEUppers"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MaybeZeroSVEUppers</h3>
      <p class="pseudocode">// MaybeZeroSVEUppers()
// ====================

func MaybeZeroSVEUppers(target_el : bits(2))
begin
    var lower_enabled : boolean;

    if UInt(target_el) &lt;= UInt(PSTATE.EL) || !<a href="shared_pseudocode.html#func_IsSVEEnabled_1" title="">IsSVEEnabled</a>(target_el) then
        return;
    end;

    if target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
        if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
            lower_enabled = <a href="shared_pseudocode.html#func_IsFPEnabled_1" title="">IsFPEnabled</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
        else
            lower_enabled = <a href="shared_pseudocode.html#func_IsFPEnabled_1" title="">IsFPEnabled</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
        end;
    elsif target_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        assert <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
        if HCR_EL2().TGE == '0' then
            lower_enabled = <a href="shared_pseudocode.html#func_IsFPEnabled_1" title="">IsFPEnabled</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
        else
            lower_enabled = <a href="shared_pseudocode.html#func_IsFPEnabled_1" title="">IsFPEnabled</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>);
        end;
    else
        assert target_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
        lower_enabled = <a href="shared_pseudocode.html#func_IsFPEnabled_1" title="">IsFPEnabled</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>);
    end;

    if lower_enabled then
        let VL : integer{} = if <a href="shared_pseudocode.html#func_IsSVEEnabled_1" title="">IsSVEEnabled</a>(PSTATE.EL) then CurrentVL() else 128;
        let PL : integer{} = VL DIV 8;
        for n = 0 to 31 do
            if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_SVEZEROUPPER" title="">Unpredictable_SVEZEROUPPER</a>) then
                _Z[[n]] = ZeroExtend{MAX_VL}(_Z[[n]][VL-1:0]);
            end;
        end;
        for n = 0 to 15 do
            if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_SVEZEROUPPER" title="">Unpredictable_SVEZEROUPPER</a>) then
                _P[[n]] = ZeroExtend{MAX_PL}(_P[[n]][PL-1:0]);
            end;
        end;
        if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_SVEZEROUPPER" title="">Unpredictable_SVEZEROUPPER</a>) then
            _FFR = ZeroExtend{MAX_PL}(_FFR[PL-1:0]);
        end;
        if IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.ZA == '1' then
            let SVL : integer{}          = CurrentSVL();
            let accessiblevecs : integer = SVL DIV 8;
            let allvecs : integer        = MaxImplementedSVL() DIV 8;

            for n = 0 to accessiblevecs - 1 do
                if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_SMEZEROUPPER" title="">Unpredictable_SMEZEROUPPER</a>) then
                    <a href="shared_pseudocode.html#global__ZA" title="">_ZA</a>[[n]] = ZeroExtend{MAX_VL}(<a href="shared_pseudocode.html#global__ZA" title="">_ZA</a>[[n]][SVL-1:0]);
                end;
            end;
            for n = accessiblevecs to allvecs - 1 do
                if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_SMEZEROUPPER" title="">Unpredictable_SMEZEROUPPER</a>) then
                    <a href="shared_pseudocode.html#global__ZA" title="">_ZA</a>[[n]] = Zeros{MAX_VL};
                end;
            end;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MemNF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MemNF</h3>
      <p class="pseudocode">// MemNF
// =====

func <a id="func_MemNF_3"/>MemNF{size : integer{8, 16, 32, 64, 128}}(address : bits(64),
                                               accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
                                              ) =&gt; (bits(size), boolean)
begin
    let bytes : integer{} = size DIV 8;
    var value : bits(size);
    var bad : boolean;

    var aligned : boolean = IsAlignedSize{64}(address, bytes);

    if !aligned &amp;&amp; <a href="shared_pseudocode.html#func_AlignmentEnforced_0" title="">AlignmentEnforced</a>() then
        return (ARBITRARY : bits(size), TRUE);
    end;

    let atomic : boolean = aligned || bytes == 1;

    if !atomic then
        (value[7:0], bad) = <a href="shared_pseudocode.html#func_MemSingleNF_4" title="">MemSingleNF</a>{8}(address, accdesc, aligned);

        if bad then
            return (ARBITRARY : bits(size), TRUE);
        end;

        // For subsequent bytes, if they cross to a new translation page which assigns
        // Device memory type, it is CONSTRAINED UNPREDICTABLE whether an unaligned access
        // will generate an Alignment Fault.
        if !aligned then
            let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_DEVPAGE2" title="">Unpredictable_DEVPAGE2</a>);
            assert c IN {<a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a>, <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>};
            if c == <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a> then aligned = TRUE; end;
        end;

        for i = 1 to bytes-1 do
            (value[i*:8], bad) = <a href="shared_pseudocode.html#func_MemSingleNF_4" title="">MemSingleNF</a>{8}(address+i, accdesc, aligned);

            if bad then
                return (ARBITRARY : bits(size), TRUE);
            end;
        end;
    else
        (value, bad) = <a href="shared_pseudocode.html#func_MemSingleNF_4" title="">MemSingleNF</a>{size}(address, accdesc, aligned);
        if bad then
            return (ARBITRARY : bits(size), TRUE);
        end;
    end;

    if <a href="shared_pseudocode.html#func_BigEndian_1" title="">BigEndian</a>(accdesc.acctype) then
        value = <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{size}(value);
    end;

    return (value, FALSE);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MemSingleNF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MemSingleNF</h3>
      <p class="pseudocode">// MemSingleNF
// ===========

func <a id="func_MemSingleNF_4"/>MemSingleNF{size : integer{8, 16, 32, 64, 128}}(address : bits(64),
                                                     accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                                     aligned : boolean) =&gt; (bits(size), boolean)
begin
    assert accdesc_in.acctype == <a href="shared_pseudocode.html#enum_AccessType_SVE" title="">AccessType_SVE</a>;
    assert accdesc_in.nonfault || (accdesc_in.firstfault &amp;&amp; !accdesc_in.first);

    let bytes : integer{} = size DIV 8;
    var value : bits(size);
    var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, address);

    // Implementation may suppress NF load for any reason
    if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_NONFAULT" title="">Unpredictable_NONFAULT</a>) then
        return (ARBITRARY : bits(size), TRUE);
    end;

    // If the instruction encoding permits tag checking, confer with system register configuration
    // which may override this.
    if accdesc.tagchecked then
        accdesc.tagchecked = <a href="shared_pseudocode.html#func_AArch64_AccessIsTagChecked_2" title="">AArch64_AccessIsTagChecked</a>(address, accdesc);
    end;

    // MMU or MPU
    memaddrdesc = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(address, accdesc, aligned, bytes);

    // Non-fault load from Device memory must not be performed externally
    if memaddrdesc.memattrs.memtype == MemType_Device then
        return (ARBITRARY : bits(size), TRUE);
    end;

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        return (ARBITRARY : bits(size), TRUE);
    end;

    if accdesc.tagchecked then
        let ltag : bits(4) = <a href="shared_pseudocode.html#func_AArch64_LogicalAddressTag_1" title="">AArch64_LogicalAddressTag</a>(address);
        fault = AArch64_CheckTag(memaddrdesc, accdesc, bytes, ltag);
        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            return (ARBITRARY : bits(size), TRUE);
        end;
    end;

    (memstatus, value) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{size}(memaddrdesc, accdesc);
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
        let iswrite : boolean = FALSE;
        if <a href="shared_pseudocode.html#func_IsExternalAbortTakenSynchronously_5" title="">IsExternalAbortTakenSynchronously</a>(memstatus, iswrite, memaddrdesc, bytes, accdesc) then
            return (ARBITRARY : bits(size), TRUE);
        end;
        fault.merrorstate = memstatus.merrorstate;
        fault.extflag    = memstatus.extflag;
        fault.statuscode = memstatus.statuscode;
        PendSErrorInterrupt(fault);
    end;

    return (value, FALSE);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.NoneActive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/NoneActive</h3>
      <p class="pseudocode">// NoneActive()
// ============

func <a id="func_NoneActive_4"/>NoneActive{N}(mask : bits(N), x : bits(N), esize : integer) =&gt; bit
begin
    let elements : integer = N DIV (esize DIV 8);
    for e = 0 to elements-1 do
        if <a href="shared_pseudocode.html#func_ActivePredicateElement_4" title="">ActivePredicateElement</a>{N}(mask, e, esize) &amp;&amp; <a href="shared_pseudocode.html#func_ActivePredicateElement_4" title="">ActivePredicateElement</a>{N}(x, e, esize) then
            return '0';
        end;
    end;
    return '1';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.P"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/P</h3>
      <p class="pseudocode">// P - accessor
// ============

accessor <a id="accessor_P_2"/>P{width}(n : integer) &lt;=&gt; value : bits(width)
begin
    getter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        assert width == CurrentVL() DIV 8;
        return _P[[n]][width-1:0];
    end;

    setter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        assert width == CurrentVL() DIV 8;
        if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_SVEZEROUPPER" title="">Unpredictable_SVEZEROUPPER</a>) then
            _P[[n]] = ZeroExtend{MAX_PL}(value);
        else
            _P[[n]][width-1:0] = value;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.PredLen"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/PredLen</h3>
      <p class="pseudocode">// PredLen
// =======

type <a id="PredLen"/>PredLen of integer{16, 32, 64, 128, 256};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.PredTest"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/PredTest</h3>
      <p class="pseudocode">// PredTest()
// ==========

func <a id="func_PredTest_4"/>PredTest{N}(mask : bits(N), result : bits(N), esize : integer) =&gt; bits(4)
begin
    let n : bit = <a href="shared_pseudocode.html#func_FirstActive_4" title="">FirstActive</a>{N}(mask, result, esize);
    let z : bit = <a href="shared_pseudocode.html#func_NoneActive_4" title="">NoneActive</a>{N}(mask, result, esize);
    let c : bit = NOT <a href="shared_pseudocode.html#func_LastActive_4" title="">LastActive</a>{N}(mask, result, esize);
    let v : bit = '0';
    return n::z::c::v;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.PredicateElement"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/PredicateElement</h3>
      <p class="pseudocode">// PredicateElement()
// ==================
// Returns the predicate bit

func <a id="func_PredicateElement_4"/>PredicateElement{N}(pred : bits(N), e : integer, esize : integer) =&gt; bit
begin
    assert esize IN {8, 16, 32, 64, 128};
    let n : integer = e * (esize DIV 8);
    assert n &gt;= 0 &amp;&amp; n &lt; N;
    return pred[n];
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ResetSMEState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ResetSMEState</h3>
      <p class="pseudocode">// ResetSMEState()
// ===============

func ResetSMEState(newenable : bit)
begin
    let vectors : integer = MAX_VL DIV 8;
    if newenable == '1' then
        for n = 0 to vectors - 1 do
            <a href="shared_pseudocode.html#global__ZA" title="">_ZA</a>[[n]] = Zeros{MAX_VL};
        end;
        if IsFeatureImplemented(FEAT_SME2) then
            <a href="shared_pseudocode.html#global__ZT0" title="">_ZT0</a> = Zeros{ZT0_LEN};
        end;
    else
        for n = 0 to vectors - 1 do
            <a href="shared_pseudocode.html#global__ZA" title="">_ZA</a>[[n]] = ARBITRARY : bits(MAX_VL);
        end;
        if IsFeatureImplemented(FEAT_SME2) then
            <a href="shared_pseudocode.html#global__ZT0" title="">_ZT0</a> = ARBITRARY : bits(ZT0_LEN);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ResetSVERegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ResetSVERegisters</h3>
      <p class="pseudocode">// ResetSVERegisters()
// ===================

func ResetSVERegisters()
begin
    for n = 0 to 31 do
        _Z[[n]] = ARBITRARY : bits(MAX_VL);
    end;
    for n = 0 to 15 do
        _P[[n]] = ARBITRARY : bits(MAX_PL);
    end;
    _FFR = ARBITRARY : bits(MAX_PL);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ResetSVEState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ResetSVEState</h3>
      <p class="pseudocode">// ResetSVEState()
// ===============

func ResetSVEState()
begin
    for n = 0 to 31 do
        _Z[[n]] = Zeros{MAX_VL};
    end;
    for n = 0 to 15 do
        _P[[n]] = Zeros{MAX_PL};
    end;
    _FFR = Zeros{MAX_PL};
    FPSR() = ZeroExtend{64}(0x0800009f[31:0]);
    FPMR() = Zeros{64};
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SMEAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SMEAccessTrap</h3>
      <p class="pseudocode">// SMEAccessTrap()
// ===============
// Trapped access to SME registers due to CPACR_EL1, CPTR_EL2, or CPTR_EL3.

func SMEAccessTrap(etype : <a href="shared_pseudocode.html#type_SMEExceptionType" title="">SMEExceptionType</a>, target_el_in : bits(2))
begin
    var target_el : bits(2) = target_el_in;
    assert UInt(target_el) &gt;= UInt(PSTATE.EL);
    if target_el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        target_el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    end;
    var route_to_el2 : boolean;
    route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1';

    var except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>              = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SMEAccessTrap" title="">Exception_SMEAccessTrap</a>);
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer                 = 0x0;

    case etype of
        when <a href="shared_pseudocode.html#enum_SMEExceptionType_AccessTrap" title="">SMEExceptionType_AccessTrap</a> =&gt;
            except.syndrome.iss[2:0] = '000';
        when <a href="shared_pseudocode.html#enum_SMEExceptionType_Streaming" title="">SMEExceptionType_Streaming</a> =&gt;
            except.syndrome.iss[2:0] = '001';
        when <a href="shared_pseudocode.html#enum_SMEExceptionType_NotStreaming" title="">SMEExceptionType_NotStreaming</a> =&gt;
            except.syndrome.iss[2:0] = '010';
        when <a href="shared_pseudocode.html#enum_SMEExceptionType_InactiveZA" title="">SMEExceptionType_InactiveZA</a> =&gt;
            except.syndrome.iss[2:0] = '011';
        when <a href="shared_pseudocode.html#enum_SMEExceptionType_InaccessibleZT0" title="">SMEExceptionType_InaccessibleZT0</a> =&gt;
            except.syndrome.iss[2:0] = '100';
    end;

    if route_to_el2 then
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    else
        AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SMEExceptionType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SMEExceptionType</h3>
      <p class="pseudocode">// SMEExceptionType
// ================
type <a id="type_SMEExceptionType"/>SMEExceptionType of enumeration {
    <a id="enum_SMEExceptionType_AccessTrap"/>SMEExceptionType_AccessTrap,        // SME functionality trapped or disabled
    <a id="enum_SMEExceptionType_Streaming"/>SMEExceptionType_Streaming,         // Illegal instruction in Streaming SVE mode
    <a id="enum_SMEExceptionType_NotStreaming"/>SMEExceptionType_NotStreaming,      // Illegal instruction not in Streaming SVE mode
    <a id="enum_SMEExceptionType_InactiveZA"/>SMEExceptionType_InactiveZA,        // Illegal instruction when ZA is inactive
    <a id="enum_SMEExceptionType_InaccessibleZT0"/>SMEExceptionType_InaccessibleZT0,   // Access to ZT0 is disabled
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SVCR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SVCR</h3>
      <p class="pseudocode">// SVCR
// ====

accessor <a id="accessor_SVCR_0"/>SVCR() &lt;=&gt; value : SVCR_Type
begin
    // Returns PSTATE.[ZA, SM]
    getter
        let value : SVCR_Type = Zeros{62} :: PSTATE.ZA :: PSTATE.SM;
        return value;
    end;

    // Sets PSTATE.[ZA, SM]
    setter
        SetPSTATE_SM(value[0]);
        SetPSTATE_ZA(value[1]);
        return;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SVEAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SVEAccessTrap</h3>
      <p class="pseudocode">// SVEAccessTrap()
// ===============
// Trapped access to SVE registers due to CPACR_EL1, CPTR_EL2, or CPTR_EL3.

func SVEAccessTrap(target_el : bits(2))
begin
    assert UInt(target_el) &gt;= UInt(PSTATE.EL) &amp;&amp; target_el != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(target_el);
    let route_to_el2 : boolean = target_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1';

    let except : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>              = <a href="shared_pseudocode.html#func_ExceptionSyndrome_1" title="">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#enum_Exception_SVEAccessTrap" title="">Exception_SVEAccessTrap</a>);
    let preferred_exception_return : bits(64) = ThisInstrAddr{}();
    let vect_offset : integer{}               = 0x0;

    if route_to_el2 then
        AArch64_TakeException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, except, preferred_exception_return, vect_offset);
    else
        AArch64_TakeException(target_el, except, preferred_exception_return, vect_offset);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SVEMoveMaskPreferred"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SVEMoveMaskPreferred</h3>
      <p class="pseudocode">// SVEMoveMaskPreferred()
// ======================
// Return FALSE if a bitmask immediate encoding would generate an immediate
// value that could also be represented by a single DUP instruction.
// Used as a condition for the preferred MOV&lt;-DUPM alias.

func <a id="func_SVEMoveMaskPreferred_1"/>SVEMoveMaskPreferred(imm13 : bits(13)) =&gt; boolean
begin
    var imm : bits(64);
    (imm, -) = <a href="shared_pseudocode.html#func_DecodeBitMasks_5" title="">DecodeBitMasks</a>{64}(imm13[12], imm13[5:0], imm13[11:6], TRUE);

    // Check for 8 bit immediates
    if !IsZero(imm[7:0]) then
        // Check for 'ffffffffffffffxy' or '00000000000000xy'
        if IsZero(imm[63:7]) || IsOnes(imm[63:7]) then
            return FALSE;
        end;

        // Check for 'ffffffxyffffffxy' or '000000xy000000xy'
        if imm[63:32] == imm[31:0] &amp;&amp; (IsZero(imm[31:7]) || IsOnes(imm[31:7])) then
            return FALSE;
        end;

        // Check for 'ffxyffxyffxyffxy' or '00xy00xy00xy00xy'
        if (imm[63:32] == imm[31:0] &amp;&amp; imm[31:16] == imm[15:0] &amp;&amp;
              (IsZero(imm[15:7]) || IsOnes(imm[15:7]))) then
            return FALSE;
        end;

        // Check for 'xyxyxyxyxyxyxyxy'
        if imm[63:32] == imm[31:0] &amp;&amp; imm[31:16] == imm[15:0] &amp;&amp; (imm[15:8] == imm[7:0]) then
            return FALSE;
        end;

    // Check for 16 bit immediates
    else
        // Check for 'ffffffffffffxy00' or '000000000000xy00'
        if IsZero(imm[63:15]) || IsOnes(imm[63:15]) then
            return FALSE;
        end;

        // Check for 'ffffxy00ffffxy00' or '0000xy000000xy00'
        if imm[63:32] == imm[31:0] &amp;&amp; (IsZero(imm[31:7]) || IsOnes(imm[31:7])) then
            return FALSE;
        end;

        // Check for 'xy00xy00xy00xy00'
        if imm[63:32] == imm[31:0] &amp;&amp; imm[31:16] == imm[15:0] then
            return FALSE;
        end;
    end;

    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SetPSTATE_SM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SetPSTATE_SM</h3>
      <p class="pseudocode">// SetPSTATE_SM()
// ==============

func SetPSTATE_SM(value : bit)
begin
    if PSTATE.SM != value then
        ResetSVEState();
        PSTATE.SM = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SetPSTATE_ZA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SetPSTATE_ZA</h3>
      <p class="pseudocode">// SetPSTATE_ZA()
// ==============

func SetPSTATE_ZA(value : bit)
begin
    if PSTATE.ZA != value then
        ResetSMEState(value);
        PSTATE.ZA = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SupportedPowerTwoSVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SupportedPowerTwoSVL</h3>
      <p class="pseudocode">// SupportedPowerTwoSVL()
// ======================
// Return an IMPLEMENTATION DEFINED specific value
// returns TRUE if SVL is supported and is a power of two, FALSE otherwise

readonly impdef func <a id="func_SupportedPowerTwoSVL_0"/>SupportedPowerTwoSVL(nbits : integer) =&gt; boolean
begin
    return IsPow2(nbits) &amp;&amp; (nbits &lt;= MAX_VL);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.System"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/System</h3>
      <p class="pseudocode">// System Registers
// ================

constant MAX_VL : <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a> = 2048;

constant MAX_PL : <a href="shared_pseudocode.html#PredLen" title="type PredLen">PredLen</a> = 256;

constant ZT0_LEN : integer{} = 512;

var _Z : array [[32]] of bits(MAX_VL);

var _P : array [[16]] of bits(MAX_PL);

var _FFR : bits(MAX_PL);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.VecLen"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/VecLen</h3>
      <p class="pseudocode">// VecLen
// ======

type <a id="VecLen"/>VecLen of integer{128, 256, 512, 1024, 2048};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.Z"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/Z</h3>
      <p class="pseudocode">// Z - accessor
// ============

accessor <a id="accessor_Z_2"/>Z{width}(n : integer) &lt;=&gt; value : bits(width)
begin
    getter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        assert width == CurrentVL();
        return _Z[[n]][width-1:0];
    end;
    setter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        assert width == CurrentVL();
        if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_SVEZEROUPPER" title="">Unpredictable_SVEZEROUPPER</a>) then
            _Z[[n]] = ZeroExtend{MAX_VL}(value);
        else
            _Z[[n]][width-1:0] = value;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.syshintop.SystemHintOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/syshintop/SystemHintOp</h3>
      <p class="pseudocode">// SystemHintOp
// ============
// System Hint instruction types.

type <a id="type_SystemHintOp"/>SystemHintOp of enumeration {
    <a id="enum_SystemHintOp_NOP"/>SystemHintOp_NOP,
    <a id="enum_SystemHintOp_YIELD"/>SystemHintOp_YIELD,
    <a id="enum_SystemHintOp_WFE"/>SystemHintOp_WFE,
    <a id="enum_SystemHintOp_WFI"/>SystemHintOp_WFI,
    <a id="enum_SystemHintOp_SEV"/>SystemHintOp_SEV,
    <a id="enum_SystemHintOp_SEVL"/>SystemHintOp_SEVL,
    <a id="enum_SystemHintOp_DGH"/>SystemHintOp_DGH,
    <a id="enum_SystemHintOp_ESB"/>SystemHintOp_ESB,
    <a id="enum_SystemHintOp_PSB"/>SystemHintOp_PSB,
    <a id="enum_SystemHintOp_TSB"/>SystemHintOp_TSB,
    <a id="enum_SystemHintOp_BTI"/>SystemHintOp_BTI,
    <a id="enum_SystemHintOp_WFET"/>SystemHintOp_WFET,
    <a id="enum_SystemHintOp_WFIT"/>SystemHintOp_WFIT,
    <a id="enum_SystemHintOp_CLRBHB"/>SystemHintOp_CLRBHB,
    <a id="enum_SystemHintOp_GCSB"/>SystemHintOp_GCSB,
    <a id="enum_SystemHintOp_CHKFEAT"/>SystemHintOp_CHKFEAT,
    <a id="enum_SystemHintOp_STSHH"/>SystemHintOp_STSHH,
    <a id="enum_SystemHintOp_SHUH"/>SystemHintOp_SHUH,
    <a id="enum_SystemHintOp_STCPH"/>SystemHintOp_STCPH,
    <a id="enum_SystemHintOp_CSDB"/>SystemHintOp_CSDB
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.syslop.SysLOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/syslop/SysLOp</h3>
      <p class="pseudocode">// SysLOp()
// ========

func <a id="func_SysLOp_4"/>SysLOp(op1 : bits(3), CRn : bits(4), CRm : bits(4), op2 : bits(3)) =&gt; <a href="shared_pseudocode.html#type_SystemLOp" title="">SystemLOp</a>
begin
    case op1::CRn::CRm::op2 of
        when '000 1100 0011 000' =&gt; return <a href="shared_pseudocode.html#enum_Sysl_GICR" title="">Sysl_GICR</a>;   // CDIA
        when '000 1100 0011 001' =&gt; return <a href="shared_pseudocode.html#enum_Sysl_GICR" title="">Sysl_GICR</a>;   // CDNMIA
        otherwise                =&gt; return <a href="shared_pseudocode.html#enum_Sysl_SYSL" title="">Sysl_SYSL</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.syslop.SystemLOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/syslop/SystemLOp</h3>
      <p class="pseudocode">// SystemLOp
// =========
// System instruction with result types.

type <a id="type_SystemLOp"/>SystemLOp of enumeration {
    <a id="enum_Sysl_GICR"/>Sysl_GICR,
    <a id="enum_Sysl_SYSL"/>Sysl_SYSL
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysop.SysOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysop/SysOp</h3>
      <p class="pseudocode">// SysOp()
// =======

func <a id="func_SysOp_4"/>SysOp(op1 : bits(3), CRn : bits(4), CRm : bits(4), op2 : bits(3)) =&gt; <a href="shared_pseudocode.html#type_SystemOp" title="">SystemOp</a>
begin
    case op1::CRn::CRm::op2 of
        when '000 0111 1000 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E1R
        when '000 0111 1000 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E1W
        when '000 0111 1000 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E0R
        when '000 0111 1000 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E0W
        when '000 0111 1001 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E1RP
        when '000 0111 1001 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E1WP
        when '000 0111 1001 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E1A
        when '100 0111 1000 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E2R
        when '100 0111 1000 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E2W
        when '100 0111 1001 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E2A
        when '100 0111 1000 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S12E1R
        when '100 0111 1000 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S12E1W
        when '100 0111 1000 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S12E0R
        when '100 0111 1000 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S12E0W
        when '110 0111 1000 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E3R
        when '110 0111 1000 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E3W
        when '110 0111 1001 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_AT" title="">Sys_AT</a>;    // S1E3A
        when '001 0111 0010 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_BRB" title="">Sys_BRB</a>;   // IALL
        when '001 0111 0010 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_BRB" title="">Sys_BRB</a>;   // INJ
        when '000 0111 0110 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // IVAC
        when '000 0111 0110 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // ISW
        when '000 0111 0110 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // IGVAC
        when '000 0111 0110 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // IGSW
        when '000 0111 0110 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // IGDVAC
        when '000 0111 0110 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // IGDSW
        when '000 0111 1010 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CSW
        when '000 0111 1010 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CGSW
        when '000 0111 1010 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CGDSW
        when '000 0111 1110 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CISW
        when '000 0111 1110 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CIGSW
        when '000 0111 1110 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CIGDSW
        when '011 0111 0100 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // ZVA
        when '011 0111 0100 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // GVA
        when '011 0111 0100 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // GZVA
        when '011 0111 1010 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CVAC
        when '011 0111 1010 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CGVAC
        when '011 0111 1010 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CGDVAC
        when '011 0111 1011 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CVAU
        when '011 0111 1100 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CVAP
        when '011 0111 1100 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CGVAP
        when '011 0111 1100 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CGDVAP
        when '011 0111 1101 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CVADP
        when '011 0111 1101 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CGVADP
        when '011 0111 1101 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CGDVADP
        when '011 0111 1110 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CIVAC
        when '011 0111 1110 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CIGVAC
        when '011 0111 1110 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CIGDVAC
        when '100 0111 1110 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CIPAE
        when '100 0111 1110 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CIGDPAE
        when '110 0111 1110 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CIPAPA
        when '110 0111 1110 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CIGDPAPA
        when '000 0111 1111 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CIVAPS
        when '000 0111 1111 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_DC" title="">Sys_DC</a>;    // CIGDVAPS
        when '000 0111 0001 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_IC" title="">Sys_IC</a>;    // IALLUIS
        when '000 0111 0101 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_IC" title="">Sys_IC</a>;    // IALLU
        when '011 0111 0101 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_IC" title="">Sys_IC</a>;    // IVAU
        when '000 1000 0001 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VMALLE1OS
        when '000 1000 0001 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE1OS
        when '000 1000 0001 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ASIDE1OS
        when '000 1000 0001 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAAE1OS
        when '000 1000 0001 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE1OS
        when '000 1000 0001 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAALE1OS
        when '000 1000 0010 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE1IS
        when '000 1000 0010 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAAE1IS
        when '000 1000 0010 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE1IS
        when '000 1000 0010 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAALE1IS
        when '000 1000 0011 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VMALLE1IS
        when '000 1000 0011 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE1IS
        when '000 1000 0011 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ASIDE1IS
        when '000 1000 0011 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAAE1IS
        when '000 1000 0011 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE1IS
        when '000 1000 0011 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAALE1IS
        when '000 1000 0101 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE1OS
        when '000 1000 0101 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAAE1OS
        when '000 1000 0101 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE1OS
        when '000 1000 0101 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAALE1OS
        when '000 1000 0110 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE1
        when '000 1000 0110 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAAE1
        when '000 1000 0110 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE1
        when '000 1000 0110 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAALE1
        when '000 1000 0111 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VMALLE1
        when '000 1000 0111 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE1
        when '000 1000 0111 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ASIDE1
        when '000 1000 0111 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAAE1
        when '000 1000 0111 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE1
        when '000 1000 0111 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAALE1
        when '000 1001 0001 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VMALLE1OSNXS
        when '000 1001 0001 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE1OSNXS
        when '000 1001 0001 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ASIDE1OSNXS
        when '000 1001 0001 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAAE1OSNXS
        when '000 1001 0001 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE1OSNXS
        when '000 1001 0001 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAALE1OSNXS
        when '000 1001 0010 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE1ISNXS
        when '000 1001 0010 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAAE1ISNXS
        when '000 1001 0010 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE1ISNXS
        when '000 1001 0010 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAALE1ISNXS
        when '000 1001 0011 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VMALLE1ISNXS
        when '000 1001 0011 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE1ISNXS
        when '000 1001 0011 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ASIDE1ISNXS
        when '000 1001 0011 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAAE1ISNXS
        when '000 1001 0011 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE1ISNXS
        when '000 1001 0011 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAALE1ISNXS
        when '000 1001 0101 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE1OSNXS
        when '000 1001 0101 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAAE1OSNXS
        when '000 1001 0101 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE1OSNXS
        when '000 1001 0101 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAALE1OSNXS
        when '000 1001 0110 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE1NXS
        when '000 1001 0110 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAAE1NXS
        when '000 1001 0110 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE1NXS
        when '000 1001 0110 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAALE1NXS
        when '000 1001 0111 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VMALLE1NXS
        when '000 1001 0111 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE1NXS
        when '000 1001 0111 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ASIDE1NXS
        when '000 1001 0111 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAAE1NXS
        when '000 1001 0111 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE1NXS
        when '000 1001 0111 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAALE1NXS
        when '100 1000 0000 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // IPAS2E1IS
        when '100 1000 0000 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RIPAS2E1IS
        when '100 1000 0000 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // IPAS2LE1IS
        when '100 1000 0000 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RIPAS2LE1IS
        when '100 1000 0001 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE2OS
        when '100 1000 0001 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE2OS
        when '100 1000 0001 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE1OS
        when '100 1000 0001 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE2OS
        when '100 1000 0001 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VMALLS12E1OS
        when '100 1000 0010 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE2IS
        when '100 1000 0010 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE2IS
        when '100 1000 0011 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE2IS
        when '100 1000 0011 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE2IS
        when '100 1000 0011 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE1IS
        when '100 1000 0011 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE2IS
        when '100 1000 0011 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VMALLS12E1IS
        when '100 1000 0100 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // IPAS2E1OS
        when '100 1000 0100 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // IPAS2E1
        when '100 1000 0100 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RIPAS2E1
        when '100 1000 0100 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RIPAS2E1OS
        when '100 1000 0100 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // IPAS2LE1OS
        when '100 1000 0100 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // IPAS2LE1
        when '100 1000 0100 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RIPAS2LE1
        when '100 1000 0100 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RIPAS2LE1OS
        when '100 1000 0101 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE2OS
        when '100 1000 0101 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE2OS
        when '100 1000 0110 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE2
        when '100 1000 0110 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE2
        when '100 1000 0111 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE2
        when '100 1000 0111 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE2
        when '100 1000 0111 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE1
        when '100 1000 0111 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE2
        when '100 1000 0111 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VMALLS12E1
        when '100 1001 0000 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // IPAS2E1ISNXS
        when '100 1001 0000 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RIPAS2E1ISNXS
        when '100 1001 0000 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // IPAS2LE1ISNXS
        when '100 1001 0000 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RIPAS2LE1ISNXS
        when '100 1001 0001 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE2OSNXS
        when '100 1001 0001 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE2OSNXS
        when '100 1001 0001 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE1OSNXS
        when '100 1001 0001 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE2OSNXS
        when '100 1001 0001 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VMALLS12E1OSNXS
        when '100 1001 0010 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE2ISNXS
        when '100 1001 0010 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE2ISNXS
        when '100 1001 0011 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE2ISNXS
        when '100 1001 0011 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE2ISNXS
        when '100 1001 0011 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE1ISNXS
        when '100 1001 0011 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE2ISNXS
        when '100 1001 0011 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VMALLS12E1ISNXS
        when '100 1001 0100 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // IPAS2E1OSNXS
        when '100 1001 0100 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // IPAS2E1NXS
        when '100 1001 0100 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RIPAS2E1NXS
        when '100 1001 0100 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RIPAS2E1OSNXS
        when '100 1001 0100 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // IPAS2LE1OSNXS
        when '100 1001 0100 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // IPAS2LE1NXS
        when '100 1001 0100 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RIPAS2LE1NXS
        when '100 1001 0100 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RIPAS2LE1OSNXS
        when '100 1001 0101 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE2OSNXS
        when '100 1001 0101 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE2OSNXS
        when '100 1001 0110 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE2NXS
        when '100 1001 0110 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE2NXS
        when '100 1001 0111 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE2NXS
        when '100 1001 0111 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE2NXS
        when '100 1001 0111 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE1NXS
        when '100 1001 0111 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE2NXS
        when '100 1001 0111 110' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VMALLS12E1NXS
        when '110 1000 0001 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE3OS
        when '110 1000 0001 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE3OS
        when '110 1000 0001 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // PAALLOS
        when '110 1000 0001 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE3OS
        when '110 1000 0010 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE3IS
        when '110 1000 0010 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE3IS
        when '110 1000 0011 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE3IS
        when '110 1000 0011 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE3IS
        when '110 1000 0011 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE3IS
        when '110 1000 0100 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RPAOS
        when '110 1000 0100 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RPALOS
        when '110 1000 0101 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE3OS
        when '110 1000 0101 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE3OS
        when '110 1000 0110 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE3
        when '110 1000 0110 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE3
        when '110 1000 0111 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE3
        when '110 1000 0111 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE3
        when '110 1000 0111 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // PAALL
        when '110 1000 0111 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE3
        when '110 1001 0001 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE3OSNXS
        when '110 1001 0001 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE3OSNXS
        when '110 1001 0001 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE3OSNXS
        when '110 1001 0010 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE3ISNXS
        when '110 1001 0010 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE3ISNXS
        when '110 1001 0011 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE3ISNXS
        when '110 1001 0011 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE3ISNXS
        when '110 1001 0011 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE3ISNXS
        when '110 1001 0101 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE3OSNXS
        when '110 1001 0101 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE3OSNXS
        when '110 1001 0110 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVAE3NXS
        when '110 1001 0110 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // RVALE3NXS
        when '110 1001 0111 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // ALLE3NXS
        when '110 1001 0111 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VAE3NXS
        when '110 1001 0111 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_TLBI" title="">Sys_TLBI</a>;  // VALE3NXS
        when '000 1100 0000 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GSB" title="">Sys_GSB</a>;   // SYS
        when '000 1100 0000 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GSB" title="">Sys_GSB</a>;   // ACK
        when '000 1100 0001 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // CDDIS
        when '000 1100 0001 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // CDEN
        when '000 1100 0001 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // CDPRI
        when '000 1100 0001 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // CDAFF
        when '000 1100 0001 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // CDPEND
        when '000 1100 0001 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // CDRCFG
        when '000 1100 0001 111' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // CDEOI
        when '000 1100 0010 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // CDDI
        when '000 1100 0010 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // CDHM
        when '100 1100 0001 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // VDDIS
        when '100 1100 0001 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // VDEN
        when '100 1100 0001 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // VDPRI
        when '100 1100 0001 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // VDAFF
        when '100 1100 0001 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // VDPEND
        when '100 1100 0001 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // VDRCFG
        when '100 1100 0010 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // VDDI
        when '100 1100 0010 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // VDHM
        when '110 1100 0001 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // LDDIS
        when '110 1100 0001 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // LDEN
        when '110 1100 0001 010' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // LDPRI
        when '110 1100 0001 011' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // LDAFF
        when '110 1100 0001 100' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // LDPEND
        when '110 1100 0001 101' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // LDRCFG
        when '110 1100 0010 000' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // LDDI
        when '110 1100 0010 001' =&gt; return <a href="shared_pseudocode.html#enum_Sys_GIC" title="">Sys_GIC</a>;   // LDHM
        otherwise =&gt;                return <a href="shared_pseudocode.html#enum_Sys_SYS" title="">Sys_SYS</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysop.SystemOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysop/SystemOp</h3>
      <p class="pseudocode">// SystemOp
// ========
// System instruction types.

type <a id="type_SystemOp"/>SystemOp of enumeration {
    <a id="enum_Sys_AT"/>Sys_AT,
    <a id="enum_Sys_BRB"/>Sys_BRB,
    <a id="enum_Sys_DC"/>Sys_DC,
    <a id="enum_Sys_GIC"/>Sys_GIC,
    <a id="enum_Sys_GSB"/>Sys_GSB,
    <a id="enum_Sys_IC"/>Sys_IC,
    <a id="enum_Sys_TLBI"/>Sys_TLBI,
    <a id="enum_Sys_SYS"/>Sys_SYS
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysop_128.SysOp128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysop_128/SysOp128</h3>
      <p class="pseudocode">// SysOp128()
// ==========

func SysOp128(op1 : bits(3), CRn : bits(4), CRm : bits(4), op2 : bits(3)) =&gt; <a href="shared_pseudocode.html#SystemOp128" title="type SystemOp128">SystemOp128</a>
begin
    case op1::CRn::CRm::op2 of
        when '000 1000 0001 001' =&gt; return Sys_TLBIP;  // VAE1OS
        when '000 1000 0001 011' =&gt; return Sys_TLBIP;  // VAAE1OS
        when '000 1000 0001 101' =&gt; return Sys_TLBIP;  // VALE1OS
        when '000 1000 0001 111' =&gt; return Sys_TLBIP;  // VAALE1OS
        when '000 1000 0011 001' =&gt; return Sys_TLBIP;  // VAE1IS
        when '000 1000 0011 011' =&gt; return Sys_TLBIP;  // VAAE1IS
        when '000 1000 0011 101' =&gt; return Sys_TLBIP;  // VALE1IS
        when '000 1000 0011 111' =&gt; return Sys_TLBIP;  // VAALE1IS
        when '000 1000 0111 001' =&gt; return Sys_TLBIP;  // VAE1
        when '000 1000 0111 011' =&gt; return Sys_TLBIP;  // VAAE1
        when '000 1000 0111 101' =&gt; return Sys_TLBIP;  // VALE1
        when '000 1000 0111 111' =&gt; return Sys_TLBIP;  // VAALE1
        when '000 1001 0001 001' =&gt; return Sys_TLBIP;  // VAE1OSNXS
        when '000 1001 0001 011' =&gt; return Sys_TLBIP;  // VAAE1OSNXS
        when '000 1001 0001 101' =&gt; return Sys_TLBIP;  // VALE1OSNXS
        when '000 1001 0001 111' =&gt; return Sys_TLBIP;  // VAALE1OSNXS
        when '000 1001 0011 001' =&gt; return Sys_TLBIP;  // VAE1ISNXS
        when '000 1001 0011 011' =&gt; return Sys_TLBIP;  // VAAE1ISNXS
        when '000 1001 0011 101' =&gt; return Sys_TLBIP;  // VALE1ISNXS
        when '000 1001 0011 111' =&gt; return Sys_TLBIP;  // VAALE1ISNXS
        when '000 1001 0111 001' =&gt; return Sys_TLBIP;  // VAE1NXS
        when '000 1001 0111 011' =&gt; return Sys_TLBIP;  // VAAE1NXS
        when '000 1001 0111 101' =&gt; return Sys_TLBIP;  // VALE1NXS
        when '000 1001 0111 111' =&gt; return Sys_TLBIP;  // VAALE1NXS
        when '100 1000 0001 001' =&gt; return Sys_TLBIP;  // VAE2OS
        when '100 1000 0001 101' =&gt; return Sys_TLBIP;  // VALE2OS
        when '100 1000 0011 001' =&gt; return Sys_TLBIP;  // VAE2IS
        when '100 1000 0011 101' =&gt; return Sys_TLBIP;  // VALE2IS
        when '100 1000 0111 001' =&gt; return Sys_TLBIP;  // VAE2
        when '100 1000 0111 101' =&gt; return Sys_TLBIP;  // VALE2
        when '100 1001 0001 001' =&gt; return Sys_TLBIP;  // VAE2OSNXS
        when '100 1001 0001 101' =&gt; return Sys_TLBIP;  // VALE2OSNXS
        when '100 1001 0011 001' =&gt; return Sys_TLBIP;  // VAE2ISNXS
        when '100 1001 0011 101' =&gt; return Sys_TLBIP;  // VALE2ISNXS
        when '100 1001 0111 001' =&gt; return Sys_TLBIP;  // VAE2NXS
        when '100 1001 0111 101' =&gt; return Sys_TLBIP;  // VALE2NXS
        when '110 1000 0001 001' =&gt; return Sys_TLBIP;  // VAE3OS
        when '110 1000 0001 101' =&gt; return Sys_TLBIP;  // VALE3OS
        when '110 1000 0011 001' =&gt; return Sys_TLBIP;  // VAE3IS
        when '110 1000 0011 101' =&gt; return Sys_TLBIP;  // VALE3IS
        when '110 1000 0111 001' =&gt; return Sys_TLBIP;  // VAE3
        when '110 1000 0111 101' =&gt; return Sys_TLBIP;  // VALE3
        when '110 1001 0001 001' =&gt; return Sys_TLBIP;  // VAE3OSNXS
        when '110 1001 0001 101' =&gt; return Sys_TLBIP;  // VALE3OSNXS
        when '110 1001 0011 001' =&gt; return Sys_TLBIP;  // VAE3ISNXS
        when '110 1001 0011 101' =&gt; return Sys_TLBIP;  // VALE3ISNXS
        when '110 1001 0111 001' =&gt; return Sys_TLBIP;  // VAE3NXS
        when '110 1001 0111 101' =&gt; return Sys_TLBIP;  // VALE3NXS
        when '100 1000 0000 001' =&gt; return Sys_TLBIP;  // IPAS2E1IS
        when '100 1000 0000 101' =&gt; return Sys_TLBIP;  // IPAS2LE1IS
        when '100 1000 0100 000' =&gt; return Sys_TLBIP;  // IPAS2E1OS
        when '100 1000 0100 001' =&gt; return Sys_TLBIP;  // IPAS2E1
        when '100 1000 0100 100' =&gt; return Sys_TLBIP;  // IPAS2LE1OS
        when '100 1000 0100 101' =&gt; return Sys_TLBIP;  // IPAS2LE1
        when '100 1001 0000 001' =&gt; return Sys_TLBIP;  // IPAS2E1ISNXS
        when '100 1001 0000 101' =&gt; return Sys_TLBIP;  // IPAS2LE1ISNXS
        when '100 1001 0100 000' =&gt; return Sys_TLBIP;  // IPAS2E1OSNXS
        when '100 1001 0100 001' =&gt; return Sys_TLBIP;  // IPAS2E1NXS
        when '100 1001 0100 100' =&gt; return Sys_TLBIP;  // IPAS2LE1OSNXS
        when '100 1001 0100 101' =&gt; return Sys_TLBIP;  // IPAS2LE1NXS
        when '000 1000 0010 001' =&gt; return Sys_TLBIP;  // RVAE1IS
        when '000 1000 0010 011' =&gt; return Sys_TLBIP;  // RVAAE1IS
        when '000 1000 0010 101' =&gt; return Sys_TLBIP;  // RVALE1IS
        when '000 1000 0010 111' =&gt; return Sys_TLBIP;  // RVAALE1IS
        when '000 1000 0101 001' =&gt; return Sys_TLBIP;  // RVAE1OS
        when '000 1000 0101 011' =&gt; return Sys_TLBIP;  // RVAAE1OS
        when '000 1000 0101 101' =&gt; return Sys_TLBIP;  // RVALE1OS
        when '000 1000 0101 111' =&gt; return Sys_TLBIP;  // RVAALE1OS
        when '000 1000 0110 001' =&gt; return Sys_TLBIP;  // RVAE1
        when '000 1000 0110 011' =&gt; return Sys_TLBIP;  // RVAAE1
        when '000 1000 0110 101' =&gt; return Sys_TLBIP;  // RVALE1
        when '000 1000 0110 111' =&gt; return Sys_TLBIP;  // RVAALE1
        when '000 1001 0010 001' =&gt; return Sys_TLBIP;  // RVAE1ISNXS
        when '000 1001 0010 011' =&gt; return Sys_TLBIP;  // RVAAE1ISNXS
        when '000 1001 0010 101' =&gt; return Sys_TLBIP;  // RVALE1ISNXS
        when '000 1001 0010 111' =&gt; return Sys_TLBIP;  // RVAALE1ISNXS
        when '000 1001 0101 001' =&gt; return Sys_TLBIP;  // RVAE1OSNXS
        when '000 1001 0101 011' =&gt; return Sys_TLBIP;  // RVAAE1OSNXS
        when '000 1001 0101 101' =&gt; return Sys_TLBIP;  // RVALE1OSNXS
        when '000 1001 0101 111' =&gt; return Sys_TLBIP;  // RVAALE1OSNXS
        when '000 1001 0110 001' =&gt; return Sys_TLBIP;  // RVAE1NXS
        when '000 1001 0110 011' =&gt; return Sys_TLBIP;  // RVAAE1NXS
        when '000 1001 0110 101' =&gt; return Sys_TLBIP;  // RVALE1NXS
        when '000 1001 0110 111' =&gt; return Sys_TLBIP;  // RVAALE1NXS
        when '100 1000 0010 001' =&gt; return Sys_TLBIP;  // RVAE2IS
        when '100 1000 0010 101' =&gt; return Sys_TLBIP;  // RVALE2IS
        when '100 1000 0101 001' =&gt; return Sys_TLBIP;  // RVAE2OS
        when '100 1000 0101 101' =&gt; return Sys_TLBIP;  // RVALE2OS
        when '100 1000 0110 001' =&gt; return Sys_TLBIP;  // RVAE2
        when '100 1000 0110 101' =&gt; return Sys_TLBIP;  // RVALE2
        when '100 1001 0010 001' =&gt; return Sys_TLBIP;  // RVAE2ISNXS
        when '100 1001 0010 101' =&gt; return Sys_TLBIP;  // RVALE2ISNXS
        when '100 1001 0101 001' =&gt; return Sys_TLBIP;  // RVAE2OSNXS
        when '100 1001 0101 101' =&gt; return Sys_TLBIP;  // RVALE2OSNXS
        when '100 1001 0110 001' =&gt; return Sys_TLBIP;  // RVAE2NXS
        when '100 1001 0110 101' =&gt; return Sys_TLBIP;  // RVALE2NXS
        when '110 1000 0010 001' =&gt; return Sys_TLBIP;  // RVAE3IS
        when '110 1000 0010 101' =&gt; return Sys_TLBIP;  // RVALE3IS
        when '110 1000 0101 001' =&gt; return Sys_TLBIP;  // RVAE3OS
        when '110 1000 0101 101' =&gt; return Sys_TLBIP;  // RVALE3OS
        when '110 1000 0110 001' =&gt; return Sys_TLBIP;  // RVAE3
        when '110 1000 0110 101' =&gt; return Sys_TLBIP;  // RVALE3
        when '110 1001 0010 001' =&gt; return Sys_TLBIP;  // RVAE3ISNXS
        when '110 1001 0010 101' =&gt; return Sys_TLBIP;  // RVALE3ISNXS
        when '110 1001 0101 001' =&gt; return Sys_TLBIP;  // RVAE3OSNXS
        when '110 1001 0101 101' =&gt; return Sys_TLBIP;  // RVALE3OSNXS
        when '110 1001 0110 001' =&gt; return Sys_TLBIP;  // RVAE3NXS
        when '110 1001 0110 101' =&gt; return Sys_TLBIP;  // RVALE3NXS
        when '100 1000 0000 010' =&gt; return Sys_TLBIP;  // RIPAS2E1IS
        when '100 1000 0000 110' =&gt; return Sys_TLBIP;  // RIPAS2LE1IS
        when '100 1000 0100 010' =&gt; return Sys_TLBIP;  // RIPAS2E1
        when '100 1000 0100 011' =&gt; return Sys_TLBIP;  // RIPAS2E1OS
        when '100 1000 0100 110' =&gt; return Sys_TLBIP;  // RIPAS2LE1
        when '100 1000 0100 111' =&gt; return Sys_TLBIP;  // RIPAS2LE1OS
        when '100 1001 0000 010' =&gt; return Sys_TLBIP;  // RIPAS2E1ISNXS
        when '100 1001 0000 110' =&gt; return Sys_TLBIP;  // RIPAS2LE1ISNXS
        when '100 1001 0100 010' =&gt; return Sys_TLBIP;  // RIPAS2E1NXS
        when '100 1001 0100 011' =&gt; return Sys_TLBIP;  // RIPAS2E1OSNXS
        when '100 1001 0100 110' =&gt; return Sys_TLBIP;  // RIPAS2LE1NXS
        when '100 1001 0100 111' =&gt; return Sys_TLBIP;  // RIPAS2LE1OSNXS
        otherwise                =&gt; return Sys_SYSP;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysop_128.SystemOp128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysop_128/SystemOp128</h3>
      <p class="pseudocode">// SystemOp128()
// =============
// System instruction types.

type <a id="SystemOp128"/>SystemOp128 of enumeration {Sys_TLBIP, Sys_SYSP};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.ELR_EL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/ELR_EL</h3>
      <p class="pseudocode">// ELR_EL - accessor
// =================

accessor <a id="accessor_ELR_EL_1"/>ELR_EL(el : bits(2)) &lt;=&gt; value : bits(64)
begin
    getter
        var r : bits(64);
        case el of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  r = ELR_EL1();
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  r = ELR_EL2();
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  r = ELR_EL3();
            otherwise =&gt; unreachable;
        end;
        return r;
    end;
    setter
        let r : bits(64) = value;
        case el of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  ELR_EL1() = r;
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  ELR_EL2() = r;
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  ELR_EL3() = r;
            otherwise =&gt; unreachable;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.ELR_ELx"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/ELR_ELx</h3>
      <p class="pseudocode">// ELR_ELx - accessor
// ==================

accessor <a id="accessor_ELR_ELx_0"/>ELR_ELx() &lt;=&gt; value : bits(64)
begin
    getter
        assert PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
        return <a href="shared_pseudocode.html#accessor_ELR_EL_1" title="">ELR_EL</a>(PSTATE.EL);
    end;
    setter
        assert PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
        <a href="shared_pseudocode.html#accessor_ELR_EL_1" title="">ELR_EL</a>(PSTATE.EL) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.ESR_EL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/ESR_EL</h3>
      <p class="pseudocode">// ESR_EL - accessor
// =================

accessor <a id="accessor_ESR_EL_1"/>ESR_EL(regime : bits(2)) &lt;=&gt; value : ESRType
begin
    getter
        var r : bits(64);
        case regime of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  r = ESR_EL1();
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  r = ESR_EL2();
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  r = ESR_EL3();
            otherwise =&gt; unreachable;
        end;
        return r;
    end;
    setter
        let r : bits(64) = value;
        case regime of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  ESR_EL1() = r;
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  ESR_EL2() = r;
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  ESR_EL3() = r;
            otherwise =&gt; unreachable;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.ESR_ELx"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/ESR_ELx</h3>
      <p class="pseudocode">// ESR_ELx - accessor
// ==================

accessor <a id="accessor_ESR_ELx_0"/>ESR_ELx() &lt;=&gt; value : ESRType
begin
    getter
        return <a href="shared_pseudocode.html#accessor_ESR_EL_1" title="">ESR_EL</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    end;

    setter
        <a href="shared_pseudocode.html#accessor_ESR_EL_1" title="">ESR_EL</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>()) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.FAR_EL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/FAR_EL</h3>
      <p class="pseudocode">// FAR_EL - accessor
// =================

accessor <a id="accessor_FAR_EL_1"/>FAR_EL(regime : bits(2)) &lt;=&gt; value : bits(64)
begin
    getter
        var r : bits(64);
        case regime of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  r = FAR_EL1();
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  r = FAR_EL2();
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  r = FAR_EL3();
            otherwise =&gt; unreachable;
        end;
        return r;
    end;
    setter
        let r : bits(64) = value;
        case regime of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  FAR_EL1() = r;
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  FAR_EL2() = r;
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  FAR_EL3() = r;
            otherwise =&gt; unreachable;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.FAR_ELx"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/FAR_ELx</h3>
      <p class="pseudocode">// FAR_ELx - accessor
// ==================

accessor <a id="accessor_FAR_ELx_0"/>FAR_ELx() &lt;=&gt; value : bits(64)
begin
    getter
        return <a href="shared_pseudocode.html#accessor_FAR_EL_1" title="">FAR_EL</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    end;

    setter
        <a href="shared_pseudocode.html#accessor_FAR_EL_1" title="">FAR_EL</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>()) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.PFAR_EL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/PFAR_EL</h3>
      <p class="pseudocode">// PFAR_EL - accessor
// ==================

accessor <a id="accessor_PFAR_EL_1"/>PFAR_EL(regime : bits(2)) &lt;=&gt; value : bits(64)
begin
    getter
        assert (IsFeatureImplemented(FEAT_PFAR) ||
                 (regime == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; IsFeatureImplemented(FEAT_RME)));
        var r : bits(64);
        case regime of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; r = PFAR_EL1();
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; r = PFAR_EL2();
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; r = MFAR_EL3();
            otherwise =&gt; unreachable;
        end;
        return r;
    end;
    setter
        let r : bits(64) = value;
        assert (IsFeatureImplemented(FEAT_PFAR) ||
                   (IsFeatureImplemented(FEAT_RME) &amp;&amp; regime == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>));
        case regime of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; PFAR_EL1() = r;
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; PFAR_EL2() = r;
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; MFAR_EL3() = r;
            otherwise =&gt; unreachable;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.PFAR_ELx"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/PFAR_ELx</h3>
      <p class="pseudocode">// PFAR_ELx - accessor
// ===================

accessor <a id="accessor_PFAR_ELx_0"/>PFAR_ELx() &lt;=&gt; value : bits(64)
begin
    getter
        return <a href="shared_pseudocode.html#accessor_PFAR_EL_1" title="">PFAR_EL</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    end;

    setter
        <a href="shared_pseudocode.html#accessor_PFAR_EL_1" title="">PFAR_EL</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>()) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.SCTLR_EL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/SCTLR_EL</h3>
      <p class="pseudocode">// SCTLR_EL - accessor
// ===================

accessor <a id="accessor_SCTLR_EL_1"/>SCTLR_EL(regime : bits(2)) &lt;=&gt; value : SCTLRType
begin
    getter
        var r : bits(64);
        case regime of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  r = SCTLR_EL1();
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  r = SCTLR_EL2();
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  r = SCTLR_EL3();
            otherwise =&gt; unreachable;
        end;
        return r;
    end;
    setter
        let r : bits(64) = value;
        case regime of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; SCTLR_EL1() = r;
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; SCTLR_EL2() = r;
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; SCTLR_EL3() = r;
            otherwise =&gt; unreachable;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.SCTLR_ELx"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/SCTLR_ELx</h3>
      <p class="pseudocode">// SCTLR_ELx - accessor
// ====================

accessor <a id="accessor_SCTLR_ELx_0"/>SCTLR_ELx() &lt;=&gt; value : SCTLRType
begin
    getter
        return <a href="shared_pseudocode.html#accessor_SCTLR_EL_1" title="">SCTLR_EL</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    end;
    setter
        <a href="shared_pseudocode.html#accessor_SCTLR_EL_1" title="">SCTLR_EL</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>()) = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.VBAR_EL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/VBAR_EL</h3>
      <p class="pseudocode">// VBAR_EL - accessor
// ==================

accessor <a id="accessor_VBAR_EL_1"/>VBAR_EL(regime : bits(2)) &lt;=&gt; value : bits(64)
begin
    getter
        var r : bits(64);
        case regime of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  r = VBAR_EL1();
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  r = VBAR_EL2();
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  r = VBAR_EL3();
            otherwise =&gt; unreachable;
        end;
        return r;
    end;
    setter
        pass;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.VBAR_ELx"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/VBAR_ELx</h3>
      <p class="pseudocode">// VBAR_ELx - accessor
// ===================

accessor <a id="accessor_VBAR_ELx_0"/>VBAR_ELx() &lt;=&gt; value : bits(64)
begin
    getter
        return <a href="shared_pseudocode.html#accessor_VBAR_EL_1" title="">VBAR_EL</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    end;
    setter
        <a href="shared_pseudocode.html#accessor_VBAR_EL_1" title="">VBAR_EL</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>())[63:0] = value;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_CheckDAIFAccess"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_CheckDAIFAccess</h3>
      <p class="pseudocode">// AArch64_CheckDAIFAccess()
// =========================
// Check that an AArch64 MSR/MRS access to the DAIF flags is permitted.

func AArch64_CheckDAIFAccess(field : <a href="shared_pseudocode.html#type_PSTATEField" title="">PSTATEField</a>)
begin
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; field IN {<a href="shared_pseudocode.html#enum_PSTATEField_DAIFSet" title="">PSTATEField_DAIFSet</a>, <a href="shared_pseudocode.html#enum_PSTATEField_DAIFClr" title="">PSTATEField_DAIFClr</a>} then
        if <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() || SCTLR_EL1().UMA == '0' then
            if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then
                AArch64_SystemAccessTrap(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, 0x18);
            else
                AArch64_SystemAccessTrap(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, 0x18);
            end;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_ChooseEIRGNonExcludedTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_ChooseEIRGNonExcludedTag</h3>
      <p class="pseudocode">// AArch64_ChooseEIRGNonExcludedTag()
// ==================================
// Return a tag derived from SEED and and EIRGSTATE, excluding any tags in the
// given mask.

func <a id="func_AArch64_ChooseEIRGNonExcludedTag_1"/>AArch64_ChooseEIRGNonExcludedTag(exclude : bits(16)) =&gt; bits(4)
begin
    assert GCR_EL1().RRND == '0';

    if IsOnes(exclude) then
        return '0000';
    end;

    var bins : array[[16]] of bits(4);

    var N : integer = 0;
    for i = 0 to 15 do
        if exclude[i] == '0' then
            bins[[N]] = i[3:0];
            N = N + 1;
        end;
    end;

    let seed : bits(16) = RGSR_EL1().SEED[15:0];
    var eirgstate : integer = UInt(RGSR_EL1().TAG);

    eirgstate = eirgstate + 1;
    if eirgstate &gt;= N then
        eirgstate = 0;
    end;

    let lbin : integer = (eirgstate + (N * UInt(seed)) &gt;&gt; 16) MOD N;

    RGSR_EL1().TAG = eirgstate[3:0];

    let top : bit = seed[5] XOR seed[3] XOR seed[2] XOR seed[0];
    RGSR_EL1().SEED[15:0] = top::seed[15:1];

    return bins[[lbin]];
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_ChooseNonExcludedTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_ChooseNonExcludedTag</h3>
      <p class="pseudocode">// AArch64_ChooseNonExcludedTag()
// ==============================
// Return a tag derived from the start and the offset values, excluding
// any tags in the given mask.

func <a id="func_AArch64_ChooseNonExcludedTag_3"/>AArch64_ChooseNonExcludedTag(tag_in : bits(4), offset_in : bits(4),
                                  exclude : bits(16)) =&gt; bits(4)
begin
    var tag : bits(4) = tag_in;
    var offset : bits(4) = offset_in;

    if IsOnes(exclude) then
        return '0000';
    end;

    if offset == '0000' then
        while exclude[UInt(tag)] == '1' looplimit 16 do
            tag = tag + '0001';
        end;
    end;

    while offset != '0000' looplimit 16 do
        offset = offset - '0001';
        tag = tag + '0001';
        while exclude[UInt(tag)] == '1' looplimit 16 do
            tag = tag + '0001';
        end;
    end;

    return tag;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_ChooseNonExludedTagOrZero"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_ChooseNonExludedTagOrZero</h3>
      <p class="pseudocode">// AArch64_ChooseNonExludedTagOrZero()
// ===================================
// Return a tag derived from the start and the offset values, excluding any
// tags in the given mask, or zero if Allocation Tag access is not enabled.

func <a id="func_AArch64_ChooseNonExcludedTagOrZero_3"/>AArch64_ChooseNonExcludedTagOrZero(tag : bits(4), offset : bits(4),
                                        exclude : bits(16)) =&gt; bits(4)
begin
    if <a href="shared_pseudocode.html#func_IsMTEEnabled_1" title="">IsMTEEnabled</a>(PSTATE.EL) then
        return <a href="shared_pseudocode.html#func_AArch64_ChooseNonExcludedTag_3" title="">AArch64_ChooseNonExcludedTag</a>(tag, offset, exclude);
    else
        return '0000';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_ChooseTagOrZero"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_ChooseTagOrZero</h3>
      <p class="pseudocode">// AArch64_ChooseTagOrZero()
// =========================
// Return a tag, excluding any tags in the given mask, , or zero if Allocation
// Tag access is not enabled.

func <a id="func_AArch64_ChooseTagOrZero_1"/>AArch64_ChooseTagOrZero(exclude : bits(16)) =&gt; bits(4)
begin
    if <a href="shared_pseudocode.html#func_IsMTEEnabled_1" title="">IsMTEEnabled</a>(PSTATE.EL) then
        if GCR_EL1().RRND == '1' then
            if IsOnes(exclude) then
                return '0000';
            else
                return <a href="shared_pseudocode.html#func_ChooseRandomNonExcludedTag_1" title="">ChooseRandomNonExcludedTag</a>(exclude);
            end;
        else
            if IsFeatureImplemented(FEAT_MTE_EIRG) then
                return <a href="shared_pseudocode.html#func_AArch64_ChooseEIRGNonExcludedTag_1" title="">AArch64_ChooseEIRGNonExcludedTag</a>(exclude);
            end;
            let start_tag : bits(4) = RGSR_EL1().TAG;
            let offset : bits(4)    = <a href="shared_pseudocode.html#func_AArch64_RandomTag_0" title="">AArch64_RandomTag</a>();

            RGSR_EL1().TAG = <a href="shared_pseudocode.html#func_AArch64_ChooseNonExcludedTag_3" title="">AArch64_ChooseNonExcludedTag</a>(start_tag, offset, exclude);

            return RGSR_EL1().TAG;
        end;
    else
        return '0000';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_ExecutingERETInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_ExecutingERETInstr</h3>
      <p class="pseudocode">// AArch64_ExecutingERETInstr()
// ============================
// Returns TRUE if current instruction is ERET.

func <a id="func_AArch64_ExecutingERETInstr_0"/>AArch64_ExecutingERETInstr() =&gt; boolean
begin
    let instr : bits(32) = <a href="shared_pseudocode.html#func_ThisInstr_0" title="">ThisInstr</a>();
    return instr[31:12] == '11010110100111110000';
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_ImpDefSysInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_ImpDefSysInstr</h3>
      <p class="pseudocode">// AArch64_ImpDefSysInstr()
// ========================
// Execute an implementation-defined system instruction with write (source operand).

impdef func AArch64_ImpDefSysInstr(op0 : bits(2), op1 : bits(3), crn : bits(4),
                                   crm : bits(4), op2 : bits(3), t : integer)
begin
    Undefined();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_ImpDefSysInstr128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_ImpDefSysInstr128</h3>
      <p class="pseudocode">// AArch64_ImpDefSysInstr128()
// ===========================
// Execute an implementation-defined system instruction with write (128-bit source operand).

impdef func AArch64_ImpDefSysInstr128(op0 : bits(2), op1 : bits(3), crn : bits(4),
                                      crm : bits(4), op2 : bits(3),
                                      t : integer, t2 : integer)
begin
    Undefined();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_ImpDefSysInstrWithResult"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_ImpDefSysInstrWithResult</h3>
      <p class="pseudocode">// AArch64_ImpDefSysInstrWithResult()
// ==================================
// Execute an implementation-defined system instruction with read (result operand).

impdef func AArch64_ImpDefSysInstrWithResult(op0 : bits(2),
                                             op1 : bits(3),
                                             crn : bits(4),
                                             crm : bits(4),
                                             op2 : bits(3),
                                             t : integer)
begin
    Undefined();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_ImpDefSysRegRead"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_ImpDefSysRegRead</h3>
      <p class="pseudocode">// AArch64_ImpDefSysRegRead()
// ==========================
// Read from an implementation-defined System register and write the contents of the register
// to X[t].

impdef func AArch64_ImpDefSysRegRead(op0 : bits(2), op1 : bits(3),
                                     crn : bits(4), crm : bits(4),
                                     op2 : bits(3), t : integer)
begin
    Undefined();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_ImpDefSysRegRead128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_ImpDefSysRegRead128</h3>
      <p class="pseudocode">// AArch64_ImpDefSysRegRead128()
// =============================
// Read from an 128-bit implementation-defined System register
// and write the contents of the register to X[t], X[t+1].

impdef func AArch64_ImpDefSysRegRead128(op0 : bits(2),
                                        op1 : bits(3), crn : bits(4),
                                        crm : bits(4), op2 : bits(3),
                                        t : integer, t2 : integer)
begin
    Undefined();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_ImpDefSysRegWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_ImpDefSysRegWrite</h3>
      <p class="pseudocode">// AArch64_ImpDefSysRegWrite()
// ===========================
// Write to an implementation-defined System register.

impdef func AArch64_ImpDefSysRegWrite(op0 : bits(2), op1 : bits(3), crn : bits(4),
                                      crm : bits(4), op2 : bits(3), t : integer)
begin
    Undefined();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_ImpDefSysRegWrite128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_ImpDefSysRegWrite128</h3>
      <p class="pseudocode">// AArch64_ImpDefSysRegWrite128()
// ==============================
// Write the contents of X[t], X[t+1] to an 128-bit implementation-defined System register.

impdef func AArch64_ImpDefSysRegWrite128(op0 : bits(2), op1 : bits(3), crn : bits(4),
                                         crm : bits(4), op2 : bits(3),
                                         t : integer, t2 : integer)
begin
    Undefined();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_InterruptPending"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_InterruptPending</h3>
      <p class="pseudocode">// AArch64_InterruptPending()
// ==========================
// Returns TRUE if there are any pending physical, virtual, or delegated
// interrupts, and FALSE otherwise.

func <a id="func_AArch64_InterruptPending_0"/>AArch64_InterruptPending() =&gt; boolean
begin
    let (irq_pending, -) = <a href="shared_pseudocode.html#func_IRQPending_0" title="">IRQPending</a>();
    let (fiq_pending, -) = <a href="shared_pseudocode.html#func_FIQPending_0" title="">FIQPending</a>();
    let pending_physical_interrupt : boolean = (irq_pending || fiq_pending ||
                                                   <a href="shared_pseudocode.html#func_IsPhysicalSErrorPending_0" title="">IsPhysicalSErrorPending</a>());

    var pending_virtual_interrupt : boolean = FALSE;
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; HCR_EL2().TGE == '0' then
        let virq_pending : boolean = (HCR_EL2().IMO == '1' &amp;&amp; (<a href="shared_pseudocode.html#func_VirtualIRQPending_0" title="">VirtualIRQPending</a>() ||
                                         HCR_EL2().VI == '1'));
        let vfiq_pending : boolean = (HCR_EL2().FMO == '1' &amp;&amp; (<a href="shared_pseudocode.html#func_VirtualFIQPending_0" title="">VirtualFIQPending</a>() ||
                                         HCR_EL2().VF == '1'));
        let vsei_pending : boolean = ((HCR_EL2().AMO == '1' ||
                                       (IsFeatureImplemented(FEAT_DoubleFault2) &amp;&amp;
                                         <a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() &amp;&amp; HCRX_EL2().TMEA == '1')) &amp;&amp;
                                       (<a href="shared_pseudocode.html#func_IsVirtualSErrorPending_0" title="">IsVirtualSErrorPending</a>() || HCR_EL2().VSE == '1'));

        pending_virtual_interrupt = vsei_pending || virq_pending || vfiq_pending;
    end;

    let pending_delegated_interrupt : boolean = (IsFeatureImplemented(FEAT_E3DSE) &amp;&amp;
                                                 PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp;
                                                 SCR_EL3().[EnDSE,DSE] == '11');

    return pending_physical_interrupt || pending_virtual_interrupt || pending_delegated_interrupt;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_NextRandomTagBit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_NextRandomTagBit</h3>
      <p class="pseudocode">// AArch64_NextRandomTagBit()
// ==========================
// Generate a random bit suitable for generating a random Allocation Tag.

func <a id="func_AArch64_NextRandomTagBit_0"/>AArch64_NextRandomTagBit() =&gt; bit
begin
    assert GCR_EL1().RRND == '0';
    let lfsr : bits(16) = RGSR_EL1().SEED[15:0];
    let top : bit = lfsr[5] XOR lfsr[3] XOR lfsr[2] XOR lfsr[0];
    RGSR_EL1().SEED[15:0] = top::lfsr[15:1];
    return top;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_RandomTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_RandomTag</h3>
      <p class="pseudocode">// AArch64_RandomTag()
// ===================
// Generate a random Allocation Tag.

func <a id="func_AArch64_RandomTag_0"/>AArch64_RandomTag() =&gt; bits(4)
begin
    var tag : bits(4);
    for i = 0 to 3 do
        tag[i] = <a href="shared_pseudocode.html#func_AArch64_NextRandomTagBit_0" title="">AArch64_NextRandomTagBit</a>();
    end;
    return tag;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_SysInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_SysInstr</h3>
      <p class="pseudocode">// AArch64_SysInstr()
// ==================
// Execute a system instruction with write (source operand).

impdef func AArch64_SysInstr(op0 : bits(2), op1 : bits(3),
                             crn : bits(4), crm : bits(4), op2 : bits(3), t : integer)
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_SysInstrWithResult"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_SysInstrWithResult</h3>
      <p class="pseudocode">// AArch64_SysInstrWithResult()
// ============================
// Execute a system instruction with read (result operand).
// Writes the result of the instruction to X[t].

impdef func AArch64_SysInstrWithResult(op0 : bits(2), op1 : bits(3),
                                       crn : bits(4), crm : bits(4),
                                       op2 : bits(3), t : integer)
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_SysRegRead"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_SysRegRead</h3>
      <p class="pseudocode">// AArch64_SysRegRead()
// ====================
// Read from a System register and write the contents of the register to X[t].

impdef func AArch64_SysRegRead(op0 : bits(2), op1 : bits(3), crn : bits(4),
                               crm : bits(4), op2 : bits(3), t : integer)
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64_SysRegWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64_SysRegWrite</h3>
      <p class="pseudocode">// AArch64_SysRegWrite()
// =====================
// Write to a System register.

impdef func AArch64_SysRegWrite(op0 : bits(2), op1 : bits(3), crn : bits(4),
                                crm : bits(4), op2 : bits(3), t : integer)
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeCompatible"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeCompatible</h3>
      <p class="pseudocode">// BTypeCompatible
// ===============
// Records the branch target compatibility.
// Returns TRUE if the branch target is compatible with PSTATE.BTYPE, else FALSE.

var <a id="global_BTypeCompatible"/>BTypeCompatible : boolean;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeCompatible_BTI"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeCompatible_BTI</h3>
      <p class="pseudocode">// BTypeCompatible_BTI
// ===================
// This function determines whether a given hint encoding is compatible with the current value of
// PSTATE.BTYPE. A value of TRUE here indicates a valid Branch Target Identification instruction.

func <a id="func_BTypeCompatible_BTI_1"/>BTypeCompatible_BTI(hintcode : bits(2)) =&gt; boolean
begin
    case hintcode of
        when '00' =&gt;
            return PSTATE.BTYPE == '00';
        when '01' =&gt;
            return PSTATE.BTYPE != '11';
        when '10' =&gt;
            return PSTATE.BTYPE != '10';
        when '11' =&gt;
            return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeCompatible_PAC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeCompatible_PAC</h3>
      <p class="pseudocode">// BTypeCompatible_PAC()
// =====================
// Returns TRUE if PACIxSP or PACIxSPPC instructions are implicitly compatible with PSTATE.BTYPE,
// FALSE otherwise.

func <a id="func_BTypeCompatible_PAC_1"/>BTypeCompatible_PAC(pacinst : <a href="shared_pseudocode.html#type_PACInstType" title="">PACInstType</a>) =&gt; boolean
begin
    // For only PACIxSP instructions, check if BTI behavior should be disabled
    if IsFeatureImplemented(FEAT_PAuth_EnhCtl) &amp;&amp; pacinst == <a href="shared_pseudocode.html#enum_PACIxSP" title="">PACIxSP</a> then
        var btd : bit;
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt; btd = if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) then SCTLR2_EL2().BTD0 else SCTLR2_EL1().BTD0;
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; btd = SCTLR2_EL1().BTD;
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; btd = SCTLR2_EL2().BTD;
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; btd = SCTLR2_EL3().BTD;
        end;
        // When BTI compatibility is disabled,
        // these instructions are not compatible when PSTATE.BTYPE is non-zero
        if btd == '1' then return IsZero(PSTATE.BTYPE); end;
    end;

    if PSTATE.BTYPE != '11' then
        return TRUE;
    else
        let index : integer = if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then 35 else 36;
        return <a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>()[index] == '0';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeCompatible_PACIXSP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeCompatible_PACIXSP</h3>
      <p class="pseudocode">// BTypeCompatible_PACIXSP()
// =========================
// Returns TRUE if PACIASP or PACIBSP instructions are implicitly compatible with PSTATE.BTYPE,
// FALSE otherwise.

func <a id="func_BTypeCompatible_PACIXSP_0"/>BTypeCompatible_PACIXSP() =&gt; boolean
begin
    let pacinst : <a href="shared_pseudocode.html#type_PACInstType" title="">PACInstType</a> = <a href="shared_pseudocode.html#enum_PACIxSP" title="">PACIxSP</a>;
    return <a href="shared_pseudocode.html#func_BTypeCompatible_PAC_1" title="">BTypeCompatible_PAC</a>(pacinst);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeNext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeNext</h3>
      <p class="pseudocode">// BTypeNext
// =========
// Updated every cycle with a value that depends upon the instruction being executed. Assigned to
// PSTATE.BTYPE at the end of each cycle and then cleared to zero. Allows SPSR save/restore of
// BTYPE for the current instruction being executed.

var <a id="global_BTypeNext"/>BTypeNext : bits(2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.ChooseRandomNonExcludedTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/ChooseRandomNonExcludedTag</h3>
      <p class="pseudocode">// ChooseRandomNonExcludedTag()
// ============================
// The ChooseRandomNonExcludedTag function is used when GCR_EL1.RRND == '1' to generate random
// Allocation Tags.
//
// The resulting Allocation Tag is selected from the set [0,15], excluding any Allocation Tag where
// exclude[tag_value] == 1. If 'exclude' is all Ones, the returned Allocation Tag is '0000'.
//
// This function is permitted to generate a non-deterministic selection from the set of non-excluded
// Allocation Tags. A reasonable implementation should select a tag from a uniform distribution and
// avoid common pitfalls such as modulo bias.
//
// This function can read RGSR_EL1 and/or write RGSR_EL1 to an IMPLEMENTATION DEFINED value.
// If it is not capable of writing RGSR_EL1.SEED[15:0] to zero from a previous nonzero
// RGSR_EL1.SEED value, it is IMPLEMENTATION DEFINED whether the randomness is significantly
// impacted if RGSR_EL1.SEED[15:0] is set to zero.

impdef func <a id="func_ChooseRandomNonExcludedTag_1"/>ChooseRandomNonExcludedTag(exclude_in : bits(16)) =&gt; bits(4)
begin
    return ARBITRARY : bits(4);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.EffectiveBADDR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/EffectiveBADDR</h3>
      <p class="pseudocode">// EffectiveBADDR()
// ================
// Check if the given VA, held in a register BADDR field, is RESS and apply
// CONSTRAINED UNPREDICTABLE behaviour if it is not.

func <a id="func_EffectiveBADDR_2"/>EffectiveBADDR(baddr_in : bits(64), directread : boolean) =&gt; bits(64)
begin
    var baddr : bits(64) = baddr_in;
    // Determine top bit position based on feature support.
    let n : integer{} = (if IsFeatureImplemented(FEAT_LVA3) then 57
                         else (if IsFeatureImplemented(FEAT_LVA) then 53
                         else 49));

    // Check if the upper bits of the base address form a valid sign extension.
    if baddr[63:n] != Replicate{64-n}(baddr[n-1]) then
        let c = ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_BADDR_RESS" title="">Unpredictable_BADDR_RESS</a>);
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_RESS" title="">Constraint_RESS</a>, <a href="shared_pseudocode.html#enum_Constraint_ALLRESS" title="">Constraint_ALLRESS</a>, <a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a>};
        if c == <a href="shared_pseudocode.html#enum_Constraint_ALLRESS" title="">Constraint_ALLRESS</a> || (!directread &amp;&amp; c == <a href="shared_pseudocode.html#enum_Constraint_RESS" title="">Constraint_RESS</a>) then
            baddr[63:n] = Replicate{64-n}(baddr[n-1]);
        end;
        // If c == Constraint_FAULT, baddr will cause an Address Size fault when used.
    end;

    return baddr;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.EffectiveDIT"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/EffectiveDIT</h3>
      <p class="pseudocode">// EffectiveDIT()
// ==============
// Returns the Effective value of PSTATE.DIT.

func <a id="func_EffectiveDIT_0"/>EffectiveDIT() =&gt; bit
begin
    if !IsFeatureImplemented(FEAT_FDIT) then
        return PSTATE.DIT;
    end;

    if (PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp;
          ((!<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) &amp;&amp; <a href="shared_pseudocode.html#func_IsSCTLR2EL1Enabled_0" title="">IsSCTLR2EL1Enabled</a>() &amp;&amp; SCTLR2_EL1().FDIT == '1') ||
           ( <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) &amp;&amp; <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() &amp;&amp; SCTLR2_EL2().FDIT == '1'))) then
        return '1';
    end;

    if (((PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>)) || PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) &amp;&amp;
          <a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() &amp;&amp; HCRX_EL2().FDIT == '1') then
        return '1';
    end;

    if PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; SCR2_EL3().FDIT == '1' then
        return '1';
    end;

    return PSTATE.DIT;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.EffectiveHCRX_EL2_NVTGE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/EffectiveHCRX_EL2_NVTGE</h3>
      <p class="pseudocode">// EffectiveHCRX_EL2_NVTGE()
// =========================
// Returns the Effective value of HCRX_EL2.NVTGE.

func <a id="func_EffectiveHCRX_EL2_NVTGE_0"/>EffectiveHCRX_EL2_NVTGE() =&gt; bit
begin
    if !IsFeatureImplemented(FEAT_NV3) then
        return '0';
    end;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR2_EL3().NV3En == '0' then
        return '0';
    end;

    if <a href="shared_pseudocode.html#func_EffectiveHCR_EL2_NVx_0" title="">EffectiveHCR_EL2_NVx</a>() != '101' then
        return '0';
    end;

    if !<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() then
        return '0';
    end;

    return HCRX_EL2().NVTGE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.EffectiveICC_SRE_EL3_Enable"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/EffectiveICC_SRE_EL3_Enable</h3>
      <p class="pseudocode">// EffectiveICC_SRE_EL3_Enable()
// =============================
// Returns the Effective value of ICC_SRE_EL3.Enable

func <a id="func_EffectiveICC_SRE_EL3_Enable_0"/>EffectiveICC_SRE_EL3_Enable() =&gt; bit
begin
    if IsFeatureImplemented(FEAT_GCIE) &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        return '1';
    end;

    return ICC_SRE_EL3().Enable;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.InGuardedPage"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/InGuardedPage</h3>
      <p class="pseudocode">// InGuardedPage
// =============
// Records whether the currently fetched instruction was retrieved from a guarded page, will be
// TRUE if the GP bit in the page or block descriptor for the current instruction fetch was equal
// to one.

var <a id="global_InGuardedPage"/>InGuardedPage : boolean;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsHCRXEL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsHCRXEL2Enabled</h3>
      <p class="pseudocode">// IsHCRXEL2Enabled()
// ==================
// Returns TRUE if access to HCRX_EL2 register is enabled, and FALSE otherwise.
// Indirect read of HCRX_EL2 returns 0 when access is not enabled.

readonly func <a id="func_IsHCRXEL2Enabled_0"/>IsHCRXEL2Enabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_HCX) then return FALSE; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().HXEn == '0' then
        return FALSE;
    end;

    return <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsMTEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsMTEEnabled</h3>
      <p class="pseudocode">// IsMTEEnabled()
// ==============
// Returns TRUE if the currently selected MTE mechanism is enabled, and FALSE otherwise.

func <a id="func_IsMTEEnabled_1"/>IsMTEEnabled(el : bits(2)) =&gt; boolean
begin
    let regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a> = <a href="shared_pseudocode.html#func_TranslationRegime_1" title="">TranslationRegime</a>(el);
    var selected : boolean = FALSE;

    if <a href="shared_pseudocode.html#func_IsPMTESelected_1" title="">IsPMTESelected</a>(el) then
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().ATA == '0' &amp;&amp; el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} then
            return FALSE;
        end;

        if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) &amp;&amp; HCR_EL2().ATA == '0' &amp;&amp; el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} then
            return FALSE;
        end;

        selected = TRUE;
    end;

    if selected then
        case regime of
            when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> =&gt;
                return SCTLR_EL3().ATA == '1';
            when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;
                return SCTLR_EL2().ATA == '1';
            when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt;
                return if el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then SCTLR_EL2().ATA0 == '1' else SCTLR_EL2().ATA == '1';
            when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;
                return if el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then SCTLR_EL1().ATA0 == '1' else SCTLR_EL1().ATA == '1';
            otherwise =&gt; unreachable;
        end;
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsPMTESelected"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsPMTESelected</h3>
      <p class="pseudocode">// IsPMTESelected()
// ================
// Returns TRUE if Physical MTE is selected for the translation regime
// associated with the EL, and FALSE otherwise

func <a id="func_IsPMTESelected_1"/>IsPMTESelected(el : bits(2)) =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_MTE2) then
        return FALSE;
    end;

    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsSCTLR2EL1Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsSCTLR2EL1Enabled</h3>
      <p class="pseudocode">// IsSCTLR2EL1Enabled()
// ====================
// Returns TRUE if access to SCTLR2_EL1 register is enabled, and FALSE otherwise.
// Indirect read of SCTLR2_EL1 returns 0 when access is not enabled.

func <a id="func_IsSCTLR2EL1Enabled_0"/>IsSCTLR2EL1Enabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_SCTLR2) then return FALSE; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SCTLR2En == '0' then
        return FALSE;
    elsif (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; (!<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().SCTLR2En == '0')) then
        return FALSE;
    else
        return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsSCTLR2EL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsSCTLR2EL2Enabled</h3>
      <p class="pseudocode">// IsSCTLR2EL2Enabled()
// ====================
// Returns TRUE if access to SCTLR2_EL2 register is enabled, and FALSE otherwise.
// Indirect read of SCTLR2_EL2 returns 0 when access is not enabled.

func <a id="func_IsSCTLR2EL2Enabled_0"/>IsSCTLR2EL2Enabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_SCTLR2) then return FALSE; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SCTLR2En == '0' then
        return FALSE;
    end;

    return <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsTCR2EL1Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsTCR2EL1Enabled</h3>
      <p class="pseudocode">// IsTCR2EL1Enabled()
// ==================
// Returns TRUE if access to TCR2_EL1 register is enabled, and FALSE otherwise.
// Indirect read of TCR2_EL1 returns 0 when access is not enabled.

func <a id="func_IsTCR2EL1Enabled_0"/>IsTCR2EL1Enabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_TCR2) then return FALSE; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().TCR2En == '0' then
        return FALSE;
    elsif (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; (!<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().TCR2En == '0')) then
        return FALSE;
    else
        return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsTCR2EL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsTCR2EL2Enabled</h3>
      <p class="pseudocode">// IsTCR2EL2Enabled()
// ==================
// Returns TRUE if access to TCR2_EL2 register is enabled, and FALSE otherwise.
// Indirect read of TCR2_EL2 returns 0 when access is not enabled.

func <a id="func_IsTCR2EL2Enabled_0"/>IsTCR2EL2Enabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_TCR2) then return FALSE; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().TCR2En == '0' then
        return FALSE;
    end;

    return <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.PACInstType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/PACInstType</h3>
      <p class="pseudocode">// PACInstType
// ===========
type <a id="type_PACInstType"/>PACInstType of enumeration {
    <a id="enum_PACIxSP"/>PACIxSP,
    <a id="enum_PACIxSPPC"/>PACIxSPPC,
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.SetBTypeCompatible"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/SetBTypeCompatible</h3>
      <p class="pseudocode">// SetBTypeCompatible()
// ====================
// Sets the value of BTypeCompatible global variable used by BTI

func SetBTypeCompatible(x : boolean)
begin
    <a href="shared_pseudocode.html#global_BTypeCompatible" title="">BTypeCompatible</a> = x;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.SetBTypeNext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/SetBTypeNext</h3>
      <p class="pseudocode">// SetBTypeNext()
// ==============
// Set the value of BTypeNext global variable used by BTI

func SetBTypeNext(x : bits(2))
begin
    <a href="shared_pseudocode.html#global_BTypeNext" title="">BTypeNext</a> = x;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.SetInGuardedPage"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/SetInGuardedPage</h3>
      <p class="pseudocode">// SetInGuardedPage()
// ==================
// Global state updated to denote if memory access is from a guarded page.

func SetInGuardedPage(guardedpage : boolean)
begin
    <a href="shared_pseudocode.html#global_InGuardedPage" title="">InGuardedPage</a> = guardedpage;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system128.AArch64_SysInstr128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system128/AArch64_SysInstr128</h3>
      <p class="pseudocode">// AArch64_SysInstr128()
// =====================
// Execute a system instruction with write (2 64-bit source operands).

impdef func AArch64_SysInstr128(op0 : bits(2), op1 : bits(3), crn : bits(4),
                                crm : bits(4), op2 : bits(3), t : integer, t2 : integer)
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system128.AArch64_SysRegRead128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system128/AArch64_SysRegRead128</h3>
      <p class="pseudocode">// AArch64_SysRegRead128()
// =======================
// Read from a 128-bit System register and write the contents of the register to X[t] and X[t2].

impdef func AArch64_SysRegRead128(op0 : bits(2), op1 : bits(3),
                                  crn : bits(4), crm : bits(4),
                                  op2 : bits(3), t : integer, t2 : integer)
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system128.AArch64_SysRegWrite128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system128/AArch64_SysRegWrite128</h3>
      <p class="pseudocode">// AArch64_SysRegWrite128()
// ========================
// Read the contents of X[t] and X[t2] and write the contents to a 128-bit System register.

impdef func AArch64_SysRegWrite128(op0 : bits(2), op1 : bits(3),
                                   crn : bits(4), crm : bits(4),
                                   op2 : bits(3), t : integer, t2 : integer)
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi</h3>
      <p class="pseudocode">constant <a id="global_DEFAULT_TLBI_DOMAIN"/>DEFAULT_TLBI_DOMAIN : bits(16) = Zeros{};  // Broadcast to all agents in the</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBIP_IPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBIP_IPAS2</h3>
      <p class="pseudocode">// AArch64_TLBIP_IPAS2()
// =====================
// Invalidate by IPA all stage 2 only TLB entries in the indicated broadcast
// domain matching the indicated VMID in the indicated regime with the indicated security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// IPA and related parameters of the are derived from Xt.

func AArch64_TLBIP_IPAS2(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                         broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                         Xt : bits(128))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_IPAS2" title="">TLBIOp_IPAS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = TRUE;
    r.level        = level;
    r.attr         = attr;
    r.ttl          = Xt[47:44];
    r.address      = ZeroExtend{64}(Xt[107:64] :: Zeros{12});
    if IsFeatureImplemented(FEAT_TLBID) &amp;&amp; Xt[32] == '1' then
        r.d64      = TRUE;
        r.d128     = r.ttl == '00xx';
    else
        r.d64      = r.ttl == '00xx';
        r.d128     = TRUE;
    end;

    case security of
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;
            r.ipaspace = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;
            r.ipaspace = if Xt[63] == '1' then <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> else <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;
            r.ipaspace = <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>;
        otherwise =&gt;
            // Root security state does not have stage 2 translation
            unreachable;
    end;

    TLBI(r);
    let domains : bits(16) = <a href="shared_pseudocode.html#func_TLBIDomains_2" title="">TLBIDomains</a>(broadcast, Xt[15:0]);
    if (broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp;
          (<a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) || <a href="shared_pseudocode.html#func_OSHDomainExceedsNIS_1" title="">OSHDomainExceedsNIS</a>(domains))) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;

    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r, domains); end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBIP_RIPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBIP_RIPAS2</h3>
      <p class="pseudocode">// AArch64_TLBIP_RIPAS2()
// ======================
// Range invalidate by IPA all stage 2 only TLB entries in the indicated
// broadcast domain matching the indicated VMID in the indicated regime with the indicated
// security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// The range of IPA and related parameters of the are derived from Xt.

func AArch64_TLBIP_RIPAS2(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                          broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                          Xt : bits(128))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_RIPAS2" title="">TLBIOp_RIPAS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = TRUE;
    r.level        = level;
    r.attr         = attr;
    r.ttl[1:0]     = Xt[38:37];
    if IsFeatureImplemented(FEAT_TLBID) &amp;&amp; Xt[32] == '1' then
        r.d64      = TRUE;
        r.d128     = r.ttl[1:0] == '00';
    else
        r.d64      = r.ttl[1:0] == '00';
        r.d128     = TRUE;
    end;

    var valid : boolean;
    (valid, r.tg, r.address, r.end_address) = TLBIPRange(regime, Xt);

    if !valid then return; end;

    case security of
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;
            r.ipaspace = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;
            r.ipaspace = if Xt[63] == '1' then <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> else <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;
            r.ipaspace = <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>;
        otherwise =&gt;
            // Root security state does not have stage 2 translation
            unreachable;
    end;

    TLBI(r);
    let domains : bits(16) = <a href="shared_pseudocode.html#func_TLBIDomains_2" title="">TLBIDomains</a>(broadcast, Xt[15:0]);
    if (broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp;
          (<a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) || <a href="shared_pseudocode.html#func_OSHDomainExceedsNIS_1" title="">OSHDomainExceedsNIS</a>(domains))) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;

    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r, domains); end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBIP_RVA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBIP_RVA</h3>
      <p class="pseudocode">// AArch64_TLBIP_RVA()
// ===================
// Range invalidate by VA range all stage 1 TLB entries in the indicated
// broadcast domain matching the indicated VMID and ASID (where regime
// supports VMID, ASID) in the indicated regime with the indicated security state.
// ASID, and range related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch64_TLBIP_RVA(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                       broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                       Xt : bits(128))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_RVA" title="">TLBIOp_RVA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = level;
    r.attr         = attr;
    r.asid         = Xt[63:48];
    r.ttl[1:0]     = Xt[38:37];
    if IsFeatureImplemented(FEAT_TLBID) &amp;&amp; Xt[32] == '1' then
        r.d64      = TRUE;
        r.d128     = r.ttl[1:0] == '00';
    else
        r.d64      = r.ttl[1:0] == '00';
        r.d128     = TRUE;
    end;

    var valid : boolean;
    (valid, r.tg, r.address, r.end_address) = TLBIPRange(regime, Xt);

    if !valid then return; end;

    TLBI(r);
    let domains : bits(16) = <a href="shared_pseudocode.html#func_TLBIDomains_2" title="">TLBIDomains</a>(broadcast, Xt[15:0]);
    if (broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp;
          (<a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) || <a href="shared_pseudocode.html#func_OSHDomainExceedsNIS_1" title="">OSHDomainExceedsNIS</a>(domains))) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;

    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r, domains); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBIP_RVAA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBIP_RVAA</h3>
      <p class="pseudocode">// AArch64_TLBIP_RVAA()
// ====================
// Range invalidate by VA range all stage 1 TLB entries in the indicated
// broadcast domain matching the indicated VMID (where regimesupports VMID)
// and all ASID in the indicated regime with the indicated security state.
// VA range related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch64_TLBIP_RVAA(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                        broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                        Xt : bits(128))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_RVAA" title="">TLBIOp_RVAA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = level;
    r.attr         = attr;
    r.ttl[1:0]     = Xt[38:37];
    if IsFeatureImplemented(FEAT_TLBID) &amp;&amp; Xt[32] == '1' then
        r.d64      = TRUE;
        r.d128     = r.ttl[1:0] == '00';
    else
        r.d64      = r.ttl[1:0] == '00';
        r.d128     = TRUE;
    end;

    var valid : boolean;
    (valid, r.tg, r.address, r.end_address) = TLBIPRange(regime, Xt);

    if !valid then return; end;

    TLBI(r);
    let domains : bits(16) = <a href="shared_pseudocode.html#func_TLBIDomains_2" title="">TLBIDomains</a>(broadcast, Xt[15:0]);
    if (broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp;
          (<a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) || <a href="shared_pseudocode.html#func_OSHDomainExceedsNIS_1" title="">OSHDomainExceedsNIS</a>(domains))) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;

    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r, domains); end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBIP_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBIP_VA</h3>
      <p class="pseudocode">// AArch64_TLBIP_VA()
// ==================
// Invalidate by VA all stage 1 TLB entries in the indicated broadcast domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch64_TLBIP_VA(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                      broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                      Xt : bits(128))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_VA" title="">TLBIOp_VA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = level;
    r.attr         = attr;
    r.asid         = Xt[63:48];
    r.ttl          = Xt[47:44];
    r.address      = ZeroExtend{64}(Xt[107:64] :: Zeros{12});
    if IsFeatureImplemented(FEAT_TLBID) &amp;&amp; Xt[32] == '1' then
        r.d64      = TRUE;
        r.d128     = r.ttl == '00xx';
    else
        r.d64      = r.ttl == '00xx';
        r.d128     = TRUE;
    end;

    TLBI(r);
    let domains : bits(16) = <a href="shared_pseudocode.html#func_TLBIDomains_2" title="">TLBIDomains</a>(broadcast, Xt[15:0]);
    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;

    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r, domains); end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBIP_VAA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBIP_VAA</h3>
      <p class="pseudocode">// AArch64_TLBIP_VAA()
// ===================
// Invalidate by VA all stage 1 TLB entries in the indicated broadcast domain
// matching the indicated VMID (where regime supports VMID) and all ASID in the indicated regime
// with the indicated security state.
// VA and related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch64_TLBIP_VAA(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                       broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                       Xt : bits(128))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_VAA" title="">TLBIOp_VAA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = level;
    r.attr         = attr;
    r.ttl          = Xt[47:44];
    r.address      = ZeroExtend{64}(Xt[107:64] :: Zeros{12});
    if IsFeatureImplemented(FEAT_TLBID) &amp;&amp; Xt[32] == '1' then
        r.d64      = TRUE;
        r.d128     = r.ttl == '00xx';
    else
        r.d64      = r.ttl == '00xx';
        r.d128     = TRUE;
    end;

    TLBI(r);
    let domains : bits(16) = <a href="shared_pseudocode.html#func_TLBIDomains_2" title="">TLBIDomains</a>(broadcast, Xt[15:0]);
    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;

    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r, domains); end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_ALL</h3>
      <p class="pseudocode">// AArch64_TLBI_ALL()
// ==================
// Invalidate all entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated broadcast domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.

func AArch64_TLBI_ALL(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                      broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>, Xt : bits(64))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_ALL" title="">TLBIOp_ALL</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.attr         = attr;

    TLBI(r);
    let domains : bits(16) = <a href="shared_pseudocode.html#func_TLBIDomains_2" title="">TLBIDomains</a>(broadcast, Xt[15:0]);
    if (broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp;
          (<a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) || <a href="shared_pseudocode.html#func_OSHDomainExceedsNIS_1" title="">OSHDomainExceedsNIS</a>(domains))) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;

    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r, domains); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_ASID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_ASID</h3>
      <p class="pseudocode">// AArch64_TLBI_ASID()
// ===================
// Invalidate all stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Xt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated broadcast domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch64_TLBI_ASID(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                       broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                       Xt :  bits(64))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_ASID" title="">TLBIOp_ASID</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = Xt[63:48];

    TLBI(r);
    let domains : bits(16) = <a href="shared_pseudocode.html#func_TLBIDomains_2" title="">TLBIDomains</a>(broadcast, Xt[15:0]);
    if (broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp;
          (<a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) || <a href="shared_pseudocode.html#func_OSHDomainExceedsNIS_1" title="">OSHDomainExceedsNIS</a>(domains))) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;

    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r, domains); end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_IPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_IPAS2</h3>
      <p class="pseudocode">// AArch64_TLBI_IPAS2()
// ====================
// Invalidate by IPA all stage 2 only TLB entries in the indicated broadcast
// domain matching the indicated VMID in the indicated regime with the indicated security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// IPA and related parameters of the are derived from Xt.

func AArch64_TLBI_IPAS2(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                        broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                        Xt : bits(64))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_IPAS2" title="">TLBIOp_IPAS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = TRUE;
    r.level        = level;
    r.attr         = attr;
    r.ttl          = Xt[47:44];
    r.address      = ZeroExtend{64}(Xt[39:0] :: Zeros{12});
    r.d64          = TRUE;
    r.d128         = r.ttl == '00xx';

    case security of
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;
            r.ipaspace = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;
            r.ipaspace = if Xt[63] == '1' then <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> else <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;
            r.ipaspace = <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>;
        otherwise =&gt;
            // Root security state does not have stage 2 translation
            unreachable;
    end;

    TLBI(r);
    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_PAALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_PAALL</h3>
      <p class="pseudocode">// AArch64_TLBI_PAALL()
// ====================
// TLB Invalidate ALL GPT Information.
// Invalidates cached copies of GPT entries from TLBs in the indicated
// Shareabilty domain.
// The invalidation applies to all TLB entries containing GPT information.

func AArch64_TLBI_PAALL(broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>)
begin
    assert IsFeatureImplemented(FEAT_RME) &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;

    // r.security and r.regime do not apply for TLBI by PA operations
    r.op    = <a href="shared_pseudocode.html#enum_TLBIOp_PAALL" title="">TLBIOp_PAALL</a>;
    r.level = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.attr  = <a href="shared_pseudocode.html#enum_TLBI_AllAttr" title="">TLBI_AllAttr</a>;

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_RIPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_RIPAS2</h3>
      <p class="pseudocode">// AArch64_TLBI_RIPAS2()
// =====================
// Range invalidate by IPA all stage 2 only TLB entries in the indicated
// broadcast domain matching the indicated VMID in the indicated regime with the indicated
// security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// The range of IPA and related parameters of the are derived from Xt.

func AArch64_TLBI_RIPAS2(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                         broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                         Xt : bits(64))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_RIPAS2" title="">TLBIOp_RIPAS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = TRUE;
    r.level        = level;
    r.attr         = attr;
    r.ttl[1:0]     = Xt[38:37];
    r.d64          = TRUE;
    r.d128         = r.ttl[1:0] == '00';

    var valid : boolean;
    (valid, r.tg, r.address, r.end_address) = <a href="shared_pseudocode.html#func_TLBIRange_2" title="">TLBIRange</a>(regime, Xt);

    if !valid then return; end;

    case security of
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;
            r.ipaspace = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;
            r.ipaspace = if Xt[63] == '1' then <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> else <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;
            r.ipaspace = <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>;
        otherwise =&gt;
            // Root security state does not have stage 2 translation
            unreachable;
    end;

    TLBI(r);
    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_RPA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_RPA</h3>
      <p class="pseudocode">// AArch64_TLBI_RPA()
// ==================
// TLB Range Invalidate GPT Information by PA.
// Invalidates cached copies of GPT entries from TLBs in the indicated
// Shareabilty domain.
// The invalidation applies to TLB entries containing GPT information relating
// to the indicated physical address range.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries containing GPT information
//                      from all levels of the GPT walk
//     TLBILevel_Last : this applies to TLB entries containing GPT information
//                      from the last level of the GPT walk

func AArch64_TLBI_RPA(level : TLBILevel, Xt : bits(64), broadcast : Broadcast)
begin
    assert IsFeatureImplemented(FEAT_RME) &amp;&amp; PSTATE.EL == EL3;

    var r : TLBIRecord;
    var range_bits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    var p : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;

    // r.security and r.regime do not apply for TLBI by PA operations
    r.op    = TLBIOp_RPA;
    r.level = level;
    r.attr  = TLBI_AllAttr;

    // SIZE field
    case Xt[47:44] of
        when '0000' =&gt; range_bits = 12; // 4KB
        when '0001' =&gt; range_bits = 14; // 16KB
        when '0010' =&gt; range_bits = 16; // 64KB
        when '0011' =&gt; range_bits = 21; // 2MB
        when '0100' =&gt; range_bits = 25; // 32MB
        when '0101' =&gt; range_bits = 29; // 512MB
        when '0110' =&gt; range_bits = 30; // 1GB
        when '0111' =&gt; range_bits = 34; // 16GB
        when '1000' =&gt; range_bits = 36; // 64GB
        when '1001' =&gt; range_bits = 39; // 512GB
        otherwise =&gt;   return;  // Reserved encoding, no TLB entries are required to be invalidated
    end;

    // If SIZE selects a range smaller than PGS, then PGS is used instead
    case DecodePGS(GPCCR_EL3().PGS) of
        when PGS_4KB =&gt;  p = 12;
        when PGS_16KB =&gt; p = 14;
        when PGS_64KB =&gt; p = 16;
        otherwise =&gt; return;    // Reserved encoding, no TLB entries are required to be invalidated
    end;

    if range_bits &lt; p then
        range_bits = p;
    end;

    var BaseADDR : bits(52) = Zeros{};
    case GPCCR_EL3().PGS of
        when '00' =&gt; BaseADDR[51:12] = Xt[39:0];   // 4KB
        when '10' =&gt; BaseADDR[51:14] = Xt[39:2];   // 16KB
        when '01' =&gt; BaseADDR[51:16] = Xt[39:4];   // 64KB
    end;

    // The calculation here automatically aligns BaseADDR to the size of
    // the region specififed in SIZE. However, the architecture does not
    // require this alignment and if BaseADDR is not aligned to the region
    // specified by SIZE then no entries are required to be invalidated.
    let range_pbits : integer{} = range_bits;
    let start_addr : bits(52) = BaseADDR AND NOT ZeroExtend{52}(Ones{range_pbits});
    let end_addr : bits(52)   = start_addr + ZeroExtend{52}(Ones{range_pbits});

    // PASpace is not considered in TLBI by PA operations
    r.address     = ZeroExtend{64}(start_addr);
    r.end_address = ZeroExtend{64}(end_addr);

    TLBI(r);
    if broadcast != Broadcast_NSH then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_RVA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_RVA</h3>
      <p class="pseudocode">// AArch64_TLBI_RVA()
// ==================
// Range invalidate by VA range all stage 1 TLB entries in the indicated
// broadcast domain matching the indicated VMID and ASID (where regime
// supports VMID, ASID) in the indicated regime with the indicated security state.
// ASID, and range related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch64_TLBI_RVA(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                      broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                      Xt : bits(64))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_RVA" title="">TLBIOp_RVA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = level;
    r.attr         = attr;
    r.asid         = Xt[63:48];
    r.ttl[1:0]     = Xt[38:37];
    r.d64          = TRUE;
    r.d128         = r.ttl[1:0] == '00';

    var valid : boolean;
    (valid, r.tg, r.address, r.end_address) = <a href="shared_pseudocode.html#func_TLBIRange_2" title="">TLBIRange</a>(regime, Xt);

    if !valid then return; end;

    TLBI(r);
    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_RVAA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_RVAA</h3>
      <p class="pseudocode">// AArch64_TLBI_RVAA()
// ===================
// Range invalidate by VA range all stage 1 TLB entries in the indicated
// broadcast domain matching the indicated VMID (where regimesupports VMID)
// and all ASID in the indicated regime with the indicated security state.
// VA range related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch64_TLBI_RVAA(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                       broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>, Xt : bits(64))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_RVAA" title="">TLBIOp_RVAA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = level;
    r.attr         = attr;
    r.ttl[1:0]     = Xt[38:37];
    r.d64          = TRUE;
    r.d128         = r.ttl[1:0] == '00';

    var valid : boolean;
    (valid, r.tg, r.address, r.end_address) = <a href="shared_pseudocode.html#func_TLBIRange_2" title="">TLBIRange</a>(regime, Xt);

    if !valid then return; end;

    TLBI(r);
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_VA</h3>
      <p class="pseudocode">// AArch64_TLBI_VA()
// =================
// Invalidate by VA all stage 1 TLB entries in the indicated broadcast domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch64_TLBI_VA(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                     broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                     Xt : bits(64))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_VA" title="">TLBIOp_VA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = level;
    r.attr         = attr;
    r.asid         = Xt[63:48];
    r.ttl          = Xt[47:44];
    r.address      = ZeroExtend{64}(Xt[43:0] :: Zeros{12});
    r.d64          = TRUE;
    r.d128         = r.ttl == '00xx';

    TLBI(r);
    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_VAA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_VAA</h3>
      <p class="pseudocode">// AArch64_TLBI_VAA()
// ==================
// Invalidate by VA all stage 1 TLB entries in the indicated broadcast domain
// matching the indicated VMID (where regime supports VMID) and all ASID in the indicated regime
// with the indicated security state.
// VA and related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.

func AArch64_TLBI_VAA(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                      broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                      Xt : bits(64))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_VAA" title="">TLBIOp_VAA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.level        = level;
    r.attr         = attr;
    r.ttl          = Xt[47:44];
    r.address      = ZeroExtend{64}(Xt[43:0] :: Zeros{12});
    r.d64          = TRUE;
    r.d128         = r.ttl == '00xx';

    TLBI(r);
    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;
    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r); end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_VMALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_VMALL</h3>
      <p class="pseudocode">// AArch64_TLBI_VMALL()
// ====================
// Invalidate all stage 1 entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated broadcast
// domain that match the indicated VMID (where applicable).
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// Note: stage 2 only entries are not in the scope of this operation.

func AArch64_TLBI_VMALL(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                        vmid : bits(16), broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>,
                        attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>, Xt : bits(64))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_VMALL" title="">TLBIOp_VMALL</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    r.attr         = attr;

    TLBI(r);
    let domains : bits(16) = <a href="shared_pseudocode.html#func_TLBIDomains_2" title="">TLBIDomains</a>(broadcast, Xt[15:0]);
    if (broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp;
          (<a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) || <a href="shared_pseudocode.html#func_OSHDomainExceedsNIS_1" title="">OSHDomainExceedsNIS</a>(domains))) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;

    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r, domains); end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_VMALLS12"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_VMALLS12</h3>
      <p class="pseudocode">// AArch64_TLBI_VMALLS12()
// =======================
// Invalidate all stage 1 and stage 2 entries for the indicated translation
// regime with the indicated security state for all TLBs within the indicated
// broadcast domain that match the indicated VMID.

func AArch64_TLBI_VMALLS12(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                           vmid : bits(16), broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>,
                           attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>, Xt : bits(64))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>};
    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_VMALLS12" title="">TLBIOp_VMALLS12</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.use_vmid     = TRUE;
    r.attr         = attr;

    TLBI(r);
    let domains : bits(16) = <a href="shared_pseudocode.html#func_TLBIDomains_2" title="">TLBIDomains</a>(broadcast, Xt[15:0]);
    if (broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp;
          (<a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) || <a href="shared_pseudocode.html#func_OSHDomainExceedsNIS_1" title="">OSHDomainExceedsNIS</a>(domains))) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;

    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r, domains); end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.AArch64_TLBI_VMALLWS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/AArch64_TLBI_VMALLWS2</h3>
      <p class="pseudocode">// AArch64_TLBI_VMALLWS2()
// =======================
// Remove stage 2 dirty state from entries for the indicated translation regime
// with the indicated security state for all TLBs within the indicated broadcast
// domain that match the indicated VMID.

func AArch64_TLBI_VMALLWS2(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, vmid : bits(16),
                           broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
                           Xt : bits(64))
begin
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>};
    assert regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>;

    if security == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().EEL2 == '0' then
        return;
    end;

    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;

    var r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>;
    r.op           = <a href="shared_pseudocode.html#enum_TLBIOp_VMALLWS2" title="">TLBIOp_VMALLWS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.use_vmid     = TRUE;
    r.attr         = attr;

    TLBI(r);
    let domains : bits(16) = <a href="shared_pseudocode.html#func_TLBIDomains_2" title="">TLBIDomains</a>(broadcast, Xt[15:0]);
    if (broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp;
          (<a href="shared_pseudocode.html#func_IsBroadcast_OSHnISH_1" title="">IsBroadcast_OSHnISH</a>(regime) || <a href="shared_pseudocode.html#func_OSHDomainExceedsNIS_1" title="">OSHDomainExceedsNIS</a>(domains))) then
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;
    end;

    if broadcast != <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a> then BroadcastTLBI(broadcast, r, domains); end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.DecodeTLBITG"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/DecodeTLBITG</h3>
      <p class="pseudocode">// DecodeTLBITG()
// ==============
// Decode translation granule size in TLBI range instructions

func <a id="func_DecodeTLBITG_1"/>DecodeTLBITG(tg : bits(2)) =&gt; <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>
begin
    case tg of
        when '01' =&gt;   return <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
        when '10' =&gt;   return <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>;
        when '11' =&gt;   return <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.GPTTLBIMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/GPTTLBIMatch</h3>
      <p class="pseudocode">// GPTTLBIMatch()
// ==============
// Determine whether the GPT TLB entry lies within the scope of invalidation

func <a id="func_GPTTLBIMatch_2"/>GPTTLBIMatch(tlbi : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>, gpt_entry : GPTEntry) =&gt; boolean
begin
    assert tlbi.op IN {<a href="shared_pseudocode.html#enum_TLBIOp_RPA" title="">TLBIOp_RPA</a>, <a href="shared_pseudocode.html#enum_TLBIOp_PAALL" title="">TLBIOp_PAALL</a>};

    var match : boolean;
    let entry_size_mask : bits(64)     = ZeroExtend{}(Ones{gpt_entry.size});
    let entry_end_address : bits(64)   = (ZeroExtend{64}(gpt_entry.pa[55:0] OR
                                             entry_size_mask[55:0]));
    let entry_start_address : bits(64) = (ZeroExtend{64}(gpt_entry.pa[55:0] AND NOT
                                             entry_size_mask[55:0]));

    case tlbi.op of
        when <a href="shared_pseudocode.html#enum_TLBIOp_RPA" title="">TLBIOp_RPA</a> =&gt;
            match = (UInt(tlbi.address[55:0]) &lt;= UInt(entry_end_address[55:0]) &amp;&amp;
                     UInt(tlbi.end_address[55:0]) &gt; UInt(entry_start_address[55:0]) &amp;&amp;
                     (tlbi.level == <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a> || gpt_entry.level == 1));
        when <a href="shared_pseudocode.html#enum_TLBIOp_PAALL" title="">TLBIOp_PAALL</a> =&gt;
            match = TRUE;
    end;

    return match;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.HasLargeAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/HasLargeAddress</h3>
      <p class="pseudocode">// HasLargeAddress()
// =================
// Returns TRUE if the regime is configured for 52 bit addresses, FALSE otherwise.

func <a id="func_HasLargeAddress_1"/>HasLargeAddress(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>) =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_LPA2) then
        return FALSE;
    end;
    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> =&gt;
            return TCR_EL3().DS == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;
            return TCR_EL2().DS == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt;
            return TCR_EL2().DS == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;
            return TCR_EL1().DS == '1';
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.IsBroadcast_OSHnISH"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/IsBroadcast_OSHnISH</h3>
      <p class="pseudocode">// IsBroadcast_OSHnISH()
// =====================
// Returns TRUE if a TLBI *OS* instruction affects TLBs in the Outer shareability domain,
// but not in the Inner shareability domain.

func <a id="func_IsBroadcast_OSHnISH_1"/>IsBroadcast_OSHnISH(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>) =&gt; boolean
begin
    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a>  =&gt; return FALSE;
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt; return <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() &amp;&amp; SCTLR2_EL2().TLBOSNIS == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; return <a href="shared_pseudocode.html#func_IsSCTLR2EL1Enabled_0" title="">IsSCTLR2EL1Enabled</a>() &amp;&amp; SCTLR2_EL1().TLBOSNIS == '1';
        otherwise        =&gt; unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.OSHDomainExceedsNIS"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/OSHDomainExceedsNIS</h3>
      <p class="pseudocode">// OSHDomainExceedsNIS()
// =====================
// Returns TRUE if a TLBI *OS* instruction affects TLBs in the Outer shareability domain,
// but not in the Inner shareability domain.

func <a id="func_OSHDomainExceedsNIS_1"/>OSHDomainExceedsNIS(domains : bits(16)) =&gt; boolean
begin
    // If the TLBID value exceeds the supported value in TLBIDIDR_EL1.NIS, then no TLBs in the
    // Inner Shareable shareability domain are guaranteed to be affected by the TLBI operation.
    let nis : integer{} = UInt(TLBIDIDR_EL1().NIS);
    return nis &lt; 16 &amp;&amp; !IsZero(domains[15:nis]);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.ResTLBIRTTL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/ResTLBIRTTL</h3>
      <p class="pseudocode">// ResTLBIRTTL()
// =============
// Determine whether the TTL field in TLBI instructions that do apply
// to a range of addresses contains a reserved value

func <a id="func_ResTLBIRTTL_2"/>ResTLBIRTTL(tg : bits(2), ttl : bits(2)) =&gt; boolean
begin
    case ttl of
        when '00' =&gt; return TRUE;
        when '01' =&gt; return <a href="shared_pseudocode.html#func_DecodeTLBITG_1" title="">DecodeTLBITG</a>(tg) == <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a> &amp;&amp; !IsFeatureImplemented(FEAT_LPA2);
        otherwise =&gt; return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.ResTLBITTL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/ResTLBITTL</h3>
      <p class="pseudocode">// ResTLBITTL()
// ============
// Determine whether the TTL field in TLBI instructions that do not apply
// to a range of addresses contains a reserved value

func <a id="func_ResTLBITTL_1"/>ResTLBITTL(ttl : bits(4)) =&gt; boolean
begin
    case ttl of
        when '00xx' =&gt; return TRUE;
        when '0100' =&gt; return !IsFeatureImplemented(FEAT_LPA2);
        when '1000' =&gt; return TRUE;
        when '1001' =&gt; return !IsFeatureImplemented(FEAT_LPA2);
        when '1100' =&gt; return TRUE;
        otherwise =&gt;   return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.TGBits"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/TGBits</h3>
      <p class="pseudocode">// TGBits()
// ========
// Return the number of least-significant address bits within a single Translation Granule.

func TGBits(tg : bits(2)) =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    case tg of
        when '01' =&gt; return 12; // 4KB
        when '10' =&gt; return 14; // 16KB
        when '11' =&gt; return 16; // 64KB
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.TLBIDomains"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/TLBIDomains</h3>
      <p class="pseudocode">// TLBIDomains()
// =============
// Determine the domains the TLBI operation is broadcast to

func <a id="func_TLBIDomains_2"/>TLBIDomains(broadcast_in : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, tlbid_in : bits(16)) =&gt; bits(16)
begin
    assert broadcast_in != <a href="shared_pseudocode.html#enum_Broadcast_OSHnISH" title="">Broadcast_OSHnISH</a>;

    var broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a> = broadcast_in;
    var tlbid : bits(16)      = tlbid_in;

    if !IsFeatureImplemented(FEAT_TLBID) then return <a href="shared_pseudocode.html#global_DEFAULT_TLBI_DOMAIN" title="">DEFAULT_TLBI_DOMAIN</a>; end;
    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_NSH" title="">Broadcast_NSH</a>        then return <a href="shared_pseudocode.html#global_DEFAULT_TLBI_DOMAIN" title="">DEFAULT_TLBI_DOMAIN</a>; end;
    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_ISH_CnP" title="">Broadcast_ISH_CnP</a>    then return <a href="shared_pseudocode.html#global_DEFAULT_TLBI_DOMAIN" title="">DEFAULT_TLBI_DOMAIN</a>; end;
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>                  then return <a href="shared_pseudocode.html#global_DEFAULT_TLBI_DOMAIN" title="">DEFAULT_TLBI_DOMAIN</a>; end;

    let nos : integer{} = UInt(TLBIDIDR_EL1().NOS);
    assert nos &lt;= 16;
    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp; nos == 0 then
        return <a href="shared_pseudocode.html#global_DEFAULT_TLBI_DOMAIN" title="">DEFAULT_TLBI_DOMAIN</a>;
    end;

    let nis : integer{} = UInt(TLBIDIDR_EL1().NIS);
    assert nis &lt;= 16;
    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_ISH" title="">Broadcast_ISH</a> &amp;&amp; nis == 0 then
        return <a href="shared_pseudocode.html#global_DEFAULT_TLBI_DOMAIN" title="">DEFAULT_TLBI_DOMAIN</a>;
    end;

    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> then
            return ZeroExtend{16}(tlbid[nos-1:0]);
        else    // Broadcast_ISH
            return ZeroExtend{16}(tlbid[nis-1:0]);
        end;
    end;

    assert PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;

    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_ForcedISH" title="">Broadcast_ForcedISH</a> then
        // For a TLBI instruction without an IS or OS qualifier executed at EL1, if HCR_EL2.FB
        // is 1 then the process for a TLBI IS instruction is followed as though TLBID is zero.
        broadcast = <a href="shared_pseudocode.html#enum_Broadcast_ISH" title="">Broadcast_ISH</a>;
        tlbid     = Zeros{16};
    end;

    assert broadcast IN {<a href="shared_pseudocode.html#enum_Broadcast_ISH" title="">Broadcast_ISH</a>, <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a>};

    // If the Effective value of VTLBID(OS)En is 0 the TLBID field is not transformed.
    if ((<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().VTLBIDEn == '0') || !<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() ||
          (broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> &amp;&amp; HCRX_EL2().VTLBIDOSEn == '0') ||
          (broadcast == <a href="shared_pseudocode.html#enum_Broadcast_ISH" title="">Broadcast_ISH</a> &amp;&amp; HCRX_EL2().VTLBIDEn == '0')) then
        if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> then
            return ZeroExtend{16}(tlbid[nos-1:0]);
        else    // Broadcast_ISH
            return ZeroExtend{16}(tlbid[nis-1:0]);
        end;
    end;

    if broadcast == <a href="shared_pseudocode.html#enum_Broadcast_OSH" title="">Broadcast_OSH</a> then
        let nvos : integer{} = UInt(TLBIDIDR_EL1().NVOS);
        assert (nos &lt;= 8 &amp;&amp; nvos &lt;= 5) || (nos &lt;= 16 &amp;&amp; nvos &lt;= 4);

        // If NVOS is 0, the TLBID field is ignored as only VTLBIDOS_EL2(n).TD0 is implemented.
        let d : integer{} = if nvos == 0 then 0 else UInt(tlbid[nvos-1:0]);
        let s : integer{} = if nos &lt;= 8 then 8 else 4;
        let n : integer = d DIVRM s;
        let m : integer = d MOD s;

        var vtlbid : bits(16);
        if nos &lt;= 8 then
            vtlbid = ZeroExtend{16}(VTLBIDOS_EL2(n)[8*m+:8]);
        else
            vtlbid = VTLBIDOS_EL2(n)[16*m+:16];
        end;

        return ZeroExtend{16}(vtlbid[nos-1:0]);
    else    // Broadcast_ISH
        let nvis : integer{} = UInt(TLBIDIDR_EL1().NVIS);
        assert (nis &lt;= 8 &amp;&amp; nvis &lt;= 5) || (nis &lt;= 16 &amp;&amp; nvis &lt;= 4);

        // If NVIS is 0, the TLBID field is ignored as only VTLBID_EL2(n).TD0 is implemented.
        let d : integer{} = if nvis == 0 then 0 else UInt(tlbid[nvis-1:0]);
        let s : integer{} = if nis &lt;= 8 then 8 else 4;
        let n : integer = d DIVRM s;
        let m : integer = d MOD s;

        var vtlbid : bits(16);
        if nis &lt;= 8 then
            vtlbid = ZeroExtend{16}(VTLBID_EL2(n)[8*m+:8]);
        else
            vtlbid = VTLBID_EL2(n)[16*m+:16];
        end;

        return ZeroExtend{16}(vtlbid[nis-1:0]);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.TLBIMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/TLBIMatch</h3>
      <p class="pseudocode">// TLBIMatch()
// ===========
// Determine whether the TLB entry lies within the scope of invalidation

func <a id="func_TLBIMatch_2"/>TLBIMatch(tlbi : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>, tlb_entry : TLBRecord) =&gt; boolean
begin
    var match : boolean;
    let entry_block_mask : bits(64)    = ZeroExtend{}(Ones{tlb_entry.blocksize});
    var entry_end_address : bits(64)   = tlb_entry.context.ia OR entry_block_mask;
    var entry_start_address : bits(64) = tlb_entry.context.ia AND NOT entry_block_mask;
    case tlbi.op of
        when <a href="shared_pseudocode.html#enum_TLBIOp_DALL" title="">TLBIOp_DALL</a>, <a href="shared_pseudocode.html#enum_TLBIOp_IALL" title="">TLBIOp_IALL</a> =&gt;
            match = (tlbi.security == tlb_entry.context.ss &amp;&amp;
                     tlbi.regime   == tlb_entry.context.regime);
        when <a href="shared_pseudocode.html#enum_TLBIOp_DASID" title="">TLBIOp_DASID</a>, <a href="shared_pseudocode.html#enum_TLBIOp_IASID" title="">TLBIOp_IASID</a> =&gt;
            match = (tlb_entry.context.includes_s1 &amp;&amp;
                     tlbi.security == tlb_entry.context.ss &amp;&amp;
                     tlbi.regime   == tlb_entry.context.regime &amp;&amp;
                     tlbi.use_vmid == tlb_entry.context.use_vmid &amp;&amp;
                     (!tlb_entry.context.use_vmid || tlbi.vmid == tlb_entry.context.vmid) &amp;&amp;
                     (<a href="shared_pseudocode.html#func_UseASID_1" title="">UseASID</a>(tlb_entry.context) &amp;&amp; tlb_entry.context.nG == '1' &amp;&amp;
                        tlbi.asid  == tlb_entry.context.asid));
        when <a href="shared_pseudocode.html#enum_TLBIOp_DVA" title="">TLBIOp_DVA</a>, <a href="shared_pseudocode.html#enum_TLBIOp_IVA" title="">TLBIOp_IVA</a> =&gt;
            var regime_match : boolean;
            var context_match : boolean;
            var address_match : boolean;
            var level_match : boolean;
            regime_match = (tlb_entry.context.includes_s1 &amp;&amp;
                            tlbi.security == tlb_entry.context.ss &amp;&amp;
                            tlbi.regime   == tlb_entry.context.regime);
            context_match = (tlbi.use_vmid == tlb_entry.context.use_vmid &amp;&amp;
                             (!tlb_entry.context.use_vmid || tlbi.vmid == tlb_entry.context.vmid) &amp;&amp;
                             (!<a href="shared_pseudocode.html#func_UseASID_1" title="">UseASID</a>(tlb_entry.context) || tlbi.asid == tlb_entry.context.asid ||
                                tlb_entry.context.nG == '0'));
            let addr_lsb : integer{} = tlb_entry.blocksize;
            address_match = tlbi.address[55:addr_lsb] == tlb_entry.context.ia[55:addr_lsb];
            level_match = (tlbi.level == <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a> || !tlb_entry.walkstate.istable);
            match = regime_match &amp;&amp; context_match  &amp;&amp; address_match  &amp;&amp; level_match;
        when <a href="shared_pseudocode.html#enum_TLBIOp_ALL" title="">TLBIOp_ALL</a> =&gt;
            let relax_regime : boolean = (tlbi.from_aarch64 &amp;&amp;
                            tlbi.regime IN {<a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>, <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>} &amp;&amp;
                            tlb_entry.context.regime IN {<a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>, <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>});
            match = (tlbi.security == tlb_entry.context.ss &amp;&amp;
                     (tlbi.regime  == tlb_entry.context.regime || relax_regime));
        when <a href="shared_pseudocode.html#enum_TLBIOp_ASID" title="">TLBIOp_ASID</a> =&gt;
            match = (tlb_entry.context.includes_s1 &amp;&amp;
                     tlbi.security == tlb_entry.context.ss &amp;&amp;
                     tlbi.regime   == tlb_entry.context.regime &amp;&amp;
                     tlbi.use_vmid == tlb_entry.context.use_vmid &amp;&amp;
                     (!tlb_entry.context.use_vmid || tlbi.vmid == tlb_entry.context.vmid) &amp;&amp;
                     (<a href="shared_pseudocode.html#func_UseASID_1" title="">UseASID</a>(tlb_entry.context) &amp;&amp; tlb_entry.context.nG == '1' &amp;&amp;
                        tlbi.asid  == tlb_entry.context.asid));
        when <a href="shared_pseudocode.html#enum_TLBIOp_IPAS2" title="">TLBIOp_IPAS2</a>, <a href="shared_pseudocode.html#enum_TLBIPOp_IPAS2" title="">TLBIPOp_IPAS2</a> =&gt;
            let addr_lsb : integer{} = tlb_entry.blocksize;
            match = (!tlb_entry.context.includes_s1 &amp;&amp; tlb_entry.context.includes_s2 &amp;&amp;
                     tlbi.security == tlb_entry.context.ss &amp;&amp;
                     tlbi.regime   == tlb_entry.context.regime &amp;&amp;
                     (!tlb_entry.context.use_vmid || tlbi.vmid == tlb_entry.context.vmid) &amp;&amp;
                     tlbi.ipaspace == tlb_entry.context.ipaspace &amp;&amp;
                     tlbi.address[55:addr_lsb] == tlb_entry.context.ia[55:addr_lsb] &amp;&amp;
                     (!tlbi.from_aarch64 || <a href="shared_pseudocode.html#func_ResTLBITTL_1" title="">ResTLBITTL</a>(tlbi.ttl) || (
                         <a href="shared_pseudocode.html#func_DecodeTLBITG_1" title="">DecodeTLBITG</a>(tlbi.ttl[3:2]) == tlb_entry.context.tg &amp;&amp;
                         UInt(tlbi.ttl[1:0]) == tlb_entry.walkstate.level)
                     ) &amp;&amp;
                     ((tlbi.d128  &amp;&amp; tlb_entry.context.isd128) ||
                      (tlbi.d64  &amp;&amp; !tlb_entry.context.isd128) ||
                      (tlbi.d64 &amp;&amp; tlbi.d128)) &amp;&amp;
                     (tlbi.level == <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a> || !tlb_entry.walkstate.istable));
        when <a href="shared_pseudocode.html#enum_TLBIOp_VAA" title="">TLBIOp_VAA</a>, <a href="shared_pseudocode.html#enum_TLBIPOp_VAA" title="">TLBIPOp_VAA</a> =&gt;
            let addr_lsb : integer{} = tlb_entry.blocksize;
            match = (tlb_entry.context.includes_s1 &amp;&amp;
                     tlbi.security == tlb_entry.context.ss &amp;&amp;
                     tlbi.regime   == tlb_entry.context.regime &amp;&amp;
                     tlbi.use_vmid == tlb_entry.context.use_vmid &amp;&amp;
                     (!tlb_entry.context.use_vmid || tlbi.vmid == tlb_entry.context.vmid) &amp;&amp;
                     tlbi.address[55:addr_lsb] == tlb_entry.context.ia[55:addr_lsb] &amp;&amp;
                     (!tlbi.from_aarch64 || <a href="shared_pseudocode.html#func_ResTLBITTL_1" title="">ResTLBITTL</a>(tlbi.ttl) || (
                         <a href="shared_pseudocode.html#func_DecodeTLBITG_1" title="">DecodeTLBITG</a>(tlbi.ttl[3:2]) == tlb_entry.context.tg &amp;&amp;
                         UInt(tlbi.ttl[1:0]) == tlb_entry.walkstate.level)
                     ) &amp;&amp;
                     ((tlbi.d128  &amp;&amp; tlb_entry.context.isd128) ||
                      (tlbi.d64  &amp;&amp; !tlb_entry.context.isd128) ||
                      (tlbi.d64 &amp;&amp; tlbi.d128)) &amp;&amp;
                     (tlbi.level == <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a> || !tlb_entry.walkstate.istable));
        when <a href="shared_pseudocode.html#enum_TLBIOp_VA" title="">TLBIOp_VA</a>, <a href="shared_pseudocode.html#enum_TLBIPOp_VA" title="">TLBIPOp_VA</a> =&gt;
            let addr_lsb : integer{} = tlb_entry.blocksize;
            match = (tlb_entry.context.includes_s1 &amp;&amp;
                     tlbi.security == tlb_entry.context.ss &amp;&amp;
                     tlbi.regime   == tlb_entry.context.regime &amp;&amp;
                     tlbi.use_vmid == tlb_entry.context.use_vmid &amp;&amp;
                     (!tlb_entry.context.use_vmid || tlbi.vmid == tlb_entry.context.vmid) &amp;&amp;
                     (!<a href="shared_pseudocode.html#func_UseASID_1" title="">UseASID</a>(tlb_entry.context) || tlbi.asid == tlb_entry.context.asid ||
                        tlb_entry.context.nG == '0') &amp;&amp;
                     tlbi.address[55:addr_lsb] == tlb_entry.context.ia[55:addr_lsb] &amp;&amp;
                     (!tlbi.from_aarch64 || <a href="shared_pseudocode.html#func_ResTLBITTL_1" title="">ResTLBITTL</a>(tlbi.ttl) || (
                         <a href="shared_pseudocode.html#func_DecodeTLBITG_1" title="">DecodeTLBITG</a>(tlbi.ttl[3:2]) == tlb_entry.context.tg &amp;&amp;
                         UInt(tlbi.ttl[1:0]) == tlb_entry.walkstate.level)
                     ) &amp;&amp;
                     ((tlbi.d128  &amp;&amp; tlb_entry.context.isd128) ||
                      (tlbi.d64  &amp;&amp; !tlb_entry.context.isd128) ||
                      (tlbi.d64 &amp;&amp; tlbi.d128)) &amp;&amp;
                     (tlbi.level == <a href="shared_pseudocode.html#enum_TLBILevel_Any" title="">TLBILevel_Any</a> || !tlb_entry.walkstate.istable));
        when <a href="shared_pseudocode.html#enum_TLBIOp_VMALL" title="">TLBIOp_VMALL</a> =&gt;
            match = (tlb_entry.context.includes_s1 &amp;&amp;
                     tlbi.security == tlb_entry.context.ss &amp;&amp;
                     tlbi.regime   == tlb_entry.context.regime &amp;&amp;
                     tlbi.use_vmid == tlb_entry.context.use_vmid &amp;&amp;
                     (!tlb_entry.context.use_vmid || tlbi.vmid == tlb_entry.context.vmid));
        when <a href="shared_pseudocode.html#enum_TLBIOp_VMALLS12" title="">TLBIOp_VMALLS12</a> =&gt;
            match = (tlbi.security == tlb_entry.context.ss &amp;&amp;
                     tlbi.regime   == tlb_entry.context.regime &amp;&amp;
                     (!tlb_entry.context.use_vmid || tlbi.vmid == tlb_entry.context.vmid));
        when <a href="shared_pseudocode.html#enum_TLBIOp_RIPAS2" title="">TLBIOp_RIPAS2</a>, <a href="shared_pseudocode.html#enum_TLBIPOp_RIPAS2" title="">TLBIPOp_RIPAS2</a> =&gt;
            match = (!tlb_entry.context.includes_s1 &amp;&amp; tlb_entry.context.includes_s2 &amp;&amp;
                     tlbi.security == tlb_entry.context.ss &amp;&amp;
                     tlbi.regime   == tlb_entry.context.regime &amp;&amp;
                     (!tlb_entry.context.use_vmid || tlbi.vmid == tlb_entry.context.vmid) &amp;&amp;
                     tlbi.ipaspace == tlb_entry.context.ipaspace &amp;&amp;
                     (tlbi.tg != '00' &amp;&amp; <a href="shared_pseudocode.html#func_DecodeTLBITG_1" title="">DecodeTLBITG</a>(tlbi.tg) == tlb_entry.context.tg) &amp;&amp;
                     (!tlbi.from_aarch64 || <a href="shared_pseudocode.html#func_ResTLBIRTTL_2" title="">ResTLBIRTTL</a>(tlbi.tg, tlbi.ttl[1:0]) ||
                        UInt(tlbi.ttl[1:0]) == tlb_entry.walkstate.level) &amp;&amp;
                     ((tlbi.d128  &amp;&amp; tlb_entry.context.isd128) ||
                      (tlbi.d64  &amp;&amp; !tlb_entry.context.isd128) ||
                      (tlbi.d64 &amp;&amp; tlbi.d128)) &amp;&amp;
                     UInt(tlbi.address[55:0]) &lt;= UInt(entry_end_address[55:0]) &amp;&amp;
                     UInt(tlbi.end_address[55:0]) &gt; UInt(entry_start_address[55:0]));
        when <a href="shared_pseudocode.html#enum_TLBIOp_RVAA" title="">TLBIOp_RVAA</a>, <a href="shared_pseudocode.html#enum_TLBIPOp_RVAA" title="">TLBIPOp_RVAA</a> =&gt;
            match = (tlb_entry.context.includes_s1 &amp;&amp;
                     tlbi.security == tlb_entry.context.ss &amp;&amp;
                     tlbi.regime   == tlb_entry.context.regime &amp;&amp;
                     tlbi.use_vmid == tlb_entry.context.use_vmid &amp;&amp;
                     (!tlb_entry.context.use_vmid || tlbi.vmid == tlb_entry.context.vmid) &amp;&amp;
                     (tlbi.tg != '00' &amp;&amp; <a href="shared_pseudocode.html#func_DecodeTLBITG_1" title="">DecodeTLBITG</a>(tlbi.tg) == tlb_entry.context.tg) &amp;&amp;
                     (!tlbi.from_aarch64 || <a href="shared_pseudocode.html#func_ResTLBIRTTL_2" title="">ResTLBIRTTL</a>(tlbi.tg, tlbi.ttl[1:0]) ||
                        UInt(tlbi.ttl[1:0]) == tlb_entry.walkstate.level) &amp;&amp;
                     ((tlbi.d128  &amp;&amp; tlb_entry.context.isd128) ||
                      (tlbi.d64  &amp;&amp; !tlb_entry.context.isd128) ||
                      (tlbi.d64 &amp;&amp; tlbi.d128)) &amp;&amp;
                     UInt(tlbi.address[55:0]) &lt;= UInt(entry_end_address[55:0]) &amp;&amp;
                     UInt(tlbi.end_address[55:0]) &gt; UInt(entry_start_address[55:0]));
        when <a href="shared_pseudocode.html#enum_TLBIOp_RVA" title="">TLBIOp_RVA</a>, <a href="shared_pseudocode.html#enum_TLBIPOp_RVA" title="">TLBIPOp_RVA</a> =&gt;
            match = (tlb_entry.context.includes_s1 &amp;&amp;
                     tlbi.security == tlb_entry.context.ss &amp;&amp;
                     tlbi.regime   == tlb_entry.context.regime &amp;&amp;
                     tlbi.use_vmid == tlb_entry.context.use_vmid &amp;&amp;
                     (!tlb_entry.context.use_vmid || tlbi.vmid == tlb_entry.context.vmid) &amp;&amp;
                     (!<a href="shared_pseudocode.html#func_UseASID_1" title="">UseASID</a>(tlb_entry.context) || tlbi.asid == tlb_entry.context.asid ||
                        tlb_entry.context.nG == '0') &amp;&amp;
                     (tlbi.tg != '00' &amp;&amp; <a href="shared_pseudocode.html#func_DecodeTLBITG_1" title="">DecodeTLBITG</a>(tlbi.tg) == tlb_entry.context.tg) &amp;&amp;
                     (!tlbi.from_aarch64 || <a href="shared_pseudocode.html#func_ResTLBIRTTL_2" title="">ResTLBIRTTL</a>(tlbi.tg, tlbi.ttl[1:0]) ||
                        UInt(tlbi.ttl[1:0]) == tlb_entry.walkstate.level) &amp;&amp;
                     ((tlbi.d128  &amp;&amp; tlb_entry.context.isd128) ||
                      (tlbi.d64  &amp;&amp; !tlb_entry.context.isd128) ||
                      (tlbi.d64 &amp;&amp; tlbi.d128)) &amp;&amp;
                     UInt(tlbi.address[55:0]) &lt;= UInt(entry_end_address[55:0]) &amp;&amp;
                     UInt(tlbi.end_address[55:0]) &gt; UInt(entry_start_address[55:0]));
        when <a href="shared_pseudocode.html#enum_TLBIOp_RPA" title="">TLBIOp_RPA</a> =&gt;
            entry_end_address[55:0] = (tlb_entry.walkstate.baseaddress.address[55:0] OR
                                               entry_block_mask[55:0]);
            entry_start_address[55:0] = (tlb_entry.walkstate.baseaddress.address[55:0] AND
                                                 NOT entry_block_mask[55:0]);
            match = (tlb_entry.context.includes_gpt &amp;&amp;
                     UInt(tlbi.address[55:0]) &lt;= UInt(entry_end_address[55:0]) &amp;&amp;
                     UInt(tlbi.end_address[55:0]) &gt; UInt(entry_start_address[55:0]));
        when <a href="shared_pseudocode.html#enum_TLBIOp_PAALL" title="">TLBIOp_PAALL</a> =&gt;
            match = tlb_entry.context.includes_gpt;
    end;

    if tlbi.attr == <a href="shared_pseudocode.html#enum_TLBI_ExcludeXS" title="">TLBI_ExcludeXS</a> &amp;&amp; tlb_entry.context.xs == '1' then
        match = FALSE;
    end;

    return match;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.TLBIPRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/TLBIPRange</h3>
      <p class="pseudocode">// TLBIPRange()
// ============
// Extract the input address range information from encoded Xt.

func TLBIPRange(regime : Regime, Xt : bits(128)) =&gt; (boolean, bits(2), bits(64), bits(64))
begin
    let valid : boolean = TRUE;
    var start_address : bits(64) = Zeros{};
    var end_address : bits(64)   = Zeros{};

    let tg : bits(2)    = Xt[47:46];
    let scale : integer = UInt(Xt[45:44]);
    let num : integer   = UInt(Xt[43:39]);

    if tg == '00' then
        return (FALSE, tg, start_address, end_address);
    end;

    let tg_bits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = TGBits(tg);
    // The more-significant bits of the start_address is not updated,
    // as they are not used when performing address matching in TLB
    start_address[55:tg_bits] = Xt[107:64+(tg_bits-12)];

    let range : integer = (num+1) &lt;&lt; (5*scale + 1 + tg_bits);
    end_address   = start_address + range[63:0];

    if end_address[55] != start_address[55] then
        // overflow, saturate it
        end_address = Replicate{9}(start_address[55]) :: Ones{55};
    end;

    return (valid, tg, start_address, end_address);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tlbi.TLBIRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tlbi/TLBIRange</h3>
      <p class="pseudocode">// TLBIRange()
// ===========
// Extract the input address range information from encoded Xt.

func <a id="func_TLBIRange_2"/>TLBIRange(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, Xt : bits(64)) =&gt; (boolean, bits(2), bits(64), bits(64))
begin
    let valid : boolean = TRUE;
    var start_address : bits(64) = Zeros{};
    var end_address : bits(64)   = Zeros{};

    let tg : bits(2)    = Xt[47:46];
    let scale : integer = UInt(Xt[45:44]);
    let num : integer   = UInt(Xt[43:39]);
    var tg_bits : integer;

    if tg == '00' then
        return (FALSE, tg, start_address, end_address);
    end;

    case tg of
        when '01' =&gt; // 4KB
            tg_bits = 12;
            if <a href="shared_pseudocode.html#func_HasLargeAddress_1" title="">HasLargeAddress</a>(regime) then
                start_address[52:16] = Xt[36:0];
                start_address[63:53] = Replicate{11}(Xt[36]);
            else
                start_address[48:12] = Xt[36:0];
                start_address[63:49] = Replicate{15}(Xt[36]);
            end;
        when '10' =&gt; // 16KB
            tg_bits = 14;
            if <a href="shared_pseudocode.html#func_HasLargeAddress_1" title="">HasLargeAddress</a>(regime) then
                start_address[52:16] = Xt[36:0];
                start_address[63:53] = Replicate{11}(Xt[36]);
            else
                start_address[50:14] = Xt[36:0];
                start_address[63:51] = Replicate{13}(Xt[36]);
            end;
        when '11' =&gt; // 64KB
            tg_bits = 16;
            start_address[52:16] = Xt[36:0];
            start_address[63:53] = Replicate{11}(Xt[36]);
        otherwise =&gt;
            unreachable;
    end;

    let range : integer = (num+1) &lt;&lt; (5*scale + 1 + tg_bits);
    end_address   = start_address + range[63:0];

    if IsFeatureImplemented(FEAT_LVA3) &amp;&amp; end_address[56] != start_address[56] then
        // overflow, saturate it
        end_address = Replicate{8}(start_address[56]) :: Ones{56};
    elsif end_address[52] != start_address[52] then
        // overflow, saturate it
        end_address = Replicate{12}(start_address[52]) :: Ones{52};
    end;

    return (valid, tg, start_address, end_address);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.vbitop.VBitOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/vbitop/VBitOp</h3>
      <p class="pseudocode">// VBitOp
// ======
// Vector bit select instruction types.

type <a id="VBitOp_2"/>VBitOp of enumeration {VBitOp_VBIF, VBitOp_VBIT, VBitOp_VBSL, VBitOp_VEOR};</p>
    </div>
    <div class="ps"><a id="aarch64.gic.gcie.AArch64_GIC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/gic/gcie/AArch64_GIC</h3>
      <p class="pseudocode">// AArch64_GIC()
// =============
// Perform GIC operation as per GIC instructions.

impdef func AArch64_GIC(Xt : bits(64), instrdomain : <a href="shared_pseudocode.html#GICInstrDomain" title="type GICInstrDomain">GICInstrDomain</a>, instruction : GICInstr)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.gic.gcie.AArch64_GICR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/gic/gcie/AArch64_GICR</h3>
      <p class="pseudocode">// AArch64_GICR()
// ==============
// Perform GICR operation as per GICR instructions.

impdef func AArch64_GICR(instrdomain : <a href="shared_pseudocode.html#GICInstrDomain" title="type GICInstrDomain">GICInstrDomain</a>, instruction : GICInstr) =&gt; bits(64)
begin
    return Zeros{64};
end;</p>
    </div>
    <div class="ps"><a id="aarch64.gic.gcie.AArch64_GSB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/gic/gcie/AArch64_GSB</h3>
      <p class="pseudocode">// AArch64_GSB()
// =============
// Perform GSB operation as per GSB instructions.

impdef func AArch64_GSB(instruction : <a href="shared_pseudocode.html#type_GICInstr" title="">GICInstr</a>)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.gic.gcie.GICDomain"/><h3 class="pseudocode">
            Library pseudocode for aarch64/gic/gcie/GICDomain</h3>
      <p class="pseudocode">// GICDomain
// =========

type <a id="GICDomain"/>GICDomain of enumeration {GICDomain_S, GICDomain_NS, GICDomain_RL, GICDomain_EL3, GICDomain_V};</p>
    </div>
    <div class="ps"><a id="aarch64.gic.gcie.GICInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/gic/gcie/GICInstr</h3>
      <p class="pseudocode">// GICInstr
// ========

type <a id="type_GICInstr"/>GICInstr of enumeration {<a id="enum_GICInstr_AFF"/>GICInstr_AFF, <a id="enum_GICInstr_DI"/>GICInstr_DI, <a id="enum_GICInstr_DIS"/>GICInstr_DIS,<a id="enum_GICInstr_EN"/>GICInstr_EN, <a id="enum_GICInstr_EOI"/>GICInstr_EOI,
                              <a id="enum_GICInstr_PEND"/>GICInstr_PEND, <a id="enum_GICInstr_PRI"/>GICInstr_PRI, <a id="enum_GICInstr_HM"/>GICInstr_HM, <a id="enum_GICInstr_RCFG"/>GICInstr_RCFG,
                              <a id="enum_GICInstr_IA"/>GICInstr_IA, <a id="enum_GICInstr_NMIA"/>GICInstr_NMIA, <a id="enum_GICInstr_ACK"/>GICInstr_ACK, <a id="enum_GICInstr_SYS"/>GICInstr_SYS};</p>
    </div>
    <div class="ps"><a id="aarch64.gic.gcie.GICInstrDomain"/><h3 class="pseudocode">
            Library pseudocode for aarch64/gic/gcie/GICInstrDomain</h3>
      <p class="pseudocode">////////////////////////////////////////////////////////////////
// GCIE Instruction functions
////////////////////////////////////////////////////////////////

// GICInstrDomain
// ==============

type <a id="GICInstrDomain"/>GICInstrDomain of enumeration {GICInstrDomain_CD, GICInstrDomain_LD, GICInstrDomain_VD};</p>
    </div>
    <div class="ps"><a id="aarch64.gic.gcie.HaveDomain"/><h3 class="pseudocode">
            Library pseudocode for aarch64/gic/gcie/HaveDomain</h3>
      <p class="pseudocode">// HaveDomain()
// ============
// This function returns if the PE implements the domain passed as an argument.

impdef func HaveDomain(dom : <a href="shared_pseudocode.html#GICDomain" title="type GICDomain">GICDomain</a>) =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.gic.gcie.HavePreemptiveDomain"/><h3 class="pseudocode">
            Library pseudocode for aarch64/gic/gcie/HavePreemptiveDomain</h3>
      <p class="pseudocode">// HavePreemptiveDomain()
// ======================

impdef func <a id="func_HavePreemptiveDomain_0"/>HavePreemptiveDomain() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.gic.gcie.IsPPIAssignedToCurrentDomain"/><h3 class="pseudocode">
            Library pseudocode for aarch64/gic/gcie/IsPPIAssignedToCurrentDomain</h3>
      <p class="pseudocode">// IsPPIAssignedToCurrentDomain()
// ==============================

impdef func <a id="func_IsPPIAssignedToCurrentDomain_1"/>IsPPIAssignedToCurrentDomain(n : integer) =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.gic.gcie.IsPPIImplemented"/><h3 class="pseudocode">
            Library pseudocode for aarch64/gic/gcie/IsPPIImplemented</h3>
      <p class="pseudocode">// IsPPIImplemented()
// ==================

impdef func <a id="func_IsPPIImplemented_1"/>IsPPIImplemented(n : integer) =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.attrs.AArch64_MAIRAttr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/attrs/AArch64_MAIRAttr</h3>
      <p class="pseudocode">// AArch64_MAIRAttr()
// ==================
// Retrieve the memory attribute encoding indexed in the given MAIR

func <a id="func_AArch64_MAIRAttr_3"/>AArch64_MAIRAttr(index : integer, mair2 : MAIRType, mair : MAIRType) =&gt; bits(8)
begin
    assert (index &lt; 8 || (IsFeatureImplemented(FEAT_AIE) &amp;&amp; (index &lt; 16)));
    if (index &gt; 7) then
        return mair2[(index-8)*:8]; // Read from LSB at MAIR2
    else
        return mair[index*:8];
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.debug.AArch64_CheckBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/debug/AArch64_CheckBreakpoint</h3>
      <p class="pseudocode">// AArch64_CheckBreakpoint()
// =========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch64
// translation regime, when either debug exceptions are enabled, or halting debug is enabled
// and halting is allowed.

func <a id="func_AArch64_CheckBreakpoint_4"/>AArch64_CheckBreakpoint(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, vaddress : bits(64),
                             accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, size : integer) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    assert !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    assert (<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; size IN {2,4}) || size == 4;

    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    var match : boolean     = FALSE;
    var addr_match_bp : boolean     = FALSE; // Default assumption that all address match
                                             // breakpoints are inactive or disabled.
    var addr_mismatch_bp : boolean  = FALSE; // Default assumption that all address mismatch
                                             // breakpoints are inactive or disabled.
    var addr_match : boolean        = FALSE;
    var addr_mismatch : boolean     = TRUE;  // Default assumption that the given virtual address
                                             // is outside the range of all address mismatch
                                             // breakpoints.
    var ctxt_match : boolean        = FALSE;

    for i = 0 to <a href="shared_pseudocode.html#func_NumBreakpointsImplemented_0" title="">NumBreakpointsImplemented</a>() - 1 do
        let brkptinfo : <a href="shared_pseudocode.html#type_BreakpointInfo" title="">BreakpointInfo</a> = <a href="shared_pseudocode.html#func_AArch64_BreakpointMatch_4" title="">AArch64_BreakpointMatch</a>(i, vaddress, accdesc, size);
        if brkptinfo.bptype == <a href="shared_pseudocode.html#enum_BreakpointType_AddrMatch" title="">BreakpointType_AddrMatch</a> then
            addr_match_bp = TRUE;
            addr_match = addr_match || brkptinfo.match;
        elsif brkptinfo.bptype == <a href="shared_pseudocode.html#enum_BreakpointType_AddrMismatch" title="">BreakpointType_AddrMismatch</a> then
            addr_mismatch_bp = TRUE;
            addr_mismatch = addr_mismatch &amp;&amp; !brkptinfo.match;
        elsif brkptinfo.bptype == <a href="shared_pseudocode.html#enum_BreakpointType_CtxtMatch" title="">BreakpointType_CtxtMatch</a> then
            ctxt_match = ctxt_match || brkptinfo.match;
        end;
    end;
    if addr_match_bp &amp;&amp; addr_mismatch_bp then
        match = addr_match &amp;&amp; addr_mismatch;
    else
        match = (addr_match_bp &amp;&amp; addr_match) || (addr_mismatch_bp &amp;&amp; addr_mismatch);
    end;

    match = match || ctxt_match;

    if match then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Debug" title="">Fault_Debug</a>;
        fault.vaddress   = vaddress;
        if <a href="shared_pseudocode.html#func_HaltOnBreakpointOrWatchpoint_0" title="">HaltOnBreakpointOrWatchpoint</a>() then
            let reason : bits(6) = <a href="shared_pseudocode.html#global_DebugHalt_Breakpoint" title="">DebugHalt_Breakpoint</a>;
            Halt(reason);
        end;
    end;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.debug.AArch64_CheckDebug"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/debug/AArch64_CheckDebug</h3>
      <p class="pseudocode">// AArch64_CheckDebug()
// ====================
// Called on each access to check for a debug exception or entry to Debug state.

func <a id="func_AArch64_CheckDebug_3"/>AArch64_CheckDebug(vaddress : bits(64), accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                        size : integer) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin

    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, vaddress);
    var generate_exception : boolean;

    let d_side : boolean = <a href="shared_pseudocode.html#func_IsWatchpointableAccess_1" title="">IsWatchpointableAccess</a>(accdesc);
    let i_side : boolean = (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a>);
    if accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_NV2" title="">AccessType_NV2</a> then
        let mask : bit = '0';
        let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();
        generate_exception = (<a href="shared_pseudocode.html#func_AArch64_GenerateDebugExceptionsFrom_3" title="">AArch64_GenerateDebugExceptionsFrom</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, ss, mask) &amp;&amp;
                              MDSCR_EL1().MDE == '1');
    else
        generate_exception = <a href="shared_pseudocode.html#func_AArch64_GenerateDebugExceptions_0" title="">AArch64_GenerateDebugExceptions</a>() &amp;&amp; MDSCR_EL1().MDE == '1';
    end;
    let halt : boolean = <a href="shared_pseudocode.html#func_HaltOnBreakpointOrWatchpoint_0" title="">HaltOnBreakpointOrWatchpoint</a>();

    if generate_exception || halt then
        if d_side then
            fault = <a href="shared_pseudocode.html#func_AArch64_CheckWatchpoint_4" title="">AArch64_CheckWatchpoint</a>(fault, vaddress, accdesc, size);
        elsif i_side then
            fault = <a href="shared_pseudocode.html#func_AArch64_CheckBreakpoint_4" title="">AArch64_CheckBreakpoint</a>(fault, vaddress, accdesc, size);
        end;
    end;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.debug.AArch64_CheckWatchpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/debug/AArch64_CheckWatchpoint</h3>
      <p class="pseudocode">// AArch64_CheckWatchpoint()
// =========================
// Called before accessing the memory location of "size" bytes at "address",
// when either debug exceptions are enabled for the access, or halting debug
// is enabled and halting is allowed.

func <a id="func_AArch64_CheckWatchpoint_4"/>AArch64_CheckWatchpoint(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, vaddress_in : bits(64),
                             accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, size_in : integer) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    assert !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_S1TranslationRegime_0" title="">S1TranslationRegime</a>());
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>          = fault_in;
    var fault_match : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>    = fault_in;
    var fault_mismatch : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    var vaddress : bits(64)          = vaddress_in;
    var size : integer               = size_in;
    var rounded_match : boolean      = FALSE;
    let original_vaddress : bits(64) = vaddress;
    let original_size : integer = size;
    var addr_match_wp : boolean      = FALSE;// Default assumption that all address
                                             //  match watchpoints are inactive or disabled.
    var addr_mismatch_wp : boolean   = FALSE; // Default assumption that all address mismatch
                                              // watchpoints are inactive or disabled.
    var addr_match : boolean         = FALSE;
    var addr_mismatch : boolean      = TRUE;// Default assumption that the given virtual address is
                                            // outside the range of all address mismatch watchpoints

    // For memory accesses of below type
    // - Contiguous SVE access
    // - SME access
    // - SIMD&amp;FP access when the PE is in Streaming SVE mode
    // each call to this function is such that:
    // - the lowest accessed address is rounded down to the nearest multiple of 16 bytes
    // - the highest accessed address is rounded up to the nearest multiple of 16 bytes
    // Since the WPF field is set if the implementation does rounding, regardless of true or
    // false match, it would be acceptable to return TRUE for either/both of the first and last
    // access.
    if <a href="shared_pseudocode.html#func_IsRelaxedWatchpointAccess_1" title="">IsRelaxedWatchpointAccess</a>(accdesc) then
        var upper_vaddress : integer = UInt(original_vaddress) + original_size;
        if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_16BYTEROUNDEDDOWNACCESS" title="">Unpredictable_16BYTEROUNDEDDOWNACCESS</a>) then
            vaddress = AlignDownSize{64}(vaddress, 16);
            rounded_match = TRUE;
        end;
        if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_16BYTEROUNDEDUPACCESS" title="">Unpredictable_16BYTEROUNDEDUPACCESS</a>) then
            upper_vaddress = AlignUpSize(upper_vaddress,16);
            rounded_match = TRUE;
        end;
        size = upper_vaddress - UInt(vaddress);
    end;

    for i = 0 to <a href="shared_pseudocode.html#func_NumWatchpointsImplemented_0" title="">NumWatchpointsImplemented</a>() - 1 do
        let watchptinfo : <a href="shared_pseudocode.html#type_WatchpointInfo" title="">WatchpointInfo</a> = <a href="shared_pseudocode.html#func_AArch64_WatchpointMatch_4" title="">AArch64_WatchpointMatch</a>(i, vaddress, size, accdesc);
        if watchptinfo.wptype == <a href="shared_pseudocode.html#enum_WatchpointType_AddrMatch" title="">WatchpointType_AddrMatch</a> then
            addr_match_wp = TRUE;
            addr_match = addr_match || watchptinfo.value_match;
            if watchptinfo.value_match then
                fault_match.statuscode = <a href="shared_pseudocode.html#enum_Fault_Debug" title="">Fault_Debug</a>;
                if DBGWCR_EL1(i).LSC[0] == '1' &amp;&amp; accdesc.read then
                    fault_match.write = FALSE;
                elsif DBGWCR_EL1(i).LSC[1] == '1' &amp;&amp; accdesc.write then
                    fault_match.write = TRUE;
                end;
                fault_match.watchptinfo = watchptinfo;
            end;
        elsif watchptinfo.wptype == <a href="shared_pseudocode.html#enum_WatchpointType_AddrMismatch" title="">WatchpointType_AddrMismatch</a> then
            addr_mismatch_wp = TRUE;
            addr_mismatch = addr_mismatch &amp;&amp; !watchptinfo.value_match;
            if !watchptinfo.value_match then
                fault_mismatch.statuscode = <a href="shared_pseudocode.html#enum_Fault_Debug" title="">Fault_Debug</a>;
                if DBGWCR_EL1(i).LSC[0] == '1' &amp;&amp; accdesc.read then
                    fault_mismatch.write = FALSE;
                elsif DBGWCR_EL1(i).LSC[1] == '1' &amp;&amp; accdesc.write then
                    fault_mismatch.write = TRUE;
                end;
                fault_mismatch.watchptinfo = watchptinfo;
            end;
        end;
    end;
    if ((addr_match_wp &amp;&amp; addr_mismatch_wp &amp;&amp; addr_match &amp;&amp; addr_mismatch) ||
        (addr_match_wp &amp;&amp; !addr_mismatch_wp &amp;&amp; addr_match)) then
        fault = fault_match;
    elsif !addr_match_wp &amp;&amp; addr_mismatch_wp &amp;&amp; addr_mismatch then
        fault = fault_mismatch;
    end;
    fault.vaddress = vaddress;
    fault.watchptinfo.maybe_false_match = rounded_match;
    if (fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_Debug" title="">Fault_Debug</a> &amp;&amp; <a href="shared_pseudocode.html#func_HaltOnBreakpointOrWatchpoint_0" title="">HaltOnBreakpointOrWatchpoint</a>() &amp;&amp;
            !accdesc.nonfault &amp;&amp; !(accdesc.firstfault &amp;&amp; !accdesc.first)) then
        let reason : bits(6) = <a href="shared_pseudocode.html#global_DebugHalt_Watchpoint" title="">DebugHalt_Watchpoint</a>;
        EDWAR() = fault.vaddress;
        let is_async : boolean = FALSE;
        Halt(reason, is_async, fault);
    end;
    return fault;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.hdbss.AppendToHDBSS"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/hdbss/AppendToHDBSS</h3>
      <p class="pseudocode">// AppendToHDBSS()
// ===============
// Appends an entry to the HDBSS when the dirty state of a stage 2 descriptor is updated
// from writable-clean to writable-dirty by hardware.

func AppendToHDBSS(fault_in : FaultRecord, ipa_in : FullAddress, accdesc : AccessDescriptor,
                   walkparams : S2TTWParams, level : integer) =&gt; FaultRecord
begin
    assert CanAppendToHDBSS();

    var fault : FaultRecord  = fault_in;
    var ipa : FullAddress    = ipa_in;
    let hdbss_size : integer{} = UInt(HDBSSBR_EL2().SZ) as integer{0..9};

    var hdbss_addrdesc : AddressDescriptor;

    var baddr : bits(56) = HDBSSBR_EL2().BADDR[43 : 0] :: Zeros{12};
    baddr[11 + hdbss_size : 12]  = Zeros{hdbss_size};

    hdbss_addrdesc.paddress.address = baddr + (8 * UInt(HDBSSPROD_EL2().INDEX));
    let nse2 : bit = '0';     // NSE2 has the Effective value of 0 within a PE.
    hdbss_addrdesc.paddress.paspace = DecodePASpace(nse2, EffectiveSCR_EL3_NSE(),
                                                    EffectiveSCR_EL3_NS());

    // Accesses to the HDBSS use the same memory attributes as used for stage 2 translation walks.
    hdbss_addrdesc.memattrs         = WalkMemAttrs(walkparams.sh, walkparams.irgn, walkparams.orgn);
    let hdbss_access : AccessDescriptor = CreateAccDescHDBSS(accdesc);
    hdbss_addrdesc.mecid            = AArch64_S2TTWalkMECID(walkparams.emec, accdesc.ss);

    if IsFeatureImplemented(FEAT_RME) then
        fault.gpcf = GranuleProtectionCheck(hdbss_addrdesc, hdbss_access);

        if fault.gpcf.gpf != GPCF_None then
            if (ImpDefBool(
                  "GPC fault on HDBSSS write reported in HDBSSPROD_EL2")) then
                HDBSSPROD_EL2().FSC = '101000';
            else
                fault.statuscode = Fault_GPCFOnWalk;
                fault.paddress   = hdbss_addrdesc.paddress;
                fault.level      = level;
                fault.gpcfs2walk = TRUE;
                fault.hdbssf     = TRUE;
            end;

            return fault;
        end;
    end;

    // The reported IPA must be aligned to the size of the translation.
    let lsb : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = TranslationSize(walkparams.d128, walkparams.tgx, level);
    ipa.address           = ipa.address[55:lsb] :: Zeros{lsb};
    var hdbss_entry : bits(64) = CreateHDBSSEntry(ipa, hdbss_access.ss, level);

    if walkparams.ee == '1' then
        hdbss_entry = BigEndianReverse{64}(hdbss_entry);
    end;

    let memstatus : PhysMemRetStatus = PhysMemWrite{64}(hdbss_addrdesc, hdbss_access,
                                                        hdbss_entry);

    if IsFault(memstatus) then
        if (ImpDefBool(
              "External Abort on HDBSS write reported in HDBSSPROD_EL2")) then
            HDBSSPROD_EL2().FSC = '010000';
        else
            let iswrite : boolean = TRUE;
            fault = HandleExternalTTWAbort(memstatus, iswrite, hdbss_addrdesc,
                                           hdbss_access, 8, fault);
            fault.level  = level;
            fault.hdbssf = TRUE;
        end;
    else
        HDBSSPROD_EL2().INDEX = HDBSSPROD_EL2().INDEX + 1;
    end;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.hdbss.CanAppendToHDBSS"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/hdbss/CanAppendToHDBSS</h3>
      <p class="pseudocode">// CanAppendToHDBSS()
// ==================
// Return TRUE if HDBSS can be appended.

readonly func <a id="func_CanAppendToHDBSS_0"/>CanAppendToHDBSS() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_HDBSS) then
        return FALSE;
    end;
    assert <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
    // The PE cannot append entries to the HDBSS if HDBSSPROD_EL2.FSC is
    // any other value than 0b000000, or HDBSS buffer is full.

    if ((UInt(HDBSSPROD_EL2().INDEX) &gt;= ((2 ^ (UInt(HDBSSBR_EL2().SZ) + 12)) DIV 8)) ||
         (HDBSSPROD_EL2().FSC != '000000')) then
        return FALSE;
    else
        return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.hdbss.CreateHDBSSEntry"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/hdbss/CreateHDBSSEntry</h3>
      <p class="pseudocode">// CreateHDBSSEntry()
// ==================
// Returns a HDBSS entry.

func <a id="func_CreateHDBSSEntry_3"/>CreateHDBSSEntry(ipa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>, ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, level : integer) =&gt; bits(64)
begin
    let ns_ipa : bit = if ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> &amp;&amp; ipa.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> then '1' else '0';
    return ZeroExtend{64}(ipa.address[55:12] ::
                          ns_ipa :: Zeros{7} :: level[2:0] :: '1');
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_IASize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_IASize</h3>
      <p class="pseudocode">// AArch64_IASize()
// ================
// Retrieve the number of bits containing the input address

func AArch64_IASize(txsz : bits(6)) =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    return (64 - UInt(txsz)) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_NextTableBase"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_NextTableBase</h3>
      <p class="pseudocode">// AArch64_NextTableBase()
// =======================
// Extract the address embedded in a table descriptor pointing to the base of
// the next level table of descriptors

func AArch64_NextTableBase{N}(descriptor : bits(N), d128 : bit, skl : bits(2),
                              ds : bit, tgx : TGx) =&gt; bits(56)
begin
    var tablebase : bits(56) = Zeros{};
    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = TGxGranuleBits(tgx);
    var tablesize : integer;

    if d128 == '1' then
        let descsizelog2 : integer = 4;
        let stride : integer = granulebits - descsizelog2;
        tablesize = stride*(1 + UInt(skl)) + descsizelog2;
    else
        tablesize = granulebits;
    end;

    case tgx of
        when TGx_4KB =&gt;  tablebase[47:12] = descriptor[47:12];
        when TGx_16KB =&gt; tablebase[47:14] = descriptor[47:14];
        when TGx_64KB =&gt; tablebase[47:16] = descriptor[47:16];
    end;

    tablebase = AlignDownP2{56}(tablebase, tablesize as integer{0..56});

    if d128 == '1' then
        tablebase[55:48] = descriptor[55:48];
    elsif tgx == TGx_64KB &amp;&amp; (AArch64_PAMax() &gt;= 52 ||
            ImpDefBool("descriptor[15:12] for 64KB granule are OA[51:48]")) then
        tablebase[51:48] = descriptor[15:12];
    elsif ds == '1' then
        tablebase[51:48] = descriptor[9:8]::descriptor[49:48];
    end;

    return tablebase;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_PhysicalAddressSize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_PhysicalAddressSize</h3>
      <p class="pseudocode">// AArch64_PhysicalAddressSize()
// =============================
// Retrieve the number of bits bounding the physical address

func AArch64_PhysicalAddressSize(d128 : bit, ds : bit, encoded_ps : bits(3),
                                 tgx : TGx) =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    var ps : integer;
    var max_ps : integer;

    case encoded_ps of
        when '000' =&gt;  ps = 32;
        when '001' =&gt;  ps = 36;
        when '010' =&gt;  ps = 40;
        when '011' =&gt;  ps = 42;
        when '100' =&gt;  ps = 44;
        when '101' =&gt;  ps = 48;
        when '110' =&gt;  ps = 52;
        when '111' =&gt;  ps = 56;
    end;

    if d128 == '1' then
        max_ps = AArch64_PAMax();
    elsif IsFeatureImplemented(FEAT_LPA) &amp;&amp; (tgx == TGx_64KB || ds == '1') then
        max_ps = Min(52, AArch64_PAMax());
    else
        max_ps = Min(48, AArch64_PAMax());
    end;

    return Min(ps, max_ps) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_S1LeafBase"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_S1LeafBase</h3>
      <p class="pseudocode">// AArch64_S1LeafBase()
// ====================
// Extract the address embedded in a block and page descriptor pointing to the
// base of a memory block

func AArch64_S1LeafBase{N}(descriptor : bits(N), walkparams : S1TTWParams,
                           level : integer) =&gt; bits(56)
begin
    var leafbase : bits(56) = Zeros{};

    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>  = TGxGranuleBits(walkparams.tgx);
    let descsizelog2 : integer{}   = if walkparams.d128 == '1' then 4 else 3;
    let stride : integer = granulebits - descsizelog2;
    let leafsize : integer = granulebits + stride * (FINAL_LEVEL - level);

    leafbase[47:0] = AlignDownP2{48}(descriptor[47:0], leafsize as integer{0..48});

    if walkparams.d128 == '1' then
        leafbase[55:48] = descriptor[55:48];
    elsif walkparams.tgx == TGx_64KB &amp;&amp; (AArch64_PAMax() &gt;= 52 ||
            ImpDefBool("descriptor[15:12] for 64KB granule are OA[51:48]")) then
        leafbase[51:48] = descriptor[15:12];
    elsif walkparams.ds == '1' then
        leafbase[51:48] = descriptor[9:8,49:48];
    end;

    return leafbase;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_S1SLTTEntryAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_S1SLTTEntryAddress</h3>
      <p class="pseudocode">// AArch64_S1SLTTEntryAddress()
// ============================
// Compute the first stage 1 translation table descriptor address within the
// table pointed to by the base at the start level

func AArch64_S1SLTTEntryAddress(level : integer, walkparams : S1TTWParams,
                                ia : bits(64), tablebase : FullAddress) =&gt; FullAddress
begin
    // Input Address size
    let iasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>       = AArch64_IASize(walkparams.txsz);
    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>  = TGxGranuleBits(walkparams.tgx);
    let descsizelog2 : integer{} = if walkparams.d128 == '1' then 4 else 3;
    let stride : integer{}       = granulebits - descsizelog2;
    let levels : integer         = FINAL_LEVEL - level;

    var index : bits(56);
    let lsb : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = (levels*stride + granulebits) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    let msb : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = (iasize - 1) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    index = ZeroExtend{56}(ia[msb:lsb]::Zeros{descsizelog2});

    var descaddress : FullAddress;
    descaddress.address = tablebase.address OR index;
    descaddress.paspace = tablebase.paspace;

    return descaddress;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_S1StartLevel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_S1StartLevel</h3>
      <p class="pseudocode">// AArch64_S1StartLevel()
// ======================
// Compute the initial lookup level when performing a stage 1 translation
// table walk

func AArch64_S1StartLevel(walkparams : S1TTWParams) =&gt; integer
begin
    // Input Address size
    let iasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>       = AArch64_IASize(walkparams.txsz);
    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>  = TGxGranuleBits(walkparams.tgx);
    let descsizelog2 : integer = if walkparams.d128 == '1' then 4 else 3;
    let stride : integer = granulebits - descsizelog2;
    var s1startlevel : integer = FINAL_LEVEL - (((iasize-1) - granulebits) DIVRM stride);
    if walkparams.d128 == '1' then
        s1startlevel = s1startlevel + UInt(walkparams.skl);
    end;
    return s1startlevel;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_S1TTBaseAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_S1TTBaseAddress</h3>
      <p class="pseudocode">// AArch64_S1TTBaseAddress()
// =========================
// Retrieve the PA/IPA pointing to the base of the initial translation table of stage 1

func AArch64_S1TTBaseAddress{N}(walkparams : S1TTWParams,
                                regime : Regime, ttbr : bits(N)) =&gt; bits(56)
begin
    var tablebase : bits(56) = Zeros{};

    // Input Address size
    let iasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>      = AArch64_IASize(walkparams.txsz);
    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = TGxGranuleBits(walkparams.tgx);
    let descsizelog2 : integer{} = if walkparams.d128 == '1' then 4 else 3;
    let stride : integer{}    = granulebits - descsizelog2;
    let startlevel : integer  = AArch64_S1StartLevel(walkparams);
    let levels : integer      = FINAL_LEVEL - startlevel;

    // Base address is aligned to size of the initial translation table in bytes
    var tsize : integer = (iasize - (levels*stride + granulebits)) + descsizelog2;

    if walkparams.d128 == '1' then
        tsize = Max(tsize, 5);
        if regime == Regime_EL3 then
            tablebase[55:5] = ttbr[55:5];
        else
            tablebase[55:5] = ttbr[87:80]::ttbr[47:5];
        end;
    elsif walkparams.ds == '1' || (walkparams.tgx == TGx_64KB &amp;&amp; walkparams.ps == '110' &amp;&amp;
            (IsFeatureImplemented(FEAT_LPA) ||
             ImpDefBool("BADDR expresses 52 bits for 64KB granule"))) then
        tsize = Max(tsize, 6);
        tablebase[51:6] = ttbr[5:2]::ttbr[47:6];
    else
        tablebase[47:1] = ttbr[47:1];
    end;
    tablebase = AlignDownP2{56}(tablebase,tsize as integer{0..56});
    return tablebase;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_S1TTEntryAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_S1TTEntryAddress</h3>
      <p class="pseudocode">// AArch64_S1TTEntryAddress()
// ==========================
// Compute translation table descriptor address within the table pointed to by
// the table base

func AArch64_S1TTEntryAddress{N}(level : integer, walkparams : S1TTWParams, skl : bits(2),
                                 ia : bits(64), tablebase : FullAddress,
                                 descriptor : bits(N)) =&gt; FullAddress
begin
    // Input Address size
    let iasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>      = AArch64_IASize(walkparams.txsz);
    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = TGxGranuleBits(walkparams.tgx);
    let descsizelog2 : integer{} = if walkparams.d128 == '1' then 4 else 3;
    let stride : integer{}      = granulebits - descsizelog2;
    let levels : integer        = FINAL_LEVEL - level;

    var index : bits(56);

    let lsb : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = (levels*stride + granulebits) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    let nstride : integer = if walkparams.d128 == '1' then UInt(skl) + 1 else 1;
    let msb : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = ((lsb + (stride * nstride)) - 1) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    index = ZeroExtend{56}(ia[msb:lsb]::Zeros{descsizelog2});

    var descaddress : FullAddress;
    descaddress.address = tablebase.address OR index;
    descaddress.paspace = tablebase.paspace;

    return descaddress;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_S2LeafBase"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_S2LeafBase</h3>
      <p class="pseudocode">// AArch64_S2LeafBase()
// ====================
// Extract the address embedded in a block and page descriptor pointing to the
// base of a memory block

func AArch64_S2LeafBase{N}(descriptor : bits(N), walkparams : S2TTWParams,
                           level : integer) =&gt; bits(56)
begin
    var leafbase : bits(56) = Zeros{};

    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>  = TGxGranuleBits(walkparams.tgx);
    let descsizelog2 : integer{} = if walkparams.d128 == '1' then 4 else 3;
    let stride : integer   = granulebits - descsizelog2;
    let leafsize : integer = granulebits + stride * (FINAL_LEVEL - level);

    leafbase[47:0] = AlignDownP2{48}(descriptor[47:0], leafsize as integer{0..48});

    if walkparams.d128 == '1' then
        leafbase[55:48] = descriptor[55:48];
    elsif walkparams.tgx == TGx_64KB &amp;&amp; (AArch64_PAMax() &gt;= 52 ||
            (ImpDefBool(
               "descriptor[15:12] for 64KB granule are OA[51:48]"))) then
        leafbase[51:48] = descriptor[15:12];
    elsif walkparams.ds == '1' then
        leafbase[51:48] = descriptor[9:8]::descriptor[49:48];
    end;

    return leafbase;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_S2SLTTEntryAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_S2SLTTEntryAddress</h3>
      <p class="pseudocode">// AArch64_S2SLTTEntryAddress()
// ============================
// Compute the first stage 2 translation table descriptor address within the
// table pointed to by the base at the start level

func AArch64_S2SLTTEntryAddress(walkparams : S2TTWParams, ipa : bits(56),
                                tablebase : FullAddress) =&gt; FullAddress
begin
    let startlevel   = AArch64_S2StartLevel(walkparams);
    let iasize       = AArch64_IASize(walkparams.txsz);
    let granulebits  = TGxGranuleBits(walkparams.tgx);
    let descsizelog2 : integer{} = if walkparams.d128 == '1' then 4 else 3;
    let stride : integer{}       = granulebits - descsizelog2;
    let levels : integer         = FINAL_LEVEL - startlevel;

    var index : bits(56);
    let lsb : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = (levels*stride + granulebits) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    let msb : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = (iasize - 1) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    index = ZeroExtend{56}(ipa[msb:lsb]::Zeros{descsizelog2});

    var descaddress : FullAddress;
    descaddress.address = tablebase.address OR index;
    descaddress.paspace = tablebase.paspace;

    return descaddress;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_S2StartLevel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_S2StartLevel</h3>
      <p class="pseudocode">// AArch64_S2StartLevel()
// ======================
// Determine the initial lookup level when performing a stage 2 translation
// table walk

func AArch64_S2StartLevel(walkparams : S2TTWParams) =&gt; integer
begin
    if walkparams.d128 == '1' then
        let iasize       : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = AArch64_IASize(walkparams.txsz);
        let granulebits  : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = TGxGranuleBits(walkparams.tgx);
        let descsizelog2 : integer{} = 4;
        let stride : integer = granulebits - descsizelog2;
        var s2startlevel : integer = FINAL_LEVEL - (((iasize-1) - granulebits) DIVRM stride);
        s2startlevel = s2startlevel + UInt(walkparams.skl);

        return s2startlevel;
    end;

    case walkparams.tgx of
        when TGx_4KB =&gt;
            case walkparams.sl2::walkparams.sl0 of
                when '000' =&gt; return 2;
                when '001' =&gt; return 1;
                when '010' =&gt; return 0;
                when '011' =&gt; return 3;
                when '100' =&gt; return -1;
            end;
        when TGx_16KB =&gt;
            case walkparams.sl0 of
                when '00' =&gt; return 3;
                when '01' =&gt; return 2;
                when '10' =&gt; return 1;
                when '11' =&gt; return 0;
            end;
        when TGx_64KB =&gt;
            case walkparams.sl0 of
                when '00' =&gt; return 3;
                when '01' =&gt; return 2;
                when '10' =&gt; return 1;
            end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_S2TTBaseAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_S2TTBaseAddress</h3>
      <p class="pseudocode">// AArch64_S2TTBaseAddress()
// =========================
// Retrieve the PA/IPA pointing to the base of the initial translation table of stage 2

func AArch64_S2TTBaseAddress{N}(walkparams : S2TTWParams, paspace : PASpace,
                                ttbr : bits(N)) =&gt; bits(56)
begin
    var tablebase : bits(56) = Zeros{};

    // Input Address size
    let iasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>      = AArch64_IASize(walkparams.txsz);
    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = TGxGranuleBits(walkparams.tgx);
    let descsizelog2 : integer{}  = if walkparams.d128 == '1' then 4 else 3;
    let stride : integer{}        = granulebits - descsizelog2;
    let startlevel : integer      = AArch64_S2StartLevel(walkparams);
    let levels : integer          = FINAL_LEVEL - startlevel;

    // Base address is aligned to size of the initial translation table in bytes
    var tsize : integer = (iasize - (levels*stride + granulebits)) + descsizelog2;

    if walkparams.d128 == '1' then
        tsize = Max(tsize, 5);
        if paspace == PAS_Secure then
            tablebase[55:5] = ttbr[55:5];
        else
            tablebase[55:5] = ttbr[87:80]::ttbr[47:5];
        end;
    elsif walkparams.ds == '1' || (walkparams.tgx == TGx_64KB &amp;&amp; walkparams.ps == '110' &amp;&amp;
            (IsFeatureImplemented(FEAT_LPA) ||
             ImpDefBool("BADDR expresses 52 bits for 64KB granule"))) then
        tsize = Max(tsize, 6);
        tablebase[51:6] = ttbr[5:2]::ttbr[47:6];
    else
        tablebase[47:1] = ttbr[47:1];
    end;
    tablebase = AlignDownP2{56}(tablebase, tsize as integer{0..56});
    return tablebase;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64_S2TTEntryAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64_S2TTEntryAddress</h3>
      <p class="pseudocode">// AArch64_S2TTEntryAddress()
// ==========================
// Compute translation table descriptor address within the table pointed to by
// the table base

func AArch64_S2TTEntryAddress(level : integer, walkparams : S2TTWParams, skl :  bits(2),
                              ipa :  bits(56), tablebase : FullAddress) =&gt; FullAddress
begin
    let ipasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>     = AArch64_IASize(walkparams.txsz);
    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = TGxGranuleBits(walkparams.tgx);
    let descsizelog2 : integer{} = if walkparams.d128 == '1' then 4 else 3;
    let stride : integer{}      = granulebits - descsizelog2;
    let levels : integer        = FINAL_LEVEL - level;

    var index : bits(56);

    let lsb : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = (levels*stride + granulebits) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    let nstride : integer = if walkparams.d128 == '1' then UInt(skl) + 1 else 1;
    let msb : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = ((lsb + (stride * nstride)) - 1) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    index = ZeroExtend{56}(ipa[msb:lsb]::Zeros{descsizelog2});

    var descaddress : FullAddress;
    descaddress.address = tablebase.address OR index;
    descaddress.paspace = tablebase.paspace;

    return descaddress;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_AddrTop"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_AddrTop</h3>
      <p class="pseudocode">// AArch64_AddrTop()
// =================
// Get the top bit position of the virtual address.
// Bits above are not accounted as part of the translation process.

func AArch64_AddrTop(tbid : bit, acctype : AccessType, tbi : bit) =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    if tbid == '1' &amp;&amp; acctype == AccessType_IFETCH then
        return 63;
    end;

    if tbi == '1' then
        return 55;
    else
        return 63;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_ContiguousBitFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_ContiguousBitFaults</h3>
      <p class="pseudocode">// AArch64_ContiguousBitFaults()
// =============================
// If contiguous bit is set, returns whether the translation size exceeds the
// input address size and if the implementation generates a fault

func AArch64_ContiguousBitFaults(d128 : bit, txsz : bits(6), tgx : TGx, level : integer) =&gt; boolean
begin
    // Input Address size
    let iasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = AArch64_IASize(txsz);
    // Translation size
    let tsize : integer = TranslationSize(d128, tgx, level) + ContiguousSize(d128, tgx, level);

    return (tsize &gt; iasize &amp;&amp;
            ImpDefBool("Translation fault on misprogrammed contiguous bit"));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_IPAIsOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_IPAIsOutOfRange</h3>
      <p class="pseudocode">// AArch64_IPAIsOutOfRange()
// =========================
// Check bits not resolved by translation are ZERO

func <a id="func_AArch64_IPAIsOutOfRange_2"/>AArch64_IPAIsOutOfRange(ipa : bits(56), walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>) =&gt; boolean
begin
    //Input Address size
    let iasize : integer{} = AArch64_IASize(walkparams.txsz);

    if iasize &lt; 56 then
        return !IsZero(ipa[55:iasize]);
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_OAOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_OAOutOfRange</h3>
      <p class="pseudocode">// AArch64_OAOutOfRange()
// ======================
// Returns whether output address is expressed in the configured size number of bits

func <a id="func_AArch64_OAOutOfRange_5"/>AArch64_OAOutOfRange(address : bits(56), d128 : bit,
                          ds : bit, ps : bits(3), tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>) =&gt; boolean
begin
    // Output Address size
    let oasize : integer{} = AArch64_PhysicalAddressSize(d128, ds, ps, tgx);

    if oasize &lt; 56 then
        return !IsZero(address[55:oasize]);
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_PermissionOverlaysApplied"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_PermissionOverlaysApplied</h3>
      <p class="pseudocode">// AArch64_PermissionOverlaysApplied()
// ===================================
// Returns TRUE if Permission overlays are applied for the given access type.

func <a id="func_AArch64_PermissionsOverlaysApplied_1"/>AArch64_PermissionsOverlaysApplied(acctype : <a href="shared_pseudocode.html#type_AccessType" title="">AccessType</a>) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S1CheckPermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S1CheckPermissions</h3>
      <p class="pseudocode">// AArch64_S1CheckPermissions()
// ============================
// Checks whether stage 1 access violates permissions of target memory
// and returns a fault record

func <a id="func_AArch64_S1CheckPermissions_7"/>AArch64_S1CheckPermissions(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, va : bits(64), size : integer,
                                regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>,
                                accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    let permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a> = walkstate.permissions;
    var s1perms : <a href="shared_pseudocode.html#type_S1AccessControls" title="">S1AccessControls</a> = <a href="shared_pseudocode.html#func_AArch64_S1ComputePermissions_4" title="">AArch64_S1ComputePermissions</a>(regime, walkstate,
                                                                  walkparams, accdesc);

    if accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> then
        // Flag the access is from a guarded page
        SetInGuardedPage(walkstate.guardedpage == '1' &amp;&amp; s1perms.x == '1');

        if s1perms.overlay &amp;&amp; s1perms.ox == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
            fault.overlay    = TRUE;
        elsif (walkstate.memattrs.memtype == MemType_Device &amp;&amp;
                ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_INSTRDEVICE" title="">Unpredictable_INSTRDEVICE</a>) == <a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a>) then
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
        elsif s1perms.x == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
        end;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a> then
        if accdesc.cacheop == <a href="shared_pseudocode.html#enum_CacheOp_Invalidate" title="">CacheOp_Invalidate</a> then
            if s1perms.overlay &amp;&amp; s1perms.ow == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
                fault.overlay    = TRUE;
            elsif s1perms.w == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
            elsif (walkparams.hd != '1' &amp;&amp; walkparams.pie == '1' &amp;&amp;
                     permissions.ndirty == '1') then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
                fault.dirtybit   = TRUE;
            end;
        // DC from privileged context which clean cannot generate a Permission fault
        elsif accdesc.el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
            if s1perms.overlay &amp;&amp; s1perms.or == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
                fault.overlay    = TRUE;
            elsif (walkparams.cmow == '1' &amp;&amp;
                    accdesc.cacheop == <a href="shared_pseudocode.html#enum_CacheOp_CleanInvalidate" title="">CacheOp_CleanInvalidate</a> &amp;&amp;
                    s1perms.overlay &amp;&amp; s1perms.ow == '0') then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
                fault.overlay    = TRUE;
            elsif s1perms.r == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
            elsif (walkparams.cmow == '1' &amp;&amp;
                    accdesc.cacheop == <a href="shared_pseudocode.html#enum_CacheOp_CleanInvalidate" title="">CacheOp_CleanInvalidate</a> &amp;&amp;
                    s1perms.w == '0') then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
            elsif (walkparams.cmow == '1' &amp;&amp; walkparams.hd != '1' &amp;&amp; walkparams.pie == '1' &amp;&amp;
                     permissions.ndirty == '1' &amp;&amp; accdesc.cacheop == <a href="shared_pseudocode.html#enum_CacheOp_CleanInvalidate" title="">CacheOp_CleanInvalidate</a>) then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
                fault.dirtybit   = TRUE;
            end;
        end;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a> then
        // IC from privileged context cannot generate Permission fault
        if accdesc.el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
            if (s1perms.overlay &amp;&amp; s1perms.or == '0' &amp;&amp;
                  ImpDefBool("Permission fault on EL0 IC_IVAU execution")) then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
                fault.overlay    = TRUE;
            elsif walkparams.cmow == '1' &amp;&amp; s1perms.overlay &amp;&amp; s1perms.ow == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
                fault.overlay    = TRUE;
            elsif (s1perms.r == '0' &amp;&amp;
                  ImpDefBool("Permission fault on EL0 IC_IVAU execution")) then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
            elsif walkparams.cmow == '1' &amp;&amp; s1perms.w == '0' then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
            elsif (walkparams.cmow == '1' &amp;&amp; walkparams.hd != '1' &amp;&amp; walkparams.pie == '1' &amp;&amp;
                     permissions.ndirty == '1') then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
                fault.dirtybit   = TRUE;
            end;
        end;
    elsif IsFeatureImplemented(FEAT_GCS) &amp;&amp; accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_GCS" title="">AccessType_GCS</a> then
        if s1perms.gcs == '0' then
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
        elsif accdesc.write &amp;&amp; walkparams.hd != '1' &amp;&amp; permissions.ndirty == '1' then
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
            fault.dirtybit   = TRUE;
            fault.write      = TRUE;
        end;
    elsif accdesc.read &amp;&amp; s1perms.overlay &amp;&amp; s1perms.or == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
        fault.overlay    = TRUE;
        fault.write      = FALSE;
    elsif accdesc.write &amp;&amp; s1perms.overlay &amp;&amp; s1perms.ow == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
        fault.overlay    = TRUE;
        fault.write      = TRUE;
    elsif accdesc.read &amp;&amp; s1perms.r == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
        fault.write      = FALSE;
    elsif accdesc.write &amp;&amp; s1perms.w == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
        fault.write      = TRUE;
    elsif (accdesc.write &amp;&amp; accdesc.tagaccess &amp;&amp;
            walkstate.memattrs.tags == <a href="shared_pseudocode.html#enum_MemTag_CanonicallyTagged" title="">MemTag_CanonicallyTagged</a>) then
        fault.statuscode   = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
        fault.write        = TRUE;
        fault.s1tagnotdata = TRUE;
    elsif (accdesc.write &amp;&amp; walkparams.hd != '1' &amp;&amp; walkparams.pie == '1' &amp;&amp;
            permissions.ndirty == '1') then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>;
        fault.dirtybit   = TRUE;
        fault.write      = TRUE;
    end;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S1ComputePermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S1ComputePermissions</h3>
      <p class="pseudocode">// AArch64_S1ComputePermissions()
// ==============================
// Computes the overall stage 1 permissions

func <a id="func_AArch64_S1ComputePermissions_4"/>AArch64_S1ComputePermissions(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>,
                                  walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>,
                                  accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_S1AccessControls" title="">S1AccessControls</a>
begin
    let permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a> = walkstate.permissions;
    var s1perms : <a href="shared_pseudocode.html#type_S1AccessControls" title="">S1AccessControls</a>;

    if walkparams.pie == '1' then
        s1perms = <a href="shared_pseudocode.html#func_AArch64_S1IndirectBasePermissions_4" title="">AArch64_S1IndirectBasePermissions</a>(regime, walkstate, walkparams, accdesc);
    else
        s1perms = <a href="shared_pseudocode.html#func_AArch64_S1DirectBasePermissions_4" title="">AArch64_S1DirectBasePermissions</a>(regime, walkstate, walkparams, accdesc);
    end;

    if accdesc.el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_AArch64_S1E0POEnabled_2" title="">AArch64_S1E0POEnabled</a>(regime, walkparams.nv1) then
        s1perms.overlay = FALSE;
    elsif accdesc.el != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_AArch64_S1POEnabled_1" title="">AArch64_S1POEnabled</a>(regime) then
        s1perms.overlay = FALSE;
    end;

    if s1perms.overlay then
        let s1overlay_perms : <a href="shared_pseudocode.html#type_S1AccessControls" title="">S1AccessControls</a> = <a href="shared_pseudocode.html#func_AArch64_S1OverlayPermissions_3" title="">AArch64_S1OverlayPermissions</a>(regime,
                                                                              walkstate,
                                                                              accdesc);
        s1perms.or = s1overlay_perms.or;
        s1perms.ow = s1overlay_perms.ow;
        s1perms.ox = s1overlay_perms.ox;
    end;

    if s1perms.overlay then
        // If WXN and the overlay X permission is present, the overlay W permission is removed.
        s1perms.ow = s1perms.ow AND NOT(s1perms.wxn AND s1perms.ox);
    else
        // If WXN and the W and X permissions are present, the X permission is removed.
        // The W and X permissions are factored into the WXN computation.
        s1perms.x  = s1perms.x AND NOT(s1perms.wxn);
    end;

    return s1perms;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S1DirectBasePermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S1DirectBasePermissions</h3>
      <p class="pseudocode">// AArch64_S1DirectBasePermissions()
// =================================
// Computes the stage 1 direct base permissions

func <a id="func_AArch64_S1DirectBasePermissions_4"/>AArch64_S1DirectBasePermissions(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>,
                                     walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>,
                                     accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_S1AccessControls" title="">S1AccessControls</a>
begin
    var r,  w,  x : bit;
    var pr, pw, px : bit;
    var ur, uw, ux : bit;
    var permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a> = walkstate.permissions;
    var s1perms : <a href="shared_pseudocode.html#type_S1AccessControls" title="">S1AccessControls</a>;
    // Descriptors marked with DBM set have the effective value of AP[2] cleared.
    // This implies no Permission faults caused by lack of write permissions are
    // reported, and the Dirty bit can be set.
    if permissions.dbm == '1' &amp;&amp; walkparams.hd == '1' then
        permissions.ap[2] = '0';
    end;

    if <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime) then
        // Apply leaf permissions
        case permissions.ap[2:1] of
            when '00' =&gt; (pr,pw,ur,uw) = ('1','1','0','0'); // Privileged access
            when '01' =&gt; (pr,pw,ur,uw) = ('1','1','1','1'); // No effect
            when '10' =&gt; (pr,pw,ur,uw) = ('1','0','0','0'); // Read-only, privileged access
            when '11' =&gt; (pr,pw,ur,uw) = ('1','0','1','0'); // Read-only
        end;

        // Apply hierarchical permissions
        case permissions.ap_table of
            when '00' =&gt; (pr,pw,ur,uw) = ( pr, pw, ur, uw); // No effect
            when '01' =&gt; (pr,pw,ur,uw) = ( pr, pw,'0','0'); // Privileged access
            when '10' =&gt; (pr,pw,ur,uw) = ( pr,'0', ur,'0'); // Read-only
            when '11' =&gt; (pr,pw,ur,uw) = ( pr,'0','0','0'); // Read-only, privileged access
        end;

        // Locations writable by unprivileged cannot be executed by privileged
        px = NOT(permissions.pxn OR permissions.pxn_table OR uw);
        ux = NOT(permissions.uxn OR permissions.uxn_table);

        if (IsFeatureImplemented(FEAT_PAN) &amp;&amp; accdesc.pan &amp;&amp; !(regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp;
              walkparams.nv1 == '1')) then
            var pan : bit;
            if (ImpDefBool("SCR_EL3.SIF affects EPAN") &amp;&amp;
                    accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> &amp;&amp;
                    walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> &amp;&amp;
                    walkparams.sif == '1') then
                ux = '0';
            end;

            if (ImpDefBool("Realm EL2&amp;0 regime affects EPAN") &amp;&amp;
                    accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> &amp;&amp; regime == <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> &amp;&amp;
                    walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>) then
                ux = '0';
            end;

            pan = PSTATE.PAN AND (ur OR uw OR (walkparams.epan AND ux));
            pr = pr AND NOT(pan);
            pw = pw AND NOT(pan);
        end;

    else
        // Apply leaf permissions
        case permissions.ap[2] of
            when '0' =&gt; (pr,pw) = ('1','1'); // No effect
            when '1' =&gt; (pr,pw) = ('1','0'); // Read-only
        end;

        // Apply hierarchical permissions
        case permissions.ap_table[1] of
            when '0' =&gt; (pr,pw) = ( pr, pw); // No effect
            when '1' =&gt; (pr,pw) = ( pr,'0'); // Read-only
        end;

        px = NOT(permissions.xn OR permissions.xn_table);
    end;

    (r,w,x) = if accdesc.el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then (ur,uw,ux) else (pr,pw,px);

    // Compute WXN value
    let wxn : bit = walkparams.wxn AND w AND x;

    // Prevent execution from Non-secure space by PE in secure state if SIF is set
    if accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> &amp;&amp; walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> then
        x = x AND NOT(walkparams.sif);
    end;
    // Prevent execution from non-Root space by Root
    if accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> &amp;&amp; walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a> then
        x = '0';
    end;
    // Prevent execution from non-Realm space by Realm EL2 and Realm EL2&amp;0
    if (accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> &amp;&amp; regime IN {<a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>, <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>} &amp;&amp;
            walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>) then
        x = '0';
    end;

    s1perms.r   = r;
    s1perms.w   = w;
    s1perms.x   = x;
    s1perms.gcs = '0';
    s1perms.wxn = wxn;
    s1perms.overlay = TRUE;

    return s1perms;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S1HasAlignmentFaultDueToMemType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S1HasAlignmentFaultDueToMemType</h3>
      <p class="pseudocode">// AArch64_S1HasAlignmentFaultDueToMemType()
// =========================================
// Returns whether stage 1 output fails alignment requirement on data accesses due to memory type

func <a id="func_AArch64_S1HasAlignmentFaultDueToMemType_5"/>AArch64_S1HasAlignmentFaultDueToMemType(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                             aligned : boolean, ntlsmd : bit,
                                             memattrs : MemoryAttributes) =&gt; boolean
begin
    if accdesc.exclusive || accdesc.atomicop || accdesc.acqsc || accdesc.acqpc || accdesc.relsc then
        if (!aligned &amp;&amp; !(<a href="shared_pseudocode.html#func_IsWBShareable_1" title="">IsWBShareable</a>(memattrs) &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_S1DCacheEnabled_1" title="">AArch64_S1DCacheEnabled</a>(regime)) &amp;&amp;
              <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_LSE2_ALIGNMENT_FAULT" title="">Unpredictable_LSE2_ALIGNMENT_FAULT</a>)) then
            return TRUE;
        end;
    end;

    let isTagWrite : boolean = accdesc.cachetype IN { <a href="shared_pseudocode.html#enum_CacheType_Tag" title="">CacheType_Tag</a>,
                                                      <a href="shared_pseudocode.html#enum_CacheType_TagWrite" title="">CacheType_TagWrite</a>,
                                                      <a href="shared_pseudocode.html#enum_CacheType_TagZero" title="">CacheType_TagZero</a> };

    if memattrs.memtype != MemType_Device then
        return FALSE;
    elsif ((accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_DCZero" title="">AccessType_DCZero</a> &amp;&amp; isTagWrite) ||
             accdesc.stzgm) then
        return ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_DEVICETAGSTORE" title="">Unpredictable_DEVICETAGSTORE</a>) == <a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a>;
    elsif accdesc.a32lsmd &amp;&amp; ntlsmd == '0' then
        return memattrs.device != <a href="shared_pseudocode.html#enum_DeviceType_GRE" title="">DeviceType_GRE</a>;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_DCZero" title="">AccessType_DCZero</a> then
        return TRUE;
    elsif !aligned then
        return !(ImpDefBool("Device location supports unaligned access"));
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S1IndirectBasePermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S1IndirectBasePermissions</h3>
      <p class="pseudocode">// AArch64_S1IndirectBasePermissions()
// ===================================
// Computes the stage 1 indirect base permissions

func <a id="func_AArch64_S1IndirectBasePermissions_4"/>AArch64_S1IndirectBasePermissions(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>,
                                       walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>,
                                       accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_S1AccessControls" title="">S1AccessControls</a>
begin

    var r,  w,  x,  gcs,  wxn,   overlay : bit;
    var pr, pw, px, pgcs, pwxn, p_overlay : bit;
    var ur, uw, ux, ugcs, uwxn, u_overlay : bit;
    let permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a> = walkstate.permissions;
    var s1perms : <a href="shared_pseudocode.html#type_S1AccessControls" title="">S1AccessControls</a>;

    // Apply privileged indirect permissions
    case permissions.ppi of
        when '0000' =&gt; (pr,pw,px,pgcs) = ('0','0','0','0'); // No access
        when '0001' =&gt; (pr,pw,px,pgcs) = ('1','0','0','0'); // Privileged read
        when '0010' =&gt; (pr,pw,px,pgcs) = ('0','0','1','0'); // Privileged execute
        when '0011' =&gt; (pr,pw,px,pgcs) = ('1','0','1','0'); // Privileged read and execute
        when '0100' =&gt; (pr,pw,px,pgcs) = ('0','0','0','0'); // Reserved
        when '0101' =&gt; (pr,pw,px,pgcs) = ('1','1','0','0'); // Privileged read and write
        when '0110' =&gt; (pr,pw,px,pgcs) = ('1','1','1','0'); // Privileged read, write and execute
        when '0111' =&gt; (pr,pw,px,pgcs) = ('1','1','1','0'); // Privileged read, write and execute
        when '1000' =&gt; (pr,pw,px,pgcs) = ('1','0','0','0'); // Privileged read
        when '1001' =&gt; (pr,pw,px,pgcs) = ('1','0','0','1'); // Privileged read and gcs
        when '1010' =&gt; (pr,pw,px,pgcs) = ('1','0','1','0'); // Privileged read and execute
        when '1011' =&gt; (pr,pw,px,pgcs) = ('0','0','0','0'); // Reserved
        when '1100' =&gt; (pr,pw,px,pgcs) = ('1','1','0','0'); // Privileged read and write
        when '1101' =&gt; (pr,pw,px,pgcs) = ('0','0','0','0'); // Reserved
        when '1110' =&gt; (pr,pw,px,pgcs) = ('1','1','1','0'); // Privileged read, write and execute
        when '1111' =&gt; (pr,pw,px,pgcs) = ('0','0','0','0'); // Reserved
    end;

    p_overlay = NOT(permissions.ppi[3]);
    pwxn = if permissions.ppi == '0110' then '1' else '0';

    if <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime) then
        // Apply unprivileged indirect permissions
        case permissions.upi of
            when '0000' =&gt; (ur,uw,ux,ugcs) = ('0','0','0','0'); // No access
            when '0001' =&gt; (ur,uw,ux,ugcs) = ('1','0','0','0'); // Unprivileged read
            when '0010' =&gt; (ur,uw,ux,ugcs) = ('0','0','1','0'); // Unprivileged execute
            when '0011' =&gt; (ur,uw,ux,ugcs) = ('1','0','1','0'); // Unprivileged read and execute
            when '0100' =&gt; (ur,uw,ux,ugcs) = ('0','0','0','0'); // Reserved
            when '0101' =&gt; (ur,uw,ux,ugcs)=('1','1','0','0');// Unprivileged read and write
            when '0110' =&gt; (ur,uw,ux,ugcs)=('1','1','1','0');// Unprivileged read, write and execute
            when '0111' =&gt; (ur,uw,ux,ugcs)=('1','1','1','0');// Unprivileged read, write and execute
            when '1000' =&gt; (ur,uw,ux,ugcs)=('1','0','0','0');// Unprivileged read
            when '1001' =&gt; (ur,uw,ux,ugcs)=('1','0','0','1');// Unprivileged read and gcs
            when '1010' =&gt; (ur,uw,ux,ugcs)=('1','0','1','0');// Unprivileged read and execute
            when '1011' =&gt; (ur,uw,ux,ugcs) = ('0','0','0','0');// Reserved
            when '1100' =&gt; (ur,uw,ux,ugcs) =('1','1','0','0');// Unprivileged read and write
            when '1101' =&gt; (ur,uw,ux,ugcs) =('0','0','0','0');// Reserved
            when '1110' =&gt; (ur,uw,ux,ugcs) =('1','1','1','0');// Unprivileged read,write and execute
            when '1111' =&gt; (ur,uw,ux,ugcs) =('0','0','0','0');// Reserved
        end;

        u_overlay = NOT(permissions.upi[3]);
        uwxn = if permissions.upi == '0110' then '1' else '0';

        // If the decoded permissions has either px or pgcs along with either uw or ugcs,
        // then all effective Stage 1 Base Permissions are set to 0
        if ((px == '1' || pgcs == '1') &amp;&amp; (uw == '1' || ugcs == '1')) then
            (pr,pw,px,pgcs) = ('0','0','0','0');
            (ur,uw,ux,ugcs) = ('0','0','0','0');
        end;

        if (IsFeatureImplemented(FEAT_PAN) &amp;&amp; accdesc.pan &amp;&amp; !(regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp;
              walkparams.nv1 == '1')) then
            if PSTATE.PAN == '1' &amp;&amp; (permissions.upi != '0000') then
                (pr,pw) = ('0','0');
            end;
        end;
    end;

    if accdesc.el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        (r,w,x,gcs,wxn,overlay) = (ur,uw,ux,ugcs,uwxn,u_overlay);
    else
        (r,w,x,gcs,wxn,overlay) = (pr,pw,px,pgcs,pwxn,p_overlay);
    end;

    // Prevent execution from Non-secure space by PE in secure state if SIF is set
    if accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> &amp;&amp; walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> then
        x   = x AND NOT(walkparams.sif);
        gcs = '0';
    end;
    // Prevent execution from non-Root space by Root
    if accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> &amp;&amp; walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a> then
        x   = '0';
        gcs = '0';
    end;
    // Prevent execution from non-Realm space by Realm EL2 and Realm EL2&amp;0
    if (accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> &amp;&amp; regime IN {<a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>, <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>} &amp;&amp;
        walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>) then
        x   = '0';
        gcs = '0';
    end;

    s1perms.r       = r;
    s1perms.w       = w;
    s1perms.x       = x;
    s1perms.gcs     = gcs;
    s1perms.wxn     = wxn;
    s1perms.overlay = overlay == '1';

    return s1perms;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S1OAOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S1OAOutOfRange</h3>
      <p class="pseudocode">// AArch64_S1OAOutOfRange()
// ========================
// Returns whether stage 1 output address is expressed in the configured size number of bits

func <a id="func_AArch64_S1OAOutOfRange_2"/>AArch64_S1OAOutOfRange(address : bits(56), walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>) =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_AArch64_OAOutOfRange_5" title="">AArch64_OAOutOfRange</a>(address, walkparams.d128, walkparams.ds, walkparams.ps,
                                walkparams.tgx);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S1OverlayPermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S1OverlayPermissions</h3>
      <p class="pseudocode">// AArch64_S1OverlayPermissions()
// ==============================
// Computes the stage 1 overlay permissions

func <a id="func_AArch64_S1OverlayPermissions_3"/>AArch64_S1OverlayPermissions(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>,
                                  accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_S1AccessControls" title="">S1AccessControls</a>
begin

    var r,  w,  x : bit;
    var pr, pw, px : bit;
    var ur, uw, ux : bit;
    let permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a> = walkstate.permissions;
    var s1overlay_perms : <a href="shared_pseudocode.html#type_S1AccessControls" title="">S1AccessControls</a>;

    let por : S1PORType = <a href="shared_pseudocode.html#func_AArch64_S1POR_1" title="">AArch64_S1POR</a>(regime);
    let bit_index : integer{} = 4 * UInt(permissions.po_index);

    let ppo : bits(4) = por[bit_index+3:bit_index];

    // Apply privileged overlay permissions
    case ppo of
        when '0000' =&gt; (pr,pw,px) = ('0','0','0'); // No access
        when '0001' =&gt; (pr,pw,px) = ('1','0','0'); // Privileged read
        when '0010' =&gt; (pr,pw,px) = ('0','0','1'); // Privileged execute
        when '0011' =&gt; (pr,pw,px) = ('1','0','1'); // Privileged read and execute
        when '0100' =&gt; (pr,pw,px) = ('0','1','0'); // Privileged write
        when '0101' =&gt; (pr,pw,px) = ('1','1','0'); // Privileged read and write
        when '0110' =&gt; (pr,pw,px) = ('0','1','1'); // Privileged write and execute
        when '0111' =&gt; (pr,pw,px) = ('1','1','1'); // Privileged read, write and execute
        when '1xxx' =&gt; (pr,pw,px) = ('0','0','0'); // Reserved
    end;

    if <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime) then
        var upo : bits(4) = '0000';
        if !(<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().PIEn == '0' &amp;&amp;
               ImpDefBool("SCR_EL3.PIEn forces PIE/POE_ELx to zero")) then
            upo = POR_EL0()[bit_index+3:bit_index];
        end;

        // Apply unprivileged overlay permissions
        case upo of
            when '0000' =&gt; (ur,uw,ux) = ('0','0','0'); // No access
            when '0001' =&gt; (ur,uw,ux) = ('1','0','0'); // Unprivileged read
            when '0010' =&gt; (ur,uw,ux) = ('0','0','1'); // Unprivileged execute
            when '0011' =&gt; (ur,uw,ux) = ('1','0','1'); // Unprivileged read and execute
            when '0100' =&gt; (ur,uw,ux) = ('0','1','0'); // Unprivileged write
            when '0101' =&gt; (ur,uw,ux) = ('1','1','0'); // Unprivileged read and write
            when '0110' =&gt; (ur,uw,ux) = ('0','1','1'); // Unprivileged write and execute
            when '0111' =&gt; (ur,uw,ux) = ('1','1','1'); // Unprivileged read, write and execute
            when '1xxx' =&gt; (ur,uw,ux) = ('0','0','0'); // Reserved
        end;
    end;

    (r,w,x) = if accdesc.el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then (ur,uw,ux) else (pr,pw,px);

    s1overlay_perms.or = r;
    s1overlay_perms.ow = w;
    s1overlay_perms.ox = x;

    return s1overlay_perms;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S1TxSZFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S1TxSZFaults</h3>
      <p class="pseudocode">// AArch64_S1TxSZFaults()
// ======================
// Detect whether configuration of stage 1 TxSZ field generates a fault

func <a id="func_AArch64_S1TxSZFaults_2"/>AArch64_S1TxSZFaults(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>) =&gt; boolean
begin
    let mintxsz : integer = <a href="shared_pseudocode.html#func_AArch64_S1MinTxSZ_2" title="">AArch64_S1MinTxSZ</a>(regime, walkparams);
    let maxtxsz : integer = <a href="shared_pseudocode.html#func_AArch64_MaxTxSZ_1" title="">AArch64_MaxTxSZ</a>(walkparams.tgx);

    if UInt(walkparams.txsz) &lt; mintxsz then
        return (IsFeatureImplemented(FEAT_LVA) ||
                ImpDefBool("Fault on TxSZ value below minimum"));
    end;
    if UInt(walkparams.txsz) &gt; maxtxsz then
        return ImpDefBool("Fault on TxSZ value above maximum");
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S2CheckPermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S2CheckPermissions</h3>
      <p class="pseudocode">// AArch64_S2CheckPermissions()
// ============================
// Verifies memory access with available permissions.

func AArch64_S2CheckPermissions(fault_in : FaultRecord, walkstate : TTWState,
                                walkparams : S2TTWParams, ipa : AddressDescriptor,
                                accdesc : AccessDescriptor) =&gt; (FaultRecord, boolean)
begin
    let memtype : <a href="shared_pseudocode.html#MemType" title="type MemType">MemType</a> = walkstate.memattrs.memtype;
    let permissions : Permissions = walkstate.permissions;
    var fault : FaultRecord = fault_in;
    let s2perms : S2AccessControls = AArch64_S2ComputePermissions(permissions, walkparams,
                                                                   accdesc);

    var r,  w : bit;
    var or, ow : bit;

    if accdesc.acctype == AccessType_TTW then
        r = s2perms.r_mmu;
        w = s2perms.w_mmu;
        or = s2perms.or_mmu;
        ow = s2perms.ow_mmu;
    elsif accdesc.rcw then
        r = s2perms.r_rcw;
        w = s2perms.w_rcw;
        or = s2perms.or_rcw;
        ow = s2perms.ow_rcw;
    else
        r = s2perms.r;
        w = s2perms.w;
        or = s2perms.or;
        ow = s2perms.ow;
    end;

    if accdesc.acctype == AccessType_TTW then
        if (accdesc.toplevel &amp;&amp; accdesc.varange == VARange_LOWER &amp;&amp;
              ((walkparams.tl0 == '1' &amp;&amp; s2perms.toplevel0 == '0') ||
              (walkparams.tl1 == '1' &amp;&amp; s2perms.[toplevel1,toplevel0] == '10'))) then
            fault.statuscode = Fault_Permission;
            fault.toplevel   = TRUE;
        elsif (accdesc.toplevel &amp;&amp; accdesc.varange == VARange_UPPER &amp;&amp;
                ((walkparams.tl1 == '1' &amp;&amp; s2perms.toplevel1 == '0') ||
                (walkparams.tl0 == '1' &amp;&amp; s2perms.[toplevel1,toplevel0] == '01'))) then
            fault.statuscode = Fault_Permission;
            fault.toplevel   = TRUE;
        // Stage 2 Permission fault due to AssuredOnly check
        elsif (walkstate.s2assuredonly == '1' &amp;&amp; !ipa.s1assured) then
                fault.statuscode  = Fault_Permission;
                fault.assuredonly = TRUE;

        elsif s2perms.overlay &amp;&amp; or == '0' then
            fault.statuscode = Fault_Permission;
            fault.overlay    = TRUE;
        elsif accdesc.write &amp;&amp; s2perms.overlay &amp;&amp; ow == '0' then
            fault.statuscode = Fault_Permission;
            fault.overlay    = TRUE;

        elsif walkparams.ptw == '1' &amp;&amp; memtype == MemType_Device then
            fault.statuscode = Fault_Permission;
        // Prevent translation table walks in Non-secure space by Realm state
        elsif accdesc.ss == SS_Realm &amp;&amp; walkstate.baseaddress.paspace != PAS_Realm then
            fault.statuscode = Fault_Permission;
        elsif r == '0' then
            fault.statuscode = Fault_Permission;
        elsif accdesc.write &amp;&amp; w == '0' then
            fault.statuscode = Fault_Permission;
            fault.hdbssf = walkparams.hdbss == '1' &amp;&amp; !CanAppendToHDBSS() &amp;&amp; permissions.dbm == '1';
        elsif (accdesc.write &amp;&amp;
                 (walkparams.hd != '1' || (walkparams.hdbss == '1' &amp;&amp; !CanAppendToHDBSS())) &amp;&amp;
                  walkparams.s2pie == '1' &amp;&amp; permissions.s2dirty == '0') then
            fault.statuscode = Fault_Permission;
            fault.dirtybit   = TRUE;
            fault.hdbssf = walkparams.hdbss == '1' &amp;&amp; !CanAppendToHDBSS();

        end;

    // Stage 2 Permission fault due to AssuredOnly check
    elsif ((walkstate.s2assuredonly == '1' &amp;&amp; !ipa.s1assured) ||
            (walkstate.s2assuredonly != '1' &amp;&amp; IsFeatureImplemented(FEAT_GCS) &amp;&amp;
             VTCR_EL2().GCSH == '1' &amp;&amp; accdesc.acctype == AccessType_GCS &amp;&amp; accdesc.el != EL0)) then
        fault.statuscode  = Fault_Permission;
        fault.assuredonly = TRUE;

    elsif accdesc.acctype == AccessType_IFETCH then
        if s2perms.overlay &amp;&amp; s2perms.ox == '0' then
            fault.statuscode = Fault_Permission;
            fault.overlay    = TRUE;
        elsif (memtype == MemType_Device &amp;&amp;
              ConstrainUnpredictable(Unpredictable_INSTRDEVICE) == Constraint_FAULT) then
            fault.statuscode = Fault_Permission;

        // Prevent execution from Non-secure space by Realm state
        elsif accdesc.ss == SS_Realm &amp;&amp; walkstate.baseaddress.paspace != PAS_Realm then
            fault.statuscode = Fault_Permission;
        elsif s2perms.x == '0' then
            fault.statuscode = Fault_Permission;
        end;

    elsif accdesc.acctype == AccessType_DC then
        if accdesc.cacheop == CacheOp_Invalidate then
            if !ELUsingAArch32(EL1) &amp;&amp; s2perms.overlay &amp;&amp; ow == '0' then
                fault.statuscode = Fault_Permission;
                fault.overlay    = TRUE;
            elsif !ELUsingAArch32(EL1) &amp;&amp; w == '0' then
                fault.statuscode = Fault_Permission;
            elsif (walkparams.hd != '1' &amp;&amp; walkparams.s2pie == '1' &amp;&amp;
                     permissions.s2dirty == '0') then
                fault.statuscode = Fault_Permission;
                fault.dirtybit   = TRUE;
            end;
        elsif !ELUsingAArch32(EL1) &amp;&amp; accdesc.el == EL0 &amp;&amp; s2perms.overlay &amp;&amp; or == '0' then
            fault.statuscode = Fault_Permission;
            fault.overlay    = TRUE;
        elsif (walkparams.cmow == '1' &amp;&amp; accdesc.cacheop == CacheOp_CleanInvalidate &amp;&amp;
                s2perms.overlay &amp;&amp; ow == '0') then
            fault.statuscode = Fault_Permission;
            fault.overlay    = TRUE;
        elsif !ELUsingAArch32(EL1) &amp;&amp; accdesc.el == EL0 &amp;&amp; r == '0' then
            fault.statuscode = Fault_Permission;
        elsif (walkparams.cmow == '1' &amp;&amp; accdesc.cacheop == CacheOp_CleanInvalidate &amp;&amp;
                w == '0') then
            fault.statuscode = Fault_Permission;
        elsif (walkparams.cmow == '1' &amp;&amp; accdesc.cacheop == CacheOp_CleanInvalidate &amp;&amp;
                 walkparams.hd != '1' &amp;&amp; walkparams.s2pie == '1' &amp;&amp; permissions.s2dirty == '0') then
            fault.statuscode = Fault_Permission;
            fault.dirtybit   = TRUE;
        end;

    elsif accdesc.acctype == AccessType_IC then
        if (!ELUsingAArch32(EL1) &amp;&amp; accdesc.el == EL0 &amp;&amp; s2perms.overlay &amp;&amp; or == '0' &amp;&amp;
                ImpDefBool("Permission fault on EL0 IC_IVAU execution")) then
            fault.statuscode = Fault_Permission;
            fault.overlay    = TRUE;
        elsif walkparams.cmow == '1' &amp;&amp; s2perms.overlay &amp;&amp; ow == '0' then
            fault.statuscode = Fault_Permission;
            fault.overlay    = TRUE;
        elsif (!ELUsingAArch32(EL1) &amp;&amp; accdesc.el == EL0 &amp;&amp;  r == '0' &amp;&amp;
              ImpDefBool("Permission fault on EL0 IC_IVAU execution")) then
            fault.statuscode = Fault_Permission;
        elsif walkparams.cmow == '1' &amp;&amp; w == '0' then
            fault.statuscode = Fault_Permission;
        elsif (walkparams.cmow == '1' &amp;&amp; walkparams.hd != '1' &amp;&amp; walkparams.s2pie == '1' &amp;&amp;
                 permissions.s2dirty == '0') then
            fault.statuscode = Fault_Permission;
            fault.dirtybit   = TRUE;
        end;

    elsif accdesc.read &amp;&amp; s2perms.overlay &amp;&amp; or == '0' then
        fault.statuscode = Fault_Permission;
        fault.overlay    = TRUE;
        fault.write      = FALSE;
    elsif accdesc.write &amp;&amp; s2perms.overlay &amp;&amp; ow == '0' then
        fault.statuscode = Fault_Permission;
        fault.overlay    = TRUE;
        fault.write      = TRUE;
    elsif accdesc.read &amp;&amp; r == '0' then
        fault.statuscode = Fault_Permission;
        fault.write      = FALSE;
    elsif accdesc.write &amp;&amp; w == '0' then
        fault.statuscode = Fault_Permission;
        fault.write      = TRUE;
        fault.hdbssf = walkparams.hdbss == '1' &amp;&amp; !CanAppendToHDBSS() &amp;&amp; permissions.dbm == '1';
    elsif (IsFeatureImplemented(FEAT_MTE_PERM) &amp;&amp;
             ((accdesc.tagchecked &amp;&amp;
               AArch64_EffectiveTCF(accdesc.el, accdesc.read) != TCFType_Ignore) ||
              accdesc.tagaccess) &amp;&amp;
             ipa.memattrs.tags == MemTag_AllocationTagged &amp;&amp;
             permissions.s2tag_na == '1' &amp;&amp; S2DCacheEnabled()) then
        fault.statuscode = Fault_Permission;
        fault.tagaccess  = TRUE;
        fault.write      = accdesc.tagaccess &amp;&amp; accdesc.write;
    elsif (accdesc.write &amp;&amp;
             (walkparams.hd != '1' || (walkparams.hdbss == '1' &amp;&amp; !CanAppendToHDBSS())) &amp;&amp;
              walkparams.s2pie == '1' &amp;&amp; permissions.s2dirty == '0') then
        fault.statuscode = Fault_Permission;
        fault.dirtybit   = TRUE;
        fault.write      = TRUE;
        fault.hdbssf     = walkparams.hdbss == '1' &amp;&amp; !CanAppendToHDBSS();
    end;
    // MRO* allows only RCW and MMU writes
    var mro : boolean;
    if s2perms.overlay then
        mro = (s2perms.[w,w_rcw,w_mmu] AND s2perms.[ow,ow_rcw,ow_mmu]) == '011';
    else
        mro = s2perms.[w,w_rcw,w_mmu] == '011';
    end;

    return (fault, mro);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S2ComputePermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S2ComputePermissions</h3>
      <p class="pseudocode">// AArch64_S2ComputePermissions()
// ==============================
// Compute the overall stage 2 permissions.

func <a id="func_AArch64_S2ComputePermissions_3"/>AArch64_S2ComputePermissions(permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a>, walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>,
                                  accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_S2AccessControls" title="">S2AccessControls</a>
begin

    var s2perms : <a href="shared_pseudocode.html#type_S2AccessControls" title="">S2AccessControls</a>;

    if walkparams.s2pie == '1' then
        s2perms = <a href="shared_pseudocode.html#func_AArch64_S2IndirectBasePermissions_2" title="">AArch64_S2IndirectBasePermissions</a>(permissions, accdesc);
        s2perms.overlay = IsFeatureImplemented(FEAT_S2POE) &amp;&amp; VTCR_EL2().S2POE == '1';
        if s2perms.overlay then
            let s2overlay_perms : <a href="shared_pseudocode.html#type_S2AccessControls" title="">S2AccessControls</a> = <a href="shared_pseudocode.html#func_AArch64_S2OverlayPermissions_2" title="">AArch64_S2OverlayPermissions</a>(permissions,
                                                                                  accdesc);
            s2perms.or          = s2overlay_perms.or;
            s2perms.ow          = s2overlay_perms.ow;
            s2perms.ox          = s2overlay_perms.ox;
            s2perms.or_rcw      = s2overlay_perms.or_rcw;
            s2perms.ow_rcw      = s2overlay_perms.ow_rcw;
            s2perms.or_mmu      = s2overlay_perms.or_mmu;
            s2perms.ow_mmu      = s2overlay_perms.ow_mmu;

            // Toplevel is applicable only when the effective S2 permissions is MRO
            if ((s2perms.[w,w_rcw,w_mmu] AND s2perms.[ow,ow_rcw,ow_mmu]) == '011') then
                s2perms.toplevel0 = s2perms.toplevel0 OR s2overlay_perms.toplevel0;
                s2perms.toplevel1 = s2perms.toplevel1 OR s2overlay_perms.toplevel1;

            else
                s2perms.toplevel0 = '0';
                s2perms.toplevel1 = '0';
            end;
        end;
    else
        s2perms = <a href="shared_pseudocode.html#func_AArch64_S2DirectBasePermissions_3" title="">AArch64_S2DirectBasePermissions</a>(permissions, accdesc, walkparams);
    end;

    return s2perms;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S2DirectBasePermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S2DirectBasePermissions</h3>
      <p class="pseudocode">// AArch64_S2DirectBasePermissions()
// =================================
// Computes the stage 2 direct base permissions.

func <a id="func_AArch64_S2DirectBasePermissions_3"/>AArch64_S2DirectBasePermissions(permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a>,
                                     accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                     walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>) =&gt; <a href="shared_pseudocode.html#type_S2AccessControls" title="">S2AccessControls</a>
begin
    var s2perms : <a href="shared_pseudocode.html#type_S2AccessControls" title="">S2AccessControls</a>;
    var w : bit;
    let r : bit = permissions.s2ap[0];
    if permissions.s2ap[1] == '1' then
        w = '1';
    // Descriptors marked with DBM set have the effective value of S2AP[1] set.
    // This implies no Permission faults caused by lack of write permissions are
    // reported, and the Dirty bit can be set.
    elsif permissions.dbm == '1' &amp;&amp; walkparams.hd == '1' then
        // An update occurs here, conditional to being able to append to HDBSS
        if walkparams.hdbss == '1' then
            w = if <a href="shared_pseudocode.html#func_CanAppendToHDBSS_0" title="">CanAppendToHDBSS</a>() then '1' else '0';
        else
            w = '1';
        end;
    else
        w = '0';
    end;

    var px, ux : bit;
    case (permissions.s2xn::permissions.s2xnx) of
        when '00' =&gt; (px,ux) = ('1','1');
        when '01' =&gt; (px,ux) = ('0','1');
        when '10' =&gt; (px,ux) = ('0','0');
        when '11' =&gt; (px,ux) = ('1','0');
    end;

    let x : bit = if accdesc.el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then ux else px;
    s2perms.r = r;
    s2perms.w = w;
    s2perms.x = x;
    s2perms.r_rcw = r;
    s2perms.w_rcw = w;
    s2perms.r_mmu = r;
    s2perms.w_mmu = w;
    s2perms.toplevel0 = '0';
    s2perms.toplevel1 = '0';
    s2perms.overlay = FALSE;

    return s2perms;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S2HasAlignmentFaultDueToMemType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S2HasAlignmentFaultDueToMemType</h3>
      <p class="pseudocode">// AArch64_S2HasAlignmentFaultDueToMemType()
// =========================================
// Returns whether stage 2 output fails alignment requirement on data accesses due to memory type

func <a id="func_AArch64_S2HasAlignmentFaultDueToMemType_3"/>AArch64_S2HasAlignmentFaultDueToMemType(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, aligned : boolean,
                                             memattrs : MemoryAttributes) =&gt; boolean
begin

    if accdesc.exclusive || accdesc.atomicop || accdesc.acqsc || accdesc.acqpc || accdesc.relsc then
        if (!aligned &amp;&amp; !(<a href="shared_pseudocode.html#func_IsWBShareable_1" title="">IsWBShareable</a>(memattrs) &amp;&amp; <a href="shared_pseudocode.html#func_S2DCacheEnabled_0" title="">S2DCacheEnabled</a>()) &amp;&amp;
                <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_LSE2_ALIGNMENT_FAULT" title="">Unpredictable_LSE2_ALIGNMENT_FAULT</a>)) then
            return TRUE;
        end;
    end;

    if memattrs.memtype != MemType_Device then
        return FALSE;
    elsif ((accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_DCZero" title="">AccessType_DCZero</a> &amp;&amp; accdesc.cachetype == <a href="shared_pseudocode.html#enum_CacheType_Tag" title="">CacheType_Tag</a>) ||
             accdesc.stzgm) then
        return ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_DEVICETAGSTORE" title="">Unpredictable_DEVICETAGSTORE</a>) == <a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a>;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_DCZero" title="">AccessType_DCZero</a> then
        return TRUE;
    elsif !aligned then
        return !(ImpDefBool("Device location supports unaligned access"));
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S2InconsistentSL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S2InconsistentSL</h3>
      <p class="pseudocode">// AArch64_S2InconsistentSL()
// ==========================
// Detect inconsistent configuration of stage 2 TxSZ and SL fields

func AArch64_S2InconsistentSL(walkparams : S2TTWParams) =&gt; boolean
begin
    let startlevel : integer      = AArch64_S2StartLevel(walkparams);
    let levels : integer          = FINAL_LEVEL - startlevel;
    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = TGxGranuleBits(walkparams.tgx);
    let descsizelog2 : integer{}  = 3;
    let stride : integer{}        = granulebits - descsizelog2;

    // Input address size must at least be large enough to be resolved from the start level
    let sl_min_iasize : integer = (
        levels * stride // Bits resolved by table walk, except initial level
        + granulebits   // Bits directly mapped to output address
        + 1);           // At least 1 more bit to be decoded by initial level

    // Can accomodate 1 more stride in the level + concatenation of up to 2^4 tables
    let sl_max_iasize : integer = sl_min_iasize + (stride-1) + 4;
    // Configured Input Address size
    let iasize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>    = AArch64_IASize(walkparams.txsz);

    return iasize &lt; sl_min_iasize || iasize &gt; sl_max_iasize;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S2IndirectBasePermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S2IndirectBasePermissions</h3>
      <p class="pseudocode">// AArch64_S2IndirectBasePermissions()
// ===================================
// Computes the stage 2 indirect base permissions.

func <a id="func_AArch64_S2IndirectBasePermissions_2"/>AArch64_S2IndirectBasePermissions(permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a>,
                                       accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_S2AccessControls" title="">S2AccessControls</a>
begin
    var r, w : bit;
    var r_rcw, w_rcw : bit;
    var r_mmu, w_mmu : bit;
    var px, ux : bit;
    var toplevel0, toplevel1 : bit;
    var s2perms : <a href="shared_pseudocode.html#type_S2AccessControls" title="">S2AccessControls</a>;

    let s2pi : bits(4) = permissions.s2pi;
    case s2pi of
        when '0000' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('0','0','0','0','0','0');  // No Access
        when '0001' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('0','0','0','0','0','0');  // Reserved
        when '0010' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO
        when '0011' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO-TL1
        when '0100' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('0','1','0','0','0','0');  // Write Only
        when '0101' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('0','0','0','0','0','0');  // Reserved
        when '0110' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO-TL0
        when '0111' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO-TL01
        when '1000' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','0','0');  // Read Only
        when '1001' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','1','0','0');  // Read, Unpriv Execute
        when '1010' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','1','0','0','0');  // Read, Priv Execute
        when '1011' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','1','1','0','0');  // Read, All Execute
        when '1100' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','1','0','0','1','1');  // RW
        when '1101' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','1','0','1','1','1');  // RW, Unpriv Execute
        when '1110' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','1','1','0','1','1');  // RW, Priv Execute
        when '1111' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','1','1','1','1','1');  // RW, All Execute
    end;

    let x : bit = if accdesc.el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then ux else px;

    // RCW and MMU read permissions.
    (r_rcw, r_mmu) = (r, r);

    // Stage 2 Top Level Permission Attributes.
    case s2pi of
        when '0110' =&gt; (toplevel0,toplevel1) = ('1','0');
        when '0011' =&gt; (toplevel0,toplevel1) = ('0','1');
        when '0111' =&gt; (toplevel0,toplevel1) = ('1','1');
        otherwise =&gt;   (toplevel0,toplevel1) = ('0','0');
    end;

    s2perms.r = r;
    s2perms.w = w;
    s2perms.x = x;
    s2perms.r_rcw = r_rcw;
    s2perms.r_mmu = r_mmu;
    s2perms.w_rcw = w_rcw;
    s2perms.w_mmu = w_mmu;
    s2perms.toplevel0 = toplevel0;
    s2perms.toplevel1 = toplevel1;

    return s2perms;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S2InvalidSL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S2InvalidSL</h3>
      <p class="pseudocode">// AArch64_S2InvalidSL()
// =====================
// Detect invalid configuration of SL field

func <a id="func_AArch64_S2InvalidSL_1"/>AArch64_S2InvalidSL(walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>) =&gt; boolean
begin
    case walkparams.tgx of
        when <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a> =&gt;
            case walkparams.sl2::walkparams.sl0 of
                when '1x1' =&gt; return TRUE;
                when '11x' =&gt; return TRUE;
                when '100' =&gt; return AArch64_PAMax() &lt; 52;
                when '010' =&gt; return AArch64_PAMax() &lt; 44;
                when '011' =&gt; return !IsFeatureImplemented(FEAT_TTST);
                otherwise  =&gt;  return FALSE;
            end;
        when <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a> =&gt;
            case walkparams.sl0 of
                when '11' =&gt; return walkparams.ds == '0' || AArch64_PAMax() &lt; 52;
                when '10' =&gt; return AArch64_PAMax() &lt; 42;
                otherwise =&gt;  return FALSE;
            end;
        when <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> =&gt;
            case walkparams.sl0 of
                when '11' =&gt;  return TRUE;
                when '10' =&gt;  return AArch64_PAMax() &lt; 44;
                otherwise =&gt;  return FALSE;
            end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S2OAOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S2OAOutOfRange</h3>
      <p class="pseudocode">// AArch64_S2OAOutOfRange()
// ========================
// Returns whether stage 2 output address is expressed in the configured size number of bits

func <a id="func_AArch64_S2OAOutOfRange_2"/>AArch64_S2OAOutOfRange(address : bits(56), walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>) =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_AArch64_OAOutOfRange_5" title="">AArch64_OAOutOfRange</a>(address, walkparams.d128, walkparams.ds, walkparams.ps,
                                walkparams.tgx);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S2OverlayPermissions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S2OverlayPermissions</h3>
      <p class="pseudocode">// AArch64_S2OverlayPermissions()
// ==============================
// Computes the stage 2 overlay permissions.

func <a id="func_AArch64_S2OverlayPermissions_2"/>AArch64_S2OverlayPermissions(permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a>,
                                  accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_S2AccessControls" title="">S2AccessControls</a>
begin
    var r, w : bit;
    var r_rcw, w_rcw : bit;
    var r_mmu, w_mmu : bit;
    var px, ux : bit;
    var toplevel0, toplevel1 : bit;
    var s2overlay_perms : <a href="shared_pseudocode.html#type_S2AccessControls" title="">S2AccessControls</a>;

    let index : integer{} = 4 * UInt(permissions.s2po_index);
    var s2po : bits(4) = '0000';
    if !(<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().PIEn == '0' &amp;&amp;
          ImpDefBool("SCR_EL3.PIEn forces PIE/POE_ELx to zero")) then
        s2po = S2POR_EL1()[index+3:index];
    end;
    case s2po of
        when '0000' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('0','0','0','0','0','0');  // No Access
        when '0001' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('0','0','0','0','0','0');  // Reserved
        when '0010' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO
        when '0011' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO-TL1
        when '0100' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('0','1','0','0','0','0');  // Write Only
        when '0101' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('0','0','0','0','0','0');  // Reserved
        when '0110' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO-TL0
        when '0111' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','1','1');  // MRO-TL01
        when '1000' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','0','0','0');  // Read Only
        when '1001' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','0','1','0','0');  // Read, Unpriv Execute
        when '1010' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','1','0','0','0');  // Read, Priv Execute
        when '1011' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','0','1','1','0','0');  // Read, All Execute
        when '1100' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','1','0','0','1','1');  // RW
        when '1101' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','1','0','1','1','1');  // RW, Unpriv Execute
        when '1110' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','1','1','0','1','1');  // RW, Priv Execute
        when '1111' =&gt; (r,w,px,ux,w_rcw,w_mmu) = ('1','1','1','1','1','1');  // RW, All Execute
    end;

    let x : bit = if accdesc.el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then ux else px;

    // RCW and MMU read permissions.
    (r_rcw, r_mmu) = (r, r);

    // Stage 2 Top Level Permission Attributes.
    case s2po of
        when '0110' =&gt; (toplevel0,toplevel1) = ('1','0');
        when '0011' =&gt; (toplevel0,toplevel1) = ('0','1');
        when '0111' =&gt; (toplevel0,toplevel1) = ('1','1');
        otherwise =&gt;   (toplevel0,toplevel1) = ('0','0');
    end;

    s2overlay_perms.or = r;
    s2overlay_perms.ow = w;
    s2overlay_perms.ox = x;
    s2overlay_perms.or_rcw = r_rcw;
    s2overlay_perms.ow_rcw = w_rcw;
    s2overlay_perms.or_mmu = r_mmu;
    s2overlay_perms.ow_mmu = w_mmu;
    s2overlay_perms.toplevel0 = toplevel0;
    s2overlay_perms.toplevel1 = toplevel1;

    return s2overlay_perms;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_S2TxSZFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_S2TxSZFaults</h3>
      <p class="pseudocode">// AArch64_S2TxSZFaults()
// ======================
// Detect whether configuration of stage 2 TxSZ field generates a fault

func <a id="func_AArch64_S2TxSZFaults_2"/>AArch64_S2TxSZFaults(walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>, s1aarch64 : boolean) =&gt; boolean
begin
    let mintxsz : integer = <a href="shared_pseudocode.html#func_AArch64_S2MinTxSZ_2" title="">AArch64_S2MinTxSZ</a>(walkparams, s1aarch64);
    let maxtxsz : integer = <a href="shared_pseudocode.html#func_AArch64_MaxTxSZ_1" title="">AArch64_MaxTxSZ</a>(walkparams.tgx);

    if UInt(walkparams.txsz) &lt; mintxsz then
        return (IsFeatureImplemented(FEAT_LPA) ||
                ImpDefBool("Fault on TxSZ value below minimum"));
    end;
    if UInt(walkparams.txsz) &gt; maxtxsz then
        return ImpDefBool("Fault on TxSZ value above maximum");
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64_VAIsOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64_VAIsOutOfRange</h3>
      <p class="pseudocode">// AArch64_VAIsOutOfRange()
// ========================
// Check bits not resolved by translation are identical and of accepted value

func AArch64_VAIsOutOfRange(va_in : bits(64), acctype : AccessType,
                            regime : Regime, walkparams : S1TTWParams) =&gt; boolean
begin
    var va : bits(64) = va_in;

    let addrtop : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = AArch64_AddrTop(walkparams.tbid, acctype, walkparams.tbi);

    // If the VA has a Logical Address Tag then the bits holding the Logical Address Tag are
    // ignored when checking if the address is out of range.
    if walkparams.mtx == '1' &amp;&amp; acctype != AccessType_IFETCH then
        va[59:56] = if AArch64_GetVARange(va) == VARange_UPPER then '1111' else '0000';
    end;

    // Input Address size
    let iasize : integer{} = AArch64_IASize(walkparams.txsz);

    // The min value of TxSZ can be 8, with LVA3 implemented.
    // If TxSZ is set to 8 iasize becomes 64 - 8 = 56
    // If tbi is also set, addrtop becomes 55
    // Then the return statements check va[56:55]
    // The check here is to guard against this corner case.
    if addrtop &lt; iasize then
        return FALSE;
    end;

    if HasUnprivileged(regime) then
        if AArch64_GetVARange(va) == VARange_LOWER then
            return !IsZero(va[addrtop:iasize]);
        else
            return !IsOnes(va[addrtop:iasize]);
        end;
    else
        return !IsZero(va[addrtop:iasize]);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_memattr.AArch64_S2ApplyFWBMemAttrs"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_memattr/AArch64_S2ApplyFWBMemAttrs</h3>
      <p class="pseudocode">// AArch64_S2ApplyFWBMemAttrs()
// ============================
// Apply stage 2 forced Write-Back on stage 1 memory attributes.

func <a id="func_AArch64_S2ApplyFWBMemAttrs_4"/>AArch64_S2ApplyFWBMemAttrs{N}(s1_memattrs : MemoryAttributes, walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>,
                                   descriptor : bits(N)) =&gt; MemoryAttributes
begin
    var memattrs : MemoryAttributes;
    let s2_attr : bits(4) = descriptor[5:2];
    let s2_sh : bits(2)   = if walkparams.ds == '1' then walkparams.sh else descriptor[9:8];
    let s2_fnxs : bit     = descriptor[11];

    if s2_attr[2] == '0' then          // S2 Device, S1 any
        let s2_device : <a href="shared_pseudocode.html#type_DeviceType" title="">DeviceType</a> = <a href="shared_pseudocode.html#func_DecodeDevice_1" title="">DecodeDevice</a>(s2_attr[1:0]);
        memattrs.memtype = MemType_Device;
        if s1_memattrs.memtype == MemType_Device then
            memattrs.device = <a href="shared_pseudocode.html#func_S2CombineS1Device_2" title="">S2CombineS1Device</a>(s1_memattrs.device, s2_device);
        else
            memattrs.device = s2_device;
        end;

        memattrs.xs = s1_memattrs.xs;

    elsif s2_attr[1:0] == '11' then    // S2 attr = S1 attr
        memattrs = s1_memattrs;

    elsif s2_attr[1:0] == '10' then    // Force writeback
        memattrs.memtype = MemType_Normal;
        memattrs.inner.attrs = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;
        memattrs.outer.attrs = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;

        if (s1_memattrs.memtype == MemType_Normal &amp;&amp;
                s1_memattrs.inner.attrs != <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>) then
            memattrs.inner.hints     = s1_memattrs.inner.hints;
            memattrs.inner.transient = s1_memattrs.inner.transient;
        else
            memattrs.inner.hints     = <a href="shared_pseudocode.html#global_MemHint_RWA" title="">MemHint_RWA</a>;
            memattrs.inner.transient = FALSE;
        end;

        if (s1_memattrs.memtype == MemType_Normal &amp;&amp;
                s1_memattrs.outer.attrs != <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>) then
            memattrs.outer.hints     = s1_memattrs.outer.hints;
            memattrs.outer.transient = s1_memattrs.outer.transient;
        else
            memattrs.outer.hints     = <a href="shared_pseudocode.html#global_MemHint_RWA" title="">MemHint_RWA</a>;
            memattrs.outer.transient = FALSE;
        end;

        memattrs.xs = '0';

    else                               // Non-cacheable unless S1 is device
        if s1_memattrs.memtype == MemType_Device then
            memattrs = s1_memattrs;
        else
            var cacheability_attr : <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a>;
            cacheability_attr.attrs = <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>;

            memattrs.memtype = MemType_Normal;
            memattrs.inner   = cacheability_attr;
            memattrs.outer   = cacheability_attr;

            memattrs.xs = s1_memattrs.xs;
        end;
    end;

    let s2_shareability : <a href="shared_pseudocode.html#type_Shareability" title="">Shareability</a> = <a href="shared_pseudocode.html#func_DecodeShareability_1" title="">DecodeShareability</a>(s2_sh);
    memattrs.shareability = <a href="shared_pseudocode.html#func_S2CombineS1Shareability_2" title="">S2CombineS1Shareability</a>(s1_memattrs.shareability, s2_shareability);
    memattrs.tags         = <a href="shared_pseudocode.html#func_S2MemTagType_2" title="">S2MemTagType</a>(memattrs, s1_memattrs.tags);
    memattrs.notagaccess  = (s2_attr[3:1] == '111' &amp;&amp; memattrs.tags == <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a>);

    if s2_fnxs == '1' then
        memattrs.xs = '0';
    end;

    memattrs.shareability = <a href="shared_pseudocode.html#func_EffectiveShareability_1" title="">EffectiveShareability</a>(memattrs);
    return memattrs;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64_GetS1TLBContext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64_GetS1TLBContext</h3>
      <p class="pseudocode">// AArch64_GetS1TLBContext()
// =========================
// Gather translation context for accesses with VA to match against TLB entries

func <a id="func_AArch64_GetS1TLBContext_4"/>AArch64_GetS1TLBContext(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>,
                             va : bits(64), tg : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>) =&gt; <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>
begin
    var tlbcontext : <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>;

    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> =&gt;  tlbcontext = <a href="shared_pseudocode.html#func_AArch64_TLBContextEL3_3" title="">AArch64_TLBContextEL3</a>(ss, va, tg);
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;  tlbcontext = <a href="shared_pseudocode.html#func_AArch64_TLBContextEL2_3" title="">AArch64_TLBContextEL2</a>(ss, va, tg);
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt; tlbcontext = <a href="shared_pseudocode.html#func_AArch64_TLBContextEL20_3" title="">AArch64_TLBContextEL20</a>(ss, va, tg);
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; tlbcontext = <a href="shared_pseudocode.html#func_AArch64_TLBContextEL10_3" title="">AArch64_TLBContextEL10</a>(ss, va, tg);
        otherwise =&gt;
            unreachable;

    end;

    tlbcontext.includes_s1  = TRUE;
    // The following may be amended for EL1&amp;0 Regime if caching of stage 2 is successful
    tlbcontext.includes_s2  = FALSE;
    tlbcontext.use_vmid     = <a href="shared_pseudocode.html#func_UseVMID_1" title="">UseVMID</a>(regime);
    // The following may be amended if Granule Protection Check passes
    tlbcontext.includes_gpt = FALSE;
    return tlbcontext;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64_GetS2TLBContext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64_GetS2TLBContext</h3>
      <p class="pseudocode">// AArch64_GetS2TLBContext()
// =========================
// Gather translation context for accesses with IPA to match against TLB entries

func <a id="func_AArch64_GetS2TLBContext_3"/>AArch64_GetS2TLBContext(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, ipa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>, tg : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>) =&gt; <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>
begin
    assert <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();

    var tlbcontext : <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>;

    tlbcontext.ss       = ss;
    tlbcontext.regime   = <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>;
    tlbcontext.ipaspace = ipa.paspace;
    tlbcontext.vmid     = <a href="shared_pseudocode.html#func_VMID_0" title="">VMID</a>();
    tlbcontext.tg       = tg;
    tlbcontext.ia       = ZeroExtend{64}(ipa.address);
    if IsFeatureImplemented(FEAT_TTCNP) then
        tlbcontext.cnp = if ipa.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then VSTTBR_EL2().CnP else VTTBR_EL2().CnP;
    else
        tlbcontext.cnp = '0';
    end;

    tlbcontext.includes_s1  = FALSE;
    tlbcontext.includes_s2  = TRUE;
    tlbcontext.use_vmid     = TRUE;
    // This amy be amended if Granule Protection Check passes
    tlbcontext.includes_gpt = FALSE;
    return tlbcontext;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64_TLBContextEL10"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64_TLBContextEL10</h3>
      <p class="pseudocode">// AArch64_TLBContextEL10()
// ========================
// Gather translation context for accesses under EL10 regime to match against TLB entries

func <a id="func_AArch64_TLBContextEL10_3"/>AArch64_TLBContextEL10(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, va : bits(64), tg : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>) =&gt; <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>
begin
    var tlbcontext : <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>;
    tlbcontext.vmid   = <a href="shared_pseudocode.html#func_VMID_0" title="">VMID</a>();

    if IsFeatureImplemented(FEAT_ASID2) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() &amp;&amp; TCR2_EL1().A2 == '1' then
        let varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a> = <a href="shared_pseudocode.html#func_AArch64_GetVARange_1" title="">AArch64_GetVARange</a>(va);
        tlbcontext.asid = if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then TTBR0_EL1().ASID else TTBR1_EL1().ASID;
    else
        tlbcontext.asid = if TCR_EL1().A1 == '0' then TTBR0_EL1().ASID else TTBR1_EL1().ASID;
    end;

    if TCR_EL1().AS == '0' then
        tlbcontext.asid[15:8] = Zeros{8};
    end;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;

    if IsFeatureImplemented(FEAT_TTCNP) then
        if <a href="shared_pseudocode.html#func_AArch64_GetVARange_1" title="">AArch64_GetVARange</a>(va) == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then
            tlbcontext.cnp = TTBR0_EL1().CnP;
        else
            tlbcontext.cnp = TTBR1_EL1().CnP;
        end;
    else
        tlbcontext.cnp = '0';
    end;

    return tlbcontext;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64_TLBContextEL2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64_TLBContextEL2</h3>
      <p class="pseudocode">// AArch64_TLBContextEL2()
// =======================
// Gather translation context for accesses under EL2 regime to match against TLB entries

func <a id="func_AArch64_TLBContextEL2_3"/>AArch64_TLBContextEL2(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, va : bits(64), tg : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>) =&gt; <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>
begin
    var tlbcontext : <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;
    tlbcontext.cnp    = if IsFeatureImplemented(FEAT_TTCNP) then TTBR0_EL2().CnP else '0';

    return tlbcontext;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64_TLBContextEL20"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64_TLBContextEL20</h3>
      <p class="pseudocode">// AArch64_TLBContextEL20()
// ========================
// Gather translation context for accesses under EL20 regime to match against TLB entries

func <a id="func_AArch64_TLBContextEL20_3"/>AArch64_TLBContextEL20(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, va : bits(64), tg : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>) =&gt; <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>
begin
    var tlbcontext : <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>;

    if IsFeatureImplemented(FEAT_ASID2) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() &amp;&amp; TCR2_EL2().A2 == '1' then
        let varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a> = <a href="shared_pseudocode.html#func_AArch64_GetVARange_1" title="">AArch64_GetVARange</a>(va);
        tlbcontext.asid = if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then TTBR0_EL2().ASID else TTBR1_EL2().ASID;
    else
        tlbcontext.asid = if TCR_EL2().A1 == '0' then TTBR0_EL2().ASID else TTBR1_EL2().ASID;
    end;

    if TCR_EL2().AS == '0' then
        tlbcontext.asid[15:8] = Zeros{8};
    end;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;

    if IsFeatureImplemented(FEAT_TTCNP) then
        if <a href="shared_pseudocode.html#func_AArch64_GetVARange_1" title="">AArch64_GetVARange</a>(va) == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then
            tlbcontext.cnp = TTBR0_EL2().CnP;
        else
            tlbcontext.cnp = TTBR1_EL2().CnP;
        end;
    else
        tlbcontext.cnp = '0';
    end;

    return tlbcontext;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64_TLBContextEL3"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64_TLBContextEL3</h3>
      <p class="pseudocode">// AArch64_TLBContextEL3()
// =======================
// Gather translation context for accesses under EL3 regime to match against TLB entries

func <a id="func_AArch64_TLBContextEL3_3"/>AArch64_TLBContextEL3(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, va : bits(64), tg : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>) =&gt; <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>
begin
    var tlbcontext : <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a>;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;
    tlbcontext.cnp    = if IsFeatureImplemented(FEAT_TTCNP) then TTBR0_EL3().CnP else '0';

    return tlbcontext;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_FullTranslate"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_FullTranslate</h3>
      <p class="pseudocode">// AArch64_FullTranslate()
// =======================
// Address translation as specified by VMSA
// Alignment check NOT due to memory type is expected to be done before translation

func <a id="func_AArch64_FullTranslate_4"/>AArch64_FullTranslate(va : bits(64), size : integer, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                           aligned : boolean) =&gt; <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>
begin
    let regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a> = <a href="shared_pseudocode.html#func_TranslationRegime_1" title="">TranslationRegime</a>(accdesc.el);
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, va);

    var ipa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    (fault, ipa) = <a href="shared_pseudocode.html#func_AArch64_S1Translate_6" title="">AArch64_S1Translate</a>(fault, regime, va, size, aligned, accdesc);

    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return <a href="shared_pseudocode.html#func_CreateFaultyAddressDescriptor_1" title="">CreateFaultyAddressDescriptor</a>(fault);
    end;

    if accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> then
        assert <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
    end;
    if regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        let s1aarch64 : boolean = TRUE;
        var pa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
        (fault, pa) = <a href="shared_pseudocode.html#func_AArch64_S2Translate_5" title="">AArch64_S2Translate</a>(fault, ipa, s1aarch64, aligned, accdesc);

        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            return <a href="shared_pseudocode.html#func_CreateFaultyAddressDescriptor_1" title="">CreateFaultyAddressDescriptor</a>(fault);
        else
            return pa;
        end;
    else
        return ipa;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_MemSwapTableDesc"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_MemSwapTableDesc</h3>
      <p class="pseudocode">// AArch64_MemSwapTableDesc()
// ==========================
// Perform HW update of table descriptor as an atomic operation

func <a id="func_AArch64_MemSwapTableDesc_7"/>AArch64_MemSwapTableDesc{N : integer{64, 128}}(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, prev_desc : bits(N),
                                                    new_desc : bits(N), ee : bit,
                                                    descaccess : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                                    descpaddr : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>
                                                ) =&gt; (<a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, bits(N))
begin
    assert descaccess.acctype == <a href="shared_pseudocode.html#enum_AccessType_TTW" title="">AccessType_TTW</a>;
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    var iswrite : boolean;

    if IsFeatureImplemented(FEAT_RME) then
        fault.gpcf = <a href="shared_pseudocode.html#func_GranuleProtectionCheck_2" title="">GranuleProtectionCheck</a>(descpaddr, descaccess);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> then
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_GPCFOnWalk" title="">Fault_GPCFOnWalk</a>;
            fault.paddress   = descpaddr.paddress;
            fault.gpcfs2walk = fault.secondstage;
            return (fault, ARBITRARY : bits(N));
        end;
    end;

    // All observers in the shareability domain observe the
    // following memory read and write accesses atomically.
    var mem_desc : bits(N);
    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    (memstatus, mem_desc) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{N}(descpaddr, descaccess);

    if ee == '1' then
        mem_desc = <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{N}(mem_desc);
    end;

    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
        iswrite = FALSE;
        fault = <a href="shared_pseudocode.html#func_HandleExternalTTWAbort_6" title="">HandleExternalTTWAbort</a>(memstatus, iswrite, descpaddr, descaccess, N DIV 8, fault);
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(fault.statuscode) then
            return (fault, ARBITRARY : bits(N));
        end;
    end;

    if mem_desc == prev_desc  then
        let ordered_new_desc : bits(N) = (if ee == '1' then <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{N}(new_desc)
                                                       else new_desc);
        memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{N}(descpaddr, descaccess, ordered_new_desc);

        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
            iswrite = TRUE;
            fault = <a href="shared_pseudocode.html#func_HandleExternalTTWAbort_6" title="">HandleExternalTTWAbort</a>(memstatus, iswrite, descpaddr, descaccess, N DIV 8,
                                           fault);

            if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(fault.statuscode) then
                return (fault, ARBITRARY : bits(N));
            end;
        end;

        // Reflect what is now in memory (in little endian format)
        mem_desc = new_desc;
    end;

    return (fault, mem_desc);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_S1DisabledOutput"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_S1DisabledOutput</h3>
      <p class="pseudocode">// AArch64_S1DisabledOutput()
// ==========================
// Map the VA to IPA/PA and assign default memory attributes

func AArch64_S1DisabledOutput(fault_in : FaultRecord, regime : Regime,
                              va_in :  bits(64), accdesc : AccessDescriptor,
                              aligned : boolean) =&gt; (FaultRecord, AddressDescriptor)
begin
    var va : bits(64) = va_in;
    let walkparams : S1TTWParams = AArch64_GetS1TTWParams(regime, accdesc.el, accdesc.ss, va);
    var fault : FaultRecord = fault_in;

    // No memory page is guarded when stage 1 address translation is disabled
    SetInGuardedPage(FALSE);

    // Output Address
    var oa : FullAddress;
    oa.address = va[55:0];
    case accdesc.ss of
        when SS_Secure =&gt;    oa.paspace = PAS_Secure;
        when SS_NonSecure =&gt; oa.paspace = PAS_NonSecure;
        when SS_Root =&gt;      oa.paspace = PAS_Root;
        when SS_Realm =&gt;     oa.paspace = PAS_Realm;
    end;

    var memattrs : MemoryAttributes;
    if regime == Regime_EL10 &amp;&amp; EL2Enabled() &amp;&amp; walkparams.dc == '1' then
        var default_cacheability : MemAttrHints;
        default_cacheability.attrs     = MemAttr_WB;
        default_cacheability.hints     = MemHint_RWA;
        default_cacheability.transient = FALSE;

        memattrs.memtype      = MemType_Normal;
        memattrs.outer        = default_cacheability;
        memattrs.inner        = default_cacheability;
        memattrs.shareability = Shareability_NSH;
        if walkparams.dct == '1' then
            memattrs.tags     = MemTag_AllocationTagged;
        elsif IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS) &amp;&amp; walkparams.mtx == '1' then
            memattrs.tags     = MemTag_CanonicallyTagged;
        else
            memattrs.tags     = MemTag_Untagged;
        end;
        memattrs.xs           = '0';
    elsif accdesc.acctype == AccessType_IFETCH then
        var i_cache_attr : MemAttrHints;
        if AArch64_S1ICacheEnabled(regime) then
            i_cache_attr.attrs     = MemAttr_WT;
            i_cache_attr.hints     = MemHint_RA;
            i_cache_attr.transient = FALSE;
        else
            i_cache_attr.attrs     = MemAttr_NC;
        end;

        memattrs.memtype      = MemType_Normal;
        memattrs.outer        = i_cache_attr;
        memattrs.inner        = i_cache_attr;
        memattrs.shareability = Shareability_OSH;
        memattrs.tags         = MemTag_Untagged;
        memattrs.xs           = '1';
    elsif accdesc.acctype == AccessType_SPE &amp;&amp; EffectivePMBLIMITR_EL1_nVM() == '1' then
        memattrs = S1DecodeMemAttrs(PMBMAR_EL1().Attr, PMBMAR_EL1().SH, TRUE,
                                    walkparams, accdesc.acctype);
    elsif accdesc.acctype == AccessType_TRBE &amp;&amp; EffectiveTRBLIMITR_EL1_nVM() == '1' then
        memattrs = S1DecodeMemAttrs(TRBMAR_EL1().Attr, TRBMAR_EL1().SH, TRUE,
                                    walkparams, accdesc.acctype);
    else
        memattrs.memtype      = MemType_Device;
        memattrs.device       = DeviceType_nGnRnE;
        memattrs.shareability = Shareability_OSH;
        if IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS) &amp;&amp; walkparams.mtx == '1' then
            memattrs.tags = MemTag_CanonicallyTagged;
        else
            memattrs.tags = MemTag_Untagged;
        end;
        memattrs.xs           = '1';
    end;
    memattrs.notagaccess = FALSE;

    if walkparams.mtx == '1' &amp;&amp; walkparams.tbi == '0' &amp;&amp; accdesc.acctype != AccessType_IFETCH then
        // For the purpose of the checks in this function, the MTE tag bits are ignored.
        va[59:56] = if HasUnprivileged(regime) then Replicate{4}(va[55]) else '0000';
    end;

    fault.level = 0;
    let addrtop : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = AArch64_AddrTop(walkparams.tbid, accdesc.acctype,
                                                   walkparams.tbi);
    let pamax : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = AArch64_PAMax();

    if !IsZero(va[addrtop:pamax]) then
        fault.statuscode = Fault_AddressSize;
    elsif AArch64_S1HasAlignmentFaultDueToMemType(regime, accdesc, aligned, walkparams.ntlsmd,
                                                  memattrs) then
        fault.statuscode = Fault_Alignment;
    elsif ((accdesc.exclusive || accdesc.atomicop) &amp;&amp;
            !(regime == Regime_EL10 &amp;&amp; EL2Enabled() &amp;&amp; HCR_EL2().DC == '1') &amp;&amp;
            ConstrainUnpredictableBool(Unpredictable_Atomic_MMU_IMPDEF_FAULT)) then
        fault.statuscode = Fault_Exclusive;
    end;

    if fault.statuscode != Fault_None then
        return (fault, ARBITRARY : AddressDescriptor);
    else
        var ipa : AddressDescriptor = CreateAddressDescriptor(va_in, oa, memattrs, accdesc);
        ipa.mecid = AArch64_S1DisabledOutputMECID(walkparams, regime, ipa.paddress.paspace);
        return (fault, ipa);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_S1Translate"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_S1Translate</h3>
      <p class="pseudocode">// AArch64_S1Translate()
// =====================
// Translate VA to IPA/PA depending on the regime

func <a id="func_AArch64_S1Translate_6"/>AArch64_S1Translate(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                         va : bits(64), size : integer, aligned : boolean,
                         accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; (<a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>)
                         recurselimit Unbounded_DescriptorUpdate
begin
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    // Prepare fault fields in case a fault is detected
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    if !<a href="shared_pseudocode.html#func_AArch64_S1Enabled_2" title="">AArch64_S1Enabled</a>(regime, accdesc.acctype) then
        return AArch64_S1DisabledOutput(fault, regime, va, accdesc, aligned);
    end;

    var walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a> = <a href="shared_pseudocode.html#func_AArch64_GetS1TTWParams_4" title="">AArch64_GetS1TTWParams</a>(regime, accdesc.el, accdesc.ss, va);
    let s1mintxsz : integer = <a href="shared_pseudocode.html#func_AArch64_S1MinTxSZ_2" title="">AArch64_S1MinTxSZ</a>(regime, walkparams);
    let s1maxtxsz : integer = <a href="shared_pseudocode.html#func_AArch64_MaxTxSZ_1" title="">AArch64_MaxTxSZ</a>(walkparams.tgx);
    if <a href="shared_pseudocode.html#func_AArch64_S1TxSZFaults_2" title="">AArch64_S1TxSZFaults</a>(regime, walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    elsif UInt(walkparams.txsz) &lt; s1mintxsz then
        walkparams.txsz = s1mintxsz[5:0];
    elsif UInt(walkparams.txsz) &gt; s1maxtxsz then
        walkparams.txsz = s1maxtxsz[5:0];
    end;

    if AArch64_VAIsOutOfRange(va, accdesc.acctype, regime, walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    if accdesc.el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; walkparams.e0pd == '1' then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    if (IsFeatureImplemented(FEAT_SVE) &amp;&amp; accdesc.el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; walkparams.nfd == '1' &amp;&amp;
          ((accdesc.nonfault &amp;&amp; accdesc.contiguous) ||
           (accdesc.firstfault &amp;&amp; !accdesc.first &amp;&amp; !accdesc.contiguous))) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    var descipaddr : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    var walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    var descriptor : bits(128);
    if walkparams.d128 == '1' then
        (fault, descipaddr, walkstate, descriptor) = <a href="shared_pseudocode.html#func_AArch64_S1Walk_6" title="">AArch64_S1Walk</a>{128}(fault, walkparams, va,
                                                                         regime, accdesc);
    else
        (fault, descipaddr, walkstate, descriptor[63:0]) = <a href="shared_pseudocode.html#func_AArch64_S1Walk_6" title="">AArch64_S1Walk</a>{64}(fault, walkparams, va,
                                                                              regime, accdesc);
        descriptor[127:64] = Zeros{64};
    end;
    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;
    if <a href="shared_pseudocode.html#func_AArch64_S1HasAlignmentFaultDueToMemType_5" title="">AArch64_S1HasAlignmentFaultDueToMemType</a>(regime, accdesc, aligned, walkparams.ntlsmd,
                                               walkstate.memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a>;
    end;

    let fault_perm : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_AArch64_S1CheckPermissions_7" title="">AArch64_S1CheckPermissions</a>(fault, va, size, regime,
                                                                 walkstate, walkparams, accdesc);

    var mem_desc : bits(128);
    var new_desc : bits(128) = descriptor;

    if <a href="shared_pseudocode.html#func_AArch64_SetAccessFlag_3" title="">AArch64_SetAccessFlag</a>(walkparams.ha, accdesc, fault) then
        // Set descriptor AF bit
        new_desc[10] = '1';
    end;

    // If HW update of dirty bit is enabled, the walk state permissions
    // will already reflect a configuration permitting writes.
    // The update of the descriptor occurs only if the descriptor bits in
    // memory do not reflect that and the access instigates a write.

    if <a href="shared_pseudocode.html#func_AArch64_SetDirtyState_5" title="">AArch64_SetDirtyState</a>(walkparams.hd, (walkparams.pie OR descriptor[51]),
                             accdesc, fault, fault_perm) then
        // Clear descriptor AP[2]/nDirty bit permitting stage 1 writes
        new_desc[7] = '0';
    end;

    if fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> &amp;&amp; fault_perm.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        fault = fault_perm;
    end;

    // Either the access flag was clear or AP[2]/nDirty is set
    if new_desc != descriptor then
        var descpaddr : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
        let descaccess : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescTTEUpdate_1" title="">CreateAccDescTTEUpdate</a>(accdesc);

        if regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
            var s2fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>;
            let s1aarch64 : boolean = TRUE;
            let s2aligned : boolean = TRUE;
            (s2fault, descpaddr) = <a href="shared_pseudocode.html#func_AArch64_S2Translate_5" title="">AArch64_S2Translate</a>(fault, descipaddr, s1aarch64, s2aligned,
                                                       descaccess);
            if s2fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
                return (s2fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
            end;

        else
            descpaddr = descipaddr;
        end;
        if walkparams.d128 == '1' then
            (fault, mem_desc) = <a href="shared_pseudocode.html#func_AArch64_MemSwapTableDesc_7" title="">AArch64_MemSwapTableDesc</a>{128}(fault, descriptor,
                                                              new_desc, walkparams.ee,
                                                              descaccess, descpaddr);
        else
            (fault, mem_desc[63:0]) = <a href="shared_pseudocode.html#func_AArch64_MemSwapTableDesc_7" title="">AArch64_MemSwapTableDesc</a>{64}(fault, descriptor[63:0],
                                                                   new_desc[63:0], walkparams.ee,
                                                                   descaccess, descpaddr);
            mem_desc[127:64] = Zeros{64};
        end;

        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            if (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a> &amp;&amp;
                    !(ImpDefBool("AT reports the HW update fault"))) then
                // Mask the fault
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
            else
                return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
            end;
        elsif new_desc != descriptor &amp;&amp; mem_desc != new_desc then
            // HW update of Dirty state or AF was not successful due to the descriptor being updated
            // not matching the descriptor used for translation. Due to this, the walk is restarted.
            return <a href="shared_pseudocode.html#func_AArch64_S1Translate_6" title="">AArch64_S1Translate</a>(fault_in, regime, va, size, aligned, accdesc);
        end;
    end;

    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    // Output Address
    let oa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a> = StageOA(va, walkparams.d128, walkparams.tgx, walkstate);
    var memattrs : MemoryAttributes;
    if <a href="shared_pseudocode.html#func_AArch64_S1TreatAsNormalNC_3" title="">AArch64_S1TreatAsNormalNC</a>(walkstate, regime, accdesc) then
       // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a href="shared_pseudocode.html#func_NormalNCMemAttr_0" title="">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;

        // The effect of SCTLR_ELx.C when '0' is Constrained UNPREDICTABLE on the Tagged attribute
        // when the memory region is Allocation Tagged.
        if (IsFeatureImplemented(FEAT_MTE2) &amp;&amp;
              walkstate.memattrs.tags == <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a> &amp;&amp;
              <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_S1CTAGGED" title="">Unpredictable_S1CTAGGED</a>)) then
            memattrs.tags = <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a>;
        // SCTLR_ELx.C has no effect on whether the memory region is treated as Canonically Tagged.
        elsif (IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS) &amp;&amp;
                 walkstate.memattrs.tags == <a href="shared_pseudocode.html#enum_MemTag_CanonicallyTagged" title="">MemTag_CanonicallyTagged</a>) then
            memattrs.tags = <a href="shared_pseudocode.html#enum_MemTag_CanonicallyTagged" title="">MemTag_CanonicallyTagged</a>;
        end;
    else
        memattrs = walkstate.memattrs;
    end;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().VM == '1' &amp;&amp;
            !(ImpDefBool("Apply effective shareability at stage 1"))) then
        memattrs.shareability = walkstate.memattrs.shareability;
    else
        memattrs.shareability = <a href="shared_pseudocode.html#func_EffectiveShareability_1" title="">EffectiveShareability</a>(memattrs);
    end;

    var ipa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAddressDescriptor_4" title="">CreateAddressDescriptor</a>(va, oa, memattrs, accdesc);
    ipa.s1assured = walkstate.s1assured;
    let varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a> = <a href="shared_pseudocode.html#func_AArch64_GetVARange_1" title="">AArch64_GetVARange</a>(va);
    ipa.mecid = <a href="shared_pseudocode.html#func_AArch64_S1OutputMECID_6" title="">AArch64_S1OutputMECID</a>{128}(walkparams, regime, varange, ipa.paddress.paspace,
                                          descriptor);

    if (accdesc.atomicop &amp;&amp; !<a href="shared_pseudocode.html#func_IsWBShareable_1" title="">IsWBShareable</a>(memattrs) &amp;&amp;
            <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_Atomic_MMU_IMPDEF_FAULT" title="">Unpredictable_Atomic_MMU_IMPDEF_FAULT</a>)) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a>;
        return (fault, ipa);
    end;

    if accdesc.ls64 &amp;&amp; memattrs.memtype == MemType_Normal then
        if IsFeatureImplemented(FEAT_LS64WB) &amp;&amp; !accdesc.withstatus then
            if (!<a href="shared_pseudocode.html#func_IsWBShareable_1" title="">IsWBShareable</a>(memattrs) &amp;&amp;
                  !(memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp;
                    memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>) &amp;&amp;
                  (ImpDefBool(
                     "LD64B or ST64B faults to cacheable non-iWBoWB memory"))) then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a>;
                return (fault, ipa);
            end;
        elsif !(memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>) then
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a>;
            return (fault, ipa);
        end;
    end;

    return (fault, ipa);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_S1TreatAsNormalNC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_S1TreatAsNormalNC</h3>
      <p class="pseudocode">// AArch64_S1TreatAsNormalNC()
// ===========================
// Returns TRUE if stage 1 memory attributes should be treated as Normal Non-Cacheable

func <a id="func_AArch64_S1TreatAsNormalNC_3"/>AArch64_S1TreatAsNormalNC(walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                               accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    return ((accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> &amp;&amp;
              (walkstate.memattrs.memtype == MemType_Device || !<a href="shared_pseudocode.html#func_AArch64_S1ICacheEnabled_1" title="">AArch64_S1ICacheEnabled</a>(regime))) ||
           (accdesc.acctype != <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> &amp;&amp;
              !<a href="shared_pseudocode.html#func_AArch64_S1DCacheEnabled_1" title="">AArch64_S1DCacheEnabled</a>(regime) &amp;&amp; walkstate.memattrs.memtype == MemType_Normal));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_S2Translate"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_S2Translate</h3>
      <p class="pseudocode">// AArch64_S2Translate()
// =====================
// Translate stage 1 IPA to PA and combine memory attributes

func <a id="func_AArch64_S2Translate_5"/>AArch64_S2Translate(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, ipa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                         s1aarch64 : boolean, aligned : boolean,
                         accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; (<a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>)
                         recurselimit Unbounded_DescriptorUpdate
begin
    var walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a> = <a href="shared_pseudocode.html#func_AArch64_GetS2TTWParams_3" title="">AArch64_GetS2TTWParams</a>(accdesc.ss, ipa.paddress.paspace,
                                                          s1aarch64);
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    var s2fs1mro : boolean;
    // Prepare fault fields in case a fault is detected
    fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>; // Ignore any faults from stage 1
    fault.dirtybit     = FALSE;
    fault.overlay      = FALSE;
    fault.tagaccess    = FALSE;
    fault.s1tagnotdata = FALSE;
    fault.secondstage  = TRUE;
    fault.s2fs1walk    = accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_TTW" title="">AccessType_TTW</a>;
    fault.ipaddress    = ipa.paddress;

    if walkparams.vm != '1' then
        // Stage 2 translation is disabled
        return (fault, ipa);
    end;

    let s2mintxsz : integer = <a href="shared_pseudocode.html#func_AArch64_S2MinTxSZ_2" title="">AArch64_S2MinTxSZ</a>(walkparams, s1aarch64);
    let s2maxtxsz : integer = <a href="shared_pseudocode.html#func_AArch64_MaxTxSZ_1" title="">AArch64_MaxTxSZ</a>(walkparams.tgx);
    if <a href="shared_pseudocode.html#func_AArch64_S2TxSZFaults_2" title="">AArch64_S2TxSZFaults</a>(walkparams, s1aarch64) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    elsif UInt(walkparams.txsz) &lt; s2mintxsz then
        walkparams.txsz = s2mintxsz[5:0];
    elsif UInt(walkparams.txsz) &gt; s2maxtxsz then
        walkparams.txsz = s2maxtxsz[5:0];
    end;

    if (walkparams.d128 == '0' &amp;&amp;
        (<a href="shared_pseudocode.html#func_AArch64_S2InvalidSL_1" title="">AArch64_S2InvalidSL</a>(walkparams) || AArch64_S2InconsistentSL(walkparams))) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    if <a href="shared_pseudocode.html#func_AArch64_IPAIsOutOfRange_2" title="">AArch64_IPAIsOutOfRange</a>(ipa.paddress.address, walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    var descpaddr : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    var walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    var descriptor : bits(128);
    if walkparams.d128 == '1' then
        (fault, descpaddr, walkstate, descriptor) = <a href="shared_pseudocode.html#func_AArch64_S2Walk_5" title="">AArch64_S2Walk</a>{128}(fault, ipa, walkparams,
                                                                        accdesc);
    else
        (fault, descpaddr, walkstate, descriptor[63:0]) = <a href="shared_pseudocode.html#func_AArch64_S2Walk_5" title="">AArch64_S2Walk</a>{64}(fault, ipa, walkparams,
                                                                             accdesc);
        descriptor[127:64] = Zeros{64};
    end;
    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    if <a href="shared_pseudocode.html#func_AArch64_S2HasAlignmentFaultDueToMemType_3" title="">AArch64_S2HasAlignmentFaultDueToMemType</a>(accdesc, aligned, walkstate.memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a>;
    end;

    var fault_perm : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>;
    (fault_perm, s2fs1mro) = AArch64_S2CheckPermissions(fault, walkstate, walkparams, ipa, accdesc);

    var mem_desc : bits(128);
    var new_desc : bits(128) = descriptor;

    if <a href="shared_pseudocode.html#func_AArch64_SetAccessFlag_3" title="">AArch64_SetAccessFlag</a>(walkparams.ha, accdesc, fault) then
        // Set descriptor AF bit
        new_desc[10] = '1';
    end;

    // If HW update of dirty bit is enabled, the walk state permissions
    // will already reflect a configuration permitting writes.
    // The update of the descriptor occurs only if the descriptor bits in
    // memory do not reflect that and the access instigates a write.

    if <a href="shared_pseudocode.html#func_AArch64_SetDirtyState_5" title="">AArch64_SetDirtyState</a>(walkparams.hd, (walkparams.s2pie OR descriptor[51]),
                             accdesc, fault, fault_perm) then
        // Set descriptor S2AP[1]/Dirty bit permitting stage 2 writes
        new_desc[7] = '1';
    end;

    if fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> &amp;&amp; fault_perm.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        fault = fault_perm;
    end;

    // Either the access flag was clear or S2AP[1]/Dirty is clear
    if new_desc != descriptor then
        if walkparams.hdbss == '1' &amp;&amp; descriptor[7] == '0' &amp;&amp; new_desc[7] == '1' then
            fault = AppendToHDBSS(fault, ipa.paddress, accdesc, walkparams, walkstate.level);
        end;

        // If an error, other than a synchronous External abort, occurred on the HDBSS update,
        // stage 2 hardware update of dirty state is not permitted.
        if (HDBSSPROD_EL2().FSC != '101000' &amp;&amp;
                (!fault.hdbssf || <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault.statuscode))) then
            let descaccess : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescTTEUpdate_1" title="">CreateAccDescTTEUpdate</a>(accdesc);
            if walkparams.d128 == '1' then
                (fault, mem_desc) = <a href="shared_pseudocode.html#func_AArch64_MemSwapTableDesc_7" title="">AArch64_MemSwapTableDesc</a>{128}(fault, descriptor, new_desc,
                                                             walkparams.ee, descaccess,
                                                             descpaddr);
            else
                (fault, mem_desc[63:0]) = <a href="shared_pseudocode.html#func_AArch64_MemSwapTableDesc_7" title="">AArch64_MemSwapTableDesc</a>{64}(fault, descriptor[63:0],
                                                                   new_desc[63:0], walkparams.ee,
                                                                   descaccess, descpaddr);
                mem_desc[127:64] = Zeros{64};
            end;
        end;

        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            if (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a> &amp;&amp;
                    !(ImpDefBool("AT reports the HW update fault"))) then
                // Mask the fault
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
            else
                return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
            end;
        elsif new_desc != descriptor &amp;&amp; mem_desc != new_desc then
            // HW update of Dirty state or AF was not successful due to the descriptor being updated
            // not matching the descriptor used for translation. Due to this, the walk is restarted.
            return <a href="shared_pseudocode.html#func_AArch64_S2Translate_5" title="">AArch64_S2Translate</a>(fault_in, ipa, s1aarch64, aligned, accdesc);
        end;
    end;

    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>);
    end;

    let ipa_64 : bits(64) = ZeroExtend{}(ipa.paddress.address);
    // Output Address
    let oa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a> = StageOA(ipa_64, walkparams.d128, walkparams.tgx, walkstate);
    var s2_memattrs : MemoryAttributes;

    if <a href="shared_pseudocode.html#func_AArch64_S2TreatAsNormalNC_3" title="">AArch64_S2TreatAsNormalNC</a>(walkstate, walkparams, accdesc) then
        // Treat memory attributes as Normal Non-Cacheable
        s2_memattrs = <a href="shared_pseudocode.html#func_NormalNCMemAttr_0" title="">NormalNCMemAttr</a>();
        s2_memattrs.xs = walkstate.memattrs.xs;
        if walkstate.memattrs.tags == <a href="shared_pseudocode.html#enum_MemTag_CanonicallyTagged" title="">MemTag_CanonicallyTagged</a> then
            s2_memattrs.tags = <a href="shared_pseudocode.html#enum_MemTag_CanonicallyTagged" title="">MemTag_CanonicallyTagged</a>;
        end;
    else
        s2_memattrs = walkstate.memattrs;
    end;

    let s2aarch64 : boolean = TRUE;
    var memattrs : MemoryAttributes;
    if walkparams.fwb == '0' then
        memattrs = <a href="shared_pseudocode.html#func_S2CombineS1MemAttrs_3" title="">S2CombineS1MemAttrs</a>(ipa.memattrs, s2_memattrs, s2aarch64);
    else
        memattrs = s2_memattrs;
    end;

    var pa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAddressDescriptor_4" title="">CreateAddressDescriptor</a>(ipa.vaddress, oa, memattrs, accdesc);
    pa.s2fs1mro = s2fs1mro;
    pa.mecid = <a href="shared_pseudocode.html#func_AArch64_S2OutputMECID_4" title="">AArch64_S2OutputMECID</a>{128}(walkparams, pa.paddress.paspace, descriptor);

    if (accdesc.atomicop &amp;&amp; !<a href="shared_pseudocode.html#func_IsWBShareable_1" title="">IsWBShareable</a>(s2_memattrs) &amp;&amp;
            <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_Atomic_MMU_IMPDEF_FAULT" title="">Unpredictable_Atomic_MMU_IMPDEF_FAULT</a>)) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a>;
        return (fault, pa);
    end;

    if accdesc.ls64 &amp;&amp; s2_memattrs.memtype == MemType_Normal then
        if IsFeatureImplemented(FEAT_LS64WB) &amp;&amp; !accdesc.withstatus then
            if (!<a href="shared_pseudocode.html#func_IsWBShareable_1" title="">IsWBShareable</a>(s2_memattrs) &amp;&amp;
                  !(s2_memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp;
                    s2_memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>) &amp;&amp;
                  (ImpDefBool(
                     "LD64B or ST64B faults to cacheable non-iWBoWB memory"))) then
                fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a>;
                return (fault, ipa);
            end;
        elsif !(s2_memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp; s2_memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>) then
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a>;
            return (fault, ipa);
        end;
    end;

    return (fault, pa);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_S2TreatAsNormalNC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_S2TreatAsNormalNC</h3>
      <p class="pseudocode">// AArch64_S2TreatAsNormalNC()
// ===========================
// Returns TRUE if stage 2 memory attributes should be treated as Normal Non-cacheable

func <a id="func_AArch64_S2TreatAsNormalNC_3"/>AArch64_S2TreatAsNormalNC(walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>,
                               accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    return ((accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_TTW" title="">AccessType_TTW</a> &amp;&amp;
             walkstate.memattrs.memtype == MemType_Device &amp;&amp; walkparams.ptw == '0') ||
            (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> &amp;&amp;
             (walkstate.memattrs.memtype == MemType_Device || HCR_EL2().ID == '1')) ||
            (accdesc.acctype != <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == MemType_Normal &amp;&amp; !<a href="shared_pseudocode.html#func_S2DCacheEnabled_0" title="">S2DCacheEnabled</a>()));
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_SetAccessFlag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_SetAccessFlag</h3>
      <p class="pseudocode">// AArch64_SetAccessFlag()
// =======================
// Determine whether the access flag could be set by HW given the fault status

func <a id="func_AArch64_SetAccessFlag_3"/>AArch64_SetAccessFlag(ha : bit, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    if ha == '0' || !<a href="shared_pseudocode.html#func_AArch64_SettingAccessFlagPermitted_1" title="">AArch64_SettingAccessFlagPermitted</a>(fault) then
        return FALSE;
    elsif accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a> then
        return ImpDefBool("AT updates AF");
    elsif accdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>} then
        return ImpDefBool("Generate access flag fault on IC/DC operations");
    else
        // Set descriptor AF bit
        return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_SetDirtyState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_SetDirtyState</h3>
      <p class="pseudocode">// AArch64_SetDirtyState()
// =======================
// Determine whether dirty state is required to be updated by HW given the fault status

func <a id="func_AArch64_SetDirtyState_5"/>AArch64_SetDirtyState(hd : bits(1), dbm : bits(1),
                           accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                           fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>,
                           fault_perm : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    if hd == '0' then
        return FALSE;
    elsif !<a href="shared_pseudocode.html#func_AArch64_SettingDirtyStatePermitted_2" title="">AArch64_SettingDirtyStatePermitted</a>(fault, fault_perm) then
        return FALSE;
    elsif accdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>, <a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>} then
        return FALSE;
    elsif !accdesc.write then
        return FALSE;
    else
        return dbm == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_SettingAccessFlagPermitted"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_SettingAccessFlagPermitted</h3>
      <p class="pseudocode">// AArch64_SettingAccessFlagPermitted()
// ====================================
// Determine whether the access flag could be set by HW given the fault status

func <a id="func_AArch64_SettingAccessFlagPermitted_1"/>AArch64_SettingAccessFlagPermitted(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    if fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return TRUE;
    elsif fault.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a>, <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>} then
        return <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_AFUPDATE" title="">Unpredictable_AFUPDATE</a>);
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_SettingDirtyStatePermitted"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_SettingDirtyStatePermitted</h3>
      <p class="pseudocode">// AArch64_SettingDirtyStatePermitted()
// ====================================
// Determine whether the dirty state could be set by HW given the fault status

func <a id="func_AArch64_SettingDirtyStatePermitted_2"/>AArch64_SettingDirtyStatePermitted(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, fault_perm : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    if fault_perm.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return FALSE;
    elsif fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return TRUE;
    elsif fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a> then
        return <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_DBUPDATE" title="">Unpredictable_DBUPDATE</a>);
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_TranslateAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_TranslateAddress</h3>
      <p class="pseudocode">// AArch64_TranslateAddress()
// ==========================
// Main entry point for translating an address

func <a id="func_AArch64_TranslateAddress_4"/>AArch64_TranslateAddress(va : bits(64), accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                              aligned : boolean, size : integer) =&gt; <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>
begin
    if (<a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> &amp;&amp;
        !(accdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a>, <a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a>, <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a>})) then
        SPEStartCounter(<a href="shared_pseudocode.html#global_SPECounterPosTranslationLatency" title="">SPECounterPosTranslationLatency</a>);
    end;

    var result : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch64_FullTranslate_4" title="">AArch64_FullTranslate</a>(va, size, accdesc, aligned);

    if !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(result) &amp;&amp; accdesc.acctype != <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a> then
        // For an instruction fetch, CheckDebug will be called
        // after the instruction is read from memory
        result.fault = <a href="shared_pseudocode.html#func_AArch64_CheckDebug_3" title="">AArch64_CheckDebug</a>(va, accdesc, size);
    end;

    if (IsFeatureImplemented(FEAT_RME) &amp;&amp; !<a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(result) &amp;&amp;
          <a href="shared_pseudocode.html#func_IsGranuleProtectionCheckedAccess_1" title="">IsGranuleProtectionCheckedAccess</a>(accdesc)) then
        result.fault.gpcf = <a href="shared_pseudocode.html#func_GranuleProtectionCheck_2" title="">GranuleProtectionCheck</a>(result, accdesc);

        if result.fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> then
            result.fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_GPCFOnOutput" title="">Fault_GPCFOnOutput</a>;
            result.fault.paddress   = result.paddress;
            result.fault.vaddress   = result.vaddress;
        end;
    end;

    if <a href="shared_pseudocode.html#global_SPESampleInFlight" title="">SPESampleInFlight</a> &amp;&amp;
        !(accdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a>, <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a>, <a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a>}) then
        SPEStopCounter(<a href="shared_pseudocode.html#global_SPECounterPosTranslationLatency" title="">SPECounterPosTranslationLatency</a>);
    end;

    // Update virtual address for abort functions
    result.vaddress = ZeroExtend{64}(va);

    return result;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64_TranslateTagAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64_TranslateTagAddress</h3>
      <p class="pseudocode">// AArch64_TranslateTagAddress()
// =============================
// Translate an address for accessing an Allocation Tag.

func <a id="func_AArch64_TranslateTagAddress_4"/>AArch64_TranslateTagAddress(va : bits(64),
                                 accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                 aligned : boolean,
                                 size : integer) =&gt; (<a href="shared_pseudocode.html#type_MemTagType" title="">MemTagType</a>, <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>)
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = accdesc_in;
    let taddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a> = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(va, accdesc, aligned, size);

    return (taddrdesc.memattrs.tags, taddrdesc);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64_BlockDescSupported"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64_BlockDescSupported</h3>
      <p class="pseudocode">// AArch64_BlockDescSupported()
// ============================
// Determine whether a block descriptor is valid for the given granule size
// and level

func <a id="func_AArch64_BlockDescSupported_4"/>AArch64_BlockDescSupported(d128 : bit, ds : bit, tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>, level : integer) =&gt; boolean
begin
    case tgx of
        when <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a> =&gt; return ((level == 0 &amp;&amp; (ds == '1' || d128 == '1')) ||
                                level == 1 ||
                                level == 2);
        when <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a> =&gt; return ((level == 1 &amp;&amp; (ds == '1' || d128 == '1')) ||
                                  level == 2);
        when <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> =&gt; return ((level == 1 &amp;&amp; (d128 == '1' || AArch64_PAMax() &gt;= 52)) ||
                                  level == 2);
    end;
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64_ContiguousBit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64_ContiguousBit</h3>
      <p class="pseudocode">// AArch64_ContiguousBit()
// =======================
// Get the value of the contiguous bit

func <a id="func_AArch64_ContiguousBit_5"/>AArch64_ContiguousBit{N}(tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>, d128 : bit, level : integer, descriptor : bits(N)) =&gt; bit
begin
    if ImpDefBool("Treat Contiguous bit as 0") then
        return '0';
    end;

    if d128 == '1' then
        if (tgx == <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> &amp;&amp; level == 1) || (tgx == <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a> &amp;&amp; level == 0) then
            return '0'; // RES0
        else
            return descriptor[111];
        end;
    end;
    // When using TGx 64KB then the Contiguous bit is RES0 for Block
    // descriptors at level 1. For VMSAv8-64, level 1 Block descriptors
    // can exist only if FEAT_LPA is implemented.

    if tgx == <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> &amp;&amp; level == 1 then
        return '0'; // RES0
    end;

    // When the Effective value of TCR_ELx.DS is '1',
    // the Contiguous bit is RES0 for all the following:
    //      * For TGx 4KB, Block descriptors at level 0
    //      * For TGx 16KB, Block descriptors at level 1
    // For VMSAv8-64, the above Block descriptors at the specified
    // levels can exist only if the Effective value of TCR_ELx.DS is 1.

    if tgx == <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a> &amp;&amp; level == 1 then
        return '0'; // RES0
    end;

    if tgx == <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>  &amp;&amp; level == 0 then
        return '0'; // RES0
    end;

    return descriptor[52];
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64_DecodeDescriptorType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64_DecodeDescriptorType</h3>
      <p class="pseudocode">// AArch64_DecodeDescriptorType()
// ==============================
// Determine whether the descriptor is a page, block or table

func <a id="func_AArch64_DecodeDescriptorType_6"/>AArch64_DecodeDescriptorType{N}(descriptor : bits(N), d128 : bit, ds : bit,
                                     tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>, level : integer) =&gt; <a href="shared_pseudocode.html#type_DescriptorType" title="">DescriptorType</a>
begin
    if descriptor[0] == '0' then
        return <a href="shared_pseudocode.html#enum_DescriptorType_Invalid" title="">DescriptorType_Invalid</a>;
    elsif d128 == '1' then
        let skl : bits(2) = descriptor[110:109];
        if tgx IN {<a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>, <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a>} &amp;&amp; UInt(skl) == 3 then
            return <a href="shared_pseudocode.html#enum_DescriptorType_Invalid" title="">DescriptorType_Invalid</a>;
        end;

        let effective_level : integer = level + UInt(skl);
        if effective_level &gt; <a href="shared_pseudocode.html#global_FINAL_LEVEL" title="">FINAL_LEVEL</a> then
            return <a href="shared_pseudocode.html#enum_DescriptorType_Invalid" title="">DescriptorType_Invalid</a>;
        elsif effective_level == <a href="shared_pseudocode.html#global_FINAL_LEVEL" title="">FINAL_LEVEL</a> then
            return <a href="shared_pseudocode.html#enum_DescriptorType_Leaf" title="">DescriptorType_Leaf</a>;
        else
            return <a href="shared_pseudocode.html#enum_DescriptorType_Table" title="">DescriptorType_Table</a>;
        end;
    else
        if descriptor[1] == '1' then
            if level == <a href="shared_pseudocode.html#global_FINAL_LEVEL" title="">FINAL_LEVEL</a> then
                return <a href="shared_pseudocode.html#enum_DescriptorType_Leaf" title="">DescriptorType_Leaf</a>;
            else
                return <a href="shared_pseudocode.html#enum_DescriptorType_Table" title="">DescriptorType_Table</a>;
            end;
        elsif descriptor[1] == '0' then
            if <a href="shared_pseudocode.html#func_AArch64_BlockDescSupported_4" title="">AArch64_BlockDescSupported</a>(d128, ds, tgx, level) then
                return <a href="shared_pseudocode.html#enum_DescriptorType_Leaf" title="">DescriptorType_Leaf</a>;
            else
                return <a href="shared_pseudocode.html#enum_DescriptorType_Invalid" title="">DescriptorType_Invalid</a>;
            end;
        end;
        unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64_S1ApplyOutputPerms"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64_S1ApplyOutputPerms</h3>
      <p class="pseudocode">// AArch64_S1ApplyOutputPerms()
// ============================
// Apply output permissions encoded in stage 1 page/block descriptors

func <a id="func_AArch64_S1ApplyOutputPerms_5"/>AArch64_S1ApplyOutputPerms{N}(permissions_in : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a>, descriptor : bits(N),
                                   regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>) =&gt; <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a>
begin
    var permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a> = permissions_in;

    var pi_index : bits (4);
    if walkparams.pie == '1' then
        if walkparams.d128 == '1' then
            pi_index = descriptor[118:115];
        else
            pi_index = descriptor[54:53]::descriptor[51]::descriptor[6];
        end;
        permissions.ppi    = walkparams.pir[UInt(pi_index)*:4];
        permissions.upi    = walkparams.pire0[UInt(pi_index)*:4];
        permissions.ndirty = descriptor[7];
    else
        if regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; walkparams.nv1 == '1' then
            permissions.ap[2:1] = descriptor[7]::'0';
            permissions.pxn     = descriptor[54];
        elsif <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime) then
            permissions.ap[2:1] = descriptor[7:6];
            permissions.uxn     = descriptor[54];
            permissions.pxn     = descriptor[53];
        else
            permissions.ap[2:1] = descriptor[7]::'1';
            permissions.xn      = descriptor[54];
        end;
        permissions.dbm = descriptor[51];
    end;
    if IsFeatureImplemented(FEAT_S1POE) then
        if walkparams.d128 == '1' then
            permissions.po_index[3:0] = descriptor[124:121];
        else
            permissions.po_index[3:0] = '0'::descriptor[62:60];
        end;
    end;

    return permissions;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64_S1ApplyTablePerms"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64_S1ApplyTablePerms</h3>
      <p class="pseudocode">// AArch64_S1ApplyTablePerms()
// ===========================
// Apply hierarchical permissions encoded in stage 1 table descriptors

func <a id="func_AArch64_S1ApplyTablePerms_4"/>AArch64_S1ApplyTablePerms(permissions_in : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a>, descriptor : bits(64),
                               regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>) =&gt; <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a>
begin
    var permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a> = permissions_in;
    var ap_table : bits(2);
    var pxn_table : bit;
    var uxn_table : bit;
    var xn_table : bit;
    if regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; walkparams.nv1 == '1' then
        ap_table  = descriptor[62]::'0';
        pxn_table = descriptor[60];
        permissions.ap_table  = permissions.ap_table  OR ap_table;
        permissions.pxn_table = permissions.pxn_table OR pxn_table;

    elsif <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime) then
        ap_table  = descriptor[62:61];
        uxn_table = descriptor[60];
        pxn_table = descriptor[59];
        permissions.ap_table  = permissions.ap_table  OR ap_table;
        permissions.uxn_table = permissions.uxn_table OR uxn_table;
        permissions.pxn_table = permissions.pxn_table OR pxn_table;
    else
        ap_table = descriptor[62]::'0';
        xn_table = descriptor[60];
        permissions.ap_table = permissions.ap_table OR ap_table;
        permissions.xn_table = permissions.xn_table OR xn_table;
    end;

    return permissions;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64_S2ApplyOutputPerms"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64_S2ApplyOutputPerms</h3>
      <p class="pseudocode">// AArch64_S2ApplyOutputPerms()
// ============================
// Apply output permissions encoded in stage 2 page/block descriptors

func <a id="func_AArch64_S2ApplyOutputPerms_3"/>AArch64_S2ApplyOutputPerms{N}(descriptor : bits(N), walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>) =&gt; <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a>
begin
    var permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a>;
    var s2pi_index : bits(4);
    if walkparams.s2pie == '1' then
        if walkparams.d128 == '1' then
            s2pi_index = descriptor[118:115];
        else
            s2pi_index = descriptor[54:53,51,6];
        end;
        permissions.s2pi = walkparams.s2pir[UInt(s2pi_index)*:4];
        permissions.s2dirty = descriptor[7];
    else
        permissions.s2ap = descriptor[7:6];
        if walkparams.d128 == '1' then
            permissions.s2xn = descriptor[118];
        else
            permissions.s2xn = descriptor[54];
        end;

        if IsFeatureImplemented(FEAT_XNX) then
            if walkparams.d128 == '1' then
                permissions.s2xnx = descriptor[117];
            else
                permissions.s2xnx = descriptor[53];
            end;
        else
            permissions.s2xnx = '0';
        end;

        permissions.dbm = descriptor[51];
    end;
    if IsFeatureImplemented(FEAT_S2POE) then
        if walkparams.d128 == '1' then
            permissions.s2po_index = descriptor[124:121];
        else
            permissions.s2po_index = descriptor[62:59];
        end;
    end;
    return permissions;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64_nTFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64_nTFaults</h3>
      <p class="pseudocode">// AArch64_nTFaults()
// ==================
// Identify whether the nT bit in a block or table descriptor is effectively set
// causing a translation fault

func <a id="func_AArch64_nTFaults_3"/>AArch64_nTFaults{N}(d128 : bit, descriptor : bits(N)) =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_BBML1) then
        return FALSE;
    end;
    let nT : bit = if d128 == '1' then descriptor[6] else descriptor[16];

    return nT == '1' &amp;&amp; ImpDefBool("nT bit causes Translation Fault");
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64_S1InitialTTWState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64_S1InitialTTWState</h3>
      <p class="pseudocode">// AArch64_S1InitialTTWState()
// ===========================
// Set properties of first access to translation tables in stage 1

func <a id="func_AArch64_S1InitialTTWState_4"/>AArch64_S1InitialTTWState(walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>, va : bits(64), regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                               ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>) =&gt; <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>
begin
    var walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    var tablebase : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;
    var permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a>;
    var ttbr : bits(128);

    ttbr              = <a href="shared_pseudocode.html#func_AArch64_S1TTBR_2" title="">AArch64_S1TTBR</a>(regime, va);
    case ss of
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;    tablebase.paspace = <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt; tablebase.paspace = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> =&gt;      tablebase.paspace = <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>;
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;     tablebase.paspace = <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>;
    end;

    tablebase.address = AArch64_S1TTBaseAddress{128}(walkparams, regime, ttbr);

    permissions.ap_table = '00';
    if <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime) then
        permissions.uxn_table = '0';
        permissions.pxn_table = '0';
    else
        permissions.xn_table  = '0';
    end;

    walkstate.baseaddress = tablebase;
    walkstate.level       = AArch64_S1StartLevel(walkparams);
    walkstate.istable     = TRUE;
    // In regimes that support global and non-global translations, translation
    // table entries from lookup levels other than the final level of lookup
    // are treated as being non-global
    walkstate.nG          = if <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime) then '1' else '0';
    walkstate.memattrs    = <a href="shared_pseudocode.html#func_WalkMemAttrs_3" title="">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);
    walkstate.permissions = permissions;
    if regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().VM == '1' then
        if ((<a href="shared_pseudocode.html#func_AArch64_GetVARange_1" title="">AArch64_GetVARange</a>(va) == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> &amp;&amp; VTCR_EL2().TL0 == '1') ||
            (<a href="shared_pseudocode.html#func_AArch64_GetVARange_1" title="">AArch64_GetVARange</a>(va) == <a href="shared_pseudocode.html#enum_VARange_UPPER" title="">VARange_UPPER</a> &amp;&amp; VTCR_EL2().TL1 == '1')) then
            walkstate.s1assured = TRUE;
        else
            walkstate.s1assured = FALSE;
        end;
    else
        walkstate.s1assured = FALSE;
    end;
    walkstate.disch = walkparams.disch;

    return walkstate;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64_S1NextWalkStateLeaf"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64_S1NextWalkStateLeaf</h3>
      <p class="pseudocode">// AArch64_S1NextWalkStateLeaf()
// =============================
// Decode stage 1 page or block descriptor as output to this stage of translation

func <a id="func_AArch64_S1NextWalkStateLeaf_7"/>AArch64_S1NextWalkStateLeaf{N}(currentstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, s2fs1mro : boolean, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                                    accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>,
                                    descriptor : bits(N)) =&gt; <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>
begin
    var nextstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    var baseaddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;
    baseaddress.address = AArch64_S1LeafBase{N}(descriptor, walkparams, currentstate.level);

    if currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then
        // Determine PA space of the block from NS bit
        let ns : bit = if walkparams.d128 == '1' then descriptor[127] else descriptor[5];
        baseaddress.paspace = if ns == '0' then <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> else <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
    elsif currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a> then
        // Determine PA space of the block from NSE and NS bits
        let ns : bit = if walkparams.d128 == '1' then descriptor[127] else descriptor[5];
        let nse : bit = descriptor[11];
        let nse2 : bit = '0';     // NSE2 has the Effective value of 0 within a PE.
        baseaddress.paspace = <a href="shared_pseudocode.html#func_DecodePASpace_3" title="">DecodePASpace</a>(nse2, nse, ns);

        // If Secure state is not implemented, but RME is,
        // force Secure space accesses to Non-secure space
        if baseaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> &amp;&amp; !<a href="shared_pseudocode.html#func_HaveSecureState_0" title="">HaveSecureState</a>() then
            baseaddress.paspace = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        end;

    elsif (currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> &amp;&amp;
            regime IN {<a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>, <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>}) then
        // Realm EL2 and EL2&amp;0 regimes have a stage 1 NS bit
        let ns : bit = if walkparams.d128 == '1' then descriptor[127] else descriptor[5];
        baseaddress.paspace = if ns == '0' then <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> else <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
    elsif currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> then
        // Realm EL1&amp;0 regime does not have a stage 1 NS bit
        baseaddress.paspace = <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>;
    else
        baseaddress.paspace = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
    end;

    nextstate.istable     = FALSE;
    nextstate.level       = currentstate.level;
    nextstate.baseaddress = baseaddress;

    var attrindx : bits(4);
    if walkparams.aie == '1' then
        if walkparams.d128 == '1' then
            attrindx = descriptor[5:2];
        else
            attrindx = descriptor[59,4:2];
        end;
    else
        attrindx = '0'::descriptor[4:2];
    end;

    var sh : bits(2);
    if walkparams.d128 == '1' then
        sh = descriptor[9:8];
    elsif walkparams.ds == '1' then
        sh = walkparams.sh;
    else
        sh = descriptor[9:8];
    end;
    let attr : bits(8) = <a href="shared_pseudocode.html#func_AArch64_MAIRAttr_3" title="">AArch64_MAIRAttr</a>(UInt(attrindx), walkparams.mair2, walkparams.mair);
    let s1aarch64 : boolean = TRUE;

    nextstate.memattrs = <a href="shared_pseudocode.html#func_S1DecodeMemAttrs_5" title="">S1DecodeMemAttrs</a>(attr, sh, s1aarch64, walkparams, accdesc.acctype);
    nextstate.permissions = <a href="shared_pseudocode.html#func_AArch64_S1ApplyOutputPerms_5" title="">AArch64_S1ApplyOutputPerms</a>{N}(currentstate.permissions,
                                                       descriptor, regime, walkparams);
    var protectedbit : bit;
    if walkparams.d128 == '1' then
        protectedbit = descriptor[114];
    else
        protectedbit = if walkparams.pnch == '1' then descriptor[52] else '0';
    end;
    if (currentstate.s1assured &amp;&amp; s2fs1mro &amp;&amp; protectedbit == '1') then
        nextstate.s1assured = TRUE;
    else
        nextstate.s1assured = FALSE;
    end;

    if walkparams.pnch == '1' || currentstate.disch == '1' then
        nextstate.contiguous = '0';
    else
        nextstate.contiguous = <a href="shared_pseudocode.html#func_AArch64_ContiguousBit_5" title="">AArch64_ContiguousBit</a>{N}(walkparams.tgx, walkparams.d128,
                                                        currentstate.level, descriptor);
    end;
    if !<a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime) then
        nextstate.nG = '0';
    elsif accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> &amp;&amp; currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> then
        // In Secure state, a translation must be treated as non-global,
        // regardless of the value of the nG bit,
        // if NSTable is set to 1 at any level of the translation table walk
        nextstate.nG = '1';
    elsif walkparams.fng == '1' then
        // Translations are treated as non-global regardless of the value of the nG bit.
        nextstate.nG = '1';
    elsif (regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().VM == '1' &amp;&amp;
            (walkparams.d128 == '1' || walkparams.pnch == '1') &amp;&amp;
            !nextstate.s1assured &amp;&amp; walkparams.fngna == '1') then
        // Translations are treated as non-global regardless of the value of the nG bit.
        nextstate.nG = '1';
    else
        nextstate.nG = descriptor[11];
    end;

    if walkparams.d128 == '1' then
        nextstate.guardedpage = descriptor[113];
    else
        nextstate.guardedpage = descriptor[50];
    end;

    return nextstate;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64_S1NextWalkStateTable"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64_S1NextWalkStateTable</h3>
      <p class="pseudocode">// AArch64_S1NextWalkStateTable()
// ==============================
// Decode stage 1 table descriptor to transition to the next level

func <a id="func_AArch64_S1NextWalkStateTable_6"/>AArch64_S1NextWalkStateTable{N}(currentstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, s2fs1mro : boolean, regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                                     walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>, descriptor : bits(N)) =&gt; <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>
begin
    var nextstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    var tablebase : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;
    let skl : bits(2) = if walkparams.d128 == '1' then descriptor[110:109] else '00';
    tablebase.address = AArch64_NextTableBase{N}(descriptor, walkparams.d128, skl, walkparams.ds,
                                                 walkparams.tgx);

    if currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then
        // Determine PA space of the next table from NSTable bit
        var nstable : bit;
        nstable = if walkparams.d128 == '1' then descriptor[127] else descriptor[63];
        tablebase.paspace = if nstable == '0' then <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> else <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
    else
        // Otherwise bit 63 is RES0 and there is no NSTable bit
        tablebase.paspace = currentstate.baseaddress.paspace;
    end;

    nextstate.istable     = TRUE;
    nextstate.nG          = currentstate.nG;
    if walkparams.d128 == '1' then
        nextstate.level   = currentstate.level + UInt(skl) + 1;
    else
        nextstate.level   = currentstate.level + 1;
    end;
    nextstate.baseaddress = tablebase;
    nextstate.memattrs    = currentstate.memattrs;
    if walkparams.hpd == '0' &amp;&amp; walkparams.pie == '0' then
        nextstate.permissions = <a href="shared_pseudocode.html#func_AArch64_S1ApplyTablePerms_4" title="">AArch64_S1ApplyTablePerms</a>(currentstate.permissions,
                                                          descriptor[63:0], regime, walkparams);
    else
        nextstate.permissions = currentstate.permissions;
    end;
    var protectedbit : bit;
    if walkparams.d128 == '1' then
        protectedbit = descriptor[114];
    else
        protectedbit = if walkparams.pnch == '1' then descriptor[52] else '0';
    end;
    if (currentstate.s1assured &amp;&amp; s2fs1mro &amp;&amp; protectedbit == '1') then
        nextstate.s1assured = TRUE;
    else
        nextstate.s1assured = FALSE;
    end;
    nextstate.disch = if walkparams.d128 == '1' then descriptor[112] else '0';

    return nextstate;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64_S1Walk"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64_S1Walk</h3>
      <p class="pseudocode">// AArch64_S1Walk()
// ================
// Traverse stage 1 translation tables obtaining the final descriptor
// as well as the address leading to that descriptor

func <a id="func_AArch64_S1Walk_6"/>AArch64_S1Walk{N : integer{64, 128}}(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>,
                                          walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>,
                                          va : bits(64), regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
                                          accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
                                         ) =&gt; (<a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, bits(N))
begin
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    var aligned : boolean;

    if <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime) &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_S1EPD_2" title="">AArch64_S1EPD</a>(regime, va) == '1' then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, ARBITRARY : bits(N));
    end;

    var walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a> = <a href="shared_pseudocode.html#func_AArch64_S1InitialTTWState_4" title="">AArch64_S1InitialTTWState</a>(walkparams, va, regime, accdesc.ss);
    let startlevel : integer = walkstate.level;

    if startlevel &gt; 3 then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, ARBITRARY : bits(N));
    end;

    var descriptor : bits(N);
    var walkaddress : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    var skl : bits(2) = '00';
    walkaddress.vaddress = va;
    walkaddress.mecid = <a href="shared_pseudocode.html#func_AArch64_S1TTWalkMECID_3" title="">AArch64_S1TTWalkMECID</a>(walkparams.emec, regime, accdesc.ss);

    if !<a href="shared_pseudocode.html#func_AArch64_S1DCacheEnabled_1" title="">AArch64_S1DCacheEnabled</a>(regime) then
        walkaddress.memattrs = <a href="shared_pseudocode.html#func_NormalNCMemAttr_0" title="">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;
    end;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().VM == '1' &amp;&amp;
            !(ImpDefBool("Apply effective shareability at stage 1"))) then
        walkaddress.memattrs.shareability = walkstate.memattrs.shareability;
    else
        walkaddress.memattrs.shareability = <a href="shared_pseudocode.html#func_EffectiveShareability_1" title="">EffectiveShareability</a>(walkaddress.memattrs);
    end;

    var s2fs1mro : boolean = FALSE;

    var desctype : <a href="shared_pseudocode.html#type_DescriptorType" title="">DescriptorType</a>;
    var descaddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a> = AArch64_S1SLTTEntryAddress(walkstate.level, walkparams, va,
                                                         walkstate.baseaddress);

    // Detect Address Size Fault by Descriptor Address
    if <a href="shared_pseudocode.html#func_AArch64_S1OAOutOfRange_2" title="">AArch64_S1OAOutOfRange</a>(descaddress.address, walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AddressSize" title="">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, ARBITRARY : bits(N));
    end;

    repeat
        fault.level = walkstate.level;
        walkaddress.paddress = descaddress;
        walkaddress.s1assured = walkstate.s1assured;

        let toplevel : boolean = walkstate.level == startlevel;
        let varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a>  = <a href="shared_pseudocode.html#func_AArch64_GetVARange_1" title="">AArch64_GetVARange</a>(va);
        let walkaccess : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescS1TTW_3" title="">CreateAccDescS1TTW</a>(toplevel, varange, accdesc);
        var s2fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>;
        var s2walkaddress : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
        if regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
            let s1aarch64 : boolean = TRUE;
            aligned   = TRUE;
            (s2fault, s2walkaddress) = <a href="shared_pseudocode.html#func_AArch64_S2Translate_5" title="">AArch64_S2Translate</a>(fault, walkaddress, s1aarch64, aligned,
                                                           walkaccess);

            if s2fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
                return (s2fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>,
                        ARBITRARY : bits(N));
            end;

            s2fs1mro = s2walkaddress.s2fs1mro;
            (fault, descriptor) = <a href="shared_pseudocode.html#func_FetchDescriptor_5" title="">FetchDescriptor</a>{N}(walkparams.ee, s2walkaddress, walkaccess,
                                                    fault);
        else
            (fault, descriptor) = <a href="shared_pseudocode.html#func_FetchDescriptor_5" title="">FetchDescriptor</a>{N}(walkparams.ee, walkaddress, walkaccess,
                                                     fault);
        end;

        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>,
                    ARBITRARY : bits(N));
        end;

        var new_descriptor : bits(N);
        repeat
            new_descriptor = descriptor;
            desctype = <a href="shared_pseudocode.html#func_AArch64_DecodeDescriptorType_6" title="">AArch64_DecodeDescriptorType</a>{N}(descriptor, walkparams.d128, walkparams.ds,
                                                       walkparams.tgx, walkstate.level);
            case desctype of
                when <a href="shared_pseudocode.html#enum_DescriptorType_Table" title="">DescriptorType_Table</a> =&gt;
                    walkstate = <a href="shared_pseudocode.html#func_AArch64_S1NextWalkStateTable_6" title="">AArch64_S1NextWalkStateTable</a>{N}(walkstate, s2fs1mro,
                                                                regime, walkparams, descriptor);
                    skl = if walkparams.d128 == '1' then descriptor[110:109] else '00';
                    descaddress = AArch64_S1TTEntryAddress{N}(walkstate.level, walkparams, skl, va,
                                                              walkstate.baseaddress, descriptor);

                    // Detect Address Size Fault by Descriptor Address
                    if <a href="shared_pseudocode.html#func_AArch64_S1OAOutOfRange_2" title="">AArch64_S1OAOutOfRange</a>(descaddress.address, walkparams) then
                        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AddressSize" title="">Fault_AddressSize</a>;
                        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>,
                                ARBITRARY : bits(N));
                    end;

                    if walkparams.haft == '1' then
                        new_descriptor[10] = '1';
                    end;
                    if (walkparams.d128 == '1' &amp;&amp; skl != '00' &amp;&amp;
                          <a href="shared_pseudocode.html#func_AArch64_nTFaults_3" title="">AArch64_nTFaults</a>{N}(walkparams.d128, descriptor)) then
                        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
                        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>,
                                ARBITRARY : bits(N));
                    end;
                when <a href="shared_pseudocode.html#enum_DescriptorType_Leaf" title="">DescriptorType_Leaf</a> =&gt;
                    walkstate = <a href="shared_pseudocode.html#func_AArch64_S1NextWalkStateLeaf_7" title="">AArch64_S1NextWalkStateLeaf</a>{N}(walkstate, s2fs1mro, regime, accdesc,
                                                               walkparams, descriptor);
                when <a href="shared_pseudocode.html#enum_DescriptorType_Invalid" title="">DescriptorType_Invalid</a> =&gt;
                    fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
                    return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>,
                            ARBITRARY : bits(N));
                otherwise =&gt;
                    unreachable;
            end;

            if new_descriptor != descriptor then
                var descpaddr : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
                let descaccess : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescTTEUpdate_1" title="">CreateAccDescTTEUpdate</a>(accdesc);
                if regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
                    let s1aarch64 : boolean = TRUE;
                    aligned   = TRUE;
                    (s2fault, descpaddr) = <a href="shared_pseudocode.html#func_AArch64_S2Translate_5" title="">AArch64_S2Translate</a>(fault, walkaddress,
                                                               s1aarch64, aligned,
                                                               descaccess);

                    if s2fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
                        return (s2fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                                ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, ARBITRARY : bits(N));
                    end;
                else
                    descpaddr = walkaddress;
                end;

                (fault, descriptor) = <a href="shared_pseudocode.html#func_AArch64_MemSwapTableDesc_7" title="">AArch64_MemSwapTableDesc</a>{N}(fault, descriptor, new_descriptor,
                                                                  walkparams.ee, descaccess,
                                                                  descpaddr);
                if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
                    return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                            ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, ARBITRARY : bits(N));
                end;
            end;
        until new_descriptor == descriptor looplimit Unbounded_DescriptorUpdate;
    until desctype == <a href="shared_pseudocode.html#enum_DescriptorType_Leaf" title="">DescriptorType_Leaf</a> looplimit MAX_WALK_LEVELS;

    let oa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a> = StageOA(va, walkparams.d128, walkparams.tgx, walkstate);
    if (walkstate.contiguous == '1' &amp;&amp;
        AArch64_ContiguousBitFaults(walkparams.d128, walkparams.txsz, walkparams.tgx,
                                    walkstate.level)) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
    elsif walkstate.level &lt; <a href="shared_pseudocode.html#global_FINAL_LEVEL" title="">FINAL_LEVEL</a> &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_nTFaults_3" title="">AArch64_nTFaults</a>{N}(walkparams.d128, descriptor) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
    elsif <a href="shared_pseudocode.html#func_AArch64_S1AMECFault_5" title="">AArch64_S1AMECFault</a>{N}(walkparams, walkstate.baseaddress.paspace, regime, descriptor) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
    // Detect Address Size Fault by final output
    elsif <a href="shared_pseudocode.html#func_AArch64_S1OAOutOfRange_2" title="">AArch64_S1OAOutOfRange</a>(oa.address, walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AddressSize" title="">Fault_AddressSize</a>;
    // Check descriptor AF bit
    elsif (descriptor[10] == '0' &amp;&amp; walkparams.ha == '0' &amp;&amp;
            (!accdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>} ||
             ImpDefBool("Generate access flag fault on IC/DC operations"))) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AccessFlag" title="">Fault_AccessFlag</a>;
    end;

    if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, ARBITRARY : bits(N));
    end;

    return (fault, walkaddress, walkstate, descriptor);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64_S2InitialTTWState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64_S2InitialTTWState</h3>
      <p class="pseudocode">// AArch64_S2InitialTTWState()
// ===========================
// Set properties of first access to translation tables in stage 2

func <a id="func_AArch64_S2InitialTTWState_2"/>AArch64_S2InitialTTWState(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>) =&gt; <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>
begin
    var walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    var tablebase : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;
    var ttbr : bits(128);

    ttbr = ZeroExtend{128}(VTTBR_EL2());
    case ss of
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt; tablebase.paspace = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a>     =&gt; tablebase.paspace = <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>;
    end;
    tablebase.address = AArch64_S2TTBaseAddress{128}(walkparams, tablebase.paspace, ttbr);

    walkstate.baseaddress = tablebase;
    walkstate.level       = AArch64_S2StartLevel(walkparams);
    walkstate.istable     = TRUE;
    walkstate.memattrs    = <a href="shared_pseudocode.html#func_WalkMemAttrs_3" title="">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);

    return walkstate;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64_S2NextWalkStateLeaf"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64_S2NextWalkStateLeaf</h3>
      <p class="pseudocode">// AArch64_S2NextWalkStateLeaf()
// =============================
// Decode stage 2 page or block descriptor as output to this stage of translation

func <a id="func_AArch64_S2NextWalkStateLeaf_6"/>AArch64_S2NextWalkStateLeaf{N}(currentstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>,
                                    walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>, ipa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                                    descriptor : bits(N)) =&gt; <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>
begin
    var nextstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    var baseaddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;

    if ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
        baseaddress.paspace = <a href="shared_pseudocode.html#func_AArch64_SS2OutputPASpace_2" title="">AArch64_SS2OutputPASpace</a>(walkparams, ipa.paddress.paspace);
    elsif ss == <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> then
        var ns : bit;
        ns = if walkparams.d128 == '1' then descriptor[127] else descriptor[55];
        baseaddress.paspace = if ns == '1' then <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> else <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>;
    else
        baseaddress.paspace = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
    end;
    baseaddress.address   = AArch64_S2LeafBase{N}(descriptor, walkparams, currentstate.level);

    nextstate.istable     = FALSE;
    nextstate.level       = currentstate.level;
    nextstate.baseaddress = baseaddress;
    nextstate.permissions = <a href="shared_pseudocode.html#func_AArch64_S2ApplyOutputPerms_3" title="">AArch64_S2ApplyOutputPerms</a>{N}(descriptor, walkparams);

    let s2_attr : bits(4) = descriptor[5:2];
    let s2_sh : bits(2)   = if walkparams.ds == '1' then walkparams.sh else descriptor[9:8];
    let s2_fnxs : bit     = descriptor[11];
    if walkparams.fwb == '1' then
        nextstate.memattrs = <a href="shared_pseudocode.html#func_AArch64_S2ApplyFWBMemAttrs_4" title="">AArch64_S2ApplyFWBMemAttrs</a>{N}(ipa.memattrs, walkparams, descriptor);
        if s2_attr[3:1] == '111' then
            nextstate.permissions.s2tag_na = '1';
        else
            nextstate.permissions.s2tag_na = '0';
        end;
    else
        let s2aarch64 : boolean = TRUE;
        nextstate.memattrs = <a href="shared_pseudocode.html#func_S2DecodeMemAttrs_3" title="">S2DecodeMemAttrs</a>(s2_attr, s2_sh, s2aarch64);
        // FnXS is used later to mask the XS value from stage 1
        nextstate.memattrs.xs = NOT s2_fnxs;
        if s2_attr == '0100' then
            nextstate.permissions.s2tag_na = '1';
        else
            nextstate.permissions.s2tag_na = '0';
        end;
    end;
    nextstate.contiguous = <a href="shared_pseudocode.html#func_AArch64_ContiguousBit_5" title="">AArch64_ContiguousBit</a>{N}(walkparams.tgx, walkparams.d128,
                                                    currentstate.level, descriptor);
    if walkparams.d128 == '1' then
        nextstate.s2assuredonly = descriptor[114];
    else
        nextstate.s2assuredonly = if walkparams.assuredonly == '1' then descriptor[58] else '0';
    end;

    return nextstate;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64_S2NextWalkStateTable"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64_S2NextWalkStateTable</h3>
      <p class="pseudocode">// AArch64_S2NextWalkStateTable()
// ==============================
// Decode stage 2 table descriptor to transition to the next level

func <a id="func_AArch64_S2NextWalkStateTable_4"/>AArch64_S2NextWalkStateTable{N}(currentstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>,
                                     descriptor : bits(N)) =&gt; <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>
begin
    var nextstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    var tablebase : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;
    let skl : bits(2) = if walkparams.d128 == '1' then descriptor[110:109] else '00';
    tablebase.address = AArch64_NextTableBase{N}(descriptor, walkparams.d128, skl, walkparams.ds,
                                                 walkparams.tgx);

    tablebase.paspace = currentstate.baseaddress.paspace;

    nextstate.istable     = TRUE;
    if walkparams.d128 == '1' then
        nextstate.level   = currentstate.level + UInt(skl) + 1;
    else
        nextstate.level   = currentstate.level + 1;
    end;
    nextstate.baseaddress = tablebase;
    nextstate.memattrs    = currentstate.memattrs;

    return nextstate;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64_S2Walk"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64_S2Walk</h3>
      <p class="pseudocode">// AArch64_S2Walk()
// ================
// Traverse stage 2 translation tables obtaining the final descriptor
// as well as the address leading to that descriptor

func <a id="func_AArch64_S2Walk_5"/>AArch64_S2Walk{N : integer{64, 128}}(fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>,
                                          ipa : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                                          walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>,
                                          accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; (<a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>,
                                                                          <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                                                                          <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>,
                                                                          bits(N))
begin

    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;
    let ipa_64 : bits(64) = ZeroExtend{}(ipa.paddress.address);

    var walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    if accdesc.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
        walkstate = <a href="shared_pseudocode.html#func_AArch64_SS2InitialTTWState_2" title="">AArch64_SS2InitialTTWState</a>(walkparams, ipa.paddress.paspace);
    else
        walkstate = <a href="shared_pseudocode.html#func_AArch64_S2InitialTTWState_2" title="">AArch64_S2InitialTTWState</a>(accdesc.ss, walkparams);
    end;
    let startlevel : integer = walkstate.level;

    if startlevel &gt; 3 then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, ARBITRARY : bits(N));
    end;

    var descriptor : bits(N);
    let walkaccess : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescS2TTW_1" title="">CreateAccDescS2TTW</a>(accdesc);
    var walkaddress : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    var skl : bits(2) = '00';

    walkaddress.vaddress = ipa.vaddress;
    walkaddress.mecid = <a href="shared_pseudocode.html#func_AArch64_S2TTWalkMECID_2" title="">AArch64_S2TTWalkMECID</a>(walkparams.emec, accdesc.ss);

    if !<a href="shared_pseudocode.html#func_S2DCacheEnabled_0" title="">S2DCacheEnabled</a>() then
        walkaddress.memattrs = <a href="shared_pseudocode.html#func_NormalNCMemAttr_0" title="">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;
    end;

    walkaddress.memattrs.shareability = <a href="shared_pseudocode.html#func_EffectiveShareability_1" title="">EffectiveShareability</a>(walkaddress.memattrs);

    var desctype : <a href="shared_pseudocode.html#type_DescriptorType" title="">DescriptorType</a>;

    // Initial lookup might index into concatenated tables
    var descaddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a> = AArch64_S2SLTTEntryAddress(walkparams, ipa.paddress.address,
                                                               walkstate.baseaddress);

    // Detect Address Size Fault by Descriptor Address
    if <a href="shared_pseudocode.html#func_AArch64_S2OAOutOfRange_2" title="">AArch64_S2OAOutOfRange</a>(descaddress.address, walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AddressSize" title="">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, ARBITRARY : bits(N));
    end;

    repeat
        fault.level = walkstate.level;
        walkaddress.paddress = descaddress;
        (fault, descriptor) = <a href="shared_pseudocode.html#func_FetchDescriptor_5" title="">FetchDescriptor</a>{N}(walkparams.ee, walkaddress, walkaccess, fault);

        if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
            return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                    ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, ARBITRARY : bits(N));
        end;

        var new_descriptor : bits(N);
        repeat
            new_descriptor = descriptor;
            desctype = <a href="shared_pseudocode.html#func_AArch64_DecodeDescriptorType_6" title="">AArch64_DecodeDescriptorType</a>{N}(descriptor, walkparams.d128, walkparams.ds,
                                                       walkparams.tgx, walkstate.level);
            case desctype of
                when <a href="shared_pseudocode.html#enum_DescriptorType_Table" title="">DescriptorType_Table</a> =&gt;
                    walkstate = <a href="shared_pseudocode.html#func_AArch64_S2NextWalkStateTable_4" title="">AArch64_S2NextWalkStateTable</a>{N}(walkstate, walkparams, descriptor);
                    skl = if walkparams.d128 == '1' then descriptor[110:109] else '00';
                    descaddress = AArch64_S2TTEntryAddress(walkstate.level, walkparams, skl,
                                                           ipa.paddress.address,
                                                           walkstate.baseaddress);

                    // Detect Address Size Fault by table descriptor
                    if <a href="shared_pseudocode.html#func_AArch64_S2OAOutOfRange_2" title="">AArch64_S2OAOutOfRange</a>(descaddress.address, walkparams) then
                        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AddressSize" title="">Fault_AddressSize</a>;
                        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>,
                                ARBITRARY : bits(N));
                    end;

                    if walkparams.haft == '1' then
                        new_descriptor[10] = '1';
                    end;

                    if (walkparams.d128 == '1' &amp;&amp; skl != '00' &amp;&amp;
                          <a href="shared_pseudocode.html#func_AArch64_nTFaults_3" title="">AArch64_nTFaults</a>{N}(walkparams.d128, descriptor)) then
                        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
                        return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>,
                                ARBITRARY : bits(N));
                    end;

                when <a href="shared_pseudocode.html#enum_DescriptorType_Leaf" title="">DescriptorType_Leaf</a> =&gt;
                    walkstate = <a href="shared_pseudocode.html#func_AArch64_S2NextWalkStateLeaf_6" title="">AArch64_S2NextWalkStateLeaf</a>{N}(walkstate, accdesc.ss, walkparams,
                                                               ipa, descriptor);
                when <a href="shared_pseudocode.html#enum_DescriptorType_Invalid" title="">DescriptorType_Invalid</a> =&gt;
                    fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
                    return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                            ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, ARBITRARY : bits(N));

                otherwise =&gt;
                    unreachable;
            end;

            if new_descriptor != descriptor then
                let descaccess : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescTTEUpdate_1" title="">CreateAccDescTTEUpdate</a>(accdesc);
                (fault, descriptor) = <a href="shared_pseudocode.html#func_AArch64_MemSwapTableDesc_7" title="">AArch64_MemSwapTableDesc</a>{N}(fault, descriptor, new_descriptor,
                                                                  walkparams.ee, descaccess,
                                                                  walkaddress);
                if fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a> then
                    return (fault, ARBITRARY : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                            ARBITRARY : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>, ARBITRARY : bits(N));
                end;
            end;
        until new_descriptor == descriptor looplimit Unbounded_DescriptorUpdate;
    until desctype == <a href="shared_pseudocode.html#enum_DescriptorType_Leaf" title="">DescriptorType_Leaf</a> looplimit MAX_WALK_LEVELS;

    let oa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a> = StageOA(ipa_64, walkparams.d128, walkparams.tgx, walkstate);
    if (walkstate.contiguous == '1' &amp;&amp;
        AArch64_ContiguousBitFaults(walkparams.d128, walkparams.txsz, walkparams.tgx,
                                    walkstate.level)) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
    elsif walkstate.level &lt; <a href="shared_pseudocode.html#global_FINAL_LEVEL" title="">FINAL_LEVEL</a> &amp;&amp; <a href="shared_pseudocode.html#func_AArch64_nTFaults_3" title="">AArch64_nTFaults</a>{N}(walkparams.d128, descriptor) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>;
    // Detect Address Size Fault by final output
    elsif <a href="shared_pseudocode.html#func_AArch64_S2OAOutOfRange_2" title="">AArch64_S2OAOutOfRange</a>(oa.address, walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AddressSize" title="">Fault_AddressSize</a>;
    // Check descriptor AF bit
    elsif (descriptor[10] == '0' &amp;&amp; walkparams.ha == '0' &amp;&amp;
            (!accdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>} ||
             ImpDefBool("Generate access flag fault on IC/DC operations"))) then
        fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AccessFlag" title="">Fault_AccessFlag</a>;
    end;

    return (fault, walkaddress, walkstate, descriptor);
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64_SS2InitialTTWState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64_SS2InitialTTWState</h3>
      <p class="pseudocode">// AArch64_SS2InitialTTWState()
// ============================
// Set properties of first access to translation tables in Secure stage 2

func <a id="func_AArch64_SS2InitialTTWState_2"/>AArch64_SS2InitialTTWState(walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>, ipaspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>) =&gt; <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>
begin
    var walkstate : <a href="shared_pseudocode.html#type_TTWState" title="">TTWState</a>;
    var tablebase : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;
    var ttbr : bits(128);

    if ipaspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then
        ttbr = ZeroExtend{128}(VSTTBR_EL2());
    else
        ttbr = ZeroExtend{128}(VTTBR_EL2());
    end;

    if ipaspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then
        if walkparams.sw == '0' then
            tablebase.paspace = <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
        else
            tablebase.paspace = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        end;
    else
        if walkparams.nsw == '0' then
            tablebase.paspace = <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
        else
            tablebase.paspace = <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        end;
    end;
    tablebase.address = AArch64_S2TTBaseAddress{128}(walkparams, tablebase.paspace, ttbr);

    walkstate.baseaddress = tablebase;
    walkstate.level       = AArch64_S2StartLevel(walkparams);
    walkstate.istable     = TRUE;
    walkstate.memattrs    = <a href="shared_pseudocode.html#func_WalkMemAttrs_3" title="">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);

    return walkstate;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64_SS2OutputPASpace"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64_SS2OutputPASpace</h3>
      <p class="pseudocode">// AArch64_SS2OutputPASpace()
// ==========================
// Assign PA Space to output of Secure stage 2 translation

func <a id="func_AArch64_SS2OutputPASpace_2"/>AArch64_SS2OutputPASpace(walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>, ipaspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>) =&gt; <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>
begin
    if ipaspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then
        if walkparams.[sw,sa] == '00' then
            return <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
        else
            return <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        end;
    else
        if walkparams.[sw,sa,nsw,nsa] == '0000' then
            return <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
        else
            return <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_GetS1TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_GetS1TTWParams</h3>
      <p class="pseudocode">// AArch64_GetS1TTWParams()
// ========================
// Returns stage 1 translation table walk parameters from respective controlling
// System registers.

func <a id="func_AArch64_GetS1TTWParams_4"/>AArch64_GetS1TTWParams(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, el : bits(2),
                            ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, va : bits(64)) =&gt; <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>
begin
    var walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>;

    let varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a> = <a href="shared_pseudocode.html#func_AArch64_GetVARange_1" title="">AArch64_GetVARange</a>(va);

    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> =&gt;  walkparams = <a href="shared_pseudocode.html#func_AArch64_S1TTWParamsEL3_0" title="">AArch64_S1TTWParamsEL3</a>();
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;  walkparams = <a href="shared_pseudocode.html#func_AArch64_S1TTWParamsEL2_1" title="">AArch64_S1TTWParamsEL2</a>(ss);
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt; walkparams = <a href="shared_pseudocode.html#func_AArch64_S1TTWParamsEL20_3" title="">AArch64_S1TTWParamsEL20</a>(el, ss, varange);
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; walkparams = <a href="shared_pseudocode.html#func_AArch64_S1TTWParamsEL10_2" title="">AArch64_S1TTWParamsEL10</a>(el, varange);
    end;

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_GetS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_GetS2TTWParams</h3>
      <p class="pseudocode">// AArch64_GetS2TTWParams()
// ========================
// Gather walk parameters for stage 2 translation

func <a id="func_AArch64_GetS2TTWParams_3"/>AArch64_GetS2TTWParams(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, ipaspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>,
                            s1aarch64 : boolean) =&gt; <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>
begin
    var walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>;

    if ss == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> then
        walkparams = <a href="shared_pseudocode.html#func_AArch64_NSS2TTWParams_1" title="">AArch64_NSS2TTWParams</a>(s1aarch64);
    elsif IsFeatureImplemented(FEAT_SEL2) &amp;&amp; ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
        walkparams = <a href="shared_pseudocode.html#func_AArch64_SS2TTWParams_2" title="">AArch64_SS2TTWParams</a>(ipaspace, s1aarch64);
    elsif ss == <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> then
        walkparams = <a href="shared_pseudocode.html#func_AArch64_RLS2TTWParams_1" title="">AArch64_RLS2TTWParams</a>(s1aarch64);
    else
        unreachable;
    end;

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_GetVARange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_GetVARange</h3>
      <p class="pseudocode">// AArch64_GetVARange()
// ====================
// Determines if the VA that is to be translated lies in LOWER or UPPER address range.

func <a id="func_AArch64_GetVARange_1"/>AArch64_GetVARange(va : bits(64)) =&gt; <a href="shared_pseudocode.html#type_VARange" title="">VARange</a>
begin
    if va[55] == '0' then
        return <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a>;
    else
        return <a href="shared_pseudocode.html#enum_VARange_UPPER" title="">VARange_UPPER</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_HaveS1TG"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_HaveS1TG</h3>
      <p class="pseudocode">// AArch64_HaveS1TG()
// ==================
// Determine whether the given translation granule is supported for stage 1

func <a id="func_AArch64_HaveS1TG_1"/>AArch64_HaveS1TG(tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>) =&gt; boolean
begin
    case tgx of
        when <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a> =&gt;  return IsFeatureImplemented(FEAT_TGran4K);
        when <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a> =&gt; return IsFeatureImplemented(FEAT_TGran16K);
        when <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> =&gt; return IsFeatureImplemented(FEAT_TGran64K);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_HaveS2TG"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_HaveS2TG</h3>
      <p class="pseudocode">// AArch64_HaveS2TG()
// ==================
// Determine whether the given translation granule is supported for stage 2

func <a id="func_AArch64_HaveS2TG_1"/>AArch64_HaveS2TG(tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>) =&gt; boolean
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);

    if IsFeatureImplemented(FEAT_GTG) then
        case tgx of
            when <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a> =&gt;  return IsFeatureImplemented(FEAT_S2TGran4K);
            when <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a> =&gt; return IsFeatureImplemented(FEAT_S2TGran16K);
            when <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> =&gt; return IsFeatureImplemented(FEAT_S2TGran64K);
        end;
    else
        return <a href="shared_pseudocode.html#func_AArch64_HaveS1TG_1" title="">AArch64_HaveS1TG</a>(tgx);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_MaxTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_MaxTxSZ</h3>
      <p class="pseudocode">// AArch64_MaxTxSZ()
// =================
// Retrieve the maximum value of TxSZ indicating minimum input address size for both
// stages of translation

func <a id="func_AArch64_MaxTxSZ_1"/>AArch64_MaxTxSZ(tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>) =&gt; integer
begin
    if IsFeatureImplemented(FEAT_TTST) then
        case tgx of
            when <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>  =&gt; return 48;
            when <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a> =&gt; return 48;
            when <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> =&gt; return 47;
        end;
    end;

    return 39;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_NSS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_NSS2TTWParams</h3>
      <p class="pseudocode">// AArch64_NSS2TTWParams()
// =======================
// Gather walk parameters specific for Non-secure stage 2 translation

func <a id="func_AArch64_NSS2TTWParams_1"/>AArch64_NSS2TTWParams(s1aarch64 : boolean) =&gt; <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>
begin
    var walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>;

    walkparams.vm   = HCR_EL2().VM OR HCR_EL2().DC;
    walkparams.tgx  = <a href="shared_pseudocode.html#func_AArch64_S2DecodeTG0_1" title="">AArch64_S2DecodeTG0</a>(VTCR_EL2().TG0);
    walkparams.txsz = VTCR_EL2().T0SZ;
    walkparams.ps   = VTCR_EL2().PS;
    walkparams.irgn = VTCR_EL2().IRGN0;
    walkparams.orgn = VTCR_EL2().ORGN0;
    walkparams.sh   = VTCR_EL2().SH0;
    walkparams.ee   = SCTLR_EL2().EE;
    walkparams.d128 = if IsFeatureImplemented(FEAT_D128)  then VTCR_EL2().D128 else '0';
    if walkparams.d128 == '1' then
        walkparams.skl = VTTBR_EL2().SKL;
    else
        walkparams.sl0 = VTCR_EL2().SL0;
    end;

    walkparams.ptw = if HCR_EL2().TGE == '0'                then HCR_EL2().PTW else '0';
    walkparams.fwb = if IsFeatureImplemented(FEAT_S2FWB)  then HCR_EL2().FWB else '0';
    walkparams.ha  = if IsFeatureImplemented(FEAT_HAFDBS) then VTCR_EL2().HA else '0';
    walkparams.hd  = if walkparams.ha == '1' then VTCR_EL2().HD else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>, <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>} &amp;&amp; IsFeatureImplemented(FEAT_LPA2) then
        walkparams.ds = VTCR_EL2().DS;
    else
        walkparams.ds = '0';
    end;
    if walkparams.tgx == <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a> &amp;&amp; IsFeatureImplemented(FEAT_LPA2) then
        walkparams.sl2 = VTCR_EL2().SL2 AND VTCR_EL2().DS;
    else
        walkparams.sl2 = '0';
    end;
    walkparams.cmow = (if IsFeatureImplemented(FEAT_CMOW) &amp;&amp; <a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() then HCRX_EL2().CMOW
                       else '0');
    if walkparams.d128 == '1' then
        walkparams.s2pie = '1';
    else
        walkparams.s2pie = if IsFeatureImplemented(FEAT_S2PIE) then VTCR_EL2().S2PIE else '0';
    end;
    if IsFeatureImplemented(FEAT_S2PIE) then
        if !(<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().PIEn == '0' &amp;&amp;
              ImpDefBool("SCR_EL3.PIEn forces PIE/POE_ELx to zero")) then
            walkparams.s2pir = S2PIR_EL2() as S2PIRType;
        else
            walkparams.s2pir = Zeros{64} as S2PIRType;
        end;
    end;
    if IsFeatureImplemented(FEAT_THE) &amp;&amp; walkparams.d128 != '1' then
        walkparams.assuredonly = VTCR_EL2().AssuredOnly;
    else
        walkparams.assuredonly = '0';
    end;
    walkparams.tl0   = if IsFeatureImplemented(FEAT_THE) then VTCR_EL2().TL0 else '0';
    walkparams.tl1   = if IsFeatureImplemented(FEAT_THE) then VTCR_EL2().TL1 else '0';
    if IsFeatureImplemented(FEAT_HAFT) &amp;&amp; walkparams.ha == '1' then
        walkparams.haft = VTCR_EL2().HAFT;
    else
        walkparams.haft = '0';
    end;
    if (IsFeatureImplemented(FEAT_HDBSS) &amp;&amp; walkparams.hd == '1' &amp;&amp;
          (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || SCR_EL3().HDBSSEn == '1')) then
        walkparams.hdbss = VTCR_EL2().HDBSS;
    else
        walkparams.hdbss = '0';
    end;

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_PAMax"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_PAMax</h3>
      <p class="pseudocode">// AArch64_PAMax()
// ===============
// Returns the IMPLEMENTATION DEFINED maximum number of bits capable of representing
// physical address for this PE

func AArch64_PAMax() =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    return ImpDefInt("Maximum Physical Address Size") as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_RLS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_RLS2TTWParams</h3>
      <p class="pseudocode">// AArch64_RLS2TTWParams()
// =======================
// Gather walk parameters specific for Realm stage 2 translation

func <a id="func_AArch64_RLS2TTWParams_1"/>AArch64_RLS2TTWParams(s1aarch64 : boolean) =&gt; <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>
begin
    // Realm stage 2 walk parameters are similar to Non-secure
    var walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a> = <a href="shared_pseudocode.html#func_AArch64_NSS2TTWParams_1" title="">AArch64_NSS2TTWParams</a>(s1aarch64);
    walkparams.emec = (if IsFeatureImplemented(FEAT_MEC) &amp;&amp;
                       <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then SCTLR2_EL2().EMEC else '0');
    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1DCacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1DCacheEnabled</h3>
      <p class="pseudocode">// AArch64_S1DCacheEnabled()
// =========================
// Determine cacheability of stage 1 data accesses

func <a id="func_AArch64_S1DCacheEnabled_1"/>AArch64_S1DCacheEnabled(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>) =&gt; boolean
begin
    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a>  =&gt; return SCTLR_EL3().C == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>  =&gt; return SCTLR_EL2().C == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt; return SCTLR_EL2().C == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; return SCTLR_EL1().C == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1DecodeTG0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1DecodeTG0</h3>
      <p class="pseudocode">// AArch64_S1DecodeTG0()
// =====================
// Decode stage 1 granule size configuration bits TG0

func <a id="func_AArch64_S1DecodeTG0_1"/>AArch64_S1DecodeTG0(tg0_in : bits(2)) =&gt; <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>
begin
    var tg0 : bits(2) = tg0_in;
    var tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>;

    if tg0 == '11' then
        tg0 = ImpDefBits{2}("TG0 encoded granule size");
    end;

    case tg0 of
        when '00' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
        when '01' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a>;
        when '10' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>;
    end;

    if !<a href="shared_pseudocode.html#func_AArch64_HaveS1TG_1" title="">AArch64_HaveS1TG</a>(tgx) then
        case ImpDefBits{2}("TG0 encoded granule size") of
            when '00' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
            when '01' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a>;
            when '10' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>;
        end;
    end;

    return tgx;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1DecodeTG1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1DecodeTG1</h3>
      <p class="pseudocode">// AArch64_S1DecodeTG1()
// =====================
// Decode stage 1 granule size configuration bits TG1

func <a id="func_AArch64_S1DecodeTG1_1"/>AArch64_S1DecodeTG1(tg1_in : bits(2)) =&gt; <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>
begin
    var tg1 : bits(2) = tg1_in;
    var tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>;

    if tg1 == '00' then
        tg1 = ImpDefBits{2}("TG1 encoded granule size");
    end;

    case tg1 of
        when '10' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
        when '11' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a>;
        when '01' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>;
    end;

    if !<a href="shared_pseudocode.html#func_AArch64_HaveS1TG_1" title="">AArch64_HaveS1TG</a>(tgx) then
        case ImpDefBits{2}("TG1 encoded granule size") of
            when '10' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
            when '11' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a>;
            when '01' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>;
        end;
    end;

    return tgx;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1E0POEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1E0POEnabled</h3>
      <p class="pseudocode">// AArch64_S1E0POEnabled()
// =======================
// Determine whether stage 1 unprivileged permission overlay is enabled

func <a id="func_AArch64_S1E0POEnabled_2"/>AArch64_S1E0POEnabled(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, nv1 : bit) =&gt; boolean
begin
    assert <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime);

    if !IsFeatureImplemented(FEAT_S1POE) then
        return FALSE;
    end;

    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt; return <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() &amp;&amp; TCR2_EL2().E0POE == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; return <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() &amp;&amp; nv1 == '0' &amp;&amp; TCR2_EL1().E0POE == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1EPD"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1EPD</h3>
      <p class="pseudocode">// AArch64_S1EPD()
// ===============
// Determine whether stage 1 translation table walk is allowed for the VA range

func <a id="func_AArch64_S1EPD_2"/>AArch64_S1EPD(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, va : bits(64)) =&gt; bit
begin
    assert <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime);
    let varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a> = <a href="shared_pseudocode.html#func_AArch64_GetVARange_1" title="">AArch64_GetVARange</a>(va);

    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt; return (if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then TCR_EL2().EPD0
                                                                else TCR_EL2().EPD1);
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; return (if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then TCR_EL1().EPD0
                                                                else TCR_EL1().EPD1);
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1Enabled</h3>
      <p class="pseudocode">// AArch64_S1Enabled()
// ===================
// Determine if stage 1 is enabled for the access type for this translation regime

func <a id="func_AArch64_S1Enabled_2"/>AArch64_S1Enabled(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, acctype : <a href="shared_pseudocode.html#type_AccessType" title="">AccessType</a>) =&gt; boolean
begin
    if acctype == <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a> &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveTRBLIMITR_EL1_nVM_0" title="">EffectiveTRBLIMITR_EL1_nVM</a>()  == '1' then
        return FALSE;
    end;
    if acctype == <a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a> &amp;&amp; <a href="shared_pseudocode.html#func_EffectivePMBLIMITR_EL1_nVM_0" title="">EffectivePMBLIMITR_EL1_nVM</a>() == '1' then
        return FALSE;
    end;
    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a>  =&gt; return SCTLR_EL3().M == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>  =&gt; return SCTLR_EL2().M == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt; return SCTLR_EL2().M == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; return ((!<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() || HCR_EL2().[DC,TGE] == '00') &amp;&amp;
                                    SCTLR_EL1().M == '1');
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1ICacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1ICacheEnabled</h3>
      <p class="pseudocode">// AArch64_S1ICacheEnabled()
// =========================
// Determine cacheability of stage 1 instruction fetches

func <a id="func_AArch64_S1ICacheEnabled_1"/>AArch64_S1ICacheEnabled(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>) =&gt; boolean
begin
    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a>  =&gt; return SCTLR_EL3().I == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>  =&gt; return SCTLR_EL2().I == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt; return SCTLR_EL2().I == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; return SCTLR_EL1().I == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1MinTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1MinTxSZ</h3>
      <p class="pseudocode">// AArch64_S1MinTxSZ()
// ===================
// Retrieve the minimum value of TxSZ indicating maximum input address size for stage 1

func <a id="func_AArch64_S1MinTxSZ_2"/>AArch64_S1MinTxSZ(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>) =&gt; integer
begin
    if IsFeatureImplemented(FEAT_LVA3) then
        if walkparams.d128 == '1' then
            if <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(regime) then
                return 9;
            else
                return 8;
            end;
        elsif walkparams.tgx == <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> || walkparams.ds == '1' then
            return 12;
        else
            return 16;
        end;
    end;
    if IsFeatureImplemented(FEAT_LVA) then
        if walkparams.tgx == <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> || walkparams.ds == '1' || walkparams.d128 == '1' then
            return 12;
        else
            return 16;
        end;
    end;

    return 16;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1POEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1POEnabled</h3>
      <p class="pseudocode">// AArch64_S1POEnabled()
// =====================
// Determine whether stage 1 privileged permission overlay is enabled

func <a id="func_AArch64_S1POEnabled_1"/>AArch64_S1POEnabled(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>) =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_S1POE) then
        return FALSE;
    end;

    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a>  =&gt; return TCR_EL3().POE == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>  =&gt; return <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() &amp;&amp; TCR2_EL2().POE == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt; return <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() &amp;&amp; TCR2_EL2().POE == '1';
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; return <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() &amp;&amp; TCR2_EL1().POE == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1POR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1POR</h3>
      <p class="pseudocode">// AArch64_S1POR()
// ===============
// Identify stage 1 permissions overlay register for the acting translation regime

func <a id="func_AArch64_S1POR_1"/>AArch64_S1POR(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>) =&gt; S1PORType
begin
    if (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().PIEn == '0' &amp;&amp; regime != <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> &amp;&amp;
          ImpDefBool("SCR_EL3.PIEn forces PIE/POE_ELx to zero")) then
        return Zeros{64} as S1PORType;
    end;

    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a>  =&gt; return POR_EL3() as S1PORType;
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>  =&gt; return POR_EL2() as S1PORType;
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt; return POR_EL2() as S1PORType;
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; return POR_EL1() as S1PORType;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1TTBR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1TTBR</h3>
      <p class="pseudocode">// AArch64_S1TTBR()
// ================
// Identify stage 1 table base register for the acting translation regime

func <a id="func_AArch64_S1TTBR_2"/>AArch64_S1TTBR(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>, va : bits(64)) =&gt; bits(128)
begin
    let varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a> = <a href="shared_pseudocode.html#func_AArch64_GetVARange_1" title="">AArch64_GetVARange</a>(va);

    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> =&gt; return ZeroExtend{128}(TTBR0_EL3());
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt; return ZeroExtend{128}(TTBR0_EL2());
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt;
            if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then
                return ZeroExtend{128}(TTBR0_EL2());
            else
                return ZeroExtend{128}(TTBR1_EL2());
            end;
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;
            if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then
                return ZeroExtend{128}(TTBR0_EL1());
            else
                return ZeroExtend{128}(TTBR1_EL1());
            end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1TTWParamsEL10"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1TTWParamsEL10</h3>
      <p class="pseudocode">// AArch64_S1TTWParamsEL10()
// =========================
// Gather stage 1 translation table walk parameters for EL1&amp;0 regime
// (with EL2 enabled or disabled)

func <a id="func_AArch64_S1TTWParamsEL10_2"/>AArch64_S1TTWParamsEL10(el : bits(2), varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a>) =&gt; <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>
begin
    var walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>;

    if IsFeatureImplemented(FEAT_D128) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() then
        walkparams.d128 = TCR2_EL1().D128;
    else
        walkparams.d128 = '0';
    end;
    let nvs : bits(3) = <a href="shared_pseudocode.html#func_EffectiveHCR_EL2_NVx_0" title="">EffectiveHCR_EL2_NVx</a>();
    walkparams.nv1 = nvs[1];

    if IsFeatureImplemented(FEAT_AIE) then
        walkparams.mair2 = MAIR2_EL1() as MAIRType;
    end;
    walkparams.aie  = (if IsFeatureImplemented(FEAT_AIE) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() then TCR2_EL1().AIE
                       else '0');
    if walkparams.d128 == '1' then
        walkparams.pie = '1';
    else
        walkparams.pie = (if IsFeatureImplemented(FEAT_S1PIE) &amp;&amp;
                          <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() then TCR2_EL1().PIE else '0');
    end;
    if IsFeatureImplemented(FEAT_S1PIE) then
        if !(<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().PIEn == '0' &amp;&amp;
               ImpDefBool("SCR_EL3.PIEn forces PIE/POE_ELx to zero")) then
            walkparams.pir = PIR_EL1() as S1PIRType;
            if walkparams.nv1 == '1' then
                walkparams.pire0 = Zeros{64} as S1PIRType;
            else
                walkparams.pire0 = PIRE0_EL1() as S1PIRType;
            end;
        else
            walkparams.pir   = Zeros{64} as S1PIRType;
            walkparams.pire0 = Zeros{64} as S1PIRType;
        end;
    end;

    if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then
        walkparams.tgx   = <a href="shared_pseudocode.html#func_AArch64_S1DecodeTG0_1" title="">AArch64_S1DecodeTG0</a>(TCR_EL1().TG0);
        walkparams.txsz  = TCR_EL1().T0SZ;
        walkparams.irgn  = TCR_EL1().IRGN0;
        walkparams.orgn  = TCR_EL1().ORGN0;
        walkparams.sh    = TCR_EL1().SH0;
        walkparams.tbi   = TCR_EL1().TBI0;

        walkparams.nfd   = if IsFeatureImplemented(FEAT_SVE)   then TCR_EL1().NFD0  else '0';
        walkparams.tbid  = if IsFeatureImplemented(FEAT_PAuth) then TCR_EL1().TBID0 else '0';
        walkparams.e0pd  = if IsFeatureImplemented(FEAT_E0PD)  then TCR_EL1().E0PD0 else '0';
        walkparams.hpd   = if IsFeatureImplemented(FEAT_HPDS)  then TCR_EL1().HPD0  else '0';
        if walkparams.hpd == '0' then
            if walkparams.aie == '1' then walkparams.hpd = '1'; end;
            if walkparams.pie == '1' then walkparams.hpd = '1'; end;
            if (<a href="shared_pseudocode.html#func_AArch64_S1POEnabled_1" title="">AArch64_S1POEnabled</a>(<a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>) ||
                  <a href="shared_pseudocode.html#func_AArch64_S1E0POEnabled_2" title="">AArch64_S1E0POEnabled</a>(<a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>, walkparams.nv1)) then walkparams.hpd = '1';
            end;
        end;
        if (IsFeatureImplemented(FEAT_MTE_NO_ADDRESS_TAGS) ||
              IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS)) then
            walkparams.mtx  = TCR_EL1().MTX0;
        else
            walkparams.mtx  = '0';
        end;
        walkparams.skl   = if walkparams.d128 == '1' then TTBR0_EL1().SKL else '00';
        walkparams.disch = if walkparams.d128 == '1' then TCR2_EL1().DisCH0 else '0';
        if IsFeatureImplemented(FEAT_ASID2) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() then
            walkparams.fng = TCR2_EL1().FNG0;
        else
            walkparams.fng = '0';
        end;
        if IsFeatureImplemented(FEAT_THE) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() then
            walkparams.fngna = TCR2_EL1().FNGNA0;
        else
            walkparams.fngna = '0';
        end;
    else
        walkparams.tgx   = <a href="shared_pseudocode.html#func_AArch64_S1DecodeTG1_1" title="">AArch64_S1DecodeTG1</a>(TCR_EL1().TG1);
        walkparams.txsz  = TCR_EL1().T1SZ;
        walkparams.irgn  = TCR_EL1().IRGN1;
        walkparams.orgn  = TCR_EL1().ORGN1;
        walkparams.sh    = TCR_EL1().SH1;
        walkparams.tbi   = TCR_EL1().TBI1;

        walkparams.nfd   = if IsFeatureImplemented(FEAT_SVE)   then TCR_EL1().NFD1  else '0';
        walkparams.tbid  = if IsFeatureImplemented(FEAT_PAuth) then TCR_EL1().TBID1 else '0';
        walkparams.e0pd  = if IsFeatureImplemented(FEAT_E0PD)  then TCR_EL1().E0PD1 else '0';
        walkparams.hpd   = if IsFeatureImplemented(FEAT_HPDS)  then TCR_EL1().HPD1  else '0';
        if walkparams.hpd == '0' then
            if walkparams.aie == '1' then walkparams.hpd = '1'; end;
            if walkparams.pie == '1' then walkparams.hpd = '1'; end;
            if (<a href="shared_pseudocode.html#func_AArch64_S1POEnabled_1" title="">AArch64_S1POEnabled</a>(<a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>) ||
                  <a href="shared_pseudocode.html#func_AArch64_S1E0POEnabled_2" title="">AArch64_S1E0POEnabled</a>(<a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>, walkparams.nv1)) then walkparams.hpd = '1';
            end;
        end;
        if (IsFeatureImplemented(FEAT_MTE_NO_ADDRESS_TAGS) ||
              IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS)) then
            walkparams.mtx  = TCR_EL1().MTX1;
        else
            walkparams.mtx  = '0';
        end;
        walkparams.skl   = if walkparams.d128 == '1' then TTBR1_EL1().SKL else '00';
        walkparams.disch = if walkparams.d128 == '1' then TCR2_EL1().DisCH1 else '0';
        if IsFeatureImplemented(FEAT_ASID2) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() then
            walkparams.fng = TCR2_EL1().FNG1;
        else
            walkparams.fng = '0';
        end;
        if IsFeatureImplemented(FEAT_THE) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() then
            walkparams.fngna = TCR2_EL1().FNGNA1;
        else
            walkparams.fngna = '0';
        end;
    end;

    walkparams.mair = MAIR_EL1() as MAIRType;
    walkparams.wxn  = SCTLR_EL1().WXN;
    walkparams.ps   = TCR_EL1().IPS;
    walkparams.ee   = SCTLR_EL1().EE;
    if (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; (!IsFeatureImplemented(FEAT_RME) || IsFeatureImplemented(FEAT_SEL2))) then
        walkparams.sif = SCR_EL3().SIF;
    else
        walkparams.sif = '0';
    end;

    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        walkparams.dc  = HCR_EL2().DC;
        walkparams.dct = if IsFeatureImplemented(FEAT_MTE2) then HCR_EL2().DCT else '0';
    end;

    if IsFeatureImplemented(FEAT_LSMAOC) then
        walkparams.ntlsmd = SCTLR_EL1().nTLSMD;
    else
        walkparams.ntlsmd = '1';
    end;

    walkparams.cmow = if IsFeatureImplemented(FEAT_CMOW)   then SCTLR_EL1().CMOW else '0';
    walkparams.ha   = if IsFeatureImplemented(FEAT_HAFDBS) then TCR_EL1().HA else '0';
    walkparams.hd   = if walkparams.ha == '1' then TCR_EL1().HD else '0';
    if (walkparams.tgx IN {<a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>, <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>} &amp;&amp; IsFeatureImplemented(FEAT_LPA2) &amp;&amp;
          walkparams.d128 == '0') then
        walkparams.ds = TCR_EL1().DS;
    else
        walkparams.ds = '0';
    end;
    if IsFeatureImplemented(FEAT_PAN3) then
        walkparams.epan = if walkparams.pie == '0' then SCTLR_EL1().EPAN else '1';
    else
        walkparams.epan = '0';
    end;
    if IsFeatureImplemented(FEAT_THE) &amp;&amp; walkparams.d128 == '0' &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() then
        walkparams.pnch = TCR2_EL1().PnCH;
    else
        walkparams.pnch = '0';
    end;
    if IsFeatureImplemented(FEAT_HAFT) &amp;&amp; walkparams.ha == '1' &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL1Enabled_0" title="">IsTCR2EL1Enabled</a>() then
        walkparams.haft = TCR2_EL1().HAFT;
    else
        walkparams.haft = '0';
    end;
    walkparams.emec = (if IsFeatureImplemented(FEAT_MEC) &amp;&amp;
                       <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then SCTLR2_EL2().EMEC else '0');

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1TTWParamsEL2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1TTWParamsEL2</h3>
      <p class="pseudocode">// AArch64_S1TTWParamsEL2()
// ========================
// Gather stage 1 translation table walk parameters for EL2 regime

func <a id="func_AArch64_S1TTWParamsEL2_1"/>AArch64_S1TTWParamsEL2(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>) =&gt; <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>
begin
    var walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>;

    walkparams.tgx  = <a href="shared_pseudocode.html#func_AArch64_S1DecodeTG0_1" title="">AArch64_S1DecodeTG0</a>(TCR_EL2().TG0);
    walkparams.txsz = TCR_EL2().T0SZ;
    walkparams.ps   = TCR_EL2().PS;
    walkparams.irgn = TCR_EL2().IRGN0;
    walkparams.orgn = TCR_EL2().ORGN0;
    walkparams.sh   = TCR_EL2().SH0;
    walkparams.tbi  = TCR_EL2().TBI;
    walkparams.mair = MAIR_EL2() as MAIRType;

    walkparams.pie = (if IsFeatureImplemented(FEAT_S1PIE) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then TCR2_EL2().PIE
                      else '0');

    if IsFeatureImplemented(FEAT_S1PIE) then
        if !(<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().PIEn == '0' &amp;&amp;
               ImpDefBool("SCR_EL3.PIEn forces PIE/POE_ELx to zero")) then
            walkparams.pir = PIR_EL2() as S1PIRType;
        else
            walkparams.pir = Zeros{64} as S1PIRType;
        end;
    end;
    if IsFeatureImplemented(FEAT_AIE) then
        walkparams.mair2 = MAIR2_EL2() as MAIRType;
    end;
    walkparams.aie  = (if IsFeatureImplemented(FEAT_AIE) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then TCR2_EL2().AIE
                       else '0');
    walkparams.wxn  = SCTLR_EL2().WXN;
    walkparams.ee   = SCTLR_EL2().EE;
    if (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; (!IsFeatureImplemented(FEAT_RME) || IsFeatureImplemented(FEAT_SEL2))) then
        walkparams.sif = SCR_EL3().SIF;
    else
        walkparams.sif = '0';
    end;

    walkparams.tbid = if IsFeatureImplemented(FEAT_PAuth)  then TCR_EL2().TBID else '0';
    walkparams.hpd  = if IsFeatureImplemented(FEAT_HPDS)   then TCR_EL2().HPD  else '0';
    if walkparams.hpd == '0' then
        if walkparams.aie == '1' then walkparams.hpd = '1'; end;
        if walkparams.pie == '1' then walkparams.hpd = '1'; end;
        if <a href="shared_pseudocode.html#func_AArch64_S1POEnabled_1" title="">AArch64_S1POEnabled</a>(<a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>) then walkparams.hpd = '1'; end;
    end;
    walkparams.ha   = if IsFeatureImplemented(FEAT_HAFDBS) then TCR_EL2().HA else '0';
    walkparams.hd   = if walkparams.ha == '1' then TCR_EL2().HD else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>, <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>} &amp;&amp; IsFeatureImplemented(FEAT_LPA2) then
        walkparams.ds = TCR_EL2().DS;
    else
        walkparams.ds = '0';
    end;
    if (IsFeatureImplemented(FEAT_MTE_NO_ADDRESS_TAGS) ||
          IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS)) then
        walkparams.mtx  = TCR_EL2().MTX;
    else
        walkparams.mtx  = '0';
    end;
    walkparams.pnch = (if IsFeatureImplemented(FEAT_THE) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then TCR2_EL2().PnCH
                       else '0');
    if IsFeatureImplemented(FEAT_HAFT) &amp;&amp; walkparams.ha == '1' &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then
        walkparams.haft = TCR2_EL2().HAFT;
    else
        walkparams.haft = '0';
    end;
    walkparams.emec = (if IsFeatureImplemented(FEAT_MEC) &amp;&amp;
                       <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then SCTLR2_EL2().EMEC else '0');
    if IsFeatureImplemented(FEAT_MEC) &amp;&amp; ss == <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then
        walkparams.amec = TCR2_EL2().AMEC0;
    else
        walkparams.amec = '0';
    end;

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1TTWParamsEL20"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1TTWParamsEL20</h3>
      <p class="pseudocode">// AArch64_S1TTWParamsEL20()
// =========================
// Gather stage 1 translation table walk parameters for EL2&amp;0 regime

func <a id="func_AArch64_S1TTWParamsEL20_3"/>AArch64_S1TTWParamsEL20(el : bits(2), ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a>) =&gt; <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>
begin
    var walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>;

    if IsFeatureImplemented(FEAT_D128) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then
        walkparams.d128 = TCR2_EL2().D128;
    else
        walkparams.d128 = '0';
    end;

    if walkparams.d128 == '1' then
        walkparams.pie = '1';
    else
        walkparams.pie = (if IsFeatureImplemented(FEAT_S1PIE) &amp;&amp;
                          <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then TCR2_EL2().PIE else '0');
    end;
    if IsFeatureImplemented(FEAT_S1PIE) then
        if !(<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().PIEn == '0' &amp;&amp;
               ImpDefBool("SCR_EL3.PIEn forces PIE/POE_ELx to zero")) then
            walkparams.pir   = PIR_EL2() as S1PIRType;
            walkparams.pire0 = PIRE0_EL2() as S1PIRType;
        else
            walkparams.pir   = Zeros{64} as S1PIRType;
            walkparams.pire0 = Zeros{64} as S1PIRType;
        end;
    end;

    if IsFeatureImplemented(FEAT_AIE) then
        walkparams.mair2 = MAIR2_EL2() as MAIRType;
    end;
    walkparams.aie  = (if IsFeatureImplemented(FEAT_AIE) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then TCR2_EL2().AIE
                       else '0');
    if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then
        walkparams.tgx  = <a href="shared_pseudocode.html#func_AArch64_S1DecodeTG0_1" title="">AArch64_S1DecodeTG0</a>(TCR_EL2().TG0);
        walkparams.txsz = TCR_EL2().T0SZ;
        walkparams.irgn = TCR_EL2().IRGN0;
        walkparams.orgn = TCR_EL2().ORGN0;
        walkparams.sh   = TCR_EL2().SH0;
        walkparams.tbi  = TCR_EL2().TBI0;

        walkparams.nfd  = if IsFeatureImplemented(FEAT_SVE)   then TCR_EL2().NFD0  else '0';
        walkparams.tbid = if IsFeatureImplemented(FEAT_PAuth) then TCR_EL2().TBID0 else '0';
        walkparams.e0pd = if IsFeatureImplemented(FEAT_E0PD)  then TCR_EL2().E0PD0 else '0';
        walkparams.hpd  = if IsFeatureImplemented(FEAT_HPDS)  then TCR_EL2().HPD0  else '0';
        if walkparams.hpd == '0' then
            if walkparams.aie == '1' then walkparams.hpd = '1'; end;
            if walkparams.pie == '1' then walkparams.hpd = '1'; end;
            if <a href="shared_pseudocode.html#func_AArch64_S1POEnabled_1" title="">AArch64_S1POEnabled</a>(<a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>) || <a href="shared_pseudocode.html#func_AArch64_S1E0POEnabled_2" title="">AArch64_S1E0POEnabled</a>(<a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>, '0') then
                walkparams.hpd = '1';
            end;
        end;
        if (IsFeatureImplemented(FEAT_MTE_NO_ADDRESS_TAGS) ||
              IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS)) then
            walkparams.mtx = TCR_EL2().MTX0;
        else
            walkparams.mtx = '0';
        end;
        walkparams.skl   = if walkparams.d128 == '1' then TTBR0_EL2().SKL else '00';
        walkparams.disch = if walkparams.d128 == '1' then TCR2_EL2().DisCH0 else '0';
        if IsFeatureImplemented(FEAT_ASID2) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then
            walkparams.fng = TCR2_EL2().FNG0;
        else
            walkparams.fng = '0';
        end;
    else
        walkparams.tgx  = <a href="shared_pseudocode.html#func_AArch64_S1DecodeTG1_1" title="">AArch64_S1DecodeTG1</a>(TCR_EL2().TG1);
        walkparams.txsz = TCR_EL2().T1SZ;
        walkparams.irgn = TCR_EL2().IRGN1;
        walkparams.orgn = TCR_EL2().ORGN1;
        walkparams.sh   = TCR_EL2().SH1;
        walkparams.tbi  = TCR_EL2().TBI1;

        walkparams.nfd  = if IsFeatureImplemented(FEAT_SVE)   then TCR_EL2().NFD1  else '0';
        walkparams.tbid = if IsFeatureImplemented(FEAT_PAuth) then TCR_EL2().TBID1 else '0';
        walkparams.e0pd = if IsFeatureImplemented(FEAT_E0PD)  then TCR_EL2().E0PD1 else '0';
        walkparams.hpd  = if IsFeatureImplemented(FEAT_HPDS)  then TCR_EL2().HPD1  else '0';
        if walkparams.hpd == '0' then
            if walkparams.aie == '1' then walkparams.hpd = '1'; end;
            if walkparams.pie == '1' then walkparams.hpd = '1'; end;
            if <a href="shared_pseudocode.html#func_AArch64_S1POEnabled_1" title="">AArch64_S1POEnabled</a>(<a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>) || <a href="shared_pseudocode.html#func_AArch64_S1E0POEnabled_2" title="">AArch64_S1E0POEnabled</a>(<a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>, '0') then
                walkparams.hpd = '1';
            end;
        end;
        if (IsFeatureImplemented(FEAT_MTE_NO_ADDRESS_TAGS) ||
              IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS)) then
            walkparams.mtx = TCR_EL2().MTX1;
        else
            walkparams.mtx = '0';
        end;
        walkparams.skl   = if walkparams.d128 == '1' then TTBR1_EL2().SKL else '00';
        walkparams.disch = if walkparams.d128 == '1' then TCR2_EL2().DisCH1 else '0';
        if IsFeatureImplemented(FEAT_ASID2) &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then
            walkparams.fng = TCR2_EL2().FNG1;
        else
            walkparams.fng = '0';
        end;
    end;

    walkparams.mair = MAIR_EL2() as MAIRType;
    walkparams.wxn  = SCTLR_EL2().WXN;
    walkparams.ps   = TCR_EL2().IPS;
    walkparams.ee   = SCTLR_EL2().EE;
    if (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; (!IsFeatureImplemented(FEAT_RME) || IsFeatureImplemented(FEAT_SEL2))) then
        walkparams.sif = SCR_EL3().SIF;
    else
        walkparams.sif = '0';
    end;

    if IsFeatureImplemented(FEAT_LSMAOC) then
        walkparams.ntlsmd = SCTLR_EL2().nTLSMD;
    else
        walkparams.ntlsmd = '1';
    end;

    walkparams.cmow = if IsFeatureImplemented(FEAT_CMOW)   then SCTLR_EL2().CMOW else '0';
    walkparams.ha   = if IsFeatureImplemented(FEAT_HAFDBS) then TCR_EL2().HA else '0';
    walkparams.hd   = if walkparams.ha == '1' then TCR_EL2().HD else '0';
    if (walkparams.tgx IN {<a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>, <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>} &amp;&amp; IsFeatureImplemented(FEAT_LPA2) &amp;&amp;
          walkparams.d128 == '0') then
        walkparams.ds = TCR_EL2().DS;
    else
        walkparams.ds = '0';
    end;
    if IsFeatureImplemented(FEAT_PAN3) then
        walkparams.epan = if walkparams.pie == '0' then SCTLR_EL2().EPAN else '1';
    else
        walkparams.epan = '0';
    end;
    if IsFeatureImplemented(FEAT_THE) &amp;&amp; walkparams.d128 == '0' &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then
        walkparams.pnch = TCR2_EL2().PnCH;
    else
        walkparams.pnch = '0';
    end;
    if IsFeatureImplemented(FEAT_HAFT) &amp;&amp; walkparams.ha == '1' &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then
        walkparams.haft = TCR2_EL2().HAFT;
    else
        walkparams.haft = '0';
    end;
    walkparams.emec = (if IsFeatureImplemented(FEAT_MEC) &amp;&amp; <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>()
                       then SCTLR2_EL2().EMEC else '0');
    if IsFeatureImplemented(FEAT_MEC) &amp;&amp; ss == <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsTCR2EL2Enabled_0" title="">IsTCR2EL2Enabled</a>() then
        walkparams.amec = if varange == <a href="shared_pseudocode.html#enum_VARange_LOWER" title="">VARange_LOWER</a> then TCR2_EL2().AMEC0 else TCR2_EL2().AMEC1;
    else
        walkparams.amec = '0';
    end;

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S1TTWParamsEL3"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S1TTWParamsEL3</h3>
      <p class="pseudocode">// AArch64_S1TTWParamsEL3()
// ========================
// Gather stage 1 translation table walk parameters for EL3 regime

func <a id="func_AArch64_S1TTWParamsEL3_0"/>AArch64_S1TTWParamsEL3() =&gt; <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>
begin
    var walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>;

    walkparams.tgx   = <a href="shared_pseudocode.html#func_AArch64_S1DecodeTG0_1" title="">AArch64_S1DecodeTG0</a>(TCR_EL3().TG0);
    walkparams.txsz  = TCR_EL3().T0SZ;
    walkparams.ps    = TCR_EL3().PS;
    walkparams.irgn  = TCR_EL3().IRGN0;
    walkparams.orgn  = TCR_EL3().ORGN0;
    walkparams.sh    = TCR_EL3().SH0;
    walkparams.tbi   = TCR_EL3().TBI;
    walkparams.mair  = MAIR_EL3() as MAIRType;
    walkparams.d128  = if IsFeatureImplemented(FEAT_D128)  then TCR_EL3().D128 else '0';
    walkparams.skl   = if walkparams.d128 == '1' then TTBR0_EL3().SKL else '00';
    walkparams.disch = if walkparams.d128 == '1' then TCR_EL3().DisCH0 else '0';

    if walkparams.d128 == '1' then
        walkparams.pie = '1';
    else
        walkparams.pie = if IsFeatureImplemented(FEAT_S1PIE) then TCR_EL3().PIE else '0';
    end;
    if IsFeatureImplemented(FEAT_S1PIE) then
        walkparams.pir = PIR_EL3() as S1PIRType;
    end;

    if IsFeatureImplemented(FEAT_AIE) then
        walkparams.mair2 = MAIR2_EL3() as MAIRType;
    end;
    walkparams.aie  = if IsFeatureImplemented(FEAT_AIE) then TCR_EL3().AIE else '0';
    walkparams.wxn  = SCTLR_EL3().WXN;
    walkparams.ee   = SCTLR_EL3().EE;
    walkparams.sif = (if !IsFeatureImplemented(FEAT_RME) || IsFeatureImplemented(FEAT_SEL2)
                      then SCR_EL3().SIF else '0');

    walkparams.tbid = if IsFeatureImplemented(FEAT_PAuth)  then TCR_EL3().TBID else '0';
    walkparams.hpd  = if IsFeatureImplemented(FEAT_HPDS)   then TCR_EL3().HPD else '0';
    if walkparams.hpd == '0' then
        if walkparams.aie == '1' then walkparams.hpd = '1'; end;
        if walkparams.pie == '1' then walkparams.hpd = '1'; end;
        if <a href="shared_pseudocode.html#func_AArch64_S1POEnabled_1" title="">AArch64_S1POEnabled</a>(<a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a>) then walkparams.hpd = '1'; end;
    end;
    walkparams.ha   = if IsFeatureImplemented(FEAT_HAFDBS) then TCR_EL3().HA else '0';
    walkparams.hd   = if walkparams.ha == '1' then TCR_EL3().HD else '0';
    if (walkparams.tgx IN {<a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>, <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>} &amp;&amp; IsFeatureImplemented(FEAT_LPA2) &amp;&amp;
          walkparams.d128 == '0') then
        walkparams.ds = TCR_EL3().DS;
    else
        walkparams.ds = '0';
    end;
    if (IsFeatureImplemented(FEAT_MTE_NO_ADDRESS_TAGS) ||
          IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS)) then
        walkparams.mtx  = TCR_EL3().MTX;
    else
        walkparams.mtx  = '0';
    end;
    if IsFeatureImplemented(FEAT_THE) &amp;&amp; walkparams.d128 == '0' then
        walkparams.pnch = TCR_EL3().PnCH;
    else
        walkparams.pnch = '0';
    end;
    if IsFeatureImplemented(FEAT_HAFT) &amp;&amp; walkparams.ha == '1' then
        walkparams.haft = TCR_EL3().HAFT;
    else
        walkparams.haft = '0';
    end;
    walkparams.emec = if IsFeatureImplemented(FEAT_MEC) then SCTLR2_EL3().EMEC else '0';

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S2DecodeTG0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S2DecodeTG0</h3>
      <p class="pseudocode">// AArch64_S2DecodeTG0()
// =====================
// Decode stage 2 granule size configuration bits TG0

func <a id="func_AArch64_S2DecodeTG0_1"/>AArch64_S2DecodeTG0(tg0_in : bits(2)) =&gt; <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>
begin
    var tg0 : bits(2) = tg0_in;
    var tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>;

    if tg0 == '11' then
        tg0 = ImpDefBits{2}("TG0 encoded granule size");
    end;

    case tg0 of
        when '00' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
        when '01' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a>;
        when '10' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>;
    end;

    if !<a href="shared_pseudocode.html#func_AArch64_HaveS2TG_1" title="">AArch64_HaveS2TG</a>(tgx) then
        case ImpDefBits{2}("TG0 encoded granule size") of
            when '00' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>;
            when '01' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a>;
            when '10' =&gt; tgx = <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>;
        end;
    end;

    return tgx;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_S2MinTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_S2MinTxSZ</h3>
      <p class="pseudocode">// AArch64_S2MinTxSZ()
// ===================
// Retrieve the minimum value of TxSZ indicating maximum input address size for stage 2

func <a id="func_AArch64_S2MinTxSZ_2"/>AArch64_S2MinTxSZ(walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>, s1aarch64 : boolean) =&gt; integer
begin
    var ips : integer;

    if AArch64_PAMax() == 56 then
        if walkparams.d128 == '1' then
            ips = 56;
        elsif walkparams.tgx == <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> || walkparams.ds == '1' then
            ips = 52;
        else
            ips = 48;
        end;
    elsif AArch64_PAMax() == 52 then
        if walkparams.tgx == <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> || walkparams.ds == '1' then
            ips = 52;
        else
            ips = 48;
        end;
    else
        ips = AArch64_PAMax();
    end;

    var min_txsz : integer = 64 - ips;
    if !s1aarch64 then
        // EL1 is AArch32
        min_txsz = Min(min_txsz, 24);
    end;

    return min_txsz;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64_SS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64_SS2TTWParams</h3>
      <p class="pseudocode">// AArch64_SS2TTWParams()
// ======================
// Gather walk parameters specific for secure stage 2 translation

func <a id="func_AArch64_SS2TTWParams_2"/>AArch64_SS2TTWParams(ipaspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>, s1aarch64 : boolean) =&gt; <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>
begin
    var walkparams : <a href="shared_pseudocode.html#type_S2TTWParams" title="">S2TTWParams</a>;

    walkparams.d128 = if IsFeatureImplemented(FEAT_D128) then VTCR_EL2().D128 else '0';
    if ipaspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then
        walkparams.tgx  = <a href="shared_pseudocode.html#func_AArch64_S2DecodeTG0_1" title="">AArch64_S2DecodeTG0</a>(VSTCR_EL2().TG0);
        walkparams.txsz = VSTCR_EL2().T0SZ;
        if walkparams.d128 == '1' then
            walkparams.skl = VSTTBR_EL2().SKL;
        else
            walkparams.sl0 = VSTCR_EL2().SL0;
        end;
        if walkparams.tgx == <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a> &amp;&amp; IsFeatureImplemented(FEAT_LPA2) then
            walkparams.sl2 = VSTCR_EL2().SL2 AND VTCR_EL2().DS;
        else
            walkparams.sl2 = '0';
        end;
    elsif ipaspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> then
        walkparams.tgx  = <a href="shared_pseudocode.html#func_AArch64_S2DecodeTG0_1" title="">AArch64_S2DecodeTG0</a>(VTCR_EL2().TG0);
        walkparams.txsz = VTCR_EL2().T0SZ;
        if walkparams.d128 == '1' then
            walkparams.skl = VTTBR_EL2().SKL;
        else
            walkparams.sl0 = VTCR_EL2().SL0;
        end;
        if walkparams.tgx == <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a> &amp;&amp; IsFeatureImplemented(FEAT_LPA2) then
            walkparams.sl2 = VTCR_EL2().SL2 AND VTCR_EL2().DS;
        else
            walkparams.sl2 = '0';
        end;
    else
        unreachable;
    end;

    walkparams.sw   = VSTCR_EL2().SW;
    walkparams.nsw  = VTCR_EL2().NSW;
    walkparams.sa   = VSTCR_EL2().SA;
    walkparams.nsa  = VTCR_EL2().NSA;
    walkparams.vm   = HCR_EL2().VM OR HCR_EL2().DC;
    walkparams.ps   = VTCR_EL2().PS;
    walkparams.irgn = VTCR_EL2().IRGN0;
    walkparams.orgn = VTCR_EL2().ORGN0;
    walkparams.sh   = VTCR_EL2().SH0;
    walkparams.ee   = SCTLR_EL2().EE;

    walkparams.ptw = if HCR_EL2().TGE == '0'                then HCR_EL2().PTW else '0';
    walkparams.fwb = if IsFeatureImplemented(FEAT_S2FWB)  then HCR_EL2().FWB else '0';
    walkparams.ha  = if IsFeatureImplemented(FEAT_HAFDBS) then VTCR_EL2().HA else '0';
    walkparams.hd  = if walkparams.ha == '1' then VTCR_EL2().HD else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a>, <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a>} &amp;&amp; IsFeatureImplemented(FEAT_LPA2) then
        walkparams.ds = VTCR_EL2().DS;
    else
        walkparams.ds = '0';
    end;
    walkparams.cmow = (if IsFeatureImplemented(FEAT_CMOW) &amp;&amp; <a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() then HCRX_EL2().CMOW
                       else '0');
    if walkparams.d128 == '1' then
        walkparams.s2pie = '1';
    else
        walkparams.s2pie = if IsFeatureImplemented(FEAT_S2PIE) then VTCR_EL2().S2PIE else '0';
    end;
    if IsFeatureImplemented(FEAT_S2PIE) then
        if !(<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().PIEn == '0' &amp;&amp;
               ImpDefBool("SCR_EL3.PIEn forces PIE/POE_ELx to zero")) then
            walkparams.s2pir = S2PIR_EL2() as S2PIRType;
        else
            walkparams.s2pir = Zeros{64} as S2PIRType;
        end;
    end;
    if IsFeatureImplemented(FEAT_THE) &amp;&amp; walkparams.d128 != '1' then
        walkparams.assuredonly = VTCR_EL2().AssuredOnly;
    else
        walkparams.assuredonly = '0';
    end;
    walkparams.tl0   = if IsFeatureImplemented(FEAT_THE) then VTCR_EL2().TL0 else '0';
    walkparams.tl1   = if IsFeatureImplemented(FEAT_THE) then VTCR_EL2().TL1 else '0';
    if IsFeatureImplemented(FEAT_HAFT) &amp;&amp; walkparams.ha == '1' then
        walkparams.haft = VTCR_EL2().HAFT;
    else
        walkparams.haft = '0';
    end;
    walkparams.emec = '0';
    if (IsFeatureImplemented(FEAT_HDBSS) &amp;&amp; walkparams.hd == '1' &amp;&amp;
          (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || SCR_EL3().HDBSSEn == '1')) then
        walkparams.hdbss = VTCR_EL2().HDBSS;
    else
        walkparams.hdbss = '0';
    end;

    return walkparams;
end;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.S2DCacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/S2DCacheEnabled</h3>
      <p class="pseudocode">// S2DCacheEnabled()
// =================
// Returns TRUE if Stage 2 Data access cacheability is enabled

func <a id="func_S2DCacheEnabled_0"/>S2DCacheEnabled() =&gt; boolean
begin
    return HCR_EL2().CD == '0';
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.ClearStickyErrors.ClearStickyErrors"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/ClearStickyErrors/ClearStickyErrors</h3>
      <p class="pseudocode">// ClearStickyErrors()
// ===================

func ClearStickyErrors()
begin
    EDSCR().TXU = '0';            // Clear TX underrun flag
    EDSCR().RXO = '0';            // Clear RX overrun flag

    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then            // in Debug state
        EDSCR().ITO = '0';        // Clear ITR overrun flag
    end;

    // If halted and the ITR is not empty then it is UNPREDICTABLE whether the EDSCR.ERR is cleared.
    // The UNPREDICTABLE behavior also affects the instructions in flight, but this is not described
    // in the pseudocode.
    if (<a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() &amp;&amp; EDSCR().ITE == '0' &amp;&amp;
          <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_CLEARERRITEZERO" title="">Unpredictable_CLEARERRITEZERO</a>)) then
        return;
    end;
    EDSCR().ERR = '0';            // Clear cumulative error flag

    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.DebugTarget.DebugTarget"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/DebugTarget/DebugTarget</h3>
      <p class="pseudocode">// DebugTarget()
// =============
// Returns the debug exception target Exception level

func <a id="func_DebugTarget_0"/>DebugTarget() =&gt; bits(2)
begin
    let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();
    return <a href="shared_pseudocode.html#func_DebugTargetFrom_1" title="">DebugTargetFrom</a>(ss);
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.DebugTarget.DebugTargetFrom"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/DebugTarget/DebugTargetFrom</h3>
      <p class="pseudocode">// DebugTargetFrom()
// =================

func <a id="func_DebugTargetFrom_1"/>DebugTargetFrom(from_state : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>) =&gt; bits(2)
begin
    var route_to_el2 : boolean;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; (from_state != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> ||
        (IsFeatureImplemented(FEAT_SEL2) &amp;&amp; (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || SCR_EL3().EEL2 == '1'))) then
        if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            route_to_el2 = (HDCR().TDE == '1' || HCR().TGE == '1');
        else
            route_to_el2 = (MDCR_EL2().TDE == '1' || HCR_EL2().TGE == '1');
        end;
    else
        route_to_el2 = FALSE;
    end;

    var target : bits(2);
    if route_to_el2 then
        target = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() &amp;&amp; from_state == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
        target = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
    else
        target = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    end;

    return target;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.DoubleLockStatus.DoubleLockStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/DoubleLockStatus/DoubleLockStatus</h3>
      <p class="pseudocode">// DoubleLockStatus()
// ==================
// Returns the state of the OS Double Lock.
//    FALSE if OSDLR_EL1.DLK == 0 or DBGPRCR_EL1.CORENPDRQ == 1 or the PE is in Debug state.
//    TRUE if OSDLR_EL1.DLK == 1 and DBGPRCR_EL1.CORENPDRQ == 0 and the PE is in Non-debug state.

func <a id="func_DoubleLockStatus_0"/>DoubleLockStatus() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_DoubleLock) then
        return FALSE;
    end;
    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        return DBGOSDLR().DLK == '1' &amp;&amp; DBGPRCR().CORENPDRQ == '0' &amp;&amp; !<a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>();
    else
        return OSDLR_EL1().DLK == '1' &amp;&amp; DBGPRCR_EL1().CORENPDRQ == '0' &amp;&amp; !<a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.OSLockStatus.OSLockStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/OSLockStatus/OSLockStatus</h3>
      <p class="pseudocode">// OSLockStatus()
// ==============
// Returns the state of the OS Lock.

readonly func <a id="func_OSLockStatus_0"/>OSLockStatus() =&gt; boolean
begin
    return (if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then DBGOSLSR().OSLK else OSLSR_EL1().OSLK) == '1';
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.SoftwareLockStatus.Component"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/SoftwareLockStatus/Component</h3>
      <p class="pseudocode">// Component
// =========
// Component Types.

type <a id="type_Component"/>Component of enumeration {
        <a id="enum_Component_ETE"/>Component_ETE,
        <a id="enum_Component_TRBE"/>Component_TRBE,
        <a id="enum_Component_RAS"/>Component_RAS,
        <a id="enum_Component_GIC"/>Component_GIC,
        <a id="enum_Component_PMU"/>Component_PMU,
        <a id="enum_Component_Debug"/>Component_Debug,
        <a id="enum_Component_CTI"/>Component_CTI
};</p>
    </div>
    <div class="ps"><a id="shared.debug.SoftwareLockStatus.GetAccessComponent"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/SoftwareLockStatus/GetAccessComponent</h3>
      <p class="pseudocode">// GetAccessComponent()
// ====================
// Returns the accessed component.

impdef func <a id="func_GetAccessComponent_0"/>GetAccessComponent() =&gt; <a href="shared_pseudocode.html#type_Component" title="">Component</a>
begin
    return <a href="shared_pseudocode.html#enum_Component_Debug" title="">Component_Debug</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.SoftwareLockStatus.SoftwareLockStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/SoftwareLockStatus/SoftwareLockStatus</h3>
      <p class="pseudocode">// SoftwareLockStatus()
// ====================
// Returns the state of the Software Lock.

func <a id="func_SoftwareLockStatus_0"/>SoftwareLockStatus() =&gt; boolean
begin
    let component : <a href="shared_pseudocode.html#type_Component" title="">Component</a> = <a href="shared_pseudocode.html#func_GetAccessComponent_0" title="">GetAccessComponent</a>();
    if !<a href="shared_pseudocode.html#func_HaveSoftwareLock_1" title="">HaveSoftwareLock</a>(component) then
        return FALSE;
    end;
    case component of
        when <a href="shared_pseudocode.html#enum_Component_ETE" title="">Component_ETE</a> =&gt;
            return TRCLSR().SLK == '1';
        when <a href="shared_pseudocode.html#enum_Component_Debug" title="">Component_Debug</a> =&gt;
            return EDLSR().SLK == '1';
        when <a href="shared_pseudocode.html#enum_Component_PMU" title="">Component_PMU</a> =&gt;
            return PMLSR().SLK == '1';
        when <a href="shared_pseudocode.html#enum_Component_CTI" title="">Component_CTI</a> =&gt;
            return CTILSR().SLK == '1';
        otherwise =&gt;
            return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.amu.IsG1ActivityMonitorImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/amu/IsG1ActivityMonitorImplemented</h3>
      <p class="pseudocode">// IsG1ActivityMonitorImplemented()
// ================================
// Returns TRUE if a G1 activity monitor is implemented for the counter
// and FALSE otherwise.

impdef func <a id="func_IsG1ActivityMonitorImplemented_1"/>IsG1ActivityMonitorImplemented(i : integer) =&gt; boolean
begin
    case i of
        when 0 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 0"));
        when 1 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 1"));
        when 2 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 2"));
        when 3 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 3"));
        when 4 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 4"));
        when 5 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 5"));
        when 6 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 6"));
        when 7 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 7"));
        when 8 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 8"));
        when 9 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 9"));
        when 10 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 10"));
        when 11 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 11"));
        when 12 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 12"));
        when 13 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 13"));
        when 14 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 14"));
        when 15 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor is implemented for counter 15"));
        otherwise =&gt;
            return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.amu.IsG1ActivityMonitorOffsetImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/amu/IsG1ActivityMonitorOffsetImplemented</h3>
      <p class="pseudocode">// IsG1ActivityMonitorOffsetImplemented()
// ======================================
// Returns TRUE if a G1 activity monitor offset is implemented for the counter,
// and FALSE otherwise.

impdef func <a id="func_IsG1ActivityMonitorOffsetImplemented_1"/>IsG1ActivityMonitorOffsetImplemented(i : integer) =&gt; boolean
begin
    case i of
        when 0 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 0"));
        when 1 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 1"));
        when 2 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 2"));
        when 3 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 3"));
        when 4 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 4"));
        when 5 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 5"));
        when 6 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 6"));
        when 7 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 7"));
        when 8 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 8"));
        when 9 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 9"));
        when 10 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 10"));
        when 11 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 11"));
        when 12 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 12"));
        when 13 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 13"));
        when 14 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 14"));
        when 15 =&gt;
            return (ImpDefBool(
                    "G1 activity monitor offset is implemented for counter 15"));
        otherwise =&gt;
            return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.AllowExternalDebugAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/AllowExternalDebugAccess</h3>
      <p class="pseudocode">// AllowExternalDebugAccess()
// ==========================
// Returns TRUE if an external debug interface access to the External DBGBVR_EL1(n),
// DBGBCR_EL1(n), DBGWVR_EL1(n), DBGWCR_EL1(n) registers, and, from Armv8.2, the
// OSLAR_EL1 register is allowed for the access. Returns FALSE otherwise.

func <a id="func_AllowExternalDebugAccess_1"/>AllowExternalDebugAccess(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; boolean
begin
    // The access may also be subject to OS Lock, power-down, etc.
    if IsFeatureImplemented(FEAT_RME) then
        case MDCR_EL3().[EDADE,EDAD] of
            when '00' =&gt; return TRUE;
            when '01' =&gt; return addrdesc.paddress.paspace IN {<a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>, <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>};
            when '10' =&gt; return addrdesc.paddress.paspace IN {<a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>, <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>};
            when '11' =&gt; return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>;
        end;
    end;

    if IsFeatureImplemented(FEAT_Debugv8p4) then
        if addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then return TRUE; end;
    else
        if !<a href="shared_pseudocode.html#func_ExternalInvasiveDebugEnabled_0" title="">ExternalInvasiveDebugEnabled</a>() then return FALSE; end;
        if <a href="shared_pseudocode.html#func_ExternalSecureInvasiveDebugEnabled_0" title="">ExternalSecureInvasiveDebugEnabled</a>() then return TRUE; end;
    end;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        let EDAD_bit : bit = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then SDCR().EDAD else MDCR_EL3().EDAD;
        return EDAD_bit == '0';
    else
        return <a href="shared_pseudocode.html#func_NonSecureOnlyImplementation_0" title="">NonSecureOnlyImplementation</a>();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.AllowExternalPMSSAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/AllowExternalPMSSAccess</h3>
      <p class="pseudocode">// AllowExternalPMSSAccess()
// =========================
// Returns TRUE if an external debug interface access to the PMU Snapshot
// registers is allowed for the given Security state, FALSE otherwise.

func <a id="func_AllowExternalPMSSAccess_1"/>AllowExternalPMSSAccess(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; boolean
begin
    assert IsFeatureImplemented(FEAT_PMUv3_SS) &amp;&amp; <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>();
    // FEAT_Debugv8p4 is always implemented when FEAT_PMUv3_SS is implemented.
    assert IsFeatureImplemented(FEAT_Debugv8p4);

    // The access may also be subject to the OS Double Lock, power-down, etc.
    var epmssad : bits(2) = if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then MDCR_EL3().EPMSSAD else '11';

    // Check for reserved values
    if !IsFeatureImplemented(FEAT_RME) &amp;&amp; epmssad IN {'01','10'} then
        (-, epmssad) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_RESEPMSSAD" title="">Unpredictable_RESEPMSSAD</a>);
        // The value returned by ConstrainUnpredictableBits() must be a
        // non-reserved value
        assert epmssad IN {'00','11'};
    end;

    case epmssad of
        when '00' =&gt;
            if IsFeatureImplemented(FEAT_RME) then
                return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>;
            else
                return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
            end;
        when '01' =&gt;
            assert IsFeatureImplemented(FEAT_RME);
            return addrdesc.paddress.paspace IN {<a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>, <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>};
        when '10' =&gt;
            assert IsFeatureImplemented(FEAT_RME);
            return addrdesc.paddress.paspace IN {<a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>, <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>};
        when '11' =&gt;
            return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.AllowExternalPMUAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/AllowExternalPMUAccess</h3>
      <p class="pseudocode">// AllowExternalPMUAccess()
// ========================
// Returns TRUE if an external debug interface access to the PMU registers is
// allowed for the given Security state, FALSE otherwise.

func <a id="func_AllowExternalPMUAccess_1"/>AllowExternalPMUAccess(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; boolean
begin
    // The access may also be subject to OS Lock, power-down, etc.
    if IsFeatureImplemented(FEAT_RME) then
        case MDCR_EL3().[EPMADE,EPMAD] of
            when '00' =&gt; return TRUE;
            when '01' =&gt; return addrdesc.paddress.paspace IN {<a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>, <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>};
            when '10' =&gt; return addrdesc.paddress.paspace IN {<a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>, <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>};
            when '11' =&gt; return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>;
        end;
    end;

    if IsFeatureImplemented(FEAT_Debugv8p4) then
        if addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then return TRUE; end;
    else
        if !<a href="shared_pseudocode.html#func_ExternalInvasiveDebugEnabled_0" title="">ExternalInvasiveDebugEnabled</a>() then return FALSE; end;
        if <a href="shared_pseudocode.html#func_ExternalSecureInvasiveDebugEnabled_0" title="">ExternalSecureInvasiveDebugEnabled</a>() then return TRUE; end;
    end;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        let EPMAD_bit : bit = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then SDCR().EPMAD else MDCR_EL3().EPMAD;
        return EPMAD_bit == '0';
    else
        return <a href="shared_pseudocode.html#func_NonSecureOnlyImplementation_0" title="">NonSecureOnlyImplementation</a>();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.AllowExternalTraceAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/AllowExternalTraceAccess</h3>
      <p class="pseudocode">// AllowExternalTraceAccess()
// ==========================
// Returns TRUE if an external Trace access to the Trace registers is allowed for the
// given PAS, FALSE otherwise.

func <a id="func_AllowExternalTraceAccess_1"/>AllowExternalTraceAccess(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; boolean
begin
    // The access may also be subject to OS lock, power-down, etc.
    if !IsFeatureImplemented(FEAT_TRBE) then return TRUE; end;
    assert IsFeatureImplemented(FEAT_Debugv8p4);
    if IsFeatureImplemented(FEAT_RME) then
        case MDCR_EL3().[ETADE,ETAD] of
            when '00' =&gt; return TRUE;
            when '01' =&gt; return addrdesc.paddress.paspace IN {<a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>, <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>};
            when '10' =&gt; return addrdesc.paddress.paspace IN {<a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>, <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>};
            when '11' =&gt; return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>;
        end;
    end;

    if addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> then return TRUE; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        // External Trace access is not supported for EL3 using AArch32
        assert !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        return MDCR_EL3().ETAD == '0';
    else
        return <a href="shared_pseudocode.html#func_NonSecureOnlyImplementation_0" title="">NonSecureOnlyImplementation</a>();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.Debug"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/Debug</h3>
      <p class="pseudocode">// Debug authentication signals
// ============================

var DBGEN : <a href="shared_pseudocode.html#Signal" title="type Signal">Signal</a>;

var NIDEN : <a href="shared_pseudocode.html#Signal" title="type Signal">Signal</a>;

var SPIDEN : <a href="shared_pseudocode.html#Signal" title="type Signal">Signal</a>;

var SPNIDEN : <a href="shared_pseudocode.html#Signal" title="type Signal">Signal</a>;

var RLPIDEN : <a href="shared_pseudocode.html#Signal" title="type Signal">Signal</a>;

var RTPIDEN : <a href="shared_pseudocode.html#Signal" title="type Signal">Signal</a>;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalInvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalInvasiveDebugEnabled()
// ==============================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the DBGEN signal.

func <a id="func_ExternalInvasiveDebugEnabled_0"/>ExternalInvasiveDebugEnabled() =&gt; boolean
begin
    return DBGEN == HIGH;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalNoninvasiveDebugAllowed"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalNoninvasiveDebugAllowed</h3>
      <p class="pseudocode">// ExternalNoninvasiveDebugAllowed()
// =================================
// Returns TRUE if Trace and PC Sample-based Profiling are allowed

func <a id="func_ExternalNoninvasiveDebugAllowed_0"/>ExternalNoninvasiveDebugAllowed() =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_ExternalNoninvasiveDebugAllowed_1" title="">ExternalNoninvasiveDebugAllowed</a>(PSTATE.EL);
end;

// ExternalNoninvasiveDebugAllowed()
// =================================

func <a id="func_ExternalNoninvasiveDebugAllowed_1"/>ExternalNoninvasiveDebugAllowed(el : bits(2)) =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_ExternalNoninvasiveDebugEnabled_0" title="">ExternalNoninvasiveDebugEnabled</a>() then return FALSE; end;
    let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(el);

    if ((<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>)) &amp;&amp; el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp;
        ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> &amp;&amp; SDER().SUNIDEN == '1') then
        return TRUE;
    end;

    case ss of
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt; return TRUE;
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;    return <a href="shared_pseudocode.html#func_ExternalSecureNoninvasiveDebugEnabled_0" title="">ExternalSecureNoninvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;     return <a href="shared_pseudocode.html#func_ExternalRealmNoninvasiveDebugEnabled_0" title="">ExternalRealmNoninvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> =&gt;      return <a href="shared_pseudocode.html#func_ExternalRootNoninvasiveDebugEnabled_0" title="">ExternalRootNoninvasiveDebugEnabled</a>();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalNoninvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalNoninvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalNoninvasiveDebugEnabled()
// =================================
// This function returns TRUE if the FEAT_Debugv8p4 is implemented.
// Otherwise, this function is IMPLEMENTATION DEFINED, and, in the
// recommended interface, ExternalNoninvasiveDebugEnabled returns
// the state of the (DBGEN OR NIDEN) signal.

func <a id="func_ExternalNoninvasiveDebugEnabled_0"/>ExternalNoninvasiveDebugEnabled() =&gt; boolean
begin
    return (IsFeatureImplemented(FEAT_Debugv8p4) || <a href="shared_pseudocode.html#func_ExternalInvasiveDebugEnabled_0" title="">ExternalInvasiveDebugEnabled</a>() ||
            NIDEN == HIGH);
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalRealmInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalRealmInvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalRealmInvasiveDebugEnabled()
// ===================================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the
// (DBGEN AND RLPIDEN) signal.

func <a id="func_ExternalRealmInvasiveDebugEnabled_0"/>ExternalRealmInvasiveDebugEnabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_RME) then return FALSE; end;
    return <a href="shared_pseudocode.html#func_ExternalInvasiveDebugEnabled_0" title="">ExternalInvasiveDebugEnabled</a>() &amp;&amp; RLPIDEN == HIGH;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalRealmNoninvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalRealmNoninvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalRealmNoninvasiveDebugEnabled()
// ======================================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the
// (DBGEN AND RLPIDEN) signal.

func <a id="func_ExternalRealmNoninvasiveDebugEnabled_0"/>ExternalRealmNoninvasiveDebugEnabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_RME) then return FALSE; end;
    return <a href="shared_pseudocode.html#func_ExternalRealmInvasiveDebugEnabled_0" title="">ExternalRealmInvasiveDebugEnabled</a>();
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalRootInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalRootInvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalRootInvasiveDebugEnabled()
// ==================================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the
// (DBGEN AND RLPIDEN AND RTPIDEN AND SPIDEN) signal when FEAT_SEL2 is implemented
// and the (DBGEN AND RLPIDEN AND RTPIDEN) signal when FEAT_SEL2 is not implemented.

func <a id="func_ExternalRootInvasiveDebugEnabled_0"/>ExternalRootInvasiveDebugEnabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_RME) then return FALSE; end;
    return (<a href="shared_pseudocode.html#func_ExternalInvasiveDebugEnabled_0" title="">ExternalInvasiveDebugEnabled</a>() &amp;&amp;
            (!IsFeatureImplemented(FEAT_SEL2) || <a href="shared_pseudocode.html#func_ExternalSecureInvasiveDebugEnabled_0" title="">ExternalSecureInvasiveDebugEnabled</a>()) &amp;&amp;
            <a href="shared_pseudocode.html#func_ExternalRealmInvasiveDebugEnabled_0" title="">ExternalRealmInvasiveDebugEnabled</a>() &amp;&amp;
            RTPIDEN == HIGH);
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalRootNoninvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalRootNoninvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalRootNoninvasiveDebugEnabled()
// =====================================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the
// (DBGEN AND RLPIDEN AND SPIDEN AND RTPIDEN) signal.

func <a id="func_ExternalRootNoninvasiveDebugEnabled_0"/>ExternalRootNoninvasiveDebugEnabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_RME) then return FALSE; end;
    return <a href="shared_pseudocode.html#func_ExternalRootInvasiveDebugEnabled_0" title="">ExternalRootInvasiveDebugEnabled</a>();
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalSecureInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalSecureInvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalSecureInvasiveDebugEnabled()
// ====================================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the (DBGEN AND SPIDEN) signal.
// CoreSight allows asserting SPIDEN without also asserting DBGEN, but this is not recommended.

func <a id="func_ExternalSecureInvasiveDebugEnabled_0"/>ExternalSecureInvasiveDebugEnabled() =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_HaveSecureState_0" title="">HaveSecureState</a>() then return FALSE; end;
    return <a href="shared_pseudocode.html#func_ExternalInvasiveDebugEnabled_0" title="">ExternalInvasiveDebugEnabled</a>() &amp;&amp; SPIDEN == HIGH;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalSecureNoninvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalSecureNoninvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalSecureNoninvasiveDebugEnabled()
// =======================================
// This function returns the value of ExternalSecureInvasiveDebugEnabled() when FEAT_Debugv8p4
// is implemented. Otherwise, the definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the (DBGEN OR NIDEN) AND
// (SPIDEN OR SPNIDEN) signal.

func <a id="func_ExternalSecureNoninvasiveDebugEnabled_0"/>ExternalSecureNoninvasiveDebugEnabled() =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_HaveSecureState_0" title="">HaveSecureState</a>() then return FALSE; end;
    if !IsFeatureImplemented(FEAT_Debugv8p4) then
        return (<a href="shared_pseudocode.html#func_ExternalNoninvasiveDebugEnabled_0" title="">ExternalNoninvasiveDebugEnabled</a>() &amp;&amp;
                (SPIDEN == HIGH || SPNIDEN == HIGH));
    else
        return <a href="shared_pseudocode.html#func_ExternalSecureInvasiveDebugEnabled_0" title="">ExternalSecureInvasiveDebugEnabled</a>();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.InvasiveDebugPermittedPAS"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/InvasiveDebugPermittedPAS</h3>
      <p class="pseudocode">// InvasiveDebugPermittedPAS()
// ===========================
// Returns TRUE if the invasive debug of the configured PASpace is permitted by
// the authentication interface, and FALSE otherwise.

func <a id="func_InvasiveDebugPermittedPAS_1"/>InvasiveDebugPermittedPAS(pas : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>) =&gt; boolean
begin
    case pas of
        when <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> =&gt;    return <a href="shared_pseudocode.html#func_ExternalSecureInvasiveDebugEnabled_0" title="">ExternalSecureInvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> =&gt; return <a href="shared_pseudocode.html#func_ExternalInvasiveDebugEnabled_0" title="">ExternalInvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a> =&gt;      return <a href="shared_pseudocode.html#func_ExternalRootInvasiveDebugEnabled_0" title="">ExternalRootInvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> =&gt;     return <a href="shared_pseudocode.html#func_ExternalRealmInvasiveDebugEnabled_0" title="">ExternalRealmInvasiveDebugEnabled</a>();
        otherwise =&gt;          return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.IsAccessNonSecure"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/IsAccessNonSecure</h3>
      <p class="pseudocode">// IsAccessNonSecure()
// ===================
// Returns TRUE when an access is Non-Secure

func <a id="func_IsAccessNonSecure_1"/>IsAccessNonSecure(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; boolean
begin
    return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.IsAccessRealm"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/IsAccessRealm</h3>
      <p class="pseudocode">// IsAccessRealm()
// ===============
// Returns TRUE when an access is Realm

func <a id="func_IsAccessRealm_1"/>IsAccessRealm(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; boolean
begin
    return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.IsAccessRoot"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/IsAccessRoot</h3>
      <p class="pseudocode">// IsAccessRoot()
// ==============
// Returns TRUE when an access is Root

func <a id="func_IsAccessRoot_1"/>IsAccessRoot(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; boolean
begin
    return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.IsAccessSecure"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/IsAccessSecure</h3>
      <p class="pseudocode">// IsAccessSecure()
// ================
// Returns TRUE when an access is Secure

func <a id="func_IsAccessSecure_1"/>IsAccessSecure(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; boolean
begin
    return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.IsCorePowered"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/IsCorePowered</h3>
      <p class="pseudocode">// IsCorePowered()
// ===============
// Returns TRUE if the Core power domain is powered on, FALSE otherwise.

impdef func <a id="func_IsCorePowered_0"/>IsCorePowered() =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.IsPASValid"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/IsPASValid</h3>
      <p class="pseudocode">// IsPASValid()
// ============
// Returns TRUE if the given value of 'pas' is not reserved, and FALSE otherwise.

func <a id="func_IsPASValid_1"/>IsPASValid(pas : bits(2)) =&gt; boolean
begin
    case pas of
        when '00' =&gt; return IsFeatureImplemented(FEAT_Secure);
        when '01' =&gt; return TRUE;
        when '10' =&gt; return IsFeatureImplemented(FEAT_RME);
        when '11' =&gt; return IsFeatureImplemented(FEAT_RME);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.BreakpointInfo"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/BreakpointInfo</h3>
      <p class="pseudocode">// BreakpointInfo
// ==============
// Breakpoint related fields.

type <a id="type_BreakpointInfo"/>BreakpointInfo of record {
    bptype : <a href="shared_pseudocode.html#type_BreakpointType" title="">BreakpointType</a>, // Type of breakpoint matched
    match : boolean,         // breakpoint match
    mismatch : boolean       // breakpoint mismatch
};</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.BreakpointType"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/BreakpointType</h3>
      <p class="pseudocode">// BreakpointType
// ==============

type <a id="type_BreakpointType"/>BreakpointType of enumeration {
    <a id="enum_BreakpointType_Inactive"/>BreakpointType_Inactive,     // Breakpoint inactive or disabled
    <a id="enum_BreakpointType_AddrMatch"/>BreakpointType_AddrMatch,    // Address Match breakpoint
    <a id="enum_BreakpointType_AddrMismatch"/>BreakpointType_AddrMismatch, // Address Mismatch breakpoint
    <a id="enum_BreakpointType_CtxtMatch"/>BreakpointType_CtxtMatch  }; // Context matching breakpoint</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.CheckValidStateMatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/CheckValidStateMatch</h3>
      <p class="pseudocode">// CheckValidStateMatch()
// ======================
// Checks for an invalid state match that will generate Constrained
// Unpredictable behavior, otherwise returns Constraint_NONE.

func <a id="func_CheckValidStateMatch_5"/>CheckValidStateMatch(ssc_in : bits(2), ssce_in : bit,
                          hmc_in : bit, pxc_in : bits(2),
                          isbreakpnt : boolean) =&gt; (<a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>, bits(2), bit, bit, bits(2))
begin
    if !IsFeatureImplemented(FEAT_RME) then assert ssce_in == '0'; end;
    var reserved : boolean = FALSE;
    var ssc : bits(2) = ssc_in;
    var ssce : bit    = ssce_in;
    var hmc : bit     = hmc_in;
    var pxc : bits(2) = pxc_in;

    // Values that are not allocated in any architecture version
    case hmc::ssce::ssc::pxc of
        when '0 0 11 10' =&gt; reserved = TRUE;
        when '0 0 1x xx' =&gt; reserved = !<a href="shared_pseudocode.html#func_HaveSecureState_0" title="">HaveSecureState</a>();
        when '1 0 00 x0' =&gt; reserved = TRUE;
        when '1 0 01 10' =&gt; reserved = TRUE;
        when '1 0 1x 10' =&gt; reserved = TRUE;
        when 'x 1 xx xx' =&gt; reserved = ssc != '01' || (hmc::pxc) IN {'000','110'};
        otherwise =&gt;        reserved = FALSE;
    end;

    // Match 'Usr/Sys/Svc' valid only for AArch32 breakpoints
    if (!isbreakpnt || !<a href="shared_pseudocode.html#func_HaveAArch32EL_1" title="">HaveAArch32EL</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>)) &amp;&amp; hmc::pxc == '000' &amp;&amp; ssc != '11' then
        reserved = TRUE;
    end;

    // Both EL3 and EL2 are not implemented
    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; (hmc != '0' || ssc != '00') then
        reserved = TRUE;
    end;

    // EL3 is not implemented
    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; ssc IN {'01','10'} &amp;&amp; hmc::ssc::pxc != '10100' then
        reserved = TRUE;
    end;

    // EL3 using AArch64 only
    if (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>()) &amp;&amp; hmc::ssc::pxc == '11000' then
        reserved = TRUE;
    end;

    // EL2 is not implemented
    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; hmc::ssc::pxc == '11100' then
        reserved = TRUE;
    end;

    // Secure EL2 is not implemented
    if !IsFeatureImplemented(FEAT_SEL2) &amp;&amp; (hmc::ssc::pxc)  IN {'01100','10100','x11x1'} then
        reserved = TRUE;
    end;

    if reserved then
        // If parameters are set to a reserved type, behaves as either disabled or a defined type
        var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;
        var unpred_state_bits : bits(6);
        (c, unpred_state_bits) = ConstrainUnpredictableBits{6}(<a href="shared_pseudocode.html#enum_Unpredictable_RESBPWPCTRL" title="">Unpredictable_RESBPWPCTRL</a>);
        hmc = unpred_state_bits[5];
        ssc = unpred_state_bits[4:3];
        ssce = unpred_state_bits[2];
        pxc = unpred_state_bits[1:0];
        assert c IN {<a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then
            return (c, ARBITRARY : bits(2), ARBITRARY : bit, ARBITRARY : bit, ARBITRARY : bits(2));
        end;
    end;
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    return (<a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>, ssc, ssce, hmc, pxc);
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.ContextAwareBreakpointRange"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/ContextAwareBreakpointRange</h3>
      <p class="pseudocode">// ContextAwareBreakpointRange()
// =============================
// Returns two numbers indicating the index of the first and last context-aware breakpoint.

func <a id="func_ContextAwareBreakpointRange_0"/>ContextAwareBreakpointRange() =&gt; (integer, integer)
begin
    let b : integer = <a href="shared_pseudocode.html#func_NumBreakpointsImplemented_0" title="">NumBreakpointsImplemented</a>();
    let c : integer = <a href="shared_pseudocode.html#func_NumContextAwareBreakpointsImplemented_0" title="">NumContextAwareBreakpointsImplemented</a>();

    if b &lt;= 16 then
        return (b - c, b - 1);
    elsif c &lt;= 16 then
        return (16 - c, 15);
    else
        return (0, c - 1);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.IsContextAwareBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/IsContextAwareBreakpoint</h3>
      <p class="pseudocode">// IsContextAwareBreakpoint()
// ==========================
// Returns TRUE if DBGBCR_EL1[n] is a context-aware breakpoint.

func <a id="func_IsContextAwareBreakpoint_1"/>IsContextAwareBreakpoint(n : integer) =&gt; boolean
begin
    let (lower, upper) : (integer, integer) = <a href="shared_pseudocode.html#func_ContextAwareBreakpointRange_0" title="">ContextAwareBreakpointRange</a>();
    return n &gt;= lower &amp;&amp; n &lt;= upper;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.NumBreakpointsImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/NumBreakpointsImplemented</h3>
      <p class="pseudocode">// NumBreakpointsImplemented()
// ===========================
// Returns the number of breakpoints implemented.

readonly func <a id="func_NumBreakpointsImplemented_0"/>NumBreakpointsImplemented() =&gt; integer
begin
    return ImpDefInt("Number of breakpoints");
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.NumContextAwareBreakpointsImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/NumContextAwareBreakpointsImplemented</h3>
      <p class="pseudocode">// NumContextAwareBreakpointsImplemented()
// =======================================
// Returns the number of context-aware breakpoints implemented.

readonly func <a id="func_NumContextAwareBreakpointsImplemented_0"/>NumContextAwareBreakpointsImplemented() =&gt; integer
begin
    return ImpDefInt("Number of context-aware breakpoints");
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.NumWatchpointsImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/NumWatchpointsImplemented</h3>
      <p class="pseudocode">// NumWatchpointsImplemented()
// ===========================
// Returns the number of watchpoints implemented.

readonly func <a id="func_NumWatchpointsImplemented_0"/>NumWatchpointsImplemented() =&gt; integer
begin
    return ImpDefInt("Number of watchpoints");
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.cti.CTI_ProcessEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/cti/CTI_ProcessEvent</h3>
      <p class="pseudocode">// CTI_ProcessEvent()
// ==================
// Process a discrete event on a Cross Trigger output event trigger.

impdef func CTI_ProcessEvent(id : <a href="shared_pseudocode.html#type_CrossTriggerOut" title="">CrossTriggerOut</a>)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.cti.CTI_SetEventLevel"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/cti/CTI_SetEventLevel</h3>
      <p class="pseudocode">// CTI_SetEventLevel()
// ===================
// Set a Cross Trigger multi-cycle input event trigger to the specified level.

impdef func CTI_SetEventLevel(id : CrossTriggerIn, level : <a href="shared_pseudocode.html#Signal" title="type Signal">Signal</a>)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.cti.CTI_SignalEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/cti/CTI_SignalEvent</h3>
      <p class="pseudocode">// CTI_SignalEvent()
// =================
// Signal a discrete event on a Cross Trigger input event trigger.

impdef func CTI_SignalEvent(id : <a href="shared_pseudocode.html#type_CrossTriggerIn" title="">CrossTriggerIn</a>)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.cti.CrossTrigger"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/cti/CrossTrigger</h3>
      <p class="pseudocode">// CrossTrigger
// ============

type <a id="type_CrossTriggerOut"/>CrossTriggerOut of enumeration {<a id="enum_CrossTriggerOut_DebugRequest"/>CrossTriggerOut_DebugRequest, <a id="enum_CrossTriggerOut_RestartRequest"/>CrossTriggerOut_RestartRequest,
                                     <a id="enum_CrossTriggerOut_IRQ"/>CrossTriggerOut_IRQ,          <a id="enum_CrossTriggerOut_RSVD3"/>CrossTriggerOut_RSVD3,
                                     <a id="enum_CrossTriggerOut_TraceExtIn0"/>CrossTriggerOut_TraceExtIn0,  <a id="enum_CrossTriggerOut_TraceExtIn1"/>CrossTriggerOut_TraceExtIn1,
                                     <a id="enum_CrossTriggerOut_TraceExtIn2"/>CrossTriggerOut_TraceExtIn2,  <a id="enum_CrossTriggerOut_TraceExtIn3"/>CrossTriggerOut_TraceExtIn3};

type <a id="type_CrossTriggerIn"/>CrossTriggerIn of enumeration {<a id="enum_CrossTriggerIn_CrossHalt"/>CrossTriggerIn_CrossHalt,     <a id="enum_CrossTriggerIn_PMUOverflow"/>CrossTriggerIn_PMUOverflow,
                                    <a id="enum_CrossTriggerIn_SPESample"/>CrossTriggerIn_SPESample,     <a id="enum_CrossTriggerIn_RSVD3"/>CrossTriggerIn_RSVD3,
                                    <a id="enum_CrossTriggerIn_TraceExtOut0"/>CrossTriggerIn_TraceExtOut0,  <a id="enum_CrossTriggerIn_TraceExtOut1"/>CrossTriggerIn_TraceExtOut1,
                                    <a id="enum_CrossTriggerIn_TraceExtOut2"/>CrossTriggerIn_TraceExtOut2,  <a id="enum_CrossTriggerIn_TraceExtOut3"/>CrossTriggerIn_TraceExtOut3,
                                    <a id="enum_CrossTriggerIn_TRBEStop"/>CrossTriggerIn_TRBEStop,      <a id="enum_CrossTriggerIn_TRBEMgmt"/>CrossTriggerIn_TRBEMgmt,
                                    <a id="enum_CrossTriggerIn_TRBEWrap"/>CrossTriggerIn_TRBEWrap};</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.CheckForDCCInterrupts"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/CheckForDCCInterrupts</h3>
      <p class="pseudocode">// CheckForDCCInterrupts()
// =======================

func CheckForDCCInterrupts()
begin
    let commrx : boolean = (EDSCR().RXfull == '1');
    let commtx : boolean = (EDSCR().TXfull == '0');

    // COMMRX and COMMTX support is optional and not recommended for new designs.
    // SetInterruptRequestLevel(InterruptID_COMMRX, if commrx then HIGH else LOW);
    // SetInterruptRequestLevel(InterruptID_COMMTX, if commtx then HIGH else LOW);

    // The value to be driven onto the common COMMIRQ signal.
    var commirq : boolean;
    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        commirq = ((commrx &amp;&amp; DBGDCCINT().RX == '1') ||
                   (commtx &amp;&amp; DBGDCCINT().TX == '1'));
    else
        commirq = ((commrx &amp;&amp; MDCCINT_EL1().RX == '1') ||
                   (commtx &amp;&amp; MDCCINT_EL1().TX == '1'));
    end;
    SetInterruptRequestLevel(<a href="shared_pseudocode.html#enum_InterruptID_COMMIRQ" title="">InterruptID_COMMIRQ</a>, if commirq then HIGH else LOW);

    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.DTR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/DTR</h3>
      <p class="pseudocode">// DTR
// ===

var <a id="global_DTRRX"/>DTRRX : bits(32);

var <a id="global_DTRTX"/>DTRTX : bits(32);</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.Read_DBGDTRRX_EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/Read_DBGDTRRX_EL0</h3>
      <p class="pseudocode">// Read_DBGDTRRX_EL0()
// ===================
// Called on reads of debug register 0x080.

func <a id="func_Read_DBGDTRRX_EL0_1"/>Read_DBGDTRRX_EL0(memory_mapped : boolean) =&gt; bits(32)
begin
    return <a href="shared_pseudocode.html#global_DTRRX" title="">DTRRX</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.Read_DBGDTRTX_EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/Read_DBGDTRTX_EL0</h3>
      <p class="pseudocode">// Read_DBGDTRTX_EL0()
// ===================
// Called on reads of debug register 0x08C.

func <a id="func_Read_DBGDTRTX_EL0_1"/>Read_DBGDTRTX_EL0(memory_mapped : boolean) =&gt; bits(32)
begin
    let underrun : boolean = (EDSCR().TXfull == '0' ||
                              (<a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() &amp;&amp; EDSCR().MA == '1' &amp;&amp; EDSCR().ITE == '0'));
    let value : bits(32)   = if underrun then ARBITRARY : bits(32) else <a href="shared_pseudocode.html#global_DTRTX" title="">DTRTX</a>;

    if EDSCR().ERR == '1' then return value; end;       // Error flag set: no side-effects

    if underrun then
        EDSCR().TXU = '1';  EDSCR().ERR = '1';          // Underrun condition: block side-effects
        return value;                                   // Return UNKNOWN
    end;

    EDSCR().TXfull = '0';
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() &amp;&amp; EDSCR().MA == '1' then
        EDSCR().ITE = '0';                              // See comments in Write_EDITR()

        if !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
            ExecuteA64(0xB8404401[31:0]);               // A64 "LDR W1,[X0],#4"
        else
            ExecuteT32(0xF850[15:0] /*hw1*/, 0x1B04[15:0] /*hw2*/);      // T32 "LDR R1,[R0],#4"
        end;
        // If the load aborts, the Data Abort exception is taken and EDSCR.ERR is set to 1
        if EDSCR().ERR == '1' then
            EDSCR().TXfull = ARBITRARY : bit;
            DBGDTRTX_EL0() = ARBITRARY : bits(64);
        else

            if !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
                ExecuteA64(0xD5130501[31:0]);           // A64 "MSR DBGDTRTX_EL0,X1"
            else
                ExecuteT32(0xEE00[15:0] /*hw1*/, 0x1E15[15:0] /*hw2*/);  // T32 "MSR DBGDTRTXint,R1"
            end;
            // "MSR DBGDTRTX_EL0,X1" calls Write_DBGDTR_EL0() which sets TXfull.
            assert EDSCR().TXfull == '1';
        end;
        if !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
            <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(1) = ARBITRARY : bits(64);
        else
            <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(1) = ARBITRARY : bits(32);
        end;
        EDSCR().ITE = '1';                                // See comments in Write_EDITR()
    end;

    return value;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.Read_DBGDTR_EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/Read_DBGDTR_EL0</h3>
      <p class="pseudocode">// Read_DBGDTR_EL0()
// =================
// System register reads of DBGDTR_EL0, DBGDTRRX_EL0 (AArch64) and DBGDTRRXint (AArch32)

func <a id="func_Read_DBGDTR_EL0_1"/>Read_DBGDTR_EL0{N}() =&gt; bits(N)
begin
    // For MRS &lt;Rt&gt;,DBGDTRTX_EL0  N=32, X[t]=Zeros(32):result
    // For MRS &lt;Xt&gt;,DBGDTR_EL0    N=64, X[t]=result
    assert N IN {32,64};
    var result : bits(N);
    if EDSCR().RXfull == '0' then
        result = ARBITRARY : bits(N);
    else
        // On a 64-bit read, implement a half-duplex channel
        // NOTE: the word order is reversed on reads with regards to writes
        if N == 64 then result[63:32] = <a href="shared_pseudocode.html#global_DTRTX" title="">DTRTX</a>; end;
        result[31:0] = <a href="shared_pseudocode.html#global_DTRRX" title="">DTRRX</a>;
    end;
    EDSCR().RXfull = '0';
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.Write_DBGDTRRX_EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/Write_DBGDTRRX_EL0</h3>
      <p class="pseudocode">// Write_DBGDTRRX_EL0()
// ====================
// Called on writes to debug register 0x080.

func Write_DBGDTRRX_EL0(memory_mapped : boolean, value : bits(32))
begin
    if EDSCR().ERR == '1' then return; end;                // Error flag set: ignore write

    if EDSCR().RXfull == '1' || (<a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() &amp;&amp; EDSCR().MA == '1' &amp;&amp; EDSCR().ITE == '0') then
        EDSCR().RXO = '1';  EDSCR().ERR = '1';              // Overrun condition: ignore write
        return;
    end;

    EDSCR().RXfull = '1';
    <a href="shared_pseudocode.html#global_DTRRX" title="">DTRRX</a>          = value;

    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() &amp;&amp; EDSCR().MA == '1' then
        EDSCR().ITE = '0';                                // See comments in Write_EDITR()
        if !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
            ExecuteA64(0xD5330501[31:0]);               // A64 "MRS X1,DBGDTRRX_EL0"
            ExecuteA64(0xB8004401[31:0]);               // A64 "STR W1,[X0],#4"
            <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(1) = ARBITRARY : bits(64);
        else
            ExecuteT32(0xEE10[15:0] /*hw1*/, 0x1E15[15:0] /*hw2*/);  // T32 "MRS R1,DBGDTRRXint"
            ExecuteT32(0xF840[15:0] /*hw1*/, 0x1B04[15:0] /*hw2*/);  // T32 "STR R1,[R0],#4"
            <a href="shared_pseudocode.html#accessor_R_1" title="">R</a>(1) = ARBITRARY : bits(32);
        end;
        // If the store aborts, the Data Abort exception is taken and EDSCR.ERR is set to 1
        if EDSCR().ERR == '1' then
            EDSCR().RXfull = ARBITRARY : bit;
            DBGDTRRX_EL0() = ARBITRARY : bits(64);
        else
            // "MRS X1,DBGDTRRX_EL0" calls Read_DBGDTR_EL0() which clears RXfull.
            assert EDSCR().RXfull == '0';
        end;

        EDSCR().ITE = '1';                                // See comments in Write_EDITR()
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.Write_DBGDTRTX_EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/Write_DBGDTRTX_EL0</h3>
      <p class="pseudocode">// Write_DBGDTRTX_EL0()
// ====================
// Called on writes to debug register 0x08C.

func Write_DBGDTRTX_EL0(memory_mapped : boolean, value : bits(32))
begin
    <a href="shared_pseudocode.html#global_DTRTX" title="">DTRTX</a> = value;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.Write_DBGDTR_EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/Write_DBGDTR_EL0</h3>
      <p class="pseudocode">// Write_DBGDTR_EL0()
// ==================
// System register writes to DBGDTR_EL0, DBGDTRTX_EL0 (AArch64) and DBGDTRTXint (AArch32)

func Write_DBGDTR_EL0{N}(value_in : bits(N))
begin
    var value : bits(N) = value_in;
    // For MSR DBGDTRTX_EL0,&lt;Rt&gt;  N=32, value=X[t]&lt;31:0&gt;, X[t]&lt;63:32&gt; is ignored
    // For MSR DBGDTR_EL0,&lt;Xt&gt;    N=64, value=X[t]&lt;63:0&gt;
    assert N IN {32,64};
    if EDSCR().TXfull == '1' then
        value = ARBITRARY : bits(N);
    end;
    // On a 64-bit write, implement a half-duplex channel
    if N == 64 then <a href="shared_pseudocode.html#global_DTRRX" title="">DTRRX</a> = value[63:32]; end;
    <a href="shared_pseudocode.html#global_DTRTX" title="">DTRTX</a> = value[31:0];        // 32-bit or 64-bit write
    EDSCR().TXfull = '1';
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.Write_EDITR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/Write_EDITR</h3>
      <p class="pseudocode">// Write_EDITR()
// =============
// Called on writes to debug register 0x084.

func Write_EDITR(memory_mapped : boolean, value : bits(32))
begin
    if EDSCR().ERR == '1' then return; end;         // Error flag set: ignore write

    if !<a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then return; end;                  // Non-debug state: ignore write

    if EDSCR().ITE == '0' || EDSCR().MA == '1' then
        EDSCR().ITO = '1';  EDSCR().ERR = '1';      // Overrun condition: block write
        return;
    end;

    // ITE indicates whether the PE is ready to accept another instruction; the PE
    // may support multiple outstanding instructions. Unlike the "InstrCompl" flag in [v7A] there
    // is no indication that the pipeline is empty (all instructions have completed). In this
    // pseudocode, the assumption is that only one instruction can be executed at a time,
    // meaning ITE acts like "InstrCompl".
    EDSCR().ITE = '0';

    if !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        ExecuteA64(value);
    else
        ExecuteT32(value[15:0]/*hw1*/, value[31:16] /*hw2*/);
    end;

    EDSCR().ITE = '1';

    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DCPSInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DCPSInstruction</h3>
      <p class="pseudocode">// DCPSInstruction()
// =================
// Operation of the DCPS instruction in Debug state

func DCPSInstruction(target_el : bits(2))
begin

    SynchronizeContext();

    var handle_el : bits(2);
    case target_el of
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || (PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>()) then
                handle_el = PSTATE.EL;
            elsif <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then
                Undefined();
            else
                handle_el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
            end;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
                Undefined();
            elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
                handle_el = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
            elsif !<a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
                Undefined();
            else
                handle_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
            end;
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            if EDSCR().SDD == '1' || !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
                Undefined();
            else
                handle_el = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
            end;
        otherwise =&gt;
            unreachable;
    end;

    let from_secure : boolean = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(handle_el) then
        if PSTATE.M == <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> then SCR().NS = '0'; end;
        assert <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();                  // Cannot move from AArch64 to AArch32
        case handle_el of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
                AArch32_WriteMode(<a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>);
                if IsFeatureImplemented(FEAT_PAN) &amp;&amp; SCTLR().SPAN == '0' then
                    PSTATE.PAN = '1';
                end;
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  AArch32_WriteMode(<a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>);
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
                AArch32_WriteMode(<a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a>);
                if IsFeatureImplemented(FEAT_PAN) then
                    if !from_secure then
                        PSTATE.PAN = '0';
                    elsif SCTLR().SPAN == '0' then
                        PSTATE.PAN = '1';
                    end;
                end;
        end;
        if handle_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
            ELR_hyp() = ARBITRARY : bits(32);  HSR() = ARBITRARY : bits(32);
        else
            <a href="shared_pseudocode.html#accessor_LR_0" title="">LR</a>() = ARBITRARY : bits(32);
        end;
        <a href="shared_pseudocode.html#accessor_SPSR_curr_0" title="">SPSR_curr</a>() = ARBITRARY : bits(32);
        PSTATE.E = <a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().EE;
        DLR() = ARBITRARY : bits(32);  DSPSR() = ARBITRARY : bits(32);

    else                                        // Targeting AArch64
        let from_32 : boolean = <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
        if from_32 then AArch64_MaybeZeroRegisterUppers(); end;
        if from_32 &amp;&amp; IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.SM == '1' then
            ResetSVEState();
        else
            MaybeZeroSVEUppers(target_el);
        end;
        PSTATE.nRW = '0';  PSTATE.SP = '1';  PSTATE.EL = handle_el;
        if IsFeatureImplemented(FEAT_PAN) &amp;&amp; ((handle_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; SCTLR_EL1().SPAN == '0') ||
                                              (handle_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) &amp;&amp;
                                               SCTLR_EL2().SPAN == '0')) then
            PSTATE.PAN = '1';
        end;
        <a href="shared_pseudocode.html#accessor_ELR_ELx_0" title="">ELR_ELx</a>() = ARBITRARY : bits(64);
        <a href="shared_pseudocode.html#accessor_SPSR_ELx_0" title="">SPSR_ELx</a>() = ARBITRARY : bits(64);
        <a href="shared_pseudocode.html#accessor_ESR_ELx_0" title="">ESR_ELx</a>() = ARBITRARY : bits(64);
        DLR_EL0() = ARBITRARY : bits(64);  DSPSR_EL0() = ARBITRARY : bits(64);
        if IsFeatureImplemented(FEAT_UAO) then PSTATE.UAO = '0'; end;
        if IsFeatureImplemented(FEAT_MTE) then PSTATE.TCO = '1'; end;
        if IsFeatureImplemented(FEAT_GCS) then PSTATE.EXLOCK = '0'; end;
    end;
    if IsFeatureImplemented(FEAT_UINJ) then PSTATE.UINJ = '0'; end;
    UpdateEDSCRFields();                        // Update EDSCR PE state flags
    var sync_errors : boolean = IsFeatureImplemented(FEAT_IESB) &amp;&amp; <a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().IESB == '1';
    if IsFeatureImplemented(FEAT_DoubleFault) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        sync_errors = (sync_errors ||
                       (<a href="shared_pseudocode.html#func_EffectiveEA_0" title="">EffectiveEA</a>() == '1' &amp;&amp; SCR_EL3().NMEA == '1' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>));
    end;
    // The Effective value of SCTLR[].IESB might be zero in Debug state.
    if !<a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_IESBinDebug" title="">Unpredictable_IESBinDebug</a>) then
        sync_errors = FALSE;
    end;
    if sync_errors then
        SynchronizeErrors();
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DRPSInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DRPSInstruction</h3>
      <p class="pseudocode">// DRPSInstruction()
// =================
// Operation of the A64 DRPS and T32 ERET instructions in Debug state

func DRPSInstruction()
begin

    var sync_errors : boolean = IsFeatureImplemented(FEAT_IESB) &amp;&amp; <a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().IESB == '1';
    if IsFeatureImplemented(FEAT_DoubleFault) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        sync_errors = (sync_errors ||
                       (<a href="shared_pseudocode.html#func_EffectiveEA_0" title="">EffectiveEA</a>() == '1' &amp;&amp; SCR_EL3().NMEA == '1' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>));
    end;
    // The Effective value of SCTLR[].IESB might be zero in Debug state.
    if !<a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_IESBinDebug" title="">Unpredictable_IESBinDebug</a>) then
        sync_errors = FALSE;
    end;
    if sync_errors then
        SynchronizeErrors();
    end;

    SynchronizeContext();

    DebugRestorePSR();

    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DebugHalt"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DebugHalt</h3>
      <p class="pseudocode">// DebugHalt
// =========
// Reason codes for entry to Debug state

constant <a id="global_DebugHalt_Breakpoint"/>DebugHalt_Breakpoint : bits(6)      = '000111';

constant <a id="global_DebugHalt_EDBGRQ"/>DebugHalt_EDBGRQ : bits(6)          = '010011';

constant <a id="global_DebugHalt_Step_Normal"/>DebugHalt_Step_Normal : bits(6)     = '011011';

constant <a id="global_DebugHalt_Step_Exclusive"/>DebugHalt_Step_Exclusive : bits(6)  = '011111';

constant <a id="global_DebugHalt_OSUnlockCatch"/>DebugHalt_OSUnlockCatch : bits(6)   = '100011';

constant <a id="global_DebugHalt_ResetCatch"/>DebugHalt_ResetCatch : bits(6)      = '100111';

constant <a id="global_DebugHalt_Watchpoint"/>DebugHalt_Watchpoint : bits(6)      = '101011';

constant <a id="global_DebugHalt_HaltInstruction"/>DebugHalt_HaltInstruction : bits(6) = '101111';

constant <a id="global_DebugHalt_SoftwareAccess"/>DebugHalt_SoftwareAccess : bits(6)  = '110011';

constant <a id="global_DebugHalt_ExceptionCatch"/>DebugHalt_ExceptionCatch : bits(6)  = '110111';

constant <a id="global_DebugHalt_Step_NoSyndrome"/>DebugHalt_Step_NoSyndrome : bits(6) = '111011';</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DebugRestorePSR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DebugRestorePSR</h3>
      <p class="pseudocode">// DebugRestorePSR()
// =================

func DebugRestorePSR()
begin
    // PSTATE.[N,Z,C,V,Q,GE,SS,D,A,I,F] are not observable and ignored in Debug state, so
    // behave as if UNKNOWN.
    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        let spsr : bits(32) = <a href="shared_pseudocode.html#accessor_SPSR_curr_0" title="">SPSR_curr</a>();
        SetPSTATEFromPSR{32}(spsr);
        PSTATE.[N,Z,C,V,Q,GE,SS,A,I,F] = ARBITRARY : bits(13);
        //  In AArch32, all instructions are T32 and unconditional.
        PSTATE.IT = '00000000';  PSTATE.T = '1';        // PSTATE.J is RES0
        DLR() = ARBITRARY : bits(32);  DSPSR() = ARBITRARY : bits(32);
    else
        let spsr : bits(64) = <a href="shared_pseudocode.html#accessor_SPSR_ELx_0" title="">SPSR_ELx</a>();
        SetPSTATEFromPSR{64}(spsr);
        PSTATE.[N,Z,C,V,SS,D,A,I,F] = ARBITRARY : bits(9);
        DLR_EL0() = ARBITRARY : bits(64);  DSPSR_EL0() = ARBITRARY : bits(64);
    end;
    UpdateEDSCRFields();                                // Update EDSCR PE state flags
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DisableITRAndResumeInstructionPrefetch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DisableITRAndResumeInstructionPrefetch</h3>
      <p class="pseudocode">// DisableITRAndResumeInstructionPrefetch()
// ========================================

impdef func DisableITRAndResumeInstructionPrefetch()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.ExecuteA64"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/ExecuteA64</h3>
      <p class="pseudocode">// ExecuteA64()
// ============
// Execute an A64 instruction in Debug state.

impdef func ExecuteA64(instr : bits(32))
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.ExecuteT32"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/ExecuteT32</h3>
      <p class="pseudocode">// ExecuteT32()
// ============
// Execute a T32 instruction in Debug state.

impdef func ExecuteT32(hw1 : bits(16), hw2 : bits(16))
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.ExitDebugState"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/ExitDebugState</h3>
      <p class="pseudocode">// ExitDebugState()
// ================

func ExitDebugState()
begin
    assert <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>();
    SynchronizeContext();

    // Although EDSCR.STATUS signals that the PE is restarting, debuggers must use EDPRSR.SDR to
    // detect that the PE has restarted.
    EDSCR().STATUS = '000001';                           // Signal restarting
    // Clear any pending Halting debug events
    if IsFeatureImplemented(FEAT_Debugv8p8) then
        EDESR()[3:0] = '0000';
    else
        EDESR()[2:0] = '000';
    end;

    var new_pc : bits(64);
    var spsr : bits(64);

    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        new_pc = ZeroExtend{64}(DLR());
        if IsFeatureImplemented(FEAT_Debugv8p9) then
            spsr = DSPSR2() :: DSPSR();
        else
            spsr = ZeroExtend{64}(DSPSR());
        end;
    else
        new_pc = DLR_EL0();
        spsr = DSPSR_EL0();
    end;

    let illegal_psr_state : boolean = <a href="shared_pseudocode.html#func_IllegalExceptionReturn_2" title="">IllegalExceptionReturn</a>{64}(spsr);
    // If this is an illegal return, SetPSTATEFromPSR() will set PSTATE.IL.
    SetPSTATEFromPSR{64}(spsr); // Can update privileged bits, even at EL0

    let branch_conditional : boolean = FALSE;
    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_RESTARTALIGNPC" title="">Unpredictable_RESTARTALIGNPC</a>) then new_pc[0] = '0'; end;
        // AArch32 branch
        BranchTo{32}(new_pc[31:0], <a href="shared_pseudocode.html#enum_BranchType_DBGEXIT" title="">BranchType_DBGEXIT</a>, branch_conditional);
    else
        // If targeting AArch32 then PC[63:32,1:0] might be set to UNKNOWN.
        if illegal_psr_state &amp;&amp; spsr[4] == '1' then
            new_pc[63:32] = ARBITRARY : bits(32);
            new_pc[1:0] = ARBITRARY : bits(2);
        end;
        if IsFeatureImplemented(FEAT_BRBE) then
            BRBEDebugStateExit(new_pc);
        end;
        // A type of branch that is never predicted
        BranchTo{64}(new_pc, <a href="shared_pseudocode.html#enum_BranchType_DBGEXIT" title="">BranchType_DBGEXIT</a>, branch_conditional);
    end;

     // Atomically signal restarted
    EDSCR().STATUS = '000010';
    EDPRSR().SDR = '1';
    // End of atomically signal
    EDPRSR().HALTED = '0';
    UpdateEDSCRFields();                               // Stop signalling PE state
    DisableITRAndResumeInstructionPrefetch();

    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.Halt"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/Halt</h3>
      <p class="pseudocode">// Halt()
// ======

func Halt(reason : bits(6))
begin
    let is_async : boolean = FALSE;
    let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_0" title="">NoFault</a>();
    Halt(reason, is_async, fault);
end;

// Halt()
// ======

func Halt(reason : bits(6), is_async : boolean, fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    CTI_SignalEvent(<a href="shared_pseudocode.html#enum_CrossTriggerIn_CrossHalt" title="">CrossTriggerIn_CrossHalt</a>);  // Trigger other cores to halt

    let preferred_restart_address : bits(64) = ThisInstrAddr{}();
    var spsr : bits(64) = GetPSRFromPSTATE{}(<a href="shared_pseudocode.html#enum_DebugState" title="">DebugState</a>);

    if (IsFeatureImplemented(FEAT_BTI) &amp;&amp; !is_async &amp;&amp;
          ! reason IN {<a href="shared_pseudocode.html#global_DebugHalt_Step_Normal" title="">DebugHalt_Step_Normal</a>, <a href="shared_pseudocode.html#global_DebugHalt_Step_Exclusive" title="">DebugHalt_Step_Exclusive</a>,
                       <a href="shared_pseudocode.html#global_DebugHalt_Step_NoSyndrome" title="">DebugHalt_Step_NoSyndrome</a>, <a href="shared_pseudocode.html#global_DebugHalt_Breakpoint" title="">DebugHalt_Breakpoint</a>,
                       <a href="shared_pseudocode.html#global_DebugHalt_HaltInstruction" title="">DebugHalt_HaltInstruction</a>} &amp;&amp;
          <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_ZEROBTYPE" title="">Unpredictable_ZEROBTYPE</a>)) then
        spsr[11:10] = '00';
    end;

    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        DLR() = preferred_restart_address[31:0];
        DSPSR() = spsr[31:0];
        if IsFeatureImplemented(FEAT_Debugv8p9) then
            DSPSR2() = spsr[63:32];
        end;
    else
        DLR_EL0() = preferred_restart_address;
        DSPSR_EL0() = spsr;
    end;
    EDSCR().ITE = '1';
    EDSCR().ITO = '0';
    if IsFeatureImplemented(FEAT_RME) then
        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
            EDSCR().SDD = '0';
        else
            EDSCR().SDD = if <a href="shared_pseudocode.html#func_ExternalRootInvasiveDebugEnabled_0" title="">ExternalRootInvasiveDebugEnabled</a>() then '0' else '1';
        end;
    elsif <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
        EDSCR().SDD = '0';                        // If entered in Secure state, allow debug
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        EDSCR().SDD = if <a href="shared_pseudocode.html#func_ExternalSecureInvasiveDebugEnabled_0" title="">ExternalSecureInvasiveDebugEnabled</a>() then '0' else '1';
    else
        EDSCR().SDD = '1';                        // Otherwise EDSCR.SDD is RES1
    end;
    EDSCR().MA = '0';

    // In Debug state:
    // * PSTATE.[SS,SSBS,D,A,I,F] are not observable and ignored so behave-as-if UNKNOWN.
    // * PSTATE.[N,Z,C,V,Q,GE,E,M,nRW,EL,SP,DIT] are also not observable, but since these
    //     are not changed on exception entry, this function also leaves them unchanged.
    // * PSTATE.[IT,T] are ignored.
    // * PSTATE.IL is ignored and behave-as-if 0.
    // * PSTATE.BTYPE is ignored and behave-as-if 0.
    // * PSTATE.TCO is set 1.
    // * PSTATE.PACM is ignored and behave-as-if 0.
    // * PSTATE.[UAO,PAN] are observable and not changed on entry into Debug state.
    // * PSTATE.UINJ is set to 0.

    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        PSTATE.[IT,SS,SSBS,A,I,F,T] = ARBITRARY : bits(14);
    else
        PSTATE.[SS,SSBS,D,A,I,F]    = ARBITRARY : bits(6);
    end;

    if IsFeatureImplemented(FEAT_MTE) then PSTATE.TCO = '1'; end;
    if IsFeatureImplemented(FEAT_BTI) then PSTATE.BTYPE = '00'; end;
    if IsFeatureImplemented(FEAT_PAuth_LR) then PSTATE.PACM = '0'; end;
    PSTATE.IL = '0';
    if IsFeatureImplemented(FEAT_UINJ) then PSTATE.UINJ = '0'; end;
    if IsFeatureImplemented(FEAT_BRBE) then
        BRBEDebugStateEntry(preferred_restart_address);
    end;
    StopInstructionPrefetchAndEnableITR();
    // atomic write
    EDSCR().STATUS = reason;
    EDPRSR().HALTED = '1';
    // end of atomic write
    UpdateEDSCRFields();                        // Update EDSCR PE state flags.
    if IsFeatureImplemented(FEAT_EDHSR) then
        UpdateEDHSR(reason, fault);             // Update EDHSR fields.
    end;
    if !is_async then EndOfInstruction(); end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.HaltOnBreakpointOrWatchpoint"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/HaltOnBreakpointOrWatchpoint</h3>
      <p class="pseudocode">// HaltOnBreakpointOrWatchpoint()
// ==============================
// Returns TRUE if the Breakpoint and Watchpoint debug events should be considered for Debug
// state entry, FALSE if they should be considered for a debug exception.

func <a id="func_HaltOnBreakpointOrWatchpoint_0"/>HaltOnBreakpointOrWatchpoint() =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_HaltingAllowed_0" title="">HaltingAllowed</a>() &amp;&amp; EDSCR().HDE == '1' &amp;&amp; OSLSR_EL1().OSLK == '0';
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.Halted"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/Halted</h3>
      <p class="pseudocode">// Halted()
// ========

readonly func <a id="func_Halted_0"/>Halted() =&gt; boolean
begin
    return ! EDSCR().STATUS IN {'000001', '000010'};                    // Halted
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.HaltingAllowed"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/HaltingAllowed</h3>
      <p class="pseudocode">// HaltingAllowed()
// ================
// Returns TRUE if halting is currently allowed, FALSE if halting is prohibited.

func <a id="func_HaltingAllowed_0"/>HaltingAllowed() =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() || <a href="shared_pseudocode.html#func_DoubleLockStatus_0" title="">DoubleLockStatus</a>() then
        return FALSE;
    end;
    let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();
    case ss of
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt; return <a href="shared_pseudocode.html#func_ExternalInvasiveDebugEnabled_0" title="">ExternalInvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;    return <a href="shared_pseudocode.html#func_ExternalSecureInvasiveDebugEnabled_0" title="">ExternalSecureInvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> =&gt;      return <a href="shared_pseudocode.html#func_ExternalRootInvasiveDebugEnabled_0" title="">ExternalRootInvasiveDebugEnabled</a>();
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;     return <a href="shared_pseudocode.html#func_ExternalRealmInvasiveDebugEnabled_0" title="">ExternalRealmInvasiveDebugEnabled</a>();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.Restarting"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/Restarting</h3>
      <p class="pseudocode">// Restarting()
// ============

readonly func <a id="func_Restarting_0"/>Restarting() =&gt; boolean
begin
    return EDSCR().STATUS == '000001';                                  // Restarting
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.StopInstructionPrefetchAndEnableITR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/StopInstructionPrefetchAndEnableITR</h3>
      <p class="pseudocode">// StopInstructionPrefetchAndEnableITR()
// =====================================

impdef func StopInstructionPrefetchAndEnableITR()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.UpdateDbgAuthStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/UpdateDbgAuthStatus</h3>
      <p class="pseudocode">// UpdateDbgAuthStatus()
// =====================
// Provides information about the state of the
// IMPLEMENTATION DEFINED authentication interface for debug.

func UpdateDbgAuthStatus()
begin
    var nsid, nsnid : bits(2);
    var sid, snid : bits(2);
    var rlid, rtid : bits(2);
    if <a href="shared_pseudocode.html#func_SecureOnlyImplementation_0" title="">SecureOnlyImplementation</a>() then
        nsid = '00';
    elsif <a href="shared_pseudocode.html#func_ExternalInvasiveDebugEnabled_0" title="">ExternalInvasiveDebugEnabled</a>() then
        nsid = '11';          // Non-secure Invasive debug implemented and enabled.
    else
        nsid = '10';          // Non-secure Invasive debug implemented and disabled.
    end;

    if <a href="shared_pseudocode.html#func_SecureOnlyImplementation_0" title="">SecureOnlyImplementation</a>() then
        nsnid = '00';
    elsif <a href="shared_pseudocode.html#func_ExternalNoninvasiveDebugEnabled_0" title="">ExternalNoninvasiveDebugEnabled</a>() then
        nsnid = '11';         // Non-secure Non-Invasive debug implemented and enabled.
    else
        nsnid = '10';         // Non-secure Non-Invasive debug implemented and disabled.
    end;

    if !<a href="shared_pseudocode.html#func_HaveSecureState_0" title="">HaveSecureState</a>() then
        sid = '00';
    elsif <a href="shared_pseudocode.html#func_ExternalSecureInvasiveDebugEnabled_0" title="">ExternalSecureInvasiveDebugEnabled</a>() then
        sid = '11';           // Secure Invasive debug implemented and enabled.
    else
        sid = '10';           // Secure Invasive debug implemented and disabled.
    end;

    if !<a href="shared_pseudocode.html#func_HaveSecureState_0" title="">HaveSecureState</a>() then
        snid = '00';
    elsif <a href="shared_pseudocode.html#func_ExternalSecureNoninvasiveDebugEnabled_0" title="">ExternalSecureNoninvasiveDebugEnabled</a>() then
        snid = '11';          // Secure Non-Invasive debug implemented and enabled.
    else
        snid = '10';          // Secure Non-Invasive debug implemented and disabled.
    end;

    if !IsFeatureImplemented(FEAT_RME) then
        rlid = '00';
    elsif <a href="shared_pseudocode.html#func_ExternalRealmInvasiveDebugEnabled_0" title="">ExternalRealmInvasiveDebugEnabled</a>() then
        rlid = '11';          // Realm Invasive debug implemented and enabled.
    else
        rlid = '10';          // Realm Invasive debug implemented and disabled.
    end;

    if !IsFeatureImplemented(FEAT_RME) then
        rtid = '00';
    elsif <a href="shared_pseudocode.html#func_ExternalRootInvasiveDebugEnabled_0" title="">ExternalRootInvasiveDebugEnabled</a>() then
        rtid = '11';          // Root Invasive debug implemented and enabled.
    else
        rtid = '10';          // Root Invasive debug implemented and disabled.
    end;

    DBGAUTHSTATUS_EL1().NSID  = nsid;
    DBGAUTHSTATUS_EL1().NSNID = nsnid;
    DBGAUTHSTATUS_EL1().SID   = sid;
    DBGAUTHSTATUS_EL1().SNID  = snid;
    DBGAUTHSTATUS_EL1().RLID  = rlid;
    DBGAUTHSTATUS_EL1().RLNID = rlid;    // Field has the same value as DBGAUTHSTATUS_EL1.RLID.
    DBGAUTHSTATUS_EL1().RTID  = rtid;
    DBGAUTHSTATUS_EL1().RTNID = rtid;    // Field has the same value as DBGAUTHSTATUS_EL1.RTID.
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.UpdateEDHSR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/UpdateEDHSR</h3>
      <p class="pseudocode">// UpdateEDHSR()
// =============
// Update EDHSR watchpoint related fields.

func UpdateEDHSR(reason : bits(6), fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    var syndrome : bits(64) = Zeros{};
    if reason == <a href="shared_pseudocode.html#global_DebugHalt_Watchpoint" title="">DebugHalt_Watchpoint</a> then
        if IsFeatureImplemented(FEAT_GCS) &amp;&amp; fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_GCS" title="">AccessType_GCS</a> then
            syndrome[40] = '1';                        // GCS
        end;
        syndrome[23:0] = <a href="shared_pseudocode.html#func_WatchpointRelatedSyndrome_1" title="">WatchpointRelatedSyndrome</a>(fault);
        if IsFeatureImplemented(FEAT_Debugv8p9) then
            if fault.write then syndrome[6] = '1'; end; // WnR
            if fault.accessdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>, <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>} then
                syndrome[8] = '1';                     // CM
            end;
            if IsFeatureImplemented(FEAT_NV2) &amp;&amp; fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_NV2" title="">AccessType_NV2</a> then
                syndrome[13] = '1';                    // VNCR
            end;
        end;
    else
        syndrome = ARBITRARY : bits(64);
    end;

    EDHSR() = syndrome;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.UpdateEDSCRFields"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/UpdateEDSCRFields</h3>
      <p class="pseudocode">// UpdateEDSCRFields()
// ===================
// Update EDSCR PE state fields

func UpdateEDSCRFields()
begin
    if !<a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        EDSCR().EL = '00';
        if IsFeatureImplemented(FEAT_RME) then
           // SDD bit.
            EDSCR().SDD = if <a href="shared_pseudocode.html#func_ExternalRootInvasiveDebugEnabled_0" title="">ExternalRootInvasiveDebugEnabled</a>() then '0' else '1';
            EDSCR().[NSE,NS] = ARBITRARY : bits(2);
        else
            // SDD bit.
            EDSCR().SDD = if <a href="shared_pseudocode.html#func_ExternalSecureInvasiveDebugEnabled_0" title="">ExternalSecureInvasiveDebugEnabled</a>() then '0' else '1';
            EDSCR().NS = ARBITRARY : bit;
        end;

        EDSCR().RW = '1111';
    else
        EDSCR().EL = PSTATE.EL;
        // SError Pending.
        if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().[AMO,TGE] == '10'  &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>,<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} then
            EDSCR().A = if <a href="shared_pseudocode.html#func_IsVirtualSErrorPending_0" title="">IsVirtualSErrorPending</a>() then '1' else '0';
        elsif (IsFeatureImplemented(FEAT_E3DSE) &amp;&amp; SCR_EL3().EnDSE == '1' &amp;&amp;
               PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>,<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>,<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>}) then
            EDSCR().A = if <a href="shared_pseudocode.html#func_IsDelegatedSErrorPending_0" title="">IsDelegatedSErrorPending</a>() then '1' else '0';
        else
            EDSCR().A = if <a href="shared_pseudocode.html#func_IsPhysicalSErrorPending_0" title="">IsPhysicalSErrorPending</a>() then '1' else '0';
        end;

        let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();
        if IsFeatureImplemented(FEAT_RME) then
            case ss of
                when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;    EDSCR().[NSE,NS] = '00';
                when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt; EDSCR().[NSE,NS] = '01';
                when <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> =&gt;      EDSCR().[NSE,NS] = '10';
                when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;     EDSCR().[NSE,NS] = '11';
            end;
        else
            EDSCR().NS = if ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then '0' else '1';
        end;

        var RW : bits(4);
        RW[1] = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then '0' else '1';
        if PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
            RW[0] = RW[1];
        else
            RW[0] = if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then '0' else '1';
        end;
        if !<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
            RW[2] = RW[1];
        else
            RW[2] = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then '0' else '1';
        end;
        if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            RW[3] = RW[2];
        else
            RW[3] = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then '0' else '1';
        end;

        // The least-significant bits of EDSCR.RW are UNKNOWN if any higher EL is using AArch32_
        if RW[3] == '0' then RW[2:0] = ARBITRARY : bits(3);
        elsif RW[2] == '0' then RW[1:0] = ARBITRARY : bits(2);
        elsif RW[1] == '0' then RW[0] = ARBITRARY : bit; end;
        EDSCR().RW = RW;
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents</h3>
      <p class="pseudocode">var EDBGRQ : <a href="shared_pseudocode.html#Signal" title="type Signal">Signal</a>; // Input Signal in external debug interface</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckEDBGRQ"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckEDBGRQ</h3>
      <p class="pseudocode">// CheckEDBGRQ()
// =============
// Checks IMPLEMENTATION DEFINED EDBGRQ Input Signal of external debug interface.
// This is an example of an IMPLEMENTATION DEFINED source of External Debug Request debug events.

func CheckEDBGRQ()
begin
    if EDBGRQ == HIGH then
        ExternalDebugRequest();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckExceptionCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckExceptionCatch</h3>
      <p class="pseudocode">// CheckExceptionCatch()
// =====================
// Check whether an Exception Catch debug event is set on the current Exception level

func CheckExceptionCatch(exception_entry : boolean)
begin
    // Called after an exception entry or exit, that is, such that the Security state
    // and PSTATE.EL are correct for the exception target. When FEAT_Debugv8p2
    // is not implemented, this function might also be called at any time.
    let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(PSTATE.EL);
    var base : integer;

    case ss of
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>    =&gt; base = 0;
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt; base = 4;
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a>     =&gt; base = 16;
        when <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a>      =&gt; base = 0;
    end;
    if <a href="shared_pseudocode.html#func_HaltingAllowed_0" title="">HaltingAllowed</a>() then
        var halt : boolean;
        if IsFeatureImplemented(FEAT_Debugv8p2) then
            let exception_exit : boolean = !exception_entry;
            let increment : integer{} = if ss == <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> then 4 else 8;
            let ctrl : bits(2) = (EDECCR()[UInt(PSTATE.EL) + base + increment]::
                                    EDECCR()[UInt(PSTATE.EL) + base]);
            case ctrl of
                when '00' =&gt;  halt = FALSE;
                when '01' =&gt;  halt = TRUE;
                when '10' =&gt;  halt = (exception_exit == TRUE);
                when '11' =&gt;  halt = (exception_entry == TRUE);
            end;
        else
            halt = (EDECCR()[UInt(PSTATE.EL) + base] == '1');
        end;

        if halt then
            if IsFeatureImplemented(FEAT_Debugv8p8) &amp;&amp; exception_entry then
                EDESR().EC = '1';
            else
                Halt(<a href="shared_pseudocode.html#global_DebugHalt_ExceptionCatch" title="">DebugHalt_ExceptionCatch</a>);
            end;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckExternalDebugRequestEvents"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckExternalDebugRequestEvents</h3>
      <p class="pseudocode">// CheckExternalDebugRequestEvents()
// =================================
// Checks for all External Debug Request debug events.

func CheckExternalDebugRequestEvents()
begin
    CheckTRBEHalt();
    CheckPMUHalt();
    CheckEDBGRQ();
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckHaltingStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckHaltingStep</h3>
      <p class="pseudocode">// CheckHaltingStep()
// ==================
// Check whether EDESR.SS has been set by Halting Step

func CheckHaltingStep(is_async : boolean)
begin
    let step_enabled : boolean = EDECR().SS == '1' &amp;&amp; <a href="shared_pseudocode.html#func_HaltingAllowed_0" title="">HaltingAllowed</a>();
    let active_pending : boolean = step_enabled &amp;&amp; EDESR().SS == '1';
    if active_pending then
        if <a href="shared_pseudocode.html#func_HaltingStep_DidNotStep_0" title="">HaltingStep_DidNotStep</a>() then
            let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_0" title="">NoFault</a>();
            Halt(<a href="shared_pseudocode.html#global_DebugHalt_Step_NoSyndrome" title="">DebugHalt_Step_NoSyndrome</a>, is_async, fault);
        elsif <a href="shared_pseudocode.html#func_HaltingStep_SteppedEX_0" title="">HaltingStep_SteppedEX</a>() then
            let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_0" title="">NoFault</a>();
            Halt(<a href="shared_pseudocode.html#global_DebugHalt_Step_Exclusive" title="">DebugHalt_Step_Exclusive</a>, is_async, fault);
        else
            let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_0" title="">NoFault</a>();
            Halt(<a href="shared_pseudocode.html#global_DebugHalt_Step_Normal" title="">DebugHalt_Step_Normal</a>, is_async, fault);
        end;
    end;
    if step_enabled then <a href="shared_pseudocode.html#global_ShouldAdvanceHS" title="">ShouldAdvanceHS</a> = TRUE; end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckOSUnlockCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckOSUnlockCatch</h3>
      <p class="pseudocode">// CheckOSUnlockCatch()
// ====================
// Called on unlocking the OS Lock to pend an OS Unlock Catch debug event

func CheckOSUnlockCatch()
begin
    if ((IsFeatureImplemented(FEAT_DoPD) &amp;&amp; CTIDEVCTL().OSUCE == '1') ||
          (!IsFeatureImplemented(FEAT_DoPD) &amp;&amp; EDECR().OSUCE == '1')) then
        if !<a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then EDESR().OSUC = '1'; end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckPMUHalt"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckPMUHalt</h3>
      <p class="pseudocode">// CheckPMUHalt()
// ==============

func CheckPMUHalt()
begin
    if !IsFeatureImplemented(FEAT_Debugv8p9) || !IsFeatureImplemented(FEAT_PMUv3p9) then
        return;
    end;

    // The request remains set until the condition is cleared.
    // For example, an interrupt handler or cross-triggered event handler clears
    // the overflow status flag by writing to PMOVSCLR_EL0

    let include_r1 : boolean = TRUE;
    let include_r2 : boolean = TRUE;
    let include_r3 : boolean = TRUE;

    let pmuhalt : boolean = <a href="shared_pseudocode.html#func_CheckPMUOverflowCondition_4" title="">CheckPMUOverflowCondition</a>(<a href="shared_pseudocode.html#enum_PMUOverflowCondition_EDBGRQ" title="">PMUOverflowCondition_EDBGRQ</a>,
                                                      include_r1, include_r2, include_r3);
    if pmuhalt &amp;&amp; EDECR().PME == '1' then
        ExternalDebugRequest();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckPendingExceptionCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckPendingExceptionCatch</h3>
      <p class="pseudocode">// CheckPendingExceptionCatch()
// ============================
// Check whether EDESR.EC has been set by an Exception Catch debug event.

func CheckPendingExceptionCatch(is_async : boolean)
begin
    if IsFeatureImplemented(FEAT_Debugv8p8) &amp;&amp; <a href="shared_pseudocode.html#func_HaltingAllowed_0" title="">HaltingAllowed</a>() &amp;&amp; EDESR().EC == '1' then
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_0" title="">NoFault</a>();
        Halt(<a href="shared_pseudocode.html#global_DebugHalt_ExceptionCatch" title="">DebugHalt_ExceptionCatch</a>, is_async, fault);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckPendingOSUnlockCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckPendingOSUnlockCatch</h3>
      <p class="pseudocode">// CheckPendingOSUnlockCatch()
// ===========================
// Check whether EDESR.OSUC has been set by an OS Unlock Catch debug event

func CheckPendingOSUnlockCatch()
begin
    if <a href="shared_pseudocode.html#func_HaltingAllowed_0" title="">HaltingAllowed</a>() &amp;&amp; EDESR().OSUC == '1' then
        let is_async : boolean = TRUE;
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_0" title="">NoFault</a>();
        Halt(<a href="shared_pseudocode.html#global_DebugHalt_OSUnlockCatch" title="">DebugHalt_OSUnlockCatch</a>, is_async, fault);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckPendingResetCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckPendingResetCatch</h3>
      <p class="pseudocode">// CheckPendingResetCatch()
// ========================
// Check whether EDESR.RC has been set by a Reset Catch debug event

func CheckPendingResetCatch()
begin
    if <a href="shared_pseudocode.html#func_HaltingAllowed_0" title="">HaltingAllowed</a>() &amp;&amp; EDESR().RC == '1' then
        let is_async : boolean = TRUE;
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_0" title="">NoFault</a>();
        Halt(<a href="shared_pseudocode.html#global_DebugHalt_ResetCatch" title="">DebugHalt_ResetCatch</a>, is_async, fault);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckResetCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckResetCatch</h3>
      <p class="pseudocode">// CheckResetCatch()
// =================
// Called after reset

func CheckResetCatch()
begin
    if ((IsFeatureImplemented(FEAT_DoPD) &amp;&amp; CTIDEVCTL().RCE == '1') ||
          (!IsFeatureImplemented(FEAT_DoPD) &amp;&amp; EDECR().RCE == '1')) then
        EDESR().RC = '1';
        // If halting is allowed then halt immediately
        if <a href="shared_pseudocode.html#func_HaltingAllowed_0" title="">HaltingAllowed</a>() then Halt(<a href="shared_pseudocode.html#global_DebugHalt_ResetCatch" title="">DebugHalt_ResetCatch</a>); end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckSoftwareAccessToDebugRegisters"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckSoftwareAccessToDebugRegisters</h3>
      <p class="pseudocode">// CheckSoftwareAccessToDebugRegisters()
// =====================================
// Check for access to Breakpoint and Watchpoint registers.

func CheckSoftwareAccessToDebugRegisters()
begin
    let os_lock : bit = (if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then DBGOSLSR().OSLK else OSLSR_EL1().OSLK);
    if <a href="shared_pseudocode.html#func_HaltingAllowed_0" title="">HaltingAllowed</a>() &amp;&amp; EDSCR().TDA == '1' &amp;&amp; os_lock == '0' then
        Halt(<a href="shared_pseudocode.html#global_DebugHalt_SoftwareAccess" title="">DebugHalt_SoftwareAccess</a>);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckTRBEHalt"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckTRBEHalt</h3>
      <p class="pseudocode">// CheckTRBEHalt()
// ===============

func CheckTRBEHalt()
begin
    if !IsFeatureImplemented(FEAT_Debugv8p9) || !IsFeatureImplemented(FEAT_TRBE_EXT) then
        return;
    end;

    if <a href="shared_pseudocode.html#func_TraceBufferEnabled_0" title="">TraceBufferEnabled</a>() &amp;&amp; TRBSR_EL1().IRQ == '1' &amp;&amp; EDECR().TRBE == '1' then
        ExternalDebugRequest();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.ExternalDebugRequest"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/ExternalDebugRequest</h3>
      <p class="pseudocode">// ExternalDebugRequest()
// ======================

func ExternalDebugRequest()
begin
    if <a href="shared_pseudocode.html#func_HaltingAllowed_0" title="">HaltingAllowed</a>() then
        let is_async : boolean = TRUE;
        let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_0" title="">NoFault</a>();
        Halt(<a href="shared_pseudocode.html#global_DebugHalt_EDBGRQ" title="">DebugHalt_EDBGRQ</a>, is_async, fault);
    // Otherwise the CTI continues to assert the debug request until it is taken.
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.HSAdvance"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/HSAdvance</h3>
      <p class="pseudocode">// HSAdvance()
// ===========
// Advance the Halting Step State Machine

func HSAdvance()
begin
    if !<a href="shared_pseudocode.html#global_ShouldAdvanceHS" title="">ShouldAdvanceHS</a> then return; end;
    let step_enabled : boolean = EDECR().SS == '1' &amp;&amp; <a href="shared_pseudocode.html#func_HaltingAllowed_0" title="">HaltingAllowed</a>();
    let active_not_pending : boolean = step_enabled &amp;&amp; EDESR().SS == '0';
    if active_not_pending then EDESR().SS = '1'; end;  // set as pending.
    <a href="shared_pseudocode.html#global_ShouldAdvanceHS" title="">ShouldAdvanceHS</a> = FALSE;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.HaltingStep_DidNotStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/HaltingStep_DidNotStep</h3>
      <p class="pseudocode">// HaltingStep_DidNotStep()
// ========================
// Returns TRUE if the previously executed instruction was executed in the inactive state, that is,
// if it was not itself stepped.

impdef func <a id="func_HaltingStep_DidNotStep_0"/>HaltingStep_DidNotStep() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.HaltingStep_SteppedEX"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/HaltingStep_SteppedEX</h3>
      <p class="pseudocode">// HaltingStep_SteppedEX()
// =======================
// Returns TRUE if the previously executed instruction was a Load-Exclusive class instruction
// executed in the active-not-pending state.

impdef func <a id="func_HaltingStep_SteppedEX_0"/>HaltingStep_SteppedEX() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.interrupts.ExternalDebugInterruptsDisabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/interrupts/ExternalDebugInterruptsDisabled</h3>
      <p class="pseudocode">// ExternalDebugInterruptsDisabled()
// =================================
// Determine whether EDSCR disables interrupts routed to 'target'.

func <a id="func_ExternalDebugInterruptsDisabled_1"/>ExternalDebugInterruptsDisabled(target : bits(2)) =&gt; boolean
begin
    var int_dis : boolean;
    let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(target);
    if IsFeatureImplemented(FEAT_Debugv8p4) then
        if EDSCR().INTdis[0] == '1' then
            case ss of
                when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt; int_dis = <a href="shared_pseudocode.html#func_ExternalInvasiveDebugEnabled_0" title="">ExternalInvasiveDebugEnabled</a>();
                when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;    int_dis = <a href="shared_pseudocode.html#func_ExternalSecureInvasiveDebugEnabled_0" title="">ExternalSecureInvasiveDebugEnabled</a>();
                when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;     int_dis = <a href="shared_pseudocode.html#func_ExternalRealmInvasiveDebugEnabled_0" title="">ExternalRealmInvasiveDebugEnabled</a>();
                when <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> =&gt;      int_dis = <a href="shared_pseudocode.html#func_ExternalRootInvasiveDebugEnabled_0" title="">ExternalRootInvasiveDebugEnabled</a>();
            end;
        else
            int_dis = FALSE;
        end;
    else
        case target of
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
                int_dis = (EDSCR().INTdis == '11' &amp;&amp; <a href="shared_pseudocode.html#func_ExternalSecureInvasiveDebugEnabled_0" title="">ExternalSecureInvasiveDebugEnabled</a>());
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
                int_dis = (EDSCR().INTdis == '1x' &amp;&amp; <a href="shared_pseudocode.html#func_ExternalInvasiveDebugEnabled_0" title="">ExternalInvasiveDebugEnabled</a>());
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
                if ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
                    int_dis = (EDSCR().INTdis == '1x' &amp;&amp; <a href="shared_pseudocode.html#func_ExternalSecureInvasiveDebugEnabled_0" title="">ExternalSecureInvasiveDebugEnabled</a>());
                else
                    int_dis = (EDSCR().INTdis != '00' &amp;&amp; <a href="shared_pseudocode.html#func_ExternalInvasiveDebugEnabled_0" title="">ExternalInvasiveDebugEnabled</a>());
                end;
        end;
    end;
    return int_dis;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu</h3>
      <p class="pseudocode">var <a id="global_PMUEventAccumulator"/>PMUEventAccumulator : array [[31]] of integer;  // Accumulates PMU events for a cycle

var <a id="global_PMULastThresholdValue"/>PMULastThresholdValue : array [[31]] of boolean;// A record of the threshold result for each

// Constant used in PMU functions to represent actions on the cycle counter.
constant <a id="global_CYCLE_COUNTER_ID"/>CYCLE_COUNTER_ID : integer = 31;

// Constant used in PMU functions to represent actions on the instruction counter.
constant <a id="global_INSTRUCTION_COUNTER_ID"/>INSTRUCTION_COUNTER_ID : integer = 32;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.CheckForPMUOverflow"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/CheckForPMUOverflow</h3>
      <p class="pseudocode">// CheckForPMUOverflow()
// =====================
// Called before each instruction is executed.
// If a PMU event counter has overflowed, this function might do any of:
//  - Signal a Performance Monitors overflow interrupt request.
//  - Signal a CTI Performance Monitors overflow event.
//  - Generate an External Debug Request debug event.
//  - Generate a BRBE freeze event.

func CheckForPMUOverflow()
begin
    let include_r1 : boolean = TRUE;
    let include_r2 : boolean = TRUE;
    let include_r3 : boolean = TRUE;

    let enabled : boolean = <a href="shared_pseudocode.html#func_PMUInterruptEnabled_0" title="">PMUInterruptEnabled</a>();
    let pmuirq : boolean = <a href="shared_pseudocode.html#func_CheckPMUOverflowCondition_4" title="">CheckPMUOverflowCondition</a>(<a href="shared_pseudocode.html#enum_PMUOverflowCondition_IRQ" title="">PMUOverflowCondition_IRQ</a>,
                                                     include_r1, include_r2, include_r3);

    SetInterruptRequestLevel(<a href="shared_pseudocode.html#enum_InterruptID_PMUIRQ" title="">InterruptID_PMUIRQ</a>,
                             if enabled &amp;&amp; pmuirq then HIGH else LOW);
    CTI_SetEventLevel(<a href="shared_pseudocode.html#enum_CrossTriggerIn_PMUOverflow" title="">CrossTriggerIn_PMUOverflow</a>,
                      if pmuirq then HIGH else LOW);

    if <a href="shared_pseudocode.html#func_ShouldBRBEFreeze_0" title="">ShouldBRBEFreeze</a>() then
        BRBEFreeze();
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.CheckPMUOverflowCondition"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/CheckPMUOverflowCondition</h3>
      <p class="pseudocode">// CheckPMUOverflowCondition()
// ===========================
// Checks for PMU overflow under certain parameter conditions described by 'reason'.
// If 'include_r1' is TRUE, then check counters in the range [0..(HPMN-1)], CCNTR
//     and ICNTR, unless excluded by 'reason'.
// If 'include_r2' is TRUE, then check counters in the range [HPMN..(EPMN-1)].
// If 'include_r3' is TRUE, then check counters in the range [EPMN..(N-1)].

func <a id="func_CheckPMUOverflowCondition_4"/>CheckPMUOverflowCondition(reason : <a href="shared_pseudocode.html#type_PMUOverflowCondition" title="">PMUOverflowCondition</a>,
                               include_r1 : boolean, include_r2 : boolean, include_r3 : boolean
                              ) =&gt; boolean
begin
    // 'reason' is decoded into a further set of parameters:
    // If 'check_e' is TRUE, then check the applicable one of PMCR_EL0.E and MDCR_EL2.HPME.
    // If 'check_inten' is TRUE, then check the applicable PMINTENCLR_EL1 bit.
    // If 'exclude_cyc' is TRUE, then CCNTR is NOT checked.
    // If 'exclude_sync' is TRUE, then counters in synchronous mode are NOT checked.
    var check_e : boolean;
    var check_inten : boolean;
    var exclude_cyc : boolean;
    var exclude_sync : boolean;

    case reason of
        when <a href="shared_pseudocode.html#enum_PMUOverflowCondition_PMUException" title="">PMUOverflowCondition_PMUException</a> =&gt;
            check_e      = TRUE;
            check_inten  = TRUE;
            exclude_cyc  = FALSE;
            exclude_sync = IsFeatureImplemented(FEAT_SEBEP);
        when <a href="shared_pseudocode.html#enum_PMUOverflowCondition_BRBEFreeze" title="">PMUOverflowCondition_BRBEFreeze</a> =&gt;
            check_e      = FALSE;
            check_inten  = FALSE;
            exclude_cyc  = TRUE;
            exclude_sync = IsFeatureImplemented(FEAT_SEBEP);
        when <a href="shared_pseudocode.html#enum_PMUOverflowCondition_Freeze" title="">PMUOverflowCondition_Freeze</a> =&gt;
            check_e      = FALSE;
            check_inten  = FALSE;
            exclude_cyc  = TRUE;
            exclude_sync = IsFeatureImplemented(FEAT_SEBEP);
        when <a href="shared_pseudocode.html#enum_PMUOverflowCondition_IRQ" title="">PMUOverflowCondition_IRQ</a>, <a href="shared_pseudocode.html#enum_PMUOverflowCondition_EDBGRQ" title="">PMUOverflowCondition_EDBGRQ</a> =&gt;
            check_e      = TRUE;
            check_inten  = TRUE;
            exclude_cyc  = FALSE;
            exclude_sync = FALSE;
        otherwise =&gt;
            unreachable;
    end;

    var ovsf : bits(64);

    if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
        ovsf = PMOVSSET_EL0();
        ovsf[63:33] = Zeros{31};
        if !IsFeatureImplemented(FEAT_PMUv3_ICNTR) then
            ovsf[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] = '0';
        end;
    else
        ovsf = ZeroExtend{64}(PMOVSSET());
    end;

    let counters : integer{} = NUM_PMU_COUNTERS;
    // Remove unimplemented counters - these fields are RES0
    if counters &lt; 31 then
        ovsf[30:counters] = Zeros{31-counters};
    end;

    for idx = 0 to counters - 1 do
        var global_en : bit;
        case <a href="shared_pseudocode.html#func_GetPMUCounterRange_1" title="">GetPMUCounterRange</a>(idx) of
            when <a href="shared_pseudocode.html#enum_PMUCounterRange_R1" title="">PMUCounterRange_R1</a> =&gt;
                global_en = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then PMCR_EL0().E else PMCR().E;
                if !include_r1 then
                    ovsf[idx] = '0';
                end;
            when <a href="shared_pseudocode.html#enum_PMUCounterRange_R2" title="">PMUCounterRange_R2</a> =&gt;
                global_en = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then MDCR_EL2().HPME else HDCR().HPME;
                if !include_r2 then
                    ovsf[idx] = '0';
                end;
            when <a href="shared_pseudocode.html#enum_PMUCounterRange_R3" title="">PMUCounterRange_R3</a> =&gt;
                global_en = PMCCR().EPME;
                if !include_r3 then
                    ovsf[idx] = '0';
                end;
            otherwise =&gt;
                unreachable;
        end;
        if exclude_sync then
            let sync : bit = PMEVTYPER_EL0(idx).SYNC;
            ovsf[idx] = ovsf[idx] AND NOT sync;
        end;
        if check_e then
            ovsf[idx] = ovsf[idx] AND global_en;
        end;
    end;

    // Cycle counter
    if exclude_cyc || !include_r1 then
        ovsf[<a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a>] = '0';
    end;

    if check_e then
        ovsf[<a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a>] = ovsf[<a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a>] AND PMCR_EL0().E;
    end;

    // Instruction counter
    if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() &amp;&amp; IsFeatureImplemented(FEAT_PMUv3_ICNTR) then
        if !include_r1 then
            ovsf[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] = '0';
        end;
        if exclude_sync then
            let sync : bit = PMICFILTR_EL0().SYNC;
            ovsf[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] = ovsf[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] AND NOT sync;
        end;
        if check_e then
            ovsf[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] = ovsf[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] AND PMCR_EL0().E;
        end;
    end;

    if check_inten then
        let inten : bits(64) = (if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then PMINTENCLR_EL1()
                                   else ZeroExtend{64}(PMINTENCLR()));
        ovsf = ovsf AND inten;
    end;

    return !IsZero(ovsf);
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.ClearEventCounters"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/ClearEventCounters</h3>
      <p class="pseudocode">// ClearEventCounters()
// ====================
// Zero all the event counters.
// Called on a write to PMCR_EL0 or PMCR that writes '1' to PMCR_EL0.P or PMCR.P.

func ClearEventCounters()
begin
    // Although ZeroPMUCounters implements the functionality for PMUACR_EL1
    // that is part of FEAT_PMUv3p9, it should be noted that writes to
    // PMCR_EL0 are not allowed at EL0 when PMUSERENR_EL0.UEN is 1, meaning
    // it is not relevant in this case.
    ZeroPMUCounters(Zeros{33} :: Ones{31});
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.CountPMUEvents"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/CountPMUEvents</h3>
      <p class="pseudocode">// CountPMUEvents()
// ================
// Return TRUE if counter "idx" should count its event.
// For the cycle counter, idx == CYCLE_COUNTER_ID (31).
// For the instruction counter, idx == INSTRUCTION_COUNTER_ID (32).

func <a id="func_CountPMUEvents_1"/>CountPMUEvents(idx : integer) =&gt; boolean
begin
    let counters : integer = NUM_PMU_COUNTERS;
    assert (idx == <a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a> || idx &lt; counters ||
            (idx == <a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a> &amp;&amp; IsFeatureImplemented(FEAT_PMUv3_ICNTR)));

    var debug : boolean;
    var enabled : boolean;
    var prohibited : boolean;
    var filtered : boolean;
    var frozen : boolean;

    // Event counting is disabled in Debug state
    debug = <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>();

    // Software can reserve some counters
    let counter_range : <a href="shared_pseudocode.html#type_PMUCounterRange" title="">PMUCounterRange</a> = <a href="shared_pseudocode.html#func_GetPMUCounterRange_1" title="">GetPMUCounterRange</a>(idx);
    var ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();

    // Main enable controls
    var global_en : bit;
    var counter_en : bit;
    case counter_range of
        when <a href="shared_pseudocode.html#enum_PMUCounterRange_R1" title="">PMUCounterRange_R1</a> =&gt;
            global_en = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then PMCR_EL0().E else PMCR().E;
        when <a href="shared_pseudocode.html#enum_PMUCounterRange_R2" title="">PMUCounterRange_R2</a> =&gt;
            global_en = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then MDCR_EL2().HPME else HDCR().HPME;
        when <a href="shared_pseudocode.html#enum_PMUCounterRange_R3" title="">PMUCounterRange_R3</a> =&gt;
            assert IsFeatureImplemented(FEAT_PMUv3_EXTPMN);
            global_en = PMCCR().EPME;
        otherwise =&gt;
            unreachable;
    end;

    case idx of
        when <a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a> =&gt;
            assert <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>();
            counter_en = PMCNTENSET_EL0().F0;
        when <a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a> =&gt;
            counter_en = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then PMCNTENSET_EL0().C else PMCNTENSET().C;
        otherwise =&gt;
            counter_en = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then PMCNTENSET_EL0()[idx] else PMCNTENSET()[idx];
            // Event counter [n] does not count when all of the following are true:
            // - FEAT_SEBEP is implemented
            // - PMEVTYPER_EL0(n).SYNC == 1
            // - Event counter [n] is configured to count an event that is not a synchronous event
            if (IsFeatureImplemented(FEAT_SEBEP) &amp;&amp; PMEVTYPER_EL0(idx).SYNC == '1' &amp;&amp;
                  !<a href="shared_pseudocode.html#func_IsSupportingPMUSynchronousMode_1" title="">IsSupportingPMUSynchronousMode</a>(PMEVTYPER_EL0(idx).evtCount)) then
                counter_en = '0';
            end;
    end;

    enabled = global_en == '1' &amp;&amp; counter_en == '1';

    // Event counting is allowed unless it is prohibited by any rule below
    prohibited = FALSE;

    // Event counting in Secure state or at EL3 is prohibited if all of:
    // * EL3 is implemented
    // * One of the following is true:
    //   - EL3 is using AArch64, MDCR_EL3.SPME == 0, and either:
    //     - FEAT_PMUv3p7 is not implemented
    //     - MDCR_EL3.MPMX == 0
    //   - EL3 is using AArch32 and SDCR.SPME == 0
    // * Either not executing at EL0 using AArch32, or one of the following is true:
    //     - EL3 is using AArch32 and SDER.SUNIDEN == 0
    //     - EL3 is using AArch64, EL1 is using AArch32, and SDER32_EL3.SUNIDEN == 0
    // * PMNx is not reserved for use by the external interface
    if (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; (ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> || PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp;
          counter_range != <a href="shared_pseudocode.html#enum_PMUCounterRange_R3" title="">PMUCounterRange_R3</a>) then
        if !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            prohibited = (MDCR_EL3().SPME == '0' &amp;&amp;
                          (!IsFeatureImplemented(FEAT_PMUv3p7) || MDCR_EL3().MPMX == '0'));
        else
            prohibited = SDCR().SPME == '0';
        end;

        if prohibited &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
            if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
                prohibited = SDER().SUNIDEN == '0';
            elsif <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
                prohibited = SDER32_EL3().SUNIDEN == '0';
            end;
        end;
    end;

    // Event counting at EL3 is prohibited if all of:
    // * FEAT_PMUv3p7 is implemented
    // * EL3 is using AArch64
    // * One of the following is true:
    //   - MDCR_EL3.SPME == 0
    //   - PMNx is not reserved for EL2
    // * MDCR_EL3.MPMX == 1
    // * PMNx is not reserved for use by the external interface
    if (!prohibited &amp;&amp; IsFeatureImplemented(FEAT_PMUv3p7) &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp;
          <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() &amp;&amp; counter_range != <a href="shared_pseudocode.html#enum_PMUCounterRange_R3" title="">PMUCounterRange_R3</a>) then
        prohibited = (MDCR_EL3().MPMX == '1' &amp;&amp;
                      (MDCR_EL3().SPME == '0' || counter_range == <a href="shared_pseudocode.html#enum_PMUCounterRange_R1" title="">PMUCounterRange_R1</a>));
    end;

    // Event counting at EL2 is prohibited if all of:
    // * FEAT_PMUv3p1 is implemented
    // * PMNx is not reserved for EL2 or the external interface
    // * EL2 is using AArch64 and MDCR_EL2.HPMD == 1, or EL2 is using AArch32 and HDCR.HPMD == 1
    if (!prohibited &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> &amp;&amp; IsFeatureImplemented(FEAT_PMUv3p1) &amp;&amp;
          counter_range == <a href="shared_pseudocode.html#enum_PMUCounterRange_R1" title="">PMUCounterRange_R1</a>) then
        let hpmd : bit = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then MDCR_EL2().HPMD else HDCR().HPMD;
        prohibited = hpmd == '1';
    end;

    // The IMPLEMENTATION DEFINED authentication interface might override software
    if prohibited &amp;&amp; !IsFeatureImplemented(FEAT_Debugv8p2) then
        prohibited = !<a href="shared_pseudocode.html#func_ExternalSecureNoninvasiveDebugEnabled_0" title="">ExternalSecureNoninvasiveDebugEnabled</a>();
    end;

    // If FEAT_PMUv3p7 is implemented, event counting can be frozen
    if IsFeatureImplemented(FEAT_PMUv3p7) then
        var fz : bit;
        case counter_range of
            when <a href="shared_pseudocode.html#enum_PMUCounterRange_R1" title="">PMUCounterRange_R1</a> =&gt;
                fz = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then PMCR_EL0().FZO else PMCR().FZO;
            when <a href="shared_pseudocode.html#enum_PMUCounterRange_R2" title="">PMUCounterRange_R2</a> =&gt;
                fz = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then MDCR_EL2().HPMFZO else HDCR().HPMFZO;
            when <a href="shared_pseudocode.html#enum_PMUCounterRange_R3" title="">PMUCounterRange_R3</a> =&gt;
                fz = '0';
            otherwise =&gt;
                unreachable;
        end;
        frozen = (fz == '1') &amp;&amp; <a href="shared_pseudocode.html#func_ShouldPMUFreeze_1" title="">ShouldPMUFreeze</a>(counter_range);
        frozen = frozen || <a href="shared_pseudocode.html#func_SPEFreezeOnEvent_1" title="">SPEFreezeOnEvent</a>(idx);
    else
        frozen = FALSE;
    end;

    // PMCR_EL0.DP or PMCR.DP disables the cycle counter when event counting is prohibited
    // or frozen
    if (prohibited || frozen) &amp;&amp; idx == <a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a> then
        let dp = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then PMCR_EL0().DP else PMCR().DP;
        enabled = enabled &amp;&amp; dp == '0';
        // Otherwise whether event counting is prohibited or frozen does not affect the cycle
        // counter
        prohibited = FALSE;
        frozen = FALSE;
    end;

    // If FEAT_PMUv3p5 is implemented, cycle counting can be prohibited.
    // This is not overridden by PMCR_EL0.DP.
    if IsFeatureImplemented(FEAT_PMUv3p5) &amp;&amp; idx == <a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a> then
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; (ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> || PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            let sccd = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then MDCR_EL3().SCCD else SDCR().SCCD;
            if sccd == '1' then
                prohibited = TRUE;
            end;
        end;

        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
            let hccd = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then MDCR_EL2().HCCD else HDCR().HCCD;
            if hccd == '1' then
                prohibited = TRUE;
            end;
        end;
    end;

    // If FEAT_PMUv3p7 is implemented, cycle counting an be prohibited at EL3.
    // This is not overriden by PMCR_EL0.DP.
    if IsFeatureImplemented(FEAT_PMUv3p7) &amp;&amp; idx == <a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a> then
        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() &amp;&amp; MDCR_EL3().MCCD == '1' then
            prohibited = TRUE;
        end;
    end;

    // Event counting can be filtered by the {P, U, NSK, NSU, NSH, M, SH, RLK, RLU, RLH} bits
    var filter : bits(32);
    case idx of
        when <a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a> =&gt;
            filter = PMICFILTR_EL0()[31:0];
        when <a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a> =&gt;
            filter = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then PMCCFILTR_EL0()[31:0] else PMCCFILTR();
        otherwise =&gt;
            filter = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then PMEVTYPER_EL0(idx)[31:0] else PMEVTYPER(idx);
    end;

    let p : bit   = filter[31];
    let u : bit   = filter[30];
    let nsk : bit = if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then filter[29] else '0';
    let nsu : bit = if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then filter[28] else '0';
    let nsh : bit = if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then filter[27] else '0';
    let m : bit   = if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then filter[26] else '0';
    let sh : bit  = if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; IsFeatureImplemented(FEAT_SEL2) then filter[24] else '0';
    let rlk : bit = if IsFeatureImplemented(FEAT_RME) then filter[22] else '0';
    let rlu : bit = if IsFeatureImplemented(FEAT_RME) then filter[21] else '0';
    let rlh : bit = if IsFeatureImplemented(FEAT_RME) then filter[20] else '0';

    ss = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            case ss of
                when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt; filtered = u != nsu;
                when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;    filtered = u == '1';
                when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;     filtered = u != rlu;
            end;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            case ss of
                when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt; filtered = p != nsk;
                when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;    filtered = p == '1';
                when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;     filtered = p != rlk;
            end;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            case ss of
                when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt; filtered = nsh == '0';
                when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;    filtered = nsh == sh;
                when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;     filtered = nsh == rlh;
            end;
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
                filtered = m != p;
            else
                filtered = p == '1';
            end;
    end;

    if IsFeatureImplemented(FEAT_PMUv3_SME) then
        let is_streaming_mode : boolean = PSTATE.SM == '1';
        var vs : bits(2);
        case idx of
            when <a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a> =&gt;
                vs = PMICFILTR_EL0().VS;
            when <a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a> =&gt;
                vs = PMCCFILTR_EL0().VS;
            otherwise =&gt;
                vs = PMEVTYPER_EL0(idx).VS;
        end;

        var streaming_mode_filtered : boolean;
        if vs == '11' then
            streaming_mode_filtered = <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_RES_PMU_VS" title="">Unpredictable_RES_PMU_VS</a>);
        else
            streaming_mode_filtered =  ((is_streaming_mode &amp;&amp; vs[0] == '1') ||
                                        (!is_streaming_mode &amp;&amp; vs[1] == '1'));
        end;

        filtered = filtered || streaming_mode_filtered;
    end;

    return !debug &amp;&amp; enabled &amp;&amp; !prohibited &amp;&amp; !filtered &amp;&amp; !frozen;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.EffectiveEPMN"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/EffectiveEPMN</h3>
      <p class="pseudocode">// EffectiveEPMN()
// ===============
// Returns the Effective value of PMCCR.EPMN.

func <a id="func_EffectiveEPMN_0"/>EffectiveEPMN() =&gt; bits(5)
begin
    let counters : integer = NUM_PMU_COUNTERS;
    var epmn_bits : bits(5);

    if IsFeatureImplemented(FEAT_PMUv3_EXTPMN) then
        epmn_bits = PMCCR().EPMN;
        if UInt(epmn_bits) &gt; counters then
            (-, epmn_bits) = ConstrainUnpredictableBits{5}(<a href="shared_pseudocode.html#enum_Unpredictable_RES_EPMN" title="">Unpredictable_RES_EPMN</a>);
        end;
    else
        epmn_bits = counters[4:0];
    end;

    return epmn_bits;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.EffectiveHPMN"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/EffectiveHPMN</h3>
      <p class="pseudocode">// EffectiveHPMN()
// ===============
// Returns the Effective value of MDCR_EL2.HPMN or HDCR.HPMN.

func <a id="func_EffectiveHPMN_0"/>EffectiveHPMN() =&gt; bits(5)
begin
    let counters : integer = UInt(<a href="shared_pseudocode.html#func_EffectiveEPMN_0" title="">EffectiveEPMN</a>());
    var hpmn_bits : bits(5);

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then     // Software can reserve some event counters for EL2
        hpmn_bits = if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then MDCR_EL2().HPMN else HDCR().HPMN;

        // When FEAT_PMUv3_EXTPMN is implemented, out of range values are capped.
        if UInt(hpmn_bits) &gt; counters &amp;&amp; IsFeatureImplemented(FEAT_PMUv3_EXTPMN) then
            hpmn_bits = counters[4:0];
        end;

        if (UInt(hpmn_bits) &gt; counters ||
              (!IsFeatureImplemented(FEAT_HPMN0) &amp;&amp; IsZero(hpmn_bits))) then
            (-, hpmn_bits) = ConstrainUnpredictableBits{5}(<a href="shared_pseudocode.html#enum_Unpredictable_RES_HPMN" title="">Unpredictable_RES_HPMN</a>);
        end;
    else
        hpmn_bits = counters[4:0];
    end;

    return hpmn_bits;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.GetNumEventCountersAccessible"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/GetNumEventCountersAccessible</h3>
      <p class="pseudocode">// GetNumEventCountersAccessible()
// ===============================
// Return the number of event counters that can be accessed at the current Exception level.

func <a id="func_GetNumEventCountersAccessible_0"/>GetNumEventCountersAccessible() =&gt; integer{0..NUM_PMU_COUNTERS}
begin
    var n : integer;

    // Software can reserve some counters for EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>} &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        n = UInt(<a href="shared_pseudocode.html#func_EffectiveHPMN_0" title="">EffectiveHPMN</a>());
    else
        n = UInt(<a href="shared_pseudocode.html#func_EffectiveEPMN_0" title="">EffectiveEPMN</a>());
    end;

    return n as integer{0..NUM_PMU_COUNTERS};
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.GetNumEventCountersSelfHosted"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/GetNumEventCountersSelfHosted</h3>
      <p class="pseudocode">// GetNumEventCountersSelfHosted()
// ===============================
// Return the number of event counters that can be accessed by the Self-hosted software.

func <a id="func_GetNumEventCountersSelfHosted_0"/>GetNumEventCountersSelfHosted() =&gt; integer
begin
    if IsFeatureImplemented(FEAT_PMUv3_EXTPMN) then
        return UInt(<a href="shared_pseudocode.html#func_EffectiveEPMN_0" title="">EffectiveEPMN</a>());
    else
        return NUM_PMU_COUNTERS;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.GetPMUAccessMask"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/GetPMUAccessMask</h3>
      <p class="pseudocode">// GetPMUAccessMask()
// ==================
// Return a mask of the PMU counters accessible at the current Exception level

func <a id="func_GetPMUAccessMask_0"/>GetPMUAccessMask() =&gt; bits(64)
begin
    var mask : bits(64) = Zeros{};

    // PMICNTR_EL0 is only accessible at EL0 using AArch64 when PMUSERENR_EL0.UEN is 1.
    if IsFeatureImplemented(FEAT_PMUv3_ICNTR) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        assert IsFeatureImplemented(FEAT_PMUv3p9);
        if PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> || PMUSERENR_EL0().UEN == '1' then
            mask[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] = '1';
        end;
    end;

    // PMCCNTR_EL0 is always implemented and accessible
    mask[<a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a>] = '1';

    // PMEVCNTR_EL0(n)
    let counters : integer{} = <a href="shared_pseudocode.html#func_GetNumEventCountersAccessible_0" title="">GetNumEventCountersAccessible</a>();
    if counters &gt; 0 then
        mask[counters-1:0] = Ones{counters};
    end;

    // Check EL0 ignore access conditions
    if (IsFeatureImplemented(FEAT_PMUv3p9) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) &amp;&amp;
          PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; PMUSERENR_EL0().UEN == '1') then
        mask = mask AND PMUACR_EL1();  // User access control
    end;

    return mask;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.GetPMUCounterRange"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/GetPMUCounterRange</h3>
      <p class="pseudocode">// GetPMUCounterRange()
// ====================
// Returns the range that a counter is currently in.

func <a id="func_GetPMUCounterRange_1"/>GetPMUCounterRange(n : integer) =&gt; <a href="shared_pseudocode.html#type_PMUCounterRange" title="">PMUCounterRange</a>
begin

    let counters : integer = NUM_PMU_COUNTERS;
    let epmn : integer = UInt(<a href="shared_pseudocode.html#func_EffectiveEPMN_0" title="">EffectiveEPMN</a>());
    let hpmn : integer = UInt(<a href="shared_pseudocode.html#func_EffectiveHPMN_0" title="">EffectiveHPMN</a>());

    if n &lt; hpmn then
        return <a href="shared_pseudocode.html#enum_PMUCounterRange_R1" title="">PMUCounterRange_R1</a>;
    elsif n &lt; epmn then
        return <a href="shared_pseudocode.html#enum_PMUCounterRange_R2" title="">PMUCounterRange_R2</a>;
    elsif n &lt; counters then
        assert IsFeatureImplemented(FEAT_PMUv3_EXTPMN);
        return <a href="shared_pseudocode.html#enum_PMUCounterRange_R3" title="">PMUCounterRange_R3</a>;
    elsif n == <a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a> then
        return <a href="shared_pseudocode.html#enum_PMUCounterRange_R1" title="">PMUCounterRange_R1</a>;
    elsif n == <a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a> then
        assert IsFeatureImplemented(FEAT_PMUv3_ICNTR);
        return <a href="shared_pseudocode.html#enum_PMUCounterRange_R1" title="">PMUCounterRange_R1</a>;
    else
        unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.GetPMUReadMask"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/GetPMUReadMask</h3>
      <p class="pseudocode">// GetPMUReadMask()
// ================
// Return a mask of the PMU counters that can be read at the current
// Exception level.
// This mask masks reads from PMCNTENSET_EL0, PMCNTENCLR_EL0, PMINTENSET_EL1,
// PMINTENCLR_EL1, PMOVSSET_EL0, and PMOVSCLR_EL0.

func <a id="func_GetPMUReadMask_0"/>GetPMUReadMask() =&gt; bits(64)
begin
    var mask : bits(64) = <a href="shared_pseudocode.html#func_GetPMUAccessMask_0" title="">GetPMUAccessMask</a>();

    // Additional PMICNTR_EL0 accessibility checks. PMICNTR_EL0 controls read-as-zero
    // if a read of PMICFILTR_EL0 would be trapped to a higher Exception level.
    if IsFeatureImplemented(FEAT_PMUv3_ICNTR) &amp;&amp; mask[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] == '1' then
        // Check for trap to EL3.
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; MDCR_EL3().EnPM2 == '0' then
            mask[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] = '0';
        end;

        // Check for trap to EL2.
        if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; HCR_EL2().[E2H,TGE] != '11' then
            // If FEAT_PMUv3_ICNTR and EL2 are implemented, then so is FEAT_FGT2.
            assert IsFeatureImplemented(FEAT_FGT2);
            if ((<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().FGTEn2 == '0') ||
                  HDFGRTR2_EL2().nPMICFILTR_EL0 == '0') then
                mask[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] = '0';
            end;
        end;
    end;

    // Traps on other counters do not affect those counters' controls in the same way.

    return mask;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.GetPMUWriteMask"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/GetPMUWriteMask</h3>
      <p class="pseudocode">// GetPMUWriteMask()
// =================
// Return a mask of the PMU counters writable at the current Exception level.
// This mask masks writes to PMCNTENSET_EL0, PMCNTENCLR_EL0, PMINTENSET_EL1,
// PMINTENCLR_EL1, PMOVSSET_EL0, PMOVSCLR_EL0, and PMZR_EL0.
// 'write_counter' is TRUE for a write to PMZR_EL0, when the counter is being
// updated, and FALSE for other cases when the controls are being updated.

func <a id="func_GetPMUWriteMask_1"/>GetPMUWriteMask(write_counter : boolean) =&gt; bits(64)
begin
    var mask : bits(64) = <a href="shared_pseudocode.html#func_GetPMUAccessMask_0" title="">GetPMUAccessMask</a>();

    // Check EL0 ignore write conditions
    if (IsFeatureImplemented(FEAT_PMUv3p9) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) &amp;&amp;
          PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; PMUSERENR_EL0().UEN == '1') then
        if (IsFeatureImplemented(FEAT_PMUv3_ICNTR) &amp;&amp;
              PMUSERENR_EL0().IR == '1') then          // PMICNTR_EL0 read-only
            mask[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] = '0';
        end;
        if PMUSERENR_EL0().CR == '1' then              // PMCCNTR_EL0 read-only
            mask[<a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a>] = '0';
        end;
        if PMUSERENR_EL0().ER == '1' then              // PMEVCNTR[n]_EL0 read-only
            mask[30:0] = Zeros{31};
        end;
    end;

    // Additional PMICNTR_EL0 accessibility checks. PMICNTR_EL0 controls ignore writes
    // if a write of PMICFILTR_EL0 would be trapped to a higher Exception level.
    // Indirect writes to PMICNTR_EL0 (through PMZR_EL0) are ignored if a write of
    // PMICNTR_EL0 would be trapped to a higher Exception level.
    if IsFeatureImplemented(FEAT_PMUv3_ICNTR) &amp;&amp; mask[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] == '1' then
        // Check for trap to EL3.
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; MDCR_EL3().EnPM2 == '0' then
            mask[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] = '0';
        end;

        // Check for trap to EL2.
        if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; HCR_EL2().[E2H,TGE] != '11' then
            // If FEAT_PMUv3_ICNTR and EL2 are implemented, then so is FEAT_FGT2.
            assert IsFeatureImplemented(FEAT_FGT2);
            let fgt_bit : bit = (if write_counter then HDFGWTR2_EL2().nPMICNTR_EL0
                                 else HDFGWTR2_EL2().nPMICFILTR_EL0);
            if (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().FGTEn2 == '0') || fgt_bit == '0' then
                mask[<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>] = '0';
            end;
        end;
    end;

    // Traps on other counters do not affect those counters' controls in the same way.

    return mask;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.HasElapsed64Cycles"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/HasElapsed64Cycles</h3>
      <p class="pseudocode">// HasElapsed64Cycles()
// ====================
// Returns TRUE if 64 cycles have elapsed between the last count, and FALSE otherwise.

impdef func <a id="func_HasElapsed64Cycles_0"/>HasElapsed64Cycles() =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.IncrementInstructionCounter"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/IncrementInstructionCounter</h3>
      <p class="pseudocode">// IncrementInstructionCounter()
// =============================
// Increment the instruction counter and possibly set overflow bits.

func IncrementInstructionCounter(increment : integer)
begin
    if <a href="shared_pseudocode.html#func_CountPMUEvents_1" title="">CountPMUEvents</a>(<a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a>) then
        let old_value : integer = UInt(PMICNTR_EL0());
        let new_value : integer = old_value + increment;
        PMICNTR_EL0()           = new_value[63:0];

        // The effective value of PMCR_EL0.LP is '1' for the instruction counter
        if old_value[64] != new_value[64] then
            PMOVSSET_EL0().F0 = '1';
        end;
        if (IsFeatureImplemented(FEAT_SEBEP) &amp;&amp; PMINTENSET_EL1().F0 == '1' &amp;&amp;
              PMOVSSET_EL0().F0 == '1' &amp;&amp; increment != 0) then
            <a href="shared_pseudocode.html#global_SyncCounterOverflowed" title="">SyncCounterOverflowed</a> = TRUE;
        end;
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.IsMostSecureAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/IsMostSecureAccess</h3>
      <p class="pseudocode">// IsMostSecureAccess()
// ====================
// Returns TRUE if the security state of an access is the most secure state.

func <a id="func_IsMostSecureAccess_1"/>IsMostSecureAccess(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; boolean
begin
    if IsFeatureImplemented(FEAT_RME) then
        return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>;
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || <a href="shared_pseudocode.html#func_SecureOnlyImplementation_0" title="">SecureOnlyImplementation</a>() then
        return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
    else
        assert addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.IsRange3Counter"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/IsRange3Counter</h3>
      <p class="pseudocode">// IsRange3Counter()
// =================
// Returns TRUE if the counter is in the third range.

func <a id="func_IsRange3Counter_1"/>IsRange3Counter(n : integer) =&gt; boolean
begin
    return <a href="shared_pseudocode.html#enum_PMUCounterRange_R3" title="">PMUCounterRange_R3</a> == <a href="shared_pseudocode.html#func_GetPMUCounterRange_1" title="">GetPMUCounterRange</a>(n);
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUCaptureEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUCaptureEvent</h3>
      <p class="pseudocode">// PMUCaptureEvent()
// =================
// If permitted and enabled, generate a PMU snapshot Capture event.

func PMUCaptureEvent()
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; IsFeatureImplemented(FEAT_PMUv3_SS) &amp;&amp; <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>();
    let debug_state : boolean = <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>();

    if !<a href="shared_pseudocode.html#func_PMUCaptureEventAllowed_0" title="">PMUCaptureEventAllowed</a>() then
        // Indicate a Capture event completed, unsuccessfully
        PMSSCR_EL1().[NC,SS] = '10';
        return;
    end;
    let counters : integer = NUM_PMU_COUNTERS;
    for idx = 0 to counters - 1 do
        PMEVCNTSVR_EL1(idx) = PMEVCNTR_EL0(idx) as PMEVCNTSVR_EL1_Type;
    end;
    PMCCNTSVR_EL1() = PMCCNTR_EL0() as PMCCNTSVR_EL1_Type;

    if IsFeatureImplemented(FEAT_PMUv3_ICNTR) then
        PMICNTSVR_EL1() = PMICNTR_EL0() as PMICNTSVR_EL1_Type;
    end;

    if IsFeatureImplemented(FEAT_PCSRv8p9) &amp;&amp; PMPCSCTL().SS == '1' then
        if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.valid &amp;&amp; !debug_state then
            SetPCSRActive();
            SetPCSample();
        else
            PMPCSR()[31:0] = Ones{32};
        end;
    end;

    if (IsFeatureImplemented(FEAT_BRBE) &amp;&amp; <a href="shared_pseudocode.html#func_BranchRecordAllowed_1" title="">BranchRecordAllowed</a>(PSTATE.EL) &amp;&amp;
          BRBCR_EL1().FZPSS == '1' &amp;&amp; (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) || BRBCR_EL2().FZPSS == '1')) then
        BRBEFreeze();
    end;

    // Indicate a successful Capture event
    PMSSCR_EL1().[NC,SS] = '00';
    if !debug_state || <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_PMUSNAPSHOTEVENT" title="">Unpredictable_PMUSNAPSHOTEVENT</a>) then
        PMUEvent(PMU_EVENT_PMU_SNAPSHOT);
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUCaptureEventAllowed"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUCaptureEventAllowed</h3>
      <p class="pseudocode">// PMUCaptureEventAllowed()
// ========================
// Returns TRUE if PMU Capture events are allowed, and FALSE otherwise.

func <a id="func_PMUCaptureEventAllowed_0"/>PMUCaptureEventAllowed() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_PMUv3_SS) || !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
        return FALSE;
    end;

    if !<a href="shared_pseudocode.html#func_PMUCaptureEventEnabled_0" title="">PMUCaptureEventEnabled</a>() || <a href="shared_pseudocode.html#func_OSLockStatus_0" title="">OSLockStatus</a>() then
        return FALSE;
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; MDCR_EL3().PMSSE != '01' then
        return MDCR_EL3().PMSSE == '11';
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; MDCR_EL2().PMSSE != '01' then
        return MDCR_EL2().PMSSE == '11';
    else
        var pmsse_el1 : bits(2) = PMECR_EL1().SSE;
        if pmsse_el1 == '01' then            // Reserved value
            var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;
            (c, pmsse_el1) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_RESPMSSE" title="">Unpredictable_RESPMSSE</a>);
            assert c IN {<a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};
            if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then pmsse_el1 = '00'; end;
            // Otherwise the value returned by ConstrainUnpredictableBits must be
            // a non-reserved value
        end;
        return pmsse_el1 == '11';
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUCaptureEventEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUCaptureEventEnabled</h3>
      <p class="pseudocode">// PMUCaptureEventEnabled()
// ========================
// Returns TRUE if PMU Capture events are enabled, and FALSE otherwise.

func <a id="func_PMUCaptureEventEnabled_0"/>PMUCaptureEventEnabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_PMUv3_SS) || !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
        return FALSE;
    end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; MDCR_EL3().PMSSE != '01' then
        return MDCR_EL3().PMSSE == '1x';
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        return FALSE;
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; MDCR_EL2().PMSSE != '01' then
        return MDCR_EL2().PMSSE == '1x';
    elsif <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        return FALSE;
    else
        var pmsse_el1 : bits(2) = PMECR_EL1().SSE;
        if pmsse_el1 == '01' then            // Reserved value
            var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;
            (c, pmsse_el1) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_RESPMSSE" title="">Unpredictable_RESPMSSE</a>);
            assert c IN {<a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};
            if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then pmsse_el1 = '00'; end;
        end;
            // Otherwise the value returned by ConstrainUnpredictableBits must be
            // a non-reserved value
        return pmsse_el1 == '1x';
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUCountValue"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUCountValue</h3>
      <p class="pseudocode">// PMUCountValue()
// ===============
// Implements the PMU threshold function, if implemented.
// Returns the value to increment event counter 'n' by.
// 'Vb' is the base value of the event that event counter 'n' is configured to count.
// 'Vm' is the value to increment event counter 'n-1' by if 'n' is odd, zero otherwise.

func <a id="func_PMUCountValue_3"/>PMUCountValue(n : integer, Vb : integer, Vm : integer) =&gt; integer
begin
    assert (n MOD 2) == 1 || Vm == 0;
    assert n &lt; NUM_PMU_COUNTERS;

    if !IsFeatureImplemented(FEAT_PMUv3_TH) || !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
        return Vb;
    end;

    let TH : integer = UInt(PMEVTYPER_EL0(n).TH);

    // Control register fields
    var tc : bits(3) = PMEVTYPER_EL0(n).TC;
    var te : bit = '0';
    if IsFeatureImplemented(FEAT_PMUv3_EDGE) then
        te = PMEVTYPER_EL0(n).TE;
    end;
    var tlc : bits(2) = '00';
    if IsFeatureImplemented(FEAT_PMUv3_TH2) &amp;&amp; (n MOD 2) == 1 then
        tlc = PMEVTYPER_EL0(n).TLC;
    end;

    // Check for reserved cases
    var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;
    (c, tc, te, tlc) = <a href="shared_pseudocode.html#func_ReservedPMUThreshold_4" title="">ReservedPMUThreshold</a>(n, tc, te, tlc);
    if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then
        return Vb;
    end;
    // Otherwise the values returned by ReservedPMUThreshold must be defined values

    // Check if disabled. Note that this function will return the value of Vb when
    // the control register fields are all zero, even without this check.
    if tc == '000' &amp;&amp; TH == 0 &amp;&amp; te == '0' &amp;&amp; tlc == '00' then
        return Vb;
    end;

    // Threshold condition
    var Ct : boolean;
    case tc[2:1] of
        when '00' =&gt; Ct = (Vb != TH);        // Disabled or not-equal
        when '01' =&gt; Ct = (Vb == TH);        // Equals
        when '10' =&gt; Ct = (Vb &gt;= TH);        // Greater-than-or-equal
        when '11' =&gt; Ct = (Vb &lt;  TH);        // Less-than
    end;

    var Vn : integer;
    if te == '1' then
        // Edge condition
        let Cp : boolean = <a href="shared_pseudocode.html#global_PMULastThresholdValue" title="">PMULastThresholdValue</a>[[n]];
        var Ce : boolean;
        var Ve : integer;
        case tc[1:0] of
            when '10' =&gt;  Ce = (Cp != Ct);   // Both edges
            when 'x1' =&gt;  Ce = (!Cp &amp;&amp; Ct);  // Single edge
            otherwise =&gt;  unreachable;     // Covered by ReservedPMUThreshold
        end;
        case tlc of
            when '00' =&gt;  Ve = (if Ce then 1 else 0);
            when '10' =&gt;  Ve = (if Ce then Vm else 0);
            otherwise =&gt;  unreachable;     // Covered by ReservedPMUThreshold
        end;
        Vn = Ve;
    else
        // Threshold condition
        var Vt : integer;
        case tc[0]::tlc of
            when '0 00' =&gt;  Vt = (if Ct then Vb else 0);
            when '0 01' =&gt;  Vt = (if Ct then Vb else Vm);
            when '0 10' =&gt;  Vt = (if Ct then Vm else 0);
            when '1 00' =&gt;  Vt = (if Ct then 1 else 0);
            when '1 01' =&gt;  Vt = (if Ct then 1 else Vm);
            otherwise =&gt;    unreachable;   // Covered by ReservedPMUThreshold
        end;
        Vn = Vt;
    end;

    <a href="shared_pseudocode.html#global_PMULastThresholdValue" title="">PMULastThresholdValue</a>[[n]] = Ct;

    return Vn;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUCounterRange"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUCounterRange</h3>
      <p class="pseudocode">// PMUCounterRange
// ===============
// Enumerates the ranges to which an event counter belongs to.

type <a id="type_PMUCounterRange"/>PMUCounterRange of enumeration {
    <a id="enum_PMUCounterRange_R1"/>PMUCounterRange_R1,
    <a id="enum_PMUCounterRange_R2"/>PMUCounterRange_R2,
    <a id="enum_PMUCounterRange_R3"/>PMUCounterRange_R3
    };</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUEvent</h3>
      <p class="pseudocode">// PMUEvent()
// ==========
// Generate a PMU event. By default, increment by 1.

func PMUEvent(pmuevent : bits(16))
begin
    PMUEvent(pmuevent, 1);
end;

// PMUEvent()
// ==========
// Accumulate a PMU Event.

func PMUEvent(pmuevent : bits(16), increment : integer)
begin
    let counters : integer = NUM_PMU_COUNTERS;
    if counters != 0 then
        for idx = 0 to counters - 1 do
            PMUEvent(pmuevent, increment, idx);
        end;
    end;

    if (<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() &amp;&amp; IsFeatureImplemented(FEAT_PMUv3_ICNTR) &amp;&amp;
          pmuevent == PMU_EVENT_INST_RETIRED) then
        IncrementInstructionCounter(increment);
    end;

end;

// PMUEvent()
// ==========
// Accumulate a PMU Event for a specific event counter.

func PMUEvent(pmuevent : bits(16), increment : integer, idx : integer)
begin
    if !IsFeatureImplemented(FEAT_PMUv3) then
        return;
    end;
    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        if PMEVTYPER(idx).evtCount == pmuevent then
            <a href="shared_pseudocode.html#global_PMUEventAccumulator" title="">PMUEventAccumulator</a>[[idx]] = <a href="shared_pseudocode.html#global_PMUEventAccumulator" title="">PMUEventAccumulator</a>[[idx]] + increment;
        end;
    else
        if PMEVTYPER_EL0(idx).evtCount == pmuevent then
            <a href="shared_pseudocode.html#global_PMUEventAccumulator" title="">PMUEventAccumulator</a>[[idx]] = <a href="shared_pseudocode.html#global_PMUEventAccumulator" title="">PMUEventAccumulator</a>[[idx]] + increment;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUOverflowCondition"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUOverflowCondition</h3>
      <p class="pseudocode">// PMUOverflowCondition()
// ======================
// Enumerates the reasons for which the PMU overflow condition is evaluated.

type <a id="type_PMUOverflowCondition"/>PMUOverflowCondition of enumeration {
    <a id="enum_PMUOverflowCondition_PMUException"/>PMUOverflowCondition_PMUException,
    <a id="enum_PMUOverflowCondition_BRBEFreeze"/>PMUOverflowCondition_BRBEFreeze,
    <a id="enum_PMUOverflowCondition_Freeze"/>PMUOverflowCondition_Freeze,
    <a id="enum_PMUOverflowCondition_IRQ"/>PMUOverflowCondition_IRQ,
    <a id="enum_PMUOverflowCondition_EDBGRQ"/>PMUOverflowCondition_EDBGRQ
};</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUSwIncrement"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUSwIncrement</h3>
      <p class="pseudocode">// PMUSwIncrement()
// ================
// Generate PMU Events on a write to PMSWINC

func PMUSwIncrement(sw_incr_in : bits(64))
begin

    var sw_incr : bits(64)   = sw_incr_in;
    var mask : bits(31)      = Zeros{};
    let counters : integer{} = <a href="shared_pseudocode.html#func_GetNumEventCountersAccessible_0" title="">GetNumEventCountersAccessible</a>();
    if counters &gt; 0 then
        mask[counters-1:0] = Ones{counters};
    end;

    if (IsFeatureImplemented(FEAT_PMUv3p9) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) &amp;&amp;
          PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; PMUSERENR_EL0().[UEN,SW] == '10') then
        mask = mask AND PMUACR_EL1()[30:0];
    end;

    sw_incr = sw_incr AND ZeroExtend{64}(mask);
    for idx = 0 to 30 do
        if sw_incr[idx] == '1' then
            PMUEvent(PMU_EVENT_SW_INCR, 1, idx);
        end;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.ReservedPMUThreshold"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/ReservedPMUThreshold</h3>
      <p class="pseudocode">// ReservedPMUThreshold()
// ======================
// Checks if the given PMEVTYPER_EL1().[TH,TE,TLC] values are reserved and will
// generate Constrained Unpredictable behavior, otherwise return Constraint_NONE.

func <a id="func_ReservedPMUThreshold_4"/>ReservedPMUThreshold(n : integer, tc_in : bits(3),
                          te_in : bit, tlc_in : bits(2)) =&gt; (<a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>, bits(3), bit, bits(2))
begin
    var tc : bits(3) = tc_in;
    var te : bit = te_in;
    var tlc : bits(2) = tlc_in;

    var reserved : boolean = FALSE;

    if IsFeatureImplemented(FEAT_PMUv3_EDGE) then
        if te == '1' &amp;&amp; tc[1:0] == '00' then      // Edge condition
            reserved = TRUE;
        end;
    else
        te = '0';                                 // Control is RES0
    end;

    if IsFeatureImplemented(FEAT_PMUv3_TH2) &amp;&amp; (n MOD 2) == 1 then
        if tlc == '11' then                       // Reserved value
            reserved = TRUE;
        end;
        if te == '1' then                         // Edge condition
            if tlc == '01' then
                reserved = TRUE;
            end;
        else                                      // Threshold condition
            if tc[0] == '1' &amp;&amp; tlc == '10' then
                reserved = TRUE;
            end;
        end;
    else
        tlc = '00';                               // Controls are RES0
    end;

    var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>;
    if reserved then
        var unpred_reserved_bits : bits(6);
        (c, unpred_reserved_bits) = ConstrainUnpredictableBits{6}(<a href="shared_pseudocode.html#enum_Unpredictable_RESTC" title="">Unpredictable_RESTC</a>);
        tc  = unpred_reserved_bits[5:3];
        te  = unpred_reserved_bits[2];
        tlc = unpred_reserved_bits[1:0];
    end;

    return (c, tc, te, tlc);
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.SMEPMUEventPredicate"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/SMEPMUEventPredicate</h3>
      <p class="pseudocode">// SMEPMUEventPredicate()
// ======================
// Call the relevant PMU predication events based on the SME instruction properties.

func SMEPMUEventPredicate{N}(mask1 : bits(N), mask2 : bits(N), esize : integer)
begin
    PMUEvent(PMU_EVENT_SVE_PRED_SPEC);
    PMUEvent(PMU_EVENT_SME_PRED2_SPEC);
    if <a href="shared_pseudocode.html#func_AllElementsActive_3" title="">AllElementsActive</a>{N}(mask1, esize) &amp;&amp; <a href="shared_pseudocode.html#func_AllElementsActive_3" title="">AllElementsActive</a>{N}(mask2, esize) then
        PMUEvent(PMU_EVENT_SME_PRED2_FULL_SPEC);
    else
        PMUEvent(PMU_EVENT_SME_PRED2_NOT_FULL_SPEC);
        if !<a href="shared_pseudocode.html#func_AnyActiveElement_3" title="">AnyActiveElement</a>{N}(mask1, esize) &amp;&amp; !<a href="shared_pseudocode.html#func_AnyActiveElement_3" title="">AnyActiveElement</a>{N}(mask2, esize) then
            PMUEvent(PMU_EVENT_SME_PRED2_EMPTY_SPEC);
        else
            PMUEvent(PMU_EVENT_SME_PRED2_PARTIAL_SPEC);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.SVEPMUEventPredicate"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/SVEPMUEventPredicate</h3>
      <p class="pseudocode">// SVEPMUEventPredicate()
// ======================
// Call the relevant PMU predication events based on the SVE instruction properties.

func SVEPMUEventPredicate{N}(mask : bits(N), esize : integer)
begin
    PMUEvent(PMU_EVENT_SVE_PRED_SPEC);
    if <a href="shared_pseudocode.html#func_AllElementsActive_3" title="">AllElementsActive</a>{N}(mask, esize) then
        PMUEvent(PMU_EVENT_SVE_PRED_FULL_SPEC);
    else
        PMUEvent(PMU_EVENT_SVE_PRED_NOT_FULL_SPEC);
        if !<a href="shared_pseudocode.html#func_AnyActiveElement_3" title="">AnyActiveElement</a>{N}(mask, esize) then
            PMUEvent(PMU_EVENT_SVE_PRED_EMPTY_SPEC);
        else
            PMUEvent(PMU_EVENT_SVE_PRED_PARTIAL_SPEC);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.ShouldPMUFreeze"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/ShouldPMUFreeze</h3>
      <p class="pseudocode">// ShouldPMUFreeze()
// =================

func <a id="func_ShouldPMUFreeze_1"/>ShouldPMUFreeze(r : <a href="shared_pseudocode.html#type_PMUCounterRange" title="">PMUCounterRange</a>) =&gt; boolean
begin
    let include_r1 : boolean = (r == <a href="shared_pseudocode.html#enum_PMUCounterRange_R1" title="">PMUCounterRange_R1</a>);
    let include_r2 : boolean = (r == <a href="shared_pseudocode.html#enum_PMUCounterRange_R2" title="">PMUCounterRange_R2</a>);
    let include_r3 : boolean = FALSE;

    if r == <a href="shared_pseudocode.html#enum_PMUCounterRange_R3" title="">PMUCounterRange_R3</a> then
        return FALSE;
    end;

    let overflow : boolean = <a href="shared_pseudocode.html#func_CheckPMUOverflowCondition_4" title="">CheckPMUOverflowCondition</a>(<a href="shared_pseudocode.html#enum_PMUOverflowCondition_Freeze" title="">PMUOverflowCondition_Freeze</a>,
                                                       include_r1, include_r2, include_r3);
    return overflow;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.ZeroCycleCounter"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/ZeroCycleCounter</h3>
      <p class="pseudocode">// ZeroCycleCounter()
// ==================
// Called on a write to PMCR_EL0 or PMCR that writes '1' to PMCR_EL0.C or PMCR.C.

func ZeroCycleCounter()
begin
    var mask : bits(64) = Zeros{};
    mask[<a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a>] = '1';
    ZeroPMUCounters(mask);
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.ZeroPMUCounters"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/ZeroPMUCounters</h3>
      <p class="pseudocode">// ZeroPMUCounters()
// =================
// Zero set of counters specified by the mask in 'val'.
// For a System register write to PMZR_EL0, 'val' is the value passed in X&lt;t&gt;.

func ZeroPMUCounters(val : bits(64))
begin
    let masked_val : bits(64) = val AND <a href="shared_pseudocode.html#func_GetPMUWriteMask_1" title="">GetPMUWriteMask</a>(TRUE);

    for idx = 0 to 63 do
        if masked_val[idx] == '1' &amp;&amp; !<a href="shared_pseudocode.html#func_IsRange3Counter_1" title="">IsRange3Counter</a>(idx) then
            case idx of
                when <a href="shared_pseudocode.html#global_INSTRUCTION_COUNTER_ID" title="">INSTRUCTION_COUNTER_ID</a> =&gt;
                    PMICNTR_EL0() = Zeros{64};
                when <a href="shared_pseudocode.html#global_CYCLE_COUNTER_ID" title="">CYCLE_COUNTER_ID</a> =&gt;
                    if !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
                        PMCCNTR() = Zeros{64};
                    else
                        PMCCNTR_EL0() = Zeros{64};
                    end;
                otherwise =&gt;
                    if !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
                        PMEVCNTR(idx) = Zeros{32};
                    elsif IsFeatureImplemented(FEAT_PMUv3p5) then
                        PMEVCNTR_EL0(idx) = Zeros{64};
                    else
                        PMEVCNTR_EL0(idx)[31:0] = Zeros{32};
                    end;
            end;
        end;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.CreatePCSample"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/CreatePCSample</h3>
      <p class="pseudocode">// CreatePCSample()
// ================

func CreatePCSample()
begin
    // In a simple sequential execution of the program, CreatePCSample is executed each time the PE
    // executes an instruction that can be sampled. An implementation is not constrained such that
    // reads of EDPCSRlo return the current values of PC, etc.
    if <a href="shared_pseudocode.html#func_PCSRSuspended_0" title="">PCSRSuspended</a>() then return; end;
    <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.valid = <a href="shared_pseudocode.html#func_ExternalNoninvasiveDebugAllowed_0" title="">ExternalNoninvasiveDebugAllowed</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>();
    <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.pc = <a href="shared_pseudocode.html#func_ThisInstrAddr_1" title="">ThisInstrAddr</a>{64}();
    <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.el = PSTATE.EL;
    <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.rw = if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then '0' else '1';
    <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.ss = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();
    <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.contextidr = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then CONTEXTIDR() else CONTEXTIDR_EL1()[31:0];
    <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.has_el2 = PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();

    if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.has_el2 then
        <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.vmid = <a href="shared_pseudocode.html#func_VMID_0" title="">VMID</a>();
        if ((IsFeatureImplemented(FEAT_VHE) || IsFeatureImplemented(FEAT_Debugv8p2)) &amp;&amp;
              !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>)) then
            <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.contextidr_el2 = CONTEXTIDR_EL2()[31:0];
        else
            <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.contextidr_el2 = ARBITRARY : bits(32);
        end;
        <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.el0h = PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>();
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.PCSRSuspended"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/PCSRSuspended</h3>
      <p class="pseudocode">// PCSRSuspended()
// ===============
// Returns TRUE if PC Sample-based Profiling is suspended, and FALSE otherwise.

func <a id="func_PCSRSuspended_0"/>PCSRSuspended() =&gt; boolean
begin
    if IsFeatureImplemented(FEAT_PMUv3_SS) &amp;&amp; PMPCSCTL().SS == '1' then
        return FALSE;
    end;
    if IsFeatureImplemented(FEAT_PCSRv8p9) &amp;&amp; PMPCSCTL().IMP == '1' then
        return PMPCSCTL().EN == '0';
    end;
    return ImpDefBool("PCSR is suspended");
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.PCSample"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/PCSample</h3>
      <p class="pseudocode">// PCSample
// ========

type <a id="type_PCSample"/>PCSample of record {
    valid : boolean,
    pc : bits(64),
    el : bits(2),
    rw : bit,
    ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>,
    has_el2 : boolean,
    contextidr : bits(32),
    contextidr_el2 : bits(32),
    el0h : boolean,
    vmid : bits(16)

};

var <a id="global_pc_sample"/>pc_sample : <a href="shared_pseudocode.html#type_PCSample" title="">PCSample</a>;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.Read_EDPCSRlo"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/Read_EDPCSRlo</h3>
      <p class="pseudocode">// Read_EDPCSRlo()
// ===============

func <a id="func_Read_EDPCSRlo_1"/>Read_EDPCSRlo(memory_mapped : boolean) =&gt; bits(32)
begin
    // The Software lock is OPTIONAL.
    let update : boolean = !memory_mapped || EDLSR().SLK == '0';// Software locked: no side-effects
    var sample : bits(32);
    if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.valid then
        sample = <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.pc[31:0];
        if update then
            if IsFeatureImplemented(FEAT_VHE) &amp;&amp; EDSCR().SC2 == '1' then
                EDPCSRhi.PC = (if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.rw == '0' then Zeros{24} else <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.pc[55:32]);
                EDPCSRhi.EL = <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.el;
                EDPCSRhi.NS = (if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then '0' else '1');
            else
                EDPCSRhi = (if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.rw == '0' then Zeros{32} else <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.pc[63:32]);
            end;
            EDCIDSR() = <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.contextidr;
            if ((IsFeatureImplemented(FEAT_VHE) || IsFeatureImplemented(FEAT_Debugv8p2)) &amp;&amp;
                  EDSCR().SC2 == '1') then
                EDVIDSR() = (if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.has_el2 then <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.contextidr_el2
                             else ARBITRARY : bits(32));
            else
                EDVIDSR().VMID = (if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.has_el2 &amp;&amp; <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.el IN {<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>,<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>}
                                  then <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.vmid else Zeros{16});
                EDVIDSR().NS = (if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then '0' else '1');
                EDVIDSR().E2 = (if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then '1' else '0');
                EDVIDSR().E3 = (if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then '1' else '0') AND <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.rw;
                // The conditions for setting HV are not specified if PCSRhi is zero.
                // An example implementation may be "pc_sample.rw".
                EDVIDSR().HV = (if !IsZero(EDPCSRhi) then '1'
                                else ImpDefBit("0 or 1"));
            end;
        end;
    else
        sample = Ones{32};
        if update then
            EDPCSRhi  = ARBITRARY : bits(32);
            EDCIDSR() = ARBITRARY : bits(32);
            EDVIDSR() = ARBITRARY : bits(32);
        end;
    end;

    return sample;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.Read_PMPCSR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/Read_PMPCSR</h3>
      <p class="pseudocode">// Read_PMPCSR()
// =============

func <a id="func_Read_PMPCSR_1"/>Read_PMPCSR(memory_mapped : boolean) =&gt; bits(64)
begin
    // The Software lock is OPTIONAL.
    var update : boolean = !memory_mapped || PMLSR().SLK == '0'; // Software locked: no side-effects

    if IsFeatureImplemented(FEAT_PCSRv8p9) &amp;&amp; update then
        if IsFeatureImplemented(FEAT_PMUv3_SS) &amp;&amp; PMPCSCTL().SS == '1' then
            update = FALSE;
        elsif PMPCSCTL().[IMP,EN] == '10' || (PMPCSCTL().IMP == '0' &amp;&amp; <a href="shared_pseudocode.html#func_PCSRSuspended_0" title="">PCSRSuspended</a>()) then
            <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.valid = FALSE;
            SetPCSRActive();
        end;
    end;

    if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.valid then
        if update then SetPCSample(); end;
        return PMPCSR();
    else
        if update then SetPCSRUnknown(); end;
        return (ARBITRARY : bits(32) :: Ones{32});
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.SetPCSRActive"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/SetPCSRActive</h3>
      <p class="pseudocode">// SetPCSRActive()
// ===============
// Sets PC Sample-based Profiling to active state.

func SetPCSRActive()
begin
    if PMPCSCTL().IMP == '1' then
        PMPCSCTL().EN = '1';
    // If PMPCSCTL.IMP reads as `0b0`, then PMPCSCTL.EN is RES0, and it is
    // IMPLEMENTATION DEFINED whether PSCR is suspended or active at reset.
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.SetPCSRUnknown"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/SetPCSRUnknown</h3>
      <p class="pseudocode">// SetPCSRUnknown()
// ================
// Sets the PC sample registers to UNKNOWN values because PC sampling
// is prohibited.

func SetPCSRUnknown()
begin
    PMPCSR()[31:0]  = Ones{32};
    PMPCSR()[55:32] = ARBITRARY : bits(24);
    PMPCSR().EL     = ARBITRARY : bits(2);
    PMPCSR().NS     = ARBITRARY : bit;

    if IsFeatureImplemented(FEAT_PMUv3_EXT64) then
        PMCCIDSR()      = ARBITRARY : bits(64);
        PMVCIDSR().VMID = ARBITRARY : bits(16);
    end;
    if IsFeatureImplemented(FEAT_PMUv3_EXT32) then
        PMCID1SR()      = ARBITRARY : bits(32);
        PMCID2SR()      = ARBITRARY : bits(32);
        PMVIDSR().VMID  = ARBITRARY : bits(16);
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.SetPCSample"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/SetPCSample</h3>
      <p class="pseudocode">// SetPCSample()
// =============
// Sets the PC sample registers to the appropriate sample values.

func SetPCSample()
begin
    PMPCSR()[31:0] = <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.pc[31:0];
    PMPCSR()[55:32] = (if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.rw == '0' then Zeros{24} else <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.pc[55:32]);
    PMPCSR().EL = <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.el;
    if IsFeatureImplemented(FEAT_RME) then
        case <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.ss of
            when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;
                PMPCSR().NSE = '0'; PMPCSR().NS = '0';
            when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;
                PMPCSR().NSE = '0'; PMPCSR().NS = '1';
            when <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> =&gt;
                PMPCSR().NSE = '1'; PMPCSR().NS = '0';
            when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;
                PMPCSR().NSE = '1'; PMPCSR().NS = '1';
        end;
    else
        PMPCSR().NS = (if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then '0' else '1');
    end;
    let contextidr_el2 : bits(32) = (if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.has_el2 then
                                        <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.contextidr_el2 else ARBITRARY : bits(32));
    var vmid : bits(16) = ARBITRARY : bits(16);
    if <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.has_el2 &amp;&amp; <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.el IN {<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>,<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>} &amp;&amp; !<a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.el0h then
        vmid = <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.vmid;
    end;
    if IsFeatureImplemented(FEAT_PMUv3_EXT64) then
        PMCCIDSR() = contextidr_el2::<a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.contextidr;
        PMVCIDSR().VMID = vmid;
    end;
    if IsFeatureImplemented(FEAT_PMUv3_EXT32) then
        PMCID1SR() = <a href="shared_pseudocode.html#global_pc_sample" title="">pc_sample</a>.contextidr;
        PMCID2SR() = contextidr_el2;
        PMVIDSR().VMID = vmid;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.CheckSoftwareStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/CheckSoftwareStep</h3>
      <p class="pseudocode">// CheckSoftwareStep()
// ===================
// Take a Software Step exception if in the active-pending state

func CheckSoftwareStep()
begin

    // Other self-hosted debug functions will call AArch32_GenerateDebugExceptions() if called from
    // AArch32 state. However, because Software Step is only active when the debug target Exception
    // level is using AArch64, CheckSoftwareStep only calls AArch64_GenerateDebugExceptions().
    let step_enabled : boolean = (!<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_DebugTarget_0" title="">DebugTarget</a>()) &amp;&amp;
                                  <a href="shared_pseudocode.html#func_AArch64_GenerateDebugExceptions_0" title="">AArch64_GenerateDebugExceptions</a>() &amp;&amp;
                                  MDSCR_EL1().SS == '1');
    let active_pending : boolean = step_enabled &amp;&amp; PSTATE.SS == '0';   // active-pending
    if active_pending then
        AArch64_SoftwareStepException();
    end;
    <a href="shared_pseudocode.html#global_ShouldAdvanceSS" title="">ShouldAdvanceSS</a> = TRUE;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.DebugExceptionReturnSS"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/DebugExceptionReturnSS</h3>
      <p class="pseudocode">// DebugExceptionReturnSS()
// ========================
// Returns value to write to PSTATE.SS on an exception return or Debug state exit.

func <a id="func_DebugExceptionReturnSS_2"/>DebugExceptionReturnSS{N}(spsr : bits(N)) =&gt; bit
begin
    assert <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() || <a href="shared_pseudocode.html#func_Restarting_0" title="">Restarting</a>() ||  PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;

    var enabled_at_source : boolean;
    if <a href="shared_pseudocode.html#func_Restarting_0" title="">Restarting</a>() then
        enabled_at_source = FALSE;
    elsif <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        enabled_at_source = <a href="shared_pseudocode.html#func_AArch32_GenerateDebugExceptions_0" title="">AArch32_GenerateDebugExceptions</a>();
    else
        enabled_at_source = <a href="shared_pseudocode.html#func_AArch64_GenerateDebugExceptions_0" title="">AArch64_GenerateDebugExceptions</a>();
    end;
    var valid : boolean;
    var dest_el : bits(2);
    if <a href="shared_pseudocode.html#func_IllegalExceptionReturn_2" title="">IllegalExceptionReturn</a>{N}(spsr) then
        dest_el = PSTATE.EL;
    else
        (valid, dest_el) = <a href="shared_pseudocode.html#func_ELFromSPSR_2" title="">ELFromSPSR</a>{N}(spsr);  assert valid;
    end;

    let dest_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(dest_el);
    var enabled_at_dest : boolean;
    let dest_using_32 : boolean = (if dest_el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then spsr[4] == '1'
                                                     else <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(dest_el));
    if dest_using_32 then
        enabled_at_dest = <a href="shared_pseudocode.html#func_AArch32_GenerateDebugExceptionsFrom_2" title="">AArch32_GenerateDebugExceptionsFrom</a>(dest_el, dest_ss);
    else
        let mask : bit = spsr[9];
        enabled_at_dest = <a href="shared_pseudocode.html#func_AArch64_GenerateDebugExceptionsFrom_3" title="">AArch64_GenerateDebugExceptionsFrom</a>(dest_el, dest_ss, mask);
    end;

    let ELd : bits(2) = <a href="shared_pseudocode.html#func_DebugTargetFrom_1" title="">DebugTargetFrom</a>(dest_ss);
    var SS_bit : bit;
    if !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(ELd) &amp;&amp; MDSCR_EL1().SS == '1' &amp;&amp; !enabled_at_source &amp;&amp; enabled_at_dest then
        SS_bit = spsr[21];
    else
        SS_bit = '0';
    end;
    return SS_bit;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.SSAdvance"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/SSAdvance</h3>
      <p class="pseudocode">// SSAdvance()
// ===========
// Advance the Software Step state machine.

func SSAdvance()
begin

    // A simpler implementation of this function just clears PSTATE.SS to zero regardless of the
    // current Software Step state machine. However, this check is made to illustrate that the
    // PE only needs to consider advancing the state machine from the active-not-pending
    // state.
    if !<a href="shared_pseudocode.html#global_ShouldAdvanceSS" title="">ShouldAdvanceSS</a> then return; end;
    let target : bits(2) = <a href="shared_pseudocode.html#func_DebugTarget_0" title="">DebugTarget</a>();
    let step_enabled : boolean = !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(target) &amp;&amp; MDSCR_EL1().SS == '1';
    let active_not_pending : boolean = step_enabled &amp;&amp; PSTATE.SS == '1';
    if active_not_pending then PSTATE.SS = '0'; end;
    <a href="shared_pseudocode.html#global_ShouldAdvanceSS" title="">ShouldAdvanceSS</a> = FALSE;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.SoftwareStepOpEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/SoftwareStepOpEnabled</h3>
      <p class="pseudocode">// SoftwareStepOpEnabled()
// =======================
// Returns a boolean indicating if execution from MDSTEPOP_EL1 is enabled.

func <a id="func_SoftwareStepOpEnabled_0"/>SoftwareStepOpEnabled() =&gt; boolean
begin

    if !IsFeatureImplemented(FEAT_STEP2) || <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        return FALSE;
    end;

    let step_enabled = <a href="shared_pseudocode.html#func_AArch64_GenerateDebugExceptions_0" title="">AArch64_GenerateDebugExceptions</a>() &amp;&amp; MDSCR_EL1().SS == '1';
    let active_not_pending = step_enabled &amp;&amp; PSTATE.SS == '1';
    let stepop = (MDSCR_EL1().EnSTEPOP == '1' &amp;&amp;
                  (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || MDCR_EL3().EnSTEPOP == '1') &amp;&amp;
                  (!<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() || MDCR_EL2().EnSTEPOP == '1'));
    return active_not_pending &amp;&amp; stepop;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.SoftwareStep_DidNotStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/SoftwareStep_DidNotStep</h3>
      <p class="pseudocode">// SoftwareStep_DidNotStep()
// =========================
// Returns TRUE if the previously executed instruction was executed in the
// inactive state, that is, if it was not itself stepped.
// Might return TRUE or FALSE if the previously executed instruction was an ISB
// or ERET executed in the active-not-pending state, or if another exception
// was taken before the Software Step exception.  Returns FALSE otherwise,
// indicating that the previously executed instruction was executed in the
// active-not-pending state, that is, the instruction was stepped.

func <a id="func_SoftwareStep_DidNotStep_0"/>SoftwareStep_DidNotStep() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.SoftwareStep_SteppedEX"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/SoftwareStep_SteppedEX</h3>
      <p class="pseudocode">// SoftwareStep_SteppedEX()
// ========================
// Returns a value that describes the previously executed instruction. The
// result is valid only if SoftwareStep_DidNotStep() returns FALSE.
// Might return TRUE or FALSE if the instruction was an AArch32 LDREX or LDAEX
// that failed its condition code test.  Otherwise returns TRUE if the
// instruction was a Load-Exclusive class instruction, and FALSE if the
// instruction was not a Load-Exclusive class instruction.

func <a id="func_SoftwareStep_SteppedEX_0"/>SoftwareStep_SteppedEX() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.watchpoint.DataCacheWatchpointSize"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/watchpoint/DataCacheWatchpointSize</h3>
      <p class="pseudocode">// DataCacheWatchpointSize()
// =========================
// Return the IMPLEMENTATION DEFINED data cache watchpoint size

func <a id="func_DataCacheWatchpointSize_0"/>DataCacheWatchpointSize() =&gt; integer
begin
    let size : integer = ImpDefInt("Data Cache Invalidate Watchpoint Size");
    assert IsPow2(size) &amp;&amp; size &gt;= 2^(UInt(CTR_EL0().DminLine) + 2) &amp;&amp; size &lt;= 2048;
    return size;
end;</p>
    </div>
    <div class="ps"><a id="shared.debug.watchpoint.WatchpointInfo"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/watchpoint/WatchpointInfo</h3>
      <p class="pseudocode">// WatchpointInfo
// ==============
// Watchpoint related fields.

type <a id="type_WatchpointInfo"/>WatchpointInfo of record {
    wptype : <a href="shared_pseudocode.html#type_WatchpointType" title="">WatchpointType</a>,     // Type of watchpoint matched
    maybe_false_match : boolean, // Watchpoint matches rounded range
    watchpt_num : integer,       // Matching watchpoint number
    value_match : boolean,       // Watchpoint match
    vaddress : bits(64)          // Matching Virtual Address

};</p>
    </div>
    <div class="ps"><a id="shared.debug.watchpoint.WatchpointType"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/watchpoint/WatchpointType</h3>
      <p class="pseudocode">// WatchpointType
// ==============

type <a id="type_WatchpointType"/>WatchpointType of enumeration {
    <a id="enum_WatchpointType_Inactive"/>WatchpointType_Inactive,      // Watchpoint inactive or disabled
    <a id="enum_WatchpointType_AddrMatch"/>WatchpointType_AddrMatch,     // Address Match watchpoint
    <a id="enum_WatchpointType_AddrMismatch"/>WatchpointType_AddrMismatch   // Address Mismatch watchpoint
};</p>
    </div>
    <div class="ps"><a id="shared.exceptions.aborts.EffectiveHCRX_EL2_TMEA"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/aborts/EffectiveHCRX_EL2_TMEA</h3>
      <p class="pseudocode">// EffectiveHCRX_EL2_TMEA()
// ========================
// Return the Effective value of HCRX_EL2.TMEA.

func <a id="func_EffectiveHCRX_EL2_TMEA_0"/>EffectiveHCRX_EL2_TMEA() =&gt; bit
begin
    if (IsFeatureImplemented(FEAT_DoubleFault2) &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
          !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>()) then
        return HCRX_EL2().TMEA;
    else
        return '0';
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.exceptions.aborts.EffectiveHCR_AMO"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/aborts/EffectiveHCR_AMO</h3>
      <p class="pseudocode">// EffectiveHCR_AMO()
// ==================
// Return the Effective value of HCR_EL2.AMO.

func <a id="func_EffectiveHCR_AMO_0"/>EffectiveHCR_AMO() =&gt; bit
begin
    if <a href="shared_pseudocode.html#func_EffectiveTGE_0" title="">EffectiveTGE</a>() == '1' then
        return (if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) || <a href="shared_pseudocode.html#func_EffectiveHCR_EL2_E2H_0" title="">EffectiveHCR_EL2_E2H</a>() == '0' then '1' else '0');
    elsif <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        return (if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then HCR().AMO else HCR_EL2().AMO);
    else
        return '0';
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.exceptions.aborts.EffectiveHCR_TEA"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/aborts/EffectiveHCR_TEA</h3>
      <p class="pseudocode">// EffectiveHCR_TEA()
// ==================
// Return the Effective value of HCR_EL2.TEA.

func <a id="func_EffectiveHCR_TEA_0"/>EffectiveHCR_TEA() =&gt; bit
begin
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; IsFeatureImplemented(FEAT_RAS) then
        return (if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then HCR2().TEA else HCR_EL2().TEA);
    else
        return '0';
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.exceptions.aborts.EffectiveNMEA"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/aborts/EffectiveNMEA</h3>
      <p class="pseudocode">// EffectiveNMEA()
// ===============
// Return the Effective value of SCR_EL3.NMEA or SCTLR2_ELx.NMEA.

func <a id="func_EffectiveNMEA_0"/>EffectiveNMEA() =&gt; bit
begin
    if IsFeatureImplemented(FEAT_DoubleFault2) then
        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
            return SCR_EL3().NMEA;
        elsif (PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>()) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            return (if <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then SCTLR2_EL2().NMEA else '0');
        elsif !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
            return (if <a href="shared_pseudocode.html#func_IsSCTLR2EL1Enabled_0" title="">IsSCTLR2EL1Enabled</a>() then SCTLR2_EL1().NMEA else '0');
        else
            return '0';
        end;
    elsif IsFeatureImplemented(FEAT_DoubleFault) &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        return SCR_EL3().NMEA AND <a href="shared_pseudocode.html#func_EffectiveEA_0" title="">EffectiveEA</a>();
    else
        return '0';
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.exceptions.aborts.EffectiveSCR_EL3_TMEA"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/aborts/EffectiveSCR_EL3_TMEA</h3>
      <p class="pseudocode">// EffectiveSCR_EL3_TMEA()
// =======================
// Return the Effective value of SCR_EL3.TMEA.

func <a id="func_EffectiveSCR_EL3_TMEA_0"/>EffectiveSCR_EL3_TMEA() =&gt; bit
begin
    if (IsFeatureImplemented(FEAT_DoubleFault2) &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp;
          !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>)) then
        return SCR_EL3().TMEA;
    else
        return '0';
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.exceptions.aborts.PhysicalSErrorTarget"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/aborts/PhysicalSErrorTarget</h3>
      <p class="pseudocode">// PhysicalSErrorTarget()
// ======================
// Returns a tuple of whether SError exception can be taken and, if so, the
// target Exception level.
// If EL3 is implemented and using AArch32, then a target Exception level of
// EL1 means Abort mode, and EL3 means Monitor mode, including in Secure
// state when Abort mode is part of EL3.

func <a id="func_PhysicalSErrorTarget_0"/>PhysicalSErrorTarget() =&gt; (boolean, bits(2))
begin
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        return (TRUE, ARBITRARY : bits(2));
    end;

    let effective_ea : bit = <a href="shared_pseudocode.html#func_EffectiveEA_0" title="">EffectiveEA</a>();
    let effective_amo : bit = <a href="shared_pseudocode.html#func_EffectiveHCR_AMO_0" title="">EffectiveHCR_AMO</a>();
    let effective_tge : bit = <a href="shared_pseudocode.html#func_EffectiveTGE_0" title="">EffectiveTGE</a>();
    let effective_nmea : bit = <a href="shared_pseudocode.html#func_EffectiveNMEA_0" title="">EffectiveNMEA</a>();

    // When EL3 is implemented and using AArch32, the SCR.AW bit can allow PSTATE.A
    // to mask SError exceptions in Non-secure state when SCR.EA is 1 and the Effective
    // value of HCR.AMO is 0.
    var effective_aw : bit;
    if (<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; effective_ea == '1' &amp;&amp;
          <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> &amp;&amp; effective_amo == '0') then
        effective_aw = SCR().AW;
    else
        effective_aw = '0';
    end;

    // The exception is masked by software.
    var masked : boolean;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            masked = (!<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; effective_ea == '0') || PSTATE.A == '1';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            masked = ((effective_ea == '0' || effective_aw == '1') &amp;&amp;
                      ((!<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; effective_tge == '0' &amp;&amp; effective_amo == '0') ||
                       PSTATE.A == '1'));
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            masked = ((effective_ea == '0' || effective_aw == '1') &amp;&amp;
                      effective_amo == '0' &amp;&amp; PSTATE.A == '1');
    end;

    // When FEAT_DoubleFault or FEAT_DoubleFault2 is implemented, the mask might be overridden.
    masked = (masked &amp;&amp; effective_nmea == '0');

    // External debug might disable the exception in the current Security state.
    // This is not relevant at EL3.
    let intdis : boolean = PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_ExternalDebugInterruptsDisabled_1" title="">ExternalDebugInterruptsDisabled</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);

    var target_el : bits(2) = ARBITRARY : bits(2);
    if effective_ea == '1' || (PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>)) then
        if !masked then target_el = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>; end;

    elsif <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; effective_amo == '1' &amp;&amp; !intdis &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
        masked = FALSE;

    elsif (<a href="shared_pseudocode.html#func_EffectiveHCRX_EL2_TMEA_0" title="">EffectiveHCRX_EL2_TMEA</a>() == '1' &amp;&amp; !intdis &amp;&amp;
             ((PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; PSTATE.A == '1') ||
              (PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; masked &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>()))) then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
        masked = FALSE;

    elsif (<a href="shared_pseudocode.html#func_EffectiveSCR_EL3_TMEA_0" title="">EffectiveSCR_EL3_TMEA</a>() == '1' &amp;&amp;
             ((PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} &amp;&amp; PSTATE.A == '1') ||
             (PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>} &amp;&amp; masked) || intdis)) then
        target_el = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
        masked = FALSE;

    elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>() then
        if !masked then target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>; end;

    else
        assert (PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> ||
                  (PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>)) ||
                  (PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>()));
        if !masked then target_el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>; end;
    end;

    // External debug might disable the exception for the target Exception level.
    if !masked &amp;&amp; <a href="shared_pseudocode.html#func_ExternalDebugInterruptsDisabled_1" title="">ExternalDebugInterruptsDisabled</a>(target_el) then
        masked = TRUE;
        target_el = ARBITRARY : bits(2);
    end;

    return (masked, target_el);
end;</p>
    </div>
    <div class="ps"><a id="shared.exceptions.aborts.SyncExternalAbortTarget"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/aborts/SyncExternalAbortTarget</h3>
      <p class="pseudocode">// SyncExternalAbortTarget()
// =========================
// Returns the target Exception level for a Synchronous External Data or
// Instruction or Prefetch Abort.
// If EL3 is implemented and using AArch32, then a target Exception level of
// EL1 means Abort mode, and EL3 means Monitor mode, including in Secure
// state when Abort mode is part of EL3.

func <a id="func_SyncExternalAbortTarget_1"/>SyncExternalAbortTarget(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; bits(2)
begin
    let effective_ea : bit = <a href="shared_pseudocode.html#func_EffectiveEA_0" title="">EffectiveEA</a>();
    let effective_tea : bit = <a href="shared_pseudocode.html#func_EffectiveHCR_TEA_0" title="">EffectiveHCR_TEA</a>();
    let effective_tge : bit = <a href="shared_pseudocode.html#func_EffectiveTGE_0" title="">EffectiveTGE</a>();

    var target_el : bits(2);
    if effective_ea == '1' || (PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>)) then
        target_el = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;

    elsif (<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>} &amp;&amp;
           (effective_tea == '1' || <a href="shared_pseudocode.html#func_IsSecondStage_1" title="">IsSecondStage</a>(fault) ||
            fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_NV2" title="">AccessType_NV2</a> ||
            (PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; effective_tge == '1'))) then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;

    elsif <a href="shared_pseudocode.html#func_EffectiveHCRX_EL2_TMEA_0" title="">EffectiveHCRX_EL2_TMEA</a>() == '1' &amp;&amp; PSTATE.A == '1' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;

    elsif <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_TMEA_0" title="">EffectiveSCR_EL3_TMEA</a>() == '1' &amp;&amp; PSTATE.A == '1' &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} then
        target_el = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;

    else
        assert PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> || <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        target_el = (if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
    end;

    return target_el;
end;</p>
    </div>
    <div class="ps"><a id="shared.exceptions.exceptions.ConditionSyndrome"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/exceptions/ConditionSyndrome</h3>
      <p class="pseudocode">// ConditionSyndrome()
// ===================
// Return CV and COND fields of instruction syndrome

func <a id="func_ConditionSyndrome_0"/>ConditionSyndrome() =&gt; bits(5)
begin

    var syndrome : bits(5);

    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        let cond = <a href="shared_pseudocode.html#func_CurrentCond_0" title="">CurrentCond</a>();
        if PSTATE.T == '0' then             // A32
            syndrome[4] = '1';
            // A conditional A32 instruction that is known to pass its condition code check
            // can be presented either with COND set to 0xE, the value for unconditional, or
            // the COND value held in the instruction.
            if <a href="shared_pseudocode.html#func_ConditionHolds_1" title="">ConditionHolds</a>(cond) &amp;&amp; <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_ESRCONDPASS" title="">Unpredictable_ESRCONDPASS</a>) then
                syndrome[3:0] = '1110';
            else
                syndrome[3:0] = cond;
            end;
        else                                // T32
            // When a T32 instruction is trapped, it is IMPLEMENTATION DEFINED whether:
            //  * CV set to 0 and COND is set to an UNKNOWN value
            //  * CV set to 1 and COND is set to the condition code for the condition that
            //    applied to the instruction.
            if ImpDefBool("Condition valid for trapped T32") then
                syndrome[4] = '1';
                syndrome[3:0] = cond;
            else
                syndrome[4] = '0';
                syndrome[3:0] = ARBITRARY : bits(4);
            end;
        end;
    else
        syndrome[4] = '1';
        syndrome[3:0] = '1110';
    end;
    return syndrome;
end;</p>
    </div>
    <div class="ps"><a id="shared.exceptions.exceptions.Exception"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/exceptions/Exception</h3>
      <p class="pseudocode">// Exception
// =========
// Classes of exception.

type <a id="type_Exception"/>Exception of enumeration {
        <a id="enum_Exception_Uncategorized"/>Exception_Uncategorized,        // Uncategorized or unknown reason
        <a id="enum_Exception_WFxTrap"/>Exception_WFxTrap,              // Trapped WFI or WFE instruction
        <a id="enum_Exception_CP15RTTrap"/>Exception_CP15RTTrap,           // Trapped AArch32 MCR or MRC access, coproc=0b111
        <a id="enum_Exception_CP15RRTTrap"/>Exception_CP15RRTTrap,          // Trapped AArch32 MCRR or MRRC access, coproc=0b1111
        <a id="enum_Exception_CP14RTTrap"/>Exception_CP14RTTrap,           // Trapped AArch32 MCR or MRC access, coproc=0b1110
        <a id="enum_Exception_CP14DTTrap"/>Exception_CP14DTTrap,           // Trapped AArch32 LDC or STC access, coproc=0b1110
        <a id="enum_Exception_CP14RRTTrap"/>Exception_CP14RRTTrap,          // Trapped AArch32 MRRC access, coproc=0b1110
        <a id="enum_Exception_AdvSIMDFPAccessTrap"/>Exception_AdvSIMDFPAccessTrap,  // HCPTR-trapped access to SIMD or FP
        <a id="enum_Exception_FPIDTrap"/>Exception_FPIDTrap,             // Trapped access to SIMD or FP ID register
        <a id="enum_Exception_LDST64BTrap"/>Exception_LDST64BTrap,          // Trapped access to ST64BV, ST64BV0, ST64B and LD64B
        //Trapped BXJ instruction not supported in Armv8
        <a id="enum_Exception_PACTrap"/>Exception_PACTrap,               // Trapped invalid PAC use
        <a id="enum_Exception_IllegalState"/>Exception_IllegalState,          // Illegal Execution state
        <a id="enum_Exception_SupervisorCall"/>Exception_SupervisorCall,        // Supervisor Call
        <a id="enum_Exception_HypervisorCall"/>Exception_HypervisorCall,        // Hypervisor Call
        <a id="enum_Exception_MonitorCall"/>Exception_MonitorCall,           // Monitor Call or Trapped SMC instruction
        <a id="enum_Exception_SystemRegisterTrap"/>Exception_SystemRegisterTrap,    // Trapped MRS or MSR System register access
        <a id="enum_Exception_ERetTrap"/>Exception_ERetTrap,              // Trapped invalid ERET use
        <a id="enum_Exception_InstructionAbort"/>Exception_InstructionAbort,      // Instruction Abort or Prefetch Abort
        <a id="enum_Exception_PCAlignment"/>Exception_PCAlignment,           // PC alignment fault
        <a id="enum_Exception_DataAbort"/>Exception_DataAbort,             // Data Abort
        <a id="enum_Exception_NV2DataAbort"/>Exception_NV2DataAbort,          // Data abort at EL1 reported as being from EL2
        <a id="enum_Exception_PACFail"/>Exception_PACFail,               // PAC Authentication failure
        <a id="enum_Exception_SPAlignment"/>Exception_SPAlignment,           // SP alignment fault
        <a id="enum_Exception_FPTrappedException"/>Exception_FPTrappedException,    // IEEE trapped FP exception
        <a id="enum_Exception_SError"/>Exception_SError,                // SError interrupt
        <a id="enum_Exception_Breakpoint"/>Exception_Breakpoint,            // (Hardware) Breakpoint
        <a id="enum_Exception_SoftwareStep"/>Exception_SoftwareStep,          // Software Step
        <a id="enum_Exception_Watchpoint"/>Exception_Watchpoint,            // Watchpoint
        <a id="enum_Exception_NV2Watchpoint"/>Exception_NV2Watchpoint,         // Watchpoint at EL1 reported as being from EL2
        <a id="enum_Exception_SoftwareBreakpoint"/>Exception_SoftwareBreakpoint,    // Software Breakpoint Instruction
        <a id="enum_Exception_VectorCatch"/>Exception_VectorCatch,           // AArch32 Vector Catch
        <a id="enum_Exception_IRQ"/>Exception_IRQ,                   // IRQ interrupt
        <a id="enum_Exception_SVEAccessTrap"/>Exception_SVEAccessTrap,         // HCPTR trapped access to SVE
        <a id="enum_Exception_SMEAccessTrap"/>Exception_SMEAccessTrap,         // HCPTR trapped access to SME
        <a id="enum_Exception_GPC"/>Exception_GPC,                   // Granule protection check
        <a id="enum_Exception_BranchTarget"/>Exception_BranchTarget,          // Branch Target Identification
        <a id="enum_Exception_MemCpyMemSet"/>Exception_MemCpyMemSet,          // Exception from a CPY* or SET* instruction
        <a id="enum_Exception_GCSFail"/>Exception_GCSFail,               // GCS Exceptions
        <a id="enum_Exception_Profiling"/>Exception_Profiling,             // Profiling exception
        <a id="enum_Exception_SystemRegister128Trap"/>Exception_SystemRegister128Trap, // Trapped MRRS or MSRR System register or SYSP access
        <a id="enum_Exception_FIQ"/>Exception_FIQ};                  // FIQ interrupt</p>
    </div>
    <div class="ps"><a id="shared.exceptions.exceptions.ExceptionRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/exceptions/ExceptionRecord</h3>
      <p class="pseudocode">// ExceptionRecord
// ===============

type <a id="type_ExceptionRecord"/>ExceptionRecord of record {
    exceptype : <a href="shared_pseudocode.html#type_Exception" title="">Exception</a>,           // Exception class
    syndrome : <a href="shared_pseudocode.html#type_IssType" title="">IssType</a>,              // Syndrome record
    paddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>,          // Physical fault address
    vaddress : bits(64),             // Virtual fault address
    ipavalid : boolean,              // Validity of Intermediate Physical fault address
    pavalid : boolean,               // Validity of Physical fault address
    NS : bit,                        // Intermediate Physical fault address space
    ipaddress : bits(56),    // Intermediate Physical fault address
    trappedsyscallinst : boolean};   // Trapped SVC or SMC instruction</p>
    </div>
    <div class="ps"><a id="shared.exceptions.exceptions.ExceptionSyndrome"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/exceptions/ExceptionSyndrome</h3>
      <p class="pseudocode">// ExceptionSyndrome()
// ===================
// Return a blank exception syndrome record for an exception of the given type.

func <a id="func_ExceptionSyndrome_1"/>ExceptionSyndrome(exceptype : <a href="shared_pseudocode.html#type_Exception" title="">Exception</a>) =&gt; <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>
begin

    var r : <a href="shared_pseudocode.html#type_ExceptionRecord" title="">ExceptionRecord</a>;

    r.exceptype      = exceptype;

    // Initialize all other fields
    r.syndrome.iss   = Zeros{25};
    r.syndrome.iss2  = Zeros{24};
    r.vaddress       = Zeros{64};
    r.ipavalid       = FALSE;
    r.pavalid        = FALSE;
    r.NS             = '0';
    r.ipaddress      = Zeros{56};
    r.paddress.paspace = ARBITRARY : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>;
    r.paddress.address = ARBITRARY : bits(56);
    r.trappedsyscallinst = FALSE;
    return r;
end;</p>
    </div>
    <div class="ps"><a id="shared.exceptions.traps.Undefined"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/traps/Undefined</h3>
      <p class="pseudocode">// Undefined()
// ===========

noreturn func Undefined()
begin
    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        AArch32_Undefined();
    else
        AArch64_Undefined();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.EncodeLDFSC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/EncodeLDFSC</h3>
      <p class="pseudocode">// EncodeLDFSC()
// =============
// Function that gives the Long-descriptor FSC code for types of Fault

func <a id="func_EncodeLDFSC_2"/>EncodeLDFSC(statuscode : <a href="shared_pseudocode.html#type_Fault" title="">Fault</a>, level : integer) =&gt; bits(6)
begin
    var result : bits(6);

    // 128-bit descriptors will start from level -2 for 4KB to resolve bits IA[55:51]
    if level == -2 then
        assert IsFeatureImplemented(FEAT_D128);
        case statuscode of
            when <a href="shared_pseudocode.html#enum_Fault_AddressSize" title="">Fault_AddressSize</a> =&gt;          result = '101100';
            when <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a> =&gt;          result = '101010';
            when <a href="shared_pseudocode.html#enum_Fault_SyncExternalOnWalk" title="">Fault_SyncExternalOnWalk</a> =&gt;   result = '010010';
            when <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a> =&gt;
                result = '011010';
                assert !IsFeatureImplemented(FEAT_RAS);
            when <a href="shared_pseudocode.html#enum_Fault_GPCFOnWalk" title="">Fault_GPCFOnWalk</a> =&gt;           result = '100010';
            otherwise =&gt;                       unreachable;
        end;
        return result;
    end;

    if level == -1 then
        assert IsFeatureImplemented(FEAT_LPA2);
        case statuscode of
            when <a href="shared_pseudocode.html#enum_Fault_AddressSize" title="">Fault_AddressSize</a> =&gt;          result = '101001';
            when <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a> =&gt;          result = '101011';
            when <a href="shared_pseudocode.html#enum_Fault_SyncExternalOnWalk" title="">Fault_SyncExternalOnWalk</a> =&gt;   result = '010011';
            when <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a> =&gt;
                result = '011011';
                assert !IsFeatureImplemented(FEAT_RAS);
            when <a href="shared_pseudocode.html#enum_Fault_GPCFOnWalk" title="">Fault_GPCFOnWalk</a> =&gt;           result = '100011';
            otherwise =&gt;                       unreachable;
        end;

        return result;
    end;
    case statuscode of
        when <a href="shared_pseudocode.html#enum_Fault_AddressSize" title="">Fault_AddressSize</a> =&gt;         result = '0000'::level[1:0]; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#enum_Fault_AccessFlag" title="">Fault_AccessFlag</a> =&gt;          result = '0010'::level[1:0]; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a> =&gt;          result = '0011'::level[1:0]; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a> =&gt;         result = '0001'::level[1:0]; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#enum_Fault_SyncExternal" title="">Fault_SyncExternal</a> =&gt;        result = '010000';
        when <a href="shared_pseudocode.html#enum_Fault_SyncExternalOnWalk" title="">Fault_SyncExternalOnWalk</a> =&gt;  result = '0101'::level[1:0]; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#enum_Fault_SyncParity" title="">Fault_SyncParity</a> =&gt;          result = '011000';
        when <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a> =&gt;    result = '0111'::level[1:0]; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#enum_Fault_AsyncParity" title="">Fault_AsyncParity</a> =&gt;         result = '011001';
        when <a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a> =&gt;       result = '010001'; assert <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
        when <a href="shared_pseudocode.html#enum_Fault_TagCheck" title="">Fault_TagCheck</a> =&gt;            result = '010001'; assert IsFeatureImplemented(FEAT_MTE2);
        when <a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a> =&gt;           result = '100001';
        when <a href="shared_pseudocode.html#enum_Fault_Debug" title="">Fault_Debug</a> =&gt;               result = '100010';
        when <a href="shared_pseudocode.html#enum_Fault_GPCFOnWalk" title="">Fault_GPCFOnWalk</a> =&gt;          result = '1001'::level[1:0]; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#enum_Fault_GPCFOnOutput" title="">Fault_GPCFOnOutput</a> =&gt;        result = '101000';
        when <a href="shared_pseudocode.html#enum_Fault_TLBConflict" title="">Fault_TLBConflict</a> =&gt;         result = '110000';
        when <a href="shared_pseudocode.html#enum_Fault_HWUpdateAccessFlag" title="">Fault_HWUpdateAccessFlag</a> =&gt;  result = '110001';
        when <a href="shared_pseudocode.html#enum_Fault_Lockdown" title="">Fault_Lockdown</a> =&gt;            result = '110100';  // IMPLEMENTATION DEFINED
        when <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a> =&gt;           result = '110101';  // IMPLEMENTATION DEFINED
        otherwise =&gt;                      unreachable;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IPAValid"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IPAValid</h3>
      <p class="pseudocode">// IPAValid()
// ==========
// Return TRUE if the IPA is reported for the abort

func <a id="func_IPAValid_1"/>IPAValid(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    assert fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;

    if fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> then
        return fault.secondstage;
    elsif fault.s2fs1walk then
        return fault.statuscode IN {
            <a href="shared_pseudocode.html#enum_Fault_AccessFlag" title="">Fault_AccessFlag</a>,
            <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>,
            <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>,
            <a href="shared_pseudocode.html#enum_Fault_AddressSize" title="">Fault_AddressSize</a>
        };
    elsif fault.secondstage then
        return fault.statuscode IN {
            <a href="shared_pseudocode.html#enum_Fault_AccessFlag" title="">Fault_AccessFlag</a>,
            <a href="shared_pseudocode.html#enum_Fault_Translation" title="">Fault_Translation</a>,
            <a href="shared_pseudocode.html#enum_Fault_AddressSize" title="">Fault_AddressSize</a>
        } || (IsFeatureImplemented(FEAT_EAESR) &amp;&amp; fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a>);
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsAsyncAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsAsyncAbort</h3>
      <p class="pseudocode">// IsAsyncAbort()
// ==============
// Returns TRUE if the abort currently being processed is an asynchronous abort, and FALSE
// otherwise.

func <a id="func_IsAsyncAbort_1"/>IsAsyncAbort(statuscode : <a href="shared_pseudocode.html#type_Fault" title="">Fault</a>) =&gt; boolean
begin
    assert statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;

    return (statuscode IN {<a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a>, <a href="shared_pseudocode.html#enum_Fault_AsyncParity" title="">Fault_AsyncParity</a>});
end;

// IsAsyncAbort()
// ==============

func <a id="func_IsAsyncAbort_1"/>IsAsyncAbort(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_IsAsyncAbort_1" title="">IsAsyncAbort</a>(fault.statuscode);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsDebugException"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsDebugException</h3>
      <p class="pseudocode">// IsDebugException()
// ==================

func <a id="func_IsDebugException_1"/>IsDebugException(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    assert fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
    return fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_Debug" title="">Fault_Debug</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsExternalAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsExternalAbort</h3>
      <p class="pseudocode">// IsExternalAbort()
// =================
// Returns TRUE if the abort currently being processed is an External abort and FALSE otherwise.

readonly func <a id="func_IsExternalAbort_1"/>IsExternalAbort(statuscode : <a href="shared_pseudocode.html#type_Fault" title="">Fault</a>) =&gt; boolean
begin
    assert statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;

    return (statuscode IN {
              <a href="shared_pseudocode.html#enum_Fault_SyncExternal" title="">Fault_SyncExternal</a>,
              <a href="shared_pseudocode.html#enum_Fault_SyncParity" title="">Fault_SyncParity</a>,
              <a href="shared_pseudocode.html#enum_Fault_SyncExternalOnWalk" title="">Fault_SyncExternalOnWalk</a>,
              <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a>,
              <a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a>,
              <a href="shared_pseudocode.html#enum_Fault_AsyncParity" title="">Fault_AsyncParity</a>
    });
end;

// IsExternalAbort()
// =================

readonly func <a id="func_IsExternalAbort_1"/>IsExternalAbort(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(fault.statuscode) || fault.gpcf.gpf == <a href="shared_pseudocode.html#enum_GPCF_EABT" title="">GPCF_EABT</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsExternalAbortOnWalk"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsExternalAbortOnWalk</h3>
      <p class="pseudocode">// IsExternalAbortOnWalk()
// =======================

func <a id="func_IsExternalAbortOnWalk_1"/>IsExternalAbortOnWalk(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    assert fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
    return fault.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_SyncExternalOnWalk" title="">Fault_SyncExternalOnWalk</a>, <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a>};
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsExternalSyncAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsExternalSyncAbort</h3>
      <p class="pseudocode">// IsExternalSyncAbort()
// =====================
// Returns TRUE if the abort currently being processed is an external
// synchronous abort and FALSE otherwise.

readonly func <a id="func_IsExternalSyncAbort_1"/>IsExternalSyncAbort(statuscode : <a href="shared_pseudocode.html#type_Fault" title="">Fault</a>) =&gt; boolean
begin
    assert statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
    if IsFeatureImplemented(FEAT_RAS) then
        assert ! statuscode IN {<a href="shared_pseudocode.html#enum_Fault_SyncParity" title="">Fault_SyncParity</a>, <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a>};
    end;

    return (statuscode IN {
              <a href="shared_pseudocode.html#enum_Fault_SyncExternal" title="">Fault_SyncExternal</a>,
              <a href="shared_pseudocode.html#enum_Fault_SyncParity" title="">Fault_SyncParity</a>,
              <a href="shared_pseudocode.html#enum_Fault_SyncExternalOnWalk" title="">Fault_SyncExternalOnWalk</a>,
              <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a>
    });
end;

// IsExternalSyncAbort()
// =====================

readonly func <a id="func_IsExternalSyncAbort_1"/>IsExternalSyncAbort(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_IsExternalSyncAbort_1" title="">IsExternalSyncAbort</a>(fault.statuscode) || fault.gpcf.gpf == <a href="shared_pseudocode.html#enum_GPCF_EABT" title="">GPCF_EABT</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsFault"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsFault</h3>
      <p class="pseudocode">// IsFault()
// =========
// Return TRUE if a fault is associated with an address descriptor

func <a id="func_IsFault_1"/>IsFault(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; boolean
begin
    return addrdesc.fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
end;

// IsFault()
// =========
// Return TRUE if a fault is associated with a memory access.

func <a id="func_IsFault_1"/>IsFault(fault : <a href="shared_pseudocode.html#type_Fault" title="">Fault</a>) =&gt; boolean
begin
    return fault != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
end;

// IsFault()
// =========
// Return TRUE if a fault is associated with status returned by memory.

func <a id="func_IsFault_1"/>IsFault(retstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>) =&gt; boolean
begin
    return retstatus.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsSErrorInterrupt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsSErrorInterrupt</h3>
      <p class="pseudocode">// IsSErrorInterrupt()
// ===================
// Returns TRUE if the abort currently being processed is an SError interrupt, and FALSE
// otherwise.

func <a id="func_IsSErrorInterrupt_1"/>IsSErrorInterrupt(statuscode : <a href="shared_pseudocode.html#type_Fault" title="">Fault</a>) =&gt; boolean
begin
    assert statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;

    return (statuscode IN {<a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a>, <a href="shared_pseudocode.html#enum_Fault_AsyncParity" title="">Fault_AsyncParity</a>});
end;

// IsSErrorInterrupt()
// ===================

func <a id="func_IsSErrorInterrupt_1"/>IsSErrorInterrupt(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_IsSErrorInterrupt_1" title="">IsSErrorInterrupt</a>(fault.statuscode);
end;

// Add a specific type of return value for FaultSyndrome
type <a id="type_IssType"/>IssType of record {
    iss : bits(25),
    iss2 : bits(24)

};</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsSecondStage"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsSecondStage</h3>
      <p class="pseudocode">// IsSecondStage()
// ===============

func <a id="func_IsSecondStage_1"/>IsSecondStage(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    assert fault.statuscode != <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;

    return fault.secondstage;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.LSInstructionSyndrome"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/LSInstructionSyndrome</h3>
      <p class="pseudocode">// LSInstructionSyndrome()
// =======================
// Returns the extended syndrome information for a second stage fault.
//  [10]  - Syndrome valid bit. The syndrome is valid only for certain types of access instruction.
//  [9:8] - Access size.
//  [7]   - Sign extended (for loads).
//  [6:2] - Transfer register.
//  [1]   - Transfer register is 64-bit.
//  [0]   - Instruction has acquire/release semantics.

impdef func <a id="func_LSInstructionSyndrome_0"/>LSInstructionSyndrome() =&gt; bits(11)
begin
    return ARBITRARY : bits(11);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.ReportAsGPCException"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/ReportAsGPCException</h3>
      <p class="pseudocode">// ReportAsGPCException()
// ======================
// Determine whether the given GPCF is reported as a Granule Protection Check Exception
// rather than a Data or Instruction Abort

func <a id="func_ReportAsGPCException_1"/>ReportAsGPCException(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    assert IsFeatureImplemented(FEAT_RME);
    assert fault.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_GPCFOnWalk" title="">Fault_GPCFOnWalk</a>, <a href="shared_pseudocode.html#enum_Fault_GPCFOnOutput" title="">Fault_GPCFOnOutput</a>};
    assert fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a>;

    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() &amp;&amp; EDSCR().SDD == '1' then
        return FALSE;
    end;

    case fault.gpcf.gpf of
        when <a href="shared_pseudocode.html#enum_GPCF_Walk" title="">GPCF_Walk</a> =&gt;        return TRUE;
        when <a href="shared_pseudocode.html#enum_GPCF_AddressSize" title="">GPCF_AddressSize</a> =&gt; return TRUE;
        when <a href="shared_pseudocode.html#enum_GPCF_EABT" title="">GPCF_EABT</a> =&gt;        return TRUE;
        when <a href="shared_pseudocode.html#enum_GPCF_Fail" title="">GPCF_Fail</a> =&gt;        return SCR_EL3().GPF == '1' &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CACHE_OP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CACHE_OP</h3>
      <p class="pseudocode">// CACHE_OP()
// ==========
// Performs Cache maintenance operations as per CacheRecord.

impdef func CACHE_OP(cache : <a href="shared_pseudocode.html#type_CacheRecord" title="">CacheRecord</a>)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CPASAtPAS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CPASAtPAS</h3>
      <p class="pseudocode">// CPASAtPAS()
// ===========
// Get cache PA space for given PA space.

func <a id="func_CPASAtPAS_1"/>CPASAtPAS(pas : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>) =&gt; <a href="shared_pseudocode.html#type_CachePASpace" title="">CachePASpace</a>
begin
    case pas of
        when <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> =&gt;
            return <a href="shared_pseudocode.html#enum_CPAS_NonSecure" title="">CPAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a> =&gt;
            return <a href="shared_pseudocode.html#enum_CPAS_Secure" title="">CPAS_Secure</a>;
        when <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a> =&gt;
            return <a href="shared_pseudocode.html#enum_CPAS_Root" title="">CPAS_Root</a>;
        when <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a> =&gt;
            return <a href="shared_pseudocode.html#enum_CPAS_Realm" title="">CPAS_Realm</a>;
        when <a href="shared_pseudocode.html#enum_PAS_SystemAgent" title="">PAS_SystemAgent</a> =&gt;
            return <a href="shared_pseudocode.html#enum_CPAS_SystemAgent" title="">CPAS_SystemAgent</a>;
        when <a href="shared_pseudocode.html#enum_PAS_NonSecureProtected" title="">PAS_NonSecureProtected</a> =&gt;
            return <a href="shared_pseudocode.html#enum_CPAS_NonSecureProtected" title="">CPAS_NonSecureProtected</a>;
        when <a href="shared_pseudocode.html#enum_PAS_NA6" title="">PAS_NA6</a> =&gt;
            return <a href="shared_pseudocode.html#enum_CPAS_NA6" title="">CPAS_NA6</a>;
        when <a href="shared_pseudocode.html#enum_PAS_NA7" title="">PAS_NA7</a> =&gt;
            return <a href="shared_pseudocode.html#enum_CPAS_NA7" title="">CPAS_NA7</a>;
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CPASAtSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CPASAtSecurityState</h3>
      <p class="pseudocode">// CPASAtSecurityState()
// =====================
// Get cache PA space for given security state.

func <a id="func_CPASAtSecurityState_1"/>CPASAtSecurityState(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>) =&gt; <a href="shared_pseudocode.html#type_CachePASpace" title="">CachePASpace</a>
begin
    case ss of
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;
            return <a href="shared_pseudocode.html#enum_CPAS_NonSecure" title="">CPAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;
            return <a href="shared_pseudocode.html#enum_CPAS_SecureNonSecure" title="">CPAS_SecureNonSecure</a>;
        when <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> =&gt;
            return <a href="shared_pseudocode.html#enum_CPAS_Any" title="">CPAS_Any</a>;
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;
            return <a href="shared_pseudocode.html#enum_CPAS_RealmNonSecure" title="">CPAS_RealmNonSecure</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CacheRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CacheRecord</h3>
      <p class="pseudocode">// CacheRecord
// ===========
// Details related to a cache operation.

type <a id="type_CacheRecord"/>CacheRecord of record {
    acctype       : <a href="shared_pseudocode.html#type_AccessType" title="">AccessType</a>,        // Access type
    cacheop       : <a href="shared_pseudocode.html#type_CacheOp" title="">CacheOp</a>,           // Cache operation
    opscope       : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>,      // Cache operation type
    cachetype     : <a href="shared_pseudocode.html#type_CacheType" title="">CacheType</a>,         // Cache type
    regval        : bits(64),
    paddress      : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>,
    vaddress      : bits(64),          // For VA operations
    setnum        : integer,           // For SW operations
    waynum        : integer,           // For SW operations
    level         : integer,           // For SW operations
    shareability  : <a href="shared_pseudocode.html#type_Shareability" title="">Shareability</a>,
    is_vmid_valid : boolean,           // is vmid valid for current context
    vmid          : bits(16),
    is_asid_valid : boolean,           // is asid valid for current context
    asid          : bits(16),
    security      : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>,
    // For inner shareable IC operations, the TLBI Domains the operation is broadcast to
    domains : bits(16),
    // For cache operations to full cache or by setnum/waynum
    // For operations by address, PA space in paddress
    cpas : <a href="shared_pseudocode.html#type_CachePASpace" title="">CachePASpace</a>
};</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.DecodeSW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/DecodeSW</h3>
      <p class="pseudocode">// DecodeSW()
// ==========
// Decode input value into setnum, waynum and level for SW instructions.

func <a id="func_DecodeSW_2"/>DecodeSW(regval : bits(64), cachetype : <a href="shared_pseudocode.html#type_CacheType" title="">CacheType</a>) =&gt; (integer, integer, integer)
begin
    let level : integer = UInt(regval[3:1]);
    let (numsets, associativity, linesize) = <a href="shared_pseudocode.html#func_GetCacheInfo_2" title="">GetCacheInfo</a>(level, cachetype);
    // For the given level and cachetype, get the number of sets, associativity and
    // cache line size in terms of actual bytes.

    let max_waybits : integer{} = if IsFeatureImplemented(FEAT_CCIDX) then 21 else 10;
    let max_setbits : integer{} = if IsFeatureImplemented(FEAT_CCIDX) then 24 else 15;

    let waybits : integer{} = CeilLog2(associativity) as integer{0..max_waybits};
    let setbits : integer{} = CeilLog2(numsets) as integer{0..max_setbits};
    let linebits : integer{} = FloorLog2(linesize) as integer{4..11};

    let waynum : integer = if associativity == 1 then 0 else UInt(regval[31:32-waybits]);
    let setnum : integer = if numsets == 1 then 0 else UInt(regval[linebits +: setbits]);

    return (setnum, waynum, level);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.GetCacheInfo"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/GetCacheInfo</h3>
      <p class="pseudocode">// GetCacheInfo()
// ==============
// Returns numsets, assosciativity &amp; linesize in terms of actual bytes.

impdef func <a id="func_GetCacheInfo_2"/>GetCacheInfo(level : integer, cachetype : <a href="shared_pseudocode.html#type_CacheType" title="">CacheType</a>) =&gt; (integer, integer, integer)
begin
    let numsets : integer = ImpDefInt("Numsets for DC SW instructions");
    let associativity : integer = ImpDefInt("Associativity for DC SW instructions");
    let linesize : integer = ImpDefInt("Linesize for DC SW instructions");
    return (numsets, associativity, linesize);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.IsZeroBit"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/IsZeroBit</h3>
      <p class="pseudocode">// IsZeroBit()
// ===========

func <a id="func_IsZeroBit_2"/>IsZeroBit{N}(x : bits(N)) =&gt; bit
begin
    return if IsZero(x) then '1' else '0';
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.NormalizeReal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/NormalizeReal</h3>
      <p class="pseudocode">// NormalizeReal
// =============
// Normalizes x to the form 1.xxx... x 2^y and returns (mantissa, exponent)

func <a id="func_NormalizeReal_1"/>NormalizeReal(x : real) =&gt; (real, integer)
begin
    let exponent : integer = ILog2(x);
    let mantissa : real = x / (2.0 ^ exponent);
    return (mantissa, exponent);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.RShr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/RShr</h3>
      <p class="pseudocode">// RShr()
// ======
// Shift integer value right with rounding

func <a id="func_RShr_3"/>RShr(value : integer, shift : integer, round : boolean) =&gt; integer
begin
    assert shift &gt; 0;
    if round then
        return (value + (1 &lt;&lt; (shift - 1))) &gt;&gt; shift;
    else
        return value &gt;&gt; shift;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Reverse"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Reverse</h3>
      <p class="pseudocode">// Reverse()
// =========
// Reverse subwords of M bits in an N-bit word

func <a id="func_Reverse_3"/>Reverse{N}(word : bits(N), M : integer) =&gt; bits(N)
begin
    assert N MOD M == 0;
    var result : bits(N);
    let swsize : integer{} = M as integer{1..N};
    let sw : integer = N DIV swsize;
    for s = 0 to sw-1 do
        result[((sw - 1) - s)*:swsize] = word[s*:swsize];
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Signal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Signal</h3>
      <p class="pseudocode">// Signal
// ======
// Available signal types

type <a id="Signal"/>Signal of enumeration {LOW, HIGH};</p>
    </div>
    <div class="ps"><a id="shared.functions.counters"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters</h3>
      <p class="pseudocode">var <a id="global_PhysicalCount"/>PhysicalCount : bits(88);

var <a id="global_IsLocalTimeoutEventPending"/>IsLocalTimeoutEventPending : boolean;

var <a id="global_LocalTimeoutVal"/>LocalTimeoutVal : bits(64);          // Value to compare against the Virtual Counter Timer</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.AArch32_CheckTimerConditions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/AArch32_CheckTimerConditions</h3>
      <p class="pseudocode">// AArch32_CheckTimerConditions()
// ==============================
// Checking timer conditions for all A32 timer registers

func AArch32_CheckTimerConditions()
begin
    var status : boolean;
    var offset : bits(64);
    offset = Zeros{64};
    assert !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>();
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if CNTP_CTL_S().ENABLE == '1' then
            status = IsTimerConditionMet(offset, CNTP_CVAL_S(),
                                         CNTP_CTL_S().IMASK, <a href="shared_pseudocode.html#enum_InterruptID_CNTPS" title="">InterruptID_CNTPS</a>);
            CNTP_CTL_S().ISTATUS = if status then '1' else '0';
        end;

        if CNTP_CTL_NS().ENABLE == '1' then
            status = IsTimerConditionMet(offset, CNTP_CVAL_NS(),
                                         CNTP_CTL_NS().IMASK, <a href="shared_pseudocode.html#enum_InterruptID_CNTP" title="">InterruptID_CNTP</a>);
            CNTP_CTL_NS().ISTATUS = if status then '1' else '0';
        end;
    else
        if CNTP_CTL().ENABLE == '1' then
            status = IsTimerConditionMet(offset, CNTP_CVAL(),
                                         CNTP_CTL().IMASK, <a href="shared_pseudocode.html#enum_InterruptID_CNTP" title="">InterruptID_CNTP</a>);
            CNTP_CTL().ISTATUS = if status then '1' else '0';
        end;
    end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; CNTHP_CTL().ENABLE == '1' then
        status = IsTimerConditionMet(offset, CNTHP_CVAL(),
                                     CNTHP_CTL().IMASK, <a href="shared_pseudocode.html#enum_InterruptID_CNTHP" title="">InterruptID_CNTHP</a>);
        CNTHP_CTL().ISTATUS = if status then '1' else '0';
    end;
    if CNTV_CTL_EL0().ENABLE == '1' then
        status = IsTimerConditionMet(CNTVOFF_EL2(), CNTV_CVAL_EL0(),
                                     CNTV_CTL_EL0().IMASK, <a href="shared_pseudocode.html#enum_InterruptID_CNTV" title="">InterruptID_CNTV</a>);
        CNTV_CTL_EL0().ISTATUS = if status then '1' else '0';
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.AArch64_CheckTimerConditions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/AArch64_CheckTimerConditions</h3>
      <p class="pseudocode">// AArch64_CheckTimerConditions()
// ==============================
// Checking timer conditions for all A64 timer registers

func AArch64_CheckTimerConditions()
begin
    var status : boolean;
    var offset : bits(64);
    var imask : bit;
    let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>();
    if (IsFeatureImplemented(FEAT_ECV_POFF) &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) &amp;&amp;
          CNTHCTL_EL2().ECV == '1' &amp;&amp; SCR_EL3().ECVEn == '1') then
        offset = CNTPOFF_EL2();
    else
        offset = Zeros{64};
    end;
    if CNTP_CTL_EL0().ENABLE == '1' then
        imask = CNTP_CTL_EL0().IMASK;
        if (IsFeatureImplemented(FEAT_RME) &amp;&amp; ss IN {<a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a>, <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a>} &amp;&amp;
              CNTHCTL_EL2().CNTPMASK == '1') then
            imask = '1';
        end;
        status = IsTimerConditionMet(offset, CNTP_CVAL_EL0(),
                                     imask, <a href="shared_pseudocode.html#enum_InterruptID_CNTP" title="">InterruptID_CNTP</a>);
        CNTP_CTL_EL0().ISTATUS = if status then '1' else '0';
    end;
    if ((<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; !IsFeatureImplemented(FEAT_SEL2))) &amp;&amp;
       CNTHP_CTL_EL2().ENABLE == '1') then
        status = IsTimerConditionMet(Zeros{64}, CNTHP_CVAL_EL2(),
                                     CNTHP_CTL_EL2().IMASK, <a href="shared_pseudocode.html#enum_InterruptID_CNTHP" title="">InterruptID_CNTHP</a>);
        CNTHP_CTL_EL2().ISTATUS = if status then '1' else '0';
    end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; IsFeatureImplemented(FEAT_SEL2) &amp;&amp; CNTHPS_CTL_EL2().ENABLE == '1' then
        status = IsTimerConditionMet(Zeros{64}, CNTHPS_CVAL_EL2(),
                                     CNTHPS_CTL_EL2().IMASK, <a href="shared_pseudocode.html#enum_InterruptID_CNTHPS" title="">InterruptID_CNTHPS</a>);
        CNTHPS_CTL_EL2().ISTATUS = if status then '1' else '0';
    end;

    if CNTPS_CTL_EL1().ENABLE == '1' then
        status = IsTimerConditionMet(Zeros{64}, CNTPS_CVAL_EL1(),
                                     CNTPS_CTL_EL1().IMASK, <a href="shared_pseudocode.html#enum_InterruptID_CNTPS" title="">InterruptID_CNTPS</a>);
        CNTPS_CTL_EL1().ISTATUS = if status then '1' else '0';
    end;

    if CNTV_CTL_EL0().ENABLE == '1' then
        imask = CNTV_CTL_EL0().IMASK;
        if (IsFeatureImplemented(FEAT_RME) &amp;&amp; ss IN {<a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a>, <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a>} &amp;&amp;
              CNTHCTL_EL2().CNTVMASK == '1') then
            imask = '1';
        end;
        status = IsTimerConditionMet(CNTVOFF_EL2(), CNTV_CVAL_EL0(),
                                     imask, <a href="shared_pseudocode.html#enum_InterruptID_CNTV" title="">InterruptID_CNTV</a>);
        CNTV_CTL_EL0().ISTATUS = if status then '1' else '0';
    end;

    if ((IsFeatureImplemented(FEAT_VHE) &amp;&amp; (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || !IsFeatureImplemented(FEAT_SEL2))) &amp;&amp;
          CNTHV_CTL_EL2().ENABLE == '1') then
        status = IsTimerConditionMet(Zeros{64}, CNTHV_CVAL_EL2(),
                                     CNTHV_CTL_EL2().IMASK, <a href="shared_pseudocode.html#enum_InterruptID_CNTHV" title="">InterruptID_CNTHV</a>);
        CNTHV_CTL_EL2().ISTATUS = if status then '1' else '0';
    end;

    if ((IsFeatureImplemented(FEAT_SEL2) &amp;&amp; IsFeatureImplemented(FEAT_VHE)) &amp;&amp;
          CNTHVS_CTL_EL2().ENABLE == '1') then
        status = IsTimerConditionMet(Zeros{64}, CNTHVS_CVAL_EL2(),
                                     CNTHVS_CTL_EL2().IMASK, <a href="shared_pseudocode.html#enum_InterruptID_CNTHVS" title="">InterruptID_CNTHVS</a>);
        CNTHVS_CTL_EL2().ISTATUS = if status then '1' else '0';
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.CNTHCTL_EL2_VHE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/CNTHCTL_EL2_VHE</h3>
      <p class="pseudocode">// CNTHCTL_EL2_VHE()
// =================
// In the case where EL2 accesses the CNTKCTL_EL1 register, and the access
// is redirected to CNTHCTL_EL2 as a result of HCR_EL2.E2H being 1,
// then the bits of CNTHCTL_EL2 that are RES0 in CNTKCTL_EL1 are
// treated as being UNKNOWN. This function applies the UNKNOWN behavior.

func <a id="func_CNTHCTL_EL2_VHE_1"/>CNTHCTL_EL2_VHE(original_value : bits(64)) =&gt; bits(64)
begin
    assert PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    assert HCR_EL2().E2H == '1';

    var return_value : bits(64) = original_value;
    if !IsFeatureImplemented(FEAT_NV2p1) then
        return_value[19:18] = ARBITRARY : bits(2);
        return_value[16:10] = ARBITRARY : bits(7);
    end;
    return return_value;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.GenericCounterTick"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/GenericCounterTick</h3>
      <p class="pseudocode">// GenericCounterTick()
// ====================
// Increments PhysicalCount value for every clock tick.

func GenericCounterTick()
begin
    var prev_physical_count : bits(64);
    if CNTCR().EN == '0' then
        if !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
            AArch32_CheckTimerConditions();
        else
            AArch64_CheckTimerConditions();
        end;
        return;
    end;
    prev_physical_count = <a href="shared_pseudocode.html#func_PhysicalCountInt_0" title="">PhysicalCountInt</a>();
    if IsFeatureImplemented(FEAT_CNTSC) &amp;&amp; CNTCR().SCEN == '1' then
        <a href="shared_pseudocode.html#global_PhysicalCount" title="">PhysicalCount</a> = <a href="shared_pseudocode.html#global_PhysicalCount" title="">PhysicalCount</a> + ZeroExtend{88}(CNTSCR());
    else
        <a href="shared_pseudocode.html#global_PhysicalCount" title="">PhysicalCount</a>[87:24] = <a href="shared_pseudocode.html#global_PhysicalCount" title="">PhysicalCount</a>[87:24] + 1;
    end;
    if !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
        AArch32_CheckTimerConditions();
    else
        AArch64_CheckTimerConditions();
    end;
    TestEventCNTP(prev_physical_count, <a href="shared_pseudocode.html#func_PhysicalCountInt_0" title="">PhysicalCountInt</a>());
    TestEventCNTV(prev_physical_count, <a href="shared_pseudocode.html#func_PhysicalCountInt_0" title="">PhysicalCountInt</a>());
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.IsTimerConditionMet"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/IsTimerConditionMet</h3>
      <p class="pseudocode">// IsTimerConditionMet()
// =====================

func IsTimerConditionMet(offset : bits(64), compare_value : bits(64),
                         imask : bits(1), intid : InterruptID) =&gt; boolean
begin
    var condition_met : boolean;
    var level : <a href="shared_pseudocode.html#Signal" title="type Signal">Signal</a>;
    condition_met = (UInt(PhysicalCountInt() - offset) - UInt(compare_value)) &gt;= 0;
    level = if condition_met &amp;&amp; imask == '0' then HIGH else LOW;
    SetInterruptRequestLevel(intid, level);
    return condition_met;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.SetEventRegister"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/SetEventRegister</h3>
      <p class="pseudocode">// SetEventRegister()
// ==================
// Sets the Event Register of this PE

func SetEventRegister()
begin
    <a href="shared_pseudocode.html#global_EventRegister" title="">EventRegister</a> = '1';
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.TestEventCNTP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/TestEventCNTP</h3>
      <p class="pseudocode">// TestEventCNTP()
// ===============
// Generate Event stream from the physical counter

func TestEventCNTP(prev_physical_count : bits(64), current_physical_count : bits(64))
begin
    var offset : bits(64);
    var samplebit, previousbit : bit;
    var n : integer;
    if CNTHCTL_EL2().EVNTEN == '1' then
        n = UInt(CNTHCTL_EL2().EVNTI);
        if IsFeatureImplemented(FEAT_ECV) &amp;&amp; CNTHCTL_EL2().EVNTIS == '1' then
            n = n + 8;
        end;
        if (IsFeatureImplemented(FEAT_ECV_POFF) &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) &amp;&amp;
             CNTHCTL_EL2().ECV == '1' &amp;&amp; SCR_EL3().ECVEn == '1') then
            offset = CNTPOFF_EL2();
        else
            offset = Zeros{64};
        end;
        samplebit   = (current_physical_count - offset)[n];
        previousbit = (prev_physical_count - offset)[n];
        if CNTHCTL_EL2().EVNTDIR == '0' then
            if previousbit == '0' &amp;&amp; samplebit == '1' then SetEventRegister(); end;
        else
            if previousbit == '1' &amp;&amp; samplebit == '0' then SetEventRegister(); end;
        end;
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.TestEventCNTV"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/TestEventCNTV</h3>
      <p class="pseudocode">// TestEventCNTV()
// ===============
// Generate Event stream from the virtual counter

func TestEventCNTV(prev_physical_count : bits(64), current_physical_count : bits(64))
begin
    var offset : bits(64);
    var samplebit, previousbit : bit;
    var n : integer;
    if (<a href="shared_pseudocode.html#func_EffectiveHCR_EL2_E2H_0" title="">EffectiveHCR_EL2_E2H</a>()::<a href="shared_pseudocode.html#func_EffectiveTGE_0" title="">EffectiveTGE</a>() != '11' &amp;&amp;
          CNTKCTL_EL1().EVNTEN == '1') then
        n = UInt(CNTKCTL_EL1().EVNTI);
        if IsFeatureImplemented(FEAT_ECV) &amp;&amp; CNTKCTL_EL1().EVNTIS == '1' then
            n = n + 8;
        end;
        offset      = if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then CNTVOFF_EL2() else Zeros{64};

        samplebit   = (current_physical_count - offset)[n];
        previousbit = (prev_physical_count - offset)[n];
        if CNTKCTL_EL1().EVNTDIR == '0' then
            if previousbit == '0' &amp;&amp; samplebit == '1' then SetEventRegister(); end;
        else
            if previousbit == '1' &amp;&amp; samplebit == '0' then SetEventRegister(); end;
        end;
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.VirtualCounterTimer"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/VirtualCounterTimer</h3>
      <p class="pseudocode">// VirtualCounterTimer()
// =====================
// Returns the Counter-Timer Virtual Count value, the value is as read by CurrentEL to CNTVCT_EL0.

func <a id="func_VirtualCounterTimer_0"/>VirtualCounterTimer() =&gt; bits(64)
begin
    var cntvct : bits(64);

    if PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(PSTATE.EL) then
            cntvct = <a href="shared_pseudocode.html#func_PhysicalCountInt_0" title="">PhysicalCountInt</a>() - CNTVOFF_EL2();
        else
            cntvct = <a href="shared_pseudocode.html#func_PhysicalCountInt_0" title="">PhysicalCountInt</a>();
        end;
    else
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            cntvct = <a href="shared_pseudocode.html#func_PhysicalCountInt_0" title="">PhysicalCountInt</a>() - CNTVOFF_EL2();
        elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            cntvct = <a href="shared_pseudocode.html#func_PhysicalCountInt_0" title="">PhysicalCountInt</a>() - CNTVOFF();
        else
            cntvct = <a href="shared_pseudocode.html#func_PhysicalCountInt_0" title="">PhysicalCountInt</a>();
        end;
    end;

    return cntvct;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crc.BitReverse"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crc/BitReverse</h3>
      <p class="pseudocode">// BitReverse()
// ============

func <a id="func_BitReverse_2"/>BitReverse{N}(data : bits(N)) =&gt; bits(N)
begin
    var result : bits(N);
    for i = 0 to N-1 do
        result[(N-i)-1] = data[i];
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crc.Poly32Mod2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crc/Poly32Mod2</h3>
      <p class="pseudocode">// Poly32Mod2()
// ============

// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation

func <a id="func_Poly32Mod2_3"/>Poly32Mod2{N}(data_in : bits(N), poly : bits(32)) =&gt; bits(32)
begin
    assert N &gt; 32;
    var data : bits(N) = data_in;
    for i = N-1 downto 32 do
        if data[i] == '1' then
            data[i-1:0] = data[i-1:0] XOR (poly::Zeros{i-32});
        end;
    end;
    return data[31:0];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESInvMixColumns"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESInvMixColumns</h3>
      <p class="pseudocode">// AESInvMixColumns()
// ==================
// Transformation in the Inverse Cipher that is the inverse of AESMixColumns.

func <a id="func_AESInvMixColumns_1"/>AESInvMixColumns(op : bits (128)) =&gt; bits(128)
begin
    let in0 : bits(4*8) = op[ 96+:8] :: op[ 64+:8] :: op[ 32+:8] :: op[  0+:8];
    let in1 : bits(4*8) = op[104+:8] :: op[ 72+:8] :: op[ 40+:8] :: op[  8+:8];
    let in2 : bits(4*8) = op[112+:8] :: op[ 80+:8] :: op[ 48+:8] :: op[ 16+:8];
    let in3 : bits(4*8) = op[120+:8] :: op[ 88+:8] :: op[ 56+:8] :: op[ 24+:8];

    var out0 : bits(4*8);
    var out1 : bits(4*8);
    var out2 : bits(4*8);
    var out3 : bits(4*8);

    for c = 0 to 3 do
        out0[c*8+:8] =  (<a href="shared_pseudocode.html#func_FFmul0E_1" title="">FFmul0E</a>(in0[c*8+:8]) XOR <a href="shared_pseudocode.html#func_FFmul0B_1" title="">FFmul0B</a>(in1[c*8+:8]) XOR <a href="shared_pseudocode.html#func_FFmul0D_1" title="">FFmul0D</a>(in2[c*8+:8]) XOR
                         <a href="shared_pseudocode.html#func_FFmul09_1" title="">FFmul09</a>(in3[c*8+:8]));
        out1[c*8+:8] =  (<a href="shared_pseudocode.html#func_FFmul09_1" title="">FFmul09</a>(in0[c*8+:8]) XOR <a href="shared_pseudocode.html#func_FFmul0E_1" title="">FFmul0E</a>(in1[c*8+:8]) XOR <a href="shared_pseudocode.html#func_FFmul0B_1" title="">FFmul0B</a>(in2[c*8+:8]) XOR
                         <a href="shared_pseudocode.html#func_FFmul0D_1" title="">FFmul0D</a>(in3[c*8+:8]));
        out2[c*8+:8] =  (<a href="shared_pseudocode.html#func_FFmul0D_1" title="">FFmul0D</a>(in0[c*8+:8]) XOR <a href="shared_pseudocode.html#func_FFmul09_1" title="">FFmul09</a>(in1[c*8+:8]) XOR <a href="shared_pseudocode.html#func_FFmul0E_1" title="">FFmul0E</a>(in2[c*8+:8]) XOR
                         <a href="shared_pseudocode.html#func_FFmul0B_1" title="">FFmul0B</a>(in3[c*8+:8]));
        out3[c*8+:8] =  (<a href="shared_pseudocode.html#func_FFmul0B_1" title="">FFmul0B</a>(in0[c*8+:8]) XOR <a href="shared_pseudocode.html#func_FFmul0D_1" title="">FFmul0D</a>(in1[c*8+:8]) XOR <a href="shared_pseudocode.html#func_FFmul09_1" title="">FFmul09</a>(in2[c*8+:8]) XOR
                         <a href="shared_pseudocode.html#func_FFmul0E_1" title="">FFmul0E</a>(in3[c*8+:8]));
    end;

    return (
        out3[3*8+:8] :: out2[3*8+:8] :: out1[3*8+:8] :: out0[3*8+:8] ::
        out3[2*8+:8] :: out2[2*8+:8] :: out1[2*8+:8] :: out0[2*8+:8] ::
        out3[1*8+:8] :: out2[1*8+:8] :: out1[1*8+:8] :: out0[1*8+:8] ::
        out3[0*8+:8] :: out2[0*8+:8] :: out1[0*8+:8] :: out0[0*8+:8]
    );
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESInvShiftRows"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESInvShiftRows</h3>
      <p class="pseudocode">// AESInvShiftRows()
// =================
// Transformation in the Inverse Cipher that is inverse of AESShiftRows.

func <a id="func_AESInvShiftRows_1"/>AESInvShiftRows(op : bits(128)) =&gt; bits(128)
begin
    return (
        op[ 31: 24] :: op[ 55: 48] :: op[ 79: 72] :: op[103: 96] ::
        op[127:120] :: op[ 23: 16] :: op[ 47: 40] :: op[ 71: 64] ::
        op[ 95: 88] :: op[119:112] :: op[ 15:  8] :: op[ 39: 32] ::
        op[ 63: 56] :: op[ 87: 80] :: op[111:104] :: op[  7:  0]
    );
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESInvSubBytes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESInvSubBytes</h3>
      <p class="pseudocode">// AESInvSubBytes()
// ================
// Transformation in the Inverse Cipher that is the inverse of AESSubBytes.

func <a id="func_AESInvSubBytes_1"/>AESInvSubBytes(op : bits(128)) =&gt; bits(128)
begin
    // Inverse S-box values
    let GF2_inv : bits(16*16*8) = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x7d0c2155631469e126d677ba7e042b17[127:0] ::
        /*E*/ 0x619953833cbbebc8b0f52aae4d3be0a0[127:0] ::
        /*D*/ 0xef9cc9939f7ae52d0d4ab519a97f5160[127:0] ::
        /*C*/ 0x5fec8027591012b131c7078833a8dd1f[127:0] ::
        /*B*/ 0xf45acd78fec0db9a2079d2c64b3e56fc[127:0] ::
        /*A*/ 0x1bbe18aa0e62b76f89c5291d711af147[127:0] ::
        /*9*/ 0x6edf751ce837f9e28535ade72274ac96[127:0] ::
        /*8*/ 0x73e6b4f0cecff297eadc674f4111913a[127:0] ::
        /*7*/ 0x6b8a130103bdafc1020f3fca8f1e2cd0[127:0] ::
        /*6*/ 0x0645b3b80558e4f70ad3bc8c00abd890[127:0] ::
        /*5*/ 0x849d8da75746155edab9edfd5048706c[127:0] ::
        /*4*/ 0x92b6655dcc5ca4d41698688664f6f872[127:0] ::
        /*3*/ 0x25d18b6d49a25b76b224d92866a12e08[127:0] ::
        /*2*/ 0x4ec3fa420b954cee3d23c2a632947b54[127:0] ::
        /*1*/ 0xcbe9dec444438e3487ff2f9b8239e37c[127:0] ::
        /*0*/ 0xfbd7f3819ea340bf38a53630d56a0952[127:0]
    );
    var out : bits(128);
    for i = 0 to 15 do
        out[i*8+:8] = GF2_inv[UInt(op[i*8+:8])*8+:8];
    end;
    return out;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESMixColumns"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESMixColumns</h3>
      <p class="pseudocode">// AESMixColumns()
// ===============
// Transformation in the Cipher that takes all of the columns of the
// State and mixes their data (independently of one another) to
// produce new columns.

func <a id="func_AESMixColumns_1"/>AESMixColumns(op : bits (128)) =&gt; bits(128)
begin
    let in0 : bits(4*8) = op[ 96+:8] :: op[ 64+:8] :: op[ 32+:8] :: op[  0+:8];
    let in1 : bits(4*8) = op[104+:8] :: op[ 72+:8] :: op[ 40+:8] :: op[  8+:8];
    let in2 : bits(4*8) = op[112+:8] :: op[ 80+:8] :: op[ 48+:8] :: op[ 16+:8];
    let in3 : bits(4*8) = op[120+:8] :: op[ 88+:8] :: op[ 56+:8] :: op[ 24+:8];

    var out0 : bits(4*8);
    var out1 : bits(4*8);
    var out2 : bits(4*8);
    var out3 : bits(4*8);

    for c = 0 to 3 do
        out0[c*8+:8] = (<a href="shared_pseudocode.html#func_FFmul02_1" title="">FFmul02</a>(in0[c*8+:8]) XOR <a href="shared_pseudocode.html#func_FFmul03_1" title="">FFmul03</a>(in1[c*8+:8]) XOR
                                 in2[c*8+:8]  XOR         in3[c*8+:8]);
        out1[c*8+:8] = (<a href="shared_pseudocode.html#func_FFmul02_1" title="">FFmul02</a>(in1[c*8+:8])  XOR <a href="shared_pseudocode.html#func_FFmul03_1" title="">FFmul03</a>(in2[c*8+:8]) XOR
                                in3[c*8+:8]   XOR         in0[c*8+:8]);
        out2[c*8+:8] = (<a href="shared_pseudocode.html#func_FFmul02_1" title="">FFmul02</a>(in2[c*8+:8])  XOR <a href="shared_pseudocode.html#func_FFmul03_1" title="">FFmul03</a>(in3[c*8+:8]) XOR
                                in0[c*8+:8]   XOR         in1[c*8+:8]);
        out3[c*8+:8] = (<a href="shared_pseudocode.html#func_FFmul02_1" title="">FFmul02</a>(in3[c*8+:8])  XOR <a href="shared_pseudocode.html#func_FFmul03_1" title="">FFmul03</a>(in0[c*8+:8]) XOR
                                in1[c*8+:8]   XOR         in2[c*8+:8]);
    end;

    return (
        out3[3*8+:8] :: out2[3*8+:8] :: out1[3*8+:8] :: out0[3*8+:8] ::
        out3[2*8+:8] :: out2[2*8+:8] :: out1[2*8+:8] :: out0[2*8+:8] ::
        out3[1*8+:8] :: out2[1*8+:8] :: out1[1*8+:8] :: out0[1*8+:8] ::
        out3[0*8+:8] :: out2[0*8+:8] :: out1[0*8+:8] :: out0[0*8+:8]
    );
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESShiftRows"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESShiftRows</h3>
      <p class="pseudocode">// AESShiftRows()
// ==============
// Transformation in the Cipher that processes the State by cyclically
// shifting the last three rows of the State by different offsets.

func <a id="func_AESShiftRows_1"/>AESShiftRows(op : bits(128)) =&gt; bits(128)
begin
    return (
        op[ 95: 88] :: op[ 55: 48] :: op[ 15:  8] :: op[103: 96] ::
        op[ 63: 56] :: op[ 23: 16] :: op[111:104] :: op[ 71: 64] ::
        op[ 31: 24] :: op[119:112] :: op[ 79: 72] :: op[ 39: 32] ::
        op[127:120] :: op[ 87: 80] :: op[ 47: 40] :: op[  7:  0]
    );
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESSubBytes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESSubBytes</h3>
      <p class="pseudocode">// AESSubBytes()
// =============
// Transformation in the Cipher that processes the State using a nonlinear
// byte substitution table (S-box) that operates on each of the State bytes
// independently.

func <a id="func_AESSubBytes_1"/>AESSubBytes(op : bits(128)) =&gt; bits(128)
begin
    // S-box values
    let GF2 : bits(16*16*8) = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x16bb54b00f2d99416842e6bf0d89a18c[127:0] ::
        /*E*/ 0xdf2855cee9871e9b948ed9691198f8e1[127:0] ::
        /*D*/ 0x9e1dc186b95735610ef6034866b53e70[127:0] ::
        /*C*/ 0x8a8bbd4b1f74dde8c6b4a61c2e2578ba[127:0] ::
        /*B*/ 0x08ae7a65eaf4566ca94ed58d6d37c8e7[127:0] ::
        /*A*/ 0x79e4959162acd3c25c2406490a3a32e0[127:0] ::
        /*9*/ 0xdb0b5ede14b8ee4688902a22dc4f8160[127:0] ::
        /*8*/ 0x73195d643d7ea7c41744975fec130ccd[127:0] ::
        /*7*/ 0xd2f3ff1021dab6bcf5389d928f40a351[127:0] ::
        /*6*/ 0xa89f3c507f02f94585334d43fbaaefd0[127:0] ::
        /*5*/ 0xcf584c4a39becb6a5bb1fc20ed00d153[127:0] ::
        /*4*/ 0x842fe329b3d63b52a05a6e1b1a2c8309[127:0] ::
        /*3*/ 0x75b227ebe28012079a059618c323c704[127:0] ::
        /*2*/ 0x1531d871f1e5a534ccf73f362693fdb7[127:0] ::
        /*1*/ 0xc072a49cafa2d4adf04759fa7dc982ca[127:0] ::
        /*0*/ 0x76abd7fe2b670130c56f6bf27b777c63[127:0]
    );
    var out : bits(128);
    for i = 0 to 15 do
        out[i*8+:8] = GF2[UInt(op[i*8+:8])*8+:8];
    end;
    return out;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul02"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul02</h3>
      <p class="pseudocode">// FFmul02()
// =========

func <a id="func_FFmul02_1"/>FFmul02(b : bits(8)) =&gt; bits(8)
begin
    let FFmul_02 : bits(256*8) = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0xE5E7E1E3EDEFE9EBF5F7F1F3FDFFF9FB[127:0] ::
        /*E*/ 0xC5C7C1C3CDCFC9CBD5D7D1D3DDDFD9DB[127:0] ::
        /*D*/ 0xA5A7A1A3ADAFA9ABB5B7B1B3BDBFB9BB[127:0] ::
        /*C*/ 0x858781838D8F898B959791939D9F999B[127:0] ::
        /*B*/ 0x656761636D6F696B757771737D7F797B[127:0] ::
        /*A*/ 0x454741434D4F494B555751535D5F595B[127:0] ::
        /*9*/ 0x252721232D2F292B353731333D3F393B[127:0] ::
        /*8*/ 0x050701030D0F090B151711131D1F191B[127:0] ::
        /*7*/ 0xFEFCFAF8F6F4F2F0EEECEAE8E6E4E2E0[127:0] ::
        /*6*/ 0xDEDCDAD8D6D4D2D0CECCCAC8C6C4C2C0[127:0] ::
        /*5*/ 0xBEBCBAB8B6B4B2B0AEACAAA8A6A4A2A0[127:0] ::
        /*4*/ 0x9E9C9A98969492908E8C8A8886848280[127:0] ::
        /*3*/ 0x7E7C7A78767472706E6C6A6866646260[127:0] ::
        /*2*/ 0x5E5C5A58565452504E4C4A4846444240[127:0] ::
        /*1*/ 0x3E3C3A38363432302E2C2A2826242220[127:0] ::
        /*0*/ 0x1E1C1A18161412100E0C0A0806040200[127:0]
    );
    return FFmul_02[UInt(b)*8+:8];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul03"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul03</h3>
      <p class="pseudocode">// FFmul03()
// =========

func <a id="func_FFmul03_1"/>FFmul03(b : bits(8)) =&gt; bits(8)
begin
    let FFmul_03 : bits(256*8) = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x1A191C1F16151013020104070E0D080B[127:0] ::
        /*E*/ 0x2A292C2F26252023323134373E3D383B[127:0] ::
        /*D*/ 0x7A797C7F76757073626164676E6D686B[127:0] ::
        /*C*/ 0x4A494C4F46454043525154575E5D585B[127:0] ::
        /*B*/ 0xDAD9DCDFD6D5D0D3C2C1C4C7CECDC8CB[127:0] ::
        /*A*/ 0xEAE9ECEFE6E5E0E3F2F1F4F7FEFDF8FB[127:0] ::
        /*9*/ 0xBAB9BCBFB6B5B0B3A2A1A4A7AEADA8AB[127:0] ::
        /*8*/ 0x8A898C8F86858083929194979E9D989B[127:0] ::
        /*7*/ 0x818287848D8E8B88999A9F9C95969390[127:0] ::
        /*6*/ 0xB1B2B7B4BDBEBBB8A9AAAFACA5A6A3A0[127:0] ::
        /*5*/ 0xE1E2E7E4EDEEEBE8F9FAFFFCF5F6F3F0[127:0] ::
        /*4*/ 0xD1D2D7D4DDDEDBD8C9CACFCCC5C6C3C0[127:0] ::
        /*3*/ 0x414247444D4E4B48595A5F5C55565350[127:0] ::
        /*2*/ 0x717277747D7E7B78696A6F6C65666360[127:0] ::
        /*1*/ 0x212227242D2E2B28393A3F3C35363330[127:0] ::
        /*0*/ 0x111217141D1E1B18090A0F0C05060300[127:0]
    );
    return FFmul_03[UInt(b)*8+:8];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul09"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul09</h3>
      <p class="pseudocode">// FFmul09()
// =========

func <a id="func_FFmul09_1"/>FFmul09(b : bits(8)) =&gt; bits(8)
begin
    let FFmul_09 : bits(256*8) = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x464F545D626B70790E071C152A233831[127:0] ::
        /*E*/ 0xD6DFC4CDF2FBE0E99E978C85BAB3A8A1[127:0] ::
        /*D*/ 0x7D746F6659504B42353C272E1118030A[127:0] ::
        /*C*/ 0xEDE4FFF6C9C0DBD2A5ACB7BE8188939A[127:0] ::
        /*B*/ 0x3039222B141D060F78716A635C554E47[127:0] ::
        /*A*/ 0xA0A9B2BB848D969FE8E1FAF3CCC5DED7[127:0] ::
        /*9*/ 0x0B0219102F263D34434A5158676E757C[127:0] ::
        /*8*/ 0x9B928980BFB6ADA4D3DAC1C8F7FEE5EC[127:0] ::
        /*7*/ 0xAAA3B8B18E879C95E2EBF0F9C6CFD4DD[127:0] ::
        /*6*/ 0x3A3328211E170C05727B6069565F444D[127:0] ::
        /*5*/ 0x9198838AB5BCA7AED9D0CBC2FDF4EFE6[127:0] ::
        /*4*/ 0x0108131A252C373E49405B526D647F76[127:0] ::
        /*3*/ 0xDCD5CEC7F8F1EAE3949D868FB0B9A2AB[127:0] ::
        /*2*/ 0x4C455E5768617A73040D161F2029323B[127:0] ::
        /*1*/ 0xE7EEF5FCC3CAD1D8AFA6BDB48B829990[127:0] ::
        /*0*/ 0x777E656C535A41483F362D241B120900[127:0]
    );
    return FFmul_09[UInt(b)*8+:8];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul0B"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul0B</h3>
      <p class="pseudocode">// FFmul0B()
// =========

func <a id="func_FFmul0B_1"/>FFmul0B(b : bits(8)) =&gt; bits(8)
begin
    let FFmul_0B : bits(256*8) = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0xA3A8B5BE8F849992FBF0EDE6D7DCC1CA[127:0] ::
        /*E*/ 0x1318050E3F3429224B405D56676C717A[127:0] ::
        /*D*/ 0xD8D3CEC5F4FFE2E9808B969DACA7BAB1[127:0] ::
        /*C*/ 0x68637E75444F5259303B262D1C170A01[127:0] ::
        /*B*/ 0x555E434879726F640D061B10212A373C[127:0] ::
        /*A*/ 0xE5EEF3F8C9C2DFD4BDB6ABA0919A878C[127:0] ::
        /*9*/ 0x2E2538330209141F767D606B5A514C47[127:0] ::
        /*8*/ 0x9E958883B2B9A4AFC6CDD0DBEAE1FCF7[127:0] ::
        /*7*/ 0x545F424978736E650C071A11202B363D[127:0] ::
        /*6*/ 0xE4EFF2F9C8C3DED5BCB7AAA1909B868D[127:0] ::
        /*5*/ 0x2F2439320308151E777C616A5B504D46[127:0] ::
        /*4*/ 0x9F948982B3B8A5AEC7CCD1DAEBE0FDF6[127:0] ::
        /*3*/ 0xA2A9B4BF8E859893FAF1ECE7D6DDC0CB[127:0] ::
        /*2*/ 0x1219040F3E3528234A415C57666D707B[127:0] ::
        /*1*/ 0xD9D2CFC4F5FEE3E8818A979CADA6BBB0[127:0] ::
        /*0*/ 0x69627F74454E5358313A272C1D160B00[127:0]
    );
    return FFmul_0B[UInt(b)*8+:8];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul0D"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul0D</h3>
      <p class="pseudocode">// FFmul0D()
// =========

func <a id="func_FFmul0D_1"/>FFmul0D(b : bits(8)) =&gt; bits(8)
begin
    let FFmul_0D : bits(256*8) = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x979A8D80A3AEB9B4FFF2E5E8CBC6D1DC[127:0] ::
        /*E*/ 0x474A5D50737E69642F2235381B16010C[127:0] ::
        /*D*/ 0x2C21363B1815020F44495E53707D6A67[127:0] ::
        /*C*/ 0xFCF1E6EBC8C5D2DF94998E83A0ADBAB7[127:0] ::
        /*B*/ 0xFAF7E0EDCEC3D4D9929F8885A6ABBCB1[127:0] ::
        /*A*/ 0x2A27303D1E130409424F5855767B6C61[127:0] ::
        /*9*/ 0x414C5B5675786F622924333E1D10070A[127:0] ::
        /*8*/ 0x919C8B86A5A8BFB2F9F4E3EECDC0D7DA[127:0] ::
        /*7*/ 0x4D40575A7974636E25283F32111C0B06[127:0] ::
        /*6*/ 0x9D90878AA9A4B3BEF5F8EFE2C1CCDBD6[127:0] ::
        /*5*/ 0xF6FBECE1C2CFD8D59E938489AAA7B0BD[127:0] ::
        /*4*/ 0x262B3C31121F08054E4354597A77606D[127:0] ::
        /*3*/ 0x202D3A3714190E034845525F7C71666B[127:0] ::
        /*2*/ 0xF0FDEAE7C4C9DED39895828FACA1B6BB[127:0] ::
        /*1*/ 0x9B96818CAFA2B5B8F3FEE9E4C7CADDD0[127:0] ::
        /*0*/ 0x4B46515C7F726568232E3934171A0D00[127:0]
    );
    return FFmul_0D[UInt(b)*8+:8];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul0E"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul0E</h3>
      <p class="pseudocode">// FFmul0E()
// =========

func <a id="func_FFmul0E_1"/>FFmul0E(b : bits(8)) =&gt; bits(8)
begin
    let FFmul_0E : bits(256*8) = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x8D83919FB5BBA9A7FDF3E1EFC5CBD9D7[127:0] ::
        /*E*/ 0x6D63717F555B49471D13010F252B3937[127:0] ::
        /*D*/ 0x56584A446E60727C26283A341E10020C[127:0] ::
        /*C*/ 0xB6B8AAA48E80929CC6C8DAD4FEF0E2EC[127:0] ::
        /*B*/ 0x202E3C321816040A505E4C426866747A[127:0] ::
        /*A*/ 0xC0CEDCD2F8F6E4EAB0BEACA28886949A[127:0] ::
        /*9*/ 0xFBF5E7E9C3CDDFD18B859799B3BDAFA1[127:0] ::
        /*8*/ 0x1B150709232D3F316B657779535D4F41[127:0] ::
        /*7*/ 0xCCC2D0DEF4FAE8E6BCB2A0AE848A9896[127:0] ::
        /*6*/ 0x2C22303E141A08065C52404E646A7876[127:0] ::
        /*5*/ 0x17190B052F21333D67697B755F51434D[127:0] ::
        /*4*/ 0xF7F9EBE5CFC1D3DD87899B95BFB1A3AD[127:0] ::
        /*3*/ 0x616F7D735957454B111F0D032927353B[127:0] ::
        /*2*/ 0x818F9D93B9B7A5ABF1FFEDE3C9C7D5DB[127:0] ::
        /*1*/ 0xBAB4A6A8828C9E90CAC4D6D8F2FCEEE0[127:0] ::
        /*0*/ 0x5A544648626C7E702A243638121C0E00[127:0]
    );
    return FFmul_0E[UInt(b)*8+:8];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHA256hash"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHA256hash</h3>
      <p class="pseudocode">// SHA256hash()
// ============

func <a id="func_SHA256hash_4"/>SHA256hash(x_in : bits (128), y_in : bits(128), w : bits(128), part1 : boolean) =&gt; bits(128)
begin
    var chs, maj, t : bits(32);
    var x : bits(128) = x_in;
    var y : bits(128) = y_in;

    for e = 0 to 3 do
        chs = <a href="shared_pseudocode.html#func_SHAchoose_3" title="">SHAchoose</a>(y[31:0], y[63:32], y[95:64]);
        maj = <a href="shared_pseudocode.html#func_SHAmajority_4" title="">SHAmajority</a>{32}(x[31:0], x[63:32], x[95:64]);
        t   = y[127:96] + <a href="shared_pseudocode.html#func_SHAhashSIGMA1_1" title="">SHAhashSIGMA1</a>(y[31:0]) + chs + w[e*:32];
        x[127:96] = t + x[127:96];
        y[127:96] = t + <a href="shared_pseudocode.html#func_SHAhashSIGMA0_1" title="">SHAhashSIGMA0</a>(x[31:0]) + maj;
        let yx : bits(256) = ROL(y :: x, 32);
        (y, x) = (yx[128+:128], yx[0+:128]);
    end;
    return (if part1 then x else y);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAchoose"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAchoose</h3>
      <p class="pseudocode">// SHAchoose()
// ===========

func <a id="func_SHAchoose_3"/>SHAchoose(x : bits(32), y : bits(32), z : bits(32)) =&gt; bits(32)
begin
    return (((y XOR z) AND x) XOR z);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAhashSIGMA0"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAhashSIGMA0</h3>
      <p class="pseudocode">// SHAhashSIGMA0()
// ===============

func <a id="func_SHAhashSIGMA0_1"/>SHAhashSIGMA0(x : bits(32)) =&gt; bits(32)
begin
    return ROR(x, 2) XOR ROR(x, 13) XOR ROR(x, 22);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAhashSIGMA1"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAhashSIGMA1</h3>
      <p class="pseudocode">// SHAhashSIGMA1()
// ===============

func <a id="func_SHAhashSIGMA1_1"/>SHAhashSIGMA1(x : bits(32)) =&gt; bits(32)
begin
    return ROR(x, 6) XOR ROR(x, 11) XOR ROR(x, 25);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAmajority"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAmajority</h3>
      <p class="pseudocode">// SHAmajority()
// =============

func <a id="func_SHAmajority_4"/>SHAmajority{N}(x : bits(N), y : bits(N), z : bits(N)) =&gt; bits(N)
begin
    assert N IN {32, 64};
    return ((x AND y) OR ((x OR y) AND z));
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAparity"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAparity</h3>
      <p class="pseudocode">// SHAparity()
// ===========

func <a id="func_SHAparity_3"/>SHAparity(x : bits(32), y : bits(32), z : bits(32)) =&gt; bits(32)
begin
    return (x XOR y XOR z);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.Sbox"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/Sbox</h3>
      <p class="pseudocode">// Sbox()
// ======
// Used in SM4E crypto instruction

func <a id="func_Sbox_1"/>Sbox(sboxin : bits(8)) =&gt; bits(8)
begin
    var sboxout : bits(8);
    let sboxstring : bits(2048) = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0xd690e9fecce13db716b614c228fb2c05[127:0] ::
        /*E*/ 0x2b679a762abe04c3aa44132649860699[127:0] ::
        /*D*/ 0x9c4250f491ef987a33540b43edcfac62[127:0] ::
        /*C*/ 0xe4b31ca9c908e89580df94fa758f3fa6[127:0] ::
        /*B*/ 0x4707a7fcf37317ba83593c19e6854fa8[127:0] ::
        /*A*/ 0x686b81b27164da8bf8eb0f4b70569d35[127:0] ::
        /*9*/ 0x1e240e5e6358d1a225227c3b01217887[127:0] ::
        /*8*/ 0xd40046579fd327524c3602e7a0c4c89e[127:0] ::
        /*7*/ 0xeabf8ad240c738b5a3f7f2cef96115a1[127:0] ::
        /*6*/ 0xe0ae5da49b341a55ad933230f58cb1e3[127:0] ::
        /*5*/ 0x1df6e22e8266ca60c02923ab0d534e6f[127:0] ::
        /*4*/ 0xd5db3745defd8e2f03ff6a726d6c5b51[127:0] ::
        /*3*/ 0x8d1baf92bbddbc7f11d95c411f105ad8[127:0] ::
        /*2*/ 0x0ac13188a5cd7bbd2d74d012b8e5b4b0[127:0] ::
        /*1*/ 0x8969974a0c96777e65b9f109c56ec684[127:0] ::
        /*0*/ 0x18f07dec3adc4d2079ee5f3ed7cb3948[127:0]
    );
    let sboxindex : integer = 255 - UInt(sboxin);
    sboxout = sboxstring[sboxindex*:8];
    return sboxout;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.decode.DecodeType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/decode/DecodeType</h3>
      <p class="pseudocode">// DecodeType
// ==========

type <a id="type_DecodeType"/>DecodeType of enumeration {
    <a id="enum_Decode_UNDEF"/>Decode_UNDEF,
    <a id="enum_Decode_NOP"/>Decode_NOP,
    <a id="enum_Decode_OK"/>Decode_OK
};</p>
    </div>
    <div class="ps"><a id="shared.functions.decode.EndOfDecode"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/decode/EndOfDecode</h3>
      <p class="pseudocode">// EndOfDecode()
// =============
// This function is invoked to end the Decode phase and performs Branch target Checks
// before taking any UNDEFINED exceptions, NOPs, or continuing to execute.

func EndOfDecode(reason : <a href="shared_pseudocode.html#type_DecodeType" title="">DecodeType</a>)
begin
    if IsFeatureImplemented(FEAT_BTI) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        BranchTargetCheck();
    end;
    case reason of
        when <a href="shared_pseudocode.html#enum_Decode_NOP" title="">Decode_NOP</a>   =&gt; ExecuteAsNOP();
        when <a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a> =&gt; Undefined();
        when <a href="shared_pseudocode.html#enum_Decode_OK" title="">Decode_OK</a>    =&gt; pass;          // Continue to execute.
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ClearExclusiveByAddress"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ClearExclusiveByAddress</h3>
      <p class="pseudocode">// ClearExclusiveByAddress()
// =========================
// Clear the global Exclusives monitors for all PEs EXCEPT processorid if they
// record any part of the physical address region of size bytes starting at paddress.
// It is IMPLEMENTATION DEFINED whether the global Exclusives monitor for processorid
// is also cleared if it records any part of the address region.

impdef func ClearExclusiveByAddress(paddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>,
                                    processorid : integer,
                                    size : integer)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ClearExclusiveLocal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ClearExclusiveLocal</h3>
      <p class="pseudocode">// ClearExclusiveLocal()
// =====================
// Clear the local Exclusives monitor for the specified processorid.

impdef func ClearExclusiveLocal(processorid : integer)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ExclusiveMonitorsStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ExclusiveMonitorsStatus</h3>
      <p class="pseudocode">// ExclusiveMonitorsStatus()
// =========================
// Returns '0' to indicate success if the last memory write by this PE was to
// the same physical address region endorsed by ExclusiveMonitorsPass().
// Returns '1' to indicate failure if address translation resulted in a different
// physical address.

impdef func <a id="func_ExclusiveMonitorsStatus_0"/>ExclusiveMonitorsStatus() =&gt; bit
begin
    return '0';
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.IsExclusiveGlobal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/IsExclusiveGlobal</h3>
      <p class="pseudocode">// IsExclusiveGlobal()
// ===================
// Return TRUE if the global Exclusives monitor for processorid includes all of
// the physical address region of size bytes starting at paddress.

impdef func <a id="func_IsExclusiveGlobal_3"/>IsExclusiveGlobal(paddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>,
                              processorid : integer,
                              size : integer) =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.IsExclusiveLocal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/IsExclusiveLocal</h3>
      <p class="pseudocode">// IsExclusiveLocal()
// ==================
// Return TRUE if the local Exclusives monitor for processorid includes all of
// the physical address region of size bytes starting at paddress.

impdef func <a id="func_IsExclusiveLocal_3"/>IsExclusiveLocal(paddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>, processorid : integer,
                             size : integer) =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.MarkExclusiveGlobal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/MarkExclusiveGlobal</h3>
      <p class="pseudocode">// MarkExclusiveGlobal()
// =====================
// Record the physical address region of size bytes starting at paddress in
// the global Exclusives monitor for processorid.

impdef func MarkExclusiveGlobal(paddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>,
                                processorid : integer,
                                size : integer)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.MarkExclusiveLocal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/MarkExclusiveLocal</h3>
      <p class="pseudocode">// MarkExclusiveLocal()
// ====================
// Record the physical address region of size bytes starting at paddress in
// the local Exclusives monitor for processorid.

impdef func MarkExclusiveLocal(paddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>, processorid : integer, size : integer)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ProcessorID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ProcessorID</h3>
      <p class="pseudocode">// ProcessorID()
// =============
// Return the ID of the currently executing PE.

impdef func <a id="func_ProcessorID_0"/>ProcessorID() =&gt; integer
begin
    if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
        return UInt(MPIDR_EL1().Aff3 :: MPIDR_EL1().Aff2 :: MPIDR_EL1().Aff1 :: MPIDR_EL1().Aff0);
    else
        return UInt(MPIDR().Aff2 :: MPIDR().Aff1 :: MPIDR().Aff0);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSoftwareLock"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSoftwareLock</h3>
      <p class="pseudocode">// HaveSoftwareLock()
// ==================
// Returns TRUE if Software Lock is implemented.

func <a id="func_HaveSoftwareLock_1"/>HaveSoftwareLock(component : <a href="shared_pseudocode.html#type_Component" title="">Component</a>) =&gt; boolean
begin
    if IsFeatureImplemented(FEAT_Debugv8p4) then
        return FALSE;
    end;
    if IsFeatureImplemented(FEAT_DoPD) &amp;&amp; component != <a href="shared_pseudocode.html#enum_Component_CTI" title="">Component_CTI</a> then
        return FALSE;
    end;
    case component of
        when <a href="shared_pseudocode.html#enum_Component_ETE" title="">Component_ETE</a> =&gt;
            return ImpDefBool("ETE has Software Lock");
        when <a href="shared_pseudocode.html#enum_Component_Debug" title="">Component_Debug</a> =&gt;
            return ImpDefBool("Debug has Software Lock");
        when <a href="shared_pseudocode.html#enum_Component_PMU" title="">Component_PMU</a> =&gt;
            return ImpDefBool("PMU has Software Lock");
        when <a href="shared_pseudocode.html#enum_Component_CTI" title="">Component_CTI</a> =&gt;
            return ImpDefBool("CTI has Software Lock");
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveTraceExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveTraceExt</h3>
      <p class="pseudocode">// HaveTraceExt()
// ==============
// Returns TRUE if Trace functionality as described by the Trace Architecture
// is implemented.

func <a id="func_HaveTraceExt_0"/>HaveTraceExt() =&gt; boolean
begin
    return IsFeatureImplemented(FEAT_ETE) || IsFeatureImplemented(FEAT_ETMv4);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.InsertIESBBeforeException"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/InsertIESBBeforeException</h3>
      <p class="pseudocode">// InsertIESBBeforeException()
// ===========================
// Returns an implementation defined choice whether to insert an implicit error synchronization
// barrier before exception.
// If SCTLR_ELx.IESB is 1 when an exception is generated to ELx, any pending Unrecoverable
// SError interrupt must be taken before executing any instructions in the exception handler.
// However, this can be before the branch to the exception handler is made.

func <a id="func_InsertIESBBeforeException_1"/>InsertIESBBeforeException(el : bits(2)) =&gt; boolean
begin
    return (IsFeatureImplemented(FEAT_IESB) &amp;&amp; ImpDefBool(
            "Has Implicit Error Synchronization Barrier before Exception"));
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ActionRequired"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ActionRequired</h3>
      <p class="pseudocode">// ActionRequired()
// ================
// Return an implementation specific value:
// returns TRUE if action is required, FALSE otherwise.

impdef func <a id="func_ActionRequired_0"/>ActionRequired() =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ClearPendingDelegatedSError"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ClearPendingDelegatedSError</h3>
      <p class="pseudocode">// ClearPendingDelegatedSError()
// =============================
// Clear a pending delegated SError interrupt.

func ClearPendingDelegatedSError()
begin
    assert IsFeatureImplemented(FEAT_E3DSE);
    SCR_EL3().DSE = '0';
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ClearPendingPhysicalSError"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ClearPendingPhysicalSError</h3>
      <p class="pseudocode">// ClearPendingPhysicalSError()
// ============================
// Clear a pending physical SError interrupt.

impdef func ClearPendingPhysicalSError()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ClearPendingVirtualSError"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ClearPendingVirtualSError</h3>
      <p class="pseudocode">// ClearPendingVirtualSError()
// ===========================
// Clear a pending virtual SError interrupt.

func ClearPendingVirtualSError()
begin
    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        HCR().VA      = '0';
    else
        HCR_EL2().VSE = '0';
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ErrorIsContained"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ErrorIsContained</h3>
      <p class="pseudocode">// ErrorIsContained()
// ==================
// Return an implementation specific value:
// TRUE if Error is contained by the PE, FALSE otherwise.

impdef func <a id="func_ErrorIsContained_0"/>ErrorIsContained() =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ErrorIsSynchronized"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ErrorIsSynchronized</h3>
      <p class="pseudocode">// ErrorIsSynchronized()
// =====================
// Return an implementation specific value:
// returns TRUE if Error is synchronized by any synchronization event
// FALSE otherwise.

impdef func <a id="func_ErrorIsSynchronized_0"/>ErrorIsSynchronized() =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ExtAbortToAArch64"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ExtAbortToAArch64</h3>
      <p class="pseudocode">// ExtAbortToAArch64()
// ===================
// Returns TRUE if synchronous exception is being taken to an Exception level using AArch64_

func <a id="func_ExtAbortToAArch64_1"/>ExtAbortToAArch64(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; boolean
begin
    assert <a href="shared_pseudocode.html#func_IsExternalSyncAbort_1" title="">IsExternalSyncAbort</a>(fault.statuscode);

    return !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#func_SyncExternalAbortTarget_1" title="">SyncExternalAbortTarget</a>(fault));
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ExternalAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ExternalAbort</h3>
      <p class="pseudocode">// ExternalAbort()
// ===============

func ExternalAbort(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) recurselimit 1
begin
    if <a href="shared_pseudocode.html#func_IsExternalSyncAbort_1" title="">IsExternalSyncAbort</a>(fault) then
        if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
            AArch32_Abort(fault);
        else
            AArch64_Abort(fault);
        end;

    else
        PendSErrorInterrupt(fault);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ExternalFault"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ExternalFault</h3>
      <p class="pseudocode">// ExternalFault()
// ===============
// Return a fault recording indicating a fault for a Synchronous/Asynchronous External abort.

func <a id="func_ExternalFault_5"/>ExternalFault(memretstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>, iswrite : boolean,
                   memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, size : integer,
                   accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    assert (memretstatus.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_SyncExternal" title="">Fault_SyncExternal</a>, <a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a>} ||
           (!IsFeatureImplemented(FEAT_RAS) &amp;&amp; memretstatus.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_SyncParity" title="">Fault_SyncParity</a>,
                                                                           <a href="shared_pseudocode.html#enum_Fault_AsyncParity" title="">Fault_AsyncParity</a>}));

    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, memaddrdesc.vaddress);
    fault.statuscode = memretstatus.statuscode;
    fault.write      = iswrite;
    fault.extflag    = memretstatus.extflag;
    // It is implementation specific whether External aborts signaled
    // in-band synchronously are taken synchronously or asynchronously
    if (<a href="shared_pseudocode.html#func_IsExternalSyncAbort_1" title="">IsExternalSyncAbort</a>(fault) &amp;&amp;
          ((IsFeatureImplemented(FEAT_RASv2) &amp;&amp; <a href="shared_pseudocode.html#func_ExtAbortToAArch64_1" title="">ExtAbortToAArch64</a>(fault) &amp;&amp;
            <a href="shared_pseudocode.html#func_PEErrorState_1" title="">PEErrorState</a>(fault) IN {<a href="shared_pseudocode.html#enum_ErrorState_UC" title="">ErrorState_UC</a>, <a href="shared_pseudocode.html#enum_ErrorState_UEU" title="">ErrorState_UEU</a>}) ||
           !<a href="shared_pseudocode.html#func_IsExternalAbortTakenSynchronously_5" title="">IsExternalAbortTakenSynchronously</a>(memretstatus, iswrite, memaddrdesc,
                                              size, accdesc))) then
        if fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_SyncParity" title="">Fault_SyncParity</a> then
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AsyncParity" title="">Fault_AsyncParity</a>;
        else
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a>;
        end;
    end;

    if IsFeatureImplemented(FEAT_RAS) then
        fault.merrorstate = memretstatus.merrorstate;
    end;
    fault.paddress = memaddrdesc.paddress;
    return fault;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.FaultIsCorrected"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/FaultIsCorrected</h3>
      <p class="pseudocode">// FaultIsCorrected()
// ==================
// Return an implementation specific value:
// TRUE if fault is corrected by the PE, FALSE otherwise.

readonly impdef func <a id="func_FaultIsCorrected_0"/>FaultIsCorrected() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.GetPendingPhysicalSError"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/GetPendingPhysicalSError</h3>
      <p class="pseudocode">// GetPendingPhysicalSError()
// ==========================
// Returns the FaultRecord containing details of pending Physical SError
// interrupt.

impdef func <a id="func_GetPendingPhysicalSError_0"/>GetPendingPhysicalSError() =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    return ARBITRARY : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.HandleExternalAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/HandleExternalAbort</h3>
      <p class="pseudocode">// HandleExternalAbort()
// =====================
// Takes a Synchronous/Asynchronous abort based on fault.

func HandleExternalAbort(memretstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>, iswrite : boolean,
                         memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, size : integer,
                         accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>)
begin
    assert (memretstatus.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_SyncExternal" title="">Fault_SyncExternal</a>, <a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a>} ||
           (!IsFeatureImplemented(FEAT_RAS) &amp;&amp; memretstatus.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_SyncParity" title="">Fault_SyncParity</a>,
                                                                           <a href="shared_pseudocode.html#enum_Fault_AsyncParity" title="">Fault_AsyncParity</a>}));

    let fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_ExternalFault_5" title="">ExternalFault</a>(memretstatus, iswrite, memaddrdesc, size, accdesc);
    ExternalAbort(fault);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.HandleExternalReadAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/HandleExternalReadAbort</h3>
      <p class="pseudocode">// HandleExternalReadAbort()
// =========================
// Wrapper function for HandleExternalAbort function in case of an External
// Abort on memory read.

func HandleExternalReadAbort(memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>, memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                             size : integer, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>)
begin
    let iswrite : boolean = FALSE;
    HandleExternalAbort(memstatus, iswrite, memaddrdesc, size, accdesc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.HandleExternalTTWAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/HandleExternalTTWAbort</h3>
      <p class="pseudocode">// HandleExternalTTWAbort()
// ========================
// Take Asynchronous abort or update FaultRecord for Translation Table Walk
// based on PhysMemRetStatus.

func <a id="func_HandleExternalTTWAbort_6"/>HandleExternalTTWAbort(memretstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>, iswrite : boolean,
                            memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                            accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, size : integer,
                            input_fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    var output_fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = input_fault;
    output_fault.extflag    = memretstatus.extflag;
    output_fault.statuscode = memretstatus.statuscode;
    if (<a href="shared_pseudocode.html#func_IsExternalSyncAbort_1" title="">IsExternalSyncAbort</a>(output_fault) &amp;&amp;
          ((IsFeatureImplemented(FEAT_RASv2) &amp;&amp; <a href="shared_pseudocode.html#func_ExtAbortToAArch64_1" title="">ExtAbortToAArch64</a>(output_fault) &amp;&amp;
            <a href="shared_pseudocode.html#func_PEErrorState_1" title="">PEErrorState</a>(output_fault) IN {<a href="shared_pseudocode.html#enum_ErrorState_UC" title="">ErrorState_UC</a>, <a href="shared_pseudocode.html#enum_ErrorState_UEU" title="">ErrorState_UEU</a>}) ||
           !<a href="shared_pseudocode.html#func_IsExternalAbortTakenSynchronously_5" title="">IsExternalAbortTakenSynchronously</a>(memretstatus, iswrite, memaddrdesc,
                                              size, accdesc))) then
        if output_fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_SyncParity" title="">Fault_SyncParity</a> then
            output_fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AsyncParity" title="">Fault_AsyncParity</a>;
        else
            output_fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a>;
        end;
    end;

    // If a synchronous fault is on a translation table walk, then update the fault type.
    if <a href="shared_pseudocode.html#func_IsExternalSyncAbort_1" title="">IsExternalSyncAbort</a>(output_fault) then
        if output_fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_SyncParity" title="">Fault_SyncParity</a> then
            output_fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a>;
        else
            output_fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_SyncExternalOnWalk" title="">Fault_SyncExternalOnWalk</a>;
        end;
    end;
    if IsFeatureImplemented(FEAT_RAS) then
        output_fault.merrorstate = memretstatus.merrorstate;
    end;
    if !<a href="shared_pseudocode.html#func_IsExternalSyncAbort_1" title="">IsExternalSyncAbort</a>(output_fault) then
        PendSErrorInterrupt(output_fault);
        output_fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
    end;
    output_fault.paddress = memaddrdesc.paddress;
    return output_fault;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.HandleExternalWriteAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/HandleExternalWriteAbort</h3>
      <p class="pseudocode">// HandleExternalWriteAbort()
// ==========================
// Wrapper function for HandleExternalAbort function in case of an External
// Abort on memory write.

func HandleExternalWriteAbort(memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>, memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                              size : integer, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>)
begin
    let iswrite : boolean = TRUE;
    HandleExternalAbort(memstatus, iswrite, memaddrdesc, size, accdesc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.IsDelegatedSErrorPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/IsDelegatedSErrorPending</h3>
      <p class="pseudocode">// IsDelegatedSErrorPending()
// ==========================
// Return TRUE if a delegated SError interrupt is pending.

func <a id="func_IsDelegatedSErrorPending_0"/>IsDelegatedSErrorPending() =&gt; boolean
begin
    return SCR_EL3().DSE == '1';
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.IsExternalAbortTakenSynchronously"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/IsExternalAbortTakenSynchronously</h3>
      <p class="pseudocode">// IsExternalAbortTakenSynchronously()
// ===================================
// Return an implementation specific value:
// TRUE if the fault returned for the access can be taken synchronously,
// FALSE otherwise.
//
// This might vary between accesses, for example depending on the error type
// or memory type being accessed.
// External aborts on data accesses and translation table walks on data accesses
// can be either synchronous or asynchronous.
//
// When FEAT_DoubleFault is not implemented, External aborts on instruction
// fetches and translation table walks on instruction fetches can be either
// synchronous or asynchronous.
// When FEAT_DoubleFault is implemented, all External abort exceptions on
// instruction fetches and translation table walks on instruction fetches
// must be synchronous.

impdef func <a id="func_IsExternalAbortTakenSynchronously_5"/>IsExternalAbortTakenSynchronously(memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>, iswrite : boolean,
                                              desc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, size : integer,
                                              accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.IsPhysicalSErrorPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/IsPhysicalSErrorPending</h3>
      <p class="pseudocode">// IsPhysicalSErrorPending()
// =========================
// Returns TRUE if a physical SError interrupt is pending.

impdef func <a id="func_IsPhysicalSErrorPending_0"/>IsPhysicalSErrorPending() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.IsSErrorEdgeTriggered"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/IsSErrorEdgeTriggered</h3>
      <p class="pseudocode">// IsSErrorEdgeTriggered()
// =======================
// Returns TRUE if the physical SError interrupt is edge-triggered
// and FALSE otherwise.

func <a id="func_IsSErrorEdgeTriggered_0"/>IsSErrorEdgeTriggered() =&gt; boolean
begin
    if IsFeatureImplemented(FEAT_DoubleFault) then
        return TRUE;
    else
        return ImpDefBool("Edge-triggered SError");
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.IsSynchronizablePhysicalSErrorPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/IsSynchronizablePhysicalSErrorPending</h3>
      <p class="pseudocode">// IsSynchronizablePhysicalSErrorPending()
// =======================================
// Returns TRUE if a synchronizable physical SError interrupt is pending.

impdef func <a id="func_IsSynchronizablePhysicalSErrorPending_0"/>IsSynchronizablePhysicalSErrorPending() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.IsVirtualSErrorPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/IsVirtualSErrorPending</h3>
      <p class="pseudocode">// IsVirtualSErrorPending()
// ========================
// Return TRUE if a virtual SError interrupt is pending.

func <a id="func_IsVirtualSErrorPending_0"/>IsVirtualSErrorPending() =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        return HCR().VA == '1';
    else
        return HCR_EL2().VSE == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.PEErrorState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/PEErrorState</h3>
      <p class="pseudocode">// PEErrorState()
// ==============
// Returns the error state of the PE on taking an error exception:
// The PE error state reported to software through the exception syndrome also
// depends on how the exception is taken, and so might differ from the value
// returned from this function.

func <a id="func_PEErrorState_1"/>PEErrorState(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; <a href="shared_pseudocode.html#type_ErrorState" title="">ErrorState</a>
begin
    assert !<a href="shared_pseudocode.html#func_FaultIsCorrected_0" title="">FaultIsCorrected</a>();
    if (!<a href="shared_pseudocode.html#func_ErrorIsContained_0" title="">ErrorIsContained</a>() ||
        (!<a href="shared_pseudocode.html#func_ErrorIsSynchronized_0" title="">ErrorIsSynchronized</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_StateIsRecoverable_0" title="">StateIsRecoverable</a>()) ||
         <a href="shared_pseudocode.html#func_ReportErrorAsUC_0" title="">ReportErrorAsUC</a>()) then
        return <a href="shared_pseudocode.html#enum_ErrorState_UC" title="">ErrorState_UC</a>;
    end;

    if !<a href="shared_pseudocode.html#func_StateIsRecoverable_0" title="">StateIsRecoverable</a>() || <a href="shared_pseudocode.html#func_ReportErrorAsUEU_0" title="">ReportErrorAsUEU</a>() then
        return <a href="shared_pseudocode.html#enum_ErrorState_UEU" title="">ErrorState_UEU</a>;
    end;

    if <a href="shared_pseudocode.html#func_ActionRequired_0" title="">ActionRequired</a>() || <a href="shared_pseudocode.html#func_ReportErrorAsUER_0" title="">ReportErrorAsUER</a>() then
        return <a href="shared_pseudocode.html#enum_ErrorState_UER" title="">ErrorState_UER</a>;
    end;

    return <a href="shared_pseudocode.html#enum_ErrorState_UEO" title="">ErrorState_UEO</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.PendSErrorInterrupt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/PendSErrorInterrupt</h3>
      <p class="pseudocode">// PendSErrorInterrupt()
// =====================
// Pend the SError Interrupt.

impdef func PendSErrorInterrupt(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ReportErrorAsIMPDEF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ReportErrorAsIMPDEF</h3>
      <p class="pseudocode">// ReportErrorAsIMPDEF()
// =====================
// Return an implementation specific value:
// returns TRUE if Error is IMPDEF, FALSE otherwise.

impdef func <a id="func_ReportErrorAsIMPDEF_0"/>ReportErrorAsIMPDEF() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ReportErrorAsUC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ReportErrorAsUC</h3>
      <p class="pseudocode">// ReportErrorAsUC()
// =================
// Return an implementation specific value:
// returns TRUE if Error is Uncontainable, FALSE otherwise.

impdef func <a id="func_ReportErrorAsUC_0"/>ReportErrorAsUC() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ReportErrorAsUER"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ReportErrorAsUER</h3>
      <p class="pseudocode">// ReportErrorAsUER()
// ==================
// Return an implementation specific value:
// returns TRUE if Error is Recoverable, FALSE otherwise.

impdef func <a id="func_ReportErrorAsUER_0"/>ReportErrorAsUER() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ReportErrorAsUEU"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ReportErrorAsUEU</h3>
      <p class="pseudocode">// ReportErrorAsUEU()
// ==================
// Return an implementation specific value:
// returns TRUE if Error is Unrecoverable, FALSE otherwise.

impdef func <a id="func_ReportErrorAsUEU_0"/>ReportErrorAsUEU() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.ReportErrorAsUncategorized"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/ReportErrorAsUncategorized</h3>
      <p class="pseudocode">// ReportErrorAsUncategorized()
// ============================
// Return an implementation specific value:
// returns TRUE if Error is uncategorized, FALSE otherwise.

impdef func <a id="func_ReportErrorAsUncategorized_0"/>ReportErrorAsUncategorized() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.StateIsRecoverable"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/StateIsRecoverable</h3>
      <p class="pseudocode">// StateIsRecoverable()
// ====================
// Return an implementation specific value:
// returns TRUE is PE State is unrecoverable else FALSE.

impdef func <a id="func_StateIsRecoverable_0"/>StateIsRecoverable() =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFAdd</h3>
      <p class="pseudocode">// BFAdd()
// =======
// Non-widening BFloat16 addition used by SVE2 instructions.

func <a id="func_BFAdd_4"/>BFAdd{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_BFAdd_5" title="">BFAdd</a>{N}(op1, op2, fpcr, fpexc);
end;

// BFAdd()
// =======
// Non-widening BFloat16 addition following computational behaviors
// corresponding to instructions that read and write BFloat16 values.
// Calculates op1 + op2.
// The 'fpcr' argument supplies the FPCR control bits.

func <a id="func_BFAdd_5"/>BFAdd{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(N)
begin
    assert N == 16;
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
    var done : boolean;
    var result : bits(2*N);

    let op1_s : bits(2*N) = op1 :: Zeros{N};
    let op2_s : bits(2*N) = op2 :: Zeros{N};
    let (type1,sign1,value1) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{2*N}(op1_s, fpcr, fpexc);
    let (type2,sign2,value2) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{2*N}(op2_s, fpcr, fpexc);

    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_7" title="">FPProcessNaNs</a>{2*N}(type1, type2, op1_s, op2_s, fpcr, fpexc);

    if !done then
        let inf1  = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2  = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{2*N}(fpcr);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{2*N}('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{2*N}('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{2*N}(sign1);
        else
            let result_value : real = value1 + value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                let result_sign : bit = if rounding == <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{2*N}(result_sign);
            else
                result = <a href="shared_pseudocode.html#func_FPRoundBF_5" title="">FPRoundBF</a>{2*N}(result_value, fpcr, rounding, fpexc);
            end;
        end;

        if fpexc then FPProcessDenorms(type1, type2, 2*N, fpcr); end;
    end;

    return result[2*N-1:N];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFAdd_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFAdd_ZA</h3>
      <p class="pseudocode">// BFAdd_ZA()
// ==========
// Non-widening BFloat16 addition used by SME2 ZA-targeting instructions.

func <a id="func_BFAdd_ZA_3"/>BFAdd_ZA(op1 : bits(16), op2 : bits(16), fpcr_in : FPCR_Type) =&gt; bits(16)
begin
    let fpexc : boolean = FALSE;
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.DN = '1';          // Generate default NaN values
    return <a href="shared_pseudocode.html#func_BFAdd_5" title="">BFAdd</a>{16}(op1, op2, fpcr, fpexc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFDotAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFDotAdd</h3>
      <p class="pseudocode">// BFDotAdd()
// ==========
// BFloat16 2-way dot-product and add to single-precision
// result = addend + op1_a*op2_a + op1_b*op2_b

func <a id="func_BFDotAdd_6"/>BFDotAdd(addend : bits(32), op1_a : bits(16), op1_b : bits(16),
              op2_a : bits(16), op2_b : bits(16), fpcr_in : FPCR_Type) =&gt; bits(32)
begin
    var fpcr : FPCR_Type = fpcr_in;
    var prod : bits(32);

    var result : bits(32);
    if !IsFeatureImplemented(FEAT_EBF16) || fpcr.EBF == '0' then   // Standard BFloat16 behaviors
        prod   = <a href="shared_pseudocode.html#func_FPAdd_BF16_3" title="">FPAdd_BF16</a>(<a href="shared_pseudocode.html#func_BFMulH_3" title="">BFMulH</a>(op1_a, op2_a, fpcr), <a href="shared_pseudocode.html#func_BFMulH_3" title="">BFMulH</a>(op1_b, op2_b, fpcr), fpcr);
        result = <a href="shared_pseudocode.html#func_FPAdd_BF16_3" title="">FPAdd_BF16</a>(addend, prod, fpcr);
    else                                                           // Extended BFloat16 behaviors
        let isbfloat16 : boolean = TRUE;
        let fpexc : boolean = FALSE;    // Do not generate floating-point exceptions
        fpcr.DN = '1';                  // Generate default NaN values
        prod    = <a href="shared_pseudocode.html#func_FPDot_7" title="">FPDot</a>(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
        result  = <a href="shared_pseudocode.html#func_FPAdd_5" title="">FPAdd</a>{32}(addend, prod, fpcr, fpexc);
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFInfinity"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFInfinity</h3>
      <p class="pseudocode">// BFInfinity()
// ============

func <a id="func_BFInfinity_2"/>BFInfinity{N}(sign : bit) =&gt; bits(N)
begin
    assert N == 16;
    let E : integer{} = 8;
    let F : integer{} = N - (E + 1);
    return sign :: Ones{E} :: Zeros{F};
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMatMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMatMulAdd</h3>
      <p class="pseudocode">// BFMatMulAdd()
// =============
// BFloat16 matrix multiply and add to same precision matrix
// result[2, 2] = addend[2, 2] + (op1[2, 2] * op2[2, 2])

func <a id="func_BFMatMulAdd_4"/>BFMatMulAdd(addend : bits(64), op1 : bits(64), op2 : bits(64), fpcr : FPCR_Type) =&gt; bits(64)
begin

    var result : bits(64);

    for i = 0 to 1 do
        for j = 0 to 1 do
            let sum : bits(16)    = addend[(2*i + j)*:16];
            let prod0 : bits(16)  = <a href="shared_pseudocode.html#func_BFMul_3" title="">BFMul</a>(op1[(2*i + 0)*:16],
                                             op2[(2*j + 0)*:16], fpcr);
            let prod1 : bits(16)  = <a href="shared_pseudocode.html#func_BFMul_3" title="">BFMul</a>(op1[(2*i + 1)*:16],
                                            op2[(2*j + 1)*:16], fpcr);
            result[(2*i + j)*:16] = <a href="shared_pseudocode.html#func_BFAdd_4" title="">BFAdd</a>{16}(sum, <a href="shared_pseudocode.html#func_BFAdd_4" title="">BFAdd</a>{16}(prod0, prod1, fpcr), fpcr);
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMatMulAddH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMatMulAddH</h3>
      <p class="pseudocode">// BFMatMulAddH()
// ==============
// BFloat16 matrix multiply and add to single-precision matrix
// result[2, 2] = addend[2, 2] + (op1[2, 4] * op2[4, 2])

func <a id="func_BFMatMulAddH_4"/>BFMatMulAddH(addend : bits(128), op1 : bits(128),
                  op2 : bits(128), fpcr : FPCR_Type) =&gt; bits(128)
begin

    var result : bits(128);
    var sum : bits(32);

    for i = 0 to 1 do
        for j = 0 to 1 do
            sum = addend[(2*i + j)*:32];
            for k = 0 to 1 do
                let elt1_a : bits(16) = op1[(4*i + 2*k + 0)*:16];
                let elt1_b : bits(16) = op1[(4*i + 2*k + 1)*:16];
                let elt2_a : bits(16) = op2[(4*j + 2*k + 0)*:16];
                let elt2_b : bits(16) = op2[(4*j + 2*k + 1)*:16];
                sum = <a href="shared_pseudocode.html#func_BFDotAdd_6" title="">BFDotAdd</a>(sum, elt1_a, elt1_b, elt2_a, elt2_b, fpcr);
            end;
            result[(2*i + j)*:32] = sum;
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMax"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMax</h3>
      <p class="pseudocode">// BFMax()
// =======
// BFloat16 maximum.

func <a id="func_BFMax_4"/>BFMax{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_BFMax_6" title="">BFMax</a>{N}(op1, op2, fpcr, altfp, fpexc);
end;

// BFMax()
// =======
// BFloat16 maximum.

func <a id="func_BFMax_5"/>BFMax{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type, altfp : boolean) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_BFMax_6" title="">BFMax</a>{N}(op1, op2, fpcr, altfp, fpexc);
end;

// BFMax()
// =======
// BFloat16 maximum following computational behaviors
// corresponding to instructions that read and write BFloat16 values.
// Compare op1 and op2 and return the larger value after rounding.
// The 'fpcr' argument supplies the FPCR control bits and 'altfp' determines
// if the function should use alternative floating-point behavior.

func <a id="func_BFMax_6"/>BFMax{N}(op1 : bits(N), op2 : bits(N), fpcr_in : FPCR_Type,
              altfp : boolean, fpexc : boolean) =&gt; bits(N)
begin
    assert N == 16;
    var fpcr : FPCR_Type = fpcr_in;
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
    var done : boolean;
    var result : bits(2*N);

    let op1_s : bits(2*N) = op1 :: Zeros{N};
    let op2_s : bits(2*N) = op2 :: Zeros{N};
    let (type1,sign1,value1) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{2*N}(op1_s, fpcr, fpexc);
    let (type2,sign2,value2) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{2*N}(op2_s, fpcr, fpexc);

    if altfp &amp;&amp; type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> &amp;&amp; sign1 != sign2 then
        // Alternate handling of zeros with differing sign
        return <a href="shared_pseudocode.html#func_BFZero_2" title="">BFZero</a>{N}(sign2);
    elsif altfp &amp;&amp; (type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>}) then
        // Alternate handling of NaN inputs
        if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        return (if type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then <a href="shared_pseudocode.html#func_BFZero_2" title="">BFZero</a>{N}(sign2) else op2);
    end;

    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_7" title="">FPProcessNaNs</a>{2*N}(type1, type2, op1_s, op2_s, fpcr, fpexc);
    if !done then
        var fptype : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>;
        var sign : bit;
        var value : real;
        if value1 &gt; value2 then
            (fptype,sign,value) = (type1,sign1,value1);
        else
            (fptype,sign,value) = (type2,sign2,value2);
        end;
        if fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{2*N}(sign);
        elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
            sign = sign1 AND sign2;              // Use most positive sign
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{2*N}(sign);
        else
            if altfp then    // Denormal output is not flushed to zero
                fpcr.FZ = '0';
            end;
            result = <a href="shared_pseudocode.html#func_FPRoundBF_5" title="">FPRoundBF</a>{2*N}(value, fpcr, rounding, fpexc);
        end;

        if fpexc then FPProcessDenorms(type1, type2, 2*N, fpcr); end;
    end;

    return result[2*N-1:N];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMaxNum"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMaxNum</h3>
      <p class="pseudocode">// BFMaxNum()
// ==========

func <a id="func_BFMaxNum_4"/>BFMaxNum{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_BFMaxNum_5" title="">BFMaxNum</a>{N}(op1, op2, fpcr, fpexc);
end;

// BFMaxNum()
// ==========
// BFloat16 maximum number following computational behaviors corresponding
// to instructions that read and write BFloat16 values.
// Compare op1 and op2 and return the larger number operand after rounding.
// The 'fpcr' argument supplies the FPCR control bits.

func <a id="func_BFMaxNum_5"/>BFMaxNum{N}(op1_in : bits(N), op2_in : bits(N), fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(N)
begin
    assert N == 16;
    let isbfloat16 : boolean = TRUE;
    var op1 : bits(N)   = op1_in;
    var op2 : bits(N)   = op2_in;
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    var result : bits(N);

    let (type1,-,-) = <a href="shared_pseudocode.html#func_FPUnpackBase_5" title="">FPUnpackBase</a>{N}(op1, fpcr, fpexc, isbfloat16);
    let (type2,-,-) = <a href="shared_pseudocode.html#func_FPUnpackBase_5" title="">FPUnpackBase</a>{N}(op2, fpcr, fpexc, isbfloat16);

    let type1_nan : boolean = type1 IN {<a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>, <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>};
    let type2_nan : boolean = type2 IN {<a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>, <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>};

    if !(altfp &amp;&amp; type1_nan &amp;&amp; type2_nan) then
        // Treat a single quiet-NaN as -Infinity.
        if type1 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> &amp;&amp; type2 != <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
            op1 = <a href="shared_pseudocode.html#func_BFInfinity_2" title="">BFInfinity</a>{N}('1');
        elsif type1 != <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
            op2 = <a href="shared_pseudocode.html#func_BFInfinity_2" title="">BFInfinity</a>{N}('1');
        end;
    end;

    let altfmaxfmin : boolean = FALSE;    // Do not use alternate NaN handling
    result = <a href="shared_pseudocode.html#func_BFMax_6" title="">BFMax</a>{N}(op1, op2, fpcr, altfmaxfmin, fpexc);

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMin"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMin</h3>
      <p class="pseudocode">// BFMin()
// =======
// BFloat16 minimum.

func <a id="func_BFMin_4"/>BFMin{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_BFMin_6" title="">BFMin</a>{N}(op1, op2, fpcr, altfp, fpexc);
end;

// BFMin()
// =======
// BFloat16 minimum.

func <a id="func_BFMin_5"/>BFMin{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type, altfp : boolean) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_BFMin_6" title="">BFMin</a>{N}(op1, op2, fpcr, altfp, fpexc);
end;

// BFMin()
// =======
// BFloat16 minimum following computational behaviors
// corresponding to instructions that read and write BFloat16 values.
// Compare op1 and op2 and return the smaller value after rounding.
// The 'fpcr' argument supplies the FPCR control bits and 'altfp' determines
// if the function should use alternative floating-point behavior.

func <a id="func_BFMin_6"/>BFMin{N}(op1 : bits(N), op2 : bits(N), fpcr_in : FPCR_Type,
              altfp : boolean, fpexc : boolean) =&gt; bits(N)
begin
    assert N == 16;
    var fpcr : FPCR_Type = fpcr_in;
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
    var done : boolean;
    var result : bits(2*N);

    let op1_s : bits(2*N) = op1 :: Zeros{N};
    let op2_s : bits(2*N) = op2 :: Zeros{N};
    let (type1,sign1,value1) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{2*N}(op1_s, fpcr, fpexc);
    let (type2,sign2,value2) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{2*N}(op2_s, fpcr, fpexc);

    if altfp &amp;&amp; type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> &amp;&amp; sign1 != sign2 then
        // Alternate handling of zeros with differing sign
        return <a href="shared_pseudocode.html#func_BFZero_2" title="">BFZero</a>{N}(sign2);
    elsif altfp &amp;&amp; (type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>}) then
        // Alternate handling of NaN inputs
        if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        return (if type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then <a href="shared_pseudocode.html#func_BFZero_2" title="">BFZero</a>{N}(sign2) else op2);
    end;

    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_7" title="">FPProcessNaNs</a>{2*N}(type1, type2, op1_s, op2_s, fpcr, fpexc);
    if !done then
        var fptype : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>;
        var sign : bit;
        var value : real;
        if value1 &lt; value2 then
            (fptype,sign,value) = (type1,sign1,value1);
        else
            (fptype,sign,value) = (type2,sign2,value2);
        end;
        if fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{2*N}(sign);
        elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
            sign = sign1 OR sign2;              // Use most negative sign
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{2*N}(sign);
        else
            if altfp then                       // Denormal output is not flushed to zero
                fpcr.FZ = '0';
            end;
            result = <a href="shared_pseudocode.html#func_FPRoundBF_5" title="">FPRoundBF</a>{2*N}(value, fpcr, rounding, fpexc);
        end;

        if fpexc then FPProcessDenorms(type1, type2, 2*N, fpcr); end;
    end;

    return result[2*N-1:N];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMinNum"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMinNum</h3>
      <p class="pseudocode">// BFMinNum()
// ==========

func <a id="func_BFMinNum_4"/>BFMinNum{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_BFMinNum_5" title="">BFMinNum</a>{N}(op1, op2, fpcr, fpexc);
end;

// BFMinNum()
// ==========
// BFloat16 minimum number following computational behaviors corresponding
// to instructions that read and write BFloat16 values.
// Compare op1 and op2 and return the smaller number operand after rounding.
// The 'fpcr' argument supplies the FPCR control bits.

func <a id="func_BFMinNum_5"/>BFMinNum{N}(op1_in : bits(N), op2_in : bits(N), fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(N)
begin
    assert N == 16;
    let isbfloat16 : boolean = TRUE;
    var op1 : bits(N)   = op1_in;
    var op2 : bits(N)   = op2_in;
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    var result : bits(N);

    let (type1,-,-) = <a href="shared_pseudocode.html#func_FPUnpackBase_5" title="">FPUnpackBase</a>{N}(op1, fpcr, fpexc, isbfloat16);
    let (type2,-,-) = <a href="shared_pseudocode.html#func_FPUnpackBase_5" title="">FPUnpackBase</a>{N}(op2, fpcr, fpexc, isbfloat16);

    let type1_nan : boolean = type1 IN {<a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>, <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>};
    let type2_nan : boolean = type2 IN {<a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>, <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>};

    if !(altfp &amp;&amp; type1_nan &amp;&amp; type2_nan) then
        // Treat a single quiet-NaN as +Infinity.
        if type1 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> &amp;&amp; type2 != <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
            op1 = <a href="shared_pseudocode.html#func_BFInfinity_2" title="">BFInfinity</a>{N}('0');
        elsif type1 != <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
            op2 = <a href="shared_pseudocode.html#func_BFInfinity_2" title="">BFInfinity</a>{N}('0');
        end;
    end;

    let altfmaxfmin : boolean = FALSE;    // Do not use alternate NaN handling
    result = <a href="shared_pseudocode.html#func_BFMin_6" title="">BFMin</a>{N}(op1, op2, fpcr, altfmaxfmin, fpexc);

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMul"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMul</h3>
      <p class="pseudocode">// BFMul()
// =======
// Non-widening BFloat16 multiply used by SVE2 instructions.

func <a id="func_BFMul_3"/>BFMul(op1 : bits(16), op2 : bits(16), fpcr : FPCR_Type) =&gt; bits(16)
begin
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_BFMul_4" title="">BFMul</a>(op1, op2, fpcr, fpexc);
end;

// BFMul()
// =======
// Non-widening BFloat16 multiply following computational behaviors
// corresponding to instructions that read and write BFloat16 values.
// Calculates op1 * op2.
// The 'fpcr' argument supplies the FPCR control bits.

func <a id="func_BFMul_4"/>BFMul(op1 : bits(16), op2 : bits(16), fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(16)
begin
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
    var done : boolean;
    var result : bits(32);

    let op1_s : bits(32) = op1 :: Zeros{16};
    let op2_s : bits(32) = op2 :: Zeros{16};
    let (type1,sign1,value1) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{32}(op1_s, fpcr, fpexc);
    let (type2,sign2,value2) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{32}(op2_s, fpcr, fpexc);

    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_7" title="">FPProcessNaNs</a>{32}(type1, type2, op1_s, op2_s, fpcr, fpexc);

    if !done then
        let inf1  = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2  = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{32}(fpcr);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}(sign1 XOR sign2);
        elsif zero1 || zero2 then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(sign1 XOR sign2);
        else
            result = <a href="shared_pseudocode.html#func_FPRoundBF_5" title="">FPRoundBF</a>{32}(value1*value2, fpcr, rounding, fpexc);
        end;

        if fpexc then FPProcessDenorms(type1, type2, 32, fpcr); end;
    end;

    return result[31:16];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMulAdd</h3>
      <p class="pseudocode">// BFMulAdd()
// ==========
// Non-widening BFloat16 fused multiply-add used by SVE2 instructions.

func <a id="func_BFMulAdd_4"/>BFMulAdd(addend : bits(16), op1 : bits(16), op2 : bits(16), fpcr : FPCR_Type) =&gt; bits(16)
begin
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_BFMulAdd_5" title="">BFMulAdd</a>(addend, op1, op2, fpcr, fpexc);
end;

// BFMulAdd()
// ==========
// Non-widening BFloat16 fused multiply-add following computational behaviors
// corresponding to instructions that read and write BFloat16 values.
// Calculates addend + op1*op2 with a single rounding.
// The 'fpcr' argument supplies the FPCR control bits.

func <a id="func_BFMulAdd_5"/>BFMulAdd(addend : bits(16), op1 : bits(16), op2 : bits(16),
              fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(16)
begin
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
    var done : boolean;
    var result : bits(32);

    let addend_s : bits(32)  = addend :: Zeros{16};
    let op1_s : bits(32)     = op1 :: Zeros{16};
    let op2_s : bits(32)     = op2 :: Zeros{16};
    let (typeA,signA,valueA) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{32}(addend_s, fpcr, fpexc);
    let (type1,sign1,value1) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{32}(op1_s, fpcr, fpexc);
    let (type2,sign2,value2) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{32}(op2_s, fpcr, fpexc);

    let inf1  = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
    let inf2  = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
    let zero1 = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
    let zero2 = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs3_9" title="">FPProcessNaNs3</a>{32}(typeA, type1, type2, addend_s, op1_s, op2_s, fpcr, fpexc);

    if !(IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1') then
        if typeA == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> &amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{32}(fpcr);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        end;
    end;

    if !done then
        let infA  = (typeA == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zeroA = (typeA == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

        // Determine sign and type product will have if it does not cause an
        // Invalid Operation.
        let signP = sign1 XOR sign2;
        let infP  = inf1 || inf2;
        let zeroP = zero1 || zero2;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero
        // by infinity and additions of opposite-signed infinities.
        let invalidop = (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP);

        if invalidop then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{32}(fpcr);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;

        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}('0');
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}('1');

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(signA);

        // Otherwise calculate numerical result and round it.
        else
            let result_value : real = valueA + (value1 * value2);
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                let result_sign : bit = if rounding == <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(result_sign);
            else
                result = <a href="shared_pseudocode.html#func_FPRoundBF_5" title="">FPRoundBF</a>{32}(result_value, fpcr, rounding, fpexc);
            end;
        end;

        if !invalidop &amp;&amp; fpexc then
            FPProcessDenorms3(typeA, type1, type2, 32, fpcr);
        end;
    end;

    return result[31:16];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMulAddH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMulAddH</h3>
      <p class="pseudocode">// BFMulAddH()
// ===========
// Used by BFMLALB, BFMLALT, BFMLSLB and BFMLSLT instructions.

func <a id="func_BFMulAddH_4"/>BFMulAddH(addend : bits(32), op1 : bits(16), op2 : bits(16), fpcr_in : FPCR_Type) =&gt; bits(32)
begin
    let value1 : bits(32) = op1 :: Zeros{16};
    let value2 : bits(32) = op2 :: Zeros{16};
    var fpcr : FPCR_Type  = fpcr_in;
    let altfp : boolean   = IsFeatureImplemented(FEAT_AFP) &amp;&amp; fpcr.AH == '1';
    // When using alternative floating-point behaviour, do not generate floating-point exceptions
    let fpexc : boolean   = !altfp;
    if altfp then fpcr.[FIZ,FZ] = '11'; end;                          // Flush denormal input and
                                                                      // output to zero
    if altfp then fpcr.RMode    = '00'; end;                          // Use RNE rounding mode
    return <a href="shared_pseudocode.html#func_FPMulAdd_6" title="">FPMulAdd</a>{32}(addend, value1, value2, fpcr, fpexc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMulAddH_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMulAddH_ZA</h3>
      <p class="pseudocode">// BFMulAddH_ZA()
// ==============
// Used by SME2 ZA-targeting BFMLAL and BFMLSL instructions.

func <a id="func_BFMulAddH_ZA_4"/>BFMulAddH_ZA(addend : bits(32), op1 : bits(16), op2 : bits(16), fpcr : FPCR_Type) =&gt; bits(32)
begin
    let value1 : bits(32) = op1 :: Zeros{16};
    let value2 : bits(32) = op2 :: Zeros{16};
    return <a href="shared_pseudocode.html#func_FPMulAdd_ZA_5" title="">FPMulAdd_ZA</a>{32}(addend, value1, value2, fpcr);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMulAdd_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMulAdd_ZA</h3>
      <p class="pseudocode">// BFMulAdd_ZA()
// =============
// Non-widening BFloat16 fused multiply-add used by SME2 ZA-targeting instructions.

func <a id="func_BFMulAdd_ZA_4"/>BFMulAdd_ZA(addend : bits(16), op1 : bits(16), op2 : bits(16), fpcr_in : FPCR_Type) =&gt; bits(16)
begin
    let fpexc : boolean  = FALSE;
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.DN = '1';          // Generate default NaN values
    return <a href="shared_pseudocode.html#func_BFMulAdd_5" title="">BFMulAdd</a>(addend, op1, op2, fpcr, fpexc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMulH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMulH</h3>
      <p class="pseudocode">// BFMulH()
// ========
// BFloat16 widening multiply to single-precision following BFloat16
// computation behaviors.

func <a id="func_BFMulH_3"/>BFMulH(op1 : bits(16), op2 : bits(16), fpcr : FPCR_Type) =&gt; bits(32)
begin
    var result : bits(32);

    let (type1,sign1,value1) = <a href="shared_pseudocode.html#func_BFUnpack_2" title="">BFUnpack</a>{16}(op1);
    let (type2,sign2,value2) = <a href="shared_pseudocode.html#func_BFUnpack_2" title="">BFUnpack</a>{16}(op2);
    if type1 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> || type2 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{32}(fpcr);
    else
        let inf1  = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2  = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{32}(fpcr);
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}(sign1 XOR sign2);
        elsif zero1 || zero2 then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(sign1 XOR sign2);
        else
            result = <a href="shared_pseudocode.html#func_BFRound_1" title="">BFRound</a>(value1*value2);
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFNeg"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFNeg</h3>
      <p class="pseudocode">// BFNeg()
// =======

func <a id="func_BFNeg_1"/>BFNeg(op : bits(16)) =&gt; bits(16)
begin
    let honor_altfp : boolean = TRUE;    // Honor alternate handling
    return <a href="shared_pseudocode.html#func_BFNeg_2" title="">BFNeg</a>(op, honor_altfp);
end;

// BFNeg()
// =======

func <a id="func_BFNeg_2"/>BFNeg(op : bits(16), honor_altfp : boolean) =&gt; bits(16)
begin
    if honor_altfp &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; IsFeatureImplemented(FEAT_AFP) then
        if FPCR().AH == '1' then
            let fpexc : boolean = FALSE;
            let isbfloat16 : boolean = TRUE;
            let (fptype, -, -) = <a href="shared_pseudocode.html#func_FPUnpackBase_5" title="">FPUnpackBase</a>{16}(op, FPCR(), fpexc, isbfloat16);
            if fptype IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} then
                return op;        // When FPCR().AH=1, sign of NaN has no consequence
            end;
        end;
    end;
    return NOT(op[15]) :: op[14:0];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFRound"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFRound</h3>
      <p class="pseudocode">// BFRound()
// =========
// Converts a real number OP into a single-precision value using the
// Round to Odd rounding mode and following BFloat16 computation behaviors.

func <a id="func_BFRound_1"/>BFRound(op : real) =&gt; bits(32)
begin
    assert op != 0.0;
    var result : bits(32);

    // Format parameters - minimum exponent, numbers of exponent and fraction bits.
    let minimum_exp : integer = -126;  let E : integer{} = 8;  let F : integer{} = 23;

    // Split value into sign, unrounded mantissa and exponent.
    var sign : bit;
    var exponent : integer;
    var mantissa : real;
    if op &lt; 0.0 then
        sign = '1';  mantissa = -op;
    else
        sign = '0';  mantissa = op;
    end;

    (mantissa, exponent) = <a href="shared_pseudocode.html#func_NormalizeReal_1" title="">NormalizeReal</a>(mantissa);
    // Fixed Flush-to-zero.
    if exponent &lt; minimum_exp then
        return <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(sign);
    end;

    // Start creating the exponent value for the result. Start by biasing the actual exponent
    // so that the minimum exponent becomes 1, lower values 0 (indicating possible underflow).
    let biased_exp : integer = Max((exponent - minimum_exp) + 1, 0);
    if biased_exp == 0 then mantissa = mantissa / 2.0^(minimum_exp - exponent); end;

    // Get the unrounded mantissa as an integer, and the "units in last place" rounding error.
    // &lt; 2.0^F if biased_exp == 0, &gt;= 2.0^F if not
    var int_mant : integer = RoundDown(mantissa * 2.0^F);
    let error : real = mantissa * 2.0^F - Real(int_mant);

    // Round to Odd
    if error != 0.0 &amp;&amp; int_mant[0] == '0' then
        int_mant = int_mant + 1;
    end;

    // Deal with overflow and generate result.
    if biased_exp &gt;= 2^E - 1 then
        result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}(sign);      // Overflows generate appropriately-signed Infinity
    else
        result = sign :: biased_exp[E-1:0] :: int_mant[F-1:0];
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFScale"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFScale</h3>
      <p class="pseudocode">// BFScale()
// =========
// Scales BFloat16 operand by 2.0 to the power of the signed integer value.

func <a id="func_BFScale_3"/>BFScale(op : bits(16), scale : integer, fpcr : FPCR_Type) =&gt; bits(16)
begin
    var result : bits(32);

    let op_s : bits(32) = op :: Zeros{16};
    let (fptype,sign,value) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{32}(op_s, fpcr);

    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#func_FPProcessNaN_4" title="">FPProcessNaN</a>{32}(fptype, op_s, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(sign);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}(sign);
    else
        let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
        let fpexc : boolean = TRUE;
        result = <a href="shared_pseudocode.html#func_FPRoundBF_5" title="">FPRoundBF</a>{32}(value * (2.0^scale), fpcr, rounding, fpexc);
        if fpexc then FPProcessDenorm(fptype, 32, fpcr); end;
    end;

    return result[31:16];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFSub"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFSub</h3>
      <p class="pseudocode">// BFSub()
// =======
// Non-widening BFloat16 subtraction used by SVE2 instructions.

func <a id="func_BFSub_3"/>BFSub(op1 : bits(16), op2 : bits(16), fpcr : FPCR_Type) =&gt; bits(16)
begin
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_BFSub_4" title="">BFSub</a>(op1, op2, fpcr, fpexc);
end;

// BFSub()
// =======
// Non-widening BFloat16 subtraction following computational behaviors
// corresponding to instructions that read and write BFloat16 values.
// Calculates op1 - op2.
// The 'fpcr' argument supplies the FPCR control bits.

func <a id="func_BFSub_4"/>BFSub(op1 : bits(16), op2 : bits(16), fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(16)
begin
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
    var done : boolean;
    var result : bits(32);

    let op1_s : bits(32) = op1 :: Zeros{16};
    let op2_s : bits(32) = op2 :: Zeros{16};
    let (type1,sign1,value1) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{32}(op1_s, fpcr, fpexc);
    let (type2,sign2,value2) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{32}(op2_s, fpcr, fpexc);

    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_7" title="">FPProcessNaNs</a>{32}(type1, type2, op1_s, op2_s, fpcr, fpexc);

    if !done then
        let inf1  = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2  = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{32}(fpcr);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(sign1);
        else
            let result_value : real = value1 - value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                let result_sign : bit = if rounding == <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(result_sign);
            else
                result = <a href="shared_pseudocode.html#func_FPRoundBF_5" title="">FPRoundBF</a>{32}(result_value, fpcr, rounding, fpexc);
            end;
        end;

        if fpexc then FPProcessDenorms(type1, type2, 32, fpcr); end;
    end;

    return result[31:16];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFSub_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFSub_ZA</h3>
      <p class="pseudocode">// BFSub_ZA()
// ==========
// Non-widening BFloat16 subtraction used by SME2 ZA-targeting instructions.

func <a id="func_BFSub_ZA_3"/>BFSub_ZA(op1 : bits(16), op2 : bits(16), fpcr_in : FPCR_Type) =&gt; bits(16)
begin
    let fpexc : boolean = FALSE;
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.DN = '1';          // Generate default NaN values
    return <a href="shared_pseudocode.html#func_BFSub_4" title="">BFSub</a>(op1, op2, fpcr, fpexc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFUnpack"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFUnpack</h3>
      <p class="pseudocode">// BFUnpack()
// ==========
// Unpacks a BFloat16 or single-precision value into its type,
// sign bit and real number that it represents.
// The real number result has the correct sign for numbers and infinities,
// is very large in magnitude for infinities, and is 0.0 for NaNs.
// (These values are chosen to simplify the description of
// comparisons and conversions.)

func <a id="func_BFUnpack_2"/>BFUnpack{N}(fpval : bits(N)) =&gt; (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real)
begin
    assert N IN {16,32};

    var sign : bit;
    var exp : bits(8);
    var frac : bits(23);
    if N == 16 then
        sign   = fpval[15];
        exp    = fpval[14:7];
        frac   = fpval[6:0] :: Zeros{16};
    else  // N == 32
        sign   = fpval[31];
        exp    = fpval[30:23];
        frac   = fpval[22:0];
    end;

    var fptype : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>;
    var value : real;
    if IsZero(exp) then
        fptype = <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>;  value = 0.0;    // Fixed Flush to Zero
    elsif IsOnes(exp) then
        if IsZero(frac) then
            fptype = <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>;  value = 2.0^1000000;
        else    // no SNaN for BF16 arithmetic
            fptype = <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>; value = 0.0;
        end;
    else
        fptype = <a href="shared_pseudocode.html#enum_FPType_Nonzero" title="">FPType_Nonzero</a>;
        value = 2.0^(UInt(exp)-127) * (1.0 + Real(UInt(frac)) * 2.0^-23);
    end;

    if sign == '1' then value = -value; end;

    return (fptype, sign, value);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFZero"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFZero</h3>
      <p class="pseudocode">// BFZero()
// ========

func <a id="func_BFZero_2"/>BFZero{N}(sign : bit) =&gt; bits(N)
begin
    assert N == 16;
    let E : integer{} = 8;
    let F : integer{} = N - (E + 1);
    return sign :: Zeros{E} :: Zeros{F};
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.FPAdd_BF16"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/FPAdd_BF16</h3>
      <p class="pseudocode">// FPAdd_BF16()
// ============
// Single-precision add following BFloat16 computation behaviors.

func <a id="func_FPAdd_BF16_3"/>FPAdd_BF16(op1 : bits(32), op2 : bits(32), fpcr : FPCR_Type) =&gt; bits(32)
begin
    var result : bits(32);

    let (type1,sign1,value1) = <a href="shared_pseudocode.html#func_BFUnpack_2" title="">BFUnpack</a>{32}(op1);
    let (type2,sign2,value2) = <a href="shared_pseudocode.html#func_BFUnpack_2" title="">BFUnpack</a>{32}(op2);
    if type1 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> || type2 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{32}(fpcr);
    else
        let inf1  = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2  = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{32}(fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(sign1);
        else
            let result_value : real = value1 + value2;
            if result_value == 0.0 then
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}('0');    // Positive sign when Round to Odd
            else
                result = <a href="shared_pseudocode.html#func_BFRound_1" title="">BFRound</a>(result_value);
            end;
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.FPConvertBF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/FPConvertBF</h3>
      <p class="pseudocode">// FPConvertBF()
// =============
// Converts a single-precision OP to BFloat16 value using the
// Round to Nearest Even rounding mode when executed from AArch64 state and
// FPCR.AH == '1', otherwise rounding is controlled by FPCR/FPSCR.

func <a id="func_FPConvertBF_3"/>FPConvertBF(op : bits(32), fpcr_in : FPCR_Type, rounding_in : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>) =&gt; bits(16)
begin
    let halfsize : integer{}  = 16;
    var fpcr : FPCR_Type      = fpcr_in;
    var rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = rounding_in;
    var result : bits(32);                              // BF16 value in top 16 bits
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    let fpexc : boolean = !altfp;                      // Generate no floating-point exceptions
    if altfp then fpcr.[FIZ,FZ] = '11'; end;           // Flush denormal input and output to zero
    if altfp then rounding = <a href="shared_pseudocode.html#enum_FPRounding_TIEEVEN" title="">FPRounding_TIEEVEN</a>; end;  // Use RNE rounding mode

    // Unpack floating-point operand, with always flush-to-zero if fpcr.AH == '1'.
    let (fptype,sign,value) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{32}(op, fpcr, fpexc);

    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        if fpcr.DN == '1' then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{32}(fpcr);
        else
            result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 32}(op);
        end;
        if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        end;
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}(sign);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(sign);
    else
        result = <a href="shared_pseudocode.html#func_FPRoundBF_5" title="">FPRoundBF</a>{32}(value, fpcr, rounding, fpexc);
    end;

    // Returns correctly rounded BF16 value from top 16 bits
    return result[(2*halfsize)-1:halfsize];
end;

// FPConvertBF()
// =============
// Converts a single-precision operand to BFloat16 value.

func <a id="func_FPConvertBF_2"/>FPConvertBF(op : bits(32), fpcr : FPCR_Type) =&gt; bits(16)
begin
    return <a href="shared_pseudocode.html#func_FPConvertBF_3" title="">FPConvertBF</a>(op, fpcr, <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr));
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.FPRoundBF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/FPRoundBF</h3>
      <p class="pseudocode">// FPRoundBF()
// ===========
// Converts a real number OP into a BFloat16 value using the supplied
// rounding mode RMODE. The 'fpexc' argument controls the generation of
// floating-point exceptions.

func <a id="func_FPRoundBF_5"/>FPRoundBF{N}(op : real, fpcr : FPCR_Type, rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>, fpexc : boolean) =&gt; bits(N)
begin
    assert N == 32;
    let isbfloat16 : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_FPRoundBase_6" title="">FPRoundBase</a>{N}(op, fpcr, rounding, isbfloat16, fpexc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fixedtofp.FixedToFP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fixedtofp/FixedToFP</h3>
      <p class="pseudocode">// FixedToFP()
// ===========

// Convert M-bit fixed point 'op' with FBITS fractional bits to
// N-bit precision floating point, controlled by UNSIGNED and ROUNDING.

func <a id="func_FixedToFP_7"/>FixedToFP{N, M}(op : bits(M), fbits : integer, unsigned : boolean, fpcr : FPCR_Type,
                     rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    assert M IN {8,16,32,64};
    var result : bits(N);
    assert fbits &gt;= 0;
    assert rounding != <a href="shared_pseudocode.html#enum_FPRounding_ODD" title="">FPRounding_ODD</a>;

    // Correct signed-ness
    let int_operand : integer{} = if unsigned then UInt(op) else SInt(op);

    // Scale by fractional bits and generate a real value
    let real_operand : real = Real(int_operand) / 2.0^fbits;

    if real_operand == 0.0 then
        result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}('0');
    else
        result = <a href="shared_pseudocode.html#func_FPRound_4" title="">FPRound</a>{N}(real_operand, fpcr, rounding);
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.BFConvertFP8"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/BFConvertFP8</h3>
      <p class="pseudocode">// BFConvertFP8()
// ==============
// Converts a BFloat16 OP to FP8 value.

func <a id="func_BFConvertFP8_3"/>BFConvertFP8(op_in : bits(16), fpcr : FPCR_Type, fpmr : FPMR_Type) =&gt; bits(8)
begin
    let op : bits(32) = op_in :: Zeros{16};
    return FPConvertFP8{8, 32}(op, fpcr, fpmr);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8Bits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8Bits</h3>
      <p class="pseudocode">// FP8Bits()
// =========
// Returns the minimum exponent, numbers of exponent and fraction bits.

func FP8Bits(fp8type : <a href="shared_pseudocode.html#FP8Type" title="type FP8Type">FP8Type</a>) =&gt; <a href="shared_pseudocode.html#FPBitsType" title="type FPBitsType">FPBitsType</a>
begin
    var minimum_exp : integer;
    var F : integer{2..3};
    if fp8type == FP8Type_OFP8_E4M3 then
        minimum_exp = -6;  F = 3;
    else  // fp8type == FP8Type_OFP8_E5M2
        minimum_exp = -14;  F = 2;
    end;

    return (F, minimum_exp);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8ConvertBF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8ConvertBF</h3>
      <p class="pseudocode">// FP8ConvertBF()
// ==============
// Converts an FP8 operand to BFloat16 value.

func <a id="func_FP8ConvertBF_4"/>FP8ConvertBF(op : bits(8), issrc2 : boolean, fpcr : FPCR_Type, fpmr : FPMR_Type) =&gt; bits(16)
begin
    let isbfloat16 : boolean = TRUE;
    let result : bits(32) = FP8ConvertFP{}(op, issrc2, fpcr, fpmr, isbfloat16);
    return result[16+:16];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8ConvertFP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8ConvertFP</h3>
      <p class="pseudocode">// FP8ConvertFP()
// ==============
// Converts an FP8 operand to half-precision value.

func FP8ConvertFP(op : bits(8), issrc2 : boolean, fpcr : FPCR_Type, fpmr : FPMR_Type) =&gt; bits(16)
begin
    let isbfloat16 : boolean = FALSE;
    return FP8ConvertFP{16}(op, issrc2, fpcr, fpmr, isbfloat16);
end;

// FP8ConvertFP()
// ==============
// Converts an FP8 operand to half-precision or BFloat16 value.
// The downscaling factor in FPMR.LSCALE or FPMR.LSCALE2 is applied to
// the value before rounding.

func FP8ConvertFP{M}(op : bits(8), issrc2 : boolean, fpcr_in : FPCR_Type, fpmr : FPMR_Type,
                     isbfloat16 : boolean) =&gt; bits(M)
begin
    assert M IN {16,32};
    var result : bits(M);

    let fpexc : boolean = TRUE;
    var fpcr : FPCR_Type = fpcr_in;
    // Do not flush denormal inputs and outputs to zero.
    // Do not support alternative half-precision format.
    fpcr.[FIZ,FZ,FZ16,AHP] = '0000';
    let rounding = FPRounding_TIEEVEN;
    let fp8type : <a href="shared_pseudocode.html#FP8Type" title="type FP8Type">FP8Type</a> = (if issrc2 then FP8DecodeType(fpmr.F8S2)
                                else FP8DecodeType(fpmr.F8S1));

    let (fptype,sign,value) = FP8Unpack{8}(op, fp8type);

    if fptype == FPType_SNaN || fptype == FPType_QNaN then
        result = FPDefaultNaN{M}(fpcr);
        if fptype == FPType_SNaN then
            FPProcessException(FPExc_InvalidOp, fpcr);
        end;
    elsif fptype == FPType_Infinity then
        result = FPInfinity{M}(sign);
    elsif fptype == FPType_Zero then
        result = FPZero{M}(sign);
    else
        var dscale : integer;
        if issrc2 then
            dscale = (if M == 16 then UInt(fpmr.LSCALE2[3:0])
                      else UInt(fpmr.LSCALE2[:6]));
        else
            dscale = (if M == 16 then UInt(fpmr.LSCALE[3:0])
                       else UInt(fpmr.LSCALE[:6]));
        end;
        let result_value : real = value * (2.0^-dscale);
        result = FPRoundBase{M}(result_value, fpcr, rounding, isbfloat16, fpexc);
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8DecodeType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8DecodeType</h3>
      <p class="pseudocode">// FP8DecodeType()
// ===============
// Decode the FP8 format encoded in F8S1, F8S2 or F8D field in FPMR

func FP8DecodeType(f8format : bits(3)) =&gt; <a href="shared_pseudocode.html#FP8Type" title="type FP8Type">FP8Type</a>
begin
    case f8format of
        when '000' =&gt; return FP8Type_OFP8_E5M2;
        when '001' =&gt; return FP8Type_OFP8_E4M3;
        otherwise =&gt;  return FP8Type_UNSUPPORTED;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8DefaultNaN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8DefaultNaN</h3>
      <p class="pseudocode">// FP8DefaultNaN()
// ===============

func FP8DefaultNaN{N}(fp8type : <a href="shared_pseudocode.html#FP8Type" title="type FP8Type">FP8Type</a>, fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N == 8;
    assert fp8type IN {FP8Type_OFP8_E5M2, FP8Type_OFP8_E4M3};
    let sign : bit = if IsFeatureImplemented(FEAT_AFP) then fpcr.AH else '0';
    let E : integer{} = if fp8type == FP8Type_OFP8_E4M3 then 4 else 5;
    let F : integer{} = N - (E + 1);
    var exp : bits(E);
    var frac : bits(F);

    case fp8type of
        when FP8Type_OFP8_E4M3 =&gt;
            exp  = Ones{E};
            frac = Ones{F};
        when FP8Type_OFP8_E5M2 =&gt;
            exp  = Ones{E};
            frac = '1'::Zeros{F-1};
    end;

    return sign :: exp :: frac;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8DotAddFP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8DotAddFP</h3>
      <p class="pseudocode">// FP8DotAddFP()
// =============

func FP8DotAddFP{M, N}(addend : bits(M), op1 : bits(N), op2 : bits(N),
                       fpcr : FPCR_Type, fpmr : FPMR_Type) =&gt; bits(M)
begin
    let E : integer{} = (N DIV 8) as integer{1, 2, 4, 8};
    return FP8DotAddFP{M, N}(addend, op1, op2, E, fpcr, fpmr);
end;

// FP8DotAddFP()
// =============
// Calculates result of "E"-way 8-bit floating-point dot-product with scaling
// and addition to half-precision or single-precision value without
// intermediate rounding.
// c = round(c + 2^-S*(a1*b1+..+aE*bE))
// The 8-bit floating-point format for op1 is determined by FPMR.F8S1
// and the one for op2 by FPMR.F8S2. The scaling factor in FPMR.LSCALE
// is applied to the sum-of-products before adding to the addend and rounding.

func FP8DotAddFP{M, N}(addend : bits(M), op1 : bits(N), op2 : bits(N), E : integer{1, 2, 4, 8},
                       fpcr_in : FPCR_Type, fpmr : FPMR_Type) =&gt; bits(M)
begin
    assert M IN {16,32};
    assert N IN {2*M, M, M DIV 2, M DIV 4};
    var fpcr : FPCR_Type = fpcr_in;
    var result : bits(M);

    fpcr.[FIZ,FZ,FZ16] = '000';        // Do not flush denormal inputs and outputs to zero
    fpcr.DN = '1';
    let rounding = FPRounding_TIEEVEN;

    let fp8type1 : <a href="shared_pseudocode.html#FP8Type" title="type FP8Type">FP8Type</a> = FP8DecodeType(fpmr.F8S1);
    let fp8type2 : <a href="shared_pseudocode.html#FP8Type" title="type FP8Type">FP8Type</a> = FP8DecodeType(fpmr.F8S2);

    var type1 : array[[E]] of FPType;
    var type2 : array[[E]] of FPType;
    var sign1 : array[[E]] of bit;
    var sign2 : array[[E]] of bit;
    var value1 : array[[E]] of real;
    var value2 : array[[E]] of real;
    var inf1 : array[[E]] of boolean;
    var inf2 : array[[E]] of boolean;
    var zero1 : array[[E]] of boolean;
    var zero2 : array[[E]] of boolean;

    let fpexc : boolean = FALSE;
    let (typeA,signA,valueA) = FPUnpack{M}(addend, fpcr, fpexc);
    let infA = (typeA == FPType_Infinity);   let zeroA = (typeA == FPType_Zero);
    var any_nan : boolean = typeA IN {FPType_SNaN, FPType_QNaN};
    for i = 0 to E-1 do
        (type1[[i]], sign1[[i]], value1[[i]]) = FP8Unpack{N DIV E}(op1[i*:(N DIV E)], fp8type1);
        (type2[[i]], sign2[[i]], value2[[i]]) = FP8Unpack{N DIV E}(op2[i*:(N DIV E)], fp8type2);
        inf1[[i]] = (type1[[i]] == FPType_Infinity); zero1[[i]] = (type1[[i]] == FPType_Zero);
        inf2[[i]] = (type2[[i]] == FPType_Infinity); zero2[[i]] = (type2[[i]] == FPType_Zero);
        any_nan = (any_nan || type1[[i]] IN {FPType_SNaN, FPType_QNaN} ||
                   type2[[i]] IN {FPType_SNaN, FPType_QNaN});
    end;

    if any_nan then
        result = FPDefaultNaN{M}(fpcr);
    else
        // Determine sign and type products will have if it does not cause an Invalid
        // Operation.
        var signP : array [[E]] of bit;
        var infP : array [[E]] of boolean;
        var zeroP : array [[E]] of boolean;
        for i = 0 to E-1 do
            signP[[i]] = sign1[[i]] XOR sign2[[i]];
            infP[[i]]  = inf1[[i]] || inf2[[i]];
            zeroP[[i]] = zero1[[i]] || zero2[[i]];
        end;

        // Detect non-numeric results of dot product and accumulate
        var posInfR : boolean = (infA &amp;&amp; signA == '0');
        var negInfR : boolean = (infA &amp;&amp; signA == '1');
        var zeroR : boolean = zeroA;
        var invalidop : boolean = FALSE;
        for i = 0 to E-1 do
            // Result is infinity if any input is infinity
            posInfR  = posInfR || (infP[[i]] &amp;&amp; signP[[i]] == '0');
            negInfR  = negInfR || (infP[[i]] &amp;&amp; signP[[i]] == '1');
            // Result is zero if the addend and the products are zeroes of the same sign
            zeroR    = zeroR &amp;&amp; zeroP[[i]] &amp;&amp; (signA == signP[[i]]);
            // Non SNaN-generated Invalid Operation cases are multiplies of zero
            // by infinity and additions of opposite-signed infinities.
            invalidop = (invalidop || (inf1[[i]] &amp;&amp; zero2[[i]]) || (zero1[[i]] &amp;&amp; inf2[[i]]) ||
                         (infA &amp;&amp; infP[[i]] &amp;&amp; (signA != signP[[i]])));
            for j = i+1 to E-1 do
                invalidop = invalidop || (infP[[i]] &amp;&amp; infP[[j]] &amp;&amp; (signP[[i]] != signP[[j]]));
            end;
        end;

        if invalidop then
            result = FPDefaultNaN{M}(fpcr);

        // Other cases involving infinities produce an infinity of the same sign.
        elsif posInfR then
            result = FPInfinity{M}('0');
        elsif negInfR then
            result = FPInfinity{M}('1');

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroR then
            result = FPZero{M}(signA);

        // Otherwise calculate numerical value and round it.
        else
            // Apply scaling to sum-of-product
            let dscale : integer = if M == 32 then UInt(fpmr.LSCALE) else UInt(fpmr.LSCALE[3:0]);

            var dp_value : real = value1[[0]] * value2[[0]];
            for i = 1 to E-1 do
                dp_value = dp_value + value1[[i]] * value2[[i]];
            end;

            let result_value : real = valueA + dp_value * (2.0^-dscale);
            if result_value == 0.0 then  // Sign of exact zero result is '0' for RNE rounding mode
                result = FPZero{M}('0');
            else
                let satoflo : boolean = (fpmr.OSM == '1');
                result = FPRound_FP8{M}(result_value, fpcr, rounding, satoflo);
            end;
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8Infinity"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8Infinity</h3>
      <p class="pseudocode">// FP8Infinity()
// =============

func FP8Infinity{N}(fp8type : <a href="shared_pseudocode.html#FP8Type" title="type FP8Type">FP8Type</a>, sign : bit) =&gt; bits(N)
begin
    assert N == 8;
    assert fp8type IN {FP8Type_OFP8_E5M2, FP8Type_OFP8_E4M3};
    let E : integer{} = if fp8type == FP8Type_OFP8_E4M3 then 4 else 5;
    let F : integer{} = N - (E + 1);
    var exp : bits(E);
    var frac : bits(F);

    case fp8type of
        when FP8Type_OFP8_E4M3 =&gt;
            exp  = Ones{E};
            frac = Ones{F};
        when FP8Type_OFP8_E5M2 =&gt;
            exp  = Ones{E};
            frac = Zeros{F};
    end;

    return sign :: exp :: frac;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8MatMulAddFP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8MatMulAddFP</h3>
      <p class="pseudocode">// FP8MatMulAddFP()
// ================
// 8-bit floating-point matrix multiply with scaling and add to half-precision
// or single-precision matrix.
// result[2, 2] = addend[2, 2] + (op1[2, E] * op2[E, 2])

func <a id="func_FP8MatMulAddFP_7"/>FP8MatMulAddFP{N}(addend : bits(N), op1 : bits(N), op2 : bits(N), E : integer{4, 8},
                       fpcr : FPCR_Type, fpmr : FPMR_Type) =&gt; bits(N)
begin
    assert N IN {64, 128};
    assert N == E*16;
    let M : integer{} = N DIV 4;
    var result : bits(N);

    for i = 0 to 1 do
        for j = 0 to 1 do
            let elt1 : bits(2*M) = op1[i*:(2*M)];
            let elt2 : bits(2*M) = op2[j*:(2*M)];
            let sum : bits(M) = addend[(2*i + j)*:M];
            result[(2*i + j)*:M] = FP8DotAddFP{M, N DIV 2}(sum, elt1, elt2, E, fpcr, fpmr);
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8MaxNormal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8MaxNormal</h3>
      <p class="pseudocode">// FP8MaxNormal()
// ==============

func FP8MaxNormal{N}(fp8type : <a href="shared_pseudocode.html#FP8Type" title="type FP8Type">FP8Type</a>, sign : bit) =&gt; bits(N)
begin
    assert N == 8;
    assert fp8type IN {FP8Type_OFP8_E5M2, FP8Type_OFP8_E4M3};
    let E : integer{} = if fp8type == FP8Type_OFP8_E4M3 then 4 else 5;
    let F : integer{} = N - (E + 1);
    var exp : bits(E);
    var frac : bits(F);

    case fp8type of
        when FP8Type_OFP8_E4M3 =&gt;
            exp  = Ones{E};
            frac = Ones{F-1}::'0';
        when FP8Type_OFP8_E5M2 =&gt;
            exp  = Ones{E-1}::'0';
            frac = Ones{F};
    end;

    return sign :: exp :: frac;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8MulAddFP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8MulAddFP</h3>
      <p class="pseudocode">// FP8MulAddFP()
// =============

func <a id="func_FP8MulAddFP_6"/>FP8MulAddFP{M}(addend : bits(M), op1 : bits(8), op2 : bits(8), fpcr : FPCR_Type,
                    fpmr : FPMR_Type) =&gt; bits(M)
begin
    assert M IN {16,32};
    let E : integer{} = 1;
    return FP8DotAddFP{M, 8}(addend, op1, op2, E, fpcr, fpmr);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8Round"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8Round</h3>
      <p class="pseudocode">// FP8Round()
// ==========
// Used by FP8 downconvert instructions which observe FPMR.OSC
// to convert a real number OP into an FP8 value.

func FP8Round{N}(op : real, fp8type : <a href="shared_pseudocode.html#FP8Type" title="type FP8Type">FP8Type</a>, fpcr : FPCR_Type, fpmr : FPMR_Type) =&gt; bits(N)
begin
    assert N == 8;
    assert fp8type IN {FP8Type_OFP8_E5M2, FP8Type_OFP8_E4M3};
    assert op != 0.0;
    var result : bits(N);

    // Format parameters - minimum exponent, numbers of exponent and fraction bits.
    let (F, minimum_exp) = FP8Bits(fp8type);
    let E : integer{} = (N - F) - 1;

    // Split value into sign, unrounded mantissa and exponent.
    var sign : bit;
    var exponent : integer;
    var mantissa : real;
    if op &lt; 0.0 then
        sign = '1';  mantissa = -op;
    else
        sign = '0';  mantissa = op;
    end;

    (mantissa, exponent) = NormalizeReal(mantissa);
    // When TRUE, detection of underflow occurs after rounding.
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; fpcr.AH == '1';

    var biased_exp_unconstrained : integer = (exponent - minimum_exp) + 1;
    var int_mant_unconstrained : integer= RoundDown(mantissa * 2.0^F);
    let error_unconstrained : real = mantissa * 2.0^F - Real(int_mant_unconstrained);

    // Start creating the exponent value for the result. Start by biasing the actual exponent
    // so that the minimum exponent becomes 1, lower values 0 (indicating possible underflow).
    var biased_exp : integer = Max((exponent - minimum_exp) + 1, 0);
    if biased_exp == 0 then mantissa = mantissa / 2.0^(minimum_exp - exponent); end;

    // Get the unrounded mantissa as an integer, and the "units in last place" rounding error.
    // &lt; 2.0^F if biased_exp == 0, &gt;= 2.0^F if not
    var int_mant : integer = RoundDown(mantissa * 2.0^F);
    var error : real = mantissa * 2.0^F - Real(int_mant);

    let trapped_UF : boolean = fpcr.UFE == '1' &amp;&amp; (!InStreamingMode() || IsFullA64Enabled());

    var round_up_unconstrained : boolean;
    var round_up : boolean;

    if altfp then
        // Round to Nearest Even
        round_up_unconstrained = (error_unconstrained &gt; 0.5 ||
                   (error_unconstrained == 0.5 &amp;&amp; int_mant_unconstrained[0] == '1'));
        round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_mant[0] == '1'));

        if round_up_unconstrained then
            int_mant_unconstrained = int_mant_unconstrained + 1;
            if int_mant_unconstrained == 2^(F+1) then    // Rounded up to next exponent
                biased_exp_unconstrained = biased_exp_unconstrained + 1;
                int_mant_unconstrained   = int_mant_unconstrained DIV 2;
            end;
        end;

        // Follow alternate floating-point behavior of underflow after rounding
        if (biased_exp_unconstrained &lt; 1 &amp;&amp; int_mant_unconstrained != 0 &amp;&amp;
            (error != 0.0 || trapped_UF)) then
            FPProcessException(FPExc_Underflow, fpcr);
        end;
    else // altfp == FALSE
        // Underflow occurs if exponent is too small before rounding, and result is inexact or
        // the Underflow exception is trapped. This applies before rounding if FPCR.AH != '1'.
        if biased_exp == 0 &amp;&amp; (error != 0.0 || trapped_UF) then
            FPProcessException(FPExc_Underflow, fpcr);
        end;

        // Round to Nearest Even
        round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_mant[0] == '1'));
    end;

    if round_up then
        int_mant = int_mant + 1;
        if int_mant == 2^F then      // Rounded up from denormalized to normalized
            biased_exp = 1;
        end;
        if int_mant == 2^(F+1) then  // Rounded up to next exponent
            biased_exp = biased_exp + 1;
            int_mant = int_mant DIV 2;
        end;
    end;

    // Deal with overflow and generate result.
    var overflow : boolean;
    case fp8type of
        when FP8Type_OFP8_E4M3 =&gt;
            overflow = biased_exp &gt;= 2^E || (biased_exp == 2^E - 1 &amp;&amp; int_mant == 2^(F+1) - 1);
        when FP8Type_OFP8_E5M2 =&gt;
            overflow = biased_exp &gt;= 2^E - 1;
    end;

    if overflow then
        result = (if fpmr.OSC == '0' then FP8Infinity{N}(fp8type, sign)
                  else FP8MaxNormal{N}(fp8type, sign));
        // Flag Overflow exception regardless of FPMR.OSC
        FPProcessException(FPExc_Overflow, fpcr);
        error = 1.0;  // Ensure that an Inexact exception occurs
    else
        result = sign :: biased_exp[E-1:0] :: int_mant[F-1:0];
    end;

    // Deal with Inexact exception.
    if error != 0.0 then
        FPProcessException(FPExc_Inexact, fpcr);
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8Type"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8Type</h3>
      <p class="pseudocode">// FP8Type
// =======

type <a id="FP8Type"/>FP8Type of enumeration {FP8Type_OFP8_E5M2, FP8Type_OFP8_E4M3, FP8Type_UNSUPPORTED};</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8Unpack"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8Unpack</h3>
      <p class="pseudocode">// FP8Unpack()
// ===========
// Unpacks an FP8 value into its type, sign bit and real number that
// it represents.

func FP8Unpack{N}(fpval : bits(N), fp8type : <a href="shared_pseudocode.html#FP8Type" title="type FP8Type">FP8Type</a>) =&gt; (FPType, bit, real)
begin
    assert N == 8;
    let E : integer{} = if fp8type == FP8Type_OFP8_E4M3 then 4 else 5;
    let F : integer{} = N - (E + 1);

    let sign : bit = fpval[N-1];
    let exp : bits(E) = fpval[(E+F)-1:F];
    let frac : bits(F) = fpval[F-1:0];

    var value : real;
    var fptype : FPType;

    if fp8type == FP8Type_OFP8_E4M3 then
        if IsZero(exp) then
            if IsZero(frac) then
                fptype = FPType_Zero;  value = 0.0;
            else
                fptype = FPType_Denormal;  value = 2.0^-6 * (Real(UInt(frac)) * 2.0^-3);
            end;
        elsif IsOnes(exp) &amp;&amp; IsOnes(frac) then
            fptype = FPType_SNaN;
            value = 0.0;
        else
            fptype = FPType_Nonzero;
            value = 2.0^(UInt(exp)-7) * (1.0 + Real(UInt(frac)) * 2.0^-3);
        end;

    elsif fp8type == FP8Type_OFP8_E5M2 then
        if IsZero(exp) then
            if IsZero(frac) then
                fptype = FPType_Zero;  value = 0.0;
            else
                fptype = FPType_Denormal;  value = 2.0^-14 * (Real(UInt(frac)) * 2.0^-2);
            end;
        elsif IsOnes(exp) then
            if IsZero(frac) then
                fptype = FPType_Infinity;  value = 2.0^1000000;
            else
                fptype = if frac[1] == '1' then FPType_QNaN else FPType_SNaN;
                value = 0.0;
            end;
        else
            fptype = FPType_Nonzero;
            value = 2.0^(UInt(exp)-15) * (1.0 + Real(UInt(frac)) * 2.0^-2);
        end;

    else // fp8type == FP8Type_UNSUPPORTED
        fptype = FPType_SNaN;
        value = 0.0;
    end;

    if sign == '1' then value = -value; end;

    return (fptype, sign, value);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FP8Zero"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FP8Zero</h3>
      <p class="pseudocode">// FP8Zero()
// =========

func FP8Zero{N}(fp8type : <a href="shared_pseudocode.html#FP8Type" title="type FP8Type">FP8Type</a>, sign : bit) =&gt; bits(N)
begin
    assert N == 8;
    assert fp8type IN {FP8Type_OFP8_E5M2, FP8Type_OFP8_E4M3};
    let E : integer{} = if fp8type == FP8Type_OFP8_E4M3 then 4 else 5;
    let F : integer{} = N - (E + 1);
    return sign :: Zeros{E} :: Zeros{F};
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fp8float.FPConvertFP8"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fp8float/FPConvertFP8</h3>
      <p class="pseudocode">// FPConvertFP8()
// ==============
// Converts a half-precision or single-precision OP to FP8 value.
// The scaling factor in FPMR.NSCALE is applied to the value before rounding.

func FPConvertFP8{M, N}(op : bits(N), fpcr_in : FPCR_Type, fpmr : FPMR_Type) =&gt; bits(M)
begin
    assert N IN {16,32} &amp;&amp; M == 8;
    var result : bits(M);

    let fpexc : boolean = TRUE;
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.[FIZ,FZ,FZ16] = '000';    // Do not flush denormal inputs and outputs to zero
    let fp8type : <a href="shared_pseudocode.html#FP8Type" title="type FP8Type">FP8Type</a> = FP8DecodeType(fpmr.F8D);

    let (fptype,sign,value) = FPUnpack{N}(op, fpcr, fpexc);

    if fp8type == FP8Type_UNSUPPORTED then
        result = Ones{M};
        FPProcessException(FPExc_InvalidOp, fpcr);
    elsif fptype == FPType_SNaN || fptype == FPType_QNaN then
        result = FP8DefaultNaN{M}(fp8type, fpcr);     // Always generate Default NaN as result
        if fptype == FPType_SNaN then
            FPProcessException(FPExc_InvalidOp, fpcr);
        end;
    elsif fptype == FPType_Infinity then
        result = (if fpmr.OSC == '0' then FP8Infinity{M}(fp8type, sign)
                  else FP8MaxNormal{M}(fp8type, sign));
    elsif fptype == FPType_Zero then
        result = FP8Zero{M}(fp8type, sign);
    else
        let scale : integer = if N == 16 then SInt(fpmr.NSCALE[4:0]) else SInt(fpmr.NSCALE);
        let result_value : real = value * (2.0^scale);
        result = FP8Round{M}(result_value, fp8type, fpcr, fpmr);
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpabs.FPAbs"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpabs/FPAbs</h3>
      <p class="pseudocode">// FPAbs()
// =======

func <a id="func_FPAbs_3"/>FPAbs{N}(op : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    if !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; IsFeatureImplemented(FEAT_AFP) then
        if fpcr.AH == '1' then
            let (fptype, -, -) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op, fpcr, FALSE);
            if fptype IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} then
                return op;       // When fpcr.AH=1, sign of NaN has no consequence
            end;
        end;
    end;
    return '0' :: op[N-2:0];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpabsmax.FPAbsMax"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpabsmax/FPAbsMax</h3>
      <p class="pseudocode">// FPAbsMax()
// ==========
// Compare absolute value of two operands and return the larger absolute
// value without rounding.

func <a id="func_FPAbsMax_4"/>FPAbsMax{N}(op1_in : bits(N), op2_in : bits(N), fpcr_in : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var done : boolean;
    var result : bits(N);
    var fpcr : FPCR_Type  = fpcr_in;
    fpcr.[AH,FIZ,FZ,FZ16] = '0000';

    let op1 = '0'::op1_in[N-2:0];
    let op2 = '0'::op2_in[N-2:0];
    let (type1,-,value1) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,-,value2) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);

    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_6" title="">FPProcessNaNs</a>{N}(type1, type2, op1_in, op2_in, fpcr);

    if !done then
        // This condition covers all results other than NaNs,
        // including Zero &amp; Infinity
        result = if value1 &gt; value2 then op1 else op2;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpabsmin.FPAbsMin"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpabsmin/FPAbsMin</h3>
      <p class="pseudocode">// FPAbsMin()
// ==========
// Compare absolute value of two operands and return the smaller absolute
// value without rounding.

func <a id="func_FPAbsMin_4"/>FPAbsMin{N}(op1_in : bits(N), op2_in : bits(N), fpcr_in : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var done : boolean;
    var result : bits(N);
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.[AH,FIZ,FZ,FZ16] = '0000';

    let op1 = '0'::op1_in[N-2:0];
    let op2 = '0'::op2_in[N-2:0];
    let (type1,-,value1) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,-,value2) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);

    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_6" title="">FPProcessNaNs</a>{N}(type1, type2, op1_in, op2_in, fpcr);

    if !done then
        // This condition covers all results other than NaNs,
        // including Zero &amp; Infinity
        result = if value1 &lt; value2 then op1 else op2;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpadd.FPAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpadd/FPAdd</h3>
      <p class="pseudocode">// FPAdd()
// =======

func <a id="func_FPAdd_4"/>FPAdd{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#func_FPAdd_5" title="">FPAdd</a>{N}(op1, op2, fpcr, fpexc);
end;

// FPAdd()
// =======

func <a id="func_FPAdd_5"/>FPAdd{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(N)
begin

    assert N IN {16,32,64};
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);

    let (type1,sign1,value1) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op1, fpcr, fpexc);
    let (type2,sign2,value2) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op2, fpcr, fpexc);

    var (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_7" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr, fpexc);
    if !done then
        let inf1 : boolean  = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2 : boolean  = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{N}(fpcr);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign1);
        else
            let result_value : real = value1 + value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                let result_sign : bit = if rounding == <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(result_sign);
            else
                result = <a href="shared_pseudocode.html#func_FPRound_5" title="">FPRound</a>{N}(result_value, fpcr, rounding, fpexc);
            end;
        end;

        if fpexc then FPProcessDenorms(type1, type2, N, fpcr); end;
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpadd.FPAdd_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpadd/FPAdd_ZA</h3>
      <p class="pseudocode">// FPAdd_ZA()
// ==========
// Calculates op1+op2 for SME2 ZA-targeting instructions.

func <a id="func_FPAdd_ZA_4"/>FPAdd_ZA{N}(op1 : bits(N), op2 : bits(N), fpcr_in : FPCR_Type) =&gt; bits(N)
begin
    var fpcr : FPCR_Type = fpcr_in;
    let fpexc : boolean = FALSE; // Do not generate floating-point exceptions
    fpcr.DN = '1';                  // Generate default NaN values
    return <a href="shared_pseudocode.html#func_FPAdd_5" title="">FPAdd</a>{N}(op1, op2, fpcr, fpexc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpbits.FPBits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpbits/FPBits</h3>
      <p class="pseudocode">// FPBits()
// ========
// Returns the minimum exponent, numbers of exponent and fraction bits.

func FPBits(N : integer, isbfloat16 : boolean) =&gt; <a href="shared_pseudocode.html#FPBitsType" title="type FPBitsType">FPBitsType</a>
begin
    var F : <a href="shared_pseudocode.html#FPFracBits" title="type FPFracBits">FPFracBits</a>;
    var minimum_exp : integer;
    if N == 16 then
        minimum_exp = -14;   F = 10;
    elsif N == 32 &amp;&amp; isbfloat16 then
        minimum_exp = -126;  F = 7;
    elsif N == 32 then
        minimum_exp = -126;  F = 23;
    else  // N == 64
        minimum_exp = -1022; F = 52;
    end;

    return (F, minimum_exp);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpbits.FPBitsType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpbits/FPBitsType</h3>
      <p class="pseudocode">// FPBitsType
// ==========

type <a id="FPBitsType"/>FPBitsType of (<a href="shared_pseudocode.html#FPFracBits" title="type FPFracBits">FPFracBits</a>, integer);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpbits.FPFracBits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpbits/FPFracBits</h3>
      <p class="pseudocode">// FPFracBits
// ==========

type <a id="FPFracBits"/>FPFracBits of integer{2, 3, 7, 10, 23, 52};</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcompare.FPCompare"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcompare/FPCompare</h3>
      <p class="pseudocode">// FPCompare()
// ===========

func <a id="func_FPCompare_5"/>FPCompare{N}(op1 : bits(N), op2 : bits(N), signal_nans : boolean, fpcr : FPCR_Type) =&gt; bits(4)
begin
    assert N IN {16,32,64};
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);

    var result : bits(4);
    if type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} then
        result = '0011';
        if type1 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || signal_nans then
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
        end;
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        if value1 == value2 then
            result = '0110';
        elsif value1 &lt; value2 then
            result = '1000';
        else  // value1 &gt; value2
            result = '0010';
        end;

        FPProcessDenorms(type1, type2, N, fpcr);
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcompareeq.FPCompareEQ"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcompareeq/FPCompareEQ</h3>
      <p class="pseudocode">// FPCompareEQ()
// =============

func <a id="func_FPCompareEQ_4"/>FPCompareEQ{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; boolean
begin
    assert N IN {16,32,64};
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);

    var result : boolean;
    if type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} then
        result = FALSE;
        if type1 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
        end;
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 == value2);
        FPProcessDenorms(type1, type2, N, fpcr);

    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcomparege.FPCompareGE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcomparege/FPCompareGE</h3>
      <p class="pseudocode">// FPCompareGE()
// =============

func <a id="func_FPCompareGE_4"/>FPCompareGE{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; boolean
begin
    assert N IN {16,32,64};
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);

    var result : boolean;
    if type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} then
        result = FALSE;
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 &gt;= value2);
        FPProcessDenorms(type1, type2, N, fpcr);

    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcomparegt.FPCompareGT"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcomparegt/FPCompareGT</h3>
      <p class="pseudocode">// FPCompareGT()
// =============

func <a id="func_FPCompareGT_4"/>FPCompareGT{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; boolean
begin
    assert N IN {16,32,64};
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);

    var result : boolean;
    if type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} then
        result = FALSE;
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 &gt; value2);
        FPProcessDenorms(type1, type2, N, fpcr);

    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpconvert.FPConvert"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpconvert/FPConvert</h3>
      <p class="pseudocode">// FPConvert()
// ===========

// Convert floating point 'op' with N-bit precision to M-bit precision,
// with rounding controlled by ROUNDING.
// This is used by the FP-to-FP conversion instructions and so for
// half-precision data ignores FZ16, but observes AHP.

func <a id="func_FPConvert_5"/>FPConvert{M, N}(op : bits(N), fpcr : FPCR_Type, rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>) =&gt; bits(M)
begin

    assert M IN {16,32,64};
    assert N IN {16,32,64};
    var result : bits(M);

    // Unpack floating-point operand optionally with flush-to-zero.
    let (fptype,sign,value) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpackCV_3" title="">FPUnpackCV</a>{N}(op, fpcr);

    let alt_hp : boolean = (M == 16) &amp;&amp; (fpcr.AHP == '1');

    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        if alt_hp then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{M}(sign);
        elsif fpcr.DN == '1' then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{M}(fpcr);
        else
            result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{M, N}(op);
        end;
        if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || alt_hp then
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>,fpcr);
        end;
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then
        if alt_hp then
            result = sign::Ones{M-1};
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
        else
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{M}(sign);
        end;
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{M}(sign);
    else
        result = <a href="shared_pseudocode.html#func_FPRoundCV_4" title="">FPRoundCV</a>{M}(value, fpcr, rounding);
        FPProcessDenorm(fptype, N, fpcr);

    end;
    return result;
end;

// FPConvert()
// ===========

func <a id="func_FPConvert_4"/>FPConvert{M, N}(op : bits(N), fpcr : FPCR_Type) =&gt; bits(M)
begin
    return <a href="shared_pseudocode.html#func_FPConvert_5" title="">FPConvert</a>{M, N}(op, fpcr, <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr));
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpconvertnan.FPConvertNaN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpconvertnan/FPConvertNaN</h3>
      <p class="pseudocode">// FPConvertNaN()
// ==============
// Converts a NaN of one floating-point type to another

func <a id="func_FPConvertNaN_3"/>FPConvertNaN{M, N}(op : bits(N)) =&gt; bits(M)
begin
    assert N IN {16,32,64};
    assert M IN {16,32,64};
    var result : bits(M);
    var frac : bits(51);

    let sign : bit = op[N-1];

    // Unpack payload from input NaN
    case N of
        when 64 =&gt; frac = op[50:0];
        when 32 =&gt; frac = op[21:0]::Zeros{29};
        when 16 =&gt; frac = op[8:0]::Zeros{42};
    end;

    // Repack payload into output NaN, while
    // converting an SNaN to a QNaN.
    case M of
        when 64 =&gt; result = sign::Ones{M-52}::frac;
        when 32 =&gt; result = sign::Ones{M-23}::frac[50:29];
        when 16 =&gt; result = sign::Ones{M-10}::frac[50:42];
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdecoderm.FPDecodeRM"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdecoderm/FPDecodeRM</h3>
      <p class="pseudocode">// FPDecodeRM()
// ============

// Decode most common AArch32 floating-point rounding encoding.

func <a id="func_FPDecodeRM_1"/>FPDecodeRM(rm : bits(2)) =&gt; <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>
begin
    var result : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>;
    case rm of
        when '00' =&gt; result = <a href="shared_pseudocode.html#enum_FPRounding_TIEAWAY" title="">FPRounding_TIEAWAY</a>; // A
        when '01' =&gt; result = <a href="shared_pseudocode.html#enum_FPRounding_TIEEVEN" title="">FPRounding_TIEEVEN</a>; // N
        when '10' =&gt; result = <a href="shared_pseudocode.html#enum_FPRounding_POSINF" title="">FPRounding_POSINF</a>;  // P
        when '11' =&gt; result = <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a>;  // M
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdecoderounding.FPDecodeRounding"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdecoderounding/FPDecodeRounding</h3>
      <p class="pseudocode">// FPDecodeRounding()
// ==================

// Decode floating-point rounding mode and common AArch64 encoding.

func <a id="func_FPDecodeRounding_1"/>FPDecodeRounding(rmode : bits(2)) =&gt; <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>
begin
    case rmode of
        when '00' =&gt; return <a href="shared_pseudocode.html#enum_FPRounding_TIEEVEN" title="">FPRounding_TIEEVEN</a>; // N
        when '01' =&gt; return <a href="shared_pseudocode.html#enum_FPRounding_POSINF" title="">FPRounding_POSINF</a>;  // P
        when '10' =&gt; return <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a>;  // M
        when '11' =&gt; return <a href="shared_pseudocode.html#enum_FPRounding_ZERO" title="">FPRounding_ZERO</a>;    // Z
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdefaultnan.FPDefaultNaN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdefaultnan/FPDefaultNaN</h3>
      <p class="pseudocode">// FPDefaultNaN()
// ==============

func <a id="func_FPDefaultNaN_2"/>FPDefaultNaN{N}(fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let E : integer{} = (if N == 16 then 5 else (if N == 32 then 8 else 11));
    let F : integer{} = N - (E + 1);
    let sign : bit = if IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then fpcr.AH else '0';

    let exp : bits(E)  = Ones{};
    let frac : bits(F) = '1'::Zeros{F-1};
    return sign :: exp :: frac;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdiv.FPDiv"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdiv/FPDiv</h3>
      <p class="pseudocode">// FPDiv()
// =======

func <a id="func_FPDiv_4"/>FPDiv{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);
    var (done,result) : (boolean, bits(N)) = <a href="shared_pseudocode.html#func_FPProcessNaNs_6" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr);

    if !done then
        let inf1 : boolean  = type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>;
        let inf2 : boolean  = type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>;
        let zero1 : boolean = type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>;
        let zero2 : boolean = type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>;

        if (inf1 &amp;&amp; inf2) || (zero1 &amp;&amp; zero2) then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{N}(fpcr);
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
        elsif inf1 || zero2 then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign1 XOR sign2);
            if !inf1 then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_DivideByZero" title="">FPExc_DivideByZero</a>, fpcr); end;
        elsif zero1 || inf2 then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign1 XOR sign2);
        else
            result = <a href="shared_pseudocode.html#func_FPRound_3" title="">FPRound</a>{N}(value1/value2, fpcr);
        end;

        if !zero2 then
            FPProcessDenorms(type1, type2, N, fpcr);
        end;
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdot.FPDot"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdot/FPDot</h3>
      <p class="pseudocode">// FPDot()
// =======
// Calculates single-precision result of 2-way 16-bit floating-point dot-product
// with a single rounding.
// The 'fpcr' argument supplies the FPCR control bits and 'isbfloat16'
// determines whether input operands are BFloat16 or half-precision type.
// and 'fpexc' controls the generation of floating-point exceptions.

func <a id="func_FPDot_6"/>FPDot(op1_a : bits(16), op1_b : bits(16), op2_a : bits(16),
           op2_b : bits(16), fpcr : FPCR_Type, isbfloat16 : boolean) =&gt; bits(32)
begin
    let fpexc : boolean = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#func_FPDot_7" title="">FPDot</a>(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
end;

func <a id="func_FPDot_7"/>FPDot(op1_a : bits(16), op1_b : bits(16), op2_a : bits(16),
           op2_b : bits(16), fpcr_in : FPCR_Type, isbfloat16 : boolean, fpexc : boolean) =&gt; bits(32)
begin
    var fpcr : FPCR_Type = fpcr_in;
    var result : bits(32);
    var done : boolean;
    fpcr.AHP = '0';           // Ignore alternative half-precision option
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);

    let (type1_a,sign1_a,value1_a) = <a href="shared_pseudocode.html#func_FPUnpackBase_5" title="">FPUnpackBase</a>{16}(op1_a, fpcr, fpexc, isbfloat16);
    let (type1_b,sign1_b,value1_b) = <a href="shared_pseudocode.html#func_FPUnpackBase_5" title="">FPUnpackBase</a>{16}(op1_b, fpcr, fpexc, isbfloat16);
    let (type2_a,sign2_a,value2_a) = <a href="shared_pseudocode.html#func_FPUnpackBase_5" title="">FPUnpackBase</a>{16}(op2_a, fpcr, fpexc, isbfloat16);
    let (type2_b,sign2_b,value2_b) = <a href="shared_pseudocode.html#func_FPUnpackBase_5" title="">FPUnpackBase</a>{16}(op2_b, fpcr, fpexc, isbfloat16);

    let inf1_a = (type1_a == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>); let zero1_a = (type1_a == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
    let inf1_b = (type1_b == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>); let zero1_b = (type1_b == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
    let inf2_a = (type2_a == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>); let zero2_a = (type2_a == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
    let inf2_b = (type2_b == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>); let zero2_b = (type2_b == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs4_10" title="">FPProcessNaNs4</a>(type1_a, type1_b, type2_a, type2_b,
                                   op1_a, op1_b, op2_a, op2_b, fpcr, fpexc);

    if !done then
        // Determine sign and type products will have if it does not cause an Invalid
        // Operation.
        let signPa = sign1_a XOR sign2_a;
        let signPb = sign1_b XOR sign2_b;
        let infPa  = inf1_a || inf2_a;
        let infPb  = inf1_b || inf2_b;
        let zeroPa = zero1_a || zero2_a;
        let zeroPb = zero1_b || zero2_b;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero
        // by infinity and additions of opposite-signed infinities.
        let invalidop = ((inf1_a &amp;&amp; zero2_a) || (zero1_a &amp;&amp; inf2_a) ||
                         (inf1_b &amp;&amp; zero2_b) || (zero1_b &amp;&amp; inf2_b) ||
                         (infPa &amp;&amp; infPb &amp;&amp; signPa != signPb));

        if invalidop then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{32}(fpcr);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;

       // Other cases involving infinities produce an infinity of the same sign.
        elsif (infPa &amp;&amp; signPa == '0') || (infPb &amp;&amp; signPb == '0') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}('0');
        elsif (infPa &amp;&amp; signPa == '1') || (infPb &amp;&amp; signPb == '1') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}('1');

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroPa &amp;&amp; zeroPb &amp;&amp; signPa == signPb then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(signPa);

        // Otherwise calculate fused sum of products and round it.
        else
            let result_value = (value1_a * value2_a) + (value1_b * value2_b);
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                let result_sign = if rounding == <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(result_sign);
            else
                result = <a href="shared_pseudocode.html#func_FPRound_5" title="">FPRound</a>{32}(result_value, fpcr, rounding, fpexc);
            end;
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdot.FPDotAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdot/FPDotAdd</h3>
      <p class="pseudocode">// FPDotAdd()
// ==========
// Half-precision 2-way dot-product and add to single-precision.

func <a id="func_FPDotAdd_6"/>FPDotAdd(addend : bits(32), op1_a : bits(16), op1_b : bits(16),
              op2_a : bits(16), op2_b : bits(16), fpcr : FPCR_Type) =&gt; bits(32)
begin
    var prod : bits(32);
    let isbfloat16 : boolean = FALSE;
    let fpexc : boolean      = TRUE;     // Generate floating-point exceptions
    prod = <a href="shared_pseudocode.html#func_FPDot_7" title="">FPDot</a>(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
    let result : bits(32) = <a href="shared_pseudocode.html#func_FPAdd_4" title="">FPAdd</a>{}(addend, prod, fpcr, fpexc);

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdot.FPDotAdd_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdot/FPDotAdd_ZA</h3>
      <p class="pseudocode">// FPDotAdd_ZA()
// =============
// Half-precision 2-way dot-product and add to single-precision
// for SME ZA-targeting instructions.

func <a id="func_FPDotAdd_ZA_6"/>FPDotAdd_ZA(addend : bits(32), op1_a : bits(16), op1_b : bits(16),
                 op2_a : bits(16), op2_b : bits(16), fpcr_in : FPCR_Type) =&gt; bits(32)
begin
    var fpcr : FPCR_Type = fpcr_in;
    var prod : bits(32);
    let isbfloat16 : boolean = FALSE;
    let fpexc : boolean      = FALSE; // Do not generate floating-point exceptions
    fpcr.DN = '1';                  // Generate default NaN values
    prod = <a href="shared_pseudocode.html#func_FPDot_7" title="">FPDot</a>(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
    let result : bits(32) = <a href="shared_pseudocode.html#func_FPAdd_4" title="">FPAdd</a>{}(addend, prod, fpcr, fpexc);

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpexc.FPExc"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpexc/FPExc</h3>
      <p class="pseudocode">// FPExc
// =====

type <a id="type_FPExc"/>FPExc of enumeration {<a id="enum_FPExc_InvalidOp"/>FPExc_InvalidOp, <a id="enum_FPExc_DivideByZero"/>FPExc_DivideByZero, <a id="enum_FPExc_Overflow"/>FPExc_Overflow,
                           <a id="enum_FPExc_Underflow"/>FPExc_Underflow, <a id="enum_FPExc_Inexact"/>FPExc_Inexact, <a id="enum_FPExc_InputDenorm"/>FPExc_InputDenorm};</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpinfinity.FPInfinity"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpinfinity/FPInfinity</h3>
      <p class="pseudocode">// FPInfinity()
// ============

func <a id="func_FPInfinity_2"/>FPInfinity{N}(sign : bit) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let E : integer{}  = (if N == 16 then 5 else (if N == 32 then 8 else 11));
    let F : integer{}  = N - (E + 1);
    let exp : bits(E)  = Ones{};
    let frac : bits(F) = Zeros{};
    return sign :: exp :: frac;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmatmul.FPMatMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmatmul/FPMatMulAdd</h3>
      <p class="pseudocode">// FPMatMulAdd()
// =============
//
// Floating point matrix multiply and add to same precision matrix
// result[2, 2] = addend[2, 2] + (op1[2, 2] * op2[2, 2])

func FPMatMulAdd{N}(addend : bits(N), op1 : bits(N), op2 : bits(N),
                    esize : <a href="shared_pseudocode.html#ESize" title="type ESize">ESize</a>, fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N == esize * 2 * 2;
    var result : bits(N);
    var prod0, prod1, sum : bits(esize);

    for i = 0 to 1 do
        for j = 0 to 1 do
            sum   = addend[(2*i + j)*:esize];
            prod0 = FPMul{esize}(op1[(2*i + 0)*:esize],
                          op2[(2*j + 0)*:esize], fpcr);
            prod1 = FPMul{esize}(op1[(2*i + 1)*:esize],
                          op2[(2*j + 1)*:esize], fpcr);
            sum   = FPAdd{esize}(sum, FPAdd{esize}(prod0, prod1, fpcr), fpcr);
            result[(2*i + j)*:esize] = sum;
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmatmulh.FPMatMulAddH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmatmulh/FPMatMulAddH</h3>
      <p class="pseudocode">// FPMatMulAddH()
// ==============
// Half-precision matrix multiply and add to single-precision matrix
// result[2, 2] = addend[2, 2] + (op1[2, 4] * op2[4, 2])

func <a id="func_FPMatMulAddH_5"/>FPMatMulAddH{N}(addend : bits(N), op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N == 128;
    let M : integer{} = 32;
    var result : bits(N);

    let isbfloat16 : boolean = FALSE;
    for i = 0 to 1 do
        for j = 0 to 1 do
            var sum : bits(M) = addend[(2*i + j)*:M];
            var prod : array[[2]] of bits(M);
            for k = 0 to 1 do
                let elt1_a : bits(M DIV 2) = op1[(4*i + 2*k + 0)*:(M DIV 2)];
                let elt1_b : bits(M DIV 2) = op1[(4*i + 2*k + 1)*:(M DIV 2)];
                let elt2_a : bits(M DIV 2) = op2[(4*j + 2*k + 0)*:(M DIV 2)];
                let elt2_b : bits(M DIV 2) = op2[(4*j + 2*k + 1)*:(M DIV 2)];
                prod[[k]] = <a href="shared_pseudocode.html#func_FPDot_6" title="">FPDot</a>(elt1_a, elt1_b, elt2_a, elt2_b, fpcr, isbfloat16);
            end;
            sum = <a href="shared_pseudocode.html#func_FPAdd_4" title="">FPAdd</a>{M}(sum, <a href="shared_pseudocode.html#func_FPAdd_4" title="">FPAdd</a>{M}(prod[[0]], prod[[1]], fpcr), fpcr);
            result[(2*i + j)*:M] = sum;
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmax.FPMax"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmax/FPMax</h3>
      <p class="pseudocode">// FPMax()
// =======

func <a id="func_FPMax_4"/>FPMax{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_FPMax_6" title="">FPMax</a>{N}(op1, op2, fpcr, altfp, fpexc);
end;

// FPMax()
// =======

func <a id="func_FPMax_5"/>FPMax{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type, altfp : boolean) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_FPMax_6" title="">FPMax</a>{N}(op1, op2, fpcr, altfp, fpexc);
end;

// FPMax()
// =======
// Compare two inputs and return the larger value after rounding. The
// 'fpcr' argument supplies the FPCR control bits and 'altfp' determines
// if the function should use alternative floating-point behavior.

func <a id="func_FPMax_6"/>FPMax{N}(op1 : bits(N), op2 : bits(N), fpcr_in : FPCR_Type,
              altfp : boolean, fpexc : boolean) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var done : boolean;
    var result : bits(N);
    var fpcr : FPCR_Type = fpcr_in;
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op1, fpcr, fpexc);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op2, fpcr, fpexc);

    if altfp &amp;&amp; type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> &amp;&amp; sign1 != sign2 then
        // Alternate handling of zeros with differing sign
        return <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign2);
    elsif altfp &amp;&amp; (type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>}) then
        // Alternate handling of NaN inputs
        if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        return (if type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign2) else op2);
    end;

    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_7" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr, fpexc);
    if !done then
        var fptype : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>;
        var sign : bit;
        var value : real;
        if value1 &gt; value2 then
            (fptype,sign,value) = (type1,sign1,value1);
        else
            (fptype,sign,value) = (type2,sign2,value2);
        end;
        if fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign);
        elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
            sign = sign1 AND sign2;         // Use most positive sign
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
        else
            // The use of FPRound() covers the case where there is a trapped underflow exception
            // for a denormalized number even though the result is exact.
            let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
            if altfp then    // Denormal output is not flushed to zero
                fpcr.FZ = '0';
                fpcr.FZ16 = '0';
            end;

            result = <a href="shared_pseudocode.html#func_FPRound_5" title="">FPRound</a>{N}(value, fpcr, rounding, fpexc);
        end;
        if fpexc then FPProcessDenorms(type1, type2, N, fpcr); end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmaxnormal.FPMaxNormal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmaxnormal/FPMaxNormal</h3>
      <p class="pseudocode">// FPMaxNormal()
// =============

func <a id="func_FPMaxNormal_2"/>FPMaxNormal{N}(sign : bit) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let E : integer{}  = (if N == 16 then 5 else (if N == 32 then 8 else 11));
    let F : integer{}  = N - (E + 1);
    let exp : bits(E)  = Ones{E-1}::'0';
    let frac : bits(F) = Ones{};
    return sign :: exp :: frac;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmaxnum.FPMaxNum"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmaxnum/FPMaxNum</h3>
      <p class="pseudocode">// FPMaxNum()
// ==========

func <a id="func_FPMaxNum_4"/>FPMaxNum{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_FPMaxNum_5" title="">FPMaxNum</a>{N}(op1, op2, fpcr, fpexc);
end;

// FPMaxNum()
// ==========

func <a id="func_FPMaxNum_5"/>FPMaxNum{N}(op1_in : bits(N), op2_in : bits(N), fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var op1 : bits(N) = op1_in;
    var op2 : bits(N) = op2_in;
    let (type1,-,-) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op1, fpcr, fpexc);
    let (type2,-,-) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op2, fpcr, fpexc);

    let type1_nan : boolean = type1 IN {<a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>, <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>};
    let type2_nan : boolean = type2 IN {<a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>, <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>};
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';

    if !(altfp &amp;&amp; type1_nan &amp;&amp; type2_nan) then
        // Treat a single quiet-NaN as -Infinity.
        if type1 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> &amp;&amp; type2 != <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
            op1 = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}('1');
        elsif type1 != <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
            op2 = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}('1');
        end;
    end;

    let altfmaxfmin : boolean = FALSE;    // Restrict use of FMAX/FMIN NaN propagation rules
    let result : bits(N) = <a href="shared_pseudocode.html#func_FPMax_5" title="">FPMax</a>{}(op1, op2, fpcr, altfmaxfmin, fpexc);

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmerge.IsMerging"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmerge/IsMerging</h3>
      <p class="pseudocode">// IsMerging()
// ===========
// Returns TRUE if the output elements other than the lowest are taken from
// the destination register.

func <a id="func_IsMerging_1"/>IsMerging(fpcr : FPCR_Type) =&gt; boolean
begin
    let nep : bit = (if IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.SM == '1' &amp;&amp;
                        !<a href="shared_pseudocode.html#func_IsFullA64Enabled_0" title="">IsFullA64Enabled</a>() then '0' else fpcr.NEP);
    return IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; nep == '1';
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmin.FPMin"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmin/FPMin</h3>
      <p class="pseudocode">// FPMin()
// =======

func <a id="func_FPMin_4"/>FPMin{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_FPMin_6" title="">FPMin</a>{N}(op1, op2, fpcr, altfp, fpexc);
end;

// FPMin()
// =======

func <a id="func_FPMin_5"/>FPMin{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type, altfp : boolean) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_FPMin_6" title="">FPMin</a>{N}(op1, op2, fpcr, altfp, fpexc);
end;

// FPMin()
// =======
// Compare two inputs and return the smaller operand after rounding. The
// 'fpcr' argument supplies the FPCR control bits and 'altfp' determines
// if the function should use alternative floating-point behavior.

func <a id="func_FPMin_6"/>FPMin{N}(op1 : bits(N), op2 : bits(N), fpcr_in : FPCR_Type,
              altfp : boolean, fpexc : boolean) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var done : boolean;
    var result : bits(N);
    var fpcr : FPCR_Type = fpcr_in;
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op1, fpcr, fpexc);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op2, fpcr, fpexc);

    if altfp &amp;&amp; type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> &amp;&amp; sign1 != sign2 then
        // Alternate handling of zeros with differing sign
        return <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign2);
    elsif altfp &amp;&amp; (type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>}) then
        // Alternate handling of NaN inputs
        if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        return (if type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign2) else op2);
    end;

    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_7" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr, fpexc);
    if !done then
        var fptype : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>;
        var sign : bit;
        var value : real;
        var rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>;
        if value1 &lt; value2 then
            (fptype,sign,value) = (type1,sign1,value1);
        else
            (fptype,sign,value) = (type2,sign2,value2);
        end;
        if fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign);
        elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
            sign = sign1 OR sign2;              // Use most negative sign
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
        else
            // The use of FPRound() covers the case where there is a trapped underflow exception
            // for a denormalized number even though the result is exact.
            rounding = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
            if altfp then    // Denormal output is not flushed to zero
                fpcr.FZ = '0';
                fpcr.FZ16 = '0';
            end;

            result = <a href="shared_pseudocode.html#func_FPRound_5" title="">FPRound</a>{N}(value, fpcr, rounding, fpexc);
        end;

        if fpexc then FPProcessDenorms(type1, type2, N, fpcr); end;
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpminnum.FPMinNum"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpminnum/FPMinNum</h3>
      <p class="pseudocode">// FPMinNum()
// ==========

func <a id="func_FPMinNum_4"/>FPMinNum{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;
    return <a href="shared_pseudocode.html#func_FPMinNum_5" title="">FPMinNum</a>{N}(op1, op2, fpcr, fpexc);
end;

// FPMinNum()
// ==========

func <a id="func_FPMinNum_5"/>FPMinNum{N}(op1_in : bits(N), op2_in : bits(N), fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var op1 : bits(N) = op1_in;
    var op2 : bits(N) = op2_in;
    let (type1,-,-) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op1, fpcr, fpexc);
    let (type2,-,-) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op2, fpcr, fpexc);

    let type1_nan : boolean = type1 IN {<a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>, <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>};
    let type2_nan : boolean = type2 IN {<a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>, <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>};
    let altfp : boolean     = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp;
                                                                 fpcr.AH == '1';

    if !(altfp &amp;&amp; type1_nan &amp;&amp; type2_nan) then
        // Treat a single quiet-NaN as +Infinity.
        if type1 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> &amp;&amp; type2 != <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
            op1 = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}('0');
        elsif type1 != <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
            op2 = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}('0');
        end;
    end;

    let altfmaxfmin : boolean = FALSE;    // Restrict use of FMAX/FMIN NaN propagation rules
    let result : bits(N) = <a href="shared_pseudocode.html#func_FPMin_5" title="">FPMin</a>{}(op1, op2, fpcr, altfmaxfmin, fpexc);

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmul.FPMul"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmul/FPMul</h3>
      <p class="pseudocode">// FPMul()
// =======

func <a id="func_FPMul_4"/>FPMul{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);
    var (done,result) : (boolean, bits(N)) = <a href="shared_pseudocode.html#func_FPProcessNaNs_6" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr);
    if !done then
        let inf1 : boolean  = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2 : boolean  = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{N}(fpcr);
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign1 XOR sign2);
        elsif zero1 || zero2 then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign1 XOR sign2);
        else
            result = <a href="shared_pseudocode.html#func_FPRound_3" title="">FPRound</a>{N}(value1*value2, fpcr);
        end;

        FPProcessDenorms(type1, type2, N, fpcr);

    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladd.FPMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladd/FPMulAdd</h3>
      <p class="pseudocode">// FPMulAdd()
// ==========

func <a id="func_FPMulAdd_5"/>FPMulAdd{N}(addend : bits(N), op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#func_FPMulAdd_6" title="">FPMulAdd</a>{N}(addend, op1, op2, fpcr, fpexc);
end;

// FPMulAdd()
// ==========
//
// Calculates addend + op1*op2 with a single rounding. The 'fpcr' argument
// supplies the FPCR control bits, and 'fpexc' controls the generation of
// floating-point exceptions.

func <a id="func_FPMulAdd_6"/>FPMulAdd{N}(addend : bits(N), op1 : bits(N), op2 : bits(N),
                 fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(N)
begin
    assert N IN {16,32,64};

    let (typeA,signA,valueA) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(addend, fpcr, fpexc);
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op1, fpcr, fpexc);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op2, fpcr, fpexc);
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
    let inf1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>); let zero1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
    let inf2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>); let zero2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

    var (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs3_9" title="">FPProcessNaNs3</a>{N}(typeA, type1, type2, addend, op1, op2, fpcr, fpexc);

    if !(IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1') then
        if typeA == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> &amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{N}(fpcr);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        end;
    end;

    if !done then
        let infA : boolean = (typeA == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zeroA : boolean = (typeA == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

        // Determine sign and type product will have if it does not cause an
        // Invalid Operation.
        let signP : bit = sign1 XOR sign2;
        let infP : boolean  = inf1 || inf2;
        let zeroP : boolean = zero1 || zero2;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero
        // by infinity and additions of opposite-signed infinities.
        let invalidop : boolean = ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) ||
                                    (infA &amp;&amp; infP &amp;&amp; signA != signP));

        if invalidop then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{N}(fpcr);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}('0');
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}('1');

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(signA);

        // Otherwise calculate numerical result and round it.
        else
            let result_value : real = valueA + (value1 * value2);
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                let result_sign : bit = if rounding == <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(result_sign);
            else
                result = <a href="shared_pseudocode.html#func_FPRound_5" title="">FPRound</a>{N}(result_value, fpcr, rounding, fpexc);
            end;
        end;

        if !invalidop &amp;&amp; fpexc then
            FPProcessDenorms3(typeA, type1, type2, N, fpcr);
        end;
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladd.FPMulAdd_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladd/FPMulAdd_ZA</h3>
      <p class="pseudocode">// FPMulAdd_ZA()
// =============
// Calculates addend + op1*op2 with a single rounding for SME ZA-targeting
// instructions.

func <a id="func_FPMulAdd_ZA_5"/>FPMulAdd_ZA{N}(addend : bits(N), op1 : bits(N), op2 : bits(N), fpcr_in : FPCR_Type) =&gt; bits(N)
begin
    var fpcr : FPCR_Type = fpcr_in;
    let fpexc : boolean  = FALSE; // Do not generate floating-point exceptions
    fpcr.DN = '1';                // Generate default NaN values
    return <a href="shared_pseudocode.html#func_FPMulAdd_6" title="">FPMulAdd</a>{N}(addend, op1, op2, fpcr, fpexc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladdh.FPMulAddH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladdh/FPMulAddH</h3>
      <p class="pseudocode">// FPMulAddH()
// ===========
// Calculates addend + op1*op2.

func <a id="func_FPMulAddH_4"/>FPMulAddH(addend : bits(32), op1 : bits(16), op2 : bits(16), fpcr : FPCR_Type) =&gt; bits(32)
begin
    let fpexc : boolean = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#func_FPMulAddH_5" title="">FPMulAddH</a>(addend, op1, op2, fpcr, fpexc);
end;

// FPMulAddH()
// ===========
// Calculates addend + op1*op2.

func <a id="func_FPMulAddH_5"/>FPMulAddH(addend : bits(32), op1 : bits(16), op2 : bits(16),
               fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(32)
begin

    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
    let (typeA,signA,valueA)  = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{32}(addend, fpcr, fpexc);
    let (type1,sign1,value1)  = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{16}(op1, fpcr, fpexc);
    let (type2,sign2,value2)  = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{16}(op2, fpcr, fpexc);
    let inf1 = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>); let zero1 = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
    let inf2 = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>); let zero2 = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

    var (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs3H_8" title="">FPProcessNaNs3H</a>(typeA, type1, type2, addend, op1, op2, fpcr, fpexc);

    if !(IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1') then
        if typeA == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> &amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{32}(fpcr);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        end;
    end;

    if !done then
        let infA = (typeA == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>); let zeroA = (typeA == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

        // Determine sign and type product will have if it does not cause an
        // Invalid Operation.
        let signP = sign1 XOR sign2;
        let infP  = inf1 || inf2;
        let zeroP = zero1 || zero2;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero by infinity and
        // additions of opposite-signed infinities.
        let invalidop = (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP);

        if invalidop then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{32}(fpcr);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;

        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}('0');
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{32}('1');

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(signA);

        // Otherwise calculate numerical result and round it.
        else
            let result_value = valueA + (value1 * value2);
            if result_value == 0.0 then // Sign of exact zero result depends on rounding mode
                let result_sign = if rounding == <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{32}(result_sign);
            else
                result = <a href="shared_pseudocode.html#func_FPRound_5" title="">FPRound</a>{32}(result_value, fpcr, rounding, fpexc);
            end;
        end;

        if !invalidop &amp;&amp; fpexc then
            FPProcessDenorm(typeA, 32, fpcr);
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladdh.FPMulAddH_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladdh/FPMulAddH_ZA</h3>
      <p class="pseudocode">// FPMulAddH_ZA()
// ==============
// Calculates addend + op1*op2 for SME2 ZA-targeting instructions.

func <a id="func_FPMulAddH_ZA_4"/>FPMulAddH_ZA(addend : bits(32), op1 : bits(16), op2 : bits(16),
                  fpcr_in : FPCR_Type) =&gt; bits(32)
begin
    var fpcr : FPCR_Type = fpcr_in;
    let fpexc : boolean = FALSE; // Do not generate floating-point exceptions
    fpcr.DN = '1';               // Generate default NaN values
    return <a href="shared_pseudocode.html#func_FPMulAddH_5" title="">FPMulAddH</a>(addend, op1, op2, fpcr, fpexc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladdh.FPProcessNaNs3H"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladdh/FPProcessNaNs3H</h3>
      <p class="pseudocode">// FPProcessNaNs3H()
// =================

func <a id="func_FPProcessNaNs3H_8"/>FPProcessNaNs3H(type1 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type2 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type3 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>,
                     op1 : bits(32), op2 : bits(16), op3 : bits(16),
                     fpcr : FPCR_Type, fpexc : boolean) =&gt; (boolean, bits(32))
begin

    var result : bits(32);
    var type_nan : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>;
    // When TRUE, use alternative NaN propagation rules.
    let altfp : boolean   = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    let op1_nan : boolean = type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>};
    let op2_nan : boolean = type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>};
    let op3_nan : boolean = type3 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>};
    if altfp then
        if (type1 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || type3 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>) then
            type_nan = <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>;
        else
            type_nan = <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>;
        end;
    end;

    var done : boolean;
    if altfp &amp;&amp; op1_nan &amp;&amp; op2_nan &amp;&amp; op3_nan then          // [n] register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type_nan, op2, fpcr, fpexc));
    elsif altfp &amp;&amp; op2_nan &amp;&amp; (op1_nan || op3_nan) then     // [n] register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type_nan, op2, fpcr, fpexc));
    elsif altfp &amp;&amp; op3_nan &amp;&amp; op1_nan then                  // [m] register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type_nan, op3, fpcr, fpexc));
    elsif type1 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{32}(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type2, op2, fpcr, fpexc));
    elsif type3 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type3, op3, fpcr, fpexc));
    elsif type1 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{32}(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type2, op2, fpcr, fpexc));
    elsif type3 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type3, op3, fpcr, fpexc));
    else
        done = FALSE; result = Zeros{32}; // 'Don't care' result
    end;
    return (done, result);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmulx.FPMulX"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmulx/FPMulX</h3>
      <p class="pseudocode">// FPMulX()
// ========

func <a id="func_FPMulX_4"/>FPMulX{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var result : bits(N);
    var done : boolean;
    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op1, fpcr);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op2, fpcr);

    (done,result) = <a href="shared_pseudocode.html#func_FPProcessNaNs_6" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr);
    if !done then
        let inf1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#func_FPTwo_2" title="">FPTwo</a>{N}(sign1 XOR sign2);
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign1 XOR sign2);
        elsif zero1 || zero2 then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign1 XOR sign2);
        else
            result = <a href="shared_pseudocode.html#func_FPRound_3" title="">FPRound</a>{N}(value1*value2, fpcr);
        end;

        FPProcessDenorms(type1, type2, N, fpcr);

    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpneg.FPNeg"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpneg/FPNeg</h3>
      <p class="pseudocode">// FPNeg()
// =======

func <a id="func_FPNeg_3"/>FPNeg{N}(op : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    if !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; IsFeatureImplemented(FEAT_AFP) then
        if fpcr.AH == '1' then
            let (fptype, -, -) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op, fpcr, FALSE);
            if fptype IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>} then
                return op;        // When fpcr.AH=1, sign of NaN has no consequence
            end;
        end;
    end;
    return NOT(op[N-1]) :: op[N-2:0];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fponepointfive.FPOnePointFive"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fponepointfive/FPOnePointFive</h3>
      <p class="pseudocode">// FPOnePointFive()
// ================

func <a id="func_FPOnePointFive_2"/>FPOnePointFive{N}(sign : bit) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let E : integer{}  = (if N == 16 then 5 else (if N == 32 then 8 else 11));
    let F : integer{}  = N - (E + 1);
    let exp : bits(E)  = '0'::Ones{E-1};
    let frac : bits(F) = '1'::Zeros{F-1};
    let result : bits((F + E) + 1) = sign :: exp :: frac;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessdenorms.FPProcessDenorm"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessdenorms/FPProcessDenorm</h3>
      <p class="pseudocode">// FPProcessDenorm()
// =================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

func FPProcessDenorm(fptype : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, N : integer, fpcr : FPCR_Type)
begin
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; fptype == <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a> then
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InputDenorm" title="">FPExc_InputDenorm</a>, fpcr);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessdenorms.FPProcessDenorms"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessdenorms/FPProcessDenorms</h3>
      <p class="pseudocode">// FPProcessDenorms()
// ==================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

func FPProcessDenorms(type1 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type2 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, N : integer, fpcr : FPCR_Type)
begin
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; (type1 == <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a> || type2 == <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a>) then
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InputDenorm" title="">FPExc_InputDenorm</a>, fpcr);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessdenorms.FPProcessDenorms3"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessdenorms/FPProcessDenorms3</h3>
      <p class="pseudocode">// FPProcessDenorms3()
// ===================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

func FPProcessDenorms3(type1 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type2 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type3 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, N : integer,
                       fpcr : FPCR_Type)
begin
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; (type1 == <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a> || type2 == <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a> ||
        type3 == <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a>) then
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InputDenorm" title="">FPExc_InputDenorm</a>, fpcr);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessdenorms.FPProcessDenorms4"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessdenorms/FPProcessDenorms4</h3>
      <p class="pseudocode">// FPProcessDenorms4()
// ===================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

func FPProcessDenorms4(type1 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type2 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type3 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type4 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>,
                       N : integer, fpcr : FPCR_Type)
begin
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; (type1 == <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a> || type2 == <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a> ||
        type3 == <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a> || type4 == <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a>) then
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InputDenorm" title="">FPExc_InputDenorm</a>, fpcr);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessexception.FPProcessException"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessexception/FPProcessException</h3>
      <p class="pseudocode">// FPProcessException()
// ====================
//
// The 'fpcr' argument supplies FPCR control bits. Status information is
// updated directly in the FPSR where appropriate.

func FPProcessException(except : <a href="shared_pseudocode.html#type_FPExc" title="">FPExc</a>, fpcr : FPCR_Type)
begin
    var cumul : integer;
    // Determine the cumulative exception bit number
    case except of
        when <a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a> =&gt;     cumul = 0;
        when <a href="shared_pseudocode.html#enum_FPExc_DivideByZero" title="">FPExc_DivideByZero</a> =&gt;  cumul = 1;
        when <a href="shared_pseudocode.html#enum_FPExc_Overflow" title="">FPExc_Overflow</a> =&gt;      cumul = 2;
        when <a href="shared_pseudocode.html#enum_FPExc_Underflow" title="">FPExc_Underflow</a> =&gt;     cumul = 3;
        when <a href="shared_pseudocode.html#enum_FPExc_Inexact" title="">FPExc_Inexact</a> =&gt;       cumul = 4;
        when <a href="shared_pseudocode.html#enum_FPExc_InputDenorm" title="">FPExc_InputDenorm</a> =&gt;   cumul = 7;
    end;
    let enable : integer = cumul + 8;
    if (fpcr[enable] == '1' &amp;&amp; (!IsFeatureImplemented(FEAT_SME) || PSTATE.SM == '0' ||
          <a href="shared_pseudocode.html#func_IsFullA64Enabled_0" title="">IsFullA64Enabled</a>())) then
        // Trapping of the exception enabled.
        // It is IMPLEMENTATION DEFINED whether the enable bit may be set at all,
        // and if so then how exceptions and in what order that they may be
        // accumulated before calling FPTrappedException().
        var accumulated_exceptions : bits(8) = <a href="shared_pseudocode.html#func_GetAccumulatedFPExceptions_0" title="">GetAccumulatedFPExceptions</a>();
        accumulated_exceptions[cumul] = '1';
        if ImpDefBool("Support trapping of floating-point exceptions") then
            if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
                AArch32_FPTrappedException(accumulated_exceptions);
            else
                let is_ase : boolean = <a href="shared_pseudocode.html#func_IsASEInstruction_0" title="">IsASEInstruction</a>();
                AArch64_FPTrappedException(is_ase, accumulated_exceptions);
            end;
        else
            // The exceptions generated by this instruction are accumulated by the PE and
            // FPTrappedException is called later during its execution, before the next
            // instruction is executed. This field is cleared at the start of each FP instruction.
            SetAccumulatedFPExceptions(accumulated_exceptions);
        end;
    elsif <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        // Set the cumulative exception bit
        FPSCR()[cumul] = '1';
    else
        // Set the cumulative exception bit
        FPSR()[cumul] = '1';
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessnan.FPProcessNaN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessnan/FPProcessNaN</h3>
      <p class="pseudocode">// FPProcessNaN()
// ==============

func <a id="func_FPProcessNaN_4"/>FPProcessNaN{N}(fptype : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, op : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;   // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(fptype, op, fpcr, fpexc);
end;

// FPProcessNaN()
// ==============
// Handle NaN input operands, returning the operand or default NaN value
// if fpcr.DN is selected. The 'fpcr' argument supplies the FPCR control bits.
// The 'fpexc' argument controls the generation of exceptions, regardless of
// whether 'fptype' is a signalling NaN or a quiet NaN.

func <a id="func_FPProcessNaN_5"/>FPProcessNaN{N}(fptype : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, op : bits(N), fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    assert fptype IN {<a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>, <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>};
    var topfrac : integer;

    case N of
        when 16 =&gt; topfrac =  9;
        when 32 =&gt; topfrac = 22;
        when 64 =&gt; topfrac = 51;
    end;

    var result : bits(N) = op;
    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        result[topfrac] = '1';
        if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
    end;
    if fpcr.DN == '1' then  // DefaultNaN requested
        result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{N}(fpcr);
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessnans.FPProcessNaNs"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessnans/FPProcessNaNs</h3>
      <p class="pseudocode">// FPProcessNaNs()
// ===============

func <a id="func_FPProcessNaNs_6"/>FPProcessNaNs{N}(type1 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type2 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, op1 : bits(N),
                      op2 : bits(N), fpcr : FPCR_Type) =&gt; (boolean, bits(N))
begin
    let fpexc : boolean = TRUE;     // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#func_FPProcessNaNs_7" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr, fpexc);
end;

// FPProcessNaNs()
// ===============
//
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits and 'altfmaxfmin' controls
// alternative floating-point behavior for FMAX, FMIN and variants. 'fpexc'
// controls the generation of floating-point exceptions. Status information
// is updated directly in the FPSR where appropriate.

func <a id="func_FPProcessNaNs_7"/>FPProcessNaNs{N}(type1 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type2 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, op1 : bits(N), op2 : bits(N),
                      fpcr : FPCR_Type, fpexc : boolean) =&gt; (boolean, bits(N))
begin
    assert N IN {16,32,64};
    var done : boolean;
    var result : bits(N);
    let altfp : boolean    = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    let op1_nan : boolean  = type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>};
    let op2_nan : boolean  = type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>};
    let any_snan : boolean = type1 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>;
    let type_nan : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a> = if any_snan then <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> else <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>;

    if altfp &amp;&amp; op1_nan &amp;&amp; op2_nan then
        // [n] register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type_nan, op1, fpcr, fpexc);
    elsif type1 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type2, op2, fpcr, fpexc);
    elsif type1 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type2, op2, fpcr, fpexc);
    else
        done = FALSE;  result = Zeros{N};  // 'Don't care' result
    end;
    return (done, result);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessnans3.FPProcessNaNs3"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessnans3/FPProcessNaNs3</h3>
      <p class="pseudocode">// FPProcessNaNs3()
// ================

func <a id="func_FPProcessNaNs3_8"/>FPProcessNaNs3{N}(type1 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type2 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type3 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>,
                       op1 : bits(N), op2 : bits(N), op3 : bits(N),
                       fpcr : FPCR_Type) =&gt; (boolean, bits(N))
begin
    let fpexc : boolean = TRUE;   // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#func_FPProcessNaNs3_9" title="">FPProcessNaNs3</a>{N}(type1, type2, type3, op1, op2, op3, fpcr, fpexc);
end;

// FPProcessNaNs3()
// ================
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits and 'fpexc' controls the
// generation of floating-point exceptions. Status information is updated
// directly in the FPSR where appropriate.

func <a id="func_FPProcessNaNs3_9"/>FPProcessNaNs3{N}(type1 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type2 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type3 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>,
                       op1 : bits(N), op2 : bits(N), op3 : bits(N),
                       fpcr : FPCR_Type, fpexc : boolean) =&gt; (boolean, bits(N))
begin
    assert N IN {16,32,64};
    var result : bits(N);
    let op1_nan : boolean = type1 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>};
    let op2_nan : boolean = type2 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>};
    let op3_nan : boolean = type3 IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>};

    let altfp : boolean   = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    var type_nan : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>;
    if altfp then
        if type1 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || type3 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
            type_nan = <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>;
        else
            type_nan = <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>;
        end;
    end;

    var done : boolean;
    if altfp &amp;&amp; op1_nan &amp;&amp; op2_nan &amp;&amp; op3_nan then
        // [n] register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type_nan, op2, fpcr, fpexc);
    elsif altfp &amp;&amp; op2_nan &amp;&amp; (op1_nan || op3_nan) then
        // [n] register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type_nan, op2, fpcr, fpexc);
    elsif altfp &amp;&amp; op3_nan &amp;&amp; op1_nan then
        // [m] register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type_nan, op3, fpcr, fpexc);
    elsif type1 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type2, op2, fpcr, fpexc);
    elsif type3 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type3, op3, fpcr, fpexc);
    elsif type1 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type2, op2, fpcr, fpexc);
    elsif type3 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(type3, op3, fpcr, fpexc);
    else
        done = FALSE;  result = Zeros{N};  // 'Don't care' result
    end;
    return (done, result);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessnans4.FPProcessNaNs4"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessnans4/FPProcessNaNs4</h3>
      <p class="pseudocode">// FPProcessNaNs4()
// ================
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits.
// Status information is updated directly in the FPSR where appropriate.
// The 'fpexc' controls the generation of floating-point exceptions.

func <a id="func_FPProcessNaNs4_10"/>FPProcessNaNs4(type1 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type2 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type3 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, type4 : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>,
                    op1 : bits(16), op2 : bits(16), op3 : bits(16),
                    op4 : bits(16), fpcr : FPCR_Type, fpexc : boolean) =&gt; (boolean, bits(32))
begin

    var result : bits(32);
    var done : boolean;
    // The FPCR.AH control does not affect these checks
    if type1 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type1, op1, fpcr, fpexc));
    elsif type2 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type2, op2, fpcr, fpexc));
    elsif type3 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type3, op3, fpcr, fpexc));
    elsif type4 == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type4, op4, fpcr, fpexc));
    elsif type1 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type1, op1, fpcr, fpexc));
    elsif type2 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type2, op2, fpcr, fpexc));
    elsif type3 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type3, op3, fpcr, fpexc));
    elsif type4 == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#func_FPConvertNaN_3" title="">FPConvertNaN</a>{32, 16}(<a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{16}(type4, op4, fpcr, fpexc));
    else
        done = FALSE;  result = Zeros{32};  // 'Don't care' result
    end;

    return (done, result);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprecipestimate.FPRecipEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprecipestimate/FPRecipEstimate</h3>
      <p class="pseudocode">// FPRecipEstimate()
// =================

func <a id="func_FPRecipEstimate_3"/>FPRecipEstimate{N}(operand : bits(N), fpcr_in : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var fpcr : FPCR_Type = fpcr_in;
    var result : bits(N);
    var overflow_to_inf : boolean;
    // When using alternative floating-point behavior, do not generate
    // floating-point exceptions, flush denormal input and output to zero,
    // and use RNE rounding mode.
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    let fpexc : boolean = !altfp;
    if altfp then fpcr.[FIZ,FZ] = '11'; end;
    if altfp then fpcr.RMode    = '00'; end;

    let (fptype,sign,value) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(operand, fpcr, fpexc);

    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);
    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(fptype, operand, fpcr, fpexc);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign);
        if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_DivideByZero" title="">FPExc_DivideByZero</a>, fpcr); end;
    elsif (
            (N == 16 &amp;&amp; Abs(value) &lt; 2.0^-16) ||
            (N == 32 &amp;&amp; Abs(value) &lt; 2.0^-128) ||
            (N == 64 &amp;&amp; Abs(value) &lt; 2.0^-1024)
          ) then
        case rounding of
            when <a href="shared_pseudocode.html#enum_FPRounding_TIEEVEN" title="">FPRounding_TIEEVEN</a> =&gt;
                overflow_to_inf = TRUE;
            when <a href="shared_pseudocode.html#enum_FPRounding_POSINF" title="">FPRounding_POSINF</a> =&gt;
                overflow_to_inf = (sign == '0');
            when <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> =&gt;
                overflow_to_inf = (sign == '1');
            when <a href="shared_pseudocode.html#enum_FPRounding_ZERO" title="">FPRounding_ZERO</a> =&gt;
                overflow_to_inf = FALSE;
        end;
        result = if overflow_to_inf then <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign) else <a href="shared_pseudocode.html#func_FPMaxNormal_2" title="">FPMaxNormal</a>{N}(sign);
        if fpexc then
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_Overflow" title="">FPExc_Overflow</a>, fpcr);
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_Inexact" title="">FPExc_Inexact</a>, fpcr);
        end;
    elsif ((fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16))
          &amp;&amp; (
               (N == 16 &amp;&amp; Abs(value) &gt;= 2.0^14) ||
               (N == 32 &amp;&amp; Abs(value) &gt;= 2.0^126) ||
               (N == 64 &amp;&amp; Abs(value) &gt;= 2.0^1022)
             ) then
        // Result flushed to zero of correct sign
        result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);

        // Flush-to-zero never generates a trapped exception.
        if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
            FPSCR().UFC = '1';
        else
            if fpexc then FPSR().UFC = '1'; end;
        end;
    else
        // Scale to a fixed point value in the range 0.5 &lt;= x &lt; 1.0 in steps of 1/512, and
        // calculate result exponent. Scaled value has copied sign bit,
        // exponent = 1022 = double-precision biased version of -1,
        // fraction = original fraction
        var fraction : bits(52);
        var exp : integer;
        case N of
            when 16 =&gt;
                fraction = operand[9:0] :: Zeros{42};
                exp = UInt(operand[14:10]);
            when 32 =&gt;
                fraction = operand[22:0] :: Zeros{29};
                exp = UInt(operand[30:23]);
            when 64 =&gt;
                fraction = operand[51:0];
                exp = UInt(operand[62:52]);
        end;

        if exp == 0 then
            if fraction[51] == '0' then
                exp = -1;
                fraction = fraction[49:0]::'00';
            else
                fraction = fraction[50:0]::'0';
            end;
        end;

        var scaled : integer;
        let increasedprecision : boolean = N==32 &amp;&amp; IsFeatureImplemented(FEAT_RPRES) &amp;&amp; altfp;

        if !increasedprecision then
            scaled = UInt('1'::fraction[51:44]);
        else
            scaled = UInt('1'::fraction[51:41]);
        end;

        var result_exp : integer;
        case N of
            when 16 =&gt; result_exp = 29 - exp; // In range 29-30 = -1 to 29+1 = 30
            when 32 =&gt; result_exp = 253 - exp; // In range 253-254 = -1 to 253+1 = 254
            when 64 =&gt; result_exp = 2045 - exp; // In range 2045-2046 = -1 to 2045+1 = 2046
        end;

        // Scaled is in range 256 .. 511 or 2048 .. 4095 range representing a
        // fixed-point number in range [0.5 .. 1.0].
        let estimate : integer = <a href="shared_pseudocode.html#func_RecipEstimate_2" title="">RecipEstimate</a>(scaled, increasedprecision);

        // Estimate is in the range 256 .. 511 or 4096 .. 8191 representing a
        // fixed-point result in the range [1.0 .. 2.0].
        // Convert to scaled floating point result with copied sign bit,
        // high-order bits from estimate, and exponent calculated above.
        if !increasedprecision then
            fraction = estimate[7:0] :: Zeros{44};
        else
            fraction = estimate[11:0] :: Zeros{40};
        end;

        if result_exp == 0 then
            fraction = '1' :: fraction[51:1];
        elsif result_exp == -1 then
            fraction = '01' :: fraction[51:2];
            result_exp = 0;
        end;

        case N of
            when 16 =&gt; result = sign :: result_exp[N-12:0] :: fraction[51:42];
            when 32 =&gt; result = sign :: result_exp[N-25:0] :: fraction[51:29];
            when 64 =&gt; result = sign :: result_exp[N-54:0] :: fraction[51:0];
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprecipestimate.RecipEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprecipestimate/RecipEstimate</h3>
      <p class="pseudocode">// RecipEstimate()
// ===============
// Compute estimate of reciprocal of 9-bit fixed-point number.
//
// a is in range 256 .. 511 or 2048 .. 4096 representing a number in
// the range 0.5 &lt;= x &lt; 1.0.
// increasedprecision determines if the mantissa is 8-bit or 12-bit.
// result is in the range 256 .. 511 or 4096 .. 8191 representing a
// number in the range 1.0 to 511/256 or 1.00 to 8191/4096.

func <a id="func_RecipEstimate_2"/>RecipEstimate(a_in : integer, increasedprecision : boolean) =&gt; integer
begin
    var a : integer = a_in;
    var r : integer;
    if !increasedprecision then
        assert 256 &lt;= a &amp;&amp; a &lt; 512;
        a = a*2+1;                       // Round to nearest
        let b : integer = (2 ^ 19) DIVRM a;
        r = (b+1) DIVRM 2;               // Round to nearest
        assert 256 &lt;= r &amp;&amp; r &lt; 512;
    else
        assert 2048 &lt;= a &amp;&amp; a &lt; 4096;
        a = a*2+1;                       // Round to nearest
        let b : integer = (2 ^ 26) DIVRM a;
        r = (b+1) DIVRM 2;               // Round to nearest
        assert 4096 &lt;= r &amp;&amp; r &lt; 8192;
    end;
    return r;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprecpx.FPRecpX"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprecpx/FPRecpX</h3>
      <p class="pseudocode">// FPRecpX()
// =========

func <a id="func_FPRecpX_3"/>FPRecpX{N}(op : bits(N), fpcr_in : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var fpcr : FPCR_Type = fpcr_in;
    let isbfloat16 : boolean = FALSE;
    let (F, -) = FPBits(N, isbfloat16);
    let E = (N - F) - 1;
    var result : bits(N);
    var exp : bits(E);
    var max_exp : bits(E);
    let frac : bits(F) = Zeros{};

    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; fpcr.AH == '1';
    let fpexc : boolean = !altfp;            // Generate no floating-point exceptions
    if altfp then fpcr.[FIZ,FZ] = '11'; end; // Flush denormal input and output to zero
    let (fptype,sign,value) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op, fpcr, fpexc);
    exp = op[F+:E];
    max_exp = Ones{E} - 1;

    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(fptype, op, fpcr, fpexc);
    else
        if IsZero(exp) then                 // Zero and denormals
            result = ZeroExtend{N}(sign::max_exp::frac);
        else                                // Infinities and normals
            result = ZeroExtend{N}(sign::NOT(exp)::frac);
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpround.FPRound"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpround/FPRound</h3>
      <p class="pseudocode">// FPRound()
// =========
// Generic conversion from precise, unbounded real data type to IEEE format.

func <a id="func_FPRound_3"/>FPRound{N}(op : real, fpcr : FPCR_Type) =&gt; bits(N)
begin
    return <a href="shared_pseudocode.html#func_FPRound_4" title="">FPRound</a>{N}(op, fpcr, <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr));
end;

// FPRound()
// =========
// For directed FP conversion, includes an explicit 'rounding' argument.

func <a id="func_FPRound_4"/>FPRound{N}(op : real, fpcr_in : FPCR_Type, rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;    // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#func_FPRound_5" title="">FPRound</a>{N}(op, fpcr_in, rounding, fpexc);
end;

// FPRound()
// =========
// For AltFP, includes an explicit FPEXC argument to disable exception
// generation and switches off Arm alternate half-precision mode.

func <a id="func_FPRound_5"/>FPRound{N}(op : real, fpcr_in : FPCR_Type, rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>, fpexc : boolean) =&gt; bits(N)
begin
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.AHP = '0';
    let isbfloat16 : boolean = FALSE;
    return <a href="shared_pseudocode.html#func_FPRoundBase_6" title="">FPRoundBase</a>{N}(op, fpcr, rounding, isbfloat16, fpexc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpround.FPRoundBase"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpround/FPRoundBase</h3>
      <p class="pseudocode">// FPRoundBase()
// =============
// For BFloat16, includes an explicit 'isbfloat16' argument.

func <a id="func_FPRoundBase_5"/>FPRoundBase{N}(op : real, fpcr : FPCR_Type, rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>,
                    isbfloat16 : boolean) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;    // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#func_FPRoundBase_6" title="">FPRoundBase</a>{N}(op, fpcr, rounding, isbfloat16, fpexc);
end;

// FPRoundBase()
// =============
// For FP8 multiply-accumulate, dot product, and outer product instructions, includes
// an explicit saturation overflow argument.

func <a id="func_FPRoundBase_6"/>FPRoundBase{N}(op : real, fpcr : FPCR_Type, rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>, isbfloat16 : boolean,
                    fpexc : boolean) =&gt; bits(N)
begin
    let satoflo : boolean = FALSE;
    return <a href="shared_pseudocode.html#func_FPRoundBase_7" title="">FPRoundBase</a>{N}(op, fpcr, rounding, isbfloat16, fpexc, satoflo);
end;

// FPRoundBase()
// =============
// Convert a real number 'op' into an N-bit floating-point value using the
// supplied rounding mode 'rounding'.
//
// The 'fpcr' argument supplies FPCR control bits and 'fpexc' controls the
// generation of floating-point exceptions. Status information is updated
// directly in the FPSR where appropriate. The 'satoflo' argument
// controls whether overflow generates Infinity or MaxNorm for 8-bit floating-point
// data processing instructions.

func <a id="func_FPRoundBase_7"/>FPRoundBase{N}(op : real, fpcr : FPCR_Type, rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>, isbfloat16 : boolean,
                    fpexc : boolean, satoflo : boolean) =&gt; bits(N)
begin

    assert N IN {16,32,64};
    assert op != 0.0;
    assert rounding != <a href="shared_pseudocode.html#enum_FPRounding_TIEAWAY" title="">FPRounding_TIEAWAY</a>;
    var result : bits(N);

    // Obtain format parameters - minimum exponent, numbers of exponent and fraction bits.
    let (F, minimum_exp) = FPBits(N, isbfloat16);
    let zeros = if N == 32 &amp;&amp; isbfloat16 then 16 else 0;
    let E = N - (F + 1 + zeros);
    // Split value into sign, unrounded mantissa and exponent.
    var sign : bit;
    var exponent : integer;
    var mantissa : real;
    if op &lt; 0.0 then
        sign = '1';  mantissa = -op;
    else
        sign = '0';  mantissa = op;
    end;
    (mantissa, exponent) = <a href="shared_pseudocode.html#func_NormalizeReal_1" title="">NormalizeReal</a>(mantissa);

    // When TRUE, detection of underflow occurs after rounding and the test for a
    // denormalized number for single and double precision values occurs after rounding.
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';

    // Deal with flush-to-zero before rounding if FPCR.AH != '1'.
    if (!altfp &amp;&amp; ((fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16)) &amp;&amp;
          exponent &lt; minimum_exp) then
        // Flush-to-zero never generates a trapped exception.
        if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
            FPSCR().UFC = '1';
        else
            if fpexc then FPSR().UFC = '1'; end;
        end;
        return <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
    end;

    var biased_exp_unconstrained : integer = (exponent - minimum_exp) + 1;
    var int_mant_unconstrained : integer = RoundDown(mantissa * 2.0^F);
    let error_unconstrained : real = mantissa * 2.0^F - Real(int_mant_unconstrained);

    // Start creating the exponent value for the result. Start by biasing the actual exponent
    // so that the minimum exponent becomes 1, lower values 0 (indicating possible underflow).
    var biased_exp : integer = Max((exponent - minimum_exp) + 1, 0);
    if biased_exp == 0 then mantissa = mantissa / 2.0^(minimum_exp - exponent); end;

    // Get the unrounded mantissa as an integer, and the "units in last place" rounding error.
    // &lt; 2.0^F if biased_exp == 0, &gt;= 2.0^F if not
    var int_mant : integer = RoundDown(mantissa * 2.0^F);
    var error : real = mantissa * 2.0^F - Real(int_mant);

    // Underflow occurs if exponent is too small before rounding, and result is inexact or
    // the Underflow exception is trapped. This applies before rounding if FPCR.AH != '1'.
    let trapped_UF : boolean = fpcr.UFE == '1' &amp;&amp; (!<a href="shared_pseudocode.html#func_InStreamingMode_0" title="">InStreamingMode</a>() || <a href="shared_pseudocode.html#func_IsFullA64Enabled_0" title="">IsFullA64Enabled</a>());
    if !altfp &amp;&amp; biased_exp == 0 &amp;&amp; (error != 0.0 || trapped_UF) then
        if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_Underflow" title="">FPExc_Underflow</a>, fpcr); end;
    end;

    // Round result according to rounding mode.
    var round_up_unconstrained : boolean;
    var round_up : boolean;
    var overflow_to_inf : boolean;
    if altfp then

        case rounding of
            when <a href="shared_pseudocode.html#enum_FPRounding_TIEEVEN" title="">FPRounding_TIEEVEN</a> =&gt;
                round_up_unconstrained = (error_unconstrained &gt; 0.5 ||
                   (error_unconstrained == 0.5 &amp;&amp; int_mant_unconstrained[0] == '1'));
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_mant[0] == '1'));
                overflow_to_inf = !satoflo;
            when <a href="shared_pseudocode.html#enum_FPRounding_POSINF" title="">FPRounding_POSINF</a> =&gt;
                round_up_unconstrained = (error_unconstrained != 0.0 &amp;&amp; sign == '0');
                round_up = (error != 0.0 &amp;&amp; sign == '0');
                overflow_to_inf = (sign == '0');
            when <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> =&gt;
                round_up_unconstrained = (error_unconstrained != 0.0 &amp;&amp; sign == '1');
                round_up = (error != 0.0 &amp;&amp; sign == '1');
                overflow_to_inf = (sign == '1');
            when <a href="shared_pseudocode.html#enum_FPRounding_ZERO" title="">FPRounding_ZERO</a>, <a href="shared_pseudocode.html#enum_FPRounding_ODD" title="">FPRounding_ODD</a> =&gt;
                round_up_unconstrained = FALSE;
                round_up = FALSE;
                overflow_to_inf = FALSE;
        end;

        if round_up_unconstrained then
            int_mant_unconstrained = int_mant_unconstrained + 1;
            if int_mant_unconstrained == 2^(F+1) then    // Rounded up to next exponent
                biased_exp_unconstrained = biased_exp_unconstrained + 1;
                int_mant_unconstrained   = int_mant_unconstrained DIV 2;
            end;
        end;

        // Deal with flush-to-zero and underflow after rounding if FPCR.AH == '1'.
        if biased_exp_unconstrained &lt; 1 &amp;&amp; int_mant_unconstrained != 0 then
            // the result of unconstrained rounding is less than the minimum normalized number
            if (fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16) then   // Flush-to-zero
                if fpexc then
                    FPSR().UFC = '1';
                    FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_Inexact" title="">FPExc_Inexact</a>, fpcr);
                end;
                return <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
            elsif error != 0.0 || trapped_UF then
                if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_Underflow" title="">FPExc_Underflow</a>, fpcr); end;
            end;
        end;
    else    // altfp == FALSE
        case rounding of
            when <a href="shared_pseudocode.html#enum_FPRounding_TIEEVEN" title="">FPRounding_TIEEVEN</a> =&gt;
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_mant[0] == '1'));
                overflow_to_inf = !satoflo;
            when <a href="shared_pseudocode.html#enum_FPRounding_POSINF" title="">FPRounding_POSINF</a> =&gt;
                round_up = (error != 0.0 &amp;&amp; sign == '0');
                overflow_to_inf = (sign == '0');
            when <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> =&gt;
                round_up = (error != 0.0 &amp;&amp; sign == '1');
                overflow_to_inf = (sign == '1');
            when <a href="shared_pseudocode.html#enum_FPRounding_ZERO" title="">FPRounding_ZERO</a>, <a href="shared_pseudocode.html#enum_FPRounding_ODD" title="">FPRounding_ODD</a> =&gt;
                round_up = FALSE;
                overflow_to_inf = FALSE;
        end;
    end;

    if round_up then
        int_mant = int_mant + 1;
        if int_mant == 2^F then      // Rounded up from denormalized to normalized
            biased_exp = 1;
        end;
        if int_mant == 2^(F+1) then  // Rounded up to next exponent
            biased_exp = biased_exp + 1;
            int_mant = int_mant DIV 2;
        end;
    end;

    // Handle rounding to odd
    if error != 0.0 &amp;&amp; rounding == <a href="shared_pseudocode.html#enum_FPRounding_ODD" title="">FPRounding_ODD</a> &amp;&amp; int_mant[0] == '0' then
        int_mant = int_mant + 1;
    end;

    // Deal with overflow and generate result.
    if N != 16 || fpcr.AHP == '0' then  // Single, double or IEEE half precision
        if biased_exp &gt;= 2^E - 1 then
            result = if overflow_to_inf then <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign) else <a href="shared_pseudocode.html#func_FPMaxNormal_2" title="">FPMaxNormal</a>{N}(sign);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_Overflow" title="">FPExc_Overflow</a>, fpcr); end;
            error = 1.0;  // Ensure that an Inexact exception occurs
        else
            result = sign :: biased_exp[E-1:0] :: int_mant[F-1:0] :: Zeros{N-(E+F+1)};
        end;
    else                                     // Alternative half precision
        if biased_exp &gt;= 2^E then
            result = sign :: Ones{N-1};
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
            error = 0.0;  // Ensure that an Inexact exception does not occur
        else
            result = sign :: biased_exp[E-1:0] :: int_mant[F-1:0] :: Zeros{N-(E+F+1)};
        end;
    end;

    // Deal with Inexact exception.
    if error != 0.0 then
        if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_Inexact" title="">FPExc_Inexact</a>, fpcr); end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpround.FPRoundCV"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpround/FPRoundCV</h3>
      <p class="pseudocode">// FPRoundCV()
// ===========
// Used for FP to FP conversion instructions.
// For half-precision data ignores FZ16 and observes AHP.

func <a id="func_FPRoundCV_4"/>FPRoundCV{N}(op : real, fpcr_in : FPCR_Type, rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>) =&gt; bits(N)
begin
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.FZ16 = '0';
    let fpexc : boolean = TRUE;    // Generate floating-point exceptions
    let isbfloat16 : boolean = FALSE;
    return <a href="shared_pseudocode.html#func_FPRoundBase_6" title="">FPRoundBase</a>{N}(op, fpcr, rounding, isbfloat16, fpexc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpround.FPRound_FP8"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpround/FPRound_FP8</h3>
      <p class="pseudocode">// FPRound_FP8()
// =============
// Used by FP8 multiply-accumulate, dot product, and outer product instructions
// which observe FPMR.OSM.

func <a id="func_FPRound_FP8_5"/>FPRound_FP8{N}(op : real, fpcr_in : FPCR_Type, rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>,
                    satoflo : boolean) =&gt; bits(N)
begin
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.AHP = '0';
    let fpexc : boolean = FALSE;
    let isbfloat16 : boolean = FALSE;
    return <a href="shared_pseudocode.html#func_FPRoundBase_7" title="">FPRoundBase</a>{N}(op, fpcr, rounding, isbfloat16, fpexc, satoflo);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprounding.FPRounding"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprounding/FPRounding</h3>
      <p class="pseudocode">// FPRounding
// ==========
// The conversion and rounding functions take an explicit
// rounding mode enumeration instead of booleans or FPCR values.

type <a id="type_FPRounding"/>FPRounding of enumeration {<a id="enum_FPRounding_TIEEVEN"/>FPRounding_TIEEVEN, <a id="enum_FPRounding_POSINF"/>FPRounding_POSINF,
                                <a id="enum_FPRounding_NEGINF"/>FPRounding_NEGINF,  <a id="enum_FPRounding_ZERO"/>FPRounding_ZERO,
                                <a id="enum_FPRounding_TIEAWAY"/>FPRounding_TIEAWAY, <a id="enum_FPRounding_ODD"/>FPRounding_ODD};</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fproundingmode.FPRoundingMode"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fproundingmode/FPRoundingMode</h3>
      <p class="pseudocode">// FPRoundingMode()
// ================
// Return the current floating-point rounding mode.

func <a id="func_FPRoundingMode_1"/>FPRoundingMode(fpcr : FPCR_Type) =&gt; <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>
begin
    return <a href="shared_pseudocode.html#func_FPDecodeRounding_1" title="">FPDecodeRounding</a>(fpcr.RMode);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fproundint.FPRoundInt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fproundint/FPRoundInt</h3>
      <p class="pseudocode">// FPRoundInt()
// ============

// Round op to nearest integral floating point value using rounding mode in FPCR/FPSCR.
// If EXACT is TRUE, set FPSR.IXC if result is not numerically equal to op.

func <a id="func_FPRoundInt_5"/>FPRoundInt{N}(op : bits(N), fpcr : FPCR_Type, rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>,
                   exact : boolean) =&gt; bits(N)
begin
    assert rounding != <a href="shared_pseudocode.html#enum_FPRounding_ODD" title="">FPRounding_ODD</a>;
    assert N IN {16,32,64};

    // When alternative floating-point support is TRUE, do not generate
    // Input Denormal floating-point exceptions.
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    let fpexc : boolean = !altfp;

    // Unpack using FPCR to determine if subnormals are flushed-to-zero.
    let (fptype,sign,value) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op, fpcr, fpexc);

    var result : bits(N);
    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#func_FPProcessNaN_4" title="">FPProcessNaN</a>{N}(fptype, op, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
    else
        // Extract integer component.
        var int_result : integer = RoundDown(value);
        let error : real = value - Real(int_result);

        // Determine whether supplied rounding mode requires an increment.
        var round_up : boolean;
        case rounding of
            when <a href="shared_pseudocode.html#enum_FPRounding_TIEEVEN" title="">FPRounding_TIEEVEN</a> =&gt;
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result[0] == '1'));
            when <a href="shared_pseudocode.html#enum_FPRounding_POSINF" title="">FPRounding_POSINF</a> =&gt;
                round_up = (error != 0.0);
            when <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> =&gt;
                round_up = FALSE;
            when <a href="shared_pseudocode.html#enum_FPRounding_ZERO" title="">FPRounding_ZERO</a> =&gt;
                round_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
            when <a href="shared_pseudocode.html#enum_FPRounding_TIEAWAY" title="">FPRounding_TIEAWAY</a> =&gt;
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result &gt;= 0));
        end;

        if round_up then int_result = int_result + 1; end;

        // Convert integer value into an equivalent real value.
        let real_result : real = Real(int_result);

        // Re-encode as a floating-point value, result is always exact.
        if real_result == 0.0 then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
        else
            result = <a href="shared_pseudocode.html#func_FPRound_4" title="">FPRound</a>{N}(real_result, fpcr, <a href="shared_pseudocode.html#enum_FPRounding_ZERO" title="">FPRounding_ZERO</a>);
        end;

        // Generate inexact exceptions.
        if error != 0.0 &amp;&amp; exact then
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_Inexact" title="">FPExc_Inexact</a>, fpcr);
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fproundintn.FPRoundIntN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fproundintn/FPRoundIntN</h3>
      <p class="pseudocode">// FPRoundIntN()
// =============

func <a id="func_FPRoundIntN_5"/>FPRoundIntN{N}(op : bits(N), fpcr : FPCR_Type,
                    rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>, intsize : integer) =&gt; bits(N)
begin
    assert rounding != <a href="shared_pseudocode.html#enum_FPRounding_ODD" title="">FPRounding_ODD</a>;
    assert N IN {32,64};
    assert intsize IN {32, 64};
    var exp : integer;
    var result : bits(N);
    var round_up : boolean;
    let E : integer{} = (if N == 32 then 8 else 11);
    let F : integer{} = N - (E + 1);

    // When alternative floating-point support is TRUE, do not generate
    // Input Denormal floating-point exceptions.
    let altfp = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    let fpexc = !altfp;

    // Unpack using FPCR to determine if subnormals are flushed-to-zero.
    let (fptype,sign,value) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op, fpcr, fpexc);

    if fptype IN {<a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>, <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a>, <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>} then
        if N == 32 then
            exp    = 126 + intsize;
            result = '1'::exp[(E-1):0]::Zeros{F};
        else
            exp    = 1022+intsize;
            result = '1'::exp[(E-1):0]::Zeros{F};
        end;
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
    else
        // Extract integer component.
        var int_result = RoundDown(value);
        var error      = value - Real(int_result);

        // Determine whether supplied rounding mode requires an increment.
        case rounding of
            when <a href="shared_pseudocode.html#enum_FPRounding_TIEEVEN" title="">FPRounding_TIEEVEN</a> =&gt;
                round_up = error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result[0] == '1');
            when <a href="shared_pseudocode.html#enum_FPRounding_POSINF" title="">FPRounding_POSINF</a> =&gt;
                round_up = error != 0.0;
            when <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> =&gt;
                round_up = FALSE;
            when <a href="shared_pseudocode.html#enum_FPRounding_ZERO" title="">FPRounding_ZERO</a> =&gt;
                round_up = error != 0.0 &amp;&amp; int_result &lt; 0;
            when <a href="shared_pseudocode.html#enum_FPRounding_TIEAWAY" title="">FPRounding_TIEAWAY</a> =&gt;
                round_up = error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result &gt;= 0);
        end;

        if round_up then int_result = int_result + 1; end;
        let overflow = int_result &gt; 2^(intsize-1)-1 || int_result &lt; -1*2^(intsize-1);

        if overflow then
            if N == 32 then
                exp    = 126 + intsize;
                result = '1'::exp[(E-1):0]::Zeros{F};
            else
                exp    = 1022 + intsize;
                result = '1'::exp[(E-1):0]::Zeros{F};
            end;
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
            // This case shouldn't set Inexact.
            error = 0.0;

        else
            // Convert integer value into an equivalent real value.
            let real_result : real = Real(int_result);

            // Re-encode as a floating-point value, result is always exact.
            if real_result == 0.0 then
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
            else
                result = <a href="shared_pseudocode.html#func_FPRound_4" title="">FPRound</a>{N}(real_result, fpcr, <a href="shared_pseudocode.html#enum_FPRounding_ZERO" title="">FPRounding_ZERO</a>);
            end;
        end;

        // Generate inexact exceptions.
        if error != 0.0 then
            FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_Inexact" title="">FPExc_Inexact</a>, fpcr);
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprsqrtestimate.FPRSqrtEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprsqrtestimate/FPRSqrtEstimate</h3>
      <p class="pseudocode">// FPRSqrtEstimate()
// =================

func <a id="func_FPRSqrtEstimate_3"/>FPRSqrtEstimate{N}(operand : bits(N), fpcr_in : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var fpcr : FPCR_Type = fpcr_in;

    // When using alternative floating-point behavior, do not generate
    // floating-point exceptions and flush denormal input to zero.
    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    let fpexc : boolean = !altfp;
    if altfp then fpcr.[FIZ,FZ] = '11'; end;

    let (fptype,sign,value) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(operand, fpcr, fpexc);

    var result : bits(N);
    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#func_FPProcessNaN_5" title="">FPProcessNaN</a>{N}(fptype, operand, fpcr, fpexc);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign);
        if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_DivideByZero" title="">FPExc_DivideByZero</a>, fpcr); end;
    elsif sign == '1' then
        result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{N}(fpcr);
        if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}('0');
    else
        // Scale to a fixed-point value in the range 0.25 &lt;= x &lt; 1.0 in steps of 512, with the
        // evenness or oddness of the exponent unchanged, and calculate result exponent.
        // Scaled value has copied sign bit, exponent = 1022 or 1021 = double-precision
        // biased version of -1 or -2, fraction = original fraction extended with zeros.

        var fraction : bits(52);
        var exp : integer;
        case N of
            when 16 =&gt;
                fraction = operand[9:0] :: Zeros{42};
                exp      = UInt(operand[14:10]);
            when 32 =&gt;
                fraction = operand[22:0] :: Zeros{29};
                exp      = UInt(operand[30:23]);
            when 64 =&gt;
                fraction = operand[51:0];
                exp      = UInt(operand[62:52]);
        end;

        if exp == 0 then
            while fraction[51] == '0' looplimit 51 do
                fraction = fraction[50:0] :: '0';
                exp      = exp - 1;
            end;
            fraction = fraction[50:0] :: '0';
        end;

        var scaled : integer;
        let increasedprecision : boolean = N==32 &amp;&amp; IsFeatureImplemented(FEAT_RPRES) &amp;&amp; altfp;

        if !increasedprecision then
            if exp[0] == '0' then
                scaled = UInt('1'::fraction[51:44]);
            else
                scaled = UInt('01'::fraction[51:45]);
            end;
        else
            if exp[0] == '0' then
                scaled = UInt('1'::fraction[51:41]);
            else
                scaled = UInt('01'::fraction[51:42]);
            end;
        end;

        var result_exp : integer;
        case N of
            when 16 =&gt; result_exp = (  44 - exp) DIVRM 2;
            when 32 =&gt; result_exp = ( 380 - exp) DIVRM 2;
            when 64 =&gt; result_exp = (3068 - exp) DIVRM 2;
        end;

        let estimate : integer = <a href="shared_pseudocode.html#func_RecipSqrtEstimate_2" title="">RecipSqrtEstimate</a>(scaled, increasedprecision);

        // Estimate is in the range 256 .. 511 or 4096 .. 8191 representing a
        // fixed-point result in the range [1.0 .. 2.0].
        // Convert to scaled floating point result with copied sign bit and high-order
        // fraction bits, and exponent calculated above.
        case N of
            when 16 =&gt; result = '0' :: result_exp[N-12:0] :: estimate[7:0]::Zeros{2};
            when 32 =&gt;
                if !increasedprecision then
                    result = '0' :: result_exp[N-25:0] :: estimate[7:0]::Zeros{15};
                else
                    result = '0' :: result_exp[N-25:0] :: estimate[11:0]::Zeros{11};
                end;
            when 64 =&gt; result = '0' :: result_exp[N-54:0] :: estimate[7:0]::Zeros{44};
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprsqrtestimate.RecipSqrtEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprsqrtestimate/RecipSqrtEstimate</h3>
      <p class="pseudocode">// RecipSqrtEstimate()
// ===================
// Compute estimate of reciprocal square root of 9-bit fixed-point number.
//
// a_in is in range 128 .. 511 or 1024 .. 4095, with increased precision,
// representing a number in the range 0.25 &lt;= x &lt; 1.0.
// increasedprecision determines if the mantissa is 8-bit or 12-bit.
// result is in the range 256 .. 511 or 4096 .. 8191, with increased precision,
// representing a number in the range 1.0 to 511/256 or 8191/4096.

func <a id="func_RecipSqrtEstimate_2"/>RecipSqrtEstimate(a_in : integer, increasedprecision : boolean) =&gt; integer
begin
    var a : integer = a_in;
    var r : integer;
    if !increasedprecision then
        assert 128 &lt;= a &amp;&amp; a &lt; 512;
        if a &lt; 256 then                      // a in [128, 255], represents a value in [0.25, 0.5)
            a = a*2+1;                       // promote to 9-bit range in units of 1/512
        else                                 // a in [256, 511], represents a value in [0.5, 1.0)
            a = (a &gt;&gt; 1) &lt;&lt; 1;               // Discard bottom bit
            a = (a+1)*2;                     // round up to nearest 1/256 and convert
        end;
        var b : integer = 512;
        while a*(b+1)*(b+1) &lt; 2^28 looplimit 510 do
            b = b+1;
        end;
        // b = largest b such that b &lt; 2^14 / sqrt(a)
        r = (b+1) DIVRM 2;                   // Round to nearest
        assert 256 &lt;= r &amp;&amp; r &lt; 512;
    else
        assert 1024 &lt;= a &amp;&amp; a &lt; 4096;
        if a &lt; 2048 then                     // a in [1024, 2047], represents a value in [0.25, 0.5)
            a = a*2 + 1;                     // promote to 13-bit range in units of 1/8192
        else                                 // a in [2048, 4095], represents a value in [0.5, 1.0)
            a = (a &gt;&gt; 1) &lt;&lt; 1;               // Discard bottom bit
            a = (a+1)*2;                     // round up to nearest 1/4096 and convert
        end;
        var b : integer = 8192;
        while a*(b+1)*(b+1) &lt; 2^39 looplimit (2^39 - (2049 * 8193^2)) do
            b = b+1;
        end;
        r = (b+1) DIVRM 2;                   // Round to nearest
        assert 4096 &lt;= r &amp;&amp; r &lt; 8192;
    end;
    return r;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpsqrt.FPSqrt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpsqrt/FPSqrt</h3>
      <p class="pseudocode">// FPSqrt()
// ========

func <a id="func_FPSqrt_3"/>FPSqrt{N}(op : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    var (fptype,sign,value) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_3" title="">FPUnpack</a>{N}(op, fpcr);

    var result : bits(N);
    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#func_FPProcessNaN_4" title="">FPProcessNaN</a>{N}(fptype, op, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign);
    elsif fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> &amp;&amp; sign == '0' then
        result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}(sign);
    elsif sign == '1' then
        result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{N}(fpcr);
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
    else
        var prec : integer;
        if N == 16 then
            prec = 13; // 10 fraction bits + 3
        elsif N == 32 then
            prec = 26; // 23 fraction bits + 3
        else // N == 64
            prec = 55; // 52 fraction bits + 3
        end;
        value = SqrtRounded(value, prec);
        result = <a href="shared_pseudocode.html#func_FPRound_3" title="">FPRound</a>{N}(value, fpcr);
        FPProcessDenorm(fptype, N, fpcr);

    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpsub.FPSub"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpsub/FPSub</h3>
      <p class="pseudocode">// FPSub()
// =======

func <a id="func_FPSub_4"/>FPSub{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type) =&gt; bits(N)
begin
    let fpexc : boolean = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#func_FPSub_5" title="">FPSub</a>{N}(op1, op2, fpcr, fpexc);
end;

// FPSub()
// =======

func <a id="func_FPSub_5"/>FPSub{N}(op1 : bits(N), op2 : bits(N), fpcr : FPCR_Type, fpexc : boolean) =&gt; bits(N)
begin

    assert N IN {16,32,64};
    let rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a> = <a href="shared_pseudocode.html#func_FPRoundingMode_1" title="">FPRoundingMode</a>(fpcr);

    let (type1,sign1,value1) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op1, fpcr, fpexc);
    let (type2,sign2,value2) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op2, fpcr, fpexc);

    var (done,result) : (boolean, bits(N)) = <a href="shared_pseudocode.html#func_FPProcessNaNs_7" title="">FPProcessNaNs</a>{N}(type1, type2, op1, op2, fpcr, fpexc);
    if !done then
        let inf1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let inf2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>);
        let zero1 : boolean = (type1 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);
        let zero2 : boolean = (type2 == <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>);

        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#func_FPDefaultNaN_2" title="">FPDefaultNaN</a>{N}(fpcr);
            if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr); end;
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#func_FPInfinity_2" title="">FPInfinity</a>{N}('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(sign1);
        else
            let result_value : real = value1 - value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                let result_sign : bit = if rounding == <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#func_FPZero_2" title="">FPZero</a>{N}(result_sign);
            else
                result = <a href="shared_pseudocode.html#func_FPRound_5" title="">FPRound</a>{N}(result_value, fpcr, rounding, fpexc);
            end;
        end;

        if fpexc then FPProcessDenorms(type1, type2, N, fpcr); end;
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpsub.FPSub_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpsub/FPSub_ZA</h3>
      <p class="pseudocode">// FPSub_ZA()
// ==========
// Calculates op1-op2 for SME2 ZA-targeting instructions.

func <a id="func_FPSub_ZA_4"/>FPSub_ZA{N}(op1 : bits(N), op2 : bits(N), fpcr_in : FPCR_Type) =&gt; bits(N)
begin
    var fpcr : FPCR_Type = fpcr_in;
    let fpexc : boolean = FALSE; // Do not generate floating-point exceptions
    fpcr.DN = '1';                  // Generate default NaN values
    return <a href="shared_pseudocode.html#func_FPSub_5" title="">FPSub</a>{N}(op1, op2, fpcr, fpexc);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpthree.FPThree"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpthree/FPThree</h3>
      <p class="pseudocode">// FPThree()
// =========

func <a id="func_FPThree_2"/>FPThree{N}(sign : bit) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let E : integer{} = (if N == 16 then 5 else (if N == 32 then 8 else 11));
    let F : integer{}  = N - (E + 1);
    let exp : bits(E)  = '1'::Zeros{E-1};
    let frac : bits(F) = '1'::Zeros{F-1};
    let result : bits((F + E) + 1) = sign :: exp :: frac;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fptofixed.FPToFixed"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fptofixed/FPToFixed</h3>
      <p class="pseudocode">// FPToFixed()
// ===========

// Convert N-bit precision floating point 'op' to M-bit fixed point with
// FBITS fractional bits, controlled by UNSIGNED and ROUNDING.

func <a id="func_FPToFixed_7"/>FPToFixed{M, N}(op : bits(N), fbits : integer, unsigned : boolean, fpcr : FPCR_Type,
                     rounding : <a href="shared_pseudocode.html#type_FPRounding" title="">FPRounding</a>) =&gt; bits(M)
begin
    assert N IN {16,32,64};
    assert M IN {8,16,32,64};
    assert fbits &gt;= 0;
    assert rounding != <a href="shared_pseudocode.html#enum_FPRounding_ODD" title="">FPRounding_ODD</a>;

    // When alternative floating-point support is TRUE, do not generate
    // Input Denormal floating-point exceptions.
    let altfp = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    let fpexc = !altfp;

    // Unpack using fpcr to determine if subnormals are flushed-to-zero.
    var (fptype,sign,value) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{N}(op, fpcr, fpexc);

    // If NaN, set cumulative flag or take exception.
    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
    end;

    // Scale by fractional bits and produce integer rounded towards minus-infinity.
    value = value * 2.0^fbits;
    var int_result : integer = RoundDown(value);
    let error : real         = value - Real(int_result);

    // Determine whether supplied rounding mode requires an increment.
    var round_up : boolean;
    case rounding of
        when <a href="shared_pseudocode.html#enum_FPRounding_TIEEVEN" title="">FPRounding_TIEEVEN</a> =&gt;
            round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result[0] == '1'));
        when <a href="shared_pseudocode.html#enum_FPRounding_POSINF" title="">FPRounding_POSINF</a> =&gt;
            round_up = (error != 0.0);
        when <a href="shared_pseudocode.html#enum_FPRounding_NEGINF" title="">FPRounding_NEGINF</a> =&gt;
            round_up = FALSE;
        when <a href="shared_pseudocode.html#enum_FPRounding_ZERO" title="">FPRounding_ZERO</a> =&gt;
            round_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
        when <a href="shared_pseudocode.html#enum_FPRounding_TIEAWAY" title="">FPRounding_TIEAWAY</a> =&gt;
            round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result &gt;= 0));
    end;

    if round_up then int_result = int_result + 1; end;

    // Generate saturated result and exceptions.
    let (result, overflow) : (bits(M), boolean) = <a href="shared_pseudocode.html#func_SatQ_3" title="">SatQ</a>{M}(int_result, unsigned);
    if overflow then
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
    elsif error != 0.0 then
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_Inexact" title="">FPExc_Inexact</a>, fpcr);
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fptofixedjs.FPToFixedJS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fptofixedjs/FPToFixedJS</h3>
      <p class="pseudocode">// FPToFixedJS()
// =============

// Converts a double precision floating point input value
// to a signed integer, with rounding to zero.

func <a id="func_FPToFixedJS_2"/>FPToFixedJS(op : bits(64), fpcr : FPCR_Type) =&gt; (bits(32), bit)
begin

    // If FALSE, never generate Input Denormal floating-point exceptions.
    let fpexc_idenorm : boolean = !(IsFeatureImplemented(FEAT_AFP) &amp;&amp;
                                    !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1');

    // Unpack using fpcr to determine if subnormals are flushed-to-zero.
    let (fptype,sign,value) = <a href="shared_pseudocode.html#func_FPUnpack_4" title="">FPUnpack</a>{64}(op, fpcr, fpexc_idenorm);

    var z : bit = '1';
    // If NaN, set cumulative flag or take exception.
    if fptype == <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> then
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
        z = '0';
    end;

    var int_result = RoundDown(value);
    let error = value - Real(int_result);

    // Determine whether supplied rounding mode requires an increment.

    let round_it_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
    if round_it_up then int_result = int_result + 1; end;

    var result : integer;
    if int_result &lt; 0 then
        result = int_result - 2^32*RoundUp(Real(int_result)/Real(2^32));
    else
        result = int_result - 2^32*RoundDown(Real(int_result)/Real(2^32));
    end;

    // Generate exceptions.
    if int_result &lt; -(2^31) || int_result &gt; (2^31)-1 then
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InvalidOp" title="">FPExc_InvalidOp</a>, fpcr);
        z = '0';
    elsif error != 0.0 then
        FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_Inexact" title="">FPExc_Inexact</a>, fpcr);
        z = '0';
    elsif sign == '1' &amp;&amp; value == 0.0 then
        z = '0';
    elsif sign == '0' &amp;&amp; value == 0.0 &amp;&amp; !IsZero(op[51:0]) then
        z = '0';
    end;

    if fptype == <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a> then result = 0; end;

    return (result[31:0], z);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fptwo.FPTwo"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fptwo/FPTwo</h3>
      <p class="pseudocode">// FPTwo()
// =======

func <a id="func_FPTwo_2"/>FPTwo{N}(sign : bit) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let E : integer{} = (if N == 16 then 5 else (if N == 32 then 8 else 11));
    let F : integer{}  = N - (E + 1);
    let exp : bits(E)  = '1'::Zeros{E-1};
    let frac : bits(F) = Zeros{};
    let result : bits((F + E) + 1) = sign :: exp :: frac;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fptype.FPType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fptype/FPType</h3>
      <p class="pseudocode">// FPType
// ======

type <a id="type_FPType"/>FPType of enumeration {<a id="enum_FPType_Zero"/>FPType_Zero,
                            <a id="enum_FPType_Denormal"/>FPType_Denormal,
                            <a id="enum_FPType_Nonzero"/>FPType_Nonzero,
                            <a id="enum_FPType_Infinity"/>FPType_Infinity,
                            <a id="enum_FPType_QNaN"/>FPType_QNaN,
                            <a id="enum_FPType_SNaN"/>FPType_SNaN};</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpunpack.FPUnpack"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpunpack/FPUnpack</h3>
      <p class="pseudocode">// FPUnpack()
// ==========

func <a id="func_FPUnpack_3"/>FPUnpack{N}(fpval : bits(N), fpcr_in : FPCR_Type) =&gt; (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real)
begin
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.AHP = '0';
    let fpexc : boolean = TRUE;   // Generate floating-point exceptions
    let (fp_type, sign, value) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpackBase_4" title="">FPUnpackBase</a>{N}(fpval, fpcr, fpexc);
    return (fp_type, sign, value);
end;

// FPUnpack()
// ==========
//
// Used by data processing, int/fixed to FP and FP to int/fixed conversion instructions.
// For half-precision data it ignores AHP, and observes FZ16.

func <a id="func_FPUnpack_4"/>FPUnpack{N}(fpval : bits(N), fpcr_in : FPCR_Type, fpexc : boolean) =&gt; (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real)
begin
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.AHP = '0';
    let (fp_type, sign, value) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpackBase_4" title="">FPUnpackBase</a>{N}(fpval, fpcr, fpexc);
    return (fp_type, sign, value);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpunpack.FPUnpackBase"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpunpack/FPUnpackBase</h3>
      <p class="pseudocode">// FPUnpackBase()
// ==============

func <a id="func_FPUnpackBase_4"/>FPUnpackBase{N}(fpval : bits(N), fpcr : FPCR_Type, fpexc : boolean) =&gt; (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real)
begin
    let isbfloat16 : boolean = FALSE;
    let (fp_type, sign, value) = <a href="shared_pseudocode.html#func_FPUnpackBase_5" title="">FPUnpackBase</a>{N}(fpval, fpcr, fpexc, isbfloat16);
    return (fp_type, sign, value);
end;

// FPUnpackBase()
// ==============
//
// Unpack a floating-point number into its type, sign bit and the real number
// that it represents. The real number result has the correct sign for numbers
// and infinities, is very large in magnitude for infinities, and is 0.0 for
// NaNs. (These values are chosen to simplify the description of comparisons
// and conversions.)
//
// The 'fpcr_in' argument supplies FPCR control bits, 'fpexc' controls the
// generation of floating-point exceptions and 'isbfloat16' determines whether
// N=16 signifies BFloat16 or half-precision type. Status information is updated
// directly in the FPSR where appropriate.

func <a id="func_FPUnpackBase_5"/>FPUnpackBase{N}(fpval : bits(N), fpcr_in : FPCR_Type, fpexc : boolean,
                     isbfloat16 : boolean) =&gt; (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real)
begin
    assert N IN {16,32,64};

    let fpcr : FPCR_Type = fpcr_in;

    let altfp : boolean = IsFeatureImplemented(FEAT_AFP) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
    let fiz : boolean   = altfp &amp;&amp; fpcr.FIZ == '1';
    let fz : boolean    = fpcr.FZ == '1' &amp;&amp; !(altfp &amp;&amp; fpcr.AH == '1');
    var value : real;
    var sign : bit;
    var fptype : <a href="shared_pseudocode.html#type_FPType" title="">FPType</a>;

    if N == 16 &amp;&amp; !isbfloat16 then
        sign   = fpval[15];
        let exp16 : bits(5)   = fpval[14:10];
        let frac16 : bits(10) = fpval[9:0];
        if IsZero(exp16) then
            if IsZero(frac16) || fpcr.FZ16 == '1' then
                fptype = <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>;  value = 0.0;
            else
                fptype = <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a>;  value = 2.0^-14 * (Real(UInt(frac16)) * 2.0^-10);
            end;
        elsif IsOnes(exp16) &amp;&amp; fpcr.AHP == '0' then  // Infinity or NaN in IEEE format
            if IsZero(frac16) then
                fptype = <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>;  value = 2.0^1000000;
            else
                fptype = if frac16[9] == '1' then <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> else <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>;
                value = 0.0;
            end;
        else
            fptype = <a href="shared_pseudocode.html#enum_FPType_Nonzero" title="">FPType_Nonzero</a>;
            value = 2.0^(UInt(exp16)-15) * (1.0 + Real(UInt(frac16)) * 2.0^-10);
        end;

    elsif N == 32 || isbfloat16 then
        var exp32 : bits(8);
        var frac32 : bits(23);
        if isbfloat16 then
            sign   = fpval[15];
            exp32  = fpval[14:7];
            frac32 = fpval[6:0] :: Zeros{16};
        else
            sign   = fpval[31];
            exp32  = fpval[30:23];
            frac32 = fpval[22:0];
        end;

        if IsZero(exp32) then
            if IsZero(frac32) then
                // Produce zero if value is zero.
                fptype = <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>;  value = 0.0;
            elsif fz || fiz then        // Flush-to-zero if FIZ==1 or AH,FZ==01
                fptype = <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>;  value = 0.0;
                // Check whether to raise Input Denormal floating-point exception.
                // fpcr.FIZ==1 does not raise Input Denormal exception.
                if fz then
                    // Denormalized input flushed to zero
                    if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InputDenorm" title="">FPExc_InputDenorm</a>, fpcr); end;
                end;
            else
                fptype = <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a>;  value = 2.0^-126 * (Real(UInt(frac32)) * 2.0^-23);
            end;
        elsif IsOnes(exp32) then
            if IsZero(frac32) then
                fptype = <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>;  value = 2.0^1000000;
            else
                fptype = if frac32[22] == '1' then <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> else <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>;
                value = 0.0;
            end;
        else
            fptype = <a href="shared_pseudocode.html#enum_FPType_Nonzero" title="">FPType_Nonzero</a>;
            value = 2.0^(UInt(exp32)-127) * (1.0 + Real(UInt(frac32)) * 2.0^-23);
        end;

    else // N == 64
        sign   = fpval[63];
        let exp64 : bits(11)  = fpval[62:52];
        let frac64 : bits(52) = fpval[51:0];

        if IsZero(exp64) then
            if IsZero(frac64) then
                // Produce zero if value is zero.
                fptype = <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>;  value = 0.0;
            elsif fz || fiz then        // Flush-to-zero if FIZ==1 or AH,FZ==01
                fptype = <a href="shared_pseudocode.html#enum_FPType_Zero" title="">FPType_Zero</a>;  value = 0.0;
                // Check whether to raise Input Denormal floating-point exception.
                // fpcr.FIZ==1 does not raise Input Denormal exception.
                if fz then
                    // Denormalized input flushed to zero
                    if fpexc then FPProcessException(<a href="shared_pseudocode.html#enum_FPExc_InputDenorm" title="">FPExc_InputDenorm</a>, fpcr); end;
                end;
            else
                fptype = <a href="shared_pseudocode.html#enum_FPType_Denormal" title="">FPType_Denormal</a>;  value = 2.0^-1022 * (Real(UInt(frac64)) * 2.0^-52);
            end;
        elsif IsOnes(exp64) then
            if IsZero(frac64) then
                fptype = <a href="shared_pseudocode.html#enum_FPType_Infinity" title="">FPType_Infinity</a>;  value = 2.0^1000000;
            else
                fptype = if frac64[51] == '1' then <a href="shared_pseudocode.html#enum_FPType_QNaN" title="">FPType_QNaN</a> else <a href="shared_pseudocode.html#enum_FPType_SNaN" title="">FPType_SNaN</a>;
                value  = 0.0;
            end;
        else
            fptype = <a href="shared_pseudocode.html#enum_FPType_Nonzero" title="">FPType_Nonzero</a>;
            value  = 2.0^(UInt(exp64)-1023) * (1.0 + Real(UInt(frac64)) * 2.0^-52);
        end;
    end;

    if sign == '1' then value = -value; end;

    return (fptype, sign, value);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpunpack.FPUnpackCV"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpunpack/FPUnpackCV</h3>
      <p class="pseudocode">// FPUnpackCV()
// ============
//
// Used for FP to FP conversion instructions.
// For half-precision data ignores FZ16 and observes AHP.

func <a id="func_FPUnpackCV_3"/>FPUnpackCV{N}(fpval : bits(N), fpcr_in : FPCR_Type) =&gt; (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real)
begin
    var fpcr : FPCR_Type = fpcr_in;
    fpcr.FZ16 = '0';
    let fpexc : boolean = TRUE;   // Generate floating-point exceptions
    let (fp_type, sign, value) : (<a href="shared_pseudocode.html#type_FPType" title="">FPType</a>, bit, real) = <a href="shared_pseudocode.html#func_FPUnpackBase_4" title="">FPUnpackBase</a>{N}(fpval, fpcr, fpexc);
    return (fp_type, sign, value);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpzero.FPZero"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpzero/FPZero</h3>
      <p class="pseudocode">// FPZero()
// ========

func <a id="func_FPZero_2"/>FPZero{N}(sign : bit) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let E : integer{}  = (if N == 16 then 5 else (if N == 32 then 8 else 11));
    let F : integer{}  = N - (E + 1);
    let exp : bits(E)  = Zeros{};
    let frac : bits(F) = Zeros{};
    let result : bits((F + E) + 1) = sign :: exp :: frac;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.vfpexpandimm.VFPExpandImm"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/vfpexpandimm/VFPExpandImm</h3>
      <p class="pseudocode">// VFPExpandImm()
// ==============

func <a id="func_VFPExpandImm_2"/>VFPExpandImm{N}(imm8 : bits(8)) =&gt; bits(N)
begin
    assert N IN {16,32,64};
    let E : integer{} = (if N == 16 then 5 else (if N == 32 then 8 else 11));
    let F : integer{} = (N - E) - 1;
    let sign : bit = imm8[7];
    let exp : bits(E)  = NOT(imm8[6])::Replicate{E - 3}(imm8[6])::imm8[5:4];
    let frac : bits(F) = imm8[3:0]::Zeros{F-4};
    let result : bits((F + E) + 1) = sign :: exp :: frac;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.integer.AddWithCarry"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/integer/AddWithCarry</h3>
      <p class="pseudocode">// AddWithCarry()
// ==============
// Integer addition with carry input, returning result and NZCV flags

func <a id="func_AddWithCarry_4"/>AddWithCarry{N}(x : bits(N), y : bits(N), carry_in : bit) =&gt; (bits(N), bits(4))
begin
    let unsigned_sum : integer = UInt(x) + UInt(y) + UInt(carry_in);
    let signed_sum : integer = SInt(x) + SInt(y) + UInt(carry_in);
    let result : bits(N) = unsigned_sum[N-1:0]; // same value as signed_sum[N-1:0]
    let n : bit = result[N-1];
    let z : bit = if IsZero(result) then '1' else '0';
    let c : bit = if UInt(result) == unsigned_sum then '0' else '1';
    let v : bit = if SInt(result) == signed_sum then '0' else '1';
    return (result, n::z::c::v);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.interrupts.InterruptID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/interrupts/InterruptID</h3>
      <p class="pseudocode">// InterruptID
// ===========

type <a id="type_InterruptID"/>InterruptID of enumeration {
    <a id="enum_InterruptID_PMUIRQ"/>InterruptID_PMUIRQ,
    <a id="enum_InterruptID_COMMIRQ"/>InterruptID_COMMIRQ,
    <a id="enum_InterruptID_CTIIRQ"/>InterruptID_CTIIRQ,
    <a id="enum_InterruptID_COMMRX"/>InterruptID_COMMRX,
    <a id="enum_InterruptID_COMMTX"/>InterruptID_COMMTX,
    <a id="enum_InterruptID_CNTP"/>InterruptID_CNTP,
    <a id="enum_InterruptID_CNTHP"/>InterruptID_CNTHP,
    <a id="enum_InterruptID_CNTHPS"/>InterruptID_CNTHPS,
    <a id="enum_InterruptID_CNTPS"/>InterruptID_CNTPS,
    <a id="enum_InterruptID_CNTV"/>InterruptID_CNTV,
    <a id="enum_InterruptID_CNTHV"/>InterruptID_CNTHV,
    <a id="enum_InterruptID_CNTHVS"/>InterruptID_CNTHVS,
    <a id="enum_InterruptID_PMBIRQ"/>InterruptID_PMBIRQ,
    <a id="enum_InterruptID_HACDBSIRQ"/>InterruptID_HACDBSIRQ,

    <a id="enum_InterruptID_TRBIRQ"/>InterruptID_TRBIRQ,
};</p>
    </div>
    <div class="ps"><a id="shared.functions.interrupts.SetInterruptRequestLevel"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/interrupts/SetInterruptRequestLevel</h3>
      <p class="pseudocode">// SetInterruptRequestLevel()
// ==========================
// Set a level-sensitive interrupt to the specified level.

impdef func SetInterruptRequestLevel(id : InterruptID, level : <a href="shared_pseudocode.html#Signal" title="type Signal">Signal</a>)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AArch64_BranchAddr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AArch64_BranchAddr</h3>
      <p class="pseudocode">// AArch64_BranchAddr()
// ====================
// Return the virtual address with tag bits removed.
// This is typically used when the address will be stored to the program counter.

func <a id="func_AArch64_BranchAddr_2"/>AArch64_BranchAddr(vaddress : bits(64), el : bits(2)) =&gt; bits(64)
begin
    assert !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
    let msbit : integer{} = AddrTop(vaddress, TRUE, el);
    if msbit == 63 then
        return vaddress;
    elsif (el IN {<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>, <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>} || <a href="shared_pseudocode.html#func_IsInHost_0" title="">IsInHost</a>()) &amp;&amp; vaddress[msbit] == '1' then
        return SignExtend{64}(vaddress[msbit:0]);
    else
        return ZeroExtend{64}(vaddress[msbit:0]);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AccessDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AccessDescriptor</h3>
      <p class="pseudocode">// AccessDescriptor
// ================
// Memory access or translation invocation details that steer architectural behavior

type <a id="type_AccessDescriptor"/>AccessDescriptor of record {
    acctype : <a href="shared_pseudocode.html#type_AccessType" title="">AccessType</a>,
    el : bits(2),                  // Acting EL for the access
    ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>,            // Acting Security State for the access
    acqsc : boolean,               // Acquire with Sequential Consistency
    acqpc : boolean,               // FEAT_LRCPC: Acquire with Processor Consistency
    relsc : boolean,               // Release with Sequential Consistency
    limitedordered : boolean,      // FEAT_LOR: Acquire/Release with limited ordering
    exclusive : boolean,           // Access has Exclusive semantics
    atomicop : boolean,            // FEAT_LSE: Atomic read-modify-write access
    modop : <a href="shared_pseudocode.html#type_MemAtomicOp" title="">MemAtomicOp</a>,           // FEAT_LSE: The modification operation in the 'atomicop' access
    nontemporal : boolean,         // Hints the access is non-temporal
    read : boolean,                // Read from memory or only require read permissions
    write : boolean,               // Write to memory or only require write permissions
    cacheop : <a href="shared_pseudocode.html#type_CacheOp" title="">CacheOp</a>,             // DC/IC: Cache operation
    opscope : <a href="shared_pseudocode.html#type_CacheOpScope" title="">CacheOpScope</a>,        // DC/IC: Scope of cache operation
    cachetype : <a href="shared_pseudocode.html#type_CacheType" title="">CacheType</a>,         // DC/IC: Type of target cache
    pan : boolean,                 // FEAT_PAN: The access is subject to PSTATE.PAN
    nonfault : boolean,            // SVE: Non-faulting load
    firstfault : boolean,          // SVE: First-fault load
    first : boolean,               // SVE: First-fault load for the first active element
    contiguous : boolean,          // SVE: Contiguous load/store not gather load/scatter store
    predicated : boolean,          // SVE: Predicated load/store
    streamingsve : boolean,        // SME: Access made by PE while in streaming SVE mode
    ls64 : boolean,                // FEAT_LS64: Accesses by accelerator support loads/stores
    withstatus : boolean,          // FEAT_LS64: Store with status result
    mops : boolean,                // FEAT_MOPS: Memory operation (CPY/SET) accesses
    rcw : boolean,                 // FEAT_THE: Read-Check-Write access
    rcws : boolean,                // FEAT_THE: Read-Check-Write Software access
    toplevel : boolean,            // FEAT_THE: Translation table walk access for TTB address
    varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a>,             // FEAT_THE: The corresponding TTBR supplying the TTB
    a32lsmd : boolean,             // A32 Load/Store Multiple Data access
    tagchecked : boolean,          // FEAT_MTE2: Access is tag checked
    tagaccess : boolean,           // FEAT_MTE: Access targets the tag bits
    stzgm : boolean,               // FEAT_MTE: Accesses that store Allocation tags to Device
                                   //           memory are CONSTRAINED UNPREDICTABLE
    Rt : integer,                  // Register named Rt in the instruction
    Rt2 : integer,                 // Register named Rt2 in the instruction
    Rs : integer,                  // Register named Rs in the instruction
    Rs2 : integer,                 // Register named Rs2 in the instruction
    ispair : boolean,              // Access represents a Load/Store pair access
    highestaddressfirst : boolean, // FEAT_LRCPC3: Highest address is accessed first
    lowestaddress : boolean,       // Is the current access the lowest address accessed by
                                   // this instruction
    mpam : MPAMinfo                // FEAT_MPAM: MPAM information
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AccessType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AccessType</h3>
      <p class="pseudocode">// AccessType
// ==========

type <a id="type_AccessType"/>AccessType of enumeration {
    <a id="enum_AccessType_IFETCH"/>AccessType_IFETCH,     // Instruction FETCH
    <a id="enum_AccessType_GPR"/>AccessType_GPR,        // Software load/store to a General Purpose Register
    <a id="enum_AccessType_FP"/>AccessType_FP,         // Software load/store to an FP register
    <a id="enum_AccessType_ASIMD"/>AccessType_ASIMD,      // Software ASIMD extension load/store instructions
    <a id="enum_AccessType_SVE"/>AccessType_SVE,        // Software SVE load/store instructions
    <a id="enum_AccessType_SME"/>AccessType_SME,        // Software SME load/store instructions
    <a id="enum_AccessType_IC"/>AccessType_IC,         // Sysop IC
    <a id="enum_AccessType_DC"/>AccessType_DC,         // Sysop DC (not DC {Z,G,GZ}VA)
    <a id="enum_AccessType_DCZero"/>AccessType_DCZero,     // Sysop DC {Z,G,GZ}VA
    <a id="enum_AccessType_AT"/>AccessType_AT,         // Sysop AT
    <a id="enum_AccessType_NV2"/>AccessType_NV2,        // NV2 memory redirected access
    <a id="enum_AccessType_SPE"/>AccessType_SPE,        // Statistical Profiling buffer access
    <a id="enum_AccessType_GCS"/>AccessType_GCS,        // Guarded Control Stack access
    <a id="enum_AccessType_TRBE"/>AccessType_TRBE,       // Trace Buffer access
    <a id="enum_AccessType_GPTW"/>AccessType_GPTW,       // Granule Protection Table Walk
    <a id="enum_AccessType_HACDBS"/>AccessType_HACDBS,     // Access to the HACDBS structure
    <a id="enum_AccessType_HDBSS"/>AccessType_HDBSS,      // Access to entries in HDBSS
    <a id="enum_AccessType_MPAMv2VID"/>AccessType_MPAMv2VID,  // Access to the MVMS or MITT structures
    <a id="enum_AccessType_TTW"/>AccessType_TTW         // Translation Table Walk
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AddrTop"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AddrTop</h3>
      <p class="pseudocode">// AddrTop()
// =========
// Return the MSB number of a virtual address in the stage 1 translation regime for "el".
// If EL1 is using AArch64 then addresses from EL0 using AArch32 are zero-extended to 64 bits.

func AddrTop(address : bits(64), IsInstr : boolean, el : bits(2)) =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    assert HaveEL(el);
    let regime : bits(2) = S1TranslationRegime(el);
    if ELUsingAArch32(regime) then
        // AArch32 translation regime.
        return 31;
    else
        if EffectiveTBI(address, IsInstr, el) == '1' then
            return 55;
        else
            return 63;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AddressSize"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AddressSize</h3>
      <p class="pseudocode">// AddressSize
// ============

type <a id="AddressSize"/>AddressSize of integer{3..64};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AlignmentEnforced"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AlignmentEnforced</h3>
      <p class="pseudocode">// AlignmentEnforced()
// ===================
// For the active translation regime, determine if alignment is required by all accesses

func <a id="func_AlignmentEnforced_0"/>AlignmentEnforced() =&gt; boolean
begin
    let regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a> = <a href="shared_pseudocode.html#func_TranslationRegime_1" title="">TranslationRegime</a>(PSTATE.EL);
    var A : bit;
    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> =&gt; A = SCTLR().A;
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> =&gt;  A = SCTLR_EL3().A;
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;  A = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then HSCTLR().A else SCTLR_EL2().A;
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt; A = SCTLR_EL2().A;
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; A = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then SCTLR().A  else SCTLR_EL1().A;
        otherwise =&gt; unreachable;
    end;
    return A == '1';
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Allocation"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Allocation</h3>
      <p class="pseudocode">// Allocation hints
// ================

constant <a id="global_MemHint_No"/>MemHint_No : bits(2)  = '00';   // No Read-Allocate, No Write-Allocate

constant <a id="global_MemHint_WA"/>MemHint_WA : bits(2)  = '01';   // No Read-Allocate, Write-Allocate

constant <a id="global_MemHint_RA"/>MemHint_RA : bits(2)  = '10';   // Read-Allocate, No Write-Allocate

constant <a id="global_MemHint_RWA"/>MemHint_RWA : bits(2) = '11';   // Read-Allocate, Write-Allocate</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.BigEndian"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/BigEndian</h3>
      <p class="pseudocode">// BigEndian()
// ===========

func <a id="func_BigEndian_1"/>BigEndian(acctype : <a href="shared_pseudocode.html#type_AccessType" title="">AccessType</a>) =&gt; boolean
begin
    var bigend : boolean;
    if IsFeatureImplemented(FEAT_NV2) &amp;&amp; acctype == <a href="shared_pseudocode.html#enum_AccessType_NV2" title="">AccessType_NV2</a> then
        return SCTLR_EL2().EE == '1';
    end;

    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then
        bigend = (PSTATE.E != '0');
    elsif PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        bigend = (<a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().E0E != '0');
    else
        bigend = (<a href="shared_pseudocode.html#accessor_SCTLR_ELx_0" title="">SCTLR_ELx</a>().EE != '0');
    end;
    return bigend;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.BigEndianReverse"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/BigEndianReverse</h3>
      <p class="pseudocode">// BigEndianReverse()
// ==================

func <a id="func_BigEndianReverse_2"/>BigEndianReverse{width}(value : bits(width)) =&gt; bits(width)
begin
    assert width IN {8, 16, 32, 64, 128, 256};

    if width == 8 then return value; end;
    return <a href="shared_pseudocode.html#func_Reverse_3" title="">Reverse</a>{width}(value, 8);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CacheOp"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CacheOp</h3>
      <p class="pseudocode">// CacheOp
// =======

type <a id="type_CacheOp"/>CacheOp of enumeration {
    <a id="enum_CacheOp_Clean"/>CacheOp_Clean,
    <a id="enum_CacheOp_Invalidate"/>CacheOp_Invalidate,
    <a id="enum_CacheOp_CleanInvalidate"/>CacheOp_CleanInvalidate
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CacheOpScope"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CacheOpScope</h3>
      <p class="pseudocode">// CacheOpScope
// ============

type <a id="type_CacheOpScope"/>CacheOpScope of enumeration {
    <a id="enum_CacheOpScope_SetWay"/>CacheOpScope_SetWay,
    <a id="enum_CacheOpScope_PoU"/>CacheOpScope_PoU,
    <a id="enum_CacheOpScope_PoC"/>CacheOpScope_PoC,
    <a id="enum_CacheOpScope_PoE"/>CacheOpScope_PoE,
    <a id="enum_CacheOpScope_PoP"/>CacheOpScope_PoP,
    <a id="enum_CacheOpScope_PoDP"/>CacheOpScope_PoDP,
    <a id="enum_CacheOpScope_PoPA"/>CacheOpScope_PoPA,
    <a id="enum_CacheOpScope_PoPS"/>CacheOpScope_PoPS,
    <a id="enum_CacheOpScope_OuterCache"/>CacheOpScope_OuterCache,
    <a id="enum_CacheOpScope_ALLU"/>CacheOpScope_ALLU,
    <a id="enum_CacheOpScope_ALLUIS_CnP"/>CacheOpScope_ALLUIS_CnP,
    <a id="enum_CacheOpScope_ALLUIS"/>CacheOpScope_ALLUIS
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CachePASpace"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CachePASpace</h3>
      <p class="pseudocode">// CachePASpace
// ============

type <a id="type_CachePASpace"/>CachePASpace of enumeration {
    <a id="enum_CPAS_NonSecure"/>CPAS_NonSecure,
    <a id="enum_CPAS_Any"/>CPAS_Any,                   // Applicable only for DC *SW / IC IALLU* in Root state:
                                // match entries from any PA Space
    <a id="enum_CPAS_RealmNonSecure"/>CPAS_RealmNonSecure,        // Applicable only for DC *SW / IC IALLU* in Realm state:
                                // match entries from Realm or Non-Secure PAS
    <a id="enum_CPAS_Realm"/>CPAS_Realm,
    <a id="enum_CPAS_Root"/>CPAS_Root,
    <a id="enum_CPAS_SystemAgent"/>CPAS_SystemAgent,           // Applicable only for DC by PA:
                                // match entries from the System Agent PAS
    <a id="enum_CPAS_NonSecureProtected"/>CPAS_NonSecureProtected,    // Applicable only for DC by PA:
                                // match entries from the Non-Secure Protected PAS
    <a id="enum_CPAS_NA6"/>CPAS_NA6,                   // Reserved
    <a id="enum_CPAS_NA7"/>CPAS_NA7,                   // Reserved
    <a id="enum_CPAS_SecureNonSecure"/>CPAS_SecureNonSecure,       // Applicable only for DC *SW / IC IALLU* in Secure state:
                                // match entries from Secure or Non-Secure PAS
    <a id="enum_CPAS_Secure"/>CPAS_Secure
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CacheType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CacheType</h3>
      <p class="pseudocode">// CacheType
// =========

type <a id="type_CacheType"/>CacheType of enumeration {
    <a id="enum_CacheType_Data"/>CacheType_Data,
    <a id="enum_CacheType_Tag"/>CacheType_Tag,
    <a id="enum_CacheType_Data_Tag"/>CacheType_Data_Tag,
    <a id="enum_CacheType_TagWrite"/>CacheType_TagWrite,
    <a id="enum_CacheType_TagZero"/>CacheType_TagZero,
    <a id="enum_CacheType_Instruction"/>CacheType_Instruction
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Cacheability"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Cacheability</h3>
      <p class="pseudocode">// Cacheability attributes
// =======================

constant <a id="global_MemAttr_NC"/>MemAttr_NC : bits(2) = '00';    // Non-cacheable

constant <a id="global_MemAttr_WT"/>MemAttr_WT : bits(2) = '10';    // Write-through

constant <a id="global_MemAttr_WB"/>MemAttr_WB : bits(2) = '11';    // Write-back</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescA32LSMD"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescA32LSMD</h3>
      <p class="pseudocode">// CreateAccDescA32LSMD()
// ======================
// Access descriptor for A32 loads/store multiple general purpose registers

func CreateAccDescA32LSMD(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);

    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;
    accdesc.pan             = TRUE;
    accdesc.a32lsmd         = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescASIMD"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescASIMD</h3>
      <p class="pseudocode">// CreateAccDescASIMD()
// ====================
// Access descriptor for ASIMD&amp;FP loads/stores

func CreateAccDescASIMD(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, nontemporal : boolean, tagchecked : boolean,
                        privileged : boolean) =&gt; AccessDescriptor
begin
    let ispair : boolean = FALSE;
    return CreateAccDescASIMD(memop, nontemporal, tagchecked, privileged, ispair);
end;

// CreateAccDescASIMD()
// ====================

func CreateAccDescASIMD(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, nontemporal : boolean, tagchecked : boolean,
                        privileged : boolean, ispair : boolean) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_ASIMD);

    accdesc.nontemporal     = nontemporal;
    accdesc.el              = if !privileged then EL0 else PSTATE.EL;
    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;
    accdesc.ispair          = ispair;
    accdesc.pan             = TRUE;
    accdesc.streamingsve    = InStreamingMode();
    if (accdesc.streamingsve &amp;&amp; ImpDefBool(
          "No tag checking of SIMD&amp;FP loads and stores in Streaming SVE mode")) then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    end;
    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescASIMDAcqRel"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescASIMDAcqRel</h3>
      <p class="pseudocode">// CreateAccDescASIMDAcqRel()
// ==========================
// Access descriptor for ASIMD&amp;FP loads/stores with ordering semantics

func CreateAccDescASIMDAcqRel(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, tagchecked : boolean) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_ASIMD);

    accdesc.acqpc           = memop == MemOp_LOAD;
    accdesc.relsc           = memop == MemOp_STORE;
    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;
    accdesc.pan             = TRUE;
    accdesc.streamingsve    = InStreamingMode();
    if (accdesc.streamingsve &amp;&amp; ImpDefBool(
          "No tag checking of SIMD&amp;FP loads and stores in Streaming SVE mode")) then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    end;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescAT"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescAT</h3>
      <p class="pseudocode">// CreateAccDescAT()
// =================
// Access descriptor for address translation operations

func <a id="func_CreateAccDescAT_3"/>CreateAccDescAT(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, el : bits(2), ataccess : <a href="shared_pseudocode.html#type_ATAccess" title="">ATAccess</a>) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>);

    accdesc.el              = el;
    accdesc.ss              = ss;
    if ImpDefBool("MPAM uses the EL targeted by the AT instruction") then
        accdesc.mpam = <a href="shared_pseudocode.html#func_GenMPAMAtEL_2" title="">GenMPAMAtEL</a>(<a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>, el);
    end;
    case ataccess of
        when <a href="shared_pseudocode.html#enum_ATAccess_Read" title="">ATAccess_Read</a> =&gt;
            accdesc.(read, write, pan) = (TRUE, FALSE, FALSE);
        when <a href="shared_pseudocode.html#enum_ATAccess_ReadPAN" title="">ATAccess_ReadPAN</a> =&gt;
            accdesc.(read, write, pan) = (TRUE, FALSE, TRUE);
        when <a href="shared_pseudocode.html#enum_ATAccess_Write" title="">ATAccess_Write</a> =&gt;
            accdesc.(read, write, pan) = (FALSE, TRUE, FALSE);
        when <a href="shared_pseudocode.html#enum_ATAccess_WritePAN" title="">ATAccess_WritePAN</a> =&gt;
            accdesc.(read, write, pan) = (FALSE, TRUE, TRUE);
        when <a href="shared_pseudocode.html#enum_ATAccess_Any" title="">ATAccess_Any</a> =&gt;
            accdesc.(read, write, pan) = (FALSE, FALSE, FALSE);
    end;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescAcqRel"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescAcqRel</h3>
      <p class="pseudocode">// CreateAccDescAcqRel()
// =====================
// Access descriptor for general purpose register loads/stores with ordering semantics

func CreateAccDescAcqRel(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, tagchecked : boolean, acqsc : boolean) =&gt; AccessDescriptor
begin
    let Rt : integer = -1;
    return CreateAccDescAcqRel(memop, tagchecked, acqsc, Rt);
end;

func CreateAccDescAcqRel(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, tagchecked : boolean,
                         acqsc : boolean, Rt : integer) =&gt; AccessDescriptor
begin
    let ispair : boolean = FALSE;
    let Rt2 : integer = -1;
    return CreateAccDescAcqRel(memop, tagchecked, ispair, acqsc, Rt, Rt2);
end;

func CreateAccDescAcqRel(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, tagchecked : boolean, ispair : boolean,
                         acqsc : boolean, Rt : integer, Rt2 : integer) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);

    accdesc.acqsc           = acqsc;
    accdesc.relsc           = memop == MemOp_STORE;
    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.ispair          = ispair;
    accdesc.Rt              = Rt;
    accdesc.Rt2             = Rt2;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescAtomicOp"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescAtomicOp</h3>
      <p class="pseudocode">// CreateAccDescAtomicOp()
// =======================
// Access descriptor for atomic read-modify-write memory accesses

func <a id="func_CreateAccDescAtomicOp_7"/>CreateAccDescAtomicOp(modop : <a href="shared_pseudocode.html#type_MemAtomicOp" title="">MemAtomicOp</a>, acquire : boolean, release : boolean,
                           tagchecked : boolean, privileged : boolean, Rt : integer,
                           Rs : integer) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    let Rt2 : integer = -1;
    let Rs2 : integer = -1;

    return <a href="shared_pseudocode.html#func_CreateAccDescAtomicOp_9" title="">CreateAccDescAtomicOp</a>(modop, acquire, release, tagchecked, privileged, Rt, Rt2, Rs, Rs2);
end;

func <a id="func_CreateAccDescAtomicOp_9"/>CreateAccDescAtomicOp(modop : <a href="shared_pseudocode.html#type_MemAtomicOp" title="">MemAtomicOp</a>, acquire : boolean, release : boolean,
                           tagchecked : boolean, privileged : boolean, Rt : integer,
                           Rt2 : integer, Rs : integer, Rs2 : integer) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_GPR" title="">AccessType_GPR</a>);

    accdesc.acqsc           = acquire;
    accdesc.el              = if !privileged then <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> else PSTATE.EL;
    accdesc.relsc           = release;
    accdesc.atomicop        = TRUE;
    accdesc.modop           = modop;
    accdesc.read            = TRUE;
    accdesc.write           = TRUE;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.Rs              = Rs;
    accdesc.Rs2             = Rs2;
    accdesc.Rt              = Rt;
    accdesc.Rt2             = Rt2;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescDC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescDC</h3>
      <p class="pseudocode">// CreateAccDescDC()
// =================
// Access descriptor for data cache operations

func <a id="func_CreateAccDescDC_1"/>CreateAccDescDC(cache : <a href="shared_pseudocode.html#type_CacheRecord" title="">CacheRecord</a>) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>);

    accdesc.cacheop         = cache.cacheop;
    accdesc.cachetype       = cache.cachetype;
    accdesc.opscope         = cache.opscope;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescDCZero"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescDCZero</h3>
      <p class="pseudocode">// CreateAccDescDCZero()
// =====================
// Access descriptor for data cache zero operations

func <a id="func_CreateAccDescDCZero_1"/>CreateAccDescDCZero(cachetype : <a href="shared_pseudocode.html#type_CacheType" title="">CacheType</a>) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_DCZero" title="">AccessType_DCZero</a>);

    accdesc.write            = TRUE;
    accdesc.pan              = TRUE;
    accdesc.tagchecked       = cachetype == <a href="shared_pseudocode.html#enum_CacheType_Data" title="">CacheType_Data</a>;
    accdesc.tagaccess        = cachetype IN {<a href="shared_pseudocode.html#enum_CacheType_Tag" title="">CacheType_Tag</a>, <a href="shared_pseudocode.html#enum_CacheType_Data_Tag" title="">CacheType_Data_Tag</a>};
    accdesc.cachetype        = cachetype;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescExLDST"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescExLDST</h3>
      <p class="pseudocode">// CreateAccDescExLDST()
// =====================
// Access descriptor for general purpose register loads/stores with exclusive semantics

func CreateAccDescExLDST(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, acqrel : boolean, tagchecked : boolean,
                         privileged : boolean) =&gt; AccessDescriptor
begin
    let Rt : integer = -1;
    return CreateAccDescExLDST(memop, acqrel, tagchecked, privileged, Rt);
end;

// CreateAccDescExLDST()
// =====================

func CreateAccDescExLDST(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, acqrel : boolean, tagchecked : boolean,
                         privileged : boolean, Rt : integer) =&gt; AccessDescriptor
begin
    let ispair : boolean = FALSE;
    let Rt2 : integer = -1;
    return CreateAccDescExLDST(memop, acqrel, tagchecked, privileged, ispair, Rt, Rt2);
end;

// CreateAccDescExLDST()
// =====================

func CreateAccDescExLDST(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, acqrel : boolean, tagchecked : boolean,
                         privileged : boolean, ispair : boolean,
                         Rt : integer, Rt2 : integer) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);

    accdesc.acqsc           = acqrel &amp;&amp; memop == MemOp_LOAD;
    accdesc.relsc           = acqrel &amp;&amp; memop == MemOp_STORE;
    accdesc.exclusive       = TRUE;
    accdesc.el              = if !privileged then EL0 else PSTATE.EL;
    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;
    accdesc.ispair          = ispair;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.Rt              = Rt;
    accdesc.Rt2             = Rt2;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescFPAtomicOp"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescFPAtomicOp</h3>
      <p class="pseudocode">// CreateAccDescFPAtomicOp()
// =========================
// Access descriptor for FP atomic read-modify-write memory accesses

func <a id="func_CreateAccDescFPAtomicOp_4"/>CreateAccDescFPAtomicOp(modop : <a href="shared_pseudocode.html#type_MemAtomicOp" title="">MemAtomicOp</a>, acquire : boolean, release : boolean,
                             tagchecked : boolean) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_FP" title="">AccessType_FP</a>);

    accdesc.acqsc           = acquire;
    accdesc.relsc           = release;
    accdesc.atomicop        = TRUE;
    accdesc.modop           = modop;
    accdesc.read            = TRUE;
    accdesc.write           = TRUE;
    accdesc.pan             = TRUE;
    accdesc.streamingsve    = <a href="shared_pseudocode.html#func_InStreamingMode_0" title="">InStreamingMode</a>();
    if (accdesc.streamingsve &amp;&amp; ImpDefBool(
          "No tag checking of SIMD&amp;FP loads and stores in Streaming SVE mode")) then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    end;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescGCS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescGCS</h3>
      <p class="pseudocode">// CreateAccDescGCS()
// ==================
// Access descriptor for memory accesses to the Guarded Control Stack

func CreateAccDescGCS(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, privileged : boolean) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_GCS);

    accdesc.el              = if !privileged then EL0 else PSTATE.EL;
    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescGCSSS1"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescGCSSS1</h3>
      <p class="pseudocode">// CreateAccDescGCSSS1()
// =====================
// Access descriptor for memory accesses to the Guarded Control Stack that switch stacks

func <a id="func_CreateAccDescGCSSS1_1"/>CreateAccDescGCSSS1(privileged : boolean) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_GCS" title="">AccessType_GCS</a>);

    accdesc.el              = if !privileged then <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> else PSTATE.EL;
    accdesc.atomicop        = TRUE;
    accdesc.modop           = <a href="shared_pseudocode.html#enum_MemAtomicOp_GCSSS1" title="">MemAtomicOp_GCSSS1</a>;
    accdesc.read            = TRUE;
    accdesc.write           = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescGPR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescGPR</h3>
      <p class="pseudocode">// CreateAccDescGPR()
// ==================
// Access descriptor for general purpose register loads/stores
// without exclusive or ordering semantics

func CreateAccDescGPR(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, nontemporal : boolean, privileged : boolean,
                      tagchecked : boolean) =&gt; AccessDescriptor
begin
    let Rt : integer = -1;
    return CreateAccDescGPR(memop, nontemporal, privileged, tagchecked, Rt);
end;

func CreateAccDescGPR(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, nontemporal : boolean, privileged : boolean,
                      tagchecked : boolean, Rt : integer) =&gt; AccessDescriptor
begin
    let ispair : boolean = FALSE;
    let Rt2 : integer = -1;
    return CreateAccDescGPR(memop, nontemporal, privileged, tagchecked, ispair, Rt, Rt2);
end;

func CreateAccDescGPR(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, nontemporal : boolean, privileged : boolean,
                      tagchecked : boolean, ispair : boolean,
                      Rt : integer, Rt2 : integer) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);

    accdesc.el              = if !privileged then EL0 else PSTATE.EL;
    accdesc.nontemporal     = nontemporal;
    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.Rt              = Rt;
    accdesc.Rt2             = Rt2;
    accdesc.ispair          = ispair;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescGPTW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescGPTW</h3>
      <p class="pseudocode">// CreateAccDescGPTW()
// ===================
// Access descriptor for Granule Protection Table walks

func <a id="func_CreateAccDescGPTW_1"/>CreateAccDescGPTW(accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_2" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_GPTW" title="">AccessType_GPTW</a>, accdesc_in.mpam);

    accdesc.el              = accdesc_in.el;
    accdesc.ss              = accdesc_in.ss;
    accdesc.read            = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescHACDBS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescHACDBS</h3>
      <p class="pseudocode">// CreateAccDescHACDBS()
// =====================
// Access descriptor for memory accesses to the HACDBS structure.

func <a id="func_CreateAccDescHACDBS_0"/>CreateAccDescHACDBS() =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_HACDBS" title="">AccessType_HACDBS</a>);

    accdesc.read            = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescHDBSS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescHDBSS</h3>
      <p class="pseudocode">// CreateAccDescHDBSS()
// ====================
// Access descriptor for appending entries to the HDBSS

func <a id="func_CreateAccDescHDBSS_1"/>CreateAccDescHDBSS(accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_2" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_HDBSS" title="">AccessType_HDBSS</a>, accdesc_in.mpam);

    accdesc.el              = accdesc_in.el;
    accdesc.ss              = accdesc_in.ss;
    accdesc.write           = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescIC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescIC</h3>
      <p class="pseudocode">// CreateAccDescIC()
// =================
// Access descriptor for instruction cache operations

func <a id="func_CreateAccDescIC_1"/>CreateAccDescIC(cache : <a href="shared_pseudocode.html#type_CacheRecord" title="">CacheRecord</a>) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>);

    accdesc.cacheop         = cache.cacheop;
    accdesc.cachetype       = cache.cachetype;
    accdesc.opscope         = cache.opscope;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescIFetch"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescIFetch</h3>
      <p class="pseudocode">// CreateAccDescIFetch()
// =====================
// Access descriptor for instruction fetches

func <a id="func_CreateAccDescIFetch_0"/>CreateAccDescIFetch() =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a>);

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescLDAcqPC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescLDAcqPC</h3>
      <p class="pseudocode">// CreateAccDescLDAcqPC()
// ======================
// Access descriptor for general purpose register loads with local ordering semantics

func <a id="func_CreateAccDescLDAcqPC_3"/>CreateAccDescLDAcqPC(tagchecked : boolean, acquire : boolean, Rt : integer) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    let ispair : boolean = FALSE;
    let Rt2 : integer = -1;
    return <a href="shared_pseudocode.html#func_CreateAccDescLDAcqPC_5" title="">CreateAccDescLDAcqPC</a>(tagchecked, ispair, acquire, Rt, Rt2);
end;

func <a id="func_CreateAccDescLDAcqPC_5"/>CreateAccDescLDAcqPC(tagchecked : boolean, ispair : boolean, acquire : boolean,
                          Rt : integer, Rt2 : integer) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_GPR" title="">AccessType_GPR</a>);

    accdesc.acqpc           = acquire;
    accdesc.read            = TRUE;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.ispair          = ispair;
    accdesc.Rt              = Rt;
    accdesc.Rt2             = Rt2;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescLDGSTG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescLDGSTG</h3>
      <p class="pseudocode">// CreateAccDescLDGSTG()
// =====================
// Access descriptor for tag memory loads/stores

func CreateAccDescLDGSTG(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, stzgm : boolean, Rt : integer) =&gt; AccessDescriptor
begin
    let ispair : boolean = FALSE;
    let Rt2 : integer = -1;
    return CreateAccDescLDGSTG(memop, stzgm, ispair, Rt, Rt2);
end;

// CreateAccDescLDGSTG()
// =====================

func CreateAccDescLDGSTG(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, stzgm : boolean, ispair : boolean, Rt : integer,
                         Rt2 : integer) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);

    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;
    accdesc.pan             = TRUE;
    accdesc.tagaccess       = TRUE;
    accdesc.stzgm           = stzgm;
    accdesc.ispair          = ispair;
    accdesc.Rt              = Rt;
    accdesc.Rt2             = Rt2;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescLOR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescLOR</h3>
      <p class="pseudocode">// CreateAccDescLOR()
// ==================
// Access descriptor for general purpose register loads/stores with limited ordering semantics

func CreateAccDescLOR(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, tagchecked : boolean,
                      acqsc : boolean, Rt : integer) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);

    accdesc.acqsc           = acqsc;
    accdesc.relsc           = memop == MemOp_STORE;
    accdesc.limitedordered  = TRUE;
    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.Rt              = Rt;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescLS64"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescLS64</h3>
      <p class="pseudocode">// CreateAccDescLS64()
// ===================
// Access descriptor for accelerator-supporting memory accesses

func CreateAccDescLS64(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, withstatus : boolean,
                       tagchecked : boolean) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);

    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;
    accdesc.pan             = TRUE;
    accdesc.ls64            = TRUE;
    accdesc.withstatus      = withstatus;
    accdesc.tagchecked      = tagchecked;
    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescMOPS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescMOPS</h3>
      <p class="pseudocode">// CreateAccDescMOPS()
// ===================
// Access descriptor for data memory copy and set instructions

func CreateAccDescMOPS(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, privileged : boolean,
                       nontemporal : boolean) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_GPR);

    accdesc.el              = if !privileged then EL0 else PSTATE.EL;
    accdesc.nontemporal     = nontemporal;
    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;
    accdesc.pan             = TRUE;
    accdesc.mops            = TRUE;
    accdesc.tagchecked      = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescMPAMv2VID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescMPAMv2VID</h3>
      <p class="pseudocode">// CreateAccDescMPAMv2VID()
// ========================
// Access descriptor for memory accesses to the MVMS or MITT structures.

func <a id="func_CreateAccDescMPAMv2VID_1"/>CreateAccDescMPAMv2VID(pspace : PARTIDSpaceType) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var mpaminfo : MPAMinfo;
    mpaminfo.mpam_sp = pspace;
    mpaminfo.partid  = MPAM2_EL2().PARTID;
    mpaminfo.pmg     = MPAM2_EL2().PMG;

    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_2" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_MPAMv2VID" title="">AccessType_MPAMv2VID</a>, mpaminfo);
    accdesc.read     = TRUE;
    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescNV2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescNV2</h3>
      <p class="pseudocode">// CreateAccDescNV2()
// ==================
// Access descriptor nested virtualization memory indirection loads/stores

func CreateAccDescNV2(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_NV2);

    accdesc.el              = EL2;
    accdesc.ss              = SecurityStateAtEL(EL2);
    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescRCW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescRCW</h3>
      <p class="pseudocode">// CreateAccDescRCW()
// ==================
// Access descriptor for atomic read-check-write memory accesses

func <a id="func_CreateAccDescRCW_7"/>CreateAccDescRCW(modop : <a href="shared_pseudocode.html#type_MemAtomicOp" title="">MemAtomicOp</a>, soft : boolean, acquire : boolean,
                      release : boolean, tagchecked : boolean,
                      Rt : integer, Rs : integer) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    let Rt2 : integer = -1;
    let Rs2 : integer = -1;

    return <a href="shared_pseudocode.html#func_CreateAccDescRCW_9" title="">CreateAccDescRCW</a>(modop, soft, acquire, release, tagchecked, Rt, Rt2, Rs, Rs2);
end;

func <a id="func_CreateAccDescRCW_9"/>CreateAccDescRCW(modop : <a href="shared_pseudocode.html#type_MemAtomicOp" title="">MemAtomicOp</a>, soft : boolean, acquire : boolean,
                      release : boolean, tagchecked : boolean, Rt : integer, Rt2 : integer,
                      Rs : integer, Rs2 : integer) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_GPR" title="">AccessType_GPR</a>);

    accdesc.acqsc           = acquire;
    accdesc.relsc           = release;
    accdesc.rcw             = TRUE;
    accdesc.rcws            = soft;
    accdesc.atomicop        = TRUE;
    accdesc.modop           = modop;
    accdesc.read            = TRUE;
    accdesc.write           = TRUE;
    accdesc.pan             = TRUE;
    accdesc.tagchecked      = tagchecked;
    accdesc.Rt              = Rt;
    accdesc.Rt2             = Rt2;
    accdesc.Rs              = Rs;
    accdesc.Rs2             = Rs2;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescS1TTW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescS1TTW</h3>
      <p class="pseudocode">// CreateAccDescS1TTW()
// ====================
// Access descriptor for stage 1 translation table walks

func <a id="func_CreateAccDescS1TTW_3"/>CreateAccDescS1TTW(toplevel : boolean,
                        varange : <a href="shared_pseudocode.html#type_VARange" title="">VARange</a>,
                        accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_2" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_TTW" title="">AccessType_TTW</a>, accdesc_in.mpam);

    accdesc.el              = accdesc_in.el;
    accdesc.ss              = accdesc_in.ss;
    accdesc.read            = TRUE;
    accdesc.toplevel        = toplevel;
    accdesc.varange         = varange;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescS2TTW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescS2TTW</h3>
      <p class="pseudocode">// CreateAccDescS2TTW()
// ====================
// Access descriptor for stage 2 translation table walks

func <a id="func_CreateAccDescS2TTW_1"/>CreateAccDescS2TTW(accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_2" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_TTW" title="">AccessType_TTW</a>, accdesc_in.mpam);

    accdesc.el              = accdesc_in.el;
    accdesc.ss              = accdesc_in.ss;
    accdesc.read            = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescSME"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescSME</h3>
      <p class="pseudocode">// CreateAccDescSME()
// ==================
// Access descriptor for SME loads/stores

func CreateAccDescSME(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, nontemporal : boolean, contiguous : boolean,
                      tagchecked : boolean) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_SME);

    accdesc.nontemporal     = nontemporal;
    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;
    accdesc.pan             = TRUE;
    accdesc.contiguous      = contiguous;
    accdesc.streamingsve    = TRUE;
    if ImpDefBool("No tag checking of SME LDR &amp; STR instructions") then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    end;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescSPE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescSPE</h3>
      <p class="pseudocode">// CreateAccDescSPE()
// ==================
// Access descriptor for memory accesses by Statistical Profiling unit

func <a id="func_CreateAccDescSPE_2"/>CreateAccDescSPE(owning_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, owning_el : bits(2)) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    let mpaminfo : MPAMinfo = <a href="shared_pseudocode.html#func_GenMPAMAtEL_2" title="">GenMPAMAtEL</a>(<a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a>, owning_el);
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_2" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a>, mpaminfo);

    accdesc.el              = owning_el;
    accdesc.ss              = owning_ss;
    accdesc.write           = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescSTGMOPS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescSTGMOPS</h3>
      <p class="pseudocode">// CreateAccDescSTGMOPS()
// ======================
// Access descriptor for tag memory set instructions

func <a id="func_CreateAccDescSTGMOPS_2"/>CreateAccDescSTGMOPS(privileged : boolean, nontemporal : boolean) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_GPR" title="">AccessType_GPR</a>);

    accdesc.el              = if !privileged then <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> else PSTATE.EL;
    accdesc.nontemporal     = nontemporal;
    accdesc.write           = TRUE;
    accdesc.pan             = TRUE;
    accdesc.mops            = TRUE;
    accdesc.tagaccess       = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescSVE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescSVE</h3>
      <p class="pseudocode">// CreateAccDescSVE()
// ==================
// Access descriptor for general SVE loads/stores

func CreateAccDescSVE(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, nontemporal : boolean, contiguous : boolean,
                      tagchecked : boolean) =&gt; AccessDescriptor
begin
    let predicated : boolean = FALSE;
    return CreateAccDescSVE(memop, nontemporal, contiguous, predicated, tagchecked);
end;

func CreateAccDescSVE(memop : <a href="shared_pseudocode.html#MemOp" title="type MemOp">MemOp</a>, nontemporal : boolean, contiguous : boolean,
                      predicated : boolean, tagchecked : boolean) =&gt; AccessDescriptor
begin
    var accdesc : AccessDescriptor = NewAccDesc(AccessType_SVE);

    accdesc.nontemporal     = nontemporal;
    accdesc.read            = memop == MemOp_LOAD;
    accdesc.write           = memop == MemOp_STORE;
    accdesc.pan             = TRUE;
    accdesc.contiguous      = contiguous;
    accdesc.streamingsve    = InStreamingMode();
    if (accdesc.streamingsve &amp;&amp; ImpDefBool(
          "No tag checking of SIMD&amp;FP loads and stores in Streaming SVE mode")) then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    end;
    accdesc.predicated      = predicated;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescSVEFF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescSVEFF</h3>
      <p class="pseudocode">// CreateAccDescSVEFF()
// ====================
// Access descriptor for first-fault SVE loads

func <a id="func_CreateAccDescSVEFF_2"/>CreateAccDescSVEFF(contiguous : boolean, tagchecked : boolean) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_SVE" title="">AccessType_SVE</a>);

    accdesc.read            = TRUE;
    accdesc.pan             = TRUE;
    accdesc.firstfault      = TRUE;
    accdesc.first           = TRUE;
    accdesc.contiguous      = contiguous;
    accdesc.streamingsve    = <a href="shared_pseudocode.html#func_InStreamingMode_0" title="">InStreamingMode</a>();
    if (accdesc.streamingsve &amp;&amp; ImpDefBool(
          "No tag checking of SIMD&amp;FP loads and stores in Streaming SVE mode")) then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    end;
    accdesc.predicated      = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescSVENF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescSVENF</h3>
      <p class="pseudocode">// CreateAccDescSVENF()
// ====================
// Access descriptor for non-fault SVE loads

func <a id="func_CreateAccDescSVENF_2"/>CreateAccDescSVENF(contiguous : boolean, tagchecked : boolean) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_1" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_SVE" title="">AccessType_SVE</a>);

    accdesc.read            = TRUE;
    accdesc.pan             = TRUE;
    accdesc.nonfault        = TRUE;
    accdesc.contiguous      = contiguous;
    accdesc.streamingsve    = <a href="shared_pseudocode.html#func_InStreamingMode_0" title="">InStreamingMode</a>();
    if (accdesc.streamingsve &amp;&amp; ImpDefBool(
          "No tag checking of SIMD&amp;FP loads and stores in Streaming SVE mode")) then
        accdesc.tagchecked  = FALSE;
    else
        accdesc.tagchecked  = tagchecked;
    end;
    accdesc.predicated      = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescTRBE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescTRBE</h3>
      <p class="pseudocode">// CreateAccDescTRBE()
// ===================
// Access descriptor for memory accesses by Trace Buffer Unit

func <a id="func_CreateAccDescTRBE_2"/>CreateAccDescTRBE(owning_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, owning_el : bits(2)) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var mpam : MPAMinfo;
    if <a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() then
        mpam = <a href="shared_pseudocode.html#func_GenMPAMAtEL_2" title="">GenMPAMAtEL</a>(<a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a>, owning_el);
    else
        mpam = <a href="shared_pseudocode.html#func_GenMPAMCurEL_1" title="">GenMPAMCurEL</a>(<a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a>);
    end;
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_2" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a>, mpam);

    accdesc.el              = owning_el;
    accdesc.ss              = owning_ss;
    accdesc.write           = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccDescTTEUpdate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccDescTTEUpdate</h3>
      <p class="pseudocode">// CreateAccDescTTEUpdate()
// ========================
// Access descriptor for translation table entry HW update

func <a id="func_CreateAccDescTTEUpdate_1"/>CreateAccDescTTEUpdate(accdesc_in : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_NewAccDesc_2" title="">NewAccDesc</a>(<a href="shared_pseudocode.html#enum_AccessType_TTW" title="">AccessType_TTW</a>, accdesc_in.mpam);

    accdesc.el              = accdesc_in.el;
    accdesc.ss              = accdesc_in.ss;
    accdesc.atomicop        = TRUE;
    accdesc.modop           = <a href="shared_pseudocode.html#enum_MemAtomicOp_CAS" title="">MemAtomicOp_CAS</a>;
    accdesc.read            = TRUE;
    accdesc.write           = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.DataMemoryBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/DataMemoryBarrier</h3>
      <p class="pseudocode">// DataMemoryBarrier()
// ===================

impdef func DataMemoryBarrier(domain : MBReqDomain, types : <a href="shared_pseudocode.html#MBReqTypes" title="type MBReqTypes">MBReqTypes</a>)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.DataSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/DataSynchronizationBarrier</h3>
      <p class="pseudocode">// DataSynchronizationBarrier()
// ============================

impdef func DataSynchronizationBarrier(domain : MBReqDomain, types : <a href="shared_pseudocode.html#MBReqTypes" title="type MBReqTypes">MBReqTypes</a>, nXS : boolean)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.DeviceType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/DeviceType</h3>
      <p class="pseudocode">// DeviceType
// ==========
// Extended memory types for Device memory.

type <a id="type_DeviceType"/>DeviceType of enumeration {<a id="enum_DeviceType_GRE"/>DeviceType_GRE, <a id="enum_DeviceType_nGRE"/>DeviceType_nGRE,
                                <a id="enum_DeviceType_nGnRE"/>DeviceType_nGnRE, <a id="enum_DeviceType_nGnRnE"/>DeviceType_nGnRnE};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.EffectiveMTX"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/EffectiveMTX</h3>
      <p class="pseudocode">// EffectiveMTX()
// ==============
// Returns the effective MTX in the AArch64 stage 1 translation regime for "el".

func <a id="func_EffectiveMTX_3"/>EffectiveMTX(address : bits(64), is_instr : boolean, el : bits(2)) =&gt; bit
begin
    var mtx : bit;
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(el);
    let regime : bits(2) = <a href="shared_pseudocode.html#func_S1TranslationRegime_1" title="">S1TranslationRegime</a>(el);
    assert(!<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(regime));

    if is_instr then
        mtx = '0';
    else
        case regime of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
                mtx = if address[55] == '1' then TCR_EL1().MTX1 else TCR_EL1().MTX0;
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
                if IsFeatureImplemented(FEAT_VHE) &amp;&amp; <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(el) then
                    mtx = if address[55] == '1' then TCR_EL2().MTX1 else TCR_EL2().MTX0;
                else
                    mtx = TCR_EL2().MTX;
                end;
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
                mtx = TCR_EL3().MTX;
        end;
    end;

    return mtx;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.EffectiveTBI"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/EffectiveTBI</h3>
      <p class="pseudocode">// EffectiveTBI()
// ==============
// Returns the effective TBI in the AArch64 stage 1 translation regime for "el".

func <a id="func_EffectiveTBI_3"/>EffectiveTBI(address : bits(64), IsInstr : boolean, el : bits(2)) =&gt; bit
begin
    var tbi : bit;
    var tbid : bit;
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(el);
    let regime : bits(2) = <a href="shared_pseudocode.html#func_S1TranslationRegime_1" title="">S1TranslationRegime</a>(el);
    assert(!<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(regime));

    case regime of
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            tbi = if address[55] == '1' then TCR_EL1().TBI1 else TCR_EL1().TBI0;
            if IsFeatureImplemented(FEAT_PAuth) then
                tbid = if address[55] == '1' then TCR_EL1().TBID1 else TCR_EL1().TBID0;
            end;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            if IsFeatureImplemented(FEAT_VHE) &amp;&amp; <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(el) then
                tbi = if address[55] == '1' then TCR_EL2().TBI1 else TCR_EL2().TBI0;
                if IsFeatureImplemented(FEAT_PAuth) then
                    tbid = if address[55] == '1' then TCR_EL2().TBID1 else TCR_EL2().TBID0;
                end;
            else
                tbi = TCR_EL2().TBI;
                if IsFeatureImplemented(FEAT_PAuth) then tbid = TCR_EL2().TBID; end;
            end;
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            tbi = TCR_EL3().TBI;
            if IsFeatureImplemented(FEAT_PAuth) then tbid = TCR_EL3().TBID; end;
    end;

    return (if (tbi == '1' &amp;&amp; (!IsFeatureImplemented(FEAT_PAuth) || tbid == '0' ||
            !IsInstr)) then '1' else '0');
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.EffectiveTCMA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/EffectiveTCMA</h3>
      <p class="pseudocode">// EffectiveTCMA()
// ===============
// Returns the effective TCMA of a virtual address in the stage 1 translation regime for "el".

func <a id="func_EffectiveTCMA_2"/>EffectiveTCMA(address : bits(64), el : bits(2)) =&gt; bit
begin
    var tcma : bit;
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(el);
    let regime : bits(2) = <a href="shared_pseudocode.html#func_S1TranslationRegime_1" title="">S1TranslationRegime</a>(el);
    assert(!<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(regime));

    case regime of
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            tcma = if address[55] == '1' then TCR_EL1().TCMA1 else TCR_EL1().TCMA0;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            if IsFeatureImplemented(FEAT_VHE) &amp;&amp; <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(el) then
                tcma = if address[55] == '1' then TCR_EL2().TCMA1 else TCR_EL2().TCMA0;
            else
                tcma = TCR_EL2().TCMA;
            end;
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            tcma = TCR_EL3().TCMA;
    end;

    return tcma;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.ErrorState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/ErrorState</h3>
      <p class="pseudocode">// ErrorState
// ==========
// The allowed error states that can be returned by memory and used by the PE.

type <a id="type_ErrorState"/>ErrorState of enumeration {
                        <a id="enum_ErrorState_UC"/>ErrorState_UC,            // Uncontainable
                        <a id="enum_ErrorState_UEU"/>ErrorState_UEU,           // Unrecoverable state
                        <a id="enum_ErrorState_UEO"/>ErrorState_UEO,           // Restartable state
                        <a id="enum_ErrorState_UER"/>ErrorState_UER,           // Recoverable state
                        <a id="enum_ErrorState_CE"/>ErrorState_CE};           // Corrected</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Fault"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Fault</h3>
      <p class="pseudocode">// Fault
// =====
// Fault types.

type <a id="type_Fault"/>Fault of enumeration {
                   <a id="enum_Fault_None"/>Fault_None,
                   <a id="enum_Fault_AccessFlag"/>Fault_AccessFlag,
                   <a id="enum_Fault_Alignment"/>Fault_Alignment,
                   <a id="enum_Fault_Background"/>Fault_Background,
                   <a id="enum_Fault_Domain"/>Fault_Domain,
                   <a id="enum_Fault_Permission"/>Fault_Permission,
                   <a id="enum_Fault_Translation"/>Fault_Translation,
                   <a id="enum_Fault_AddressSize"/>Fault_AddressSize,
                   <a id="enum_Fault_SyncExternal"/>Fault_SyncExternal,
                   <a id="enum_Fault_SyncExternalOnWalk"/>Fault_SyncExternalOnWalk,
                   <a id="enum_Fault_SyncParity"/>Fault_SyncParity,
                   <a id="enum_Fault_SyncParityOnWalk"/>Fault_SyncParityOnWalk,
                   <a id="enum_Fault_GPCFOnWalk"/>Fault_GPCFOnWalk,
                   <a id="enum_Fault_GPCFOnOutput"/>Fault_GPCFOnOutput,
                   <a id="enum_Fault_AsyncParity"/>Fault_AsyncParity,
                   <a id="enum_Fault_AsyncExternal"/>Fault_AsyncExternal,
                   <a id="enum_Fault_TagCheck"/>Fault_TagCheck,
                   <a id="enum_Fault_Debug"/>Fault_Debug,
                   <a id="enum_Fault_TLBConflict"/>Fault_TLBConflict,
                   <a id="enum_Fault_BranchTarget"/>Fault_BranchTarget,
                   <a id="enum_Fault_HWUpdateAccessFlag"/>Fault_HWUpdateAccessFlag,
                   <a id="enum_Fault_Lockdown"/>Fault_Lockdown,
                   <a id="enum_Fault_Exclusive"/>Fault_Exclusive,
                   <a id="enum_Fault_ICacheMaint"/>Fault_ICacheMaint};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.FaultRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/FaultRecord</h3>
      <p class="pseudocode">// FaultRecord
// ===========
// Fields that relate only to Faults.

type <a id="type_FaultRecord"/>FaultRecord of record {
    statuscode : <a href="shared_pseudocode.html#type_Fault" title="">Fault</a>,             // Fault Status
    accessdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,  // Details of the faulting access
    vaddress   : bits(64),          // Faulting virtual address
    ipaddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>,        // Intermediate physical address
    paddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>,         // Physical address
    gpcf : <a href="shared_pseudocode.html#type_GPCFRecord" title="">GPCFRecord</a>,              // Granule Protection Check Fault record
    gpcfs2walk : boolean,           // GPC for a stage 2 translation table walk
    s2fs1walk : boolean,            // Is on a Stage 1 translation table walk
    write : boolean,                // TRUE for a write, FALSE for a read
    s1tagnotdata : boolean,         // TRUE for a fault due to tag not accessible at stage 1.
    tagaccess : boolean,            // TRUE for a fault due to NoTagAccess permission.
    level : integer,                // For translation, access flag and Permission faults
    extflag : bit,                  // IMPLEMENTATION DEFINED syndrome for External aborts
    secondstage : boolean,          // Is a Stage 2 abort
    assuredonly : boolean,          // Stage 2 Permission fault due to AssuredOnly attribute
    toplevel    : boolean,             // Stage 2 Permission fault due to TopLevel
    overlay : boolean,              // Fault due to overlay permissions
    dirtybit : boolean,             // Fault due to dirty state
    domain : bits(4),               // Domain number, AArch32 only
    merrorstate : <a href="shared_pseudocode.html#type_ErrorState" title="">ErrorState</a>,       // Incoming error state from memory
    hdbssf : boolean,               // Fault caused by HDBSS
    watchptinfo : <a href="shared_pseudocode.html#type_WatchpointInfo" title="">WatchpointInfo</a>,   // Watchpoint related fields
    debugmoe : bits(4)              // Debug method of entry, from AArch32 only

};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.FullAddress"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/FullAddress</h3>
      <p class="pseudocode">// FullAddress
// ===========
// Physical or Intermediate Physical Address type.
// Although AArch32 only has access to 40 bits of physical or intermediate physical address space,
// the full address type has 56 bits to allow interprocessing with AArch64.
// The maximum physical or intermediate physical address size is IMPLEMENTATION DEFINED,
// but never exceeds 56 bits.

type <a id="type_FullAddress"/>FullAddress of record {
    paspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>,
    address : bits(56)

};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.GPCF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/GPCF</h3>
      <p class="pseudocode">// GPCF
// ====
// Possible Granule Protection Check Fault reasons

type <a id="type_GPCF"/>GPCF of enumeration {
    <a id="enum_GPCF_None"/>GPCF_None,        // No fault
    <a id="enum_GPCF_AddressSize"/>GPCF_AddressSize, // GPT address size fault
    <a id="enum_GPCF_Walk"/>GPCF_Walk,        // GPT walk fault
    <a id="enum_GPCF_EABT"/>GPCF_EABT,        // Synchronous External abort on GPT fetch
    <a id="enum_GPCF_Fail"/>GPCF_Fail         // Granule protection fault
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.GPCFRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/GPCFRecord</h3>
      <p class="pseudocode">// GPCFRecord
// ==========
// Full details of a Granule Protection Check Fault

type <a id="type_GPCFRecord"/>GPCFRecord of record {
    gpf : <a href="shared_pseudocode.html#type_GPCF" title="">GPCF</a>,
    level : integer
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Hint_Prefetch"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Hint_Prefetch</h3>
      <p class="pseudocode">// Hint_Prefetch()
// ===============
// Signals the memory system that memory accesses of type HINT to or from the specified address are
// likely in the near future. The memory system may take some action to speed up the memory
// accesses when they do occur, such as pre-loading the specified address into one or more
// caches as indicated by the innermost cache level target (0=L1, 1=L2, etc) and non-temporal hint
// stream. Any or all prefetch hints may be treated as a NOP. A prefetch hint must not cause a
// synchronous abort due to Alignment or Translation faults and the like. Its only effect on
// software-visible state should be on caches and TLBs associated with address, which must be
// accessible by reads, writes or execution, as defined in the translation regime of the current
// Exception level. It is guaranteed not to access Device memory.
// A Prefetch_EXEC hint must not result in an access that could not be performed by a speculative
// instruction fetch, therefore if all associated MMUs are disabled, then it cannot access any
// memory location that cannot be accessed by instruction fetches.

impdef func Hint_Prefetch(address : bits(64),
                          hint : <a href="shared_pseudocode.html#PrefetchHint" title="type PrefetchHint">PrefetchHint</a>,
                          target : integer,
                          stream : boolean)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Hint_RangePrefetch"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Hint_RangePrefetch</h3>
      <p class="pseudocode">// Hint_RangePrefetch()
// ====================
// Signals the memory system that data memory accesses from a specified range
// of addresses are likely to occur in the near future. The memory system can
// respond by taking actions that are expected to speed up the memory accesses
// when they do occur, such as preloading the locations within the specified
// address ranges into one or more caches.

impdef func Hint_RangePrefetch(address : bits(64), length : integer, stride : integer,
                               count : integer, reuse : integer, operation : bits(6))
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.IsContiguousSVEAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/IsContiguousSVEAccess</h3>
      <p class="pseudocode">// IsContiguousSVEAccess()
// =======================
// Return TRUE if memory access is contiguous load/stores in an SVE mode.

func <a id="func_IsContiguousSVEAccess_1"/>IsContiguousSVEAccess(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    return (IsFeatureImplemented(FEAT_SVE) &amp;&amp;
            accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_SVE" title="">AccessType_SVE</a> &amp;&amp;
            accdesc.contiguous);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.IsRelaxedWatchpointAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/IsRelaxedWatchpointAccess</h3>
      <p class="pseudocode">// IsRelaxedWatchpointAccess()
// ===========================
// Return TRUE if memory access is one of -
// - SIMD&amp;FP load/store instruction when the PE is in Streaming SVE mode
// - SVE contiguous vector load/store instruction.
// - SME load/store instruction

func <a id="func_IsRelaxedWatchpointAccess_1"/>IsRelaxedWatchpointAccess(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    return (<a href="shared_pseudocode.html#func_IsContiguousSVEAccess_1" title="">IsContiguousSVEAccess</a>(accdesc) ||
            <a href="shared_pseudocode.html#func_IsSMEAccess_1" title="">IsSMEAccess</a>(accdesc) ||
            (<a href="shared_pseudocode.html#func_IsSIMDFPAccess_1" title="">IsSIMDFPAccess</a>(accdesc) &amp;&amp; <a href="shared_pseudocode.html#func_InStreamingMode_0" title="">InStreamingMode</a>()));
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.IsSIMDFPAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/IsSIMDFPAccess</h3>
      <p class="pseudocode">// IsSIMDFPAccess()
// ================
// Return TRUE if access is SIMD&amp;FP.

func <a id="func_IsSIMDFPAccess_1"/>IsSIMDFPAccess(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    return accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.IsSMEAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/IsSMEAccess</h3>
      <p class="pseudocode">// IsSMEAccess()
// =============
// Return TRUE if access is of SME load/stores.

func <a id="func_IsSMEAccess_1"/>IsSMEAccess(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    return IsFeatureImplemented(FEAT_SME) &amp;&amp; accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_SME" title="">AccessType_SME</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.IsWatchpointableAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/IsWatchpointableAccess</h3>
      <p class="pseudocode">// IsWatchpointableAccess()
// ========================
// Return TRUE if access should be checked for watchpoints.

func <a id="func_IsWatchpointableAccess_1"/>IsWatchpointableAccess(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    return (!(accdesc.acctype IN {<a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a>,
                                  <a href="shared_pseudocode.html#enum_AccessType_TTW" title="">AccessType_TTW</a>,
                                  <a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a>,
                                  <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a>,
                                  <a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a>,
                                  <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a>,
                                  <a href="shared_pseudocode.html#enum_AccessType_AT" title="">AccessType_AT</a>}) ||
            (accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a> &amp;&amp;
             accdesc.cacheop == <a href="shared_pseudocode.html#enum_CacheOp_Invalidate" title="">CacheOp_Invalidate</a> &amp;&amp;
             (!<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() || (ImpDefBool("DCIMVAC generates watchpoint")))));
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MBReqDomain"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MBReqDomain</h3>
      <p class="pseudocode">// MBReqDomain
// ===========
// Memory barrier domain.

type <a id="type_MBReqDomain"/>MBReqDomain of enumeration {<a id="enum_MBReqDomain_Nonshareable"/>MBReqDomain_Nonshareable, <a id="enum_MBReqDomain_InnerShareable"/>MBReqDomain_InnerShareable,
                                 <a id="enum_MBReqDomain_OuterShareable"/>MBReqDomain_OuterShareable, <a id="enum_MBReqDomain_FullSystem"/>MBReqDomain_FullSystem};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MBReqTypes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MBReqTypes</h3>
      <p class="pseudocode">// MBReqTypes
// ==========
// Memory barrier read/write.

type <a id="MBReqTypes"/>MBReqTypes of enumeration {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemAtomicOp"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemAtomicOp</h3>
      <p class="pseudocode">// MemAtomicOp
// ===========
// Atomic data processing instruction types.

type <a id="type_MemAtomicOp"/>MemAtomicOp of enumeration {
    <a id="enum_MemAtomicOp_GCSSS1"/>MemAtomicOp_GCSSS1,
    <a id="enum_MemAtomicOp_ADD"/>MemAtomicOp_ADD,
    <a id="enum_MemAtomicOp_BIC"/>MemAtomicOp_BIC,
    <a id="enum_MemAtomicOp_EOR"/>MemAtomicOp_EOR,
    <a id="enum_MemAtomicOp_ORR"/>MemAtomicOp_ORR,
    <a id="enum_MemAtomicOp_SMAX"/>MemAtomicOp_SMAX,
    <a id="enum_MemAtomicOp_SMIN"/>MemAtomicOp_SMIN,
    <a id="enum_MemAtomicOp_UMAX"/>MemAtomicOp_UMAX,
    <a id="enum_MemAtomicOp_UMIN"/>MemAtomicOp_UMIN,
    <a id="enum_MemAtomicOp_SWP"/>MemAtomicOp_SWP,
    <a id="enum_MemAtomicOp_CAS"/>MemAtomicOp_CAS,
    <a id="enum_MemAtomicOp_FPADD"/>MemAtomicOp_FPADD,
    <a id="enum_MemAtomicOp_FPMAX"/>MemAtomicOp_FPMAX,
    <a id="enum_MemAtomicOp_FPMIN"/>MemAtomicOp_FPMIN,
    <a id="enum_MemAtomicOp_FPMAXNM"/>MemAtomicOp_FPMAXNM,
    <a id="enum_MemAtomicOp_FPMINNM"/>MemAtomicOp_FPMINNM,
    <a id="enum_MemAtomicOp_BFADD"/>MemAtomicOp_BFADD,
    <a id="enum_MemAtomicOp_BFMAX"/>MemAtomicOp_BFMAX,
    <a id="enum_MemAtomicOp_BFMIN"/>MemAtomicOp_BFMIN,
    <a id="enum_MemAtomicOp_BFMAXNM"/>MemAtomicOp_BFMAXNM,
    <a id="enum_MemAtomicOp_BFMINNM"/>MemAtomicOp_BFMINNM
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemAttrHints"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemAttrHints</h3>
      <p class="pseudocode">// MemAttrHints
// ============
// Attributes and hints for Normal memory.

type <a id="type_MemAttrHints"/>MemAttrHints of record {
    attrs : bits(2),  // See MemAttr_*, Cacheability attributes
    hints : bits(2),  // See MemHint_*, Allocation hints
    transient : boolean
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemOp"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemOp</h3>
      <p class="pseudocode">// MemOp
// =====
// Memory access instruction types.

type <a id="MemOp"/>MemOp of enumeration {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemType</h3>
      <p class="pseudocode">// MemType
// =======
// Basic memory types.

type <a id="MemType"/>MemType of enumeration {MemType_Normal, MemType_Device};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Memory"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Memory</h3>
      <p class="pseudocode">// Memory Tag type
// ===============

type <a id="type_MemTagType"/>MemTagType of enumeration {
    <a id="enum_MemTag_AllocationTagged"/>MemTag_AllocationTagged,
    <a id="enum_MemTag_CanonicallyTagged"/>MemTag_CanonicallyTagged,
    <a id="enum_MemTag_Untagged"/>MemTag_Untagged
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemoryAttributes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemoryAttributes</h3>
      <p class="pseudocode">// MemoryAttributes
// ================
// Memory attributes descriptor

type MemoryAttributes of record {
    memtype : <a href="shared_pseudocode.html#MemType" title="type MemType">MemType</a>,
    device : DeviceType,         // For Device memory types
    inner : MemAttrHints,        // Inner hints and attributes
    outer : MemAttrHints,        // Outer hints and attributes
    shareability : Shareability, // Shareability attribute
    tags : MemTagType,           // MTE tag type for this memory.
    notagaccess : boolean,       // Allocation Tag access permission
    xs : bit                     // XS attribute
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.NewAccDesc"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/NewAccDesc</h3>
      <p class="pseudocode">// NewAccDesc()
// ============
// Create a new AccessDescriptor with initialised fields

func <a id="func_NewAccDesc_1"/>NewAccDesc(acctype : <a href="shared_pseudocode.html#type_AccessType" title="">AccessType</a>) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    let mpaminfo : MPAMinfo = <a href="shared_pseudocode.html#func_GenMPAMCurEL_1" title="">GenMPAMCurEL</a>(acctype);
    return <a href="shared_pseudocode.html#func_NewAccDesc_2" title="">NewAccDesc</a>(acctype, mpaminfo);
end;

func <a id="func_NewAccDesc_2"/>NewAccDesc(acctype : <a href="shared_pseudocode.html#type_AccessType" title="">AccessType</a>, mpam : MPAMinfo) =&gt; <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
begin
    var accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>;

    accdesc.acctype             = acctype;
    accdesc.el                  = PSTATE.EL;
    accdesc.ss                  = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(PSTATE.EL);
    accdesc.acqsc               = FALSE;
    accdesc.acqpc               = FALSE;
    accdesc.relsc               = FALSE;
    accdesc.limitedordered      = FALSE;
    accdesc.exclusive           = FALSE;
    accdesc.rcw                 = FALSE;
    accdesc.rcws                = FALSE;
    accdesc.atomicop            = FALSE;
    accdesc.nontemporal         = FALSE;
    accdesc.read                = FALSE;
    accdesc.write               = FALSE;
    accdesc.pan                 = FALSE;
    accdesc.nonfault            = FALSE;
    accdesc.firstfault          = FALSE;
    accdesc.first               = FALSE;
    accdesc.contiguous          = FALSE;
    accdesc.predicated          = FALSE;
    accdesc.streamingsve        = FALSE;
    accdesc.ls64                = FALSE;
    accdesc.withstatus          = FALSE;
    accdesc.mops                = FALSE;
    accdesc.a32lsmd             = FALSE;
    accdesc.tagchecked          = FALSE;
    accdesc.tagaccess           = FALSE;
    accdesc.stzgm               = FALSE;
    accdesc.mpam                = mpam;
    accdesc.Rs                  = -1;
    accdesc.Rs2                 = -1;
    accdesc.Rt                  = -1;
    accdesc.Rt2                 = -1;
    accdesc.ispair              = FALSE;
    accdesc.highestaddressfirst = FALSE;
    accdesc.lowestaddress       = TRUE;

    return accdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PASpace"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PASpace</h3>
      <p class="pseudocode">// PASpace
// =======
// Physical address spaces

type <a id="type_PASpace"/>PASpace of enumeration {
    <a id="enum_PAS_Root"/>PAS_Root,
    <a id="enum_PAS_SystemAgent"/>PAS_SystemAgent,
    <a id="enum_PAS_NonSecureProtected"/>PAS_NonSecureProtected,
    <a id="enum_PAS_NA6"/>PAS_NA6,                // Reserved
    <a id="enum_PAS_NA7"/>PAS_NA7,                // Reserved
    <a id="enum_PAS_Realm"/>PAS_Realm,
    <a id="enum_PAS_Secure"/>PAS_Secure,
    <a id="enum_PAS_NonSecure"/>PAS_NonSecure
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Permissions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Permissions</h3>
      <p class="pseudocode">// Permissions
// ===========
// Access Control bits in translation table descriptors

type <a id="type_Permissions"/>Permissions of record {
    ap_table  : bits(2),  // Stage 1 hierarchical access permissions
    xn_table  : bit,      // Stage 1 hierarchical execute-never for single EL regimes
    pxn_table : bit,      // Stage 1 hierarchical privileged execute-never
    uxn_table : bit,      // Stage 1 hierarchical unprivileged execute-never
    ap  : bits(3),        // Stage 1 access permissions
    xn  : bit,            // Stage 1 execute-never for single EL regimes
    uxn : bit,            // Stage 1 unprivileged execute-never
    pxn : bit,            // Stage 1 privileged execute-never
    ppi : bits(4),        // Stage 1 privileged indirect permissions
    upi : bits(4),        // Stage 1 unprivileged indirect permissions
    ndirty : bit,         // Stage 1 dirty state for indirect permissions scheme
    s2pi    : bits(4),    // Stage 2 indirect permissions
    s2dirty : bit,        // Stage 2 dirty state
    po_index : bits(4),   // Stage 1 overlay permissions index
    s2po_index : bits(4), // Stage 2 overlay permissions index
    s2ap : bits(2),       // Stage 2 access permissions
    s2tag_na : bit,       // Stage 2 tag access
    s2xnx : bit,          // Stage 2 extended execute-never
    dbm : bit,            // Dirty bit management
    s2xn : bit            // Stage 2 execute-never
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PhysMemRead"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PhysMemRead</h3>
      <p class="pseudocode">// PhysMemRead()
// =============
// Returns the value read from memory, and a status.
// Returned value is UNKNOWN if an External abort occurred while reading the
// memory.
// Otherwise the PhysMemRetStatus statuscode is Fault_None.

impdef func <a id="func_PhysMemRead_3"/>PhysMemRead{size : integer{8, 16, 32, 64, 128, 256, 512}}(
                                                    desc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                                                    accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>
                                            ) =&gt; (<a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>, bits(size))
begin
    return (ARBITRARY : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>, ARBITRARY : bits(size));
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PhysMemRetStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PhysMemRetStatus</h3>
      <p class="pseudocode">// PhysMemRetStatus
// ================
// Fields that relate only to return values of PhysMem functions.

type <a id="type_PhysMemRetStatus"/>PhysMemRetStatus of record {
    statuscode : <a href="shared_pseudocode.html#type_Fault" title="">Fault</a>,       // Fault Status
    extflag : bit,            // IMPLEMENTATION DEFINED syndrome for External aborts
    merrorstate : <a href="shared_pseudocode.html#type_ErrorState" title="">ErrorState</a>, // Optional error state returned on a physical memory access
    store64bstatus : bits(64) // Status of 64B store

};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PhysMemWrite"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PhysMemWrite</h3>
      <p class="pseudocode">// PhysMemWrite()
// ==============
// Writes the value to memory, and returns the status of the write.
// If there is an External abort on the write, the PhysMemRetStatus indicates this.
// Otherwise the statuscode of PhysMemRetStatus is Fault_None.

impdef func <a id="func_PhysMemWrite_4"/>PhysMemWrite{size : integer{8, 16, 32, 64, 128, 256, 512}}(desc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                                                                       accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                                value : bits(size)) =&gt; <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>
begin
    return ARBITRARY : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PrefetchHint"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PrefetchHint</h3>
      <p class="pseudocode">// PrefetchHint
// ============
// Prefetch hint types.

type <a id="PrefetchHint"/>PrefetchHint of enumeration {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.S1AccessControls"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/S1AccessControls</h3>
      <p class="pseudocode">// S1AccessControls
// ================
// Effective access controls defined by stage 1 translation

type <a id="type_S1AccessControls"/>S1AccessControls of record {
    r : bit,                 // Stage 1 base read permission
    w : bit,                 // Stage 1 base write permission
    x : bit,                 // Stage 1 base execute permission
    gcs : bit,               // Stage 1 GCS permission
    overlay : boolean,       // Stage 1 FEAT_S1POE overlay applies
    or : bit,                // Stage 1 FEAT_S1POE overlay read permission
    ow : bit,                // Stage 1 FEAT_S1POE overlay write permission
    ox : bit,                // Stage 1 FEAT_S1POE overlay execute permission
    wxn : bit                // Stage 1 write permission implies execute-never

};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.S2AccessControls"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/S2AccessControls</h3>
      <p class="pseudocode">// S2AccessControls
// ================
// Effective access controls defined by stage 2 translation

type <a id="type_S2AccessControls"/>S2AccessControls of record {
    r : bit,                 // Stage 2 read permission.
    w : bit,                 // Stage 2 write permission.
    x : bit,                 // Stage 2 execute permission.
    r_rcw : bit,             // Stage 2 Read perms for RCW instruction.
    w_rcw : bit,             // Stage 2 Write perms for RCW instruction.
    r_mmu : bit,             // Stage 2 Read perms for TTW data.
    w_mmu : bit,             // Stage 2 Write perms for TTW data.
    toplevel0 : bit,         // IPA as top level table for TTBR0_EL1.
    toplevel1 : bit,         // IPA as top level table for TTBR1_EL1.
    overlay : boolean,       // Overlay enable
    or : bit,                // Stage 2 overlay read permission.
    ow : bit,                // Stage 2 overlay write permission.
    ox : bit,                // Stage 2 overlay execute permission.
    or_rcw : bit,            // Stage 2 overlay Read perms for RCW instruction.
    ow_rcw : bit,            // Stage 2 overlay Write perms for RCW instruction.
    or_mmu : bit,            // Stage 2 overlay Read perms for TTW data.
    ow_mmu : bit,            // Stage 2 overlay Write perms for TTW data.
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Shareability"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Shareability</h3>
      <p class="pseudocode">// Shareability
// ============

type <a id="type_Shareability"/>Shareability of enumeration {
    <a id="enum_Shareability_NSH"/>Shareability_NSH,
    <a id="enum_Shareability_ISH"/>Shareability_ISH,
    <a id="enum_Shareability_OSH"/>Shareability_OSH
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.SpeculativeStoreBypassBarrierToPA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/SpeculativeStoreBypassBarrierToPA</h3>
      <p class="pseudocode">// SpeculativeStoreBypassBarrierToPA()
// ===================================

impdef func SpeculativeStoreBypassBarrierToPA()
begin
    // Since there is no speculation in ASL model, this is a NOP.
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.SpeculativeStoreBypassBarrierToVA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/SpeculativeStoreBypassBarrierToVA</h3>
      <p class="pseudocode">// SpeculativeStoreBypassBarrierToVA()
// ===================================

impdef func SpeculativeStoreBypassBarrierToVA()
begin
    // Since there is no speculation in ASL model, this is a NOP.
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Tag"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Tag</h3>
      <p class="pseudocode">// Tag Granule size
// ================

constant <a id="global_LOG2_TAG_GRANULE"/>LOG2_TAG_GRANULE : integer{} = 4;

constant <a id="global_TAG_GRANULE"/>TAG_GRANULE : integer{} = 1 &lt;&lt; <a href="shared_pseudocode.html#global_LOG2_TAG_GRANULE" title="">LOG2_TAG_GRANULE</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.VARange"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/VARange</h3>
      <p class="pseudocode">// VARange
// =======
// Virtual address ranges

type <a id="type_VARange"/>VARange of enumeration {
    <a id="enum_VARange_LOWER"/>VARange_LOWER,
    <a id="enum_VARange_UPPER"/>VARange_UPPER
};</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.AltPARTIDSpace"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/AltPARTIDSpace</h3>
      <p class="pseudocode">// AltPARTIDSpace()
// ================
// From the Security state, EL and ALTSP configuration, determine
// whether to primary space or the alt space is selected and which
// PARTID space is the alternative space. Return that alternative
// PARTID space if selected or the primary space if not.

func <a id="func_AltPARTIDSpace_3"/>AltPARTIDSpace(el : bits(2), security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>,
                    primaryPIDSpace : PARTIDSpaceType) =&gt; PARTIDSpaceType
begin
    case security of
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;
            assert el != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
            return primaryPIDSpace;
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;
            assert el != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
            if primaryPIDSpace == PIDSpace_NonSecure then
                return primaryPIDSpace;
            end;
            return <a href="shared_pseudocode.html#func_AltPIDSecure_2" title="">AltPIDSecure</a>(el, primaryPIDSpace);
        when <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> =&gt;
            assert el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
            if MPAM3_EL3().ALTSP_EL3 == '1' then
                if MPAM3_EL3().RT_ALTSP_NS == '1' then
                    return PIDSpace_NonSecure;
                else
                    return PIDSpace_Secure;
                end;
            else
                return primaryPIDSpace;
            end;
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;
            assert el != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
            return <a href="shared_pseudocode.html#func_AltPIDRealm_2" title="">AltPIDRealm</a>(el, primaryPIDSpace);
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.AltPIDRealm"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/AltPIDRealm</h3>
      <p class="pseudocode">// AltPIDRealm()
// =============
// Compute PARTID space as either the primary PARTID space or
// alternative PARTID space in the Realm Security state.
// Helper for AltPARTIDSpace.

func <a id="func_AltPIDRealm_2"/>AltPIDRealm(el : bits(2), primaryPIDSpace : PARTIDSpaceType) =&gt; PARTIDSpaceType
begin
    var PIDSpace : PARTIDSpaceType = primaryPIDSpace;
    case el of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) then
                if !<a href="shared_pseudocode.html#func_UsePrimarySpaceEL2_0" title="">UsePrimarySpaceEL2</a>() then
                    PIDSpace = PIDSpace_NonSecure;
                end;
            elsif !<a href="shared_pseudocode.html#func_UsePrimarySpaceEL10_0" title="">UsePrimarySpaceEL10</a>() then
                PIDSpace = PIDSpace_NonSecure;
            end;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            if !<a href="shared_pseudocode.html#func_UsePrimarySpaceEL10_0" title="">UsePrimarySpaceEL10</a>() then
                PIDSpace = PIDSpace_NonSecure;
            end;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            if !<a href="shared_pseudocode.html#func_UsePrimarySpaceEL2_0" title="">UsePrimarySpaceEL2</a>() then
                PIDSpace = PIDSpace_NonSecure;
            end;
        otherwise =&gt;
            unreachable;
    end;
    return PIDSpace;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.AltPIDSecure"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/AltPIDSecure</h3>
      <p class="pseudocode">// AltPIDSecure()
// ==============
// Compute PARTID space as either the primary PARTID space or
// alternative PARTID space in the Secure Security state.
// Helper for AltPARTIDSpace.

func <a id="func_AltPIDSecure_2"/>AltPIDSecure(el : bits(2), primaryPIDSpace : PARTIDSpaceType) =&gt; PARTIDSpaceType
begin
    var PIDSpace : PARTIDSpaceType = primaryPIDSpace;
    case el of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
                if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) then
                    if !<a href="shared_pseudocode.html#func_UsePrimarySpaceEL2_0" title="">UsePrimarySpaceEL2</a>() then
                        PIDSpace = PIDSpace_NonSecure;
                    end;
                elsif !<a href="shared_pseudocode.html#func_UsePrimarySpaceEL10_0" title="">UsePrimarySpaceEL10</a>() then
                    PIDSpace = PIDSpace_NonSecure;
                end;
            elsif MPAM3_EL3().ALTSP_HEN == '0' &amp;&amp; MPAM3_EL3().ALTSP_HFC == '1' then
                PIDSpace = PIDSpace_NonSecure;
            end;
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
                if !<a href="shared_pseudocode.html#func_UsePrimarySpaceEL10_0" title="">UsePrimarySpaceEL10</a>() then
                    PIDSpace = PIDSpace_NonSecure;
                end;
            elsif MPAM3_EL3().ALTSP_HEN == '0' &amp;&amp; MPAM3_EL3().ALTSP_HFC == '1' then
                PIDSpace = PIDSpace_NonSecure;
            end;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            if !<a href="shared_pseudocode.html#func_UsePrimarySpaceEL2_0" title="">UsePrimarySpaceEL2</a>() then
                PIDSpace = PIDSpace_NonSecure;
            end;
        otherwise =&gt;
            unreachable;
    end;
    return PIDSpace;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.DefaultMPAMInfo"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/DefaultMPAMInfo</h3>
      <p class="pseudocode">// DefaultMPAMInfo()
// =================
// Returns default MPAM info.  The partidspace argument sets
// the PARTID space of the default MPAM information returned.

func <a id="func_DefaultMPAMInfo_1"/>DefaultMPAMInfo(partidspace : PARTIDSpaceType) =&gt; MPAMinfo
begin
    var defaultinfo : MPAMinfo;
    defaultinfo.mpam_sp = partidspace;
    defaultinfo.partid  = DEFAULT_PARTID;
    defaultinfo.pmg     = DEFAULT_PMG;
    return defaultinfo;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.GenMPAM"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/GenMPAM</h3>
      <p class="pseudocode">// GenMPAM()
// =========
// Returns MPAMinfo for Exception level el.
// If mpamdata.sm is TRUE returns MPAM information using MPAMSM_EL1.
// If mpamdata.trb is TRUE returns MPAM information using TRBMPAM_EL1.
// If mpamdata.in_d is TRUE and alternative ID is enabled returns MPAM information
// using MPAMn_ELx.[altPARTID, altPMG].
// Otherwise returns MPAM information using MPAMn_ELx.

func GenMPAM(el_in : bits(2), mpamdata : MPAMdata, pspace : PARTIDSpaceType) =&gt; MPAMinfo
begin
    var returninfo : MPAMinfo;
    var partidel : <a href="shared_pseudocode.html#PARTIDType" title="type PARTIDType">PARTIDType</a>;
    var perr : boolean;
    var el : bits(2) = el_in;

    // Check if the guest OS application is locked by the EL2 hypervisor to
    // only use the EL1 virtual machine's PARTIDs.
    if (!IsFeatureImplemented(FEAT_MPAMv2) &amp;&amp; el == EL0 &amp;&amp; EL2Enabled() &amp;&amp;
          MPAMHCR_EL2().GSTAPP_PLK == '1' &amp;&amp; HCR_EL2().TGE == '0') then
        el = EL1;
    end;

    (partidel, perr)      = GenPARTID(el, mpamdata, pspace);
    let groupel : <a href="shared_pseudocode.html#PMGType" title="type PMGType">PMGType</a> = GenPMG(el, mpamdata, perr, pspace);

    returninfo.mpam_sp = pspace;
    returninfo.partid  = partidel;
    returninfo.pmg     = groupel;
    return returninfo;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.GenMPAMAtEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/GenMPAMAtEL</h3>
      <p class="pseudocode">// GenMPAMAtEL()
// =============
// Returns MPAMinfo for the specified EL.
// May be called if MPAM is not implemented (but in an version that supports
// MPAM), MPAM is disabled, or in AArch32_  In AArch32, convert the mode to
// EL if can and use that to drive MPAM information generation.  If mode
// cannot be converted, MPAM is not implemented, or MPAM is disabled return
// default MPAM information for the current security state.

func <a id="func_GenMPAMAtEL_2"/>GenMPAMAtEL(acctype : <a href="shared_pseudocode.html#type_AccessType" title="">AccessType</a>, el : bits(2)) =&gt; MPAMinfo
begin
    var mpamEL : bits(2);
    var pspace : PARTIDSpaceType;
    let security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(el);
    var mpamdata : MPAMdata      = <a href="shared_pseudocode.html#func_GenNewMPAMData_0" title="">GenNewMPAMData</a>();
    if IsFeatureImplemented(FEAT_MPAMv2_MSC) &amp;&amp; IsFeatureImplemented(FEAT_RME) then
        pspace = PIDSpace_NonSecure;
    else
        pspace = <a href="shared_pseudocode.html#func_PARTIDSpaceFromSS_1" title="">PARTIDSpaceFromSS</a>(security);
    end;
    if pspace == PIDSpace_NonSecure &amp;&amp; !<a href="shared_pseudocode.html#func_MPAMIsEnabled_0" title="">MPAMIsEnabled</a>() then
        return <a href="shared_pseudocode.html#func_DefaultMPAMInfo_1" title="">DefaultMPAMInfo</a>(pspace);
    end;
    mpamEL = if acctype == <a href="shared_pseudocode.html#enum_AccessType_NV2" title="">AccessType_NV2</a> then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else el;
    case acctype of
        when <a href="shared_pseudocode.html#enum_AccessType_IFETCH" title="">AccessType_IFETCH</a>, <a href="shared_pseudocode.html#enum_AccessType_IC" title="">AccessType_IC</a> =&gt;
            mpamdata.in_d = TRUE;
        when <a href="shared_pseudocode.html#enum_AccessType_SME" title="">AccessType_SME</a> =&gt;
            mpamdata.sm = (ImpDefBool("Shared SMCU") ||
                           ImpDefBool("MPAMSM_EL1 label precedence"));
        when <a href="shared_pseudocode.html#enum_AccessType_FP" title="">AccessType_FP</a>, <a href="shared_pseudocode.html#enum_AccessType_ASIMD" title="">AccessType_ASIMD</a>, <a href="shared_pseudocode.html#enum_AccessType_SVE" title="">AccessType_SVE</a> =&gt;
            mpamdata.sm = (IsFeatureImplemented(FEAT_SME) &amp;&amp; PSTATE.SM == '1' &amp;&amp;
                           (ImpDefBool("Shared SMCU") ||
                            ImpDefBool("MPAMSM_EL1 label precedence")));
        when <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a> =&gt;
            if !<a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() then
                if !IsFeatureImplemented(FEAT_TRBE_MPAM) || TRBMPAM_EL1().EN == '0' then
                    return <a href="shared_pseudocode.html#func_DefaultMPAMInfo_1" title="">DefaultMPAMInfo</a>(pspace);
                else
                    mpamdata.trb = TRUE;
                end;
            end;
            if !IsFeatureImplemented(FEAT_MPAMv2) &amp;&amp; mpamdata.trb then
                var ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>;
                case TRBMPAM_EL1().MPAM_SP of
                    when '00' =&gt; ss = <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
                    when '01' =&gt; ss = <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;
                    when '10' =&gt; ss = <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a>;
                    when '11' =&gt; ss = <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a>;
                end;
                pspace = <a href="shared_pseudocode.html#func_PARTIDSpaceFromSS_1" title="">PARTIDSpaceFromSS</a>(ss);
            end;
        otherwise =&gt;
            // Other access types are DATA accesses
            mpamdata.in_d = FALSE;
    end;
    if (IsFeatureImplemented(FEAT_RME) &amp;&amp; !IsFeatureImplemented(FEAT_MPAMv2) &amp;&amp;
          MPAMIDR_EL1().HAS_ALTSP == '1') then
        // Substitute alternative PARTID space if selected
        pspace = <a href="shared_pseudocode.html#func_AltPARTIDSpace_3" title="">AltPARTIDSpace</a>(mpamEL, security, pspace);
    end;
    if IsFeatureImplemented(FEAT_MPAMv0p1) &amp;&amp; MPAMIDR_EL1().HAS_FORCE_NS == '1' then
        if MPAM3_EL3().FORCE_NS == '1' &amp;&amp; security == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
            pspace = PIDSpace_NonSecure;
        end;
    end;
    if ((IsFeatureImplemented(FEAT_MPAMv0p1) || IsFeatureImplemented(FEAT_MPAMv1p1)) &amp;&amp;
          MPAMIDR_EL1().HAS_SDEFLT == '1') then
        if MPAM3_EL3().SDEFLT == '1' &amp;&amp; security == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
            return <a href="shared_pseudocode.html#func_DefaultMPAMInfo_1" title="">DefaultMPAMInfo</a>(pspace);
        end;
    end;
    if !<a href="shared_pseudocode.html#func_MPAMIsEnabled_0" title="">MPAMIsEnabled</a>() then
        return <a href="shared_pseudocode.html#func_DefaultMPAMInfo_1" title="">DefaultMPAMInfo</a>(pspace);
    else
        return GenMPAM(mpamEL, mpamdata, pspace);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.GenMPAMCurEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/GenMPAMCurEL</h3>
      <p class="pseudocode">// GenMPAMCurEL()
// ==============
// Returns MPAMinfo for the current EL and security state.
// May be called if MPAM is not implemented (but in an version that supports
// MPAM), MPAM is disabled, or in AArch32_  In AArch32, convert the mode to
// EL if can and use that to drive MPAM information generation.  If mode
// cannot be converted, MPAM is not implemented, or MPAM is disabled return
// default MPAM information for the current security state.

func <a id="func_GenMPAMCurEL_1"/>GenMPAMCurEL(acctype : <a href="shared_pseudocode.html#type_AccessType" title="">AccessType</a>) =&gt; MPAMinfo
begin
    return <a href="shared_pseudocode.html#func_GenMPAMAtEL_2" title="">GenMPAMAtEL</a>(acctype, PSTATE.EL);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.GenNewMPAMData"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/GenNewMPAMData</h3>
      <p class="pseudocode">// GenNewMPAMData()
// ================

func <a id="func_GenNewMPAMData_0"/>GenNewMPAMData() =&gt; MPAMdata
begin
    var mpamdata : MPAMdata;
    mpamdata.in_d   = FALSE;
    mpamdata.sm  = FALSE;
    mpamdata.trb = FALSE;
    return mpamdata;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.GenPARTID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/GenPARTID</h3>
      <p class="pseudocode">// GenPARTID()
// ===========
// Returns physical PARTID and error boolean for Exception level el.
// If mpamdata.sm is TRUE then PARTID is from MPAMSM_EL1.
// If mpamdata.trb is TRUE then PARTID is from TRBMPAM_EL1.
// If mpamdata.in_d is TRUE and alternative ID is enabled then PARTID is from MPAMn_ELx.altPARTID.
// Otherwise, the PARTID is from MPAMn_ELx.

func GenPARTID(el : bits(2), mpamdata : MPAMdata, pspace : PARTIDSpaceType) =&gt; (<a href="shared_pseudocode.html#PARTIDType" title="type PARTIDType">PARTIDType</a>, boolean)
begin
    var partidel : <a href="shared_pseudocode.html#PARTIDType" title="type PARTIDType">PARTIDType</a> = GetMPAM_PARTID(el, mpamdata);
    if IsFeatureImplemented(FEAT_MPAMv2) then
        if PARTIDIsVirtual(el, mpamdata) then
            if !IsZero(MPAMVIDSR_EL2().FSC) then
                return (DEFAULT_PARTID, TRUE);
            end;
            // When the virtual identifier is greater than or equal to 2^12,
            // it is CONSTRAINED UNPREDICTABLE whether the virtual identifier is truncated
            // to its least significant 12 bits for translation, or it is replaced
            // by the default virtual identifier
            if (UInt(partidel) &gt;= 2^12 &amp;&amp;
                  !ConstrainUnpredictableBool(Unpredictable_MPAM_TRUNCATE_VID)) then
                partidel = DEFAULT_PARTID;
            end;
            return TranslatevPARTID(partidel[11:0], mpamdata, el, pspace);
        else
            return (partidel, FALSE);
        end;
    end;

    let partid_max : <a href="shared_pseudocode.html#PARTIDType" title="type PARTIDType">PARTIDType</a> = (if mpamdata.trb then TRBDEVID1().PARTID_MAX
                                   else MPAMIDR_EL1().PARTID_MAX);
    if UInt(partidel) &gt; UInt(partid_max) then
        return (DEFAULT_PARTID, TRUE);
    end;
    if MPAMIsVirtual(el, mpamdata) then
        return MAP_vPARTID(partidel);
    else
        return (partidel, FALSE);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.GenPMG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/GenPMG</h3>
      <p class="pseudocode">// GenPMG()
// ========
// Returns PMG for Exception level el.
// if mpamdata.sm is TRUE then PMG is from MPAMSM_EL1.
// If mpamdata.trb is TRUE then PMG is from TRBMPAM_EL1.
// If mpamdata.in_d is TRUE and alternative id is enabled, then the PMG is from MPAMn_ELx.altPMG.
// Otherwise, PMG is from MPAMn_ELx.
// If PARTID generation (GenPARTID) encountered an error, GenPMG() should be
// called with partid_err as TRUE.

func GenPMG(el : bits(2), mpamdata : MPAMdata, partid_err : boolean,
            pspace : PARTIDSpaceType) =&gt; <a href="shared_pseudocode.html#PMGType" title="type PMGType">PMGType</a>
begin
    if (!IsFeatureImplemented(FEAT_MPAMv2) &amp;&amp; partid_err &amp;&amp;
          ConstrainUnpredictableBool(Unpredictable_USE_DEFAULT_PMG)) then
        return DEFAULT_PMG;
    end;
    var groupel : <a href="shared_pseudocode.html#PMGType" title="type PMGType">PMGType</a> = GetMPAM_PMG(el, mpamdata);
    if IsFeatureImplemented(FEAT_MPAMv2) then
        if PMGIsVirtual(el, mpamdata) then
            if !IsZero(MPAMVIDSR_EL2().FSC) then
                return DEFAULT_PMG;
            end;
            // When the virtual identifier is greater than or equal to 2^12,
            // it is CONSTRAINED UNPREDICTABLE whether the virtual identifier is truncated
            // to its least significant 12 bits for translation, or it is replaced
            // by the default virtual identifier
            if (UInt(groupel) &gt;= 2^12 &amp;&amp;
                  !ConstrainUnpredictableBool(Unpredictable_MPAM_TRUNCATE_VID)) then
                groupel = DEFAULT_PMG;
            end;
            return TranslatevPMG(groupel[11:0], mpamdata, el, pspace);
        else
            return groupel;
        end;
    end;

    let pmg_max : integer = (if mpamdata.trb then UInt(TRBDEVID1().PMG_MAX)
                             else UInt(MPAMIDR_EL1().PMG_MAX));
    if UInt(groupel) &lt;= pmg_max then
        return groupel;
    end;
    return DEFAULT_PMG;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.GetMPAM_PARTID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/GetMPAM_PARTID</h3>
      <p class="pseudocode">// GetMPAM_PARTID()
// ================
// Returns a PARTID
// If mpamdata.sm is TRUE then PARTID is from MPAMSM_EL1.
// If mpamdata.trb is TRUE then PARTID is from TRBMPAM_EL1.
// If mpamdata.in_d is TRUE and alternative ID is enabled then PARTID is from MPAMn_ELx.altPARTID.
// Otherwise, the PARTID is from MPAMn_ELx.

func GetMPAM_PARTID(MPAMn : bits(2), mpamdata : MPAMdata) =&gt; <a href="shared_pseudocode.html#PARTIDType" title="type PARTIDType">PARTIDType</a>
begin
    if mpamdata.sm then
        return (if IsFeatureImplemented(FEAT_MPAMv2) then MPAMSM_EL1().PARTID
                                                     else MPAMSM_EL1().PARTID_D);
    end;

    if mpamdata.trb then
        return TRBMPAM_EL1().PARTID;
    end;

    if (IsFeatureImplemented(FEAT_MPAMv2_ALT_ID) &amp;&amp; mpamdata.in_d &amp;&amp;
          MPAMIDR_EL1().HAS_INSTR_ALT_ID == '1') then
        case MPAMn of
            when '11' =&gt;
                if MPAMCTL_EL3().EN_ALT_IPARTID == '1' then
                    return MPAM3_EL3().altPARTID;
                else
                    return MPAM3_EL3().PARTID;
                end;
            when '10' =&gt;
                if !EL2Enabled() then
                    return DEFAULT_PARTID;
                elsif MPAMCTL_EL2().EN_ALT_IPARTID == '1' then
                    return MPAM2_EL2().altPARTID;
                else
                    return MPAM2_EL2().PARTID;
                end;
            when '01' =&gt;
                if MPAMCTL_EL1().EN_ALT_IPARTID == '1' then
                    return MPAM1_EL1().altPARTID;
                else
                    return MPAM1_EL1().PARTID;
                end;
            when '00' =&gt;
                if MPAMCTL_EL1().EN_ALT_IPARTID_EL0 == '1' then
                    return MPAM0_EL1().altPARTID;
                else
                    return MPAM0_EL1().PARTID;
                end;
        end;
    end;

    if IsFeatureImplemented(FEAT_MPAMv2) then
        case MPAMn of
            when '11' =&gt; return MPAM3_EL3().PARTID;
            when '10' =&gt; return (if EL2Enabled() then MPAM2_EL2().PARTID else DEFAULT_PARTID);
            when '01' =&gt; return MPAM1_EL1().PARTID;
            when '00' =&gt; return MPAM0_EL1().PARTID;
        end;
    end;

    if mpamdata.in_d then
        case MPAMn of
            when '11' =&gt; return MPAM3_EL3().PARTID_I;
            when '10' =&gt; return (if EL2Enabled() then MPAM2_EL2().PARTID_I else DEFAULT_PARTID);
            when '01' =&gt; return MPAM1_EL1().PARTID_I;
            when '00' =&gt; return MPAM0_EL1().PARTID_I;
        end;
    else
        case MPAMn of
            when '11' =&gt; return MPAM3_EL3().PARTID_D;
            when '10' =&gt; return (if EL2Enabled() then MPAM2_EL2().PARTID_D else DEFAULT_PARTID);
            when '01' =&gt; return MPAM1_EL1().PARTID_D;
            when '00' =&gt; return MPAM0_EL1().PARTID_D;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.GetMPAM_PMG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/GetMPAM_PMG</h3>
      <p class="pseudocode">// GetMPAM_PMG()
// =============
// Returns a PMG.
// if mpamdata.sm is TRUE then PMG is from MPAMSM_EL1.
// If mpamdata.trb is TRUE then PMG is from TRBMPAM_EL1.
// If mpamdata.in_d is TRUE and alternative id is enabled, then the PMG is from MPAMn_ELx.altPMG.
// Otherwise, PMG is from MPAMn_ELx.

func GetMPAM_PMG(MPAMn : bits(2), mpamdata : MPAMdata) =&gt; <a href="shared_pseudocode.html#PMGType" title="type PMGType">PMGType</a>
begin
    if mpamdata.sm then
        return (if IsFeatureImplemented(FEAT_MPAMv2) then MPAMSM_EL1().PMG
                                                     else ZeroExtend{16}(MPAMSM_EL1().PMG_D));
    end;

    if mpamdata.trb then
        return TRBMPAM_EL1().PMG;
    end;

    if (IsFeatureImplemented(FEAT_MPAMv2_ALT_ID) &amp;&amp; mpamdata.in_d &amp;&amp;
          MPAMIDR_EL1().HAS_INSTR_ALT_ID == '1') then
        case MPAMn of
            when '11' =&gt;
                if MPAMCTL_EL3().EN_ALT_IPMG == '1' then
                    return MPAM3_EL3().altPMG;
                else
                    return MPAM3_EL3().PMG;
                end;
            when '10' =&gt;
                if !EL2Enabled() then
                    return DEFAULT_PMG;
                elsif MPAMCTL_EL2().EN_ALT_IPMG == '1' then
                    return MPAM2_EL2().altPMG;
                else
                    return MPAM2_EL2().PMG;
                end;
            when '01' =&gt;
                if MPAMCTL_EL1().EN_ALT_IPMG == '1' then
                    return MPAM1_EL1().altPMG;
                else
                    return MPAM1_EL1().PMG;
                end;
            when '00' =&gt;
                if MPAMCTL_EL1().EN_ALT_IPMG_EL0 == '1' then
                    return MPAM0_EL1().altPMG;
                else
                    return MPAM0_EL1().PMG;
                end;
        end;
    end;

    if IsFeatureImplemented(FEAT_MPAMv2) then
        case MPAMn of
            when '11' =&gt; return MPAM3_EL3().PMG;
            when '10' =&gt; return (if EL2Enabled() then MPAM2_EL2().PMG else DEFAULT_PMG);
            when '01' =&gt; return MPAM1_EL1().PMG;
            when '00' =&gt; return MPAM0_EL1().PMG;
        end;
    end;

    if mpamdata.in_d then
        case MPAMn of
            when '11'=&gt;
                return ZeroExtend{16}(MPAM3_EL3().PMG_I);
            when '10' =&gt;
                return (if EL2Enabled() then ZeroExtend{16}(MPAM2_EL2().PMG_I) else DEFAULT_PMG);
            when '01' =&gt;
                return ZeroExtend{16}(MPAM1_EL1().PMG_I);
            when '00' =&gt;
                return ZeroExtend{16}(MPAM0_EL1().PMG_I);
        end;
    else
        case MPAMn of
            when '11' =&gt;
                return ZeroExtend{16}(MPAM3_EL3().PMG_D);
            when '10' =&gt;
                return (if EL2Enabled() then ZeroExtend{16}(MPAM2_EL2().PMG_D) else DEFAULT_PMG);
            when '01' =&gt;
                return ZeroExtend{16}(MPAM1_EL1().PMG_D);
            when '00' =&gt;
                return ZeroExtend{16}(MPAM0_EL1().PMG_D);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.MAP_vPARTID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/MAP_vPARTID</h3>
      <p class="pseudocode">// MAP_vPARTID()
// =============
// Performs conversion of virtual PARTID into physical PARTID
// Contains all of the error checking and implementation
// choices for the conversion.

func MAP_vPARTID(vpartid : <a href="shared_pseudocode.html#PARTIDType" title="type PARTIDType">PARTIDType</a>) =&gt; (<a href="shared_pseudocode.html#PARTIDType" title="type PARTIDType">PARTIDType</a>, boolean)
begin
    // should not ever be called if EL2 is not implemented
    // or is implemented but not enabled in the current
    // security state.
    var ret : <a href="shared_pseudocode.html#PARTIDType" title="type PARTIDType">PARTIDType</a>;
    var err : boolean;
    var virt : integer    = UInt(vpartid);
    let vpmrmax : integer = UInt(MPAMIDR_EL1().VPMR_MAX);

    // vpartid_max is largest vpartid supported
    let vpartid_max : integer = (vpmrmax &lt;&lt; 2) + 3;

    // One of many ways to reduce vpartid to value less than vpartid_max.
    if UInt(vpartid) &gt; vpartid_max then
        virt = virt MOD (vpartid_max+1);
    end;

    // Check for valid mapping entry.
    if MPAMVPMV_EL2()[virt] == '1' then
        // vpartid has a valid mapping, access the map.
        ret = mapvpmw(virt);
        err = FALSE;

    // Check for default virtual PARTID valid
    elsif MPAMVPMV_EL2()[0] == '1' then
        // Use default mapping for vpartid == 0.
        ret = MPAMVPM0_EL2()[0 +: 16];
        err = FALSE;

    // Neither is valid, use default physical PARTID.
    else
        ret = DEFAULT_PARTID;
        err = TRUE;
    end;

    // Check that the physical PARTID is in-range.
    // This physical PARTID came from a virtual mapping entry.
    let partid_max : integer = UInt(MPAMIDR_EL1().PARTID_MAX);
    if UInt(ret) &gt; partid_max then
        // Out of range, so return default physical PARTID
        ret = DEFAULT_PARTID;
        err = TRUE;
    end;
    return (ret, err);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.MPAM"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/MPAM</h3>
      <p class="pseudocode">// Defines the MPAM _engine_. The _engine_ produces the MPAM labels for memory
// accesses from the state information stored in the MPAM System registers.

// The MPAM _engine_ runs in all states and with the MPAM AArch64 system
// registers and PE execution state controlling its behavior.

// MPAM Types
// ==========

type <a id="PARTIDType"/>PARTIDType of bits(16);

type <a id="PMGType"/>PMGType of bits(16);

type PARTIDSpaceType of enumeration {
    PIDSpace_Secure,
    PIDSpace_Root,
    PIDSpace_Realm,
    PIDSpace_NonSecure
};

type MPAMinfo of record {
     mpam_sp : PARTIDSpaceType,
     partid : <a href="shared_pseudocode.html#PARTIDType" title="type PARTIDType">PARTIDType</a>,
     pmg : <a href="shared_pseudocode.html#PMGType" title="type PMGType">PMGType</a>
};

constant DEFAULT_PARTID : <a href="shared_pseudocode.html#PARTIDType" title="type PARTIDType">PARTIDType</a> = 0[15:0];

constant DEFAULT_PMG : <a href="shared_pseudocode.html#PMGType" title="type PMGType">PMGType</a> = 0[15:0];

type MPAMdata of record {
    in_d : boolean,       // TRUE for instruction accesses
    sm : boolean,         // TRUE for SME, SVE, SIMD&amp;FP access, and SVE prefetch
                          // instructions, when the PE is in Streaming mode
    trb : boolean         // TRUE for TRBE accesses using External mode when TRBMPAM_EL1.EN is 0b1
};</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.MPAMIsEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/MPAMIsEnabled</h3>
      <p class="pseudocode">// MPAMIsEnabled()
// ===============
// Returns TRUE if MPAM is enabled.

func <a id="func_MPAMIsEnabled_0"/>MPAMIsEnabled() =&gt; boolean
begin
    let el : bits(2) = <a href="shared_pseudocode.html#func_HighestEL_0" title="">HighestEL</a>();
    if IsFeatureImplemented(FEAT_MPAMv2) then
        case el of
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; return MPAMCTL_EL3().MPAMEN == '1';
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; return MPAMCTL_EL2().MPAMEN == '1';
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; return MPAMCTL_EL1().MPAMEN == '1';
        end;
    end;

    case el of
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; return MPAM3_EL3().MPAMEN == '1';
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; return MPAM2_EL2().MPAMEN == '1';
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; return MPAM1_EL1().MPAMEN == '1';
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.MPAMIsVirtual"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/MPAMIsVirtual</h3>
      <p class="pseudocode">// MPAMIsVirtual()
// ===============
// If FEAT_MPAMv2 is not implemented, returns TRUE if MPAM is configured to be virtual
// at the given el.

func <a id="func_MPAMIsVirtual_2"/>MPAMIsVirtual(el : bits(2), mpamdata : MPAMdata) =&gt; boolean
begin
    if mpamdata.trb then
        return FALSE;
    end;

    return (MPAMIDR_EL1().HAS_HCR == '1' &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp;
            ((el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; MPAMHCR_EL2().EL0_VPMEN == '1' &amp;&amp; !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>)) ||
             (el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; MPAMHCR_EL2().EL1_VPMEN == '1')));
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.PARTIDIsVirtual"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/PARTIDIsVirtual</h3>
      <p class="pseudocode">// PARTIDIsVirtual()
// =================
// Returns TRUE if MPAMv2 PARTID is configured to be virtual at the given el.

func <a id="func_PARTIDIsVirtual_2"/>PARTIDIsVirtual(el : bits(2), mpamdata : MPAMdata) =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_MPAMv2_VID) then
        return FALSE;
    end;
    if mpamdata.trb then
        return FALSE;
    end;

    if !<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        return FALSE;
    end;
    if mpamdata.sm then
        return MPAMHCR_EL2().SMVPMEN == '1';
    end;
    return MPAMHCR_EL2().VPMEN == '1' &amp;&amp; (el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> || (el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>)));
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.PARTIDSpaceFromSS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/PARTIDSpaceFromSS</h3>
      <p class="pseudocode">// PARTIDSpaceFromSS()
// ===================
// Returns the primary PARTID space from the Security State.

func <a id="func_PARTIDSpaceFromSS_1"/>PARTIDSpaceFromSS(security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>) =&gt; PARTIDSpaceType
begin
    case security of
        when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;
            return PIDSpace_NonSecure;
        when <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> =&gt;
            return PIDSpace_Root;
        when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;
            return PIDSpace_Realm;
        when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;
            return PIDSpace_Secure;
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.PMGIsVirtual"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/PMGIsVirtual</h3>
      <p class="pseudocode">// PMGIsVirtual()
// ==============
// Returns TRUE if MPAMv2 PMG is configured to be virtual at the given el.

func <a id="func_PMGIsVirtual_2"/>PMGIsVirtual(el : bits(2), mpamdata : MPAMdata) =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_MPAMv2_VID) then
        return FALSE;
    end;
    if mpamdata.trb then
        return FALSE;
    end;

    if !<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        return FALSE;
    end;
    if mpamdata.sm then
        return MPAMHCR_EL2().SMVMMEN == '1';
    end;
    return MPAMHCR_EL2().VMMEN == '1' &amp;&amp; (el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> || (el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>)));
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.ReportVIDFault"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/ReportVIDFault</h3>
      <p class="pseudocode">// ReportVIDFault()
// ================
// Report a GPCF or External abort on an MVMS or MITT access.

func ReportVIDFault(mpamdata : MPAMdata, el : bits(2),
                    fault_address : bits(56), fsc : bits(2))
begin
    assert el == '0x';
    MPAMVIDSR_EL2().FADDR = fault_address;
    MPAMVIDSR_EL2().FSC   = fsc;
    MPAMVIDSR_EL2().FIR   = if mpamdata.sm then '10' else el;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.TranslatevPARTID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/TranslatevPARTID</h3>
      <p class="pseudocode">// TranslatevPARTID()
// ==================
// Given a virtual PARTID, return the corresponding physical PARTID from MITT

func TranslatevPARTID(virtual_pid : bits(12), mpamdata : MPAMdata, el : bits(2),
                      pspace : PARTIDSpaceType) =&gt; (<a href="shared_pseudocode.html#PARTIDType" title="type PARTIDType">PARTIDType</a>, boolean)
begin
    let mvms_baddr : bits(56) = MPAMVIDCR_EL2().BADDR :: Zeros{12};
    let mvms_offset : integer         = UInt(virtual_pid[11]) &lt;&lt; 3;
    let mvms_addr : bits(56)  = mvms_baddr + mvms_offset;

    let mvms_entry_size : integer{} = 64;
    var mvms_entry : bits(64);
    var mvms_err : boolean;
    (mvms_entry, mvms_err) = VIDFetch{mvms_entry_size}(mvms_addr, pspace, mpamdata, el);
    if mvms_err || mvms_entry[0] == '0' then
        return (DEFAULT_PARTID, mvms_err);
    end;

    let mitt_baddr : bits(56) = mvms_entry[55:12] :: Zeros{12};
    let mitt_offset : integer         = UInt(virtual_pid[10:0]) &lt;&lt; 1;
    let mitt_addr : bits(56)  = mitt_baddr + mitt_offset;

    let mitt_entry_size : integer{} = 16;
    var physical_pid : bits(16);
    var mitt_err : boolean;
    (physical_pid, mitt_err)      = VIDFetch{mitt_entry_size}(mitt_addr, pspace, mpamdata, el);
    if mitt_err then physical_pid = DEFAULT_PARTID; end;
    return (physical_pid, mitt_err);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.TranslatevPMG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/TranslatevPMG</h3>
      <p class="pseudocode">// TranslatevPMG()
// ===============
// Given a virtual PMG, return the corresponding physical PMG from MITT

func TranslatevPMG(virtual_pmg : bits(12), mpamdata : MPAMdata, el : bits(2),
                   pspace : PARTIDSpaceType) =&gt; <a href="shared_pseudocode.html#PMGType" title="type PMGType">PMGType</a>
begin
    let mvms_baddr : bits(56) = MPAMVIDCR_EL2().BADDR :: Zeros{12};
    let mvms_offset : integer         = (UInt(virtual_pmg[11]) &lt;&lt; 3) + 0x20;
    let mvms_addr : bits(56)  = mvms_baddr + mvms_offset;

    let mvms_entry_size : integer{} = 64;
    var mvms_entry : bits(64);
    var mvms_err : boolean;
    (mvms_entry, mvms_err) = VIDFetch{mvms_entry_size}(mvms_addr, pspace, mpamdata, el);
    if mvms_err || mvms_entry[0] == '0' then
        return DEFAULT_PMG;
    end;

    let mitt_baddr : bits(56) = mvms_entry[55:12] :: Zeros{12};
    let mitt_offset : integer         = UInt(virtual_pmg[10:0]) &lt;&lt; 1;
    let mitt_addr : bits(56)  = mitt_baddr + mitt_offset;

    let mitt_entry_size : integer{} = 16;
    var physical_pmg : bits(16);
    var mitt_err : boolean;
    (physical_pmg, mitt_err)      = VIDFetch{mitt_entry_size}(mitt_addr, pspace, mpamdata, el);
    if mitt_err then physical_pmg = DEFAULT_PMG; end;
    return physical_pmg;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.UsePrimarySpaceEL10"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/UsePrimarySpaceEL10</h3>
      <p class="pseudocode">// UsePrimarySpaceEL10()
// =====================
// Checks whether Primary space is configured in the
// MPAM3_EL3 and MPAM2_EL2 ALTSP control bits that affect
// MPAM ALTSP use at EL1 and EL0.

func <a id="func_UsePrimarySpaceEL10_0"/>UsePrimarySpaceEL10() =&gt; boolean
begin
    if MPAM3_EL3().ALTSP_HEN == '0' then
        return MPAM3_EL3().ALTSP_HFC == '0';
    end;
    return !<a href="shared_pseudocode.html#func_MPAMIsEnabled_0" title="">MPAMIsEnabled</a>() || !<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() || MPAM2_EL2().ALTSP_HFC == '0';
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.UsePrimarySpaceEL2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/UsePrimarySpaceEL2</h3>
      <p class="pseudocode">// UsePrimarySpaceEL2()
// ====================
// Checks whether Primary space is configured in the
// MPAM3_EL3 and MPAM2_EL2 ALTSP control bits that affect
// MPAM ALTSP use at EL2.

func <a id="func_UsePrimarySpaceEL2_0"/>UsePrimarySpaceEL2() =&gt; boolean
begin
    if MPAM3_EL3().ALTSP_HEN == '0' then
        return MPAM3_EL3().ALTSP_HFC == '0';
    end;
    return !<a href="shared_pseudocode.html#func_MPAMIsEnabled_0" title="">MPAMIsEnabled</a>() || MPAM2_EL2().ALTSP_EL2 == '0';
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.VIDFetch"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/VIDFetch</h3>
      <p class="pseudocode">// VIDFetch()
// ==========
// Given a physical address in the MVMS or MITT, perform a read of 'size'

func <a id="func_VIDFetch_5"/>VIDFetch{size : integer{16, 64}}(paddress : bits(56),
                                      pspace : PARTIDSpaceType, mpamdata : MPAMdata,
                                      el : bits(2)) =&gt; (bits(size), boolean)
begin
    assert <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; IsFeatureImplemented(FEAT_MPAMv2_VID);
    let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescMPAMv2VID_1" title="">CreateAccDescMPAMv2VID</a>(pspace);
    var addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    addrdesc.paddress.address = paddress;
    let nse2 : bit            = '0';
    addrdesc.paddress.paspace = <a href="shared_pseudocode.html#func_DecodePASpace_3" title="">DecodePASpace</a>(nse2, <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NSE_0" title="">EffectiveSCR_EL3_NSE</a>(), <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>());
    addrdesc.memattrs         = <a href="shared_pseudocode.html#func_WalkMemAttrs_3" title="">WalkMemAttrs</a>(VTCR_EL2().SH0, VTCR_EL2().IRGN0, VTCR_EL2().ORGN0);
    let emec : bit            = (if IsFeatureImplemented(FEAT_MEC) &amp;&amp;
                                    <a href="shared_pseudocode.html#func_IsSCTLR2EL2Enabled_0" title="">IsSCTLR2EL2Enabled</a>() then SCTLR2_EL2().EMEC else '0');
    addrdesc.mecid            = <a href="shared_pseudocode.html#func_AArch64_S2TTWalkMECID_2" title="">AArch64_S2TTWalkMECID</a>(emec, accdesc.ss);

    if IsFeatureImplemented(FEAT_RME) then
        var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_1" title="">NoFault</a>(accdesc);
        fault.gpcf              = <a href="shared_pseudocode.html#func_GranuleProtectionCheck_2" title="">GranuleProtectionCheck</a>(addrdesc, accdesc);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> then
            let fsc : bits(2) = '01';
            ReportVIDFault(mpamdata, el, paddress, fsc);
            let err : boolean = TRUE;
            return (ARBITRARY : bits(size), err);
        end;
    end;

    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    var data : bits(size);
    (memstatus, data) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{size}(addrdesc, accdesc);

    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
        assert <a href="shared_pseudocode.html#func_IsExternalAbort_1" title="">IsExternalAbort</a>(memstatus.statuscode);
        let fsc : bits(2) = '10';
        ReportVIDFault(mpamdata, el, paddress, fsc);
        let err : boolean = TRUE;
        return (ARBITRARY : bits(size), err);
    end;

    let err : boolean = FALSE;
    return (data, err);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.mapvpmw"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/mapvpmw</h3>
      <p class="pseudocode">// mapvpmw()
// =========
// Map a virtual PARTID into a physical PARTID using
// the MPAMVPMn_EL2 registers.
// vpartid is now assumed in-range and valid (checked by caller)
// returns physical PARTID from mapping entry.

func mapvpmw(vpartid : integer) =&gt; <a href="shared_pseudocode.html#PARTIDType" title="type PARTIDType">PARTIDType</a>
begin
    var vpmw : bits(64);
    let wd : integer = vpartid DIVRM 4;
    case wd of
        when 0    =&gt; vpmw = MPAMVPM0_EL2();
        when 1    =&gt; vpmw = MPAMVPM1_EL2();
        when 2    =&gt; vpmw = MPAMVPM2_EL2();
        when 3    =&gt; vpmw = MPAMVPM3_EL2();
        when 4    =&gt; vpmw = MPAMVPM4_EL2();
        when 5    =&gt; vpmw = MPAMVPM5_EL2();
        when 6    =&gt; vpmw = MPAMVPM6_EL2();
        when 7    =&gt; vpmw = MPAMVPM7_EL2();
        otherwise =&gt; vpmw = Zeros{64};
    end;
    // vpme_lsb selects LSB of field within register
    let vpme_lsb : integer = (vpartid MOD 4) * 16;
    return vpmw[vpme_lsb +: 16];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.ASID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/ASID</h3>
      <p class="pseudocode">// ASID
// ====
// Effective ASID.

func <a id="func_ASID_0"/>ASID() =&gt; bits(16)
begin
    if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) then
        if TCR_EL2().A1 == '1' then
            return TTBR1_EL2().ASID;
        else
            return TTBR0_EL2().ASID;
        end;
    end;
    if !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        if TCR_EL1().A1 == '1' then
            return TTBR1_EL1().ASID;
        else
            return TTBR0_EL1().ASID;
        end;
    else
        if TTBCR().EAE == '0' then
            return ZeroExtend{16}(CONTEXTIDR().ASID);
        else
            if TTBCR().A1 == '1' then
                return ZeroExtend{16}(TTBR1().ASID);
            else
                return ZeroExtend{16}(TTBR0().ASID);
            end;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.ExecutionCntxt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/ExecutionCntxt</h3>
      <p class="pseudocode">// ExecutionCntxt
// ===============
// Context information for prediction restriction operation.

type <a id="type_ExecutionCntxt"/>ExecutionCntxt of record {
    is_vmid_valid : boolean,        // is vmid valid for current context
    all_vmid      : boolean,        // should the operation be applied for all vmids
    vmid          : bits(16), // if all_vmid = FALSE, vmid to which operation is applied
    is_asid_valid : boolean,        // is asid valid for current context
    all_asid      : boolean,        // should the operation be applied for all asids
    asid          : bits(16), // if all_asid = FALSE, ASID to which operation is applied
    target_el     : bits(2),        // target EL at which operation is performed
    security      : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>,
    restriction   : <a href="shared_pseudocode.html#type_RestrictType" title="">RestrictType</a>    // type of restriction operation
};</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.RESTRICT_PREDICTIONS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/RESTRICT_PREDICTIONS</h3>
      <p class="pseudocode">// RESTRICT_PREDICTIONS()
// ======================
// Clear all speculated values.

impdef func RESTRICT_PREDICTIONS(c : <a href="shared_pseudocode.html#type_ExecutionCntxt" title="">ExecutionCntxt</a>)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.RestrictType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/RestrictType</h3>
      <p class="pseudocode">// RestrictType
// ============
// Type of restriction on speculation.

type <a id="type_RestrictType"/>RestrictType of enumeration {
    <a id="enum_RestrictType_DataValue"/>RestrictType_DataValue,
    <a id="enum_RestrictType_ControlFlow"/>RestrictType_ControlFlow,
    <a id="enum_RestrictType_CachePrefetch"/>RestrictType_CachePrefetch,
    <a id="enum_RestrictType_Other"/>RestrictType_Other              // Any other trained speculation mechanisms than those above
};</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.TargetSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/TargetSecurityState</h3>
      <p class="pseudocode">// TargetSecurityState()
// =====================
// Decode the target security state for the prediction context.

func <a id="func_TargetSecurityState_2"/>TargetSecurityState(NS : bit, NSE : bit) =&gt; <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>
begin
    let curr_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> =  <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(PSTATE.EL);
    if curr_ss == <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> then
        return <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;
    elsif curr_ss == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> then
        case NS of
            when '0' =&gt; return <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
            when '1' =&gt; return <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;
        end;
    elsif IsFeatureImplemented(FEAT_RME) then
        if curr_ss == <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> then
            case NSE::NS of
                when '00' =&gt; return <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
                when '01' =&gt; return <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;
                when '11' =&gt; return <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a>;
                when '10' =&gt; return <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a>;
            end;
        elsif curr_ss == <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> then
            return <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a>;
        end;
    end;
    unreachable;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.BranchTo"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/BranchTo</h3>
      <p class="pseudocode">// BranchTo()
// ==========
// Set program counter to a new address, with a branch type.
// Parameter branch_conditional indicates whether the executed branch has a conditional encoding.
// In AArch64 state the address might include a tag in the top eight bits.

func BranchTo{N}(target : bits(N), branch_type : <a href="shared_pseudocode.html#type_BranchType" title="">BranchType</a>, branch_conditional : boolean)
begin
    Hint_Branch(branch_type);
    if N == 32 then
        assert <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
        <a href="shared_pseudocode.html#global__PC" title="">_PC</a> = ZeroExtend{64}(target);
    else
        assert N == 64 &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
        let target_vaddress : bits(64) = <a href="shared_pseudocode.html#func_AArch64_BranchAddr_2" title="">AArch64_BranchAddr</a>(target[63:0], PSTATE.EL);
        if (IsFeatureImplemented(FEAT_BRBE) &amp;&amp;
              branch_type IN {<a href="shared_pseudocode.html#enum_BranchType_DIR" title="">BranchType_DIR</a>, <a href="shared_pseudocode.html#enum_BranchType_INDIR" title="">BranchType_INDIR</a>,
                              <a href="shared_pseudocode.html#enum_BranchType_DIRCALL" title="">BranchType_DIRCALL</a>, <a href="shared_pseudocode.html#enum_BranchType_INDCALL" title="">BranchType_INDCALL</a>,
                              <a href="shared_pseudocode.html#enum_BranchType_RET" title="">BranchType_RET</a>}) then
            BRBEBranch(branch_type, branch_conditional, target_vaddress);
        end;
        let branch_taken : boolean = TRUE;

        if IsFeatureImplemented(FEAT_SPE) then
            SPEBranch{N}(target, branch_type, branch_conditional, branch_taken);
        end;

        <a href="shared_pseudocode.html#global__PC" title="">_PC</a> = target_vaddress;
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.BranchToAddr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/BranchToAddr</h3>
      <p class="pseudocode">// BranchToAddr()
// ==============
// Set program counter to a new address, with a branch type.
// In AArch64 state the address does not include a tag in the top eight bits.

func BranchToAddr{N}(target : bits(N), branch_type : <a href="shared_pseudocode.html#type_BranchType" title="">BranchType</a>)
begin
    Hint_Branch(branch_type);
    if N == 32 then
        assert <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
        <a href="shared_pseudocode.html#global__PC" title="">_PC</a> = ZeroExtend{64}(target);
    else
        assert N == 64 &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
        <a href="shared_pseudocode.html#global__PC" title="">_PC</a> = target[63:0];
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.BranchType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/BranchType</h3>
      <p class="pseudocode">// BranchType
// ==========
// Information associated with a change in control flow.

type <a id="type_BranchType"/>BranchType of enumeration {
    <a id="enum_BranchType_DIRCALL"/>BranchType_DIRCALL,     // Direct Branch with link
    <a id="enum_BranchType_INDCALL"/>BranchType_INDCALL,     // Indirect Branch with link
    <a id="enum_BranchType_ERET"/>BranchType_ERET,        // Exception return (indirect)
    <a id="enum_BranchType_DBGEXIT"/>BranchType_DBGEXIT,     // Exit from Debug state
    <a id="enum_BranchType_RET"/>BranchType_RET,         // Indirect branch with function return hint
    <a id="enum_BranchType_DIR"/>BranchType_DIR,         // Direct branch
    <a id="enum_BranchType_INDIR"/>BranchType_INDIR,       // Indirect branch
    <a id="enum_BranchType_EXCEPTION"/>BranchType_EXCEPTION,   // Exception entry
    <a id="enum_BranchType_RESET"/>BranchType_RESET,       // Reset
    <a id="enum_BranchType_UNKNOWN"/>BranchType_UNKNOWN};    // Other</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.Branchtypetaken"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/Branchtypetaken</h3>
      <p class="pseudocode">// Branchtypetaken
// ===============
var <a id="global_Branchtypetaken"/>Branchtypetaken : <a href="shared_pseudocode.html#type_BranchType" title="">BranchType</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.ESize"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/ESize</h3>
      <p class="pseudocode">// SIMD and Floating-point registers
// +++++++++++++++++++++++++++++++++

// ESize
// =====

type <a id="ESize"/>ESize of integer{8, 16, 32, 64, 128};</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.EffectiveFPCR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/EffectiveFPCR</h3>
      <p class="pseudocode">// EffectiveFPCR()
// ===============
// Returns the effective FPCR value

func <a id="func_EffectiveFPCR_0"/>EffectiveFPCR() =&gt; FPCR_Type
begin
    return FPCR();
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.Hint_Branch"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/Hint_Branch</h3>
      <p class="pseudocode">// Hint_Branch()
// =============
// Report the hint passed to BranchTo() and BranchToAddr(), for consideration when processing
// the next instruction.

impdef func Hint_Branch(hint : <a href="shared_pseudocode.html#type_BranchType" title="">BranchType</a>)
begin
    <a href="shared_pseudocode.html#global_Branchtypetaken" title="">Branchtypetaken</a> = hint;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.NextInstrAddr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/NextInstrAddr</h3>
      <p class="pseudocode">// NextInstrAddr()
// ===============
// Return address of the sequentially next instruction.

impdef func <a id="func_NextInstrAddr_1"/>NextInstrAddr{N}() =&gt; bits(N)
begin
    return Zeros{N};
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.ResetExternalDebugRegisters"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/ResetExternalDebugRegisters</h3>
      <p class="pseudocode">// ResetExternalDebugRegisters()
// =============================
// Reset the External Debug registers in the Core power domain.

impdef func ResetExternalDebugRegisters(cold_reset : boolean)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.ThisInstrAddr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/ThisInstrAddr</h3>
      <p class="pseudocode">// ThisInstrAddr()
// ===============
// Return address of the current instruction.

func <a id="func_ThisInstrAddr_1"/>ThisInstrAddr{N}() =&gt; bits(N)
begin
    assert N == 64 || (N == 32 &amp;&amp; <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>());
    return <a href="shared_pseudocode.html#global__PC" title="">_PC</a>[N-1:0];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.UnimplementedIDRegister"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/UnimplementedIDRegister</h3>
      <p class="pseudocode">// UnimplementedIDRegister()
// =========================
// Trap access to unimplemented encodings in the feature ID register space.

func UnimplementedIDRegister()
begin
    if IsFeatureImplemented(FEAT_IDST) then
        var target_el : bits(2) = PSTATE.EL;
        if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
            target_el = if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; HCR_EL2().TGE == '1' then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
        end;
        AArch64_SystemAccessTrap(target_el, 0x18);
    end;
    Undefined();
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.V"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/V</h3>
      <p class="pseudocode">// V - accessor
// ============

accessor V{width : <a href="shared_pseudocode.html#ESize" title="type ESize">ESize</a>}(n : integer) &lt;=&gt; value : bits(width)
begin
    // Read from SIMD&amp;FP register with implicit slice of 8, 16
    // 32, 64 or 128 bits.
    getter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        return _Z[[n]][width-1:0];
    end;

    // Write to SIMD&amp;FP register with implicit extension from
    // 8, 16, 32, 64 or 128 bits.
    setter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        let vlen : <a href="shared_pseudocode.html#VecLen" title="type VecLen">VecLen</a> = if IsSVEEnabled(PSTATE.EL) then CurrentVL() else 128;
        if ConstrainUnpredictableBool(Unpredictable_SVEZEROUPPER) then
            _Z[[n]] = ZeroExtend{MAX_VL}(value);
        else
            _Z[[n]][vlen-1:0] = ZeroExtend{vlen}(value);
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.Vpart"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/Vpart</h3>
      <p class="pseudocode">// Vpart - accessor
// ================

accessor Vpart{width : <a href="shared_pseudocode.html#ESize" title="type ESize">ESize</a>}(n : integer, part : integer) &lt;=&gt; value : bits(width)
begin
    // Reads a 128-bit SIMD&amp;FP register in up to two parts:
    //  part 0 returns the bottom 8, 16, 32 or 64 bits of a value held in the register;
    //  part 1 returns the top half of the bottom 64 bits or the top half of the 128-bit
    //  value held in the register.
    getter
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        assert part IN {0, 1};
        if part == 0 then
            assert width &lt; 128;
            return V{width}(n);
        else
            assert width IN {32,64};
            let vreg : bits(128) = V{}(n);
            return vreg[(width * 2)-1:width];
        end;
    end;

    setter
    // Writes a 128-bit SIMD&amp;FP register in up to two parts:
    //  part 0 zero extends a 8, 16, 32, or 64-bit value to fill the whole register;
    //  part 1 inserts a 64-bit value into the top half of the register.
        assert n &gt;= 0 &amp;&amp; n &lt;= 31;
        assert part IN {0, 1};
        if part == 0 then
            assert width &lt; 128;
            V{width}(n) = value;
        else
            assert width == 64;
            let vreg : bits(64) = V{}(n);
            V{128}(n) = value[63:0] :: vreg;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers._PC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/_PC</h3>
      <p class="pseudocode">// _PC - the program counter
// =========================

var <a id="global__PC"/>_PC : bits(64);</p>
    </div>
    <div class="ps"><a id="shared.functions.registers._R"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/_R</h3>
      <p class="pseudocode">// _R - the general-purpose register file array
// ============================================

var <a id="global__R"/>_R : array [[31]] of bits(64);</p>
    </div>
    <div class="ps"><a id="shared.functions.sysregisters.SPSR_ELx"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/sysregisters/SPSR_ELx</h3>
      <p class="pseudocode">// SPSR_ELx - accessor
// ===================

accessor <a id="accessor_SPSR_ELx_0"/>SPSR_ELx() &lt;=&gt; value :  bits(64)
begin
    getter
        var result : bits(64);
        case PSTATE.EL of
                when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>  =&gt; result = SPSR_EL1()[63:0];
                when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>  =&gt; result = SPSR_EL2()[63:0];
                when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>  =&gt; result = SPSR_EL3()[63:0];
                otherwise =&gt; unreachable;
        end;
        return result;
    end;
    setter
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>  =&gt; SPSR_EL1()[63:0] = value[63:0];
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>  =&gt; SPSR_EL2()[63:0] = value[63:0];
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>  =&gt; SPSR_EL3()[63:0] = value[63:0];
            otherwise =&gt; unreachable;
        end;
        return;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.sysregisters.SPSR_curr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/sysregisters/SPSR_curr</h3>
      <p class="pseudocode">// SPSR_curr - accessor
// ====================

accessor <a id="accessor_SPSR_curr_0"/>SPSR_curr() &lt;=&gt; value : bits(32)
begin
    getter
        var result : bits(32);
        case PSTATE.M of
            when <a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a>     =&gt;  result = SPSR_fiq()[31:0];
            when <a href="shared_pseudocode.html#global_M32_IRQ" title="">M32_IRQ</a>     =&gt;  result = SPSR_irq()[31:0];
            when <a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>     =&gt;  result = SPSR_svc()[31:0];
            when <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> =&gt;  result = SPSR_mon()[31:0];
            when <a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>   =&gt;  result = SPSR_abt()[31:0];
            when <a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>     =&gt;  result = SPSR_hyp()[31:0];
            when <a href="shared_pseudocode.html#global_M32_Undef" title="">M32_Undef</a>   =&gt;  result = SPSR_und()[31:0];
            otherwise        =&gt;  unreachable;
        end;
        return result;
    end;

    setter
        case PSTATE.M of
            when <a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a>     =&gt; SPSR_fiq()[31:0] = value[31:0];
            when <a href="shared_pseudocode.html#global_M32_IRQ" title="">M32_IRQ</a>     =&gt; SPSR_irq()[31:0] = value[31:0];
            when <a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>     =&gt; SPSR_svc()[31:0] = value[31:0];
            when <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> =&gt; SPSR_mon()[31:0] = value[31:0];
            when <a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>   =&gt; SPSR_abt()[31:0] = value[31:0];
            when <a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a>     =&gt; SPSR_hyp()[31:0] = value[31:0];
            when <a href="shared_pseudocode.html#global_M32_Undef" title="">M32_Undef</a>   =&gt; SPSR_und()[31:0] = value[31:0];
            otherwise        =&gt; unreachable;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.AArch64_ChkFeat"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/AArch64_ChkFeat</h3>
      <p class="pseudocode">// AArch64_ChkFeat()
// =================
// Indicates the status of some features

func <a id="func_AArch64_ChkFeat_1"/>AArch64_ChkFeat(feat_select : bits(64)) =&gt; bits(64)
begin
    var feat_en : bits(64) = Zeros{};
    feat_en[0] = if IsFeatureImplemented(FEAT_GCS) &amp;&amp; <a href="shared_pseudocode.html#func_GCSEnabled_1" title="">GCSEnabled</a>(PSTATE.EL) then '1' else '0';
    return feat_select AND NOT(feat_en);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.AddressAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/AddressAdd</h3>
      <p class="pseudocode">// AddressAdd()
// ============
// Add an address with an offset and return the result.
// If FEAT_CPA2 is implemented, the pointer arithmetic is checked.

func <a id="func_AddressAdd_3"/>AddressAdd(base : bits(64), offset : integer, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; bits(64)
begin
    return <a href="shared_pseudocode.html#func_AddressAdd_3" title="">AddressAdd</a>(base, offset[63:0], accdesc);
end;

func <a id="func_AddressAdd_3"/>AddressAdd(base : bits(64), offset : bits(64), accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; bits(64)
begin
    var result : bits(64) = base + offset;
    result = <a href="shared_pseudocode.html#func_PointerAddCheckAtEL_3" title="">PointerAddCheckAtEL</a>(accdesc.el, result, base);
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.AddressInNaturallyAlignedBlock"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/AddressInNaturallyAlignedBlock</h3>
      <p class="pseudocode">// AddressInNaturallyAlignedBlock()
// ================================
// Returns TRUE if the given addresses are in the same naturally aligned block, and FALSE otherwise.
// An address is in a naturally aligned block if it meets any of the below conditions:
// * is a power-of-two size.
// * Is no larger than the DC ZVA block size if ESR_ELx.FnP is being set to 0b0, or EDHSR is not
//   implemented or EDHSR.FnP is being set to 0b0 (as appropriate).
// * Is no larger than the smallest implemented translation granule if ESR_ELx.FnP, or EDHSR.FnP
//   (as appropriate) is being set to 0b1.
// * Contains a watchpointed address accessed by the memory access or set of contiguous memory
//   accesses that triggered the watchpoint.

impdef func <a id="func_AddressInNaturallyAlignedBlock_2"/>AddressInNaturallyAlignedBlock(address1 : bits(64), address2 : bits(64)) =&gt; boolean
begin
    // Returns TRUE if address in within a naturally aligned block of memory as the watchpointed
    // location, else FALSE.
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.AddressIncrement"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/AddressIncrement</h3>
      <p class="pseudocode">// AddressIncrement()
// ==================
// Increment an address and return the result.
// If FEAT_CPA2 is implemented, the pointer arithmetic may be checked.

func <a id="func_AddressIncrement_3"/>AddressIncrement(base : bits(64), increment : integer, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; bits(64)
begin
    return <a href="shared_pseudocode.html#func_AddressIncrement_3" title="">AddressIncrement</a>(base, increment[63:0], accdesc);
end;

func <a id="func_AddressIncrement_3"/>AddressIncrement(base : bits(64), increment : bits(64), accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; bits(64)
begin
    var result : bits(64) = base + increment;
    // Checking the Pointer Arithmetic on an increment is equivalent to checking the
    // bytes in a sequential access crossing the 0xXXFF_FFFF_FFFF_FFFF boundary.
    if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_CPACHECK" title="">Unpredictable_CPACHECK</a>) then
        result = <a href="shared_pseudocode.html#func_PointerAddCheckAtEL_3" title="">PointerAddCheckAtEL</a>(accdesc.el, result, base);
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.BranchTargetCheck"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/BranchTargetCheck</h3>
      <p class="pseudocode">// BranchTargetCheck()
// ===================
// This function is executed checks if the current instruction is a valid target for a branch
// taken into, or inside, a guarded page. It is executed on every cycle once the current
// instruction has been decoded and the values of InGuardedPage and BTypeCompatible have been
// determined for the current instruction.

func BranchTargetCheck()
begin
    assert IsFeatureImplemented(FEAT_BTI) &amp;&amp; !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();

    // The branch target check considers the following state variables:
    // * InGuardedPage, which is evaluated during instruction fetch.
    // * BTypeCompatible, which is evaluated during instruction decode.
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        return;
    elsif IsZero(PSTATE.BTYPE) then
        return;
    elsif <a href="shared_pseudocode.html#global_InGuardedPage" title="">InGuardedPage</a> &amp;&amp; !<a href="shared_pseudocode.html#global_BTypeCompatible" title="">BTypeCompatible</a> then
        let pc : bits(64) = ThisInstrAddr{}();
        AArch64_BranchTargetException(pc[51:0]);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ClearEventRegister"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ClearEventRegister</h3>
      <p class="pseudocode">// ClearEventRegister()
// ====================
// Clear the Event Register of this PE.

func ClearEventRegister()
begin
    <a href="shared_pseudocode.html#global_EventRegister" title="">EventRegister</a> = '0';
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ConditionHolds"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ConditionHolds</h3>
      <p class="pseudocode">// ConditionHolds()
// ================
// Return TRUE iff COND currently holds

func <a id="func_ConditionHolds_1"/>ConditionHolds(cond : bits(4)) =&gt; boolean
begin
    // Evaluate base condition.
    var result : boolean;
    case cond[3:1] of
        when '000' =&gt; result = (PSTATE.Z == '1');                          // EQ or NE
        when '001' =&gt; result = (PSTATE.C == '1');                          // CS or CC
        when '010' =&gt; result = (PSTATE.N == '1');                          // MI or PL
        when '011' =&gt; result = (PSTATE.V == '1');                          // VS or VC
        when '100' =&gt; result = (PSTATE.C == '1' &amp;&amp; PSTATE.Z == '0');       // HI or LS
        when '101' =&gt; result = (PSTATE.N == PSTATE.V);                     // GE or LT
        when '110' =&gt; result = (PSTATE.N == PSTATE.V &amp;&amp; PSTATE.Z == '0');  // GT or LE
        when '111' =&gt; result = TRUE;                                       // AL
    end;

    // Condition flag values in the set '111x' indicate always true
    // Otherwise, invert condition if necessary.
    if cond[0] == '1' &amp;&amp; cond != '1111' then
        result = !result;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ConsumptionOfSpeculativeDataBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ConsumptionOfSpeculativeDataBarrier</h3>
      <p class="pseudocode">// ConsumptionOfSpeculativeDataBarrier()
// =====================================

impdef func ConsumptionOfSpeculativeDataBarrier()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.CurrentInstrSet"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/CurrentInstrSet</h3>
      <p class="pseudocode">// CurrentInstrSet()
// =================

readonly func CurrentInstrSet() =&gt; <a href="shared_pseudocode.html#InstrSet" title="type InstrSet">InstrSet</a>
begin
    var result : <a href="shared_pseudocode.html#InstrSet" title="type InstrSet">InstrSet</a>;
    if UsingAArch32() then
        result = if PSTATE.T == '0' then InstrSet_A32 else InstrSet_T32;
        // PSTATE.J is RES0. Implementation of T32EE or Jazelle state not permitted.
    else
        result = InstrSet_A64;
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.CurrentSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/CurrentSecurityState</h3>
      <p class="pseudocode">// CurrentSecurityState()
// ======================
// Returns the effective security state at the exception level based off current settings.

readonly func <a id="func_CurrentSecurityState_0"/>CurrentSecurityState() =&gt; <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>
begin
    return <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(PSTATE.EL);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.DSBAlias"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/DSBAlias</h3>
      <p class="pseudocode">// DSBAlias
// ========
// Aliases of DSB.

type <a id="DSBAlias"/>DSBAlias of enumeration {DSBAlias_SSBB, DSBAlias_PSSBB, DSBAlias_DSB};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EL0</h3>
      <p class="pseudocode">// EL0-3
// =====
// PSTATE.EL Exception level bits.

constant <a id="global_EL3"/>EL3 : bits(2) = '11';

constant <a id="global_EL2"/>EL2 : bits(2) = '10';

constant <a id="global_EL1"/>EL1 : bits(2) = '01';

constant <a id="global_EL0"/>EL0 : bits(2) = '00';</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EL2Enabled</h3>
      <p class="pseudocode">// EL2Enabled()
// ============
// Returns TRUE if EL2 is present and executing
// - with the PE in Non-secure state when Non-secure EL2 is implemented, or
// - with the PE in Realm state when Realm EL2 is implemented, or
// - with the PE in Secure state when Secure EL2 is implemented and enabled, or
// - when EL3 is not implemented.

readonly func <a id="func_EL2Enabled_0"/>EL2Enabled() =&gt; boolean
begin
    var scr_ns : bit;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            scr_ns = SCR().NS;
        else
            scr_ns = SCR_EL3().NS;
        end;
    end;

    return <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; (!<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || scr_ns == '1' || <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>());
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EL3SDDUndef"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EL3SDDUndef</h3>
      <p class="pseudocode">// EL3SDDUndef()
// =============
// Returns TRUE if in Debug state and EDSCR.SDD is set.

func <a id="func_EL3SDDUndef_0"/>EL3SDDUndef() =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() &amp;&amp; EDSCR().SDD == '1' then
        assert (PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>  &amp;&amp;
                  (IsFeatureImplemented(FEAT_RME) || <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>));
        return TRUE;
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EL3SDDUndefPriority"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EL3SDDUndefPriority</h3>
      <p class="pseudocode">// EL3SDDUndefPriority()
// =====================
// Returns TRUE if in Debug state, EDSCR.SDD is set, and an EL3 trap by an
// EL3 control register has priority over other traps.
// The IMPLEMENTATION DEFINED priority may be different for each case.

func <a id="func_EL3SDDUndefPriority_0"/>EL3SDDUndefPriority() =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() &amp;&amp; ImpDefBool("EL3 trap priority when SDD == '1'");
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELFromM32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELFromM32</h3>
      <p class="pseudocode">// ELFromM32()
// ===========

func <a id="func_ELFromM32_1"/>ELFromM32(mode : bits(5)) =&gt; (boolean,bits(2))
begin
    // Convert an AArch32 mode encoding to an Exception level.
    // Returns (valid,EL):
    //   'valid' is TRUE if 'mode[4:0]' encodes a mode that is both valid for this implementation
    //           and the current value of SCR.NS/SCR_EL3.NS.
    //   'EL'    is the Exception level decoded from 'mode'.
    var el : bits(2);
    // Check for modes that are not valid for this implementation
    var valid : boolean = !<a href="shared_pseudocode.html#func_BadMode_1" title="">BadMode</a>(mode);
    let effective_nse_ns : bits(2) = <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NSE_0" title="">EffectiveSCR_EL3_NSE</a>() :: <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>();

    case mode of
        when <a href="shared_pseudocode.html#global_M32_Monitor" title="">M32_Monitor</a> =&gt;
            el = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
        when <a href="shared_pseudocode.html#global_M32_Hyp" title="">M32_Hyp</a> =&gt;
            el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
        when <a href="shared_pseudocode.html#global_M32_FIQ" title="">M32_FIQ</a>, <a href="shared_pseudocode.html#global_M32_IRQ" title="">M32_IRQ</a>, <a href="shared_pseudocode.html#global_M32_Svc" title="">M32_Svc</a>, <a href="shared_pseudocode.html#global_M32_Abort" title="">M32_Abort</a>, <a href="shared_pseudocode.html#global_M32_Undef" title="">M32_Undef</a>, <a href="shared_pseudocode.html#global_M32_System" title="">M32_System</a> =&gt;
            // If EL3 is implemented and using AArch32, then these modes are EL3 modes in Secure
            // state, and EL1 modes in Non-secure state. If EL3 is not implemented or is using
            // AArch64, then these modes are EL1 modes.
            el = (if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() &amp;&amp; SCR().NS == '0' then <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
        when <a href="shared_pseudocode.html#global_M32_User" title="">M32_User</a> =&gt;
            el = <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>;
        otherwise =&gt;
            valid = FALSE;           // Passed an illegal mode value
    end;

    if valid &amp;&amp; el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR().NS == '0' then
            valid = FALSE; // EL2 only valid in Non-secure state in AArch32
        elsif !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().NS == '0' then
            valid = FALSE; // EL2 only valid in Non-secure state in AArch32
        end;
    elsif valid &amp;&amp; IsFeatureImplemented(FEAT_RME) &amp;&amp; effective_nse_ns == '10' then
        valid = FALSE;               // Illegal Exception Return from EL3 if SCR_EL3.[NSE,NS]
                                     // selects a reserved encoding
    end;

    if !valid then el = ARBITRARY : bits(2); end;
    return (valid, el);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELFromSPSR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELFromSPSR</h3>
      <p class="pseudocode">// ELFromSPSR()
// ============

// Convert an SPSR value encoding to an Exception level.
// Returns (valid,EL):
//   'valid' is TRUE if 'spsr[4:0]' encodes a valid mode for the current state.
//   'EL'    is the Exception level decoded from 'spsr'.

func <a id="func_ELFromSPSR_2"/>ELFromSPSR{N}(spsr : bits(N)) =&gt; (boolean,bits(2))
begin
    var el : bits(2);
    var valid : boolean;
    if spsr[4] == '0' then      // AArch64 state
        el = spsr[3:2];
        if (IsFeatureImplemented(FEAT_NV3) &amp;&amp; spsr[3:2] == '10' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp;
              <a href="shared_pseudocode.html#func_EffectiveHCRX_EL2_NVTGE_0" title="">EffectiveHCRX_EL2_NVTGE</a>() == '1') then
            el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
        end;

        let effective_nse_ns : bits(2) = <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NSE_0" title="">EffectiveSCR_EL3_NSE</a>() :: <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>();
        if !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
            valid = FALSE;      // No AArch64 support
        elsif !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(el) then
            valid = FALSE;      // Exception level not implemented
        elsif spsr[1] == '1' then
            valid = FALSE;      // M[1] must be 0
        elsif el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; spsr[0] == '1' then
            valid = FALSE;      // for EL0, M[0] must be 0
        elsif IsFeatureImplemented(FEAT_RME) &amp;&amp; el != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; effective_nse_ns == '10' then
            valid = FALSE;      // Only EL3 valid in Root state
        elsif el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>() == '0' then
            valid = FALSE;      // Unless Secure EL2 is enabled, EL2 valid only in Non-secure state
        else
            valid = TRUE;
        end;
    elsif <a href="shared_pseudocode.html#func_HaveAArch32_0" title="">HaveAArch32</a>() then    // AArch32 state
        (valid, el) = <a href="shared_pseudocode.html#func_ELFromM32_1" title="">ELFromM32</a>(spsr[4:0]);
    else
        valid = FALSE;
    end;

    if !valid then el = ARBITRARY : bits(2); end;
    return (valid,el);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELIsInHost"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELIsInHost</h3>
      <p class="pseudocode">// ELIsInHost()
// ============

readonly func <a id="func_ELIsInHost_1"/>ELIsInHost(el : bits(2)) =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_VHE) || <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        return FALSE;
    end;
    case el of
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            return FALSE;
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            return <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveHCR_EL2_E2H_0" title="">EffectiveHCR_EL2_E2H</a>() == '1';
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;
            return FALSE;
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            return <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveHCR_EL2_E2H_0" title="">EffectiveHCR_EL2_E2H</a>()::HCR_EL2().TGE == '11';
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELStateUsingAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELStateUsingAArch32</h3>
      <p class="pseudocode">// ELStateUsingAArch32()
// =====================

readonly func <a id="func_ELStateUsingAArch32_2"/>ELStateUsingAArch32(el : bits(2), secure : boolean) =&gt; boolean
begin
    // See ELStateUsingAArch32K() for description. Must only be called in circumstances where
    // result is valid (typically, that means 'el IN {EL1,EL2,EL3}').
    let (known, aarch32) : (boolean, boolean) = <a href="shared_pseudocode.html#func_ELStateUsingAArch32K_2" title="">ELStateUsingAArch32K</a>(el, secure);
    assert known;
    return aarch32;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELStateUsingAArch32K"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELStateUsingAArch32K</h3>
      <p class="pseudocode">// ELStateUsingAArch32K()
// ======================
// Returns (known, aarch32):
//   'known'   is FALSE for EL0 if the current Exception level is not EL0 and EL1 is
//             using AArch64, since it cannot determine the state of EL0; TRUE otherwise.
//   'aarch32' is TRUE if the specified Exception level is using AArch32; FALSE otherwise.

readonly func <a id="func_ELStateUsingAArch32K_2"/>ELStateUsingAArch32K(el : bits(2), secure : boolean) =&gt; (boolean, boolean)
begin
    assert <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(el);

    if !<a href="shared_pseudocode.html#func_HaveAArch32EL_1" title="">HaveAArch32EL</a>(el) then
        return (TRUE, FALSE);   // Exception level is using AArch64
    elsif secure &amp;&amp; el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        return (TRUE, FALSE);   // Secure EL2 is using AArch64
    elsif !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
        return (TRUE, TRUE);    // Highest Exception level, therefore all levels are using AArch32
    end;

    // Remainder of function deals with the interprocessing cases when highest
    // Exception level is using AArch64_

    if el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
        return (TRUE, FALSE);
    end;

    if (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().RW == '0' &amp;&amp;
          (!secure || !IsFeatureImplemented(FEAT_SEL2) || SCR_EL3().EEL2 == '0')) then
        // AArch32 below EL3.
        return (TRUE, TRUE);
    end;

    if el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        return (TRUE, FALSE);
    end;

    if (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) &amp;&amp; HCR_EL2().RW == '0' &amp;&amp;
          (!secure || (IsFeatureImplemented(FEAT_SEL2) &amp;&amp; SCR_EL3().EEL2 == '1'))) then
        // AArch32 below EL2.
        return (TRUE, TRUE);
    end;

    if el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> then
        return (TRUE, FALSE);
    end;

    // The execution state of EL0 is only known from PSTATE.nRW when executing at EL0.
    if PSTATE.EL == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        return (TRUE, PSTATE.nRW == '1');
    else
        return (FALSE, ARBITRARY : boolean);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELUsingAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELUsingAArch32</h3>
      <p class="pseudocode">// ELUsingAArch32()
// ================

readonly func <a id="func_ELUsingAArch32_1"/>ELUsingAArch32(el : bits(2)) =&gt; boolean
                                     recurselimit 1
begin
    return <a href="shared_pseudocode.html#func_ELStateUsingAArch32_2" title="">ELStateUsingAArch32</a>(el, <a href="shared_pseudocode.html#func_IsSecureBelowEL3_0" title="">IsSecureBelowEL3</a>());
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELUsingAArch32K"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELUsingAArch32K</h3>
      <p class="pseudocode">// ELUsingAArch32K()
// =================

readonly func <a id="func_ELUsingAArch32K_1"/>ELUsingAArch32K(el : bits(2)) =&gt; (boolean,boolean)
begin
    return <a href="shared_pseudocode.html#func_ELStateUsingAArch32K_2" title="">ELStateUsingAArch32K</a>(el, <a href="shared_pseudocode.html#func_IsSecureBelowEL3_0" title="">IsSecureBelowEL3</a>());
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EffectiveEA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EffectiveEA</h3>
      <p class="pseudocode">// EffectiveEA()
// =============
// Returns effective SCR_EL3.EA value

func <a id="func_EffectiveEA_0"/>EffectiveEA() =&gt; bit
begin
    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) || <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then
        return '0';
    else
        return if <a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then SCR_EL3().EA else SCR().EA;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EffectiveHCR_EL2_E2H"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EffectiveHCR_EL2_E2H</h3>
      <p class="pseudocode">// EffectiveHCR_EL2_E2H()
// ======================
// Return the Effective HCR_EL2.E2H value.

readonly func <a id="func_EffectiveHCR_EL2_E2H_0"/>EffectiveHCR_EL2_E2H() =&gt; bit
begin
    if !IsFeatureImplemented(FEAT_VHE) then
        return '0';
    end;

    if !IsFeatureImplemented(FEAT_E2H0) then
        return '1';
    end;

    return HCR_EL2().E2H;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EffectiveHCR_EL2_NVx"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EffectiveHCR_EL2_NVx</h3>
      <p class="pseudocode">// EffectiveHCR_EL2_NVx()
// ======================
// Return the Effective value of HCR_EL2().[NV2,NV1,NV].

func <a id="func_EffectiveHCR_EL2_NVx_0"/>EffectiveHCR_EL2_NVx() =&gt; bits(3)
begin
    if !<a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() || !IsFeatureImplemented(FEAT_NV) then
        return '000';
    end;

    var nv1 : bit = HCR_EL2().NV1;
    if (!IsFeatureImplemented(FEAT_E2H0) &amp;&amp;
          ImpDefBool("HCR_EL2.NV1 is implemented as RAZ")) then
        nv1 = '0';
    end;

    if HCR_EL2().NV == '0' then
        if nv1 == '1' then
            case ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_NVNV1" title="">Unpredictable_NVNV1</a>) of
                when <a href="shared_pseudocode.html#enum_Constraint_NVNV1_00" title="">Constraint_NVNV1_00</a> =&gt; return '000';
                when <a href="shared_pseudocode.html#enum_Constraint_NVNV1_01" title="">Constraint_NVNV1_01</a> =&gt; return '010';
                when <a href="shared_pseudocode.html#enum_Constraint_NVNV1_11" title="">Constraint_NVNV1_11</a> =&gt; return '011';
            end;
        else
            return '000';
        end;
    end;

    if !IsFeatureImplemented(FEAT_NV2) then
        return '0' :: nv1 :: '1';
    end;

    var nv2 : bit = HCR_EL2().NV2;
    if (nv2 == '0' &amp;&amp; ImpDefBool(
          "Programming HCR_EL2.&lt;NV,NV2&gt; to '10' behaves as '11'")) then
        nv2 = '1';
    end;

    return nv2 :: nv1 :: '1';
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EffectiveSCR_EL3_NS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EffectiveSCR_EL3_NS</h3>
      <p class="pseudocode">// EffectiveSCR_EL3_NS()
// =====================
// Return Effective SCR_EL3.NS value.

readonly func <a id="func_EffectiveSCR_EL3_NS_0"/>EffectiveSCR_EL3_NS() =&gt; bit
begin
    if !<a href="shared_pseudocode.html#func_HaveSecureState_0" title="">HaveSecureState</a>() then
        return '1';
    elsif !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        return '0';
    elsif <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        return SCR().NS;
    else
        return SCR_EL3().NS;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EffectiveSCR_EL3_NSE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EffectiveSCR_EL3_NSE</h3>
      <p class="pseudocode">// EffectiveSCR_EL3_NSE()
// ======================
// Return Effective SCR_EL3.NSE value.

readonly func <a id="func_EffectiveSCR_EL3_NSE_0"/>EffectiveSCR_EL3_NSE() =&gt; bit
begin
    return if !IsFeatureImplemented(FEAT_RME) then '0' else SCR_EL3().NSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EffectiveSCR_EL3_RW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EffectiveSCR_EL3_RW</h3>
      <p class="pseudocode">// EffectiveSCR_EL3_RW()
// =====================
// Returns effective SCR_EL3.RW value

func <a id="func_EffectiveSCR_EL3_RW_0"/>EffectiveSCR_EL3_RW() =&gt; bit
begin
    if !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
        return '0';
    end;
    if !<a href="shared_pseudocode.html#func_HaveAArch32EL_1" title="">HaveAArch32EL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#func_HaveAArch32EL_1" title="">HaveAArch32EL</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        return '1';
    end;
    if <a href="shared_pseudocode.html#func_HaveAArch32EL_1" title="">HaveAArch32EL</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then
        if !<a href="shared_pseudocode.html#func_HaveAArch32EL_1" title="">HaveAArch32EL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>() == '1' then
            return '1';
        end;
        if (IsFeatureImplemented(FEAT_SEL2) &amp;&amp; SCR_EL3().EEL2 == '1' &amp;&amp;
              <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>() == '0') then
            return '1';
        end;
    end;
    return SCR_EL3().RW;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EffectiveTGE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EffectiveTGE</h3>
      <p class="pseudocode">// EffectiveTGE()
// ==============
// Returns effective TGE value

func <a id="func_EffectiveTGE_0"/>EffectiveTGE() =&gt; bit
begin
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        return if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then HCR().TGE else HCR_EL2().TGE;
    else
        return '0';        // Effective value of TGE is zero
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EndOfInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EndOfInstruction</h3>
      <p class="pseudocode">noreturn impdef func EndOfInstruction()
begin
    throw <a href="shared_pseudocode.html#EndOfInstructionException" title="type EndOfInstructionException">EndOfInstructionException</a>{-};
end;

// EndOfInstruction()
// ==================
// Terminate processing of the current instruction.

type <a id="EndOfInstructionException"/>EndOfInstructionException of exception{-};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EnterLowPowerState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EnterLowPowerState</h3>
      <p class="pseudocode">// EnterLowPowerState()
// ====================
// PE enters a low-power state.

impdef func EnterLowPowerState()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EventRegister"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EventRegister</h3>
      <p class="pseudocode">// EventRegister
// =============
// Event Register for this PE.

var <a id="global_EventRegister"/>EventRegister : bits(1);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ExceptionalOccurrenceTargetState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ExceptionalOccurrenceTargetState</h3>
      <p class="pseudocode">// ExceptionalOccurrenceTargetState
// ================================
// Enumeration to represent the target state of an Exceptional Occurrence.
// The Exceptional Occurrence can be either Exception or Debug State entry.

type <a id="type_ExceptionalOccurrenceTargetState"/>ExceptionalOccurrenceTargetState of enumeration {
    <a id="enum_AArch32_NonDebugState"/>AArch32_NonDebugState,
    <a id="enum_AArch64_NonDebugState"/>AArch64_NonDebugState,
    <a id="enum_DebugState"/>DebugState
};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ExecuteAsNOP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ExecuteAsNOP</h3>
      <p class="pseudocode">// ExecuteAsNOP()
// ==============

func ExecuteAsNOP()
begin
    EndOfInstruction();
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.FIQPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/FIQPending</h3>
      <p class="pseudocode">// FIQPending()
// ============
// Returns a tuple indicating if there is any pending physical FIQ
// and if the pending FIQ has superpriority.

impdef func <a id="func_FIQPending_0"/>FIQPending() =&gt; (boolean, boolean)
begin
    return (FALSE, FALSE);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.GetAccumulatedFPExceptions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/GetAccumulatedFPExceptions</h3>
      <p class="pseudocode">// GetAccumulatedFPExceptions()
// ============================
// Returns FP exceptions accumulated by the PE.

impdef func <a id="func_GetAccumulatedFPExceptions_0"/>GetAccumulatedFPExceptions() =&gt; bits(8)
begin
    return ARBITRARY : bits(8);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.GetLoadStoreType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/GetLoadStoreType</h3>
      <p class="pseudocode">// GetLoadStoreType()
// ==================
// Returns the Load/Store Type. Used when a Translation fault,
// Access flag fault, or Permission fault generates a Data Abort.

impdef func <a id="func_GetLoadStoreType_0"/>GetLoadStoreType() =&gt; bits(2)
begin
    return ARBITRARY : bits(2);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.GetPSRFromPSTATE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/GetPSRFromPSTATE</h3>
      <p class="pseudocode">// GetPSRFromPSTATE()
// ==================
// Return a PSR value which represents the current PSTATE

func <a id="func_GetPSRFromPSTATE_2"/>GetPSRFromPSTATE{N}(targetELState : <a href="shared_pseudocode.html#type_ExceptionalOccurrenceTargetState" title="">ExceptionalOccurrenceTargetState</a>) =&gt; bits(N)
begin
    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; targetELState == <a href="shared_pseudocode.html#enum_AArch32_NonDebugState" title="">AArch32_NonDebugState</a> then
        assert N == 32;
    else
        assert N == 64;
    end;

    var spsr : bits(N) = Zeros{};
    if IsFeatureImplemented(FEAT_UINJ) &amp;&amp; targetELState == <a href="shared_pseudocode.html#enum_DebugState" title="">DebugState</a> then
        spsr[36] = PSTATE.UINJ;
    end;
    spsr[31:28] = PSTATE.[N,Z,C,V];
    if IsFeatureImplemented(FEAT_PAN) then spsr[22] = PSTATE.PAN; end;
    spsr[20]     = PSTATE.IL;
    if PSTATE.nRW == '1' then                           // AArch32 state
        if IsFeatureImplemented(FEAT_SEBEP) &amp;&amp; targetELState != <a href="shared_pseudocode.html#enum_AArch32_NonDebugState" title="">AArch32_NonDebugState</a> then
            spsr[33] = PSTATE.PPEND;
        end;
        spsr[27]     = PSTATE.Q;
        spsr[26:25]  = PSTATE.IT[1:0];
        if IsFeatureImplemented(FEAT_SSBS) then spsr[23] = PSTATE.SSBS; end;
        if IsFeatureImplemented(FEAT_DIT) then
            if targetELState == <a href="shared_pseudocode.html#enum_AArch32_NonDebugState" title="">AArch32_NonDebugState</a> then
                spsr[21] = PSTATE.DIT;
            else                                        // AArch64_NonDebugState or DebugState
                spsr[24] = PSTATE.DIT;
            end;
        end;
        if targetELState IN {<a href="shared_pseudocode.html#enum_AArch64_NonDebugState" title="">AArch64_NonDebugState</a>, <a href="shared_pseudocode.html#enum_DebugState" title="">DebugState</a>} then
            spsr[21] = PSTATE.SS;
        end;
        spsr[19:16]  = PSTATE.GE;
        spsr[15:10]  = PSTATE.IT[7:2];
        spsr[9]      = PSTATE.E;
        spsr[8:6]    = PSTATE.[A,I,F];                  // No PSTATE.D in AArch32 state
        spsr[5]      = PSTATE.T;
        assert PSTATE.M[4] == PSTATE.nRW;               // bit [4] is the discriminator
        spsr[4:0]    = PSTATE.M;
    else                                                // AArch64 state
        if IsFeatureImplemented(FEAT_PAuth_LR) then spsr[35] = PSTATE.PACM; end;
        if IsFeatureImplemented(FEAT_GCS) then spsr[34] = PSTATE.EXLOCK; end;
        if IsFeatureImplemented(FEAT_SEBEP) then spsr[33] = PSTATE.PPEND; end;
        if (IsFeatureImplemented(FEAT_EBEP) || IsFeatureImplemented(FEAT_SPE_EXC) ||
              IsFeatureImplemented(FEAT_TRBE_EXC)) then
            spsr[32] = PSTATE.PM;
        end;
        if IsFeatureImplemented(FEAT_MTE) then spsr[25] = PSTATE.TCO; end;
        if IsFeatureImplemented(FEAT_DIT) then spsr[24] = PSTATE.DIT; end;
        if IsFeatureImplemented(FEAT_UAO) then spsr[23] = PSTATE.UAO; end;
        spsr[21]    = PSTATE.SS;
        if IsFeatureImplemented(FEAT_NMI) then spsr[13] = PSTATE.ALLINT; end;
        if IsFeatureImplemented(FEAT_SSBS) then spsr[12] = PSTATE.SSBS; end;
        if IsFeatureImplemented(FEAT_BTI) then spsr[11:10] = PSTATE.BTYPE; end;
        spsr[9:6]    = PSTATE.[D,A,I,F];
        spsr[4]      = PSTATE.nRW;
        spsr[3:2]    = PSTATE.EL;
        spsr[0]      = PSTATE.SP;
    end;
    return spsr;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveAArch32</h3>
      <p class="pseudocode">// HaveAArch32()
// =============
// Return TRUE if AArch32 state is supported at at least EL0.

readonly func <a id="func_HaveAArch32_0"/>HaveAArch32() =&gt; boolean
begin
    return IsFeatureImplemented(FEAT_AA32EL0);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveAArch32EL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveAArch32EL</h3>
      <p class="pseudocode">// HaveAArch32EL()
// ===============
// Return TRUE if Exception level 'el' supports AArch32 in this implementation

readonly func <a id="func_HaveAArch32EL_1"/>HaveAArch32EL(el : bits(2)) =&gt; boolean
begin
    case el of
        when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt; return IsFeatureImplemented(FEAT_AA32EL0);
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; return IsFeatureImplemented(FEAT_AA32EL1);
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; return IsFeatureImplemented(FEAT_AA32EL2);
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; return IsFeatureImplemented(FEAT_AA32EL3);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveAArch64"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveAArch64</h3>
      <p class="pseudocode">// HaveAArch64()
// =============
// Return TRUE if the highest Exception level is using AArch64 state.

readonly func <a id="func_HaveAArch64_0"/>HaveAArch64() =&gt; boolean
begin
    return (IsFeatureImplemented(FEAT_AA64EL0)
            || IsFeatureImplemented(FEAT_AA64EL1)
            || IsFeatureImplemented(FEAT_AA64EL2)
            || IsFeatureImplemented(FEAT_AA64EL3)
            );
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveEL</h3>
      <p class="pseudocode">// HaveEL()
// ========
// Return TRUE if Exception level 'el' is supported

readonly func <a id="func_HaveEL_1"/>HaveEL(el : bits(2)) =&gt; boolean
begin
    case el of
        when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>,<a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
            return TRUE;                         // EL1 and EL0 must exist
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            return IsFeatureImplemented(FEAT_AA64EL2) || IsFeatureImplemented(FEAT_AA32EL2);
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            return IsFeatureImplemented(FEAT_AA64EL3) || IsFeatureImplemented(FEAT_AA32EL3);
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveELUsingSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveELUsingSecurityState</h3>
      <p class="pseudocode">// HaveELUsingSecurityState()
// ==========================
// Returns TRUE if Exception level 'el' with Security state 'secure' is supported,
// FALSE otherwise.

readonly func <a id="func_HaveELUsingSecurityState_2"/>HaveELUsingSecurityState(el : bits(2), secure : boolean) =&gt; boolean
begin

    case el of
        when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;
            assert secure;
            return <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;
            if secure then
                return <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; IsFeatureImplemented(FEAT_SEL2);
            else
                return <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
            end;
        otherwise =&gt;
            return (<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) ||
                    (secure == ImpDefBool("Secure-only implementation")));
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveSecureState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveSecureState</h3>
      <p class="pseudocode">// HaveSecureState()
// =================
// Return TRUE if Secure State is supported.

readonly func <a id="func_HaveSecureState_0"/>HaveSecureState() =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        return <a href="shared_pseudocode.html#func_SecureOnlyImplementation_0" title="">SecureOnlyImplementation</a>();
    end;
    if IsFeatureImplemented(FEAT_RME) &amp;&amp; !IsFeatureImplemented(FEAT_SEL2) then
        return FALSE;
    end;
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HighestEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HighestEL</h3>
      <p class="pseudocode">// HighestEL()
// ===========
// Returns the highest implemented Exception level.

readonly func <a id="func_HighestEL_0"/>HighestEL() =&gt; bits(2)
begin
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        return <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        return <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    else
        return <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_CLRBHB"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_CLRBHB</h3>
      <p class="pseudocode">// Hint_CLRBHB()
// =============
// Provides a hint to clear the branch history for the current context.

impdef func Hint_CLRBHB()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_DGH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_DGH</h3>
      <p class="pseudocode">// Hint_DGH()
// ==========
// Provides a hint to close any gathering occurring within the implementation.

impdef func Hint_DGH()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_SharedUpdate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_SharedUpdate</h3>
      <p class="pseudocode">// Hint_SharedUpdate()
// ===================
// Provides a hint to the memory system that if the next instruction in program order generates an
// Explicit Memory Effect, then it is to a location that one or more other threads of execution
// are likely to subsequently update, and there is a performance benefit to ensuring subsequent
// updates by other threads of execution may complete with minimal latency.

impdef func Hint_SharedUpdate(priority : boolean)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_StoreConcurrentPriority"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_StoreConcurrentPriority</h3>
      <p class="pseudocode">// Hint_StoreConcurrentPriority()
// ==============================
// Provides a hint to the memory system that if the next instruction in program order generates an
// Explicit Memory Write Effect, then there is a performance benefit if the corresponding Explicit
// Memory Write Effect is sequenced before Explicit Memory Effects from other threads of execution
// in the coherence order to the same location.

impdef func Hint_StoreConcurrentPriority()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_StoreShared"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_StoreShared</h3>
      <p class="pseudocode">// Hint_StoreShared()
// ==================
// Provides a hint that if the next instruction is an explict write it is being waited on by
// observers and as such the data should propagate to them with minimum latency.
// A stream value of FALSE indicates KEEP whilst a value of TRUE indicates STRM.

impdef func Hint_StoreShared(stream : boolean)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_WFE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_WFE</h3>
      <p class="pseudocode">// Hint_WFE()
// ==========
// Provides a hint indicating that the PE can enter a low-power state and
// remain there until a wakeup event occurs.

func Hint_WFE()
begin
    if <a href="shared_pseudocode.html#func_IsEventRegisterSet_0" title="">IsEventRegisterSet</a>() then
        ClearEventRegister();
        return;
    end;

    var trap : boolean;
    var target_el : bits(2);
    (trap, target_el) = AArch64_CheckForWFxTrap(WFxType_WFE);
    if trap then
        if IsFeatureImplemented(FEAT_TWED) then
            // Determine if trap delay is enabled and delay amount
            var delay_enabled : boolean;
            var delay : integer;
            (delay_enabled, delay) = <a href="shared_pseudocode.html#func_WFETrapDelay_1" title="">WFETrapDelay</a>(target_el);
            if <a href="shared_pseudocode.html#func_WaitForEventUntilDelay_2" title="">WaitForEventUntilDelay</a>(delay_enabled, delay) then
                // Event arrived before delay
                return;
            end;
        end;

        // Proceed with trapping
        if target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then
            Undefined();
        else
            AArch64_WFxTrap(WFxType_WFE, target_el);
        end;
    else
        WaitForEvent();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_WFET"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_WFET</h3>
      <p class="pseudocode">// Hint_WFET()
// ===========
// Provides a hint indicating that the PE can enter a low-power state
// and remain there until a wakeup event occurs or, for WFET,  a local
// timeout event is generated when the virtual timer value equals or
// exceeds the supplied threshold value.

func Hint_WFET(localtimeout : integer)
begin
    if <a href="shared_pseudocode.html#func_IsEventRegisterSet_0" title="">IsEventRegisterSet</a>() then
        ClearEventRegister();
        return;
    end;

    if IsFeatureImplemented(FEAT_WFxT) &amp;&amp; <a href="shared_pseudocode.html#func_LocalTimeoutEvent_1" title="">LocalTimeoutEvent</a>(localtimeout) then
        // No further operation if the local timeout has expired.
        EndOfInstruction();
    end;

    var trap : boolean;
    var target_el : bits(2);
    (trap, target_el) = AArch64_CheckForWFxTrap(WFxType_WFET);
    if trap then
        if IsFeatureImplemented(FEAT_TWED) then
            // Determine if trap delay is enabled and delay amount
            var delay_enabled : boolean;
            var delay : integer;
            (delay_enabled, delay) = <a href="shared_pseudocode.html#func_WFETrapDelay_1" title="">WFETrapDelay</a>(target_el);
            if <a href="shared_pseudocode.html#func_WaitForEventUntilDelay_2" title="">WaitForEventUntilDelay</a>(delay_enabled, delay) then
                // Event arrived before the delay expired
                return;
            end;
        end;

        // Proceed with trapping
        if target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then
            Undefined();
        else
            AArch64_WFxTrap(WFxType_WFET, target_el);
        end;
    else
        WaitForEvent(localtimeout);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_WFI"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_WFI</h3>
      <p class="pseudocode">// Hint_WFI()
// ==========
// Provides a hint indicating that the PE can enter a low-power state and
// remain there until a wakeup event occurs.

func Hint_WFI()
begin
    if <a href="shared_pseudocode.html#func_AArch64_InterruptPending_0" title="">AArch64_InterruptPending</a>() then
        // No further operation if an interrupt is pending.
        EndOfInstruction();
    end;

    var trap : boolean;
    var target_el : bits(2);
    (trap, target_el) = AArch64_CheckForWFxTrap(WFxType_WFI);
    if trap then
        if target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then
            Undefined();
        end;
        AArch64_WFxTrap(WFxType_WFI, target_el);
    else
        WaitForInterrupt();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_WFIT"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_WFIT</h3>
      <p class="pseudocode">// Hint_WFIT()
// ===========
// Provides a hint indicating that the PE can enter a low-power state and
// remain there until a wakeup event occurs or, for WFIT, a local timeout
// event is generated when the virtual timer value equals or exceeds the
// supplied threshold value.

func Hint_WFIT(localtimeout : integer)
begin
    if (<a href="shared_pseudocode.html#func_AArch64_InterruptPending_0" title="">AArch64_InterruptPending</a>() || (IsFeatureImplemented(FEAT_WFxT) &amp;&amp;
          <a href="shared_pseudocode.html#func_LocalTimeoutEvent_1" title="">LocalTimeoutEvent</a>(localtimeout))) then
        // No further operation if an interrupt is pending or the local timeout has expired.
        EndOfInstruction();
    end;

    var trap : boolean;
    var target_el : bits(2);
    (trap, target_el) = AArch64_CheckForWFxTrap(WFxType_WFIT);
    if trap then
        if target_el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL3SDDUndef_0" title="">EL3SDDUndef</a>() then
            Undefined();
        end;
        AArch64_WFxTrap(WFxType_WFIT, target_el);
    else
        WaitForInterrupt(localtimeout);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_Yield"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_Yield</h3>
      <p class="pseudocode">// Hint_Yield()
// ============
// Provides a hint that the task performed by a thread is of low
// importance so that it could yield to improve overall performance.

impdef func Hint_Yield()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IRQPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IRQPending</h3>
      <p class="pseudocode">// IRQPending()
// ============
// Returns a tuple indicating if there is any pending physical IRQ
// and if the pending IRQ has superpriority.

impdef func <a id="func_IRQPending_0"/>IRQPending() =&gt; (boolean, boolean)
begin
    return (FALSE, FALSE);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IllegalExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IllegalExceptionReturn</h3>
      <p class="pseudocode">// IllegalExceptionReturn()
// ========================

func <a id="func_IllegalExceptionReturn_2"/>IllegalExceptionReturn{N}(spsr : bits(N)) =&gt; boolean
begin
    // Check for illegal return:
    //   * To an unimplemented Exception level.
    //   * To EL2 in Secure state, when SecureEL2 is not enabled.
    //   * To EL0 using AArch64 state, with SPSR.M[0]==1.
    //   * To AArch64 state with SPSR.M[1]==1.
    //   * To AArch32 state with an illegal value of SPSR.M.
    let (valid, target) : (boolean, bits(2)) = <a href="shared_pseudocode.html#func_ELFromSPSR_2" title="">ELFromSPSR</a>{N}(spsr);
    if !valid then return TRUE; end;

    // Check for return to higher Exception level.
    if UInt(target) &gt; UInt(PSTATE.EL) then return TRUE; end;

    let spsr_mode_is_aarch32 : boolean = (spsr[4] == '1');

    // Check for illegal return:
    //   * To EL1, EL2 or EL3 with register width specified in the SPSR different from the
    //     Execution state used in the Exception level being returned to, as determined by
    //     the SCR_EL3.RW or HCR_EL2.RW bits, or as configured from reset.
    //   * To EL0 using AArch64 state when EL1 is using AArch32 state as determined by the
    //     SCR_EL3.RW or HCR_EL2.RW bits or as configured from reset.
    //   * To AArch64 state from AArch32 state (should be caught by above).
    let (known, target_el_is_aarch32) : (boolean, boolean) = <a href="shared_pseudocode.html#func_ELUsingAArch32K_1" title="">ELUsingAArch32K</a>(target);
    assert known || (target == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>));
    if known &amp;&amp; spsr_mode_is_aarch32 != target_el_is_aarch32 then return TRUE; end;

    // Check for illegal return from AArch32 to AArch64_
    if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() &amp;&amp; !spsr_mode_is_aarch32 then return TRUE; end;
    // Check for illegal return to EL1 when HCR_EL2.TGE is set and when either of
    // * SecureEL2 is enabled.
    // * SecureEL2 is not enabled and EL1 is in Non-secure state.
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; target == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; HCR_EL2().TGE == '1' then
        if (!<a href="shared_pseudocode.html#func_IsSecureBelowEL3_0" title="">IsSecureBelowEL3</a>() || <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>()) then return TRUE; end;
    end;

    // Check for an illegal return to EL1 by a Guest Hypervisor at EL1 when HCRX_EL2.NVTGE is set.
    if (IsFeatureImplemented(FEAT_NV3) &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; spsr[3:2] == '01' &amp;&amp;
          <a href="shared_pseudocode.html#func_EffectiveHCR_EL2_NVx_0" title="">EffectiveHCR_EL2_NVx</a>() == '101' &amp;&amp; <a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() &amp;&amp;  HCRX_EL2().NVTGE == '1' &amp;&amp;
          NVHCR_EL2().TGE == '1') then
        return TRUE;
    end;

    if (IsFeatureImplemented(FEAT_GCS) &amp;&amp; PSTATE.EXLOCK == '0' &amp;&amp;
          PSTATE.EL == target &amp;&amp; <a href="shared_pseudocode.html#func_GetCurrentEXLOCKEN_0" title="">GetCurrentEXLOCKEN</a>()) then
        return TRUE;
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.InstrSet"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/InstrSet</h3>
      <p class="pseudocode">// InstrSet
// ========

type <a id="InstrSet"/>InstrSet of enumeration {InstrSet_A64, InstrSet_A32, InstrSet_T32};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.InstructionFetchBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/InstructionFetchBarrier</h3>
      <p class="pseudocode">// InstructionFetchBarrier()
// =========================

impdef func InstructionFetchBarrier()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.InstructionSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/InstructionSynchronizationBarrier</h3>
      <p class="pseudocode">// InstructionSynchronizationBarrier()
// ===================================

impdef func InstructionSynchronizationBarrier()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsASEInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsASEInstruction</h3>
      <p class="pseudocode">// IsASEInstruction()
// ==================
// Returns TRUE if the current instruction is an ASIMD or SVE vector instruction.

impdef func <a id="func_IsASEInstruction_0"/>IsASEInstruction() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsCurrentSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsCurrentSecurityState</h3>
      <p class="pseudocode">// IsCurrentSecurityState()
// ========================
// Returns TRUE if the current Security state matches
// the given Security state, and FALSE otherwise.

func <a id="func_IsCurrentSecurityState_1"/>IsCurrentSecurityState(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>) =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == ss;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsEventRegisterSet"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsEventRegisterSet</h3>
      <p class="pseudocode">// IsEventRegisterSet()
// ====================
// Return TRUE if the Event Register of this PE is set, and FALSE if it is clear.

func <a id="func_IsEventRegisterSet_0"/>IsEventRegisterSet() =&gt; boolean
begin
    return <a href="shared_pseudocode.html#global_EventRegister" title="">EventRegister</a> == '1';
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsHighestEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsHighestEL</h3>
      <p class="pseudocode">// IsHighestEL()
// =============
// Returns TRUE if given exception level is the highest exception level implemented

readonly func <a id="func_IsHighestEL_1"/>IsHighestEL(el : bits(2)) =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_HighestEL_0" title="">HighestEL</a>() == el;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsInHost"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsInHost</h3>
      <p class="pseudocode">// IsInHost()
// ==========

readonly func <a id="func_IsInHost_0"/>IsInHost() =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(PSTATE.EL);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsSecureBelowEL3"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsSecureBelowEL3</h3>
      <p class="pseudocode">// IsSecureBelowEL3()
// ==================
// Return TRUE if an Exception level below EL3 is in Secure state
// or would be following an exception return to that level.
//
// That is, if at AArch64 EL3 or in AArch32 Monitor mode, whether an
// exception return would pass to Secure or Non-secure state.

readonly func <a id="func_IsSecureBelowEL3_0"/>IsSecureBelowEL3() =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        return if !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then SCR().NS == '0' else SCR_EL3().NS == '0';
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; (!IsFeatureImplemented(FEAT_SEL2) || !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>()) then
        // If Secure EL2 is not an architecture option then we must be Non-secure.
        return FALSE;
    else
        // TRUE if PE is Secure or FALSE if Non-secure.
        return ImpDefBool("Secure-only implementation");
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsSecureEL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsSecureEL2Enabled</h3>
      <p class="pseudocode">// IsSecureEL2Enabled()
// ====================
// Returns TRUE if Secure EL2 is enabled, FALSE otherwise.

readonly func <a id="func_IsSecureEL2Enabled_0"/>IsSecureEL2Enabled() =&gt; boolean
begin
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; IsFeatureImplemented(FEAT_SEL2) then
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            if !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().EEL2 == '1' then
                return TRUE;
            else
                return FALSE;
            end;
        else
            return <a href="shared_pseudocode.html#func_SecureOnlyImplementation_0" title="">SecureOnlyImplementation</a>();
        end;
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.LocalTimeoutEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/LocalTimeoutEvent</h3>
      <p class="pseudocode">// LocalTimeoutEvent()
// ===================
// Returns TRUE if CNTVCT_EL0 equals or exceeds the localtimeout value.

func <a id="func_LocalTimeoutEvent_1"/>LocalTimeoutEvent(localtimeout : integer) =&gt; boolean
begin
    assert localtimeout &gt;= 0;

    let cntvct : bits(64) = <a href="shared_pseudocode.html#func_VirtualCounterTimer_0" title="">VirtualCounterTimer</a>();
    if UInt(cntvct) &gt;= localtimeout then
        return TRUE;
    end;

    <a href="shared_pseudocode.html#global_IsLocalTimeoutEventPending" title="">IsLocalTimeoutEventPending</a> = TRUE;
    <a href="shared_pseudocode.html#global_LocalTimeoutVal" title="">LocalTimeoutVal</a> = localtimeout[63:0];   // Store value to compare against
                                            // Virtual Counter Timer at subsequent clock ticks
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Mode"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Mode</h3>
      <p class="pseudocode">// Mode bits
// =========
// AArch32 PSTATE.M mode bits.

constant <a id="global_M32_User"/>M32_User : bits(5)    = '10000';

constant <a id="global_M32_FIQ"/>M32_FIQ : bits(5)     = '10001';

constant <a id="global_M32_IRQ"/>M32_IRQ : bits(5)     = '10010';

constant <a id="global_M32_Svc"/>M32_Svc : bits(5)     = '10011';

constant <a id="global_M32_Monitor"/>M32_Monitor : bits(5) = '10110';

constant <a id="global_M32_Abort"/>M32_Abort : bits(5)   = '10111';

constant <a id="global_M32_Hyp"/>M32_Hyp : bits(5)     = '11010';

constant <a id="global_M32_Undef"/>M32_Undef : bits(5)   = '11011';

constant <a id="global_M32_System"/>M32_System : bits(5)  = '11111';</p>
    </div>
    <div class="ps"><a id="shared.functions.system.NonSecureOnlyImplementation"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/NonSecureOnlyImplementation</h3>
      <p class="pseudocode">// NonSecureOnlyImplementation()
// =============================
// Returns TRUE if the security state is always Non-secure for this implementation.

func <a id="func_NonSecureOnlyImplementation_0"/>NonSecureOnlyImplementation() =&gt; boolean
begin
    return ImpDefBool("Non-secure only implementation");
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.PLOfEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/PLOfEL</h3>
      <p class="pseudocode">// PLOfEL()
// ========

func PLOfEL(el : bits(2)) =&gt; <a href="shared_pseudocode.html#PrivilegeLevel" title="type PrivilegeLevel">PrivilegeLevel</a>
begin
    case el of
        when EL3 =&gt;  return if !HaveAArch64() then PL1 else PL3;
        when EL2 =&gt;  return PL2;
        when EL1 =&gt;  return PL1;
        when EL0 =&gt;  return PL0;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.PSTATE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/PSTATE</h3>
      <p class="pseudocode">// PSTATE
// ======
// PE state bits.
// There is no significance to the field order.

var PSTATE : collection {
    N : bits (1),        // Negative condition flag
    Z : bits (1),        // Zero condition flag
    C : bits (1),        // Carry condition flag
    V : bits (1),        // Overflow condition flag
    D : bits (1),        // Debug mask bit                     [AArch64 only]
    A : bits (1),        // SError interrupt mask bit
    I : bits (1),        // IRQ mask bit
    F : bits (1),        // FIQ mask bit
    EXLOCK : bits (1),   // Lock exception return state
    PAN : bits (1),      // Privileged Access Never Bit        [v8.1]
    UAO : bits (1),      // User Access Override               [v8.2]
    DIT : bits (1),      // Data Independent Timing            [v8.4]
    TCO : bits (1),      // Tag Check Override                 [v8.5, AArch64 only]
    PM : bits (1),       // PMU exception Mask
    PPEND : bits (1),     // synchronous PMU exception to be observed
    BTYPE : bits (2),    // Branch Type                        [v8.5]
    PACM : bits (1),     // PAC instruction modifier
    ZA : bits (1),       // Accumulation array enabled         [SME]
    SM : bits (1),       // Streaming SVE mode enabled         [SME]
    ALLINT : bits (1),   // Interrupt mask bit
    UINJ : bits (1),     // Undefined Exception Injection
    SS : bits (1),       // Software step bit
    IL : bits (1),       // Illegal Execution state bit
    EL : bits (2),       // Exception level
    nRW : bits (1),      // Execution state: 0=AArch64, 1=AArch32
    SP : bits (1),       // Stack pointer select: 0=SP0, 1=SPx [AArch64 only]
    Q : bits (1),        // Cumulative saturation flag         [AArch32 only]
    GE : bits (4),       // Greater than or Equal flags        [AArch32 only]
    SSBS : bits (1),     // Speculative Store Bypass Safe
    IT : bits (8),       // If-then bits, RES0 in CPSR         [AArch32 only]
    J : bits (1),        // J bit, RES0                        [AArch32 only, RES0 in SPSR and CPSR]
    T : bits (1),        // T32 bit, RES0 in CPSR              [AArch32 only]
    E : bits (1),        // Endianness bit                     [AArch32 only]
    M : bits (5);        // Mode field                         [AArch32 only]

};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.PhysicalCountInt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/PhysicalCountInt</h3>
      <p class="pseudocode">// PhysicalCountInt()
// ==================
// Returns the integral part of physical count value of the System counter.

func <a id="func_PhysicalCountInt_0"/>PhysicalCountInt() =&gt; bits(64)
begin
    return <a href="shared_pseudocode.html#global_PhysicalCount" title="">PhysicalCount</a>[87:24];
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.PrivilegeLevel"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/PrivilegeLevel</h3>
      <p class="pseudocode">// PrivilegeLevel
// ==============
// Privilege Level abstraction.

type <a id="PrivilegeLevel"/>PrivilegeLevel of enumeration {PL3, PL2, PL1, PL0};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.RestoredITBits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/RestoredITBits</h3>
      <p class="pseudocode">// RestoredITBits()
// ================
// Get the value of PSTATE.IT to be restored on this exception return.

func <a id="func_RestoredITBits_2"/>RestoredITBits{N}(spsr : bits(N)) =&gt; bits(8)
begin
    let it : bits(8) = spsr[15:10,26:25];

    // When PSTATE.IL is set, it is CONSTRAINED UNPREDICTABLE whether the IT bits are each set
    // to zero or copied from the SPSR.
    if PSTATE.IL == '1' then
        if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_ILZEROIT" title="">Unpredictable_ILZEROIT</a>) then return '00000000';
        else return it;
        end;
    end;

    // The IT bits are forced to zero when they are set to a reserved value.
    if !IsZero(it[7:4]) &amp;&amp; IsZero(it[3:0]) then
        return '00000000';
    end;

    // The IT bits are forced to zero when returning to A32 state, or when returning to an EL
    // with the ITD bit set to 1, and the IT bits are describing a multi-instruction block.
    let itd : bit = if PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then HSCTLR().ITD else SCTLR().ITD;
    if (spsr[5] == '0' &amp;&amp; !IsZero(it)) || (itd == '1' &amp;&amp; !IsZero(it[2:0])) then
        return '00000000';
    else
        return it;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SecureOnlyImplementation"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SecureOnlyImplementation</h3>
      <p class="pseudocode">// SecureOnlyImplementation()
// ==========================
// Returns TRUE if the security state is always Secure for this implementation.

readonly func <a id="func_SecureOnlyImplementation_0"/>SecureOnlyImplementation() =&gt; boolean
begin
    return ImpDefBool("Secure-only implementation");
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SecurityState</h3>
      <p class="pseudocode">// SecurityState
// =============
// The Security state of an execution context

type <a id="type_SecurityState"/>SecurityState of enumeration {
    <a id="enum_SS_NonSecure"/>SS_NonSecure,
    <a id="enum_SS_Root"/>SS_Root,
    <a id="enum_SS_Realm"/>SS_Realm,
    <a id="enum_SS_Secure"/>SS_Secure
};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SecurityStateAtEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SecurityStateAtEL</h3>
      <p class="pseudocode">// SecurityStateAtEL()
// ===================
// Returns the effective security state at the exception level based off current settings.

readonly func <a id="func_SecurityStateAtEL_1"/>SecurityStateAtEL(EL : bits(2)) =&gt; <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>
begin
    if IsFeatureImplemented(FEAT_RME) then
        if EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then return <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a>; end;
        let effective_nse_ns : bits(2) = <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NSE_0" title="">EffectiveSCR_EL3_NSE</a>() :: <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>();
        case effective_nse_ns of
            when '00' =&gt;
                if IsFeatureImplemented(FEAT_SEL2) then
                    return <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
                else
                    unreachable;
                end;
            when '01' =&gt;
                return <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;
            when '11' =&gt;
                return <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a>;
            otherwise =&gt;
                unreachable;
        end;
    end;

    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        if <a href="shared_pseudocode.html#func_SecureOnlyImplementation_0" title="">SecureOnlyImplementation</a>() then
            return <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
        else
            return <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;
        end;
    elsif EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
        return <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
    else
        // For EL2 call only when EL2 is enabled in current security state
        assert(EL != <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> || <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>());
        if !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            return if <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>() == '1' then <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> else <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
        else
            return if SCR().NS == '1' then <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> else <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SendEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SendEvent</h3>
      <p class="pseudocode">// SendEvent()
// ===========
// Signal an event to all PEs in a multiprocessor system to set their Event Registers.
// When a PE executes the SEV instruction, it causes this function to be executed.

impdef func SendEvent()
begin
    SendEventLocal();
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SendEventLocal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SendEventLocal</h3>
      <p class="pseudocode">// SendEventLocal()
// ================
// Set the local Event Register of this PE.
// When a PE executes the SEVL instruction, it causes this function to be executed.

func SendEventLocal()
begin
    <a href="shared_pseudocode.html#global_EventRegister" title="">EventRegister</a> = '1';
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SetAccumulatedFPExceptions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SetAccumulatedFPExceptions</h3>
      <p class="pseudocode">// SetAccumulatedFPExceptions()
// ============================
// Stores FP Exceptions accumulated by the PE.

impdef func SetAccumulatedFPExceptions(accumulated_exceptions : bits(8))
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SetPSTATEFromPSR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SetPSTATEFromPSR</h3>
      <p class="pseudocode">// SetPSTATEFromPSR()
// ==================

func SetPSTATEFromPSR{N}(spsr : bits(N))
begin
    let illegal_psr_state : boolean = <a href="shared_pseudocode.html#func_IllegalExceptionReturn_2" title="">IllegalExceptionReturn</a>{N}(spsr);
    SetPSTATEFromPSR{N}(spsr, illegal_psr_state);
end;

// SetPSTATEFromPSR()
// ==================
// Set PSTATE based on a PSR value

func SetPSTATEFromPSR{N}(spsr_in : bits(N), illegal_psr_state : boolean)
begin
    var spsr : bits(N) = spsr_in;
    let from_aarch64 : boolean = !<a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>();
    PSTATE.SS = <a href="shared_pseudocode.html#func_DebugExceptionReturnSS_2" title="">DebugExceptionReturnSS</a>{N}(spsr);
    if IsFeatureImplemented(FEAT_SEBEP) then
        assert N == 64;
        ExceptionReturnPPEND(ZeroExtend{64}(spsr));
    end;

    <a href="shared_pseudocode.html#global_ShouldAdvanceSS" title="">ShouldAdvanceSS</a> = FALSE;
    if illegal_psr_state then
        PSTATE.IL = '1';
        if IsFeatureImplemented(FEAT_SSBS) then PSTATE.SSBS = ARBITRARY : bit; end;
        if IsFeatureImplemented(FEAT_BTI) then PSTATE.BTYPE = ARBITRARY : bits(2); end;
        if IsFeatureImplemented(FEAT_UAO) then PSTATE.UAO = ARBITRARY : bit; end;
        if IsFeatureImplemented(FEAT_DIT) then PSTATE.DIT = ARBITRARY : bit; end;
        if IsFeatureImplemented(FEAT_MTE) then PSTATE.TCO = ARBITRARY : bit; end;
        if IsFeatureImplemented(FEAT_PAuth_LR) then PSTATE.PACM = ARBITRARY : bit; end;
        if IsFeatureImplemented(FEAT_UINJ) then PSTATE.UINJ = '0'; end;
    else
        // State that is reinstated only on a legal exception return
        PSTATE.IL = spsr[20];
        if IsFeatureImplemented(FEAT_UINJ) then PSTATE.UINJ = spsr[36]; end;
        if spsr[4] == '1' then                    // AArch32 state
            AArch32_WriteMode(spsr[4:0]);         // Sets PSTATE.EL correctly
            if IsFeatureImplemented(FEAT_SSBS) then PSTATE.SSBS = spsr[23]; end;
        else                                      // AArch64 state
            PSTATE.nRW = '0';
            (-, PSTATE.EL) = <a href="shared_pseudocode.html#func_ELFromSPSR_2" title="">ELFromSPSR</a>{N}(spsr);
            PSTATE.SP  = spsr[0];
            if IsFeatureImplemented(FEAT_BTI) then PSTATE.BTYPE = spsr[11:10]; end;
            if IsFeatureImplemented(FEAT_SSBS) then PSTATE.SSBS = spsr[12]; end;
            if IsFeatureImplemented(FEAT_UAO) then PSTATE.UAO = spsr[23]; end;
            if IsFeatureImplemented(FEAT_DIT) then PSTATE.DIT = spsr[24]; end;
            if IsFeatureImplemented(FEAT_MTE) then PSTATE.TCO = spsr[25]; end;
            if IsFeatureImplemented(FEAT_GCS) then PSTATE.EXLOCK = spsr[34]; end;
            if IsFeatureImplemented(FEAT_PAuth_LR) then
                PSTATE.PACM = if <a href="shared_pseudocode.html#func_IsPACMEnabled_0" title="">IsPACMEnabled</a>() then spsr[35] else '0';
            end;
        end;
    end;

    // If PSTATE.IL is set, it is CONSTRAINED UNPREDICTABLE whether the T bit is set to zero or
    // copied from SPSR.
    if PSTATE.IL == '1' &amp;&amp; PSTATE.nRW == '1' then
        if <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_ILZEROT" title="">Unpredictable_ILZEROT</a>) then spsr[5] = '0'; end;
    end;

    // State that is reinstated regardless of illegal exception return
    PSTATE.[N,Z,C,V] = spsr[31:28];
    if IsFeatureImplemented(FEAT_PAN) then PSTATE.PAN = spsr[22]; end;
    if PSTATE.nRW == '1' then                     // AArch32 state
        PSTATE.Q         = spsr[27];
        PSTATE.IT        = <a href="shared_pseudocode.html#func_RestoredITBits_2" title="">RestoredITBits</a>{N}(spsr);
        <a href="shared_pseudocode.html#global_ShouldAdvanceIT" title="">ShouldAdvanceIT</a>  = FALSE;
        if IsFeatureImplemented(FEAT_DIT) then
            PSTATE.DIT = (if (<a href="shared_pseudocode.html#func_Restarting_0" title="">Restarting</a>() || from_aarch64) then spsr[24] else spsr[21]);
        end;
        PSTATE.GE        = spsr[19:16];
        PSTATE.E         = spsr[9];
        PSTATE.[A,I,F]   = spsr[8:6];             // No PSTATE.D in AArch32 state
        PSTATE.T         = spsr[5];               // PSTATE.J is RES0
    else                                          // AArch64 state
        if (IsFeatureImplemented(FEAT_EBEP) || IsFeatureImplemented(FEAT_SPE_EXC) ||
              IsFeatureImplemented(FEAT_TRBE_EXC)) then
            PSTATE.PM    = spsr[32];
        end;
        if IsFeatureImplemented(FEAT_NMI) then PSTATE.ALLINT  = spsr[13]; end;
        PSTATE.[D,A,I,F] = spsr[9:6];             // No PSTATE.[Q,IT,GE,E,T] in AArch64 state
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ShouldAdvanceHS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ShouldAdvanceHS</h3>
      <p class="pseudocode">// ShouldAdvanceHS
// ===============
// Cleared if we should not advance the EDESR.SS after the current instruction.

var <a id="global_ShouldAdvanceHS"/>ShouldAdvanceHS : boolean;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ShouldAdvanceIT"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ShouldAdvanceIT</h3>
      <p class="pseudocode">// ShouldAdvanceIT
// ===============
// Cleared if we should not advance the PSTATE.IT after the current instruction.

var <a id="global_ShouldAdvanceIT"/>ShouldAdvanceIT : boolean;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ShouldAdvanceSS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ShouldAdvanceSS</h3>
      <p class="pseudocode">// ShouldAdvanceSS
// ===============
// Cleared if PSTATE.SS is written by the current instruction.

var <a id="global_ShouldAdvanceSS"/>ShouldAdvanceSS : boolean;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ShouldSetPPEND"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ShouldSetPPEND</h3>
      <p class="pseudocode">// ShouldSetPPEND
// ==============
// TRUE if PSTATE.PPEND is set or cleared at the end of the current instruction, according to
// whether a PMU counter configured for synchronous mode overflowed or not.
// Otherwise, PSTATE.PPEND is not changed at the end of the instruction.

var <a id="global_ShouldSetPPEND"/>ShouldSetPPEND : boolean;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SmallestTranslationGranule"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SmallestTranslationGranule</h3>
      <p class="pseudocode">// SmallestTranslationGranule()
// ============================
// Smallest implemented translation granule.

func <a id="func_SmallestTranslationGranule_0"/>SmallestTranslationGranule() =&gt; integer
begin
    if IsFeatureImplemented(FEAT_TGran4K) then return 12; end;
    if IsFeatureImplemented(FEAT_TGran16K) then return 14; end;
    if IsFeatureImplemented(FEAT_TGran64K)  then return 16; end;
    unreachable;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SpeculationBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SpeculationBarrier</h3>
      <p class="pseudocode">// SpeculationBarrier()
// ====================

impdef func SpeculationBarrier()
begin
    // Since there is no speculation in asl model, this is a NOP.
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SyncCounterOverflowed"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SyncCounterOverflowed</h3>
      <p class="pseudocode">// SyncCounterOverflowed
// =====================
// Set if a PMU counter configured for synchronous mode has overflowed
// during the execution of the current instruction.

var <a id="global_SyncCounterOverflowed"/>SyncCounterOverflowed : boolean;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SynchronizeContext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SynchronizeContext</h3>
      <p class="pseudocode">// SynchronizeContext()
// ====================
// Context Synchronization event, includes Instruction Fetch Barrier effect

impdef func SynchronizeContext()
begin
    InstructionFetchBarrier();
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SynchronizeErrors"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SynchronizeErrors</h3>
      <p class="pseudocode">// SynchronizeErrors()
// ===================
// Implements the error synchronization event.

impdef func SynchronizeErrors()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.TakeUnmaskedPhysicalSErrorInterrupts"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/TakeUnmaskedPhysicalSErrorInterrupts</h3>
      <p class="pseudocode">// TakeUnmaskedPhysicalSErrorInterrupts()
// ======================================
// Take any pending unmasked physical SError interrupt.

impdef func TakeUnmaskedPhysicalSErrorInterrupts(iesb_req : boolean)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.TakeUnmaskedSErrorInterrupts"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/TakeUnmaskedSErrorInterrupts</h3>
      <p class="pseudocode">// TakeUnmaskedSErrorInterrupts()
// ==============================
// Take any pending unmasked physical SError interrupt or unmasked virtual SError
// interrupt.

impdef func TakeUnmaskedSErrorInterrupts()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ThisInstr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ThisInstr</h3>
      <p class="pseudocode">// ThisInstr()
// ===========

impdef func <a id="func_ThisInstr_0"/>ThisInstr() =&gt; bits(32)
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ThisInstrLength"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ThisInstrLength</h3>
      <p class="pseudocode">// ThisInstrLength()
// =================

impdef func <a id="func_ThisInstrLength_0"/>ThisInstrLength() =&gt; integer
begin
    Unimplemented();
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.UndefinedInjectionCheck"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/UndefinedInjectionCheck</h3>
      <p class="pseudocode">// UndefinedInjectionCheck()
// =========================
// Check PSTATE.UINJ to determine if execution of the current
// instruction should cause an Undefined exception.

func UndefinedInjectionCheck()
begin
    if IsFeatureImplemented(FEAT_UINJ) &amp;&amp; PSTATE.UINJ == '1' then
        Undefined();
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.UsingAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/UsingAArch32</h3>
      <p class="pseudocode">// UsingAArch32()
// ==============
// Return TRUE if the current Exception level is using AArch32, FALSE if using AArch64_

readonly func <a id="func_UsingAArch32_0"/>UsingAArch32() =&gt; boolean
begin
    let aarch32 : boolean = (PSTATE.nRW == '1');
    if !<a href="shared_pseudocode.html#func_HaveAArch32_0" title="">HaveAArch32</a>() then assert !aarch32; end;
    if !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then assert aarch32; end;
    return aarch32;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ValidSecurityStateAtEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ValidSecurityStateAtEL</h3>
      <p class="pseudocode">// ValidSecurityStateAtEL()
// ========================
// Returns TRUE if the current settings and architecture choices for this
// implementation permit a valid Security state at the indicated EL.

func <a id="func_ValidSecurityStateAtEL_1"/>ValidSecurityStateAtEL(el : bits(2)) =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(el) then
        return FALSE;
    end;

    if el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
        return TRUE;
    end;

    if IsFeatureImplemented(FEAT_RME) then
        let effective_nse_ns : bits(2) = <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NSE_0" title="">EffectiveSCR_EL3_NSE</a>() :: <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>();
        if effective_nse_ns == '10' then
            return FALSE;
        end;
    end;

    if el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        return <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
    end;

    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.VirtualFIQPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/VirtualFIQPending</h3>
      <p class="pseudocode">// VirtualFIQPending()
// ===================
// Returns TRUE if there is any pending virtual FIQ.

impdef func <a id="func_VirtualFIQPending_0"/>VirtualFIQPending() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.VirtualIRQPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/VirtualIRQPending</h3>
      <p class="pseudocode">// VirtualIRQPending()
// ===================
// Returns TRUE if there is any pending virtual IRQ.

impdef func <a id="func_VirtualIRQPending_0"/>VirtualIRQPending() =&gt; boolean
begin
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.WFxType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/WFxType</h3>
      <p class="pseudocode">// WFxType
// =======
// WFx instruction types.

type <a id="WFxType"/>WFxType of enumeration {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.WaitForEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/WaitForEvent</h3>
      <p class="pseudocode">// WaitForEvent()
// ==============
// PE optionally suspends execution until one of the following occurs:
// - A WFE wakeup event.
// - A reset.
// - The implementation chooses to resume execution.
// It is IMPLEMENTATION DEFINED whether restarting execution after the period of
// suspension causes the Event Register to be cleared.

func WaitForEvent()
begin
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then return; end;
    if !<a href="shared_pseudocode.html#func_IsEventRegisterSet_0" title="">IsEventRegisterSet</a>() then
        EnterLowPowerState();
    end;
    return;
end;

// WaitForEvent()
// ==============
// PE optionally suspends execution until one of the following occurs:
// - A WFE wakeup event.
// - A reset.
// - The implementation chooses to resume execution.
// - A Wait for Event with Timeout (WFET) is executing, and a local timeout event occurs
// It is IMPLEMENTATION DEFINED whether restarting execution after the period of
// suspension causes the Event Register to be cleared.

func WaitForEvent(localtimeout : integer)
begin
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then return; end;
    if !(<a href="shared_pseudocode.html#func_IsEventRegisterSet_0" title="">IsEventRegisterSet</a>() || <a href="shared_pseudocode.html#func_LocalTimeoutEvent_1" title="">LocalTimeoutEvent</a>(localtimeout)) then
        EnterLowPowerState();
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.WaitForInterrupt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/WaitForInterrupt</h3>
      <p class="pseudocode">// WaitForInterrupt()
// ==================
// PE optionally suspends execution until one of the following occurs:
// - A WFI wakeup event.
// - A reset.
// - The implementation chooses to resume execution.

func WaitForInterrupt()
begin
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then return; end;
    EnterLowPowerState();
    return;
end;

// WaitForInterrupt()
// ==================
// PE optionally suspends execution until one of the following occurs:
// - A WFI wakeup event.
// - A reset.
// - The implementation chooses to resume execution.
// - A Wait for Interrupt with Timeout (WFIT) is executing, and a local timeout event occurs.

func WaitForInterrupt(localtimeout : integer)
begin
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() then return; end;
    if !<a href="shared_pseudocode.html#func_LocalTimeoutEvent_1" title="">LocalTimeoutEvent</a>(localtimeout) then
        EnterLowPowerState();
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.WatchpointRelatedSyndrome"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/WatchpointRelatedSyndrome</h3>
      <p class="pseudocode">// WatchpointRelatedSyndrome()
// ===========================
// Update common Watchpoint related fields.

func <a id="func_WatchpointRelatedSyndrome_1"/>WatchpointRelatedSyndrome(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; bits(24)
begin
    var syndrome : bits(24) = Zeros{};

    if fault.watchptinfo.maybe_false_match then
        syndrome[16] = '1';                                          // WPF
    elsif IsFeatureImplemented(FEAT_Debugv8p2) then
        syndrome[16] = ImpDefBit("WPF value on TRUE Watchpoint match");
    end;

    if <a href="shared_pseudocode.html#func_IsRelaxedWatchpointAccess_1" title="">IsRelaxedWatchpointAccess</a>(fault.accessdesc) then
        if <a href="shared_pseudocode.html#func_HaltOnBreakpointOrWatchpoint_0" title="">HaltOnBreakpointOrWatchpoint</a>() then
            if ImpDefBool("EDWAR is not valid on watchpoint debug event") then
                syndrome[10] = '1';                                  // FnV
            end;
        else
            if ImpDefBool("FAR is not valid on watchpoint exception") then
                syndrome[10] = '1';                                  // FnV
            end;
        end;
    else
        if <a href="shared_pseudocode.html#func_WatchpointFARNotPrecise_1" title="">WatchpointFARNotPrecise</a>(fault) then
            syndrome[15] = '1';                                      // FnP
        end;
    end;

    // Watchpoint number is valid if FEAT_Debugv8p9 is implemented or
    // if Feat_Debugv8p2 is implemented and below set of conditions are satisfied:
    // - Either FnV = 1 or FnP = 1.
    // - If the address recorded in FAR is not within a naturally-aligned block of memory.
    // Otherwise, it is IMPLEMENTATION DEFINED if watchpoint number is valid.
    if IsFeatureImplemented(FEAT_Debugv8p9) then
        syndrome[17]    = '1';                                       // WPTV
        syndrome[23:18] = fault.watchptinfo.watchpt_num[5:0];        // WPT
    elsif IsFeatureImplemented(FEAT_Debugv8p2) then
        if syndrome[15] == '1' || syndrome[10] == '1' then           // Either of FnP or FnV is 1
            syndrome[17] = '1';                                      // WPTV
        elsif !<a href="shared_pseudocode.html#func_AddressInNaturallyAlignedBlock_2" title="">AddressInNaturallyAlignedBlock</a>(fault.vaddress, fault.watchptinfo.vaddress) then
            syndrome[17] = '1';                                      // WPTV
        elsif ImpDefBool("WPTV field is valid") then
            syndrome[17] = '1';
        end;
        if syndrome[17] == '1' then
            syndrome[23:18] = fault.watchptinfo.watchpt_num[5:0];    // WPT
        else
            syndrome[23:18] = ARBITRARY : bits(6);
        end;
    end;

    return syndrome;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.tlbi"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/tlbi</h3>
      <p class="pseudocode">constant <a id="global_VMID_NONE"/>VMID_NONE : bits(16) = Zeros{};

constant <a id="global_ASID_NONE"/>ASID_NONE : bits(16) = Zeros{};</p>
    </div>
    <div class="ps"><a id="shared.functions.tlbi.Broadcast"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/tlbi/Broadcast</h3>
      <p class="pseudocode">// Broadcast
// =========

type <a id="type_Broadcast"/>Broadcast of enumeration {
    <a id="enum_Broadcast_ISH"/>Broadcast_ISH,
    <a id="enum_Broadcast_ForcedISH"/>Broadcast_ForcedISH,
    <a id="enum_Broadcast_ISH_CnP"/>Broadcast_ISH_CnP,          // Broadcast only to PEs which would share TLB entries if CnP is 1.
    <a id="enum_Broadcast_OSHnISH"/>Broadcast_OSHnISH,          // Broadcast only to PEs in the Outer shareability domain, but not
                                // in the Inner shareability domain.
    <a id="enum_Broadcast_OSH"/>Broadcast_OSH,
    <a id="enum_Broadcast_NSH"/>Broadcast_NSH
};</p>
    </div>
    <div class="ps"><a id="shared.functions.tlbi.BroadcastTLBI"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/tlbi/BroadcastTLBI</h3>
      <p class="pseudocode">// BroadcastTLBI()
// ===============
// IMPLEMENTATION DEFINED function to broadcast TLBI operation within the indicated broadcast
// domain.

impdef func BroadcastTLBI(broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>)
begin
    BroadcastTLBI(broadcast, r, <a href="shared_pseudocode.html#global_DEFAULT_TLBI_DOMAIN" title="">DEFAULT_TLBI_DOMAIN</a>);
end;

impdef func BroadcastTLBI(broadcast : <a href="shared_pseudocode.html#type_Broadcast" title="">Broadcast</a>, r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>, domains : bits(16))
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.tlbi.TLBI"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/tlbi/TLBI</h3>
      <p class="pseudocode">// TLBI()
// ======
// Invalidates TLB entries for which TLBIMatch() returns TRUE.

impdef func TLBI(r : <a href="shared_pseudocode.html#type_TLBIRecord" title="">TLBIRecord</a>)
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.tlbi.TLBILevel"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/tlbi/TLBILevel</h3>
      <p class="pseudocode">// TLBILevel
// =========

type <a id="type_TLBILevel"/>TLBILevel of enumeration {
    <a id="enum_TLBILevel_Any"/>TLBILevel_Any,        // this applies to TLB entries at all levels
    <a id="enum_TLBILevel_Last"/>TLBILevel_Last        // this applies to TLB entries at last level only
};</p>
    </div>
    <div class="ps"><a id="shared.functions.tlbi.TLBIMemAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/tlbi/TLBIMemAttr</h3>
      <p class="pseudocode">// TLBIMemAttr
// ===========
// Defines the attributes of the memory operations that must be completed in
// order to deem the TLBI operation as completed.

type <a id="type_TLBIMemAttr"/>TLBIMemAttr of enumeration {
    <a id="enum_TLBI_AllAttr"/>TLBI_AllAttr,         // All TLB entries within the scope of the invalidation
    <a id="enum_TLBI_ExcludeXS"/>TLBI_ExcludeXS        // Only TLB entries with XS=0 within the scope of the invalidation
};</p>
    </div>
    <div class="ps"><a id="shared.functions.tlbi.TLBIOp"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/tlbi/TLBIOp</h3>
      <p class="pseudocode">// TLBIOp
// ======

type <a id="type_TLBIOp"/>TLBIOp of enumeration {
    <a id="enum_TLBIOp_DALL"/>TLBIOp_DALL,          // AArch32 Data TLBI operations - deprecated
    <a id="enum_TLBIOp_DASID"/>TLBIOp_DASID,
    <a id="enum_TLBIOp_DVA"/>TLBIOp_DVA,
    <a id="enum_TLBIOp_IALL"/>TLBIOp_IALL,          // AArch32 Instruction TLBI operations - deprecated
    <a id="enum_TLBIOp_IASID"/>TLBIOp_IASID,
    <a id="enum_TLBIOp_IVA"/>TLBIOp_IVA,
    <a id="enum_TLBIOp_ALL"/>TLBIOp_ALL,
    <a id="enum_TLBIOp_ASID"/>TLBIOp_ASID,
    <a id="enum_TLBIOp_IPAS2"/>TLBIOp_IPAS2,
    <a id="enum_TLBIPOp_IPAS2"/>TLBIPOp_IPAS2,
    <a id="enum_TLBIOp_VAA"/>TLBIOp_VAA,
    <a id="enum_TLBIOp_VA"/>TLBIOp_VA,
    <a id="enum_TLBIPOp_VAA"/>TLBIPOp_VAA,
    <a id="enum_TLBIPOp_VA"/>TLBIPOp_VA,
    <a id="enum_TLBIOp_VMALL"/>TLBIOp_VMALL,
    <a id="enum_TLBIOp_VMALLS12"/>TLBIOp_VMALLS12,
    <a id="enum_TLBIOp_RIPAS2"/>TLBIOp_RIPAS2,
    <a id="enum_TLBIPOp_RIPAS2"/>TLBIPOp_RIPAS2,
    <a id="enum_TLBIOp_RVAA"/>TLBIOp_RVAA,
    <a id="enum_TLBIOp_RVA"/>TLBIOp_RVA,
    <a id="enum_TLBIPOp_RVAA"/>TLBIPOp_RVAA,
    <a id="enum_TLBIPOp_RVA"/>TLBIPOp_RVA,
    <a id="enum_TLBIOp_RPA"/>TLBIOp_RPA,
    <a id="enum_TLBIOp_PAALL"/>TLBIOp_PAALL,
    <a id="enum_TLBIOp_VMALLWS2"/>TLBIOp_VMALLWS2
};</p>
    </div>
    <div class="ps"><a id="shared.functions.tlbi.TLBIRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/tlbi/TLBIRecord</h3>
      <p class="pseudocode">// TLBIRecord
// ==========
// Details related to a TLBI operation.

type <a id="type_TLBIRecord"/>TLBIRecord of record {
    op : <a href="shared_pseudocode.html#type_TLBIOp" title="">TLBIOp</a>,
    from_aarch64 : boolean, // originated as an AArch64 operation
    security : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>,
    regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
    use_vmid : boolean,
    vmid : bits(16),
    asid : bits(16),
    level : <a href="shared_pseudocode.html#type_TLBILevel" title="">TLBILevel</a>,
    attr : <a href="shared_pseudocode.html#type_TLBIMemAttr" title="">TLBIMemAttr</a>,
    ipaspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>,     // For operations that take IPA as input address
    address : bits(64),     // input address, for range operations, start address
    end_address : bits(64), // for range operations, end; address
    d64 : boolean,          // For operations that evict VMSAv8-64 based TLB entries
    d128 : boolean,         // For operations that evict VMSAv9-128 based TLB entries
    ttl : bits(4),          // translation table walk level holding the leaf entry
                            // for the address being invalidated
                            // For Non-Range Invalidations:
                            //   When the ttl is
                            //     '00xx'    : this applies to all TLB entries
                            //     Otherwise : TLBIP instructions invalidates D128 TLB
                            //                 entries only
                            //                 TLBI instructions invalidates D64 TLB
                            //                 entries only
                            // For Range Invalidations:
                            //   When the ttl is
                            //     '00'      : this applies to all TLB entries
                            //     Otherwise : TLBIP instructions invalidates D128 TLB
                            //                 entries only
                            //                 TLBI instructions invalidates D64 TLB
                            //                 entries only
    tg : bits(2)            // for range operations, translation granule

};</p>
    </div>
    <div class="ps"><a id="shared.functions.tlbi.VMID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/tlbi/VMID</h3>
      <p class="pseudocode">// VMID
// ====
// Effective VMID.

func <a id="func_VMID_0"/>VMID() =&gt; bits(16)
begin
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() then
        if !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            if IsFeatureImplemented(FEAT_VMID16) &amp;&amp; VTCR_EL2().VS == '1' then
                return VTTBR_EL2().VMID;
            else
                return ZeroExtend{16}(VTTBR_EL2().VMID[7:0]);
            end;
        else
            return ZeroExtend{16}(VTTBR().VMID);
        end;
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; IsFeatureImplemented(FEAT_SEL2) then
        return Zeros{16};
    else
        return <a href="shared_pseudocode.html#global_VMID_NONE" title="">VMID_NONE</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.unbounded_configs.Maximum"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unbounded_configs/Maximum</h3>
      <p class="pseudocode">// Maximum walk levels
// ===================
let MAX_WALK_LEVELS : integer{} = (if IsFeatureImplemented(FEAT_D128) then 6
                                   else (if IsFeatureImplemented(FEAT_LPA2) then 5
                                   else 4));</p>
    </div>
    <div class="ps"><a id="shared.functions.unbounded_configs.Unbounded"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unbounded_configs/Unbounded</h3>
      <p class="pseudocode">// Unbounded Variables
// ===================
// Sets the upper limit for a specific loop or function.

constant <a id="global_Unbounded"/>Unbounded : integer{} = 2^128;

config Unbounded_DiscardTransactionalWrites : integer{0..<a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>} = <a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>;

config Unbounded_DescriptorUpdate : integer{0..<a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>} = <a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>;

config Unbounded_semihost : integer{0..<a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>} = <a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>;

config Unbounded_ParseTrace : integer{0..<a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>} = <a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>;

config Unbounded_ParseExtensionPacket : integer{0..<a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>} = <a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>;

config Unbounded_ULEB128 : integer{0..<a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>} = <a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>;

config Unbounded_ULEB128n : integer{0..<a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>} = <a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>;

config Unbounded_FloorPow2 : integer{0..<a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>} = <a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>;

config Unbounded_NormalizeReal : integer{0..<a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>} = <a href="shared_pseudocode.html#global_Unbounded" title="">Unbounded</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictable"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictable</h3>
      <p class="pseudocode">// ConstrainUnpredictable()
// ========================
// Return the appropriate Constraint result to control the caller's behavior.
// The return value is IMPLEMENTATION DEFINED within a permitted list for each
// UNPREDICTABLE case.
// (The permitted list is determined by an assert or case statement at the call site.)

readonly impdef func <a id="func_ConstrainUnpredictable_0"/>ConstrainUnpredictable(which : <a href="shared_pseudocode.html#type_Unpredictable" title="">Unpredictable</a>) =&gt; <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>
begin
    case which of
        when <a href="shared_pseudocode.html#enum_Unpredictable_VMSR" title="">Unpredictable_VMSR</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_WBOVERLAPLD" title="">Unpredictable_WBOVERLAPLD</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_WBSUPPRESS" title="">Constraint_WBSUPPRESS</a>; // return loaded value
        when <a href="shared_pseudocode.html#enum_Unpredictable_WBOVERLAPST" title="">Unpredictable_WBOVERLAPST</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>;     // store pre-writeback value
        when <a href="shared_pseudocode.html#enum_Unpredictable_LDPOVERLAP" title="">Unpredictable_LDPOVERLAP</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>;    // instruction is UNDEFINED
        when <a href="shared_pseudocode.html#enum_Unpredictable_BASEOVERLAP" title="">Unpredictable_BASEOVERLAP</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>;  // use UNKNOWN address
        when <a href="shared_pseudocode.html#enum_Unpredictable_DATAOVERLAP" title="">Unpredictable_DATAOVERLAP</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>;  // store UNKNOWN value
        when <a href="shared_pseudocode.html#enum_Unpredictable_DEVPAGE2" title="">Unpredictable_DEVPAGE2</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FAULT" title="">Constraint_FAULT</a>;    // take an alignment fault
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESTCF" title="">Unpredictable_RESTCF</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>;  // Do not take a fault
        when <a href="shared_pseudocode.html#enum_Unpredictable_DEVICETAGSTORE" title="">Unpredictable_DEVICETAGSTORE</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>;     // Do not take a fault
        when <a href="shared_pseudocode.html#enum_Unpredictable_INSTRDEVICE" title="">Unpredictable_INSTRDEVICE</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_NONE" title="">Constraint_NONE</a>;     // Do not take a fault
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESCPACR" title="">Unpredictable_RESCPACR</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;     // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESMAIR" title="">Unpredictable_RESMAIR</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#enum_Unpredictable_S1CTAGGED" title="">Unpredictable_S1CTAGGED</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // SCTLR_ELx.C == '0' marks address as untagged
        when <a href="shared_pseudocode.html#enum_Unpredictable_S2RESMEMATTR" title="">Unpredictable_S2RESMEMATTR</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_NC" title="">Constraint_NC</a>;       // Map to Noncacheable value
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESTEXCB" title="">Unpredictable_RESTEXCB</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESDACR" title="">Unpredictable_RESDACR</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESPRRR" title="">Unpredictable_RESPRRR</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESVTCRS" title="">Unpredictable_RESVTCRS</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESTnSZ" title="">Unpredictable_RESTnSZ</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FORCE" title="">Constraint_FORCE</a>;    // Map to the limit value
        when <a href="shared_pseudocode.html#enum_Unpredictable_OORTnSZ" title="">Unpredictable_OORTnSZ</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FORCE" title="">Constraint_FORCE</a>;    // Map to the limit value
        when <a href="shared_pseudocode.html#enum_Unpredictable_LARGEIPA" title="">Unpredictable_LARGEIPA</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FORCE" title="">Constraint_FORCE</a>;    // Restrict the IA size to the PAMax value
        when <a href="shared_pseudocode.html#enum_Unpredictable_ESRCONDPASS" title="">Unpredictable_ESRCONDPASS</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Report as "AL"
        when <a href="shared_pseudocode.html#enum_Unpredictable_ILZEROIT" title="">Unpredictable_ILZEROIT</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Do not zero PSTATE.IT
        when <a href="shared_pseudocode.html#enum_Unpredictable_ILZEROT" title="">Unpredictable_ILZEROT</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Do not zero PSTATE.T
        when <a href="shared_pseudocode.html#enum_Unpredictable_BPVECTORCATCHPRI" title="">Unpredictable_BPVECTORCATCHPRI</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;     // Debug Vector Catch: match on 2nd halfword
        when <a href="shared_pseudocode.html#enum_Unpredictable_VCMATCHHALF" title="">Unpredictable_VCMATCHHALF</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // No match
        when <a href="shared_pseudocode.html#enum_Unpredictable_VCMATCHDAPA" title="">Unpredictable_VCMATCHDAPA</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // No match on Data Abort or Prefetch abort
        when <a href="shared_pseudocode.html#enum_Unpredictable_WPMASKANDBAS" title="">Unpredictable_WPMASKANDBAS</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Watchpoint disabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_WPBASCONTIGUOUS" title="">Unpredictable_WPBASCONTIGUOUS</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Watchpoint disabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESWPMASK" title="">Unpredictable_RESWPMASK</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>; // Watchpoint disabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_WPMASKEDBITS" title="">Unpredictable_WPMASKEDBITS</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Watchpoint disabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESBPWPCTRL" title="">Unpredictable_RESBPWPCTRL</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>; // Breakpoint/watchpoint disabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_BPNOTIMPL" title="">Unpredictable_BPNOTIMPL</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>; // Breakpoint disabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESBPTYPE" title="">Unpredictable_RESBPTYPE</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>; // Breakpoint disabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_BPNOTCTXCMP" title="">Unpredictable_BPNOTCTXCMP</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>; // Breakpoint disabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESMDSELR" title="">Unpredictable_RESMDSELR</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#enum_Unpredictable_BPMATCHHALF" title="">Unpredictable_BPMATCHHALF</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // No match
        when <a href="shared_pseudocode.html#enum_Unpredictable_BPMISMATCHHALF" title="">Unpredictable_BPMISMATCHHALF</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // No match
        when <a href="shared_pseudocode.html#enum_Unpredictable_BPLINKINGDISABLED" title="">Unpredictable_BPLINKINGDISABLED</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Breakpoint does not match
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESTARTALIGNPC" title="">Unpredictable_RESTARTALIGNPC</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Do not force alignment
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESTARTZEROUPPERPC" title="">Unpredictable_RESTARTZEROUPPERPC</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;     // Force zero extension
        when <a href="shared_pseudocode.html#enum_Unpredictable_ZEROUPPER" title="">Unpredictable_ZEROUPPER</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;     // zero top halves of X registers
        when <a href="shared_pseudocode.html#enum_Unpredictable_ERETZEROUPPERPC" title="">Unpredictable_ERETZEROUPPERPC</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;     // zero top half of PC
        when <a href="shared_pseudocode.html#enum_Unpredictable_A32FORCEALIGNPC" title="">Unpredictable_A32FORCEALIGNPC</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Do not force alignment
        when <a href="shared_pseudocode.html#enum_Unpredictable_SMD" title="">Unpredictable_SMD</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>;    // disabled SMC is Unallocated
        when <a href="shared_pseudocode.html#enum_Unpredictable_NONFAULT" title="">Unpredictable_NONFAULT</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Speculation enabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_SVEZEROUPPER" title="">Unpredictable_SVEZEROUPPER</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;     // zero top bits of Z registers
        when <a href="shared_pseudocode.html#enum_Unpredictable_SVELDNFDATA" title="">Unpredictable_SVELDNFDATA</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;     // Load mem data in NF loads
        when <a href="shared_pseudocode.html#enum_Unpredictable_SVELDNFZERO" title="">Unpredictable_SVELDNFZERO</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;     // Write zeros in NF loads
        when <a href="shared_pseudocode.html#enum_Unpredictable_CHECKSPNONEACTIVE" title="">Unpredictable_CHECKSPNONEACTIVE</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;     // Check SP alignment
        when <a href="shared_pseudocode.html#enum_Unpredictable_SMEZEROUPPER" title="">Unpredictable_SMEZEROUPPER</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;     // zero top bits of ZA registers
        when <a href="shared_pseudocode.html#enum_Unpredictable_NVNV1" title="">Unpredictable_NVNV1</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_NVNV1_00" title="">Constraint_NVNV1_00</a>; // Map unpredictable configuration of HCR_EL2[NV,NV1]
                                        // to NV = 0 and NV1 = 0
        when <a href="shared_pseudocode.html#enum_Unpredictable_BADDR_RESS" title="">Unpredictable_BADDR_RESS</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_RESS" title="">Constraint_RESS</a>;     // Values behave as RESS
        when <a href="shared_pseudocode.html#enum_Unpredictable_Shareability" title="">Unpredictable_Shareability</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_OSH" title="">Constraint_OSH</a>;      // Map reserved encoding of shareability to Outer Shareable
        when <a href="shared_pseudocode.html#enum_Unpredictable_AFUPDATE" title="">Unpredictable_AFUPDATE</a> =&gt;  // AF update for alignment or Permission fault
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_DBUPDATE" title="">Unpredictable_DBUPDATE</a> =&gt;  // DB State update for alignment fault
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_IESBinDebug" title="">Unpredictable_IESBinDebug</a> =&gt;  // Use SCTLR_ELx[].IESB in Debug state
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_BADPMSFCR" title="">Unpredictable_BADPMSFCR</a> =&gt;    // Bad settings for PMSFCR_EL1/PMSEVFR_EL1/PMSLATFR_EL1
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_RES_PMU_VS" title="">Unpredictable_RES_PMU_VS</a> =&gt;   // Bad setting for SVE Streaming mode filter
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_COUNT_CHAIN" title="">Unpredictable_COUNT_CHAIN</a> =&gt;  // Chained PMU counters idx, idx+1 are not in same range
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_EL1TIMESTAMP" title="">Unpredictable_EL1TIMESTAMP</a> =&gt; // Bad settings for TRFCR_EL1
            return <a href="shared_pseudocode.html#enum_Constraint_EL1TIMESTAMP" title="">Constraint_EL1TIMESTAMP</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_EL2TIMESTAMP" title="">Unpredictable_EL2TIMESTAMP</a> =&gt; // Bad settings for TRFCR_EL2
            return <a href="shared_pseudocode.html#enum_Constraint_EL2TIMESTAMP" title="">Constraint_EL2TIMESTAMP</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_ZEROBTYPE" title="">Unpredictable_ZEROBTYPE</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;           // Save BTYPE in SPSR_ELx/DPSR_EL0 as '00'
        when <a href="shared_pseudocode.html#enum_Unpredictable_CLEARERRITEZERO" title="">Unpredictable_CLEARERRITEZERO</a> =&gt; // Clearing sticky errors when instruction in flight
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_ALUEXCEPTIONRETURN" title="">Unpredictable_ALUEXCEPTIONRETURN</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_DBGxVR_RESS" title="">Unpredictable_DBGxVR_RESS</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_PMSCR_PCT" title="">Unpredictable_PMSCR_PCT</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_PMSCR_PCT_VIRT" title="">Constraint_PMSCR_PCT_VIRT</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_WFxTDEBUG" title="">Unpredictable_WFxTDEBUG</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // WFxT in Debug state does not execute as a NOP
        // Accesses are not single-copy atomic above the byte level
        when <a href="shared_pseudocode.html#enum_Unpredictable_LS64UNSUPPORTED" title="">Unpredictable_LS64UNSUPPORTED</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_LIMITED_ATOMICITY" title="">Constraint_LIMITED_ATOMICITY</a>;
        // Unaligned exclusives, atomics, acquire/release
        // to a region that is not to Normal inner write-back
        // outer write-back shareable generate an Alignment fault.
        when <a href="shared_pseudocode.html#enum_Unpredictable_LSE2_ALIGNMENT_FAULT" title="">Unpredictable_LSE2_ALIGNMENT_FAULT</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_LSE128OVERLAP" title="">Unpredictable_LSE128OVERLAP</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>;    // instruction is UNDEFINED
        when <a href="shared_pseudocode.html#enum_Unpredictable_IGNORETRAPINDEBUG" title="">Unpredictable_IGNORETRAPINDEBUG</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Trap to register access in debug state is enabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_PMUEVENTCOUNTER" title="">Unpredictable_PMUEVENTCOUNTER</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>;    // Accesses to the register are UNDEFINED
        when <a href="shared_pseudocode.html#enum_Unpredictable_RES_HPMN" title="">Unpredictable_RES_HPMN</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>;  // The counter is reserved for EL2 use
        when <a href="shared_pseudocode.html#enum_Unpredictable_RES_EPMN" title="">Unpredictable_RES_EPMN</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>;  // The counter is reserved for external use
        when <a href="shared_pseudocode.html#enum_Unpredictable_BRBFILTRATE" title="">Unpredictable_BRBFILTRATE</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // BRB_FILTRATE event not generated on BRB injection
        when <a href="shared_pseudocode.html#enum_Unpredictable_PMUSNAPSHOTEVENT" title="">Unpredictable_PMUSNAPSHOTEVENT</a> =&gt; // PMU_SNAPSHOT event not generated in Debug state
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESEPMSSAD" title="">Unpredictable_RESEPMSSAD</a> =&gt;
            // External access to PMUv3 Snapshot extension allowed in Secure state
            // when FEAT_RME is not implemented or Root state otherwise
            return <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESPMSSE" title="">Unpredictable_RESPMSSE</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>;   // PMU capture events disabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESPMEE" title="">Unpredictable_RESPMEE</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>;   // PMU Profiling exception disabled, PMUIRQ enabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESPMSEE" title="">Unpredictable_RESPMSEE</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>;   // SPE Profiling exception disabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESTRFEE" title="">Unpredictable_RESTRFEE</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>;   // TRBE Profiling exception disabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESTC" title="">Unpredictable_RESTC</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>;   // Threshold features disabled
        when <a href="shared_pseudocode.html#enum_Unpredictable_MOPSOVERLAP" title="">Unpredictable_MOPSOVERLAP</a> =&gt; // Instruction is UNDEFINED
            return <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_MOPS_R31" title="">Unpredictable_MOPS_R31</a> =&gt;    // Instruction is UNDEFINED
            return <a href="shared_pseudocode.html#enum_Constraint_UNDEF" title="">Constraint_UNDEF</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_CASRETURNOLDVALUE" title="">Unpredictable_CASRETURNOLDVALUE</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_WRITEFAILEDCAS" title="">Unpredictable_WRITEFAILEDCAS</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_STRONLYTAGCHECKEDCAS" title="">Unpredictable_STRONLYTAGCHECKEDCAS</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;     // CAS with compare fail does a Tag Check
        when <a href="shared_pseudocode.html#enum_Unpredictable_STRONLYTAGCHECKEDRCWSCAS" title="">Unpredictable_STRONLYTAGCHECKEDRCWSCAS</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;     // RCW(S)CAS with RCW(S) fail/compare fail does a Tag Check
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESERVEDNSxB" title="">Unpredictable_RESERVEDNSxB</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_MAPTOALLOCATED" title="">Constraint_MAPTOALLOCATED</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESERVEDNSxB_Trap" title="">Unpredictable_RESERVEDNSxB_Trap</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_RES_ETBAD" title="">Unpredictable_RES_ETBAD</a> =&gt;
            // ExternalTracebufferaccess disabled for res values
            return <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_RESBPMASK" title="">Unpredictable_RESBPMASK</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>; // Mask set to 0
        when <a href="shared_pseudocode.html#enum_Unpredictable_BPMASK" title="">Unpredictable_BPMASK</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Breakpoint match will fail
        when <a href="shared_pseudocode.html#enum_Unpredictable_BPMASKEDBITS" title="">Unpredictable_BPMASKEDBITS</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Breakpoint match will fail
        when <a href="shared_pseudocode.html#enum_Unpredictable_BPLINKEDADDRMATCH" title="">Unpredictable_BPLINKEDADDRMATCH</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;    // Breakpoint match will fail
        when <a href="shared_pseudocode.html#enum_Unpredictable_16BYTEROUNDEDUPACCESS" title="">Unpredictable_16BYTEROUNDEDUPACCESS</a> =&gt;
            // Watchpoint match of 16 byte rounded range in case of SVE access
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_16BYTEROUNDEDDOWNACCESS" title="">Unpredictable_16BYTEROUNDEDDOWNACCESS</a> =&gt;
            // Watchpoint match of 16 byte rounded range in case of SVE access
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_NODTRTAGCHK" title="">Unpredictable_NODTRTAGCHK</a> =&gt;
            // The load or store operation does not perform the Tag check in Debug state
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_CPACHECK" title="">Unpredictable_CPACHECK</a> =&gt;     // Do not perform Checked Pointer Arithmetic
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_Atomic_SYNC_ABORT" title="">Unpredictable_Atomic_SYNC_ABORT</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_Atomic_SERROR" title="">Unpredictable_Atomic_SERROR</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_Atomic_NOP" title="">Unpredictable_Atomic_NOP</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_Atomic_MMU_IMPDEF_FAULT" title="">Unpredictable_Atomic_MMU_IMPDEF_FAULT</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_MPAM_TRUNCATE_VID" title="">Unpredictable_MPAM_TRUNCATE_VID</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_USE_DEFAULT_PMG" title="">Unpredictable_USE_DEFAULT_PMG</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_BankedRegister" title="">Unpredictable_BankedRegister</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a>;
        when <a href="shared_pseudocode.html#enum_Unpredictable_UnimplementedRegister" title="">Unpredictable_UnimplementedRegister</a> =&gt;
            return <a href="shared_pseudocode.html#enum_Constraint_NOP" title="">Constraint_NOP</a>;
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictableBits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictableBits</h3>
      <p class="pseudocode">// ConstrainUnpredictableBits()
// ============================

// This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN.
// If the result is Constraint_UNKNOWN then the function also returns UNKNOWN value, but that
// value is always an allocated value; that is, one for which the behavior is not itself
// CONSTRAINED.

readonly impdef func <a id="func_ConstrainUnpredictableBits_0"/>ConstrainUnpredictableBits{width}(which : <a href="shared_pseudocode.html#type_Unpredictable" title="">Unpredictable</a>
                                                      ) =&gt; (<a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>, bits(width))
begin
    let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(which);

    case c of
        when <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a> =&gt;
            return (c, Zeros{width});     // See notes; this is an example implementation only
        when <a href="shared_pseudocode.html#enum_Constraint_PMSCR_PCT_VIRT" title="">Constraint_PMSCR_PCT_VIRT</a> =&gt;
            return (c, Zeros{width});
        when <a href="shared_pseudocode.html#enum_Constraint_EL1TIMESTAMP" title="">Constraint_EL1TIMESTAMP</a> =&gt;
            return (c, ZeroExtend{width}('01'));
        when <a href="shared_pseudocode.html#enum_Constraint_EL2TIMESTAMP" title="">Constraint_EL2TIMESTAMP</a> =&gt;
            return (c, ZeroExtend{width}('01'));
        when <a href="shared_pseudocode.html#enum_Constraint_MAPTOALLOCATED" title="">Constraint_MAPTOALLOCATED</a> =&gt;
            return (c, ZeroExtend{width}('010'));  // return non-secure state_bits
        otherwise =&gt;
            return (c, ARBITRARY : bits(width));   // bits result not used
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictableBool"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictableBool</h3>
      <p class="pseudocode">// ConstrainUnpredictableBool()
// ============================
// This is a variant of the ConstrainUnpredictable function where the result is either
// Constraint_TRUE or Constraint_FALSE.

impdef func <a id="func_ConstrainUnpredictableBool_1"/>ConstrainUnpredictableBool(which : <a href="shared_pseudocode.html#type_Unpredictable" title="">Unpredictable</a>) =&gt; boolean
begin
    let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(which);
    assert c IN {<a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>, <a href="shared_pseudocode.html#enum_Constraint_FALSE" title="">Constraint_FALSE</a>};
    return (c == <a href="shared_pseudocode.html#enum_Constraint_TRUE" title="">Constraint_TRUE</a>);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictableInteger"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictableInteger</h3>
      <p class="pseudocode">// ConstrainUnpredictableInteger()
// ===============================
// This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN.
// If the result is Constraint_UNKNOWN then the function also returns an UNKNOWN
// value in the range low to high, inclusive.

impdef func <a id="func_ConstrainUnpredictableInteger_3"/>ConstrainUnpredictableInteger(low : integer,
                                          high : integer,
                                          which : <a href="shared_pseudocode.html#type_Unpredictable" title="">Unpredictable</a>) =&gt; (<a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>,integer)
begin
    let c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a> = ConstrainUnpredictable(which);
    if c == <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a> then
        return (c, low);                 // See notes; this is an example implementation only
    else
        return (c, ARBITRARY : integer); // integer result not used
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictableProcedure"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictableProcedure</h3>
      <p class="pseudocode">// ConstrainUnpredictableProcedure()
// =================================
// This is a variant of ConstrainUnpredictable that implements a Constrained
// Unpredictable behavior for a given Unpredictable situation.
// The behavior is within permitted behaviors for a given Unpredictable situation,
// these are documented in the textual part of the architecture specification.
//
// This function is expected to be refined in an IMPLEMENTATION DEFINED manner.
// The details of possible outcomes may not be present in the code and must be interpreted
// for each use with respect to the CONSTRAINED UNPREDICTABLE specifications
// for the specific area.

impdef func ConstrainUnpredictableProcedure(which : <a href="shared_pseudocode.html#type_Unpredictable" title="">Unpredictable</a>)
begin
    case which of
        when <a href="shared_pseudocode.html#enum_Unpredictable_PMUEVENTCOUNTER" title="">Unpredictable_PMUEVENTCOUNTER</a> =&gt;
            Undefined();
        when <a href="shared_pseudocode.html#enum_Unpredictable_MRC_APSR_TARGET" title="">Unpredictable_MRC_APSR_TARGET</a> =&gt;
            PSTATE.[N,Z,C,V] = DBGDSCRint()[31:28];
        otherwise =&gt;
            ImpDef("IMPLEMENTATION_DEFINED");
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.Constraint"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/Constraint</h3>
      <p class="pseudocode">// Constraint
// ==========
// List of Constrained Unpredictable behaviors.

type <a id="type_Constraint"/>Constraint of enumeration {
                           // General
                           <a id="enum_Constraint_NONE"/>Constraint_NONE,              // Instruction executes with
                                                         // no change or side-effect
                                                         // to its described behavior
                           <a id="enum_Constraint_UNKNOWN"/>Constraint_UNKNOWN,           // Destination register
                                                         // has UNKNOWN value
                           <a id="enum_Constraint_UNDEF"/>Constraint_UNDEF,             // Instruction is UNDEFINED
                           <a id="enum_Constraint_UNDEFEL0"/>Constraint_UNDEFEL0,          // Instruction is UNDEFINED at EL0 only
                           <a id="enum_Constraint_NOP"/>Constraint_NOP,               // Instruction executes as NOP
                           <a id="enum_Constraint_TRUE"/>Constraint_TRUE,
                           <a id="enum_Constraint_FALSE"/>Constraint_FALSE,
                           <a id="enum_Constraint_DISABLED"/>Constraint_DISABLED,
                           <a id="enum_Constraint_UNCOND"/>Constraint_UNCOND,            // Instruction executes unconditionally
                           <a id="enum_Constraint_COND"/>Constraint_COND,              // Instruction executes conditionally
                           <a id="enum_Constraint_ADDITIONAL_DECODE"/>Constraint_ADDITIONAL_DECODE, // Instruction executes
                                                         // with additional decode
                           // Load-store
                           <a id="enum_Constraint_WBSUPPRESS"/>Constraint_WBSUPPRESS,
                           <a id="enum_Constraint_FAULT"/>Constraint_FAULT,
                           <a id="enum_Constraint_LIMITED_ATOMICITY"/>Constraint_LIMITED_ATOMICITY, // Accesses are not
                                                         // single-copy atomic
                                                         // above the byte level
                           <a id="enum_Constraint_NVNV1_00"/>Constraint_NVNV1_00,
                           <a id="enum_Constraint_NVNV1_01"/>Constraint_NVNV1_01,
                           <a id="enum_Constraint_NVNV1_11"/>Constraint_NVNV1_11,
                           <a id="enum_Constraint_EL1TIMESTAMP"/>Constraint_EL1TIMESTAMP,      // Constrain to Virtual Timestamp
                           <a id="enum_Constraint_EL2TIMESTAMP"/>Constraint_EL2TIMESTAMP,      // Constrain to Virtual Timestamp
                           <a id="enum_Constraint_OSH"/>Constraint_OSH,               // Constrain to Outer Shareable
                           <a id="enum_Constraint_ISH"/>Constraint_ISH,               // Constrain to Inner Shareable
                           <a id="enum_Constraint_NSH"/>Constraint_NSH,               // Constrain to Nonshareable

                           <a id="enum_Constraint_NC"/>Constraint_NC,                // Constrain to Noncacheable
                           <a id="enum_Constraint_WT"/>Constraint_WT,                // Constrain to Writethrough
                           <a id="enum_Constraint_WB"/>Constraint_WB,                // Constrain to Writeback
                           <a id="enum_Constraint_RESS"/>Constraint_RESS,              // Bits behave as RESS for all purposes
                                                         // other than reading back the register
                           <a id="enum_Constraint_ALLRESS"/>Constraint_ALLRESS,           // Bits behave as RESS for all purposes

                           // IPA too large
                           <a id="enum_Constraint_FORCE"/>Constraint_FORCE, <a id="enum_Constraint_FORCENOSLCHECK"/>Constraint_FORCENOSLCHECK,
                           // An unallocated System register value maps onto an allocated value
                           <a id="enum_Constraint_MAPTOALLOCATED"/>Constraint_MAPTOALLOCATED,
                           // PMSCR_PCT reserved values select Virtual timestamp
                           <a id="enum_Constraint_PMSCR_PCT_VIRT"/>Constraint_PMSCR_PCT_VIRT,
                           <a id="enum_Constraint_ANYREG"/>Constraint_ANYREG,            // Any allocated register is chosen
};</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.Unpredictable"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/Unpredictable</h3>
      <p class="pseudocode">// Unpredictable
// =============
// List of Constrained Unpredictable situations.

type <a id="type_Unpredictable"/>Unpredictable of enumeration {
                           // VMSR on MVFR
                           <a id="enum_Unpredictable_VMSR"/>Unpredictable_VMSR,
                           // Writeback/transfer register overlap (load)
                           <a id="enum_Unpredictable_WBOVERLAPLD"/>Unpredictable_WBOVERLAPLD,
                           // Writeback/transfer register overlap (store)
                           <a id="enum_Unpredictable_WBOVERLAPST"/>Unpredictable_WBOVERLAPST,
                           // Load Pair transfer register overlap
                           <a id="enum_Unpredictable_LDPOVERLAP"/>Unpredictable_LDPOVERLAP,
                           // Store-exclusive base/status register overlap
                           <a id="enum_Unpredictable_BASEOVERLAP"/>Unpredictable_BASEOVERLAP,
                           // Store-exclusive data/status register overlap
                           <a id="enum_Unpredictable_DATAOVERLAP"/>Unpredictable_DATAOVERLAP,
                           // Load-store alignment checks
                           <a id="enum_Unpredictable_DEVPAGE2"/>Unpredictable_DEVPAGE2,
                           // Instruction fetch from Device memory
                           <a id="enum_Unpredictable_INSTRDEVICE"/>Unpredictable_INSTRDEVICE,
                           // Reserved CPACR value
                           <a id="enum_Unpredictable_RESCPACR"/>Unpredictable_RESCPACR,
                           // Reserved MAIR value
                           <a id="enum_Unpredictable_RESMAIR"/>Unpredictable_RESMAIR,
                           // Effect of SCTLR_ELx.C on Tagged attribute
                           <a id="enum_Unpredictable_S1CTAGGED"/>Unpredictable_S1CTAGGED,
                           // Reserved Stage 2 MemAttr value
                           <a id="enum_Unpredictable_S2RESMEMATTR"/>Unpredictable_S2RESMEMATTR,
                           // Reserved TEX:C:B value
                           <a id="enum_Unpredictable_RESTEXCB"/>Unpredictable_RESTEXCB,
                           // Reserved PRRR value
                           <a id="enum_Unpredictable_RESPRRR"/>Unpredictable_RESPRRR,
                           // Reserved DACR field
                           <a id="enum_Unpredictable_RESDACR"/>Unpredictable_RESDACR,
                           // Reserved VTCR.S value
                           <a id="enum_Unpredictable_RESVTCRS"/>Unpredictable_RESVTCRS,
                           // Reserved TCR.TnSZ value
                           <a id="enum_Unpredictable_RESTnSZ"/>Unpredictable_RESTnSZ,
                           // Reserved SCTLR_ELx.TCF value
                           <a id="enum_Unpredictable_RESTCF"/>Unpredictable_RESTCF,
                           // Tag stored to Device memory
                           <a id="enum_Unpredictable_DEVICETAGSTORE"/>Unpredictable_DEVICETAGSTORE,
                           // Out-of-range TCR.TnSZ value
                           <a id="enum_Unpredictable_OORTnSZ"/>Unpredictable_OORTnSZ,

                           // IPA size exceeds PA size
                           <a id="enum_Unpredictable_LARGEIPA"/>Unpredictable_LARGEIPA,
                           // Syndrome for a known-passing conditional A32 instruction
                           <a id="enum_Unpredictable_ESRCONDPASS"/>Unpredictable_ESRCONDPASS,
                           // Illegal State exception: zero PSTATE.IT
                           <a id="enum_Unpredictable_ILZEROIT"/>Unpredictable_ILZEROIT,
                           // Illegal State exception: zero PSTATE.T
                           <a id="enum_Unpredictable_ILZEROT"/>Unpredictable_ILZEROT,
                           // Debug: prioritization of Vector Catch
                           <a id="enum_Unpredictable_BPVECTORCATCHPRI"/>Unpredictable_BPVECTORCATCHPRI,
                           // Debug Vector Catch: match on 2nd halfword
                           <a id="enum_Unpredictable_VCMATCHHALF"/>Unpredictable_VCMATCHHALF,
                           // Debug Vector Catch: match on Data Abort
                           // or Prefetch abort
                           <a id="enum_Unpredictable_VCMATCHDAPA"/>Unpredictable_VCMATCHDAPA,
                           // Debug watchpoints: nonzero MASK and non-ones BAS
                           <a id="enum_Unpredictable_WPMASKANDBAS"/>Unpredictable_WPMASKANDBAS,
                           // Debug watchpoints: non-contiguous BAS
                           <a id="enum_Unpredictable_WPBASCONTIGUOUS"/>Unpredictable_WPBASCONTIGUOUS,
                           // Debug watchpoints: reserved MASK
                           <a id="enum_Unpredictable_RESWPMASK"/>Unpredictable_RESWPMASK,
                           // Debug watchpoints: nonzero MASKed bits of address
                           <a id="enum_Unpredictable_WPMASKEDBITS"/>Unpredictable_WPMASKEDBITS,
                           // Debug breakpoints and watchpoints: reserved control bits
                           <a id="enum_Unpredictable_RESBPWPCTRL"/>Unpredictable_RESBPWPCTRL,
                           // Debug breakpoints: not implemented
                           <a id="enum_Unpredictable_BPNOTIMPL"/>Unpredictable_BPNOTIMPL,
                           // Debug breakpoints: reserved type
                           <a id="enum_Unpredictable_RESBPTYPE"/>Unpredictable_RESBPTYPE,
                           // Debug breakpoints and watchpoints: reserved MDSELR_EL1.BANK
                           <a id="enum_Unpredictable_RESMDSELR"/>Unpredictable_RESMDSELR,
                           // Debug breakpoints: not-context-aware breakpoint
                           <a id="enum_Unpredictable_BPNOTCTXCMP"/>Unpredictable_BPNOTCTXCMP,
                           // Debug breakpoints: match on 2nd halfword of instruction
                           <a id="enum_Unpredictable_BPMATCHHALF"/>Unpredictable_BPMATCHHALF,
                           // Debug breakpoints: mismatch on 2nd halfword of instruction
                           <a id="enum_Unpredictable_BPMISMATCHHALF"/>Unpredictable_BPMISMATCHHALF,
                           // Debug breakpoints: a breakpoint is linked to that is not
                           // programmed with linking enabled
                           <a id="enum_Unpredictable_BPLINKINGDISABLED"/>Unpredictable_BPLINKINGDISABLED,
                           // Debug breakpoints: reserved MASK
                           <a id="enum_Unpredictable_RESBPMASK"/>Unpredictable_RESBPMASK,
                           // Debug breakpoints: MASK is set for a Context matching
                           // breakpoint or when DBGBCR_EL1[n].BAS != '1111'
                           <a id="enum_Unpredictable_BPMASK"/>Unpredictable_BPMASK,
                           // Debug breakpoints: nonzero MASKed bits of address
                           <a id="enum_Unpredictable_BPMASKEDBITS"/>Unpredictable_BPMASKEDBITS,
                           // Debug breakpoints: A linked breakpoint is
                           // linked to an address matching breakpoint
                           <a id="enum_Unpredictable_BPLINKEDADDRMATCH"/>Unpredictable_BPLINKEDADDRMATCH,
                           // Debug: restart to a misaligned AArch32 PC value
                           <a id="enum_Unpredictable_RESTARTALIGNPC"/>Unpredictable_RESTARTALIGNPC,
                           // Debug: restart to a not-zero-extended AArch32 PC value
                           <a id="enum_Unpredictable_RESTARTZEROUPPERPC"/>Unpredictable_RESTARTZEROUPPERPC,
                           // Zero top 32 bits of X registers in AArch32 state
                           <a id="enum_Unpredictable_ZEROUPPER"/>Unpredictable_ZEROUPPER,
                           // Zero top 32 bits of PC on illegal return to
                           // AArch32 state
                           <a id="enum_Unpredictable_ERETZEROUPPERPC"/>Unpredictable_ERETZEROUPPERPC,
                           // Force address to be aligned when interworking
                           // branch to A32 state
                           <a id="enum_Unpredictable_A32FORCEALIGNPC"/>Unpredictable_A32FORCEALIGNPC,
                           // SMC disabled
                           <a id="enum_Unpredictable_SMD"/>Unpredictable_SMD,
                           // FF speculation
                           <a id="enum_Unpredictable_NONFAULT"/>Unpredictable_NONFAULT,
                           // Zero top bits of Z registers in EL change
                           <a id="enum_Unpredictable_SVEZEROUPPER"/>Unpredictable_SVEZEROUPPER,
                           // Load mem data in NF loads
                           <a id="enum_Unpredictable_SVELDNFDATA"/>Unpredictable_SVELDNFDATA,
                           // Write zeros in NF loads
                           <a id="enum_Unpredictable_SVELDNFZERO"/>Unpredictable_SVELDNFZERO,
                           // SP alignment fault when predicate is all zero
                           <a id="enum_Unpredictable_CHECKSPNONEACTIVE"/>Unpredictable_CHECKSPNONEACTIVE,
                           // Zero top bits of ZA registers in EL change
                           <a id="enum_Unpredictable_SMEZEROUPPER"/>Unpredictable_SMEZEROUPPER,
                           // Watchpoint match of last rounded up memory access in case of
                           // 16 byte rounding
                           <a id="enum_Unpredictable_16BYTEROUNDEDUPACCESS"/>Unpredictable_16BYTEROUNDEDUPACCESS,
                           // Watchpoint match of first rounded down memory access in case of
                           // 16 byte rounding
                           <a id="enum_Unpredictable_16BYTEROUNDEDDOWNACCESS"/>Unpredictable_16BYTEROUNDEDDOWNACCESS,
                           // HCR_EL2().[NV,NV1] == '01'
                           <a id="enum_Unpredictable_NVNV1"/>Unpredictable_NVNV1,
                           // Upper bits of a BADDR are not RESS
                           <a id="enum_Unpredictable_BADDR_RESS"/>Unpredictable_BADDR_RESS,
                           // Reserved shareability encoding
                           <a id="enum_Unpredictable_Shareability"/>Unpredictable_Shareability,
                           // Access Flag Update by HW
                           <a id="enum_Unpredictable_AFUPDATE"/>Unpredictable_AFUPDATE,
                           // Dirty Bit State Update by HW
                           <a id="enum_Unpredictable_DBUPDATE"/>Unpredictable_DBUPDATE,
                           // Consider SCTLR_ELx[].IESB in Debug state
                           <a id="enum_Unpredictable_IESBinDebug"/>Unpredictable_IESBinDebug,
                           // Bad settings for PMSFCR_EL1/PMSEVFR_EL1/PMSLATFR_EL1
                           <a id="enum_Unpredictable_BADPMSFCR"/>Unpredictable_BADPMSFCR,
                           // Zero saved BType value in SPSR_ELx/DPSR_EL0
                           <a id="enum_Unpredictable_ZEROBTYPE"/>Unpredictable_ZEROBTYPE,
                           // Timestamp constrained to virtual or physical
                           <a id="enum_Unpredictable_EL2TIMESTAMP"/>Unpredictable_EL2TIMESTAMP,
                           <a id="enum_Unpredictable_EL1TIMESTAMP"/>Unpredictable_EL1TIMESTAMP,
                            // Reserved MDCR_EL3().[NSTBE,NSTB] or MDCR_EL3().[NSPBE,NSPB] value
                            <a id="enum_Unpredictable_RESERVEDNSxB"/>Unpredictable_RESERVEDNSxB,
                            <a id="enum_Unpredictable_RESERVEDNSxB_Trap"/>Unpredictable_RESERVEDNSxB_Trap,
                           // WFET or WFIT instruction in Debug state
                           <a id="enum_Unpredictable_WFxTDEBUG"/>Unpredictable_WFxTDEBUG,
                           // Address does not support LS64 instructions
                           <a id="enum_Unpredictable_LS64UNSUPPORTED"/>Unpredictable_LS64UNSUPPORTED,
                           // Unaligned exclusives, atomics, acquire/release
                           // to a region that is not to Normal inner write-back
                           // outer write-back shareable generate an Alignment fault.
                           <a id="enum_Unpredictable_LSE2_ALIGNMENT_FAULT"/>Unpredictable_LSE2_ALIGNMENT_FAULT,
                           // 128-bit Atomic or 128-bit RCW{S} transfer register overlap
                           <a id="enum_Unpredictable_LSE128OVERLAP"/>Unpredictable_LSE128OVERLAP,
                           // Clearing DCC/ITR sticky flags when instruction is in flight
                           <a id="enum_Unpredictable_CLEARERRITEZERO"/>Unpredictable_CLEARERRITEZERO,
                           // ALUEXCEPTIONRETURN when in user/system mode in
                           // A32 instructions
                           <a id="enum_Unpredictable_ALUEXCEPTIONRETURN"/>Unpredictable_ALUEXCEPTIONRETURN,
                           // Trap to register in debug state are ignored
                           <a id="enum_Unpredictable_IGNORETRAPINDEBUG"/>Unpredictable_IGNORETRAPINDEBUG,
                           // Compare DBGBVR.RESS for BP/WP
                           <a id="enum_Unpredictable_DBGxVR_RESS"/>Unpredictable_DBGxVR_RESS,
                           // Inaccessible event counter
                           <a id="enum_Unpredictable_PMUEVENTCOUNTER"/>Unpredictable_PMUEVENTCOUNTER,
                           // Reserved PMSCR.PCT behavior
                           <a id="enum_Unpredictable_PMSCR_PCT"/>Unpredictable_PMSCR_PCT,
                           // MDCR_EL2.HPMN or HDCR.HPMN is larger than PMCR.N or
                           // FEAT_HPMN0 is not implemented and HPMN is 0.
                           <a id="enum_Unpredictable_RES_HPMN"/>Unpredictable_RES_HPMN,
                           // Chained PMU counters idx and idx+1 are not in same range
                           <a id="enum_Unpredictable_COUNT_CHAIN"/>Unpredictable_COUNT_CHAIN,
                           // PMCCR.EPMN is larger than PMCR.N
                           <a id="enum_Unpredictable_RES_EPMN"/>Unpredictable_RES_EPMN,
                           // Generate BRB_FILTRATE event on BRB injection
                           <a id="enum_Unpredictable_BRBFILTRATE"/>Unpredictable_BRBFILTRATE,
                           // Generate PMU_SNAPSHOT event in Debug state
                           <a id="enum_Unpredictable_PMUSNAPSHOTEVENT"/>Unpredictable_PMUSNAPSHOTEVENT,
                           // Reserved MDCR_EL3.EPMSSAD value
                           <a id="enum_Unpredictable_RESEPMSSAD"/>Unpredictable_RESEPMSSAD,
                           // Reserved PMECR_EL1.SSE value
                           <a id="enum_Unpredictable_RESPMSSE"/>Unpredictable_RESPMSSE,
                           // Enable for PMU Profiling exception and PMUIRQ
                           <a id="enum_Unpredictable_RESPMEE"/>Unpredictable_RESPMEE,
                           // Enables for SPE Profiling exceptions and PMSIRQ
                           <a id="enum_Unpredictable_RESPMSEE"/>Unpredictable_RESPMSEE,
                           // Enables for TRBE Profiling exceptions and PMSIRQ
                           <a id="enum_Unpredictable_RESTRFEE"/>Unpredictable_RESTRFEE,
                           // Operands for CPY*/SET* instructions overlap
                           <a id="enum_Unpredictable_MOPSOVERLAP"/>Unpredictable_MOPSOVERLAP,
                           // Operands for CPY*/SET* instructions use 0b11111
                           // as a register specifier
                           <a id="enum_Unpredictable_MOPS_R31"/>Unpredictable_MOPS_R31,
                           // Chooses which value to return in a non failed Atomic Compare and Swap
                           <a id="enum_Unpredictable_CASRETURNOLDVALUE"/>Unpredictable_CASRETURNOLDVALUE,
                           // Enables write of the newvalue in a failed Atomic Compare and Swap
                           <a id="enum_Unpredictable_WRITEFAILEDCAS"/>Unpredictable_WRITEFAILEDCAS,
                           // Store-only Tag checking on a failed Atomic Compare and Swap
                           <a id="enum_Unpredictable_STRONLYTAGCHECKEDCAS"/>Unpredictable_STRONLYTAGCHECKEDCAS,
                           // Store-only Tag checking on a failed RCW(S) checks
                           // or RCW(S) Atomic Compare and Swap
                           <a id="enum_Unpredictable_STRONLYTAGCHECKEDRCWSCAS"/>Unpredictable_STRONLYTAGCHECKEDRCWSCAS,
                           // Reserved MDCR_EL3.ETBAD value
                           <a id="enum_Unpredictable_RES_ETBAD"/>Unpredictable_RES_ETBAD,
                           // Invalid Streaming Mode filter bits
                           <a id="enum_Unpredictable_RES_PMU_VS"/>Unpredictable_RES_PMU_VS,
                           // Apply Checked Pointer Arithmetic on a sequential access to bytes
                           // that cross the 0xXXFF_FFFF_FFFF_FFFF boundary.
                           <a id="enum_Unpredictable_CPACHECK"/>Unpredictable_CPACHECK,
                           // Reserved PMEVTYPER_EL0(n).[TC,TE,TC2] values
                           <a id="enum_Unpredictable_RESTC"/>Unpredictable_RESTC,
                           // When FEAT_MTE is implemented, if Memory access mode is enabled
                           // and PSTATE.TCO is 0,  Reads and writes to the external debug
                           // interface DTR registers are CONSTRAINED UNPREDICTABLE for tagcheck
                           <a id="enum_Unpredictable_NODTRTAGCHK"/>Unpredictable_NODTRTAGCHK,
                           // Use the default PMG when the default PARTID is generated
                           // due to MPAM error
                           <a id="enum_Unpredictable_USE_DEFAULT_PMG"/>Unpredictable_USE_DEFAULT_PMG,
                           // If the atomic instructions are not atomic in regard to other
                           // agents that access memory, then the instruction can have one or
                           // more of the following effects
                           <a id="enum_Unpredictable_Atomic_SYNC_ABORT"/>Unpredictable_Atomic_SYNC_ABORT,
                           <a id="enum_Unpredictable_Atomic_SERROR"/>Unpredictable_Atomic_SERROR,
                           <a id="enum_Unpredictable_Atomic_NOP"/>Unpredictable_Atomic_NOP,
                           <a id="enum_Unpredictable_Atomic_MMU_IMPDEF_FAULT"/>Unpredictable_Atomic_MMU_IMPDEF_FAULT,
                           // Truncate virtual identifier to bottom 12 bits if it exceeds 2^12
                           <a id="enum_Unpredictable_MPAM_TRUNCATE_VID"/>Unpredictable_MPAM_TRUNCATE_VID,
                           // Accessing DBGDSCRint via MRC in debug state
                           <a id="enum_Unpredictable_MRC_APSR_TARGET"/>Unpredictable_MRC_APSR_TARGET,
                           // Accessing Banked register not accessible from the PE mode
                           <a id="enum_Unpredictable_BankedRegister"/>Unpredictable_BankedRegister,
                           // Accessing unimplemented Banked register
                           <a id="enum_Unpredictable_UnimplementedRegister"/>Unpredictable_UnimplementedRegister,
};</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.AdvSIMDExpandImm"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/AdvSIMDExpandImm</h3>
      <p class="pseudocode">// AdvSIMDExpandImm()
// ==================

func <a id="func_AdvSIMDExpandImm_3"/>AdvSIMDExpandImm(op : bit, cmode : bits(4), imm8 : bits(8)) =&gt; bits(64)
begin
    var imm64 : bits(64);
    case cmode[3:1] of
        when '000' =&gt;
            imm64 = Replicate{64}(Zeros{24}::imm8);
        when '001' =&gt;
            imm64 = Replicate{64}(Zeros{16}::imm8::Zeros{8});
        when '010' =&gt;
            imm64 = Replicate{64}(Zeros{8}::imm8::Zeros{16});
        when '011' =&gt;
            imm64 = Replicate{64}(imm8::Zeros{24});
        when '100' =&gt;
            imm64 = Replicate{64}(Zeros{8}::imm8);
        when '101' =&gt;
            imm64 = Replicate{64}(imm8::Zeros{8});
        when '110' =&gt;
            if cmode[0] == '0' then
                imm64 = Replicate{64}(Zeros{16}::imm8::Ones{8});
            else
                imm64 = Replicate{64}(Zeros{8}::imm8::Ones{16});
            end;
        when '111' =&gt;
            if cmode[0] == '0' &amp;&amp; op == '0' then
                imm64 = Replicate{64}(imm8);
            end;
            if cmode[0] == '0' &amp;&amp; op == '1' then
                let imm8a : bits(8) = Replicate{}(imm8[7]);
                let imm8b : bits(8) = Replicate{}(imm8[6]);
                let imm8c : bits(8) = Replicate{}(imm8[5]);
                let imm8d : bits(8) = Replicate{}(imm8[4]);
                let imm8e : bits(8) = Replicate{}(imm8[3]);
                let imm8f : bits(8) = Replicate{}(imm8[2]);
                let imm8g : bits(8) = Replicate{}(imm8[1]);
                let imm8h : bits(8) = Replicate{}(imm8[0]);
                imm64 = imm8a::imm8b::imm8c::imm8d::imm8e::imm8f::imm8g::imm8h;
            end;
            if cmode[0] == '1' &amp;&amp; op == '0' then
                let imm32 : bits(32) = (imm8[7]::NOT(imm8[6])::Replicate{5}(imm8[6])::
                                            imm8[5:0]::Zeros{19});
                imm64 = Replicate{64}(imm32);
            end;
            if cmode[0] == '1' &amp;&amp; op == '1' then
                if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then ReservedEncoding(); end;
                imm64 = imm8[7]::NOT(imm8[6])::Replicate{8}(imm8[6])::imm8[5:0]::Zeros{48};
            end;
    end;

    return imm64;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.MatMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/MatMulAdd</h3>
      <p class="pseudocode">// MatMulAdd()
// ===========
//
// Signed or unsigned 8-bit integer matrix multiply and add to 32-bit integer matrix
// result[2, 2] = addend[2, 2] + (op1[2, 8] * op2[8, 2])

func <a id="func_MatMulAdd_5"/>MatMulAdd(addend : bits(128), op1 : bits(128), op2 : bits(128), op1_unsigned : boolean,
             op2_unsigned : boolean) =&gt; bits(128)
begin

    var result : bits(128);
    var sum : bits(32);
    var prod : integer;

    for i = 0 to 1 do
        for j = 0 to 1 do
            sum = addend[(2*i + j)*:32];
            for k = 0 to 7 do
                let opelt1 : bits(8) = op1[(8*i + k)*:8];
                let opelt2 : bits(8) = op2[(8*j + k)*:8];
                let element1 : integer = if op1_unsigned then UInt(opelt1) else SInt(opelt1);
                let element2 : integer = if op2_unsigned then UInt(opelt2) else SInt(opelt2);
                prod = element1 * element2;
                sum  = sum + prod;
            end;
            result[(2*i + j)*:32] = sum;
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.PolynomialMult"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/PolynomialMult</h3>
      <p class="pseudocode">// PolynomialMult()
// ================

func <a id="func_PolynomialMult_4"/>PolynomialMult{M, N}(op1 : bits(M), op2 : bits(N)) =&gt; bits(M+N)
begin
    var result : bits(N + M) = Zeros{M+N};
    let extended_op2 : bits(N + M) = ZeroExtend{M+N}(op2);
    for i=0 to M-1 do
        if op1[i] == '1' then
            result = result XOR LSL(extended_op2, i);
        end;
    end;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.SatQ"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/SatQ</h3>
      <p class="pseudocode">// SatQ()
// ======

func <a id="func_SatQ_3"/>SatQ{N}(i : integer, unsigned : boolean) =&gt; (bits(N), boolean)
begin
    let (result, sat) : (bits(N), boolean) = (if unsigned then <a href="shared_pseudocode.html#func_UnsignedSatQ_2" title="">UnsignedSatQ</a>{N}(i)
                                                          else <a href="shared_pseudocode.html#func_SignedSatQ_2" title="">SignedSatQ</a>{N}(i));
    return (result, sat);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.ShiftSat"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/ShiftSat</h3>
      <p class="pseudocode">// ShiftSat()
// ==========

func <a id="func_ShiftSat_2"/>ShiftSat(shift : integer, esize : integer) =&gt; integer
begin
    if shift &gt; esize+1 then return esize+1;
    elsif shift &lt; -(esize+1) then return -(esize+1); end;
    return shift;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.SignedSat"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/SignedSat</h3>
      <p class="pseudocode">// SignedSat()
// ===========

func <a id="func_SignedSat_2"/>SignedSat{N}(i : integer) =&gt; bits(N)
begin
    let (result, -) = <a href="shared_pseudocode.html#func_SignedSatQ_2" title="">SignedSatQ</a>{N}(i);
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.SignedSatQ"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/SignedSatQ</h3>
      <p class="pseudocode">// SignedSatQ()
// ============

func <a id="func_SignedSatQ_2"/>SignedSatQ{N}(i : integer) =&gt; (bits(N), boolean)
begin
    var result : integer;
    var saturated : boolean;
    if i &gt; 2^(N-1) - 1 then
        result = 2^(N-1) - 1;  saturated = TRUE;
    elsif i &lt; -(2^(N-1)) then
        result = -(2^(N-1));  saturated = TRUE;
    else
        result = i;  saturated = FALSE;
    end;
    return (result[N-1:0], saturated);
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.UnsignedRSqrtEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/UnsignedRSqrtEstimate</h3>
      <p class="pseudocode">// UnsignedRSqrtEstimate()
// =======================

func <a id="func_UnsignedRSqrtEstimate_2"/>UnsignedRSqrtEstimate{N}(operand : bits(N)) =&gt; bits(N)
begin
    assert N == 32;
    var result : bits(N);
    if operand[N-1:N-2] == '00' then  // Operands &lt;= 0x3FFFFFFF produce 0xFFFFFFFF
        result = Ones{N};
    else
        // input is in the range 0x40000000 .. 0xffffffff representing [0.25 .. 1.0)
        // estimate is in the range 256 .. 511 representing [1.0 .. 2.0)
        let increasedprecision : boolean = FALSE;
        let estimate : integer = <a href="shared_pseudocode.html#func_RecipSqrtEstimate_2" title="">RecipSqrtEstimate</a>(UInt(operand[31:23]), increasedprecision);
        // result is in the range 0x80000000 .. 0xff800000 representing [1.0 .. 2.0)
        result = estimate[8:0] :: Zeros{N-9};
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.UnsignedRecipEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/UnsignedRecipEstimate</h3>
      <p class="pseudocode">// UnsignedRecipEstimate()
// =======================

func <a id="func_UnsignedRecipEstimate_2"/>UnsignedRecipEstimate{N}(operand : bits(N)) =&gt; bits(N)
begin
    assert N == 32;
    var result : bits(N);
    if operand[N-1] == '0' then  // Operands &lt;= 0x7FFFFFFF produce 0xFFFFFFFF
        result = Ones{N};
    else
        // input is in the range 0x80000000 .. 0xffffffff representing [0.5 .. 1.0)

        // estimate is in the range 256 to 511 representing [1.0 .. 2.0)
        let increasedprecision : boolean = FALSE;
        let estimate : integer = <a href="shared_pseudocode.html#func_RecipEstimate_2" title="">RecipEstimate</a>(UInt(operand[31:23]), increasedprecision);

        // result is in the range 0x80000000 .. 0xff800000 representing [1.0 .. 2.0)
        result = estimate[8:0] :: Zeros{N-9};
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.UnsignedSat"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/UnsignedSat</h3>
      <p class="pseudocode">// UnsignedSat()
// =============

func <a id="func_UnsignedSat_2"/>UnsignedSat{N}(i : integer) =&gt; bits(N)
begin
    let (result, -) = <a href="shared_pseudocode.html#func_UnsignedSatQ_2" title="">UnsignedSatQ</a>{N}(i);
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.UnsignedSatQ"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/UnsignedSatQ</h3>
      <p class="pseudocode">// UnsignedSatQ()
// ==============

func <a id="func_UnsignedSatQ_2"/>UnsignedSatQ{N}(i : integer) =&gt; (bits(N), boolean)
begin
    var result : integer;
    var saturated : boolean;
    if i &gt; 2^N - 1 then
        result = 2^N - 1;  saturated = TRUE;
    elsif i &lt; 0 then
        result = 0;  saturated = TRUE;
    else
        result = i;  saturated = FALSE;
    end;
    return (result[N-1:0], saturated);
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.Common.DebugMemWrite"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/Common/DebugMemWrite</h3>
      <p class="pseudocode">// DebugMemWrite()
// ===============
// Write data to memory one byte at a time. Starting at the passed virtual address.
// Used by SPE and TRBE.

func <a id="func_DebugMemWrite_4"/>DebugMemWrite(vaddress : bits(64), accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                   aligned : boolean, data : bits(8)) =&gt; (<a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>, <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>)
begin

    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a> = ARBITRARY : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;

    // Translate virtual address
    var addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
    let size : integer = 1;
    addrdesc = <a href="shared_pseudocode.html#func_AArch64_TranslateAddress_4" title="">AArch64_TranslateAddress</a>(vaddress, accdesc, aligned, size);

    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(addrdesc) then
        return (memstatus, addrdesc);
    end;

    memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{8}(addrdesc, accdesc, data);

    return (memstatus, addrdesc);
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.Common.DebugWriteExternalAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/Common/DebugWriteExternalAbort</h3>
      <p class="pseudocode">// DebugWriteExternalAbort()
// =========================
// Populate the syndrome register for an External abort caused by a call of DebugMemWrite().

func DebugWriteExternalAbort(memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>, addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                             start_vaddr : bits(64))
begin

    let iswrite : boolean = TRUE;

    var handle_as_SError : boolean = FALSE;
    case addrdesc.fault.accessdesc.acctype of
        when <a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a> =&gt;
            handle_as_SError = ImpDefBool("Report SPE ExtAbort as SError");
        when <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a> =&gt;
            handle_as_SError = ImpDefBool("Report TRBE ExtAbort as SError");
        otherwise =&gt;
            unreachable;
    end;

    let ttw_abort : boolean = addrdesc.fault.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_SyncExternalOnWalk" title="">Fault_SyncExternalOnWalk</a>,
                                                               <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a>};
    let statuscode : <a href="shared_pseudocode.html#type_Fault" title="">Fault</a> = (if ttw_abort then addrdesc.fault.statuscode
                                 else memstatus.statuscode);

    if statuscode IN {<a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a>, <a href="shared_pseudocode.html#enum_Fault_AsyncParity" title="">Fault_AsyncParity</a>} || handle_as_SError then
        // Report the abort as an SError
        var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_0" title="">NoFault</a>();
        let parity : boolean = statuscode IN {<a href="shared_pseudocode.html#enum_Fault_SyncParity" title="">Fault_SyncParity</a>, <a href="shared_pseudocode.html#enum_Fault_AsyncParity" title="">Fault_AsyncParity</a>,
                                                 <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a>};
        fault.statuscode = if parity then <a href="shared_pseudocode.html#enum_Fault_AsyncParity" title="">Fault_AsyncParity</a> else <a href="shared_pseudocode.html#enum_Fault_AsyncExternal" title="">Fault_AsyncExternal</a>;
        if IsFeatureImplemented(FEAT_RAS) then
            fault.merrorstate = memstatus.merrorstate;
        end;
        let extflag : bit = if ttw_abort then addrdesc.fault.extflag else memstatus.extflag;
        fault.extflag = extflag;
        fault.accessdesc.acctype = addrdesc.fault.accessdesc.acctype;
        PendSErrorInterrupt(fault);
        return;
    end;

    // Generate a buffer management event, modifying the existing syndrome.
    var handle_async : boolean = FALSE;
    var syndrome : bits(64);
    case addrdesc.fault.accessdesc.acctype of
        when <a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a> =&gt;
            handle_async = ImpDefBool("Report SPE ExtAbort asynchronously");
            assert !IsFeatureImplemented(FEAT_SPE_EXC);
            syndrome = PMBSR_EL1();
        when <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a> =&gt;
            handle_async = ImpDefBool("Report TRBE ExtAbort asynchronously");
            assert !IsFeatureImplemented(FEAT_TRBE_EXC);
            syndrome = TRBSR_EL1();
        otherwise =&gt;
            unreachable;
    end;

    var ec : bits(6);
    if (IsFeatureImplemented(FEAT_RME) &amp;&amp; addrdesc.fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> &amp;&amp;
          addrdesc.fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_Fail" title="">GPCF_Fail</a>) then
        ec = '011110';
    else
        ec = if addrdesc.fault.secondstage then '100101' else '100100';
    end;

    let mss2 : bits(24) = Zeros{};
    var mss : bits(16) = Zeros{};
    if handle_async then                // FSC bits
        mss[5:0] = '010001';
    else
        mss[5:0] = <a href="shared_pseudocode.html#func_EncodeLDFSC_2" title="">EncodeLDFSC</a>(statuscode, addrdesc.fault.level);
    end;

    // The following values are always updated in the syndrome register.
    if (addrdesc.fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a> &amp;&amp;
          (handle_async || start_vaddr != addrdesc.vaddress)) then
        syndrome[19] = '1';             // DL bit (SPE only)
    end;

    syndrome[18] = '1';                 // EA bit

    // The following values are not modified if a previous buffer management event
    // has not been handled. Note that in this simple sequential model, this test
    // will never fail.
    if syndrome[17] == '0' then         // Check previous 'S' bit.
        syndrome[55:32] = mss2;         // MSS2 bits
        syndrome[31:26] = ec;           // EC bits
        if addrdesc.fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a> then
            syndrome[22] = '1';         // IRQ bit (TRBE only)
        end;
        syndrome[17] = '1';             // S bit
        syndrome[15:0] = mss;           // MSS bits
    end;

    case addrdesc.fault.accessdesc.acctype of
        when <a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a> =&gt;
            PMBSR_EL1() = syndrome;
        when <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a> =&gt;
            TRBSR_EL1() = syndrome;
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.Common.DebugWriteFault"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/Common/DebugWriteFault</h3>
      <p class="pseudocode">// DebugWriteFault()
// =================
// Populate the syndrome register for a fault caused by a call of DebugMemWrite().

func DebugWriteFault(vaddress : bits(64), fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>)
begin
    var ec : bits(6);
    if (IsFeatureImplemented(FEAT_RME) &amp;&amp; fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> &amp;&amp;
          fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_Fail" title="">GPCF_Fail</a>) then
        ec = '011110';
    else
        ec = if fault.secondstage then '100101' else '100100';
    end;

    var mss2 : bits(24) = Zeros{};
    if fault.statuscode == <a href="shared_pseudocode.html#enum_Fault_Permission" title="">Fault_Permission</a> then
        mss2[8] = if fault.toplevel then '1' else '0';      // TopLevel bit
        mss2[7] = if fault.assuredonly then '1' else '0';   // AssuredOnly bit
        mss2[6] = if fault.overlay then '1' else '0';       // Overlay bit
        mss2[5] = if fault.dirtybit then '1' else '0';      // DirtyBit
    end;

    var mss : bits(16) = Zeros{};
    if !(IsFeatureImplemented(FEAT_RME) &amp;&amp; fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> &amp;&amp;
           fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_Fail" title="">GPCF_Fail</a>) then
        mss[5:0] = <a href="shared_pseudocode.html#func_EncodeLDFSC_2" title="">EncodeLDFSC</a>(fault.statuscode, fault.level);  // FSC bits
    end;

    // Generate a buffer management event, modifying the existing syndrome.
    var target_el : bits(2);
    var syndrome : bits(64);
    case fault.accessdesc.acctype of
        when <a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a> =&gt;
            target_el = <a href="shared_pseudocode.html#func_ReportSPEEvent_2" title="">ReportSPEEvent</a>(ec, mss[5:0]);
            syndrome = <a href="shared_pseudocode.html#accessor_PMBSR_EL_1" title="">PMBSR_EL</a>(target_el);
        when <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a> =&gt;
            target_el = <a href="shared_pseudocode.html#func_ReportTRBEEvent_2" title="">ReportTRBEEvent</a>(ec, mss[5:0]);
            syndrome = <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el);
        otherwise =&gt;
            unreachable;
    end;

    // The following values are not modified if a previous buffer management event
    // has not been handled. Note that in this simple sequential model, this test
    // will never fail.
    if syndrome[17] == '0' then         // Check previous 'S' bit.
        syndrome[55:32] = mss2;         // MSS2 bits
        syndrome[31:26] = ec;           // EC bits
        if fault.accessdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a> then
            syndrome[22] = '1';         // IRQ bit (TRBE only)
        end;
        syndrome[17] = '1';             // S bit
        syndrome[15:0] = mss;           // MSS bits
    end;

    // For SPE, PMBPTR_EL1 points to the address that generated the fault, and writing
    // to memory never started. Therefore, there isno data loss and DL is unchanged.

    case fault.accessdesc.acctype of
        when <a href="shared_pseudocode.html#enum_AccessType_SPE" title="">AccessType_SPE</a> =&gt;
            <a href="shared_pseudocode.html#accessor_PMBSR_EL_1" title="">PMBSR_EL</a>(target_el) = syndrome;

        when <a href="shared_pseudocode.html#enum_AccessType_TRBE" title="">AccessType_TRBE</a> =&gt;
            <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el) = syndrome;

        otherwise =&gt;
            unreachable;
    end;

    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.Common.GetTimestamp"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/Common/GetTimestamp</h3>
      <p class="pseudocode">// GetTimestamp()
// ==============
// Returns the Timestamp depending on the type

func <a id="func_GetTimestamp_1"/>GetTimestamp(timeStampType : <a href="shared_pseudocode.html#type_TimeStamp" title="">TimeStamp</a>) =&gt; bits(64)
begin
    case timeStampType of
        when <a href="shared_pseudocode.html#enum_TimeStamp_Physical" title="">TimeStamp_Physical</a> =&gt;
            return <a href="shared_pseudocode.html#func_PhysicalCountInt_0" title="">PhysicalCountInt</a>();
        when <a href="shared_pseudocode.html#enum_TimeStamp_Virtual" title="">TimeStamp_Virtual</a> =&gt;
            return <a href="shared_pseudocode.html#func_PhysicalCountInt_0" title="">PhysicalCountInt</a>() - CNTVOFF_EL2();
        when <a href="shared_pseudocode.html#enum_TimeStamp_OffsetPhysical" title="">TimeStamp_OffsetPhysical</a> =&gt;
            let physoff : bits(64) = if <a href="shared_pseudocode.html#func_PhysicalOffsetIsValid_0" title="">PhysicalOffsetIsValid</a>() then CNTPOFF_EL2() else Zeros{64};
            return <a href="shared_pseudocode.html#func_PhysicalCountInt_0" title="">PhysicalCountInt</a>() - physoff;
        when <a href="shared_pseudocode.html#enum_TimeStamp_None" title="">TimeStamp_None</a> =&gt;
            return Zeros{64};
        when <a href="shared_pseudocode.html#enum_TimeStamp_CoreSight" title="">TimeStamp_CoreSight</a> =&gt;
            return ImpDefBits{64}("CoreSight timestamp");
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.Common.PhysicalOffsetIsValid"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/Common/PhysicalOffsetIsValid</h3>
      <p class="pseudocode">// PhysicalOffsetIsValid()
// =======================
// Returns whether the Physical offset for the timestamp is valid

func <a id="func_PhysicalOffsetIsValid_0"/>PhysicalOffsetIsValid() =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then
        return FALSE;
    elsif !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) || !IsFeatureImplemented(FEAT_ECV_POFF) then
        return FALSE;
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>() == '1' &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveSCR_EL3_RW_0" title="">EffectiveSCR_EL3_RW</a>() == '0' then
        return FALSE;
    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().ECVEn == '0' then
        return FALSE;
    elsif CNTHCTL_EL2().ECV == '0' then
        return FALSE;
    else
        return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.Common.TRBCRManStopWrite"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/Common/TRBCRManStopWrite</h3>
      <p class="pseudocode">// TRBCRManStopWrite()
// ===================
// Called on a write of 1 to TRBCR.ManStop.

func TRBCRManStopWrite()
begin
    TraceUnitFlush();
    OtherTRBEManagementEvent('000011');
    TryAssertTRBIRQ();
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBranch.BranchNotTaken"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBranch/BranchNotTaken</h3>
      <p class="pseudocode">// BranchNotTaken()
// ================
// Called when a branch is not taken.

func BranchNotTaken(branchtype : <a href="shared_pseudocode.html#type_BranchType" title="">BranchType</a>, branch_conditional : boolean)
begin
    let branchtaken : boolean = FALSE;
    if IsFeatureImplemented(FEAT_SPE) then
        SPEBranch{64}(ARBITRARY : bits(64), branchtype, branch_conditional, branchtaken);
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.AllowExternalTraceBufferAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/AllowExternalTraceBufferAccess</h3>
      <p class="pseudocode">// AllowExternalTraceBufferAccess()
// ================================
// Returns TRUE if an external debug interface access to the Trace Buffer
// registers is allowed for the given Security state, FALSE otherwise.
// The access may also be subject to OS Lock, power-down, etc.

func <a id="func_AllowExternalTraceBufferAccess_1"/>AllowExternalTraceBufferAccess(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>) =&gt; boolean
begin
    assert IsFeatureImplemented(FEAT_TRBE_EXT);
    // FEAT_Debugv8p4 is always implemented when FEAT_TRBE_EXT is implemented.
    assert IsFeatureImplemented(FEAT_Debugv8p4);

    var etbad : bits(2) = if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then MDCR_EL3().ETBAD else '11';

    // Check for reserved values
    if !IsFeatureImplemented(FEAT_RME) &amp;&amp; etbad IN {'01','10'} then
        (-, etbad) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_RES_ETBAD" title="">Unpredictable_RES_ETBAD</a>);
        // The value returned by ConstrainUnpredictableBits must be a
        // non-reserved value
        assert etbad IN {'00', '11'};
    end;

    case etbad of
        when '00' =&gt;
            if IsFeatureImplemented(FEAT_RME) then
                return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>;
            else
                return addrdesc.paddress.paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
            end;
        when '01' =&gt;
            assert IsFeatureImplemented(FEAT_RME);
            return addrdesc.paddress.paspace IN {<a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>, <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>};
        when '10' =&gt;
            assert IsFeatureImplemented(FEAT_RME);
            return addrdesc.paddress.paspace IN {<a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>, <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>};
        when '11' =&gt;
            return TRUE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.CheckForTRBEException"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/CheckForTRBEException</h3>
      <p class="pseudocode">// CheckForTRBEException()
// =======================
// Take a TRBE Profiling exception if pending, permitted, and unmasked.

func CheckForTRBEException()
begin
    if !IsFeatureImplemented(FEAT_TRBE_EXC) || !<a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() then
        return;
    end;

    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() || <a href="shared_pseudocode.html#func_Restarting_0" title="">Restarting</a>() then
        return;
    end;

    var route_to_el3 : boolean = FALSE;
    var route_to_el2 : boolean = FALSE;
    var route_to_el1 : boolean = FALSE;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; MDCR_EL3().TRBEE == '1x' then
        let pending : boolean = TRBSR_EL3().IRQ == '1';
        let masked  : boolean = PSTATE.EL       == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
        route_to_el3 = pending &amp;&amp; !masked;
    end;

    var owning_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>;
    var owning_el : bits(2);
    (owning_ss, owning_el) = <a href="shared_pseudocode.html#func_TraceBufferOwner_0" title="">TraceBufferOwner</a>();
    let in_owning_ss : boolean = <a href="shared_pseudocode.html#func_IsCurrentSecurityState_1" title="">IsCurrentSecurityState</a>(owning_ss);

    if <a href="shared_pseudocode.html#func_EffectiveTRFCR_EL2_EE_0" title="">EffectiveTRFCR_EL2_EE</a>() IN {'1x'} then
        let pending : boolean = TRBSR_EL2().IRQ == '1';
        let masked : boolean = (!in_owning_ss || PSTATE.EL == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> ||
                                   (PSTATE.EL == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> &amp;&amp; (TRFCR_EL2().EE != '11' ||
                                                         TRFCR_EL2().KE == '0' ||
                                                         PSTATE.PM == '1')));
        route_to_el2 = pending &amp;&amp; !masked;
    end;

    if <a href="shared_pseudocode.html#func_EffectiveTRFCR_EL1_EE_0" title="">EffectiveTRFCR_EL1_EE</a>() == '11' then
        let pending : boolean = TRBSR_EL1().IRQ == '1';
        let masked  : boolean = (!in_owning_ss || PSTATE.EL IN {<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>} ||
                                   (PSTATE.EL == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp; (TRFCR_EL1().KE == '0' ||
                                                         PSTATE.PM == '1')));
        if <a href="shared_pseudocode.html#func_EffectiveTGE_0" title="">EffectiveTGE</a>() == '1' then
            route_to_el2 = route_to_el2 || (pending &amp;&amp; !masked);
        else
            route_to_el1 = pending &amp;&amp; !masked;
        end;
    end;

    let fsc : bits(5) = '00010';        // TRBE exception
    let synchronous : boolean = FALSE;

    // The relative priorities of the following checks is IMPLEMENTATION DEFINED
    if route_to_el3 then
        TakeProfilingException(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>, fsc, synchronous);
    end;
    if route_to_el2 then
        TakeProfilingException(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>, fsc, synchronous);
    end;
    if route_to_el1 then
        TakeProfilingException(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>, fsc, synchronous);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.CheckMDCR_EL3_NSTBTrap"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/CheckMDCR_EL3_NSTBTrap</h3>
      <p class="pseudocode">// CheckMDCR_EL3_NSTBTrap()
// ========================
// Check if the register access is trappable by MDCR_EL3.[NSTBE, NSTB]

func <a id="func_CheckMDCR_EL3_NSTBTrap_0"/>CheckMDCR_EL3_NSTBTrap() =&gt; boolean
begin
    var state_bits : bits(3);
    var reserved   : boolean;
    (state_bits, reserved) = <a href="shared_pseudocode.html#func_EffectiveMDCR_EL3_NSTB_0" title="">EffectiveMDCR_EL3_NSTB</a>();
    return ((reserved &amp;&amp; <a href="shared_pseudocode.html#func_ConstrainUnpredictableBool_1" title="">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#enum_Unpredictable_RESERVEDNSxB_Trap" title="">Unpredictable_RESERVEDNSxB_Trap</a>)) ||
             state_bits[0] == '0' || state_bits[1] != SCR_EL3().NS ||
             (IsFeatureImplemented(FEAT_RME) &amp;&amp; state_bits[2] != SCR_EL3().NSE));
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.CollectTrace"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/CollectTrace</h3>
      <p class="pseudocode">// CollectTrace()
// ==============
// Called for each byte generated by the trace unit.
// Returns TRUE if the Trace Buffer Unit accepts or discards the trace
// data, and FALSE if the Trace Buffer Unit rejects the trace data.

func <a id="func_CollectTrace_1"/>CollectTrace(datum : bits(8)) =&gt; boolean recurselimit ElementStreamSize
begin
    if !<a href="shared_pseudocode.html#func_TraceBufferEnabled_0" title="">TraceBufferEnabled</a>() then  // Trace buffer disabled
        // 'datum' is discarded
        if <a href="shared_pseudocode.html#func_HaveImpDefTraceOutput_0" title="">HaveImpDefTraceOutput</a>() then
            return <a href="shared_pseudocode.html#func_ImpDefTraceOutput_1" title="">ImpDefTraceOutput</a>(datum);
        else
            return TRUE;           // Discard the trace byte
        end;
    end;

    // If the TRBE cannot accept the trace data, it must return FALSE
    if <a href="shared_pseudocode.html#func_TRBEInternalBufferFull_0" title="">TRBEInternalBufferFull</a>() then
        return FALSE;
    end;

    if <a href="shared_pseudocode.html#func_TraceBufferRunning_0" title="">TraceBufferRunning</a>() then   // Accept the data
        let address            : bits(64) = TRBPTR_EL1();
        var ttw_abort          : boolean = FALSE;
        let ttw_abort_as_fault : boolean = (ImpDefBool(
                                            "Report TRBE ExtAbort on TTW as fault"));
        var addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
        var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;

        if !<a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() then
            // The Trace Buffer Unit is using External mode.
            if IsFeatureImplemented(FEAT_RME) &amp;&amp; !<a href="shared_pseudocode.html#func_ExternalRootInvasiveDebugEnabled_0" title="">ExternalRootInvasiveDebugEnabled</a>() then
                if IsZero(GPCCR_EL3().[TBGPCD, GPC]) then
                    return FALSE;
                end;
            end;

            let pas : bits(2) = TRBMAR_EL1().PAS;
            let paspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a> = <a href="shared_pseudocode.html#func_DecodePASpace_3" title="">DecodePASpace</a>('0', pas[1], pas[0]);
            var valid_config : boolean = <a href="shared_pseudocode.html#func_IsPASValid_1" title="">IsPASValid</a>(pas) &amp;&amp; <a href="shared_pseudocode.html#func_InvasiveDebugPermittedPAS_1" title="">InvasiveDebugPermittedPAS</a>(paspace);
            if IsFeatureImplemented(FEAT_TRBE_MPAM) &amp;&amp; TRBMPAM_EL1().EN == '1' then
                let mpam_sp : bits(2) = TRBMPAM_EL1().MPAM_SP;
                let mpam_pa : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a> = <a href="shared_pseudocode.html#func_DecodePASpace_3" title="">DecodePASpace</a>('0', mpam_sp[1], mpam_sp[0]);
                valid_config = (valid_config &amp;&amp; <a href="shared_pseudocode.html#func_IsPASValid_1" title="">IsPASValid</a>(mpam_sp) &amp;&amp;
                                <a href="shared_pseudocode.html#func_InvasiveDebugPermittedPAS_1" title="">InvasiveDebugPermittedPAS</a>(mpam_pa));
            end;

            if !valid_config then
                OtherTRBEManagementEvent('000000');
                TryAssertTRBIRQ();
                return TRUE;
            end;

            let el : bits(2) = ARBITRARY : bits(2);
            let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = ARBITRARY : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>;
            let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescTRBE_2" title="">CreateAccDescTRBE</a>(ss, el);

            var pa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>;
            pa.address = address[55:0];
            pa.paspace = paspace;
            let memattrs : MemoryAttributes = <a href="shared_pseudocode.html#func_S1DecodeMemAttrs_3" title="">S1DecodeMemAttrs</a>(TRBMAR_EL1().Attr,
                                                                  TRBMAR_EL1().SH, TRUE);
            addrdesc = <a href="shared_pseudocode.html#func_CreateAddressDescriptor_3" title="">CreateAddressDescriptor</a>(pa, memattrs, accdesc);
            addrdesc.mecid = <a href="shared_pseudocode.html#global_DEFAULT_MECID" title="">DEFAULT_MECID</a>;
            if IsFeatureImplemented(FEAT_RME) &amp;&amp; !<a href="shared_pseudocode.html#func_ExternalRootInvasiveDebugEnabled_0" title="">ExternalRootInvasiveDebugEnabled</a>() then
                let gpcf : <a href="shared_pseudocode.html#type_GPCFRecord" title="">GPCFRecord</a> = <a href="shared_pseudocode.html#func_GranuleProtectionCheck_2" title="">GranuleProtectionCheck</a>(addrdesc, accdesc);
                if gpcf.gpf == <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> then
                    memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{8}(addrdesc, accdesc, datum);
                else
                    addrdesc.fault.gpcf       = gpcf;
                    addrdesc.fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_GPCFOnOutput" title="">Fault_GPCFOnOutput</a>;
                end;
            else
                memstatus = <a href="shared_pseudocode.html#func_PhysMemWrite_4" title="">PhysMemWrite</a>{8}(addrdesc, accdesc, datum);
            end;
        else
            // The Trace Buffer Unit is using Self-hosted mode.
            var owning_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>;
            var owning_el : bits(2);
            (owning_ss, owning_el) = <a href="shared_pseudocode.html#func_TraceBufferOwner_0" title="">TraceBufferOwner</a>();
            let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = <a href="shared_pseudocode.html#func_CreateAccDescTRBE_2" title="">CreateAccDescTRBE</a>(owning_ss, owning_el);

            let aligned : boolean = TRUE;
            (memstatus, addrdesc) = <a href="shared_pseudocode.html#func_DebugMemWrite_4" title="">DebugMemWrite</a>(address, accdesc, aligned, datum);

            ttw_abort = addrdesc.fault.statuscode IN {<a href="shared_pseudocode.html#enum_Fault_SyncExternalOnWalk" title="">Fault_SyncExternalOnWalk</a>,
                                                      <a href="shared_pseudocode.html#enum_Fault_SyncParityOnWalk" title="">Fault_SyncParityOnWalk</a>};
        end;

        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(addrdesc.fault.statuscode) &amp;&amp; (!ttw_abort || ttw_abort_as_fault) then
            DebugWriteFault(address, addrdesc.fault);
            TryAssertTRBIRQ();
            return TRUE;
        elsif <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) || (ttw_abort &amp;&amp; !ttw_abort_as_fault) then
            DebugWriteExternalAbort(memstatus, addrdesc, address);
            TryAssertTRBIRQ();
            return TRUE;
        end;

        // Check for Trigger Event
        let target_el : bits(2) = <a href="shared_pseudocode.html#func_DefaultTRBEEvent_0" title="">DefaultTRBEEvent</a>();
        let triggered : boolean = <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).TRG == '1';
        if triggered &amp;&amp; !IsZero(TRBTRG_EL1().TRG) then
            TRBTRG_EL1().TRG = (TRBTRG_EL1().TRG - 1)[31:0];
            if IsZero(TRBTRG_EL1().TRG) &amp;&amp; TRBLIMITR_EL1().TM != '11' then
                TraceUnitFlush();
                TraceUnitFlushOnTriggerComplete();
            end;
        end;

        // Increment the pointer
        var next_address : bits(64) = TRBPTR_EL1() + 1;
        if next_address[63:12] == TRBLIMITR_EL1().LIMIT then
            next_address = TRBBASER_EL1().BASE::Zeros{12};
            <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).WRAP = '1';
            CTI_SignalEvent(<a href="shared_pseudocode.html#enum_CrossTriggerIn_TRBEWrap" title="">CrossTriggerIn_TRBEWrap</a>);
            if TRBLIMITR_EL1().FM == '00' then     // Fill mode
                let bsc : bits(6) = '000001'; // Buffer full event
                OtherTRBEManagementEvent(bsc);
            elsif TRBLIMITR_EL1().FM != '11' then  // Not Circular Buffer mode
                if <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).IRQ == '0' then
                    <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).IRQ = '1';   // Assert interrupt or exception
                    CTI_SignalEvent(<a href="shared_pseudocode.html#enum_CrossTriggerIn_TRBEMgmt" title="">CrossTriggerIn_TRBEMgmt</a>);
                end;
            end;
        end;
        TRBPTR_EL1() = next_address[63:0];

        TryAssertTRBIRQ();
    end;
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.DefaultTRBEEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/DefaultTRBEEvent</h3>
      <p class="pseudocode">// DefaultTRBEEvent()
// ==================
// Return the target ELx for an indirect write to TRBSR_ELx for an Other buffer management
// event or anything other than a buffer management event.

func <a id="func_DefaultTRBEEvent_0"/>DefaultTRBEEvent() =&gt; bits(2)
begin
    return <a href="shared_pseudocode.html#func_ReportTRBEEvent_2" title="">ReportTRBEEvent</a>(Zeros{6}, ARBITRARY : bits(6));
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.DetectedTraceTrigger"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/DetectedTraceTrigger</h3>
      <p class="pseudocode">// DetectedTraceTrigger()
// ======================
// Called when the trace unit detects a trace trigger

func DetectedTraceTrigger()
begin
    if <a href="shared_pseudocode.html#func_TraceBufferRunning_0" title="">TraceBufferRunning</a>() then
        let target_el : bits(2) = <a href="shared_pseudocode.html#func_DefaultTRBEEvent_0" title="">DefaultTRBEEvent</a>();
        if <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).TRG == '0' then
            <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).TRG = '1';
            if IsZero(TRBTRG_EL1().TRG) &amp;&amp; TRBLIMITR_EL1().TM != '11' then
                TraceUnitFlush();
                TraceUnitFlushOnTriggerComplete();
            end;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.EffectiveMDCR_EL3_NSTB"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/EffectiveMDCR_EL3_NSTB</h3>
      <p class="pseudocode">// EffectiveMDCR_EL3_NSTB()
// ========================
// Return the Effective value of MDCR_EL3().[NSTBE, NSTB] field and whether it is a reserved value.

func <a id="func_EffectiveMDCR_EL3_NSTB_0"/>EffectiveMDCR_EL3_NSTB() =&gt; (bits(3), boolean)
begin
    var state_bits : bits(3);
    var reserved   : boolean = FALSE;

    if IsFeatureImplemented(FEAT_RME) then
        state_bits = MDCR_EL3().[NSTBE, NSTB];
        if state_bits == '10x' || (!IsFeatureImplemented(FEAT_Secure) &amp;&amp; state_bits == '00x') then
            // Reserved value
            reserved = TRUE;
            (-, state_bits) = ConstrainUnpredictableBits{3}(<a href="shared_pseudocode.html#enum_Unpredictable_RESERVEDNSxB" title="">Unpredictable_RESERVEDNSxB</a>);
        end;
    else
        state_bits = '0' :: MDCR_EL3().NSTB;
    end;

    return (state_bits, reserved);
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.EffectiveTRBLIMITR_EL1_nVM"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/EffectiveTRBLIMITR_EL1_nVM</h3>
      <p class="pseudocode">// EffectiveTRBLIMITR_EL1_nVM()
// ============================

func <a id="func_EffectiveTRBLIMITR_EL1_nVM_0"/>EffectiveTRBLIMITR_EL1_nVM() =&gt; bit
begin
    if !<a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() then
        // If SelfHostedTraceEnabled() is FALSE, then this function is only called when
        // FEAT_TRBE_EXT is implemented.
        assert IsFeatureImplemented(FEAT_TRBE_EXT);
        return '1';
    end;
    if IsFeatureImplemented(FEAT_TRBEv1p1) &amp;&amp; <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        let (owning_ss, owning_el) = <a href="shared_pseudocode.html#func_TraceBufferOwner_0" title="">TraceBufferOwner</a>();
        if ((owning_ss != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> || <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>()) &amp;&amp; owning_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> &amp;&amp;
              TRFCR_EL2().DnVM == '1') then
            return '0';
        end;
    end;
    return TRBLIMITR_EL1().nVM;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.EffectiveTRFCR_EL1_EE"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/EffectiveTRFCR_EL1_EE</h3>
      <p class="pseudocode">// EffectiveTRFCR_EL1_EE()
// =======================
// Return the Effective value of TRFCR_EL1.EE for the purpose of controlling the
// TRBE Profiling exception.

func <a id="func_EffectiveTRFCR_EL1_EE_0"/>EffectiveTRFCR_EL1_EE() =&gt; bits(2)
begin
    if <a href="shared_pseudocode.html#func_EffectiveTRFCR_EL2_EE_0" title="">EffectiveTRFCR_EL2_EE</a>() == '00' then
        return '00';
    end;

    var ee : bits(2) = TRFCR_EL1().EE;
    if ee IN {'01', '10'} then            // Reserved value
        if IsFeatureImplemented(FEAT_NV) then
            ee[0] = ee[1];
        else
            var c : <a href="shared_pseudocode.html#type_Constraint" title="">Constraint</a>;
            (c, ee) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_RESTRFEE" title="">Unpredictable_RESTRFEE</a>);
            assert c IN {<a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#enum_Constraint_UNKNOWN" title="">Constraint_UNKNOWN</a>};
            if c == <a href="shared_pseudocode.html#enum_Constraint_DISABLED" title="">Constraint_DISABLED</a> then
                ee = '00';
            end;
            // Otherwise the value returned by ConstrainUnpredictableBits must be
            // a non-reserved value
        end;
    end;

    return ee;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.EffectiveTRFCR_EL2_EE"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/EffectiveTRFCR_EL2_EE</h3>
      <p class="pseudocode">// EffectiveTRFCR_EL2_EE()
// =======================
// Return the Effective value of TRFCR_EL2.EE.

func <a id="func_EffectiveTRFCR_EL2_EE_0"/>EffectiveTRFCR_EL2_EE() =&gt; bits(2)
begin
    if !IsFeatureImplemented(FEAT_TRBE_EXC) || !<a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() then
        return '00';
    end;

    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; MDCR_EL3().TRBEE == '00' then
        return '00';
    end;

    let check_el2 : boolean = <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; (<a href="shared_pseudocode.html#func_EffectiveSCR_EL3_NS_0" title="">EffectiveSCR_EL3_NS</a>() == '1' ||
                                                 <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>());
    return if check_el2 then TRFCR_EL2().EE else '01';
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.ElementStreamSize"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/ElementStreamSize</h3>
      <p class="pseudocode">// ElementStreamSize
// =================

config ElementStreamSize : integer{0..4096} = 4096;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.GetTRBSR_EL1_FSC"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/GetTRBSR_EL1_FSC</h3>
      <p class="pseudocode">// GetTRBSR_EL1_FSC()
// ==================
// Query the TRBSR_EL1.FSC field.

func <a id="func_GetTRBSR_EL1_FSC_0"/>GetTRBSR_EL1_FSC() =&gt; bits(6)
begin
    var FSC : bits(6);

    FSC = TRBSR_EL1()[5:0];
    return FSC;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.GetTRBSR_EL2_FSC"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/GetTRBSR_EL2_FSC</h3>
      <p class="pseudocode">// GetTRBSR_EL2_FSC()
// ==================
// Query the TRBSR_EL2.FSC field.

func <a id="func_GetTRBSR_EL2_FSC_0"/>GetTRBSR_EL2_FSC() =&gt; bits(6)
begin
    var FSC : bits(6);

    FSC = TRBSR_EL2()[5:0];
    return FSC;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.GetTRBSR_EL3_FSC"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/GetTRBSR_EL3_FSC</h3>
      <p class="pseudocode">// GetTRBSR_EL3_FSC()
// ==================
// Query the TRBSR_EL3.FSC field.

func <a id="func_GetTRBSR_EL3_FSC_0"/>GetTRBSR_EL3_FSC() =&gt; bits(6)
begin
    var FSC : bits(6);

    FSC = TRBSR_EL3()[5:0];
    return FSC;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.HaveImpDefTraceOutput"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/HaveImpDefTraceOutput</h3>
      <p class="pseudocode">// HaveImpDefTraceOutput()
// =======================

func <a id="func_HaveImpDefTraceOutput_0"/>HaveImpDefTraceOutput() =&gt; boolean
begin
    return ImpDefBool("Has Enabled External Trace Port");
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.ImpDefTraceOutput"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/ImpDefTraceOutput</h3>
      <p class="pseudocode">// ImpDefTraceOutput()
// ===================

func <a id="func_ImpDefTraceOutput_1"/>ImpDefTraceOutput(datum : bits(8)) =&gt; boolean
begin
    // Send 'datum' to an IMPLEMENTATION DEFINED trace output port
    // return TRUE if the byte is sent
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.OtherTRBEManagementEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/OtherTRBEManagementEvent</h3>
      <p class="pseudocode">// OtherTRBEManagementEvent()
// ==========================
// Report an Other buffer management event, with the status code 'bsc'

func OtherTRBEManagementEvent(bsc : bits(6))
begin
    ReportTRBEManagementEvent('000000', bsc);
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.ReportTRBEEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/ReportTRBEEvent</h3>
      <p class="pseudocode">// ReportTRBEEvent()
// =================
// Return the target ELx for an indirect write to TRBSR_ELx.
// When the indirect write is due to a buffer management event:
// 'ec_bits' is the Event Class for the management event.
// 'fsc_bits' is the Fault Status Code when this is a fault, ignored otherwise.
// Otherwise, 'ec_bits' should be Zeros().

func <a id="func_ReportTRBEEvent_2"/>ReportTRBEEvent(ec_bits : bits(6), fsc_bits : bits(6)) =&gt; bits(2)
begin
    var target_el : bits(2);
    var route_to_el3 : boolean = FALSE;
    var route_to_el2 : boolean = FALSE;

    if IsFeatureImplemented(FEAT_TRBE_EXC) &amp;&amp; <a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() then
        let s1fault : boolean = (ec_bits == '100100');   // Stage 1 fault
        let s2fault : boolean = (ec_bits == '100101');   // Stage 2 fault

        var gpcfault, gpfault : boolean;
        if IsFeatureImplemented(FEAT_RME) then
            // Granule Protection Check fault, other than GPF. That is, a GPT address size fault,
            // GPT walk fault, or synchronous External abort on GPT fetch.
            gpcfault = (ec_bits == '011110');
            // Other Granule Protection Fault, reported as Stage 1 or Stage 2 fault.
            gpfault =  ((s1fault || s2fault) &amp;&amp; fsc_bits IN {'10001x', '1001xx', '101000'});
        else
            gpcfault = FALSE;
            gpfault = FALSE;
        end;
        let sync_ext_abort : boolean = ((s1fault || s2fault) &amp;&amp;
                                           fsc_bits IN {'010000', '01001x', '0101xx', '011011'});

        var owning_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>;
        var owning_el : bits(2);
        (owning_ss, owning_el) = <a href="shared_pseudocode.html#func_TraceBufferOwner_0" title="">TraceBufferOwner</a>();

        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; MDCR_EL3().TRBEE == '1x' then
            route_to_el3 = (MDCR_EL3().TRBEE == '11' ||
                            gpcfault || (gpfault &amp;&amp; SCR_EL3().GPF == '1') ||
                            (sync_ext_abort &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveEA_0" title="">EffectiveEA</a>() == '1'));
        end;

        if <a href="shared_pseudocode.html#func_EffectiveTRFCR_EL2_EE_0" title="">EffectiveTRFCR_EL2_EE</a>() == '1x' then
            route_to_el2 = (TRFCR_EL2().EE == '11' || (s1fault &amp;&amp; owning_el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) || s2fault ||
                            gpcfault || (gpfault &amp;&amp; HCR_EL2().GPF == '1') ||
                            (sync_ext_abort &amp;&amp; <a href="shared_pseudocode.html#func_EffectiveHCR_TEA_0" title="">EffectiveHCR_TEA</a>() == '1'));
        end;
    end;

    if route_to_el3 then
        target_el = <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
    elsif route_to_el2 then
        target_el = <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    else
        target_el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    end;

    return target_el;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.ReportTRBEManagementEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/ReportTRBEManagementEvent</h3>
      <p class="pseudocode">// ReportTRBEManagementEvent()
// ===========================
// Report a buffer management event with the event class 'ec' and status code 'bsc'

func ReportTRBEManagementEvent(ec : bits(6), bsc : bits(6))
begin
    let target_el : bits(2) = <a href="shared_pseudocode.html#func_DefaultTRBEEvent_0" title="">DefaultTRBEEvent</a>();
    if <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).S == '0' then
        <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).S    = '1';     // Stop collection
        if <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).IRQ == '0' then
            <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).IRQ  = '1';     // Assert interrupt or exception
            CTI_SignalEvent(<a href="shared_pseudocode.html#enum_CrossTriggerIn_TRBEMgmt" title="">CrossTriggerIn_TRBEMgmt</a>);
        end;
        <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).EC   = ec;
        <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).MSS  = ZeroExtend{16}(bsc);
        <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).MSS2 = Zeros{24};
        CTI_SignalEvent(<a href="shared_pseudocode.html#enum_CrossTriggerIn_TRBEStop" title="">CrossTriggerIn_TRBEStop</a>);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TRBEInternalBufferFull"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TRBEInternalBufferFull</h3>
      <p class="pseudocode">// TRBEInternalBufferFull()
// ========================

func <a id="func_TRBEInternalBufferFull_0"/>TRBEInternalBufferFull() =&gt; boolean
begin
    // In the simple sequential model, the internal buffer never fills
    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TRBEInterruptEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TRBEInterruptEnabled</h3>
      <p class="pseudocode">// TRBEInterruptEnabled()
// ======================
// Return TRUE if the TRBE interrupt request (TRBIRQ) is enabled, FALSE otherwise.

func <a id="func_TRBEInterruptEnabled_0"/>TRBEInterruptEnabled() =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_EffectiveTRFCR_EL1_EE_0" title="">EffectiveTRFCR_EL1_EE</a>() == '00';
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TRBE_TRBIDR_P_Read"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TRBE_TRBIDR_P_Read</h3>
      <p class="pseudocode">// TRBE_TRBIDR_P_Read()
// ====================
// Called when TRBIDR_EL1 is read, returns the value of TRBIDR_EL1.P

func <a id="func_TRBE_TRBIDR_P_Read_0"/>TRBE_TRBIDR_P_Read() =&gt; bit
begin
    var owning_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>;
    var owning_el : bits(2);
    (owning_ss, owning_el) = <a href="shared_pseudocode.html#func_TraceBufferOwner_0" title="">TraceBufferOwner</a>();

    // Reads as one if the Trace Buffer is owned by a higher Exception
    // Level or another Security state.
    if (UInt(owning_el) &gt; UInt(PSTATE.EL) ||
          (PSTATE.EL != <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> &amp;&amp; owning_ss != <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>())) then
        return '1';
    else
        return '0';
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TRBSR_EL"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TRBSR_EL</h3>
      <p class="pseudocode">// TRBSR_EL - accessor
// ===================

accessor <a id="accessor_TRBSR_EL_1"/>TRBSR_EL(el : bits(2)) &lt;=&gt; value : TRBSRType
begin
    getter
        var r : bits(64);
        case el of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;   r = TRBSR_EL1();
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;   r = TRBSR_EL2();
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;   r = TRBSR_EL3();
            otherwise =&gt;  unreachable;
        end;
        return r;
    end;

    setter
        let r : bits(64) = value;
        case el of
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;   TRBSR_EL1() = r;
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;   TRBSR_EL2() = r;
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;   TRBSR_EL3() = r;
            otherwise =&gt;  unreachable;
        end;
        return;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TraceBufferEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TraceBufferEnabled</h3>
      <p class="pseudocode">// TraceBufferEnabled()
// ====================

func <a id="func_TraceBufferEnabled_0"/>TraceBufferEnabled() =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_TRBE) then
        return FALSE;
    elsif <a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() then
        if TRBLIMITR_EL1().E == '0' then
            return FALSE;
        end;
        var el : bits(2);
        (-, el) = <a href="shared_pseudocode.html#func_TraceBufferOwner_0" title="">TraceBufferOwner</a>();
        return !<a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(el);
    elsif IsFeatureImplemented(FEAT_TRBE) then
        return TRBLIMITR_EL1().XE == '1';
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TraceBufferOwner"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TraceBufferOwner</h3>
      <p class="pseudocode">// TraceBufferOwner()
// ==================
// Return the owning Security state and Exception level. Must only be called
// when SelfHostedTraceEnabled() is TRUE.

func <a id="func_TraceBufferOwner_0"/>TraceBufferOwner() =&gt; (<a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, bits(2))
begin
    assert IsFeatureImplemented(FEAT_TRBE);

    var owning_ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>;
    var state_bits :  bits(3);
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        (state_bits, -) = <a href="shared_pseudocode.html#func_EffectiveMDCR_EL3_NSTB_0" title="">EffectiveMDCR_EL3_NSTB</a>();
    else
        state_bits = if <a href="shared_pseudocode.html#func_SecureOnlyImplementation_0" title="">SecureOnlyImplementation</a>() then '001' else '011';
    end;

    case state_bits of
        when '00x' =&gt; owning_ss = <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>;
        when '01x' =&gt; owning_ss = <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>;
        when '11x' =&gt; owning_ss = <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a>;
    end;
    var owning_el : bits(2);
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) &amp;&amp; (owning_ss != <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> || <a href="shared_pseudocode.html#func_IsSecureEL2Enabled_0" title="">IsSecureEL2Enabled</a>()) then
        owning_el = if MDCR_EL2().E2TB == '00' then <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> else <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    else
        owning_el = <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    end;
    return (owning_ss, owning_el);
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TraceBufferRunning"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TraceBufferRunning</h3>
      <p class="pseudocode">// TraceBufferRunning()
// ====================

func <a id="func_TraceBufferRunning_0"/>TraceBufferRunning() =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_TraceBufferEnabled_0" title="">TraceBufferEnabled</a>() then
        return FALSE;
    end;

    var stopped : boolean = TRBSR_EL1().S == '1';
    if IsFeatureImplemented(FEAT_TRBE_EXC) &amp;&amp; <a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() then
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; MDCR_EL3().TRBEE == '1x' then
            stopped = stopped || (TRBSR_EL3().S == '1');
        end;
        if <a href="shared_pseudocode.html#func_EffectiveTRFCR_EL2_EE_0" title="">EffectiveTRFCR_EL2_EE</a>() == '1x' then
            stopped = stopped || (TRBSR_EL2().S == '1');
        end;
    end;
    return !stopped;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TraceUnitFlushOnTriggerComplete"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TraceUnitFlushOnTriggerComplete</h3>
      <p class="pseudocode">// TraceUnitFlushOnTriggerComplete()
// =================================
// Called when a trace unit flush completes following a call to
// TraceUnitFlush() due to a trace trigger.

func TraceUnitFlushOnTriggerComplete()
begin
    if TRBLIMITR_EL1().TM == '00' then     // Stop on trigger
        let bsc : bits(6) = '000010';      // Trigger event
        OtherTRBEManagementEvent(bsc);
    elsif TRBLIMITR_EL1().TM != '11' then  // Not Ignore trigger
        let target_el : bits(2) = <a href="shared_pseudocode.html#func_DefaultTRBEEvent_0" title="">DefaultTRBEEvent</a>();
        <a href="shared_pseudocode.html#accessor_TRBSR_EL_1" title="">TRBSR_EL</a>(target_el).IRQ = '1';     // Assert interrupt or exception
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TryAssertTRBIRQ"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TryAssertTRBIRQ</h3>
      <p class="pseudocode">// TryAssertTRBIRQ()
// =================
// Assert TRBIRQ pin when appropriate.

func TryAssertTRBIRQ()
begin
    if <a href="shared_pseudocode.html#func_TRBEInterruptEnabled_0" title="">TRBEInterruptEnabled</a>() &amp;&amp; TRBSR_EL1().IRQ == '1' then
        SetInterruptRequestLevel(<a href="shared_pseudocode.html#enum_InterruptID_TRBIRQ" title="">InterruptID_TRBIRQ</a>, HIGH);
    else
        SetInterruptRequestLevel(<a href="shared_pseudocode.html#enum_InterruptID_TRBIRQ" title="">InterruptID_TRBIRQ</a>, LOW);
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceInstrumentationAllowed.TraceInstrumentationAllowed"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceInstrumentationAllowed/TraceInstrumentationAllowed</h3>
      <p class="pseudocode">// TraceInstrumentationAllowed()
// =============================
// Returns TRUE if Instrumentation Trace is allowed
// in the given Exception level and Security state.

func <a id="func_TraceInstrumentationAllowed_2"/>TraceInstrumentationAllowed(ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>, el : bits(2)) =&gt; boolean
begin
    if !IsFeatureImplemented(FEAT_ITE) then return FALSE; end;
    if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(el) then return FALSE; end;

    if <a href="shared_pseudocode.html#func_TraceAllowed_1" title="">TraceAllowed</a>(el) then
        var ite_bit : bit;
        case el of
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; ite_bit = '0';
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; ite_bit = TRCITECR_EL2().E2E;
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; ite_bit = TRCITECR_EL1().E1E;
            when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
                if <a href="shared_pseudocode.html#func_EffectiveTGE_0" title="">EffectiveTGE</a>() == '1' then
                    ite_bit = TRCITECR_EL2().E0HE;
                else
                    ite_bit = TRCITECR_EL1().E0E;
                end;
        end;

        if <a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() then
            return ite_bit == '1';
        else
            var el_bit : bit;
            var ss_bit : bit;
            case el of
                when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt; el_bit = TRCITEEDCR().E0;
                when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt; el_bit = TRCITEEDCR().E1;
                when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt; el_bit = TRCITEEDCR().E2;
                when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt; el_bit = TRCITEEDCR().E3;
            end;
            case ss of
                when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;     ss_bit = TRCITEEDCR().RL;
                when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;    ss_bit = TRCITEEDCR().S;
                when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt; ss_bit = TRCITEEDCR().NS;
                otherwise =&gt; ss_bit = '1';
            end;

            let ed_allowed : boolean = ss_bit == '1' &amp;&amp; el_bit == '1';

            if TRCCONFIGR().ITO == '1' then
                return ed_allowed;
            else
                return ed_allowed &amp;&amp; ite_bit == '1';
            end;
        end;
    else
        return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceProcessElements.TraceUnitFlush"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceProcessElements/TraceUnitFlush</h3>
      <p class="pseudocode">// TraceUnitFlush()
// ================
// Called when a trace unit flush is requested, to output previous recorded trace.

impdef func TraceUnitFlush()
begin
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.EffectiveE0HTRE"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/EffectiveE0HTRE</h3>
      <p class="pseudocode">// EffectiveE0HTRE()
// =================
// Returns effective E0HTRE value

func <a id="func_EffectiveE0HTRE_0"/>EffectiveE0HTRE() =&gt; bit
begin
    return if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then HTRFCR().E0HTRE else TRFCR_EL2().E0HTRE;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.EffectiveE0TRE"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/EffectiveE0TRE</h3>
      <p class="pseudocode">// EffectiveE0TRE()
// ================
// Returns effective E0TRE value

func <a id="func_EffectiveE0TRE_0"/>EffectiveE0TRE() =&gt; bit
begin
    return if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>) then TRFCR().E0TRE else TRFCR_EL1().E0TRE;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.EffectiveE1TRE"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/EffectiveE1TRE</h3>
      <p class="pseudocode">// EffectiveE1TRE()
// ================
// Returns effective E1TRE value

func <a id="func_EffectiveE1TRE_0"/>EffectiveE1TRE() =&gt; bit
begin
    return if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then TRFCR().E1TRE else TRFCR_EL1().E1TRE;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.EffectiveE2TRE"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/EffectiveE2TRE</h3>
      <p class="pseudocode">// EffectiveE2TRE()
// ================
// Returns effective E2TRE value

func <a id="func_EffectiveE2TRE_0"/>EffectiveE2TRE() =&gt; bit
begin
    return if <a href="shared_pseudocode.html#func_UsingAArch32_0" title="">UsingAArch32</a>() then HTRFCR().E2TRE else TRFCR_EL2().E2TRE;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.SelfHostedTraceEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/SelfHostedTraceEnabled</h3>
      <p class="pseudocode">// SelfHostedTraceEnabled()
// ========================
// Returns TRUE if Self-hosted Trace is enabled.

func <a id="func_SelfHostedTraceEnabled_0"/>SelfHostedTraceEnabled() =&gt; boolean
begin
    var secure_trace_enable : bit = '0';
    if !(<a href="shared_pseudocode.html#func_HaveTraceExt_0" title="">HaveTraceExt</a>() &amp;&amp; IsFeatureImplemented(FEAT_TRF)) then return FALSE; end;
    if EDSCR().TFO == '0' then return TRUE; end;
    if IsFeatureImplemented(FEAT_RME) then
        secure_trace_enable = if IsFeatureImplemented(FEAT_SEL2) then MDCR_EL3().STE else '0';
        return ((secure_trace_enable == '1' &amp;&amp; !<a href="shared_pseudocode.html#func_ExternalSecureNoninvasiveDebugEnabled_0" title="">ExternalSecureNoninvasiveDebugEnabled</a>()) ||
                (MDCR_EL3().RLTE == '1' &amp;&amp; !<a href="shared_pseudocode.html#func_ExternalRealmNoninvasiveDebugEnabled_0" title="">ExternalRealmNoninvasiveDebugEnabled</a>()));
    end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
        secure_trace_enable = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then SDCR().STE else MDCR_EL3().STE;
    else
        secure_trace_enable = if <a href="shared_pseudocode.html#func_SecureOnlyImplementation_0" title="">SecureOnlyImplementation</a>() then '1' else '0';
    end;

    if secure_trace_enable == '1' &amp;&amp; !<a href="shared_pseudocode.html#func_ExternalSecureNoninvasiveDebugEnabled_0" title="">ExternalSecureNoninvasiveDebugEnabled</a>() then
        return TRUE;
    end;

    return FALSE;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.TraceAllowed"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/TraceAllowed</h3>
      <p class="pseudocode">// TraceAllowed()
// ==============
// Returns TRUE if Self-hosted Trace is allowed in the given Exception level.

func <a id="func_TraceAllowed_1"/>TraceAllowed(el : bits(2)) =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_HaveTraceExt_0" title="">HaveTraceExt</a>() then
        return FALSE;
    end;
    // If in Debug state then tracing is not allowed
    if <a href="shared_pseudocode.html#func_Halted_0" title="">Halted</a>() &amp;&amp; !<a href="shared_pseudocode.html#func_Restarting_0" title="">Restarting</a>() then
        return FALSE;
    end;
    if <a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() then
        var trace_allowed : boolean;
        let ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a> = <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(el);
        // Detect scenarios where tracing in this Security state is never allowed.
        case ss of
            when <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a> =&gt;
                trace_allowed = TRUE;
            when <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> =&gt;
                var trace_bit : bit;
                if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
                    trace_bit = if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then SDCR().STE else MDCR_EL3().STE;
                else
                    trace_bit = '1';
                end;
                trace_allowed = trace_bit == '1';
            when <a href="shared_pseudocode.html#enum_SS_Realm" title="">SS_Realm</a> =&gt;
                trace_allowed = MDCR_EL3().RLTE == '1';
            when <a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a> =&gt;
                trace_allowed = FALSE;
        end;

        // Tracing is prohibited if the trace buffer owning security state is not the
        // current Security state or the owning Exception level is a lower Exception level.
        if IsFeatureImplemented(FEAT_TRBE) &amp;&amp; <a href="shared_pseudocode.html#func_TraceBufferEnabled_0" title="">TraceBufferEnabled</a>() then
            let (owning_ss, owning_el) = <a href="shared_pseudocode.html#func_TraceBufferOwner_0" title="">TraceBufferOwner</a>();
            if (ss != owning_ss || UInt(owning_el) &lt; UInt(el) ||
                (<a href="shared_pseudocode.html#func_EffectiveTGE_0" title="">EffectiveTGE</a>() == '1' &amp;&amp; owning_el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>)) then
                trace_allowed = FALSE;
            end;
        end;

        var TRE_bit : bit;
        case el of
            when <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> =&gt;  TRE_bit = if !<a href="shared_pseudocode.html#func_HaveAArch64_0" title="">HaveAArch64</a>() then TRFCR().E1TRE else '0';
            when <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> =&gt;  TRE_bit = <a href="shared_pseudocode.html#func_EffectiveE2TRE_0" title="">EffectiveE2TRE</a>();
            when <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> =&gt;  TRE_bit = <a href="shared_pseudocode.html#func_EffectiveE1TRE_0" title="">EffectiveE1TRE</a>();
            when <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> =&gt;
                if <a href="shared_pseudocode.html#func_EffectiveTGE_0" title="">EffectiveTGE</a>() == '1' then
                    TRE_bit = <a href="shared_pseudocode.html#func_EffectiveE0HTRE_0" title="">EffectiveE0HTRE</a>();
                else
                    TRE_bit = <a href="shared_pseudocode.html#func_EffectiveE0TRE_0" title="">EffectiveE0TRE</a>();
                end;
        end;

        return trace_allowed &amp;&amp; TRE_bit == '1';
    else
        return <a href="shared_pseudocode.html#func_ExternalNoninvasiveDebugAllowed_1" title="">ExternalNoninvasiveDebugAllowed</a>(el);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.TraceContextIDR2"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/TraceContextIDR2</h3>
      <p class="pseudocode">// TraceContextIDR2()
// ==================

func <a id="func_TraceContextIDR2_0"/>TraceContextIDR2() =&gt; boolean
begin
    if !<a href="shared_pseudocode.html#func_TraceAllowed_1" title="">TraceAllowed</a>(PSTATE.EL)|| !<a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then return FALSE; end;
    return (!<a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() || TRFCR_EL2().CX == '1');
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.TraceSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/TraceSynchronizationBarrier</h3>
      <p class="pseudocode">// TraceSynchronizationBarrier()
// =============================
// Barrier instruction that preserves the relative order of accesses to System
// registers due to trace operations and other accesses to the same registers.
// When FEAT_TRBE is implemented, a TraceSynchronizationBarrier also acts as a memory
// barrier operation to flush any trace data generated by the trace unit, such that
// a subsequent Data Synchronization Barrier does not complete until the trace data
// has been written to memory.

func TraceSynchronizationBarrier()
begin
    if IsFeatureImplemented(FEAT_TRBE) &amp;&amp; !<a href="shared_pseudocode.html#func_TraceAllowed_1" title="">TraceAllowed</a>(PSTATE.EL) then
        TraceUnitFlush();
    end;
    return;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.TraceTimeStamp"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/TraceTimeStamp</h3>
      <p class="pseudocode">// TraceTimeStamp()
// ================

func <a id="func_TraceTimeStamp_0"/>TraceTimeStamp() =&gt; <a href="shared_pseudocode.html#type_TimeStamp" title="">TimeStamp</a>
begin
    if <a href="shared_pseudocode.html#func_SelfHostedTraceEnabled_0" title="">SelfHostedTraceEnabled</a>() then
        if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
            var TS_el2 : bits(2) = TRFCR_EL2().TS;
            if !IsFeatureImplemented(FEAT_ECV) &amp;&amp; TS_el2 == '10' then
                // Reserved value
                (-, TS_el2) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_EL2TIMESTAMP" title="">Unpredictable_EL2TIMESTAMP</a>);
            end;

            case TS_el2 of
                when '00' =&gt;
                    // Falls out to check TRFCR_EL1.TS
                    pass;
                when '01' =&gt;
                    return <a href="shared_pseudocode.html#enum_TimeStamp_Virtual" title="">TimeStamp_Virtual</a>;
                when '10' =&gt;
                    // Otherwise ConstrainUnpredictableBits removes this case
                    assert IsFeatureImplemented(FEAT_ECV);
                    return <a href="shared_pseudocode.html#enum_TimeStamp_OffsetPhysical" title="">TimeStamp_OffsetPhysical</a>;
                when '11' =&gt;
                    return <a href="shared_pseudocode.html#enum_TimeStamp_Physical" title="">TimeStamp_Physical</a>;
            end;
        end;

        var TS_el1 : bits(2) = TRFCR_EL1().TS;
        if TS_el1 == '00' || (!IsFeatureImplemented(FEAT_ECV) &amp;&amp; TS_el1 == '10') then
            // Reserved value
            (-, TS_el1) = ConstrainUnpredictableBits{2}(<a href="shared_pseudocode.html#enum_Unpredictable_EL1TIMESTAMP" title="">Unpredictable_EL1TIMESTAMP</a>);
        end;

        case TS_el1 of
            when '01' =&gt;
                return <a href="shared_pseudocode.html#enum_TimeStamp_Virtual" title="">TimeStamp_Virtual</a>;
            when '10' =&gt;
                assert IsFeatureImplemented(FEAT_ECV);
                return <a href="shared_pseudocode.html#enum_TimeStamp_OffsetPhysical" title="">TimeStamp_OffsetPhysical</a>;
            when '11' =&gt;
                return <a href="shared_pseudocode.html#enum_TimeStamp_Physical" title="">TimeStamp_Physical</a>;
            otherwise =&gt;
                unreachable;         // ConstrainUnpredictableBits removes this case
        end;
    else
        return <a href="shared_pseudocode.html#enum_TimeStamp_CoreSight" title="">TimeStamp_CoreSight</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.trace.system.IsTraceCorePowered"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/system/IsTraceCorePowered</h3>
      <p class="pseudocode">// IsTraceCorePowered()
// ====================
// Returns TRUE if the trace unit Core power domain is powered up

impdef func <a id="func_IsTraceCorePowered_0"/>IsTraceCorePowered() =&gt; boolean
begin
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.at"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at</h3>
      <p class="pseudocode">type <a id="type_TranslationStage"/>TranslationStage of enumeration {
    <a id="enum_TranslationStage_1"/>TranslationStage_1,
    <a id="enum_TranslationStage_12"/>TranslationStage_12
};

type <a id="type_ATAccess"/>ATAccess of enumeration {
    <a id="enum_ATAccess_Read"/>ATAccess_Read,
    <a id="enum_ATAccess_Write"/>ATAccess_Write,
    <a id="enum_ATAccess_Any"/>ATAccess_Any,
    <a id="enum_ATAccess_ReadPAN"/>ATAccess_ReadPAN,
    <a id="enum_ATAccess_WritePAN"/>ATAccess_WritePAN
};</p>
    </div>
    <div class="ps"><a id="shared.translation.at.EncodePARAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at/EncodePARAttrs</h3>
      <p class="pseudocode">// EncodePARAttrs()
// ================
// Convert orthogonal attributes and hints to 64-bit PAR ATTR field.

func <a id="func_EncodePARAttrs_1"/>EncodePARAttrs(memattrs : MemoryAttributes) =&gt; bits(8)
begin
    var result : bits(8);

    if IsFeatureImplemented(FEAT_MTE) &amp;&amp; memattrs.tags == <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a> then
        if IsFeatureImplemented(FEAT_MTE_PERM) &amp;&amp; memattrs.notagaccess then
            result[7:0] = '11100000';
        else
            result[7:0] = '11110000';
        end;
        return result;
    end;

    if memattrs.memtype == MemType_Device then
        result[7:4] = '0000';
        case memattrs.device of
            when <a href="shared_pseudocode.html#enum_DeviceType_nGnRnE" title="">DeviceType_nGnRnE</a> =&gt; result[3:0] = '0000';
            when <a href="shared_pseudocode.html#enum_DeviceType_nGnRE" title="">DeviceType_nGnRE</a>  =&gt; result[3:0] = '0100';
            when <a href="shared_pseudocode.html#enum_DeviceType_nGRE" title="">DeviceType_nGRE</a>   =&gt; result[3:0] = '1000';
            when <a href="shared_pseudocode.html#enum_DeviceType_GRE" title="">DeviceType_GRE</a>    =&gt; result[3:0] = '1100';
            otherwise              =&gt; unreachable;
        end;
        result[0] = NOT memattrs.xs;
    else
        if memattrs.xs == '0' then
            if (memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a> &amp;&amp; memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a> &amp;&amp;
                  !memattrs.outer.transient &amp;&amp; memattrs.outer.hints == <a href="shared_pseudocode.html#global_MemHint_RA" title="">MemHint_RA</a>) then
                return '10100000';
            elsif memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp; memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> then
                return '01000000';
            end;
        end;

        if memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a> then
            result[7:6] = if memattrs.outer.transient then '00' else '10';
            result[5:4] = memattrs.outer.hints;
        elsif memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> then
            result[7:6] = if memattrs.outer.transient then '01' else '11';
            result[5:4] = memattrs.outer.hints;
        else // MemAttr_NC
            result[7:4] = '0100';
        end;

        if memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a> then
            result[3:2] = if memattrs.inner.transient then '00' else '10';
            result[1:0] = memattrs.inner.hints;
        elsif memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> then
            result[3:2] = if memattrs.inner.transient then '01' else '11';
            result[1:0] = memattrs.inner.hints;
        else // MemAttr_NC
            result[3:0] = '0100';
        end;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.at.PAREncodeShareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at/PAREncodeShareability</h3>
      <p class="pseudocode">// PAREncodeShareability()
// =======================
// Derive 64-bit PAR SH field.

func <a id="func_PAREncodeShareability_1"/>PAREncodeShareability(memattrs : MemoryAttributes) =&gt; bits(2)
begin
    if (memattrs.memtype == MemType_Device ||
            (memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp;
             memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>)) then
        // Force Outer-Shareable on Device and Normal Non-Cacheable memory
        return '10';
    end;

    case memattrs.shareability of
        when <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a> =&gt; return '00';
        when <a href="shared_pseudocode.html#enum_Shareability_ISH" title="">Shareability_ISH</a> =&gt; return '11';
        when <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a> =&gt; return '10';
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.at.ReportedPARAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at/ReportedPARAttrs</h3>
      <p class="pseudocode">// ReportedPARAttrs()
// ==================
// The value returned in this field can be the resulting attribute, as determined by any permitted
// implementation choices and any applicable configuration bits, instead of the value that appears
// in the translation table descriptor.

impdef func <a id="func_ReportedPARAttrs_1"/>ReportedPARAttrs(parattrs : bits(8)) =&gt; bits(8)
begin
    return parattrs;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.at.ReportedPARShareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at/ReportedPARShareability</h3>
      <p class="pseudocode">// ReportedPARShareability()
// =========================
// The value returned in SH field can be the resulting attribute, as determined by any
// permitted implementation choices and any applicable configuration bits, instead of
// the value that appears in the translation table descriptor.

impdef func <a id="func_ReportedPARShareability_1"/>ReportedPARShareability(sh : bits(2)) =&gt; bits(2)
begin
    return sh;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.DecodeDevice"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/DecodeDevice</h3>
      <p class="pseudocode">// DecodeDevice()
// ==============
// Decode output Device type

func <a id="func_DecodeDevice_1"/>DecodeDevice(device : bits(2)) =&gt; <a href="shared_pseudocode.html#type_DeviceType" title="">DeviceType</a>
begin
    case device of
        when '00' =&gt; return <a href="shared_pseudocode.html#enum_DeviceType_nGnRnE" title="">DeviceType_nGnRnE</a>;
        when '01' =&gt; return <a href="shared_pseudocode.html#enum_DeviceType_nGnRE" title="">DeviceType_nGnRE</a>;
        when '10' =&gt; return <a href="shared_pseudocode.html#enum_DeviceType_nGRE" title="">DeviceType_nGRE</a>;
        when '11' =&gt; return <a href="shared_pseudocode.html#enum_DeviceType_GRE" title="">DeviceType_GRE</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.DecodeLDFAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/DecodeLDFAttr</h3>
      <p class="pseudocode">// DecodeLDFAttr()
// ===============
// Decode memory attributes using LDF (Long Descriptor Format) mapping

func <a id="func_DecodeLDFAttr_1"/>DecodeLDFAttr(attr : bits(4)) =&gt; <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a>
begin
    var ldfattr : <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a>;

    if    attr == 'x0xx' then ldfattr.attrs = <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a>; // Write-through
    elsif attr == '0100' then ldfattr.attrs = <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>; // Non-cacheable
    elsif attr == 'x1xx' then ldfattr.attrs = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>; // Write-back
    else                      unreachable;
    end;

    // Allocation hints are applicable only to cacheable memory.
    if ldfattr.attrs != <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> then
        case attr[1:0] of
            when '00' =&gt; ldfattr.hints = <a href="shared_pseudocode.html#global_MemHint_No" title="">MemHint_No</a>;  // No allocation hints
            when '01' =&gt; ldfattr.hints = <a href="shared_pseudocode.html#global_MemHint_WA" title="">MemHint_WA</a>;  // Write-allocate
            when '10' =&gt; ldfattr.hints = <a href="shared_pseudocode.html#global_MemHint_RA" title="">MemHint_RA</a>;  // Read-allocate
            when '11' =&gt; ldfattr.hints = <a href="shared_pseudocode.html#global_MemHint_RWA" title="">MemHint_RWA</a>; // Read/Write allocate
        end;
    end;

    // The Transient hint applies only to cacheable memory with some allocation hints.
    if ldfattr.attrs != <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp; ldfattr.hints != <a href="shared_pseudocode.html#global_MemHint_No" title="">MemHint_No</a> then
        ldfattr.transient = attr[3] == '0';
    end;

    return ldfattr;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.DecodeSDFAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/DecodeSDFAttr</h3>
      <p class="pseudocode">// DecodeSDFAttr()
// ===============
// Decode memory attributes using SDF (Short Descriptor Format) mapping

func <a id="func_DecodeSDFAttr_1"/>DecodeSDFAttr(rgn : bits(2)) =&gt; <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a>
begin
    var sdfattr : <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a>;

    case rgn of
        when '00' =&gt;                   // Non-cacheable (no allocate)
            sdfattr.attrs = <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>;
        when '01' =&gt;                   // Write-back, Read and Write allocate
            sdfattr.attrs = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;
            sdfattr.hints = <a href="shared_pseudocode.html#global_MemHint_RWA" title="">MemHint_RWA</a>;
        when '10' =&gt;                   // Write-through, Read allocate
            sdfattr.attrs = <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a>;
            sdfattr.hints = <a href="shared_pseudocode.html#global_MemHint_RA" title="">MemHint_RA</a>;
        when '11' =&gt;                   // Write-back, Read allocate
            sdfattr.attrs = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;
            sdfattr.hints = <a href="shared_pseudocode.html#global_MemHint_RA" title="">MemHint_RA</a>;
    end;

    sdfattr.transient = FALSE;

    return sdfattr;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.DecodeShareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/DecodeShareability</h3>
      <p class="pseudocode">// DecodeShareability()
// ====================
// Decode shareability of target memory region

func <a id="func_DecodeShareability_1"/>DecodeShareability(sh : bits(2)) =&gt; <a href="shared_pseudocode.html#type_Shareability" title="">Shareability</a>
begin
    case sh of
        when '10' =&gt; return <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
        when '11' =&gt; return <a href="shared_pseudocode.html#enum_Shareability_ISH" title="">Shareability_ISH</a>;
        when '00' =&gt; return <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a>;
        otherwise =&gt;
            case ConstrainUnpredictable(<a href="shared_pseudocode.html#enum_Unpredictable_Shareability" title="">Unpredictable_Shareability</a>) of
                when <a href="shared_pseudocode.html#enum_Constraint_OSH" title="">Constraint_OSH</a> =&gt; return <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
                when <a href="shared_pseudocode.html#enum_Constraint_ISH" title="">Constraint_ISH</a> =&gt; return <a href="shared_pseudocode.html#enum_Shareability_ISH" title="">Shareability_ISH</a>;
                when <a href="shared_pseudocode.html#enum_Constraint_NSH" title="">Constraint_NSH</a> =&gt; return <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a>;
            end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.EffectiveShareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/EffectiveShareability</h3>
      <p class="pseudocode">// EffectiveShareability()
// =======================
// Force Outer Shareability on Device and Normal iNCoNC memory

func <a id="func_EffectiveShareability_1"/>EffectiveShareability(memattrs : MemoryAttributes) =&gt; <a href="shared_pseudocode.html#type_Shareability" title="">Shareability</a>
begin
    if (memattrs.memtype == MemType_Device ||
          (memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> &amp;&amp;
           memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>)) then
        return <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
    else
        return memattrs.shareability;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.IsTaggableMemAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/IsTaggableMemAttr</h3>
      <p class="pseudocode">// IsTaggableMemAttr()
// ===================
// Determine whether the current memory attributes support MTE

func <a id="func_IsTaggableMemAttr_1"/>IsTaggableMemAttr(attrs : MemoryAttributes) =&gt; boolean
begin
    return ((attrs.memtype == MemType_Normal)  &amp;&amp;
            (attrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>)  &amp;&amp;
            (attrs.inner.hints == <a href="shared_pseudocode.html#global_MemHint_RWA" title="">MemHint_RWA</a>) &amp;&amp;
            (!attrs.inner.transient)           &amp;&amp;
            (attrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>)  &amp;&amp;
            (attrs.outer.hints == <a href="shared_pseudocode.html#global_MemHint_RWA" title="">MemHint_RWA</a>) &amp;&amp;
            (!attrs.outer.transient));
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.IsWBShareable"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/IsWBShareable</h3>
      <p class="pseudocode">// IsWBShareable()
// ===============
// Determines whether the given memory attributes are iWBoWB Shareable

func <a id="func_IsWBShareable_1"/>IsWBShareable(memattrs : MemoryAttributes) =&gt; boolean
begin

    return (memattrs.memtype == MemType_Normal &amp;&amp;
            memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> &amp;&amp;
            memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> &amp;&amp;
            memattrs.shareability IN {<a href="shared_pseudocode.html#enum_Shareability_ISH" title="">Shareability_ISH</a>, <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>});
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.NormalNCMemAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/NormalNCMemAttr</h3>
      <p class="pseudocode">// NormalNCMemAttr()
// =================
// Normal Non-cacheable memory attributes

func <a id="func_NormalNCMemAttr_0"/>NormalNCMemAttr() =&gt; MemoryAttributes
begin
    var non_cacheable : <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a>;
    non_cacheable.attrs = <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>;

    var nc_memattrs : MemoryAttributes;
    nc_memattrs.memtype      = MemType_Normal;
    nc_memattrs.outer        = non_cacheable;
    nc_memattrs.inner        = non_cacheable;
    nc_memattrs.shareability = <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
    nc_memattrs.tags         = <a href="shared_pseudocode.html#enum_MemTag_Untagged" title="">MemTag_Untagged</a>;
    nc_memattrs.notagaccess  = FALSE;

    return nc_memattrs;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S1ConstrainUnpredictableRESMAIR"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S1ConstrainUnpredictableRESMAIR</h3>
      <p class="pseudocode">// S1ConstrainUnpredictableRESMAIR()
// =================================
// Determine whether a reserved value occupies MAIR_ELx.AttrN

func <a id="func_S1ConstrainUnpredictableRESMAIR_2"/>S1ConstrainUnpredictableRESMAIR(attr : bits(8), s1aarch64 : boolean) =&gt; boolean
begin
    case attr of
        when '0000xx01' =&gt; return !(s1aarch64 &amp;&amp; IsFeatureImplemented(FEAT_XS));
        when '0000xxxx' =&gt; return attr[1:0] != '00';
        when '01000000' =&gt; return !(s1aarch64 &amp;&amp; IsFeatureImplemented(FEAT_XS));
        when '10100000' =&gt; return !(s1aarch64 &amp;&amp; IsFeatureImplemented(FEAT_XS));
        when '11110000' =&gt; return !(s1aarch64 &amp;&amp; IsFeatureImplemented(FEAT_MTE2));
        when 'xxxx0000' =&gt; return TRUE;
        otherwise       =&gt; return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S1DecodeMemAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S1DecodeMemAttrs</h3>
      <p class="pseudocode">// S1DecodeMemAttrs()
// ==================
// Decode MAIR-format memory attributes assigned in stage 1

func <a id="func_S1DecodeMemAttrs_3"/>S1DecodeMemAttrs(attr_in : bits(8), sh : bits(2), s1aarch64 : boolean) =&gt; MemoryAttributes
begin
    var attr : bits(8) = attr_in;
    if <a href="shared_pseudocode.html#func_S1ConstrainUnpredictableRESMAIR_2" title="">S1ConstrainUnpredictableRESMAIR</a>(attr, s1aarch64) then
        // Map reserved encodings to an allocated encoding
        (-, attr) = ConstrainUnpredictableBits{8}(<a href="shared_pseudocode.html#enum_Unpredictable_RESMAIR" title="">Unpredictable_RESMAIR</a>);
    end;

    var memattrs : MemoryAttributes;
    case attr of
        when '0000xxxx' =&gt; // Device memory
            memattrs.memtype = MemType_Device;
            memattrs.device  = <a href="shared_pseudocode.html#func_DecodeDevice_1" title="">DecodeDevice</a>(attr[3:2]);
            memattrs.xs      = if s1aarch64 then NOT attr[0] else '1';
        when '01000000' =&gt;
            assert s1aarch64 &amp;&amp; IsFeatureImplemented(FEAT_XS);
            memattrs.memtype = MemType_Normal;
            memattrs.outer.attrs = <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>;
            memattrs.inner.attrs = <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>;
            memattrs.xs          = '0';
        when '10100000' =&gt;
            assert s1aarch64 &amp;&amp; IsFeatureImplemented(FEAT_XS);
            memattrs.memtype = MemType_Normal;
            memattrs.outer.attrs     = <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a>;
            memattrs.outer.hints     = <a href="shared_pseudocode.html#global_MemHint_RA" title="">MemHint_RA</a>;
            memattrs.outer.transient = FALSE;
            memattrs.inner.attrs     = <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a>;
            memattrs.inner.hints     = <a href="shared_pseudocode.html#global_MemHint_RA" title="">MemHint_RA</a>;
            memattrs.inner.transient = FALSE;
            memattrs.xs              = '0';
        when '11110000' =&gt; // Tagged memory
            assert s1aarch64 &amp;&amp; IsFeatureImplemented(FEAT_MTE2);
            memattrs.memtype = MemType_Normal;
            memattrs.outer.attrs     = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;
            memattrs.outer.hints     = <a href="shared_pseudocode.html#global_MemHint_RWA" title="">MemHint_RWA</a>;
            memattrs.outer.transient = FALSE;
            memattrs.inner.attrs     = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;
            memattrs.inner.hints     = <a href="shared_pseudocode.html#global_MemHint_RWA" title="">MemHint_RWA</a>;
            memattrs.inner.transient = FALSE;
            memattrs.xs              = '0';
        otherwise =&gt;
            memattrs.memtype = MemType_Normal;
            memattrs.outer   = <a href="shared_pseudocode.html#func_DecodeLDFAttr_1" title="">DecodeLDFAttr</a>(attr[7:4]);
            memattrs.inner   = <a href="shared_pseudocode.html#func_DecodeLDFAttr_1" title="">DecodeLDFAttr</a>(attr[3:0]);

            if (memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> &amp;&amp;
                    memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>) then
                memattrs.xs = '0';
            else
                memattrs.xs = '1';
            end;
    end;

    memattrs.shareability = <a href="shared_pseudocode.html#func_DecodeShareability_1" title="">DecodeShareability</a>(sh);
    memattrs.tags = <a href="shared_pseudocode.html#enum_MemTag_Untagged" title="">MemTag_Untagged</a>;
    memattrs.notagaccess = FALSE;

    return memattrs;
end;

// S1DecodeMemAttrs()
// ==================
// Decode MAIR-format memory attributes assigned in stage 1

func <a id="func_S1DecodeMemAttrs_5"/>S1DecodeMemAttrs(attr_in : bits(8), sh : bits(2), s1aarch64 : boolean,
                      walkparams : <a href="shared_pseudocode.html#type_S1TTWParams" title="">S1TTWParams</a>, acctype : <a href="shared_pseudocode.html#type_AccessType" title="">AccessType</a>) =&gt; MemoryAttributes
begin
    var memattrs : MemoryAttributes = <a href="shared_pseudocode.html#func_S1DecodeMemAttrs_3" title="">S1DecodeMemAttrs</a>(attr_in, sh, s1aarch64);
    if s1aarch64 &amp;&amp; attr_in == '11110000' then
        memattrs.tags = <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a>;
    elsif IsFeatureImplemented(FEAT_MTE_CANONICAL_TAGS) &amp;&amp; s1aarch64 &amp;&amp; walkparams.mtx == '1' then
        memattrs.tags = <a href="shared_pseudocode.html#enum_MemTag_CanonicallyTagged" title="">MemTag_CanonicallyTagged</a>;
    end;

    return memattrs;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2CombineS1AttrHints"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2CombineS1AttrHints</h3>
      <p class="pseudocode">// S2CombineS1AttrHints()
// ======================
// Determine resultant Normal memory cacheability and allocation hints from
// combining stage 1 Normal memory attributes and stage 2 cacheability attributes.

func <a id="func_S2CombineS1AttrHints_2"/>S2CombineS1AttrHints(s1_attrhints : <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a>, s2_attrhints : <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a>) =&gt; <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a>
begin
    var attrhints : <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a>;

    if s1_attrhints.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> || s2_attrhints.attrs == <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> then
        attrhints.attrs = <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>;
    elsif s1_attrhints.attrs == <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a> || s2_attrhints.attrs == <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a> then
        attrhints.attrs = <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a>;
    else
        attrhints.attrs = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;
    end;

    // Stage 2 does not assign any allocation hints
    // Instead, they are inherited from stage 1
    if attrhints.attrs != <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a> then
        attrhints.hints     = s1_attrhints.hints;
        attrhints.transient = s1_attrhints.transient;
    end;

    return attrhints;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2CombineS1Device"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2CombineS1Device</h3>
      <p class="pseudocode">// S2CombineS1Device()
// ===================
// Determine resultant Device type from combining output memory attributes
// in stage 1 and Device attributes in stage 2

func <a id="func_S2CombineS1Device_2"/>S2CombineS1Device(s1_device : <a href="shared_pseudocode.html#type_DeviceType" title="">DeviceType</a>, s2_device : <a href="shared_pseudocode.html#type_DeviceType" title="">DeviceType</a>) =&gt; <a href="shared_pseudocode.html#type_DeviceType" title="">DeviceType</a>
begin
    if s1_device == <a href="shared_pseudocode.html#enum_DeviceType_nGnRnE" title="">DeviceType_nGnRnE</a> || s2_device == <a href="shared_pseudocode.html#enum_DeviceType_nGnRnE" title="">DeviceType_nGnRnE</a> then
        return <a href="shared_pseudocode.html#enum_DeviceType_nGnRnE" title="">DeviceType_nGnRnE</a>;
    elsif s1_device == <a href="shared_pseudocode.html#enum_DeviceType_nGnRE" title="">DeviceType_nGnRE</a> || s2_device == <a href="shared_pseudocode.html#enum_DeviceType_nGnRE" title="">DeviceType_nGnRE</a> then
        return <a href="shared_pseudocode.html#enum_DeviceType_nGnRE" title="">DeviceType_nGnRE</a>;
    elsif s1_device == <a href="shared_pseudocode.html#enum_DeviceType_nGRE" title="">DeviceType_nGRE</a> || s2_device == <a href="shared_pseudocode.html#enum_DeviceType_nGRE" title="">DeviceType_nGRE</a> then
        return <a href="shared_pseudocode.html#enum_DeviceType_nGRE" title="">DeviceType_nGRE</a>;
    else
        return <a href="shared_pseudocode.html#enum_DeviceType_GRE" title="">DeviceType_GRE</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2CombineS1MemAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2CombineS1MemAttrs</h3>
      <p class="pseudocode">// S2CombineS1MemAttrs()
// =====================
// Combine stage 2 with stage 1 memory attributes

func <a id="func_S2CombineS1MemAttrs_3"/>S2CombineS1MemAttrs(s1_memattrs : MemoryAttributes, s2_memattrs : MemoryAttributes,
                         s2aarch64 : boolean) =&gt; MemoryAttributes
begin
    var memattrs : MemoryAttributes;

    if s1_memattrs.memtype == MemType_Device &amp;&amp; s2_memattrs.memtype == MemType_Device then
        memattrs.memtype = MemType_Device;
        memattrs.device  = <a href="shared_pseudocode.html#func_S2CombineS1Device_2" title="">S2CombineS1Device</a>(s1_memattrs.device, s2_memattrs.device);
    elsif s1_memattrs.memtype == MemType_Device then    // S2 Normal, S1 Device
        memattrs = s1_memattrs;
    elsif s2_memattrs.memtype == MemType_Device then    // S2 Device, S1 Normal
        memattrs = s2_memattrs;
    else                                                // S2 Normal, S1 Normal
        memattrs.memtype = MemType_Normal;
        memattrs.inner   = <a href="shared_pseudocode.html#func_S2CombineS1AttrHints_2" title="">S2CombineS1AttrHints</a>(s1_memattrs.inner, s2_memattrs.inner);
        memattrs.outer   = <a href="shared_pseudocode.html#func_S2CombineS1AttrHints_2" title="">S2CombineS1AttrHints</a>(s1_memattrs.outer, s2_memattrs.outer);
    end;

    memattrs.tags = <a href="shared_pseudocode.html#func_S2MemTagType_2" title="">S2MemTagType</a>(memattrs, s1_memattrs.tags);

    if !IsFeatureImplemented(FEAT_MTE_PERM) then
        memattrs.notagaccess = FALSE;
    else
        memattrs.notagaccess = (s2_memattrs.notagaccess &amp;&amp;
                                s1_memattrs.tags == <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a>);
    end;
    memattrs.shareability = <a href="shared_pseudocode.html#func_S2CombineS1Shareability_2" title="">S2CombineS1Shareability</a>(s1_memattrs.shareability,
                                                    s2_memattrs.shareability);

    if (memattrs.memtype == MemType_Normal &amp;&amp;
            memattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> &amp;&amp;
            memattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>) then
        memattrs.xs = '0';
    elsif s2aarch64 then
        memattrs.xs = s2_memattrs.xs AND s1_memattrs.xs;
    else
        memattrs.xs = s1_memattrs.xs;
    end;

    memattrs.shareability = <a href="shared_pseudocode.html#func_EffectiveShareability_1" title="">EffectiveShareability</a>(memattrs);
    return memattrs;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2CombineS1Shareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2CombineS1Shareability</h3>
      <p class="pseudocode">// S2CombineS1Shareability()
// =========================
// Combine stage 2 shareability with stage 1

func <a id="func_S2CombineS1Shareability_2"/>S2CombineS1Shareability(s1_shareability : <a href="shared_pseudocode.html#type_Shareability" title="">Shareability</a>,
                             s2_shareability : <a href="shared_pseudocode.html#type_Shareability" title="">Shareability</a>) =&gt; <a href="shared_pseudocode.html#type_Shareability" title="">Shareability</a>
begin

    if (s1_shareability == <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a> ||
            s2_shareability == <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>) then
        return <a href="shared_pseudocode.html#enum_Shareability_OSH" title="">Shareability_OSH</a>;
    elsif (s1_shareability == <a href="shared_pseudocode.html#enum_Shareability_ISH" title="">Shareability_ISH</a> ||
            s2_shareability == <a href="shared_pseudocode.html#enum_Shareability_ISH" title="">Shareability_ISH</a>) then
        return <a href="shared_pseudocode.html#enum_Shareability_ISH" title="">Shareability_ISH</a>;
    else
        return <a href="shared_pseudocode.html#enum_Shareability_NSH" title="">Shareability_NSH</a>;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2DecodeCacheability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2DecodeCacheability</h3>
      <p class="pseudocode">// S2DecodeCacheability()
// ======================
// Determine the stage 2 cacheability for Normal memory

func <a id="func_S2DecodeCacheability_1"/>S2DecodeCacheability(attr : bits(2)) =&gt; <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a>
begin
    var s2attr : <a href="shared_pseudocode.html#type_MemAttrHints" title="">MemAttrHints</a>;

    case attr of
        when '01' =&gt; s2attr.attrs = <a href="shared_pseudocode.html#global_MemAttr_NC" title="">MemAttr_NC</a>;  // Non-cacheable
        when '10' =&gt; s2attr.attrs = <a href="shared_pseudocode.html#global_MemAttr_WT" title="">MemAttr_WT</a>;  // Write-through
        when '11' =&gt; s2attr.attrs = <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>;  // Write-back
        otherwise =&gt; unreachable;
    end;

    // Stage 2 does not assign hints or the transient property
    // They are inherited from stage 1 if the result of the combination allows it
    s2attr.hints     = ARBITRARY : bits(2);
    s2attr.transient = ARBITRARY : boolean;

    return s2attr;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2DecodeMemAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2DecodeMemAttrs</h3>
      <p class="pseudocode">// S2DecodeMemAttrs()
// ==================
// Decode stage 2 memory attributes when FWB is 0

func <a id="func_S2DecodeMemAttrs_3"/>S2DecodeMemAttrs(attr_in : bits(4), sh : bits(2), s2aarch64 : boolean) =&gt; MemoryAttributes
begin
    var memattrs : MemoryAttributes;

    var attr : bits(4);
    if <a href="shared_pseudocode.html#func_S2ResMemAttr_2" title="">S2ResMemAttr</a>(s2aarch64, attr_in) then
        // Map reserved encodings to an allocated encoding
        (-, attr) = ConstrainUnpredictableBits{4}(<a href="shared_pseudocode.html#enum_Unpredictable_S2RESMEMATTR" title="">Unpredictable_S2RESMEMATTR</a>);
    else
        attr = attr_in;
    end;

    case attr of
        when '00xx' =&gt; // Device memory
            memattrs.memtype      = MemType_Device;
            memattrs.device       = <a href="shared_pseudocode.html#func_DecodeDevice_1" title="">DecodeDevice</a>(attr[1:0]);
        when '0100' =&gt; // Normal, Inner+Outer WB cacheable NoTagAccess memory
            assert s2aarch64 &amp;&amp; IsFeatureImplemented(FEAT_MTE_PERM);
            memattrs.memtype      = MemType_Normal;
            memattrs.outer        = <a href="shared_pseudocode.html#func_S2DecodeCacheability_1" title="">S2DecodeCacheability</a>('11'); // Write-back
            memattrs.inner        = <a href="shared_pseudocode.html#func_S2DecodeCacheability_1" title="">S2DecodeCacheability</a>('11'); // Write-back
        otherwise =&gt;   // Normal memory
            memattrs.memtype      = MemType_Normal;
            memattrs.outer        = <a href="shared_pseudocode.html#func_S2DecodeCacheability_1" title="">S2DecodeCacheability</a>(attr[3:2]);
            memattrs.inner        = <a href="shared_pseudocode.html#func_S2DecodeCacheability_1" title="">S2DecodeCacheability</a>(attr[1:0]);
    end;

    memattrs.shareability = <a href="shared_pseudocode.html#func_DecodeShareability_1" title="">DecodeShareability</a>(sh);

    if s2aarch64 &amp;&amp; IsFeatureImplemented(FEAT_MTE_PERM) then
        memattrs.notagaccess = attr == '0100';
    else
        memattrs.notagaccess = FALSE;
    end;

    return memattrs;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2MemTagType"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2MemTagType</h3>
      <p class="pseudocode">// S2MemTagType()
// ==============
// Determine whether the combined output memory attributes of stage 1 and
// stage 2 indicate tagged memory

func <a id="func_S2MemTagType_2"/>S2MemTagType(s2_memattrs : MemoryAttributes, s1_tagtype : <a href="shared_pseudocode.html#type_MemTagType" title="">MemTagType</a>) =&gt; <a href="shared_pseudocode.html#type_MemTagType" title="">MemTagType</a>
begin

    if !IsFeatureImplemented(FEAT_MTE2) then
        return <a href="shared_pseudocode.html#enum_MemTag_Untagged" title="">MemTag_Untagged</a>;
    end;

    if s1_tagtype == <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a> &amp;&amp; <a href="shared_pseudocode.html#func_IsTaggableMemAttr_1" title="">IsTaggableMemAttr</a>(s2_memattrs) then
        return <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a>;
    end;

    // Return what stage 1 asked for if we can, otherwise Untagged.
    if s1_tagtype != <a href="shared_pseudocode.html#enum_MemTag_AllocationTagged" title="">MemTag_AllocationTagged</a> then
        return s1_tagtype;
    end;

    return <a href="shared_pseudocode.html#enum_MemTag_Untagged" title="">MemTag_Untagged</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2ResMemAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2ResMemAttr</h3>
      <p class="pseudocode">// S2ResMemAttr()
// ==============
// Determine whether a reserved value occupies stage 2 MemAttr field when FWB is 0

func <a id="func_S2ResMemAttr_2"/>S2ResMemAttr(s2aarch64 : boolean, attr : bits(4)) =&gt; boolean
begin
    case attr of
        when '0100' =&gt; return !(s2aarch64 &amp;&amp; IsFeatureImplemented(FEAT_MTE_PERM));
        when '1x00' =&gt; return TRUE;
        otherwise   =&gt; return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.WalkMemAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/WalkMemAttrs</h3>
      <p class="pseudocode">// WalkMemAttrs()
// ==============
// Retrieve memory attributes of translation table walk

func <a id="func_WalkMemAttrs_3"/>WalkMemAttrs(sh : bits(2), irgn : bits(2), orgn : bits(2)) =&gt; MemoryAttributes
begin
    var walkmemattrs : MemoryAttributes;

    walkmemattrs.memtype      = MemType_Normal;
    walkmemattrs.shareability = <a href="shared_pseudocode.html#func_DecodeShareability_1" title="">DecodeShareability</a>(sh);
    walkmemattrs.inner        = <a href="shared_pseudocode.html#func_DecodeSDFAttr_1" title="">DecodeSDFAttr</a>(irgn);
    walkmemattrs.outer        = <a href="shared_pseudocode.html#func_DecodeSDFAttr_1" title="">DecodeSDFAttr</a>(orgn);
    walkmemattrs.tags         = <a href="shared_pseudocode.html#enum_MemTag_Untagged" title="">MemTag_Untagged</a>;
    if (walkmemattrs.inner.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a> &amp;&amp;
            walkmemattrs.outer.attrs == <a href="shared_pseudocode.html#global_MemAttr_WB" title="">MemAttr_WB</a>) then
        walkmemattrs.xs = '0';
    else
        walkmemattrs.xs = '1';
    end;
    walkmemattrs.notagaccess = FALSE;

    return walkmemattrs;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.faults.AlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/faults/AlignmentFault</h3>
      <p class="pseudocode">// AlignmentFault()
// ================
// Return a fault record indicating an Alignment fault not due to memory type has occured
// for a specific access

func <a id="func_AlignmentFault_2"/>AlignmentFault(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, vaddress : bits(64)) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, vaddress);
    fault.statuscode        = <a href="shared_pseudocode.html#enum_Fault_Alignment" title="">Fault_Alignment</a>;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.faults.ExclusiveFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/faults/ExclusiveFault</h3>
      <p class="pseudocode">// ExclusiveFault()
// ================
// Return a fault record indicating a fault for an unsupported Exclusive access

func <a id="func_ExclusiveFault_2"/>ExclusiveFault(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, vaddress : bits(64)) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_2" title="">NoFault</a>(accdesc, vaddress);
    fault.statuscode        = <a href="shared_pseudocode.html#enum_Fault_Exclusive" title="">Fault_Exclusive</a>;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.faults.NoFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/faults/NoFault</h3>
      <p class="pseudocode">// NoFault()
// =========
// Return a clear fault record indicating no faults have occured

func <a id="func_NoFault_0"/>NoFault() =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>;

    fault.vaddress = ARBITRARY : bits(64);
    fault.statuscode  = <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
    fault.accessdesc  = ARBITRARY : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;
    fault.dirtybit    = FALSE;
    fault.overlay     = FALSE;
    fault.toplevel    = FALSE;
    fault.assuredonly = FALSE;
    fault.s1tagnotdata = FALSE;
    fault.tagaccess    = FALSE;
    fault.gpcfs2walk   = FALSE;
    fault.gpcf         = <a href="shared_pseudocode.html#func_GPCNoFault_0" title="">GPCNoFault</a>();
    fault.hdbssf       = FALSE;

    return fault;
end;

// NoFault()
// =========
// Return a clear fault record indicating no faults have occured for a specific access

func <a id="func_NoFault_1"/>NoFault(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>;

    fault.statuscode  = <a href="shared_pseudocode.html#enum_Fault_None" title="">Fault_None</a>;
    fault.accessdesc  = accdesc;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;
    fault.dirtybit    = FALSE;
    fault.overlay     = FALSE;
    fault.toplevel    = FALSE;
    fault.assuredonly = FALSE;
    fault.s1tagnotdata = FALSE;
    fault.tagaccess   = FALSE;
    fault.write       = !accdesc.read &amp;&amp; accdesc.write;
    fault.gpcfs2walk  = FALSE;
    fault.gpcf        = <a href="shared_pseudocode.html#func_GPCNoFault_0" title="">GPCNoFault</a>();
    fault.hdbssf      = FALSE;

    return fault;
end;

// NoFault()
// =========

func <a id="func_NoFault_2"/>NoFault(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>, vaddress : bits(64)) =&gt; <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>
begin
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = <a href="shared_pseudocode.html#func_NoFault_0" title="">NoFault</a>();
    fault.accessdesc  = accdesc;
    fault.write       = !accdesc.read &amp;&amp; accdesc.write;
    fault.vaddress    = vaddress;

    return fault;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.AbovePPS"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/AbovePPS</h3>
      <p class="pseudocode">// AbovePPS()
// ==========
// Returns TRUE if an address exceeds the range configured in GPCCR_EL3.PPS.

func <a id="func_AbovePPS_1"/>AbovePPS(address : bits(56)) =&gt; boolean
begin
    let pps : integer{} = DecodePPS();
    if pps &gt;= 56 then
        return FALSE;
    end;

    return !IsZero(address[55:pps]);
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodeGPTBlock"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodeGPTBlock</h3>
      <p class="pseudocode">// DecodeGPTBlock()
// ================
// Decode a GPT Block descriptor.

func <a id="func_DecodeGPTBlock_2"/>DecodeGPTBlock(pgs : <a href="shared_pseudocode.html#type_PGSe" title="">PGSe</a>, gpt_entry : bits(64)) =&gt; GPTEntry
begin
    assert gpt_entry[3:0] == <a href="shared_pseudocode.html#global_GPT_Block" title="">GPT_Block</a>;
    var result : GPTEntry;
    result.gpi   = gpt_entry[7:4];
    result.level = 0;

    // GPT information from a level 0 GPT Block descriptor is permitted
    // to be cached in a TLB as though the Block is a contiguous region
    // of granules each of the size configured in GPCCR_EL3.PGS.
    case pgs of
        when <a href="shared_pseudocode.html#enum_PGS_4KB" title="">PGS_4KB</a>  =&gt; result.size = GPTRange_4KB;
        when <a href="shared_pseudocode.html#enum_PGS_16KB" title="">PGS_16KB</a> =&gt; result.size = GPTRange_16KB;
        when <a href="shared_pseudocode.html#enum_PGS_64KB" title="">PGS_64KB</a> =&gt; result.size = GPTRange_64KB;
        otherwise     =&gt; unreachable;
    end;
    result.contig_size = GPTL0Size();

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodeGPTContiguous"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodeGPTContiguous</h3>
      <p class="pseudocode">// DecodeGPTContiguous()
// =====================
// Decode a GPT Contiguous descriptor.

func <a id="func_DecodeGPTContiguous_2"/>DecodeGPTContiguous(pgs : <a href="shared_pseudocode.html#type_PGSe" title="">PGSe</a>, gpt_entry : bits(64)) =&gt; GPTEntry
begin
    assert gpt_entry[3:0] == <a href="shared_pseudocode.html#global_GPT_Contig" title="">GPT_Contig</a>;
    var result : GPTEntry;
    result.gpi = gpt_entry[7:4];

    case pgs of
        when <a href="shared_pseudocode.html#enum_PGS_4KB" title="">PGS_4KB</a>  =&gt; result.size = GPTRange_4KB;
        when <a href="shared_pseudocode.html#enum_PGS_16KB" title="">PGS_16KB</a> =&gt; result.size = GPTRange_16KB;
        when <a href="shared_pseudocode.html#enum_PGS_64KB" title="">PGS_64KB</a> =&gt; result.size = GPTRange_64KB;
        otherwise     =&gt; unreachable;
    end;

    case gpt_entry[9:8] of
        when '01' =&gt; result.contig_size = GPTRange_2MB;
        when '10' =&gt; result.contig_size = GPTRange_32MB;
        when '11' =&gt; result.contig_size = GPTRange_512MB;
        otherwise =&gt; unreachable;
    end;

    result.level = 1;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodeGPTGranules"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodeGPTGranules</h3>
      <p class="pseudocode">// DecodeGPTGranules()
// ===================
// Decode a GPT Granules descriptor.

func <a id="func_DecodeGPTGranules_3"/>DecodeGPTGranules(pgs : <a href="shared_pseudocode.html#type_PGSe" title="">PGSe</a>, index : integer, gpt_entry : bits(64)) =&gt; GPTEntry
begin
    var result : GPTEntry;
    result.gpi = gpt_entry[index*4 +:4];

    case pgs of
        when <a href="shared_pseudocode.html#enum_PGS_4KB" title="">PGS_4KB</a>  =&gt; result.size = GPTRange_4KB;
        when <a href="shared_pseudocode.html#enum_PGS_16KB" title="">PGS_16KB</a> =&gt; result.size = GPTRange_16KB;
        when <a href="shared_pseudocode.html#enum_PGS_64KB" title="">PGS_64KB</a> =&gt; result.size = GPTRange_64KB;
        otherwise     =&gt; unreachable;
    end;

    result.contig_size = result.size; // No contiguity
    result.level = 1;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodeGPTTable"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodeGPTTable</h3>
      <p class="pseudocode">// DecodeGPTTable()
// ================
// Decode a GPT Table descriptor.

func <a id="func_DecodeGPTTable_2"/>DecodeGPTTable(pgs : <a href="shared_pseudocode.html#type_PGSe" title="">PGSe</a>, gpt_entry : bits(64)) =&gt; <a href="shared_pseudocode.html#type_GPTTable" title="">GPTTable</a>
begin
    assert gpt_entry[3:0] == <a href="shared_pseudocode.html#global_GPT_Table" title="">GPT_Table</a>;
    var result : <a href="shared_pseudocode.html#type_GPTTable" title="">GPTTable</a>;

    case pgs of
        when <a href="shared_pseudocode.html#enum_PGS_4KB" title="">PGS_4KB</a>  =&gt; result.address = gpt_entry[55:17]::Zeros{17};
        when <a href="shared_pseudocode.html#enum_PGS_16KB" title="">PGS_16KB</a> =&gt; result.address = gpt_entry[55:15]::Zeros{15};
        when <a href="shared_pseudocode.html#enum_PGS_64KB" title="">PGS_64KB</a> =&gt; result.address = gpt_entry[55:13]::Zeros{13};
        otherwise =&gt; unreachable;
    end;

    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodePGS"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodePGS</h3>
      <p class="pseudocode">// DecodePGS()
// ===========

func <a id="func_DecodePGS_1"/>DecodePGS(pgs : bits(2)) =&gt; <a href="shared_pseudocode.html#type_PGSe" title="">PGSe</a>
begin
    case pgs of
        when '00' =&gt; return <a href="shared_pseudocode.html#enum_PGS_4KB" title="">PGS_4KB</a>;
        when '10' =&gt; return <a href="shared_pseudocode.html#enum_PGS_16KB" title="">PGS_16KB</a>;
        when '01' =&gt; return <a href="shared_pseudocode.html#enum_PGS_64KB" title="">PGS_64KB</a>;
        otherwise =&gt; unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodePGSRange"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodePGSRange</h3>
      <p class="pseudocode">// DecodePGSRange()
// ================

func DecodePGSRange(pgs : PGSe) =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    case pgs of
        when PGS_4KB  =&gt; return GPTRange_4KB;
        when PGS_16KB =&gt; return GPTRange_16KB;
        when PGS_64KB =&gt; return GPTRange_64KB;
        otherwise     =&gt; unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodePPS"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodePPS</h3>
      <p class="pseudocode">// DecodePPS()
// ===========
// Size of region protected by the GPT, in bits.

func DecodePPS() =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    case GPCCR_EL3().[PPS3, PPS] of
        when '0000' =&gt; return 32;
        when '0001' =&gt; return 36;
        when '0010' =&gt; return 40;
        when '0011' =&gt; return 42;
        when '0100' =&gt; return 44;
        when '0101' =&gt; return 48;
        when '0110' =&gt; return 52;
        when '0111' =&gt; assert IsFeatureImplemented(FEAT_RME_GPC3); return 56;
        when '1000' =&gt; assert IsFeatureImplemented(FEAT_RME_GPC3); return 46;
        when '1001' =&gt; assert IsFeatureImplemented(FEAT_RME_GPC3); return 47;
        otherwise =&gt; unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPCBW_EL3BWSTRIDEValid"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPCBW_EL3BWSTRIDEValid</h3>
      <p class="pseudocode">// GPCBW_EL3BWSTRIDEValid()
// ========================
// Returns whether the current GPCBW_EL3.BWSTRIDE value is valid

func <a id="func_GPCBW_EL3BWSTRIDEValid_0"/>GPCBW_EL3BWSTRIDEValid() =&gt; boolean
begin
    assert IsFeatureImplemented(FEAT_RME_GPC3);
    return GPCBW_EL3().BWSTRIDE IN {
        '00000',
        '00010',
        '00100',
        '00110',
        '00111',
        '01000',
        '01001',
        '01010',
        '10000'
    };
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPCFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPCFault</h3>
      <p class="pseudocode">// GPCFault()
// ==========
// Constructs and returns a GPCF

func <a id="func_GPCFault_2"/>GPCFault(gpf : <a href="shared_pseudocode.html#type_GPCF" title="">GPCF</a>, level : integer) =&gt; <a href="shared_pseudocode.html#type_GPCFRecord" title="">GPCFRecord</a>
begin
    var fault : <a href="shared_pseudocode.html#type_GPCFRecord" title="">GPCFRecord</a>;
    fault.gpf   = gpf;
    fault.level = level;
    return fault;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPCNoFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPCNoFault</h3>
      <p class="pseudocode">// GPCNoFault()
// ============
// Returns the default properties of a GPCF that does not represent a fault

func <a id="func_GPCNoFault_0"/>GPCNoFault() =&gt; <a href="shared_pseudocode.html#type_GPCFRecord" title="">GPCFRecord</a>
begin
    var result : <a href="shared_pseudocode.html#type_GPCFRecord" title="">GPCFRecord</a>;
    result.gpf = <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a>;
    return result;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPCRegistersConsistent"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPCRegistersConsistent</h3>
      <p class="pseudocode">// GPCRegistersConsistent()
// ========================
// Returns whether the GPT registers are configured correctly.
// This returns false if any fields select a Reserved value.

func <a id="func_GPCRegistersConsistent_0"/>GPCRegistersConsistent() =&gt; boolean
begin
    // Check for Reserved register values
    if IsFeatureImplemented(FEAT_RME_GPC3) then
        if  ! GPCCR_EL3().[PPS3, PPS] IN {'0xxx', '100x'} then
            return FALSE;
        end;

        if GPCCR_EL3().GPCBW == '1' then
            if ! GPCBW_EL3().BWSIZE IN {'00x', '1x0', '010'} then
                return FALSE;
            end;

            if !<a href="shared_pseudocode.html#func_GPCBW_EL3BWSTRIDEValid_0" title="">GPCBW_EL3BWSTRIDEValid</a>() then
                return FALSE;
            end;

            let bwstride : integer = 1 &lt;&lt; (40 + UInt(GPCBW_EL3().BWSTRIDE));
            let bwaddr : integer = UInt(GPCBW_EL3().BWADDR) &lt;&lt; 30;
            if bwstride &lt;= bwaddr then
                return FALSE;
            end;

            if !IsAlignedSize{26}(GPCBW_EL3().BWADDR, 1 &lt;&lt; UInt(GPCBW_EL3().BWSIZE)) then
                return FALSE;
            end;
        end;
    else
        if GPCCR_EL3().PPS == '111' then
            return FALSE;
        end;
    end;

    if DecodePPS() &gt; AArch64_PAMax() then
        return FALSE;
    end;
    if GPCCR_EL3().PGS == '11' then
        return FALSE;
    end;
    if GPCCR_EL3().SH == '01' then
        return FALSE;
    end;

    // Inner and Outer Non-cacheable requires Outer Shareable
    if GPCCR_EL3().[ORGN, IRGN] == '0000' &amp;&amp; GPCCR_EL3().SH != '10' then
        return FALSE;
    end;

    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPICheck"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPICheck</h3>
      <p class="pseudocode">// GPICheck()
// ==========
// Returns whether an access to a given physical address space is permitted
// given the configured GPI value.
// paspace: Physical address space of the access
// gpi: Value read from GPT for the access
// ss: Security state of the access

func <a id="func_GPICheck_3"/>GPICheck(paspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>, gpi : bits(4), ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>) =&gt; boolean
begin
    case gpi of
        when <a href="shared_pseudocode.html#global_GPT_NoAccess" title="">GPT_NoAccess</a> =&gt;
            return FALSE;
        when <a href="shared_pseudocode.html#global_GPT_Secure" title="">GPT_Secure</a> =&gt;
            assert IsFeatureImplemented(FEAT_SEL2);
            return paspace == <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#global_GPT_NonSecure" title="">GPT_NonSecure</a> =&gt;
            return paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#global_GPT_Root" title="">GPT_Root</a> =&gt;
            return paspace == <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>;
        when <a href="shared_pseudocode.html#global_GPT_Realm" title="">GPT_Realm</a> =&gt;
            return paspace == <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>;
        when <a href="shared_pseudocode.html#global_GPT_NonSecureOnly" title="">GPT_NonSecureOnly</a> =&gt;
            assert IsFeatureImplemented(FEAT_RME_GPC2);
            return paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> &amp;&amp; (ss IN {<a href="shared_pseudocode.html#enum_SS_Root" title="">SS_Root</a>, <a href="shared_pseudocode.html#enum_SS_NonSecure" title="">SS_NonSecure</a>});
        when <a href="shared_pseudocode.html#global_GPT_SystemAgent" title="">GPT_SystemAgent</a> =&gt;
            assert IsFeatureImplemented(FEAT_RME_GDI);
            return paspace == <a href="shared_pseudocode.html#enum_PAS_SystemAgent" title="">PAS_SystemAgent</a>;
        when <a href="shared_pseudocode.html#global_GPT_NonSecureProtected" title="">GPT_NonSecureProtected</a> =&gt;
            assert IsFeatureImplemented(FEAT_RME_GDI);
            return paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecureProtected" title="">PAS_NonSecureProtected</a>;
        when <a href="shared_pseudocode.html#global_GPT_NA6" title="">GPT_NA6</a> =&gt;
            assert IsFeatureImplemented(FEAT_RME_GDI);
            return FALSE;
        when <a href="shared_pseudocode.html#global_GPT_NA7" title="">GPT_NA7</a> =&gt;
            assert IsFeatureImplemented(FEAT_RME_GDI);
            return FALSE;
        when <a href="shared_pseudocode.html#global_GPT_Any" title="">GPT_Any</a> =&gt;
            return TRUE;
        otherwise =&gt;
            unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPIIndex"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPIIndex</h3>
      <p class="pseudocode">// GPIIndex()
// ==========

func <a id="func_GPIIndex_1"/>GPIIndex(pa : bits(56)) =&gt; integer
begin
    case <a href="shared_pseudocode.html#func_DecodePGS_1" title="">DecodePGS</a>(GPCCR_EL3().PGS) of
        when <a href="shared_pseudocode.html#enum_PGS_4KB" title="">PGS_4KB</a>  =&gt; return UInt(pa[15:12]);
        when <a href="shared_pseudocode.html#enum_PGS_16KB" title="">PGS_16KB</a> =&gt; return UInt(pa[17:14]);
        when <a href="shared_pseudocode.html#enum_PGS_64KB" title="">PGS_64KB</a> =&gt; return UInt(pa[19:16]);
        otherwise     =&gt; unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPIValid"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPIValid</h3>
      <p class="pseudocode">// GPIValid()
// ==========
// Returns whether a given value is a valid encoding for a GPI value

func <a id="func_GPIValid_1"/>GPIValid(gpi : bits(4)) =&gt; boolean
begin
    case gpi of
        when <a href="shared_pseudocode.html#global_GPT_NoAccess" title="">GPT_NoAccess</a> =&gt;
            return TRUE;
        when <a href="shared_pseudocode.html#global_GPT_NonSecureProtected" title="">GPT_NonSecureProtected</a> =&gt;
            return IsFeatureImplemented(FEAT_RME_GDI) &amp;&amp; GPCCR_EL3().NSP == '1';
        when <a href="shared_pseudocode.html#global_GPT_SystemAgent" title="">GPT_SystemAgent</a> =&gt;
            return IsFeatureImplemented(FEAT_RME_GDI) &amp;&amp; GPCCR_EL3().SA  == '1';
        when <a href="shared_pseudocode.html#global_GPT_NA6" title="">GPT_NA6</a> =&gt;
            return IsFeatureImplemented(FEAT_RME_GDI) &amp;&amp; GPCCR_EL3().NA6 == '1';
        when <a href="shared_pseudocode.html#global_GPT_NA7" title="">GPT_NA7</a> =&gt;
            return IsFeatureImplemented(FEAT_RME_GDI) &amp;&amp; GPCCR_EL3().NA7 == '1';
        when <a href="shared_pseudocode.html#global_GPT_Secure" title="">GPT_Secure</a> =&gt;
            return IsFeatureImplemented(FEAT_SEL2);
        when <a href="shared_pseudocode.html#global_GPT_NonSecure" title="">GPT_NonSecure</a> =&gt;
            return TRUE;
        when <a href="shared_pseudocode.html#global_GPT_Realm" title="">GPT_Realm</a> =&gt;
            return TRUE;
        when <a href="shared_pseudocode.html#global_GPT_Root" title="">GPT_Root</a> =&gt;
            return TRUE;
        when <a href="shared_pseudocode.html#global_GPT_NonSecureOnly" title="">GPT_NonSecureOnly</a> =&gt;
            return IsFeatureImplemented(FEAT_RME_GPC2) &amp;&amp; GPCCR_EL3().NSO == '1';
        when <a href="shared_pseudocode.html#global_GPT_Any" title="">GPT_Any</a> =&gt;
            return TRUE;
        otherwise =&gt;
            return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPT"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPT</h3>
      <p class="pseudocode">// GPT dimensions
// ==============

constant GPTRange_4KB : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>   = 12;

constant GPTRange_16KB : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>  = 14;

constant GPTRange_64KB : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>  = 16;

constant GPTRange_2MB : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>   = 21;

constant GPTRange_32MB : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>  = 25;

constant GPTRange_512MB : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = 29;

constant GPTRange_1GB : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>   = 30;

constant GPTRange_16GB : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>  = 34;

constant GPTRange_64GB : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>  = 36;

constant GPTRange_512GB : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = 39;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTBlockDescriptorValid"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTBlockDescriptorValid</h3>
      <p class="pseudocode">// GPTBlockDescriptorValid()
// =========================
// Returns TRUE if the given GPT Block descriptor is valid, and FALSE otherwise.

func <a id="func_GPTBlockDescriptorValid_1"/>GPTBlockDescriptorValid(level_0_entry : bits(64)) =&gt; boolean
begin
    assert level_0_entry[3:0] == <a href="shared_pseudocode.html#global_GPT_Block" title="">GPT_Block</a>;
    return IsZero(level_0_entry[63:8]) &amp;&amp; <a href="shared_pseudocode.html#func_GPIValid_1" title="">GPIValid</a>(level_0_entry[7:4]);
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTContigDescriptorValid"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTContigDescriptorValid</h3>
      <p class="pseudocode">// GPTContigDescriptorValid()
// ==========================
// Returns TRUE if the given GPT Contiguous descriptor is valid, and FALSE otherwise.

func <a id="func_GPTContigDescriptorValid_1"/>GPTContigDescriptorValid(level_1_entry : bits(64)) =&gt; boolean
begin
    assert level_1_entry[3:0] == <a href="shared_pseudocode.html#global_GPT_Contig" title="">GPT_Contig</a>;
    return (IsZero(level_1_entry[63:10]) &amp;&amp;
            !IsZero(level_1_entry[9:8])  &amp;&amp;
            <a href="shared_pseudocode.html#func_GPIValid_1" title="">GPIValid</a>(level_1_entry[7:4]));
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTEntry"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTEntry</h3>
      <p class="pseudocode">// GPTEntry
// ========

type GPTEntry of record {
    gpi : bits(4),               // GPI value for this region
    size : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>,          // Region size
    contig_size : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>,   // Contiguous region size
    level : integer,             // Level of GPT lookup
    pa : bits(56)        // PA uniquely identifying the GPT entry

};</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTGranulesDescriptorValid"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTGranulesDescriptorValid</h3>
      <p class="pseudocode">// GPTGranulesDescriptorValid()
// ============================
// Returns TRUE if the given GPT Granules descriptor is valid, and FALSE otherwise.

func <a id="func_GPTGranulesDescriptorValid_1"/>GPTGranulesDescriptorValid(level_1_entry : bits(64)) =&gt; boolean
begin
    for i = 0 to 15 do
        if !<a href="shared_pseudocode.html#func_GPIValid_1" title="">GPIValid</a>(level_1_entry[i*4 +:4]) then
            return FALSE;
        end;
    end;
    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTL0Size"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTL0Size</h3>
      <p class="pseudocode">// GPTL0Size()
// ===========
// Returns number of bits covered by a level 0 GPT entry

func GPTL0Size() =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    case GPCCR_EL3().L0GPTSZ of
        when '0000' =&gt; return GPTRange_1GB;
        when '0100' =&gt; return GPTRange_16GB;
        when '0110' =&gt; return GPTRange_64GB;
        when '1001' =&gt; return GPTRange_512GB;
        otherwise   =&gt; unreachable;
    end;
    return 30;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTLevel0EntryValid"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTLevel0EntryValid</h3>
      <p class="pseudocode">// GPTLevel0EntryValid()
// =====================
// Returns TRUE if the given level 0 gpt descriptor is valid, and FALSE otherwise.

func <a id="func_GPTLevel0EntryValid_1"/>GPTLevel0EntryValid(gpt_entry : bits(64)) =&gt; boolean
begin
    case gpt_entry[3:0] of
        when <a href="shared_pseudocode.html#global_GPT_Block" title="">GPT_Block</a> =&gt; return <a href="shared_pseudocode.html#func_GPTBlockDescriptorValid_1" title="">GPTBlockDescriptorValid</a>(gpt_entry);
        when <a href="shared_pseudocode.html#global_GPT_Table" title="">GPT_Table</a> =&gt; return <a href="shared_pseudocode.html#func_GPTTableDescriptorValid_1" title="">GPTTableDescriptorValid</a>(gpt_entry);
        otherwise      =&gt; return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTLevel0Index"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTLevel0Index</h3>
      <p class="pseudocode">// GPTLevel0Index()
// ================
// Compute the level 0 index based on input PA.

func <a id="func_GPTLevel0Index_1"/>GPTLevel0Index(pa : bits(56)) =&gt; integer
begin
    // Input address and index bounds
    let pps : integer{} = DecodePPS();
    let l0sz : integer{} = GPTL0Size();
    if pps &lt;= l0sz then
        return 0;
    end;

    return UInt(pa[pps-1:l0sz]);
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTLevel1EntryValid"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTLevel1EntryValid</h3>
      <p class="pseudocode">// GPTLevel1EntryValid()
// =====================
// Returns TRUE if the given level 1 gpt descriptor is valid, and FALSE otherwise.

func <a id="func_GPTLevel1EntryValid_1"/>GPTLevel1EntryValid(gpt_entry : bits(64)) =&gt; boolean
begin
    case gpt_entry[3:0] of
        when <a href="shared_pseudocode.html#global_GPT_Contig" title="">GPT_Contig</a> =&gt; return <a href="shared_pseudocode.html#func_GPTContigDescriptorValid_1" title="">GPTContigDescriptorValid</a>(gpt_entry);
        otherwise       =&gt; return <a href="shared_pseudocode.html#func_GPTGranulesDescriptorValid_1" title="">GPTGranulesDescriptorValid</a>(gpt_entry);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTLevel1Index"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTLevel1Index</h3>
      <p class="pseudocode">// GPTLevel1Index()
// ================
// Compute the level 1 index based on input PA.

func <a id="func_GPTLevel1Index_1"/>GPTLevel1Index(pa : bits(56)) =&gt; integer
begin
    // Input address and index bounds
    let l0sz : integer{} = GPTL0Size();
    case <a href="shared_pseudocode.html#func_DecodePGS_1" title="">DecodePGS</a>(GPCCR_EL3().PGS) of
        when <a href="shared_pseudocode.html#enum_PGS_4KB" title="">PGS_4KB</a>  =&gt; return UInt(pa[l0sz-1:16]);
        when <a href="shared_pseudocode.html#enum_PGS_16KB" title="">PGS_16KB</a> =&gt; return UInt(pa[l0sz-1:18]);
        when <a href="shared_pseudocode.html#enum_PGS_64KB" title="">PGS_64KB</a> =&gt; return UInt(pa[l0sz-1:20]);
        otherwise     =&gt; unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTTable"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTTable</h3>
      <p class="pseudocode">// GPTTable
// ========

type <a id="type_GPTTable"/>GPTTable of record {
    address : bits(56)   // Base address of next table

};</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTTableDescriptorValid"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTTableDescriptorValid</h3>
      <p class="pseudocode">// GPTTableDescriptorValid()
// =========================
// Returns TRUE if the given GPT Table descriptor is valid, and FALSE otherwise.

func <a id="func_GPTTableDescriptorValid_1"/>GPTTableDescriptorValid(level_0_entry : bits(64)) =&gt; boolean
begin
    assert level_0_entry[3:0] == <a href="shared_pseudocode.html#global_GPT_Table" title="">GPT_Table</a>;
    let l0sz : integer{} = GPTL0Size();
    let pgs : <a href="shared_pseudocode.html#type_PGSe" title="">PGSe</a>       = <a href="shared_pseudocode.html#func_DecodePGS_1" title="">DecodePGS</a>(GPCCR_EL3().PGS);
    let p : integer{}    = DecodePGSRange(pgs);
    return IsZero(level_0_entry[63:52,11:4]) &amp;&amp; IsZero(level_0_entry[(l0sz-p)-2:12]);
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTWalk"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTWalk</h3>
      <p class="pseudocode">// GPTWalk()
// =========
// Get the GPT entry for a given physical address, pa

func GPTWalk(pa : bits(56), accdesc : AccessDescriptor) =&gt; (GPCFRecord, GPTEntry)
begin
    // GPT base address
    var base : bits(56);
    let pgs : PGSe = DecodePGS(GPCCR_EL3().PGS);

    // The level 0 GPT base address is aligned to the greater of:
    // * the size of the level 0 GPT, determined by GPCCR_EL3().[PPS, L0GPTSZ].
    // * 4KB
    base = ZeroExtend{56}(GPTBR_EL3().BADDR::Zeros{12});
    let pps : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>     = DecodePPS();
    let l0sz : integer{}      = GPTL0Size();
    let alignment : integer{} = Max((pps - l0sz) + 3, 12) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    base[alignment-1:0]       = Zeros{alignment};

    let gptaccdesc : AccessDescriptor = CreateAccDescGPTW(accdesc);

    // Access attributes and address for GPT fetches
    var gptaddrdesc : AddressDescriptor;
    gptaddrdesc.memattrs = WalkMemAttrs(GPCCR_EL3().SH, GPCCR_EL3().IRGN, GPCCR_EL3().ORGN);
    gptaddrdesc.fault    = NoFault(gptaccdesc);

    gptaddrdesc.paddress.paspace = PAS_Root;
    gptaddrdesc.paddress.address = base + GPTLevel0Index(pa) * 8;

    // Fetch L0GPT entry
    var level_0_entry : bits(64);
    var memstatus : PhysMemRetStatus;
    (memstatus, level_0_entry) = PhysMemRead{64}(gptaddrdesc, gptaccdesc);
    if IsFault(memstatus) then
        return (GPCFault(GPCF_EABT, 0), ARBITRARY : GPTEntry);
    end;

    if !GPTLevel0EntryValid(level_0_entry) then
        return (GPCFault(GPCF_Walk, 0), ARBITRARY : GPTEntry);
    end;

    var result : GPTEntry;
    var table : GPTTable;
    case level_0_entry[3:0] of
        when GPT_Block =&gt;
            // Decode the GPI value and return that
            result = DecodeGPTBlock(pgs, level_0_entry);
            result.pa = pa;
            return (GPCNoFault(), result);
        when GPT_Table =&gt;
            // Decode the table entry and continue walking
            table = DecodeGPTTable(pgs, level_0_entry);
            // The address must be within the range covered by the GPT
            if AbovePPS(table.address) then
                return (GPCFault(GPCF_AddressSize, 0), ARBITRARY : GPTEntry);
            end;
        otherwise =&gt;
            // An invalid encoding would be caught by GPTLevel0EntryValid()
            unreachable;
    end;

    // Must be a GPT Table entry
    assert level_0_entry[3:0] == GPT_Table;

    // Address of level 1 GPT entry
    let offset : integer = GPTLevel1Index(pa) * 8;

    var level_1_entry : bits(64);

    if IsFeatureImplemented(FEAT_RME_GDI) then
        // When FEAT_RME_GDI is implemented, the descriptor validation checks are performed
        // on a pair of descriptors within a naturally aligned 16-byte region of memory.
        gptaddrdesc.paddress.address = AlignDownSize{56}(table.address + offset, 16);
        var level_1_entry_lower : bits(64);
        (memstatus, level_1_entry_lower) = PhysMemRead{64}(gptaddrdesc, gptaccdesc);
        if IsFault(memstatus) then
            return (GPCFault(GPCF_EABT, 1), ARBITRARY : GPTEntry);
        end;

        gptaddrdesc.paddress.address = gptaddrdesc.paddress.address + 8;
        var level_1_entry_upper : bits(64);
        (memstatus, level_1_entry_upper) = PhysMemRead{64}(gptaddrdesc, gptaccdesc);
        if IsFault(memstatus) then
            return (GPCFault(GPCF_EABT, 1), ARBITRARY : GPTEntry);
        end;

        // An individual GPT descriptor is valid when both descriptors within the pair are valid.
        if (!GPTLevel1EntryValid(level_1_entry_upper) ||
              !GPTLevel1EntryValid(level_1_entry_lower)) then
            return (GPCFault(GPCF_Walk, 1), ARBITRARY : GPTEntry);
        end;

        if offset[3] == '1' then
            level_1_entry = level_1_entry_upper;
        else
            level_1_entry = level_1_entry_lower;
        end;
    else
        gptaddrdesc.paddress.address = table.address + offset;
        // Fetch L1GPT entry
        (memstatus, level_1_entry) = PhysMemRead{64}(gptaddrdesc, gptaccdesc);
        if IsFault(memstatus) then
            return (GPCFault(GPCF_EABT, 1), ARBITRARY : GPTEntry);
        end;

        if !GPTLevel1EntryValid(level_1_entry) then
            return (GPCFault(GPCF_Walk, 1), ARBITRARY : GPTEntry);
        end;
    end;

    case level_1_entry[3:0] of
        when GPT_Contig =&gt;
            result = DecodeGPTContiguous(pgs, level_1_entry);
        otherwise =&gt;
            let gpi_index : integer = GPIIndex(pa);
            result = DecodeGPTGranules(pgs, gpi_index, level_1_entry);
    end;

    result.pa = pa;
    return (GPCNoFault(), result);
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GranuleProtectionCheck"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GranuleProtectionCheck</h3>
      <p class="pseudocode">// GranuleProtectionCheck()
// ========================
// Returns whether a given access is permitted, according to the
// granule protection check.
// addrdesc and accdesc describe the access to be checked.

func <a id="func_GranuleProtectionCheck_2"/>GranuleProtectionCheck(addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>, accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_GPCFRecord" title="">GPCFRecord</a>
begin

    assert IsFeatureImplemented(FEAT_RME);
    // The address to be checked
    let address = addrdesc.paddress;

    // Bypass mode - all accesses pass
    if GPCCR_EL3().GPC == '0' then
        return <a href="shared_pseudocode.html#func_GPCNoFault_0" title="">GPCNoFault</a>();
    end;

    // Configuration consistency check
    if !<a href="shared_pseudocode.html#func_GPCRegistersConsistent_0" title="">GPCRegistersConsistent</a>() then
        return <a href="shared_pseudocode.html#func_GPCFault_2" title="">GPCFault</a>(<a href="shared_pseudocode.html#enum_GPCF_Walk" title="">GPCF_Walk</a>, 0);
    end;

    if IsFeatureImplemented(FEAT_RME_GPC2) then
        var access_disabled : boolean;

        case address.paspace of
            when <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>    =&gt; access_disabled = GPCCR_EL3().SPAD  == '1';
            when <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> =&gt; access_disabled = GPCCR_EL3().NSPAD == '1';
            when <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>     =&gt; access_disabled = GPCCR_EL3().RLPAD == '1';
            when <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>      =&gt; access_disabled = FALSE;
            otherwise          =&gt; unreachable;
        end;

        if access_disabled then
            return <a href="shared_pseudocode.html#func_GPCFault_2" title="">GPCFault</a>(<a href="shared_pseudocode.html#enum_GPCF_Fail" title="">GPCF_Fail</a>, 0);
        end;
    end;

    // Input address size check
    if <a href="shared_pseudocode.html#func_AbovePPS_1" title="">AbovePPS</a>(address.address) then
        if (address.paspace == <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a> ||
              (IsFeatureImplemented(FEAT_RME_GPC2) &amp;&amp; GPCCR_EL3().APPSAA == '1')) then
            return <a href="shared_pseudocode.html#func_GPCNoFault_0" title="">GPCNoFault</a>();
        else
            return <a href="shared_pseudocode.html#func_GPCFault_2" title="">GPCFault</a>(<a href="shared_pseudocode.html#enum_GPCF_Fail" title="">GPCF_Fail</a>, 0);
        end;
    end;

    if (IsFeatureImplemented(FEAT_RME_GPC3) &amp;&amp; GPCCR_EL3().GPCBW == '1' &amp;&amp;
          <a href="shared_pseudocode.html#func_PAWithinGPCBypassWindow_1" title="">PAWithinGPCBypassWindow</a>(address.address)) then
        return <a href="shared_pseudocode.html#func_GPCNoFault_0" title="">GPCNoFault</a>();
    end;

    // GPT base address size check
    let gpt_base : bits(56) = ZeroExtend{}(GPTBR_EL3().BADDR::Zeros{12});
    if <a href="shared_pseudocode.html#func_AbovePPS_1" title="">AbovePPS</a>(gpt_base) then
        return <a href="shared_pseudocode.html#func_GPCFault_2" title="">GPCFault</a>(<a href="shared_pseudocode.html#enum_GPCF_AddressSize" title="">GPCF_AddressSize</a>, 0);
    end;

    // GPT lookup
    var (gpcf, gpt_entry) = GPTWalk(address.address, accdesc);
    if gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> then
        return gpcf;
    end;

    // Check input physical address space against GPI
    let permitted : boolean = <a href="shared_pseudocode.html#func_GPICheck_3" title="">GPICheck</a>(address.paspace, gpt_entry.gpi, accdesc.ss);

    if !permitted then
        gpcf = <a href="shared_pseudocode.html#func_GPCFault_2" title="">GPCFault</a>(<a href="shared_pseudocode.html#enum_GPCF_Fail" title="">GPCF_Fail</a>, gpt_entry.level);
        return gpcf;
    end;

    // Check passed

    return <a href="shared_pseudocode.html#func_GPCNoFault_0" title="">GPCNoFault</a>();
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.IsGranuleProtectionCheckedAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/IsGranuleProtectionCheckedAccess</h3>
      <p class="pseudocode">// IsGranuleProtectionCheckedAccess()
// ==================================
// Check if the access should be subject to Granule protection check returns
// true if it is, false otherwise

func <a id="func_IsGranuleProtectionCheckedAccess_1"/>IsGranuleProtectionCheckedAccess(accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; boolean
begin
    if accdesc.acctype == <a href="shared_pseudocode.html#enum_AccessType_DC" title="">AccessType_DC</a> then
        return ImpDefBool("GPC Fault on DC operations");
    end;

    return TRUE;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.PAWithinGPCBypassWindow"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/PAWithinGPCBypassWindow</h3>
      <p class="pseudocode">// PAWithinGPCBypassWindow()
// =========================
// Check if the supplied address is within a GPC Bypass window.

func <a id="func_PAWithinGPCBypassWindow_1"/>PAWithinGPCBypassWindow(pa_in : bits(56)) =&gt; boolean
begin
    // Only check the top 26 bits as the minimum window size is 1GB
    let pa : bits(26)      = pa_in[55:30];

    let gpcbwl : integer{} = UInt(GPCBW_EL3().BWSIZE);
    let gpcbwu : integer{} = 9 + UInt(GPCBW_EL3().BWSTRIDE);

    return pa[gpcbwu:gpcbwl] == GPCBW_EL3().BWADDR[gpcbwu:gpcbwl];
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.PGS"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/PGS</h3>
      <p class="pseudocode">// PGS
// ===
// Physical granule size

type <a id="type_PGSe"/>PGSe of enumeration {
    <a id="enum_PGS_4KB"/>PGS_4KB,
    <a id="enum_PGS_16KB"/>PGS_16KB,
    <a id="enum_PGS_64KB"/>PGS_64KB
};</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.Table"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/Table</h3>
      <p class="pseudocode">// Table format information
// ========================
// Granule Protection Table constants

constant <a id="global_GPT_NoAccess"/>GPT_NoAccess : bits(4)           = '0000';

constant <a id="global_GPT_Table"/>GPT_Table : bits(4)              = '0011';

constant <a id="global_GPT_Block"/>GPT_Block : bits(4)              = '0001';

constant <a id="global_GPT_Contig"/>GPT_Contig : bits(4)             = '0001';

constant <a id="global_GPT_SystemAgent"/>GPT_SystemAgent : bits(4)        = '0100';

constant <a id="global_GPT_NonSecureProtected"/>GPT_NonSecureProtected : bits(4) = '0101';

constant <a id="global_GPT_NA6"/>GPT_NA6 : bits(4)                = '0110';

constant <a id="global_GPT_NA7"/>GPT_NA7 : bits(4)                = '0111';

constant <a id="global_GPT_Secure"/>GPT_Secure : bits(4)             = '1000';

constant <a id="global_GPT_NonSecure"/>GPT_NonSecure : bits(4)          = '1001';

constant <a id="global_GPT_Root"/>GPT_Root : bits(4)               = '1010';

constant <a id="global_GPT_Realm"/>GPT_Realm : bits(4)              = '1011';

constant <a id="global_GPT_NonSecureOnly"/>GPT_NonSecureOnly : bits(4)      = '1101';

constant <a id="global_GPT_Any"/>GPT_Any : bits(4)                = '1111';</p>
    </div>
    <div class="ps"><a id="shared.translation.translation.S1TranslationRegime"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/translation/S1TranslationRegime</h3>
      <p class="pseudocode">// S1TranslationRegime()
// =====================
// Stage 1 translation regime for the given Exception level

readonly func <a id="func_S1TranslationRegime_1"/>S1TranslationRegime(el : bits(2)) =&gt; bits(2)
begin
    if el != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        return el;

    elsif <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR().NS == '0' then
        return <a href="shared_pseudocode.html#global_EL3" title="">EL3</a>;
    elsif IsFeatureImplemented(FEAT_VHE) &amp;&amp; <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(el) then
        return <a href="shared_pseudocode.html#global_EL2" title="">EL2</a>;
    else
        return <a href="shared_pseudocode.html#global_EL1" title="">EL1</a>;
    end;
end;

// S1TranslationRegime()
// =====================
// Returns the Exception level controlling the current Stage 1 translation regime. For the most
// part this is unused in code because the System register accessors (SCTLR_ELx, etc.) implicitly
// return the correct value.

readonly func <a id="func_S1TranslationRegime_0"/>S1TranslationRegime() =&gt; bits(2)
begin
    return <a href="shared_pseudocode.html#func_S1TranslationRegime_1" title="">S1TranslationRegime</a>(PSTATE.EL);
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.AddressDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/AddressDescriptor</h3>
      <p class="pseudocode">// AddressDescriptor
// =================
// Descriptor used to access the underlying memory array.

type <a id="type_AddressDescriptor"/>AddressDescriptor of record {
    fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>,      // fault.statuscode indicates whether the address is valid
    memattrs : MemoryAttributes,
    paddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>,
    s1assured : boolean,      // Stage 1 Assured Translation Property
    s2fs1mro : boolean,       // Stage 2 MRO permission for Stage 1
    mecid : bits(16),         // FEAT_MEC: Memory Encryption Context ID
    vaddress : bits(64)

};

constant <a id="global_FINAL_LEVEL"/>FINAL_LEVEL : integer = 3;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.ContiguousSize"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/ContiguousSize</h3>
      <p class="pseudocode">// ContiguousSize()
// ================
// Return the number of entries log 2 marking a contiguous output range

func <a id="func_ContiguousSize_3"/>ContiguousSize(d128 : bit, tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>, level : integer) =&gt; integer
begin
    if d128 == '1' then
        case tgx of
            when <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a> =&gt;
                assert level IN {1, 2, 3};
                return if level == 1 then 2 else 4;
            when <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a> =&gt;
                assert level IN {1, 2, 3};
                if level == 1 then
                    return 2;
                elsif level == 2 then
                    return 4;
                else
                    return 6;
                end;
            when <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> =&gt;
                assert level IN {2, 3};
                return if level == 2 then 6 else 4;
        end;
    else
        case tgx of
            when <a href="shared_pseudocode.html#enum_TGx_4KB" title="">TGx_4KB</a> =&gt;
                assert level IN {1, 2, 3};
                return 4;
            when <a href="shared_pseudocode.html#enum_TGx_16KB" title="">TGx_16KB</a> =&gt;
                assert level IN {2, 3};
                return if level == 2 then 5 else 7;
            when <a href="shared_pseudocode.html#enum_TGx_64KB" title="">TGx_64KB</a> =&gt;
                assert level IN {2, 3};
                return 5;
        end;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.CreateAddressDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/CreateAddressDescriptor</h3>
      <p class="pseudocode">// CreateAddressDescriptor()
// =========================
// Set internal members for address descriptor type to valid values

func <a id="func_CreateAddressDescriptor_3"/>CreateAddressDescriptor(pa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>, memattrs : MemoryAttributes,
                             accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>
begin
    var addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;

    addrdesc.paddress = pa;
    addrdesc.memattrs = memattrs;
    addrdesc.fault    = <a href="shared_pseudocode.html#func_NoFault_1" title="">NoFault</a>(accdesc);

    return addrdesc;
end;

// CreateAddressDescriptor()
// =========================
// Set internal members for address descriptor type to valid values

func <a id="func_CreateAddressDescriptor_4"/>CreateAddressDescriptor(va : bits(64), pa : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>,
                             memattrs : MemoryAttributes,
                             accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>) =&gt; <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>
begin
    var addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;

    addrdesc.paddress  = pa;
    addrdesc.vaddress  = va;
    addrdesc.memattrs  = memattrs;
    addrdesc.fault     = <a href="shared_pseudocode.html#func_NoFault_1" title="">NoFault</a>(accdesc);
    addrdesc.s1assured = FALSE;

    return addrdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.CreateFaultyAddressDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/CreateFaultyAddressDescriptor</h3>
      <p class="pseudocode">// CreateFaultyAddressDescriptor()
// ===============================
// Set internal members for address descriptor type with values indicating error

func <a id="func_CreateFaultyAddressDescriptor_1"/>CreateFaultyAddressDescriptor(fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>
begin
    var addrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;

    addrdesc.vaddress = fault.vaddress;
    addrdesc.fault    = fault;

    return addrdesc;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.DecodePASpace"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/DecodePASpace</h3>
      <p class="pseudocode">// DecodePASpace()
// ===============
// Decode the target PA Space

func <a id="func_DecodePASpace_3"/>DecodePASpace(nse2 : bit, nse : bit, ns : bit) =&gt; <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>
begin
    case nse2::nse::ns of
        when '000' =&gt;   return <a href="shared_pseudocode.html#enum_PAS_Secure" title="">PAS_Secure</a>;
        when '001' =&gt;   return <a href="shared_pseudocode.html#enum_PAS_NonSecure" title="">PAS_NonSecure</a>;
        when '010' =&gt;   return <a href="shared_pseudocode.html#enum_PAS_Root" title="">PAS_Root</a>;
        when '011' =&gt;   return <a href="shared_pseudocode.html#enum_PAS_Realm" title="">PAS_Realm</a>;
        when '100' =&gt;   return <a href="shared_pseudocode.html#enum_PAS_SystemAgent" title="">PAS_SystemAgent</a>;
        when '101' =&gt;   return <a href="shared_pseudocode.html#enum_PAS_NonSecureProtected" title="">PAS_NonSecureProtected</a>;
        when '110' =&gt;   return <a href="shared_pseudocode.html#enum_PAS_NA6" title="">PAS_NA6</a>;
        when '111' =&gt;   return <a href="shared_pseudocode.html#enum_PAS_NA7" title="">PAS_NA7</a>;
        otherwise =&gt;    unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.DescriptorType"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/DescriptorType</h3>
      <p class="pseudocode">// DescriptorType
// ==============
// Translation table descriptor formats

type <a id="type_DescriptorType"/>DescriptorType of enumeration {
    <a id="enum_DescriptorType_Table"/>DescriptorType_Table,
    <a id="enum_DescriptorType_Leaf"/>DescriptorType_Leaf,
    <a id="enum_DescriptorType_Invalid"/>DescriptorType_Invalid
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.Domains"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/Domains</h3>
      <p class="pseudocode">// Domains
// =======
// Short-descriptor format Domains

constant <a id="global_Domain_NoAccess"/>Domain_NoAccess : bits(2) = '00';

constant <a id="global_Domain_Client"/>Domain_Client   : bits(2) = '01';

constant <a id="global_Domain_Manager"/>Domain_Manager  : bits(2) = '11';</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.FetchDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/FetchDescriptor</h3>
      <p class="pseudocode">// FetchDescriptor()
// =================
// Fetch a translation table descriptor

func <a id="func_FetchDescriptor_5"/>FetchDescriptor{N : integer{32, 64, 128}}(ee : bit, walkaddress : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>,
                                               walkaccess : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a>,
                                               fault_in : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>) =&gt; (<a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a>, bits(N))
begin
    var descriptor : bits(N);
    var fault : <a href="shared_pseudocode.html#type_FaultRecord" title="">FaultRecord</a> = fault_in;

    if IsFeatureImplemented(FEAT_RME) then
        fault.gpcf = <a href="shared_pseudocode.html#func_GranuleProtectionCheck_2" title="">GranuleProtectionCheck</a>(walkaddress, walkaccess);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#enum_GPCF_None" title="">GPCF_None</a> then
            fault.statuscode = <a href="shared_pseudocode.html#enum_Fault_GPCFOnWalk" title="">Fault_GPCFOnWalk</a>;
            fault.paddress   = walkaddress.paddress;
            fault.gpcfs2walk = fault.secondstage;
            return (fault, ARBITRARY : bits(N));
        end;
    end;

    var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
    (memstatus, descriptor) = <a href="shared_pseudocode.html#func_PhysMemRead_3" title="">PhysMemRead</a>{N}(walkaddress, walkaccess);
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memstatus) then
        let iswrite : boolean = FALSE;
        fault = <a href="shared_pseudocode.html#func_HandleExternalTTWAbort_6" title="">HandleExternalTTWAbort</a>(memstatus, iswrite, walkaddress,
                                       walkaccess, N DIV 8, fault);
        if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(fault.statuscode) then
            return (fault, ARBITRARY : bits(N));
        end;
    end;

    if ee == '1' then
        descriptor = <a href="shared_pseudocode.html#func_BigEndianReverse_2" title="">BigEndianReverse</a>{N}(descriptor);
    end;

    return (fault, descriptor);
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.HasUnprivileged"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/HasUnprivileged</h3>
      <p class="pseudocode">// HasUnprivileged()
// =================
// Returns whether a translation regime serves EL0 as well as a higher EL

readonly func <a id="func_HasUnprivileged_1"/>HasUnprivileged(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>) =&gt; boolean
begin
    return (regime IN {
        <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>,
        <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a>,
        <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>
    });
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.Regime"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/Regime</h3>
      <p class="pseudocode">// Regime
// ======
// Translation regimes

type <a id="type_Regime"/>Regime of enumeration {
    <a id="enum_Regime_EL3"/>Regime_EL3,            // EL3
    <a id="enum_Regime_EL30"/>Regime_EL30,           // EL3&amp;0 (PL1&amp;0 when EL3 is AArch32)
    <a id="enum_Regime_EL2"/>Regime_EL2,            // EL2
    <a id="enum_Regime_EL20"/>Regime_EL20,           // EL2&amp;0
    <a id="enum_Regime_EL10"/>Regime_EL10            // EL1&amp;0
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.RegimeUsingAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/RegimeUsingAArch32</h3>
      <p class="pseudocode">// RegimeUsingAArch32()
// ====================
// Determine if the EL controlling the regime executes in AArch32 state

func <a id="func_RegimeUsingAArch32_1"/>RegimeUsingAArch32(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>) =&gt; boolean
begin
    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt; return <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
        when <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> =&gt; return TRUE;
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt; return FALSE;
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;  return <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> =&gt;  return FALSE;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.S1TTWParams"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/S1TTWParams</h3>
      <p class="pseudocode">// S1TTWParams
// ===========
// Register fields corresponding to stage 1 translation
// For A32-VMSA, if noted, they correspond to A32-LPAE (Long descriptor format)

type <a id="type_S1TTWParams"/>S1TTWParams of record {
// A64-VMSA exclusive parameters
    ha : bit,         // TCR_ELx.HA
    hd : bit,         // TCR_ELx.HD
    tbi : bit,        // TCR_ELx.TBI{x}
    tbid : bit,       // TCR_ELx.TBID{x}
    nfd : bit,        // TCR_EL1.NFDx or TCR_EL2.NFDx when HCR_EL2.E2H == '1'
    e0pd : bit,       // TCR_EL1.E0PDx or TCR_EL2.E0PDx when HCR_EL2.E2H == '1'
    d128 : bit,       // TCR_ELx.D128
    aie : bit,        // (TCR2_ELx/TCR_EL3).AIE
    mair2 : MAIRType, // MAIR2_ELx
    ds : bit,         // TCR_ELx.DS
    ps : bits(3),     // TCR_ELx.{I}PS
    txsz : bits(6),   // TCR_ELx.TxSZ
    epan : bit,       // SCTLR_EL1.EPAN or SCTLR_EL2.EPAN when HCR_EL2.E2H == '1'
    dct : bit,        // HCR_EL2.DCT
    nv1 : bit,        // HCR_EL2.NV1
    cmow : bit,       // SCTLR_EL1.CMOW or SCTLR_EL2.CMOW when HCR_EL2.E2H == '1'
    pnch : bit,       // TCR{2}_ELx.PnCH
    disch : bit,      // TCR{2}_ELx.DisCH
    haft : bit,       // TCR{2}_ELx.HAFT
    mtx : bit,        // TCR_ELx.MTX{y}
    skl : bits(2),    // TTBRn_ELx.SKL
    pie : bit,        // TCR2_ELx.PIE or TCR_EL3.PIE
    pir : S1PIRType,  // PIR_ELx
    pire0 : S1PIRType,// PIRE0_EL1 or PIRE0_EL2 when HCR_EL2.E2H == '1'
    emec : bit,       // SCTLR2_EL2.EMEC or SCTLR2_EL3.EMEC
    amec : bit,       // TCR2_EL2.AMEC0 or TCR2_EL2.AMEC1 when HCR_EL2.E2H == '1'
    fng : bit,        // TCR2_EL1.FNGx or TCR2_EL2.FNGx when HCR_EL2.E2H == '1'
    fngna : bit,      // TCR2_EL1.FNGx

// A32-VMSA exclusive parameters
    t0sz : bits(3),   // TTBCR.T0SZ
    t1sz : bits(3),   // TTBCR.T1SZ
    uwxn : bit,       // SCTLR.UWXN

// Parameters common to both A64-VMSA &amp; A32-VMSA (A64/A32)
    tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>,        // TCR_ELx.TGx      / Always TGx_4KB
    irgn : bits(2),   // TCR_ELx.IRGNx    / TTBCR.IRGNx or HTCR.IRGN0
    orgn : bits(2),   // TCR_ELx.ORGNx    / TTBCR.ORGNx or HTCR.ORGN0
    sh : bits(2),     // TCR_ELx.SHx      / TTBCR.SHx or HTCR.SH0
    hpd : bit,        // TCR_ELx.HPD{x}   / TTBCR2.HPDx or HTCR.HPD
    ee : bit,         // SCTLR_ELx.EE     / SCTLR.EE or HSCTLR.EE
    wxn : bit,        // SCTLR_ELx.WXN    / SCTLR.WXN or HSCTLR.WXN
    ntlsmd : bit,     // SCTLR_ELx.nTLSMD / SCTLR.nTLSMD or HSCTLR.nTLSMD
    dc : bit,         // HCR_EL2.DC       / HCR.DC
    sif : bit,        // SCR_EL3.SIF      / SCR.SIF
    mair : MAIRType   // MAIR_ELx         / MAIR1:MAIR0 or HMAIR1:HMAIR0
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.S2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/S2TTWParams</h3>
      <p class="pseudocode">// S2TTWParams
// ===========
// Register fields corresponding to stage 2 translation.

type <a id="type_S2TTWParams"/>S2TTWParams of record {
// A64-VMSA exclusive parameters
    ha : bit,           // VTCR_EL2.HA
    hd : bit,           // VTCR_EL2.HD
    sl2 : bit,          // V{S}TCR_EL2.SL2
    ds : bit,           // VTCR_EL2.DS
    d128 : bit,         // VTCR_ELx.D128
    sw : bit,           // VSTCR_EL2.SW
    nsw : bit,          // VTCR_EL2.NSW
    sa : bit,           // VSTCR_EL2.SA
    nsa : bit,          // VTCR_EL2.NSA
    ps : bits(3),       // VTCR_EL2.PS
    txsz : bits(6),     // V{S}TCR_EL2.T0SZ
    fwb : bit,          // HCR_EL2.FWB
    cmow : bit,         // HCRX_EL2.CMOW
    skl : bits(2),      // VTTBR_EL2.SKL
    s2pie : bit,        // VTCR_EL2.S2PIE
    s2pir : S2PIRType,  // S2PIR_EL2
    tl0 : bit,          // VTCR_EL2.TL0
    tl1 : bit,          // VTCR_EL2.TL1
    assuredonly : bit,  // VTCR_EL2.AssuredOnly
    haft : bit,         // VTCR_EL2.HAFT
    emec : bit,         // SCTLR2_EL2.EMEC
    hdbss : bit,        // VTCR_EL2.HDBSS

// A32-VMSA exclusive parameters
    s : bit,            // VTCR.S
    t0sz : bits(4),     // VTCR.T0SZ

// Parameters common to both A64-VMSA &amp; A32-VMSA if implemented (A64/A32)
    tgx : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>,          // V{S}TCR_EL2.TG0  / Always TGx_4KB
    sl0 : bits(2),      // V{S}TCR_EL2.SL0  / VTCR.SL0
    irgn : bits(2),     // VTCR_EL2.IRGN0   / VTCR.IRGN0
    orgn : bits(2),     // VTCR_EL2.ORGN0   / VTCR.ORGN0
    sh : bits(2),       // VTCR_EL2.SH0     / VTCR.SH0
    ee : bit,           // SCTLR_EL2.EE     / HSCTLR.EE
    ptw : bit,          // HCR_EL2.PTW      / HCR.PTW
    vm : bit            // HCR_EL2.VM       / HCR.VM
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.SDFType"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/SDFType</h3>
      <p class="pseudocode">// SDFType
// =======
// Short-descriptor format type

type <a id="type_SDFType"/>SDFType of enumeration {
    <a id="enum_SDFType_Table"/>SDFType_Table,
    <a id="enum_SDFType_Invalid"/>SDFType_Invalid,
    <a id="enum_SDFType_Supersection"/>SDFType_Supersection,
    <a id="enum_SDFType_Section"/>SDFType_Section,
    <a id="enum_SDFType_LargePage"/>SDFType_LargePage,
    <a id="enum_SDFType_SmallPage"/>SDFType_SmallPage
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.SecurityStateForRegime"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/SecurityStateForRegime</h3>
      <p class="pseudocode">// SecurityStateForRegime()
// ========================
// Return the Security State of the given translation regime

func <a id="func_SecurityStateForRegime_1"/>SecurityStateForRegime(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>) =&gt; <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>
begin
    case regime of
        when <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a> =&gt;     return <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>);
        when <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> =&gt;    return <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a>; // A32 EL3 is always Secure
        when <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a> =&gt;     return <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
        when <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> =&gt;    return <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>);
        when <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> =&gt;    return <a href="shared_pseudocode.html#func_SecurityStateAtEL_1" title="">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#global_EL1" title="">EL1</a>);
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.StageOA"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/StageOA</h3>
      <p class="pseudocode">// StageOA()
// =========
// Given the final walk state (a page or block descriptor), map the untranslated
// input address bits to the output address

func StageOA(ia : bits(64), d128 : bit, tgx : TGx, walkstate : TTWState) =&gt; FullAddress
begin
    // Output Address
    var oa : FullAddress;
    let tsize : integer = TranslationSize(d128, tgx, walkstate.level);
    let csize : integer = (if walkstate.contiguous == '1' then
                           ContiguousSize(d128, tgx, walkstate.level)
                           else 0);
    let ia_msb : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = (tsize + csize) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
    oa.paspace = walkstate.baseaddress.paspace;
    oa.address = walkstate.baseaddress.address[55:ia_msb]::ia[ia_msb-1:0];

    return oa;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TGx"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TGx</h3>
      <p class="pseudocode">// TGx
// ===
// Translation granules sizes

type <a id="type_TGx"/>TGx of enumeration {
    <a id="enum_TGx_4KB"/>TGx_4KB,
    <a id="enum_TGx_16KB"/>TGx_16KB,
    <a id="enum_TGx_64KB"/>TGx_64KB
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TGxGranuleBits"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TGxGranuleBits</h3>
      <p class="pseudocode">// TGxGranuleBits()
// ================
// Retrieve the address size, in bits, of a granule

func TGxGranuleBits(tgx : TGx) =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    case tgx of
        when TGx_4KB =&gt;  return 12;
        when TGx_16KB =&gt; return 14;
        when TGx_64KB =&gt; return 16;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TLBContext"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TLBContext</h3>
      <p class="pseudocode">// TLBContext
// ==========
// Translation context compared on TLB lookups and invalidations, promoting a TLB hit on match

type <a id="type_TLBContext"/>TLBContext of record {
    ss : <a href="shared_pseudocode.html#type_SecurityState" title="">SecurityState</a>,
    regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>,
    vmid : bits(16),
    asid : bits(16),
    nG : bit,
    ipaspace : <a href="shared_pseudocode.html#type_PASpace" title="">PASpace</a>,    // Used in stage 2 lookups &amp; invalidations only
    includes_s1 : boolean,
    includes_s2 : boolean,
    use_vmid : boolean,
    includes_gpt : boolean,
    ia : bits(64),         // Input Address
    tg : <a href="shared_pseudocode.html#type_TGx" title="">TGx</a>,
    cnp : bit,
    level : integer,       // Assist TLBI level hints (FEAT_TTL)
    isd128 : boolean,
    xs : bit               // XS attribute (FEAT_XS)
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TLBRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TLBRecord</h3>
      <p class="pseudocode">// TLBRecord
// =========
// Translation output as a TLB payload

type TLBRecord of record {
    context : TLBContext,
    walkstate : TTWState,
    blocksize : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>,  // Number of bits directly mapped from IA to OA
    contigsize : integer,     // Number of entries log 2 marking a contiguous output range
    s1descriptor : bits(128), // Stage 1 leaf descriptor in memory (valid if the TLB caches stage 1)
    s2descriptor : bits(128)  // Stage 2 leaf descriptor in memory (valid if the TLB caches stage 2)

};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TTWState"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TTWState</h3>
      <p class="pseudocode">// TTWState
// ========
// Translation table walk state

type <a id="type_TTWState"/>TTWState of record {
    istable : boolean,
    level : integer,
    baseaddress : <a href="shared_pseudocode.html#type_FullAddress" title="">FullAddress</a>,
    contiguous : bit,
    s1assured : boolean,  // Stage 1 Assured Translation Property
    s2assuredonly : bit,  // Stage 2 AssuredOnly attribute
    disch : bit,          // Stage 1 Disable Contiguous Hint
    nG : bit,
    guardedpage : bit,
    sdftype : <a href="shared_pseudocode.html#type_SDFType" title="">SDFType</a>,    // AArch32 Short-descriptor format walk only
    domain : bits(4),     // AArch32 Short-descriptor format walk only
    memattrs : MemoryAttributes,
    permissions : <a href="shared_pseudocode.html#type_Permissions" title="">Permissions</a>
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TranslationRegime"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TranslationRegime</h3>
      <p class="pseudocode">// TranslationRegime()
// ===================
// Select the translation regime given the target EL and PE state

func <a id="func_TranslationRegime_1"/>TranslationRegime(el : bits(2)) =&gt; <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>
begin
    if el == <a href="shared_pseudocode.html#global_EL3" title="">EL3</a> then
        return if <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a> else <a href="shared_pseudocode.html#enum_Regime_EL3" title="">Regime_EL3</a>;
    elsif el == <a href="shared_pseudocode.html#global_EL2" title="">EL2</a> then
        return if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a> else <a href="shared_pseudocode.html#enum_Regime_EL2" title="">Regime_EL2</a>;
    elsif el == <a href="shared_pseudocode.html#global_EL1" title="">EL1</a> then
        return <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>;
    elsif el == <a href="shared_pseudocode.html#global_EL0" title="">EL0</a> then
        if <a href="shared_pseudocode.html#func_CurrentSecurityState_0" title="">CurrentSecurityState</a>() == <a href="shared_pseudocode.html#enum_SS_Secure" title="">SS_Secure</a> &amp;&amp; <a href="shared_pseudocode.html#func_ELUsingAArch32_1" title="">ELUsingAArch32</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) then
            return <a href="shared_pseudocode.html#enum_Regime_EL30" title="">Regime_EL30</a>;
        elsif <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL0" title="">EL0</a>) then
            return <a href="shared_pseudocode.html#enum_Regime_EL20" title="">Regime_EL20</a>;
        else
            return <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a>;
        end;
    else
        unreachable;
    end;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TranslationSize"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TranslationSize</h3>
      <p class="pseudocode">// TranslationSize()
// =================
// Compute the number of bits directly mapped from the input address
// to the output address

func TranslationSize(d128 : bit, tgx : TGx, level : integer) =&gt; <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>
begin
    let granulebits : <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a> = TGxGranuleBits(tgx);
    let descsizelog2 : integer{} = if d128 == '1' then 4 else 3;
    let blockbits : integer   = (FINAL_LEVEL - level) * (granulebits - descsizelog2);

    return (granulebits + blockbits) as <a href="shared_pseudocode.html#AddressSize" title="type AddressSize">AddressSize</a>;
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.UseASID"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/UseASID</h3>
      <p class="pseudocode">// UseASID()
// =========
// Determine whether the translation context for the access requires ASID or is a global entry

func <a id="func_UseASID_1"/>UseASID(accesscontext : <a href="shared_pseudocode.html#type_TLBContext" title="">TLBContext</a>) =&gt; boolean
begin
    return <a href="shared_pseudocode.html#func_HasUnprivileged_1" title="">HasUnprivileged</a>(accesscontext.regime);
end;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.UseVMID"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/UseVMID</h3>
      <p class="pseudocode">// UseVMID()
// =========
// Determine whether the translation context for the access requires VMID to match a TLB entry

func <a id="func_UseVMID_1"/>UseVMID(regime : <a href="shared_pseudocode.html#type_Regime" title="">Regime</a>) =&gt; boolean
begin
    return regime == <a href="shared_pseudocode.html#enum_Regime_EL10" title="">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>();
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveACTLRMASK_EL1"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveACTLRMASK_EL1</h3>
      <p class="pseudocode">// EffectiveACTLRMASK_EL1()
// ========================
// Return the effective value of ACTLRMASK_EL1.

func <a id="func_EffectiveACTLRMASK_EL1_0"/>EffectiveACTLRMASK_EL1() =&gt; ACTLR_EL1_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; (!<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().SRMASKEn == '0') then
        return Zeros{64};
    end;
    let mask : ACTLR_EL1_Type = ImpDefBits{64}("ACTLR_EL1 layout");

    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveACTLRMASK_EL2"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveACTLRMASK_EL2</h3>
      <p class="pseudocode">// EffectiveACTLRMASK_EL2()
// ========================
// Return the effective value of ACTLRMASK_EL2.

func <a id="func_EffectiveACTLRMASK_EL2_0"/>EffectiveACTLRMASK_EL2() =&gt; ACTLR_EL2_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    let mask : ACTLR_EL2_Type = ImpDefBits{64}("ACTLR_EL2 layout");

    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveCPACRMASK_EL1"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveCPACRMASK_EL1</h3>
      <p class="pseudocode">// EffectiveCPACRMASK_EL1()
// ========================
// Return the effective value of CPACRMASK_EL1.

func <a id="func_EffectiveCPACRMASK_EL1_0"/>EffectiveCPACRMASK_EL1() =&gt; CPACR_EL1_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; (!<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().SRMASKEn == '0') then
        return Zeros{64};
    end;
    var mask : CPACR_EL1_Type = Ones{64};
    let mask_reg : CPACRMASK_EL1_Type = CPACRMASK_EL1();

    mask.TCPAC = mask_reg.TCPAC;
    mask.TAM = mask_reg.TAM;
    mask.E0POE = mask_reg.E0POE;
    mask.TTA = mask_reg.TTA;
    mask.SMEN = SignExtend{2}(mask_reg.SMEN);
    mask.FPEN = SignExtend{2}(mask_reg.FPEN);
    mask.ZEN = SignExtend{2}(mask_reg.ZEN);
    mask[32+: 32] = Zeros{32};
    mask[26+: 2] = Zeros{2};
    mask[22+: 2] = Zeros{2};
    mask[18+: 2] = Zeros{2};
    mask[0+: 16] = Zeros{16};
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveCPTRMASK_EL2"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveCPTRMASK_EL2</h3>
      <p class="pseudocode">// EffectiveCPTRMASK_EL2()
// =======================
// Return the effective value of CPTRMASK_EL2.

func <a id="func_EffectiveCPTRMASK_EL2_0"/>EffectiveCPTRMASK_EL2() =&gt; CPTR_EL2_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    var mask : CPTR_EL2_Type = Ones{64};
    let mask_reg : CPTRMASK_EL2_Type = CPTRMASK_EL2();

    if <a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        mask.TCPAC = mask_reg.TCPAC;
        mask.TAM = mask_reg.TAM;
        mask.E0POE = mask_reg.E0POE;
        mask.TTA = mask_reg.TTA;
        mask.SMEN = SignExtend{2}(mask_reg.SMEN);
        mask.FPEN = SignExtend{2}(mask_reg.FPEN);
        mask.ZEN = SignExtend{2}(mask_reg.ZEN);
        mask[32+: 32] = Zeros{32};
        mask[26+: 2] = Zeros{2};
        mask[22+: 2] = Zeros{2};
        mask[18+: 2] = Zeros{2};
        mask[0+: 16] = Zeros{16};
    else
        mask.TCPAC = mask_reg.TCPAC;
        mask.TAM = mask_reg.TAM;
        mask.TTA = mask_reg.TTA;
        mask.TSM = mask_reg.TSM;
        mask.TFP = mask_reg.TFP;
        mask.TZ = mask_reg.TZ;
        mask[32+: 32] = Zeros{32};
        mask[21+: 9] = Zeros{9};
        mask[14+: 6] = Zeros{6};
        mask[13+: 1] = '0';
        mask[11+: 1] = '0';
        mask[9+: 1] = '0';
        mask[0+: 8] = Zeros{8};
    end;
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveHCRMASK_EL2"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveHCRMASK_EL2</h3>
      <p class="pseudocode">// EffectiveHCRMASK_EL2()
// ======================
// Return the effective value of HCRMASK_EL2.

func <a id="func_EffectiveHCRMASK_EL2_0"/>EffectiveHCRMASK_EL2() =&gt; HCR_EL2_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK2) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    var mask : HCR_EL2_Type = Ones{64};
    let mask_reg : HCRMASK_EL2_Type = HCRMASK_EL2();

    mask.TWEDEL = SignExtend{4}(mask_reg.TWEDEL);
    mask.TWEDEn = mask_reg.TWEDEn;
    mask.TID5 = mask_reg.TID5;
    mask.DCT = mask_reg.DCT;
    mask.ATA = mask_reg.ATA;
    mask.TTLBOS = mask_reg.TTLBOS;
    mask.TTLBIS = mask_reg.TTLBIS;
    mask.EnSCXT = mask_reg.EnSCXT;
    mask.TOCU = mask_reg.TOCU;
    mask.AMVOFFEN = mask_reg.AMVOFFEN;
    mask.TICAB = mask_reg.TICAB;
    mask.TID4 = mask_reg.TID4;
    mask.GPF = mask_reg.GPF;
    mask.FIEN = mask_reg.FIEN;
    mask.FWB = mask_reg.FWB;
    mask.NV2 = mask_reg.NV2;
    mask.AT = mask_reg.AT;
    mask.NV1 = mask_reg.NV1;
    mask.NV = mask_reg.NV;
    mask.API = mask_reg.API;
    mask.APK = mask_reg.APK;
    mask.TEA = mask_reg.TEA;
    mask.TERR = mask_reg.TERR;
    mask.TLOR = mask_reg.TLOR;
    mask.E2H = mask_reg.E2H;
    mask.ID = mask_reg.ID;
    mask.CD = mask_reg.CD;
    mask.RW = mask_reg.RW;
    mask.TRVM = mask_reg.TRVM;
    mask.HCD = mask_reg.HCD;
    mask.TDZ = mask_reg.TDZ;
    mask.TGE = mask_reg.TGE;
    mask.TVM = mask_reg.TVM;
    mask.TTLB = mask_reg.TTLB;
    mask.TPU = mask_reg.TPU;
    mask.TPCP = mask_reg.TPCP;
    mask.TSW = mask_reg.TSW;
    mask.TACR = mask_reg.TACR;
    mask.TIDCP = mask_reg.TIDCP;
    mask.TSC = mask_reg.TSC;
    mask.TID3 = mask_reg.TID3;
    mask.TID2 = mask_reg.TID2;
    mask.TID1 = mask_reg.TID1;
    mask.TID0 = mask_reg.TID0;
    mask.TWE = mask_reg.TWE;
    mask.TWI = mask_reg.TWI;
    mask.DC = mask_reg.DC;
    mask.BSU = SignExtend{2}(mask_reg.BSU);
    mask.FB = mask_reg.FB;
    mask.VSE = mask_reg.VSE;
    mask.VI = mask_reg.VI;
    mask.VF = mask_reg.VF;
    mask.AMO = mask_reg.AMO;
    mask.IMO = mask_reg.IMO;
    mask.FMO = mask_reg.FMO;
    mask.PTW = mask_reg.PTW;
    mask.SWIO = mask_reg.SWIO;
    mask.VM = mask_reg.VM;
    mask[38+: 2] = Zeros{2};
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveHCRXMASK_EL2"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveHCRXMASK_EL2</h3>
      <p class="pseudocode">// EffectiveHCRXMASK_EL2()
// =======================
// Return the effective value of HCRXMASK_EL2.

func <a id="func_EffectiveHCRXMASK_EL2_0"/>EffectiveHCRXMASK_EL2() =&gt; HCRX_EL2_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK2) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    var mask : HCRX_EL2_Type = Ones{64};
    let mask_reg : HCRXMASK_EL2_Type = HCRXMASK_EL2();

    mask.FNB = mask_reg.FNB;
    mask.VTLBIDOSEn = mask_reg.VTLBIDOSEn;
    mask.NVnTTLBOS = mask_reg.NVnTTLBOS;
    mask.NVnTTLBIS = mask_reg.NVnTTLBIS;
    mask.NVnTTLB = mask_reg.NVnTTLB;
    mask.FDIT = mask_reg.FDIT;
    mask.NVTGE = mask_reg.NVTGE;
    mask.SRMASKEn = mask_reg.SRMASKEn;
    mask.VTLBIDEn = mask_reg.VTLBIDEn;
    mask.PACMEn = mask_reg.PACMEn;
    mask.EnFPM = mask_reg.EnFPM;
    mask.GCSEn = mask_reg.GCSEn;
    mask.EnIDCP128 = mask_reg.EnIDCP128;
    mask.EnSDERR = mask_reg.EnSDERR;
    mask.TMEA = mask_reg.TMEA;
    mask.EnSNERR = mask_reg.EnSNERR;
    mask.D128En = mask_reg.D128En;
    mask.PTTWI = mask_reg.PTTWI;
    mask.SCTLR2En = mask_reg.SCTLR2En;
    mask.TCR2En = mask_reg.TCR2En;
    mask.MSCEn = mask_reg.MSCEn;
    mask.MCE2 = mask_reg.MCE2;
    mask.CMOW = mask_reg.CMOW;
    mask.VFNMI = mask_reg.VFNMI;
    mask.VINMI = mask_reg.VINMI;
    mask.TALLINT = mask_reg.TALLINT;
    mask.SMPME = mask_reg.SMPME;
    mask.FGTnXS = mask_reg.FGTnXS;
    mask.FnXS = mask_reg.FnXS;
    mask.EnASR = mask_reg.EnASR;
    mask.EnALS = mask_reg.EnALS;
    mask.EnAS0 = mask_reg.EnAS0;
    mask[37+: 27] = Zeros{27};
    mask[28+: 3] = Zeros{3};
    mask[12+: 2] = Zeros{2};
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveNVHCRMASK_EL2"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveNVHCRMASK_EL2</h3>
      <p class="pseudocode">// EffectiveNVHCRMASK_EL2()
// ========================
// Return the effective value of NVHCRMASK_EL2.

func <a id="func_EffectiveNVHCRMASK_EL2_0"/>EffectiveNVHCRMASK_EL2() =&gt; NVHCR_EL2_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK2) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    var mask : NVHCR_EL2_Type = Ones{64};
    let mask_reg : NVHCRMASK_EL2_Type = NVHCRMASK_EL2();

    mask.TWEDEL = mask_reg.TWEDEL;
    mask.TWEDEn = mask_reg.TWEDEn;
    mask.TID5 = mask_reg.TID5;
    mask.DCT = mask_reg.DCT;
    mask.ATA = mask_reg.ATA;
    mask.EnSCXT = mask_reg.EnSCXT;
    mask.TOCU = mask_reg.TOCU;
    mask.AMVOFFEN = mask_reg.AMVOFFEN;
    mask.TICAB = mask_reg.TICAB;
    mask.TID4 = mask_reg.TID4;
    mask.GPF = mask_reg.GPF;
    mask.FIEN = mask_reg.FIEN;
    mask.FWB = mask_reg.FWB;
    mask.NV2 = mask_reg.NV2;
    mask.AT = mask_reg.AT;
    mask.NV1 = mask_reg.NV1;
    mask.NV = mask_reg.NV;
    mask.API = mask_reg.API;
    mask.APK = mask_reg.APK;
    mask.TEA = mask_reg.TEA;
    mask.TERR = mask_reg.TERR;
    mask.TLOR = mask_reg.TLOR;
    mask.E2H = mask_reg.E2H;
    mask.ID = mask_reg.ID;
    mask.CD = mask_reg.CD;
    mask.RW = mask_reg.RW;
    mask.HCD = mask_reg.HCD;
    mask.TDZ = mask_reg.TDZ;
    mask.TGE = mask_reg.TGE;
    mask.TVM = mask_reg.TVM;
    mask.TTLB = mask_reg.TTLB;
    mask.TPU = mask_reg.TPU;
    mask.TPCP = mask_reg.TPCP;
    mask.TSW = mask_reg.TSW;
    mask.TACR = mask_reg.TACR;
    mask.TIDCP = mask_reg.TIDCP;
    mask.TSC = mask_reg.TSC;
    mask.TID3 = mask_reg.TID3;
    mask.TID2 = mask_reg.TID2;
    mask.TID1 = mask_reg.TID1;
    mask.TID0 = mask_reg.TID0;
    mask.TWE = mask_reg.TWE;
    mask.TWI = mask_reg.TWI;
    mask.DC = mask_reg.DC;
    mask.BSU = mask_reg.BSU;
    mask.FB = mask_reg.FB;
    mask.VSE = mask_reg.VSE;
    mask.VI = mask_reg.VI;
    mask.VF = mask_reg.VF;
    mask.AMO = mask_reg.AMO;
    mask.IMO = mask_reg.IMO;
    mask.FMO = mask_reg.FMO;
    mask.PTW = mask_reg.PTW;
    mask.SWIO = mask_reg.SWIO;
    mask.VM = mask_reg.VM;
    mask[61+: 3] = Zeros{3};
    mask[38+: 2] = Zeros{2};
    mask[11+: 1] = '0';
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveNVHCRXMASK_EL2"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveNVHCRXMASK_EL2</h3>
      <p class="pseudocode">// EffectiveNVHCRXMASK_EL2()
// =========================
// Return the effective value of NVHCRXMASK_EL2.

func <a id="func_EffectiveNVHCRXMASK_EL2_0"/>EffectiveNVHCRXMASK_EL2() =&gt; NVHCRX_EL2_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK2) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    var mask : NVHCRX_EL2_Type = Ones{64};
    let mask_reg : NVHCRXMASK_EL2_Type = NVHCRXMASK_EL2();

    mask.FNB = mask_reg.FNB;
    mask.VTLBIDOSEn = mask_reg.VTLBIDOSEn;
    mask.NVnTTLBOS = mask_reg.NVnTTLBOS;
    mask.NVnTTLBIS = mask_reg.NVnTTLBIS;
    mask.NVnTTLB = mask_reg.NVnTTLB;
    mask.FDIT = mask_reg.FDIT;
    mask.NVTGE = mask_reg.NVTGE;
    mask.SRMASKEn = mask_reg.SRMASKEn;
    mask.VTLBIDEn = mask_reg.VTLBIDEn;
    mask.PACMEn = mask_reg.PACMEn;
    mask.EnFPM = mask_reg.EnFPM;
    mask.GCSEn = mask_reg.GCSEn;
    mask.EnIDCP128 = mask_reg.EnIDCP128;
    mask.EnSDERR = mask_reg.EnSDERR;
    mask.TMEA = mask_reg.TMEA;
    mask.EnSNERR = mask_reg.EnSNERR;
    mask.D128En = mask_reg.D128En;
    mask.PTTWI = mask_reg.PTTWI;
    mask.SCTLR2En = mask_reg.SCTLR2En;
    mask.TCR2En = mask_reg.TCR2En;
    mask.MSCEn = mask_reg.MSCEn;
    mask.MCE2 = mask_reg.MCE2;
    mask.CMOW = mask_reg.CMOW;
    mask.VFNMI = mask_reg.VFNMI;
    mask.VINMI = mask_reg.VINMI;
    mask.TALLINT = mask_reg.TALLINT;
    mask.SMPME = mask_reg.SMPME;
    mask.FGTnXS = mask_reg.FGTnXS;
    mask.FnXS = mask_reg.FnXS;
    mask.EnASR = mask_reg.EnASR;
    mask.EnALS = mask_reg.EnALS;
    mask.EnAS0 = mask_reg.EnAS0;
    mask[37+: 27] = Zeros{27};
    mask[28+: 3] = Zeros{3};
    mask[12+: 2] = Zeros{2};
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveSCTLR2MASK_EL1"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveSCTLR2MASK_EL1</h3>
      <p class="pseudocode">// EffectiveSCTLR2MASK_EL1()
// =========================
// Return the effective value of SCTLR2MASK_EL1.

func <a id="func_EffectiveSCTLR2MASK_EL1_0"/>EffectiveSCTLR2MASK_EL1() =&gt; SCTLR2_EL1_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; (!<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().SRMASKEn == '0') then
        return Zeros{64};
    end;
    var mask : SCTLR2_EL1_Type = Ones{64};
    let mask_reg : SCTLR2MASK_EL1_Type = SCTLR2MASK_EL1();

    mask.TLBOSNIS = mask_reg.TLBOSNIS;
    mask.FDIT = mask_reg.FDIT;
    mask.BTD = mask_reg.BTD;
    mask.BTD0 = mask_reg.BTD0;
    mask.EnIA2 = mask_reg.EnIA2;
    mask.EnIB2 = mask_reg.EnIB2;
    mask.EnDA2 = mask_reg.EnDA2;
    mask.EnDB2 = mask_reg.EnDB2;
    mask.CPTM0 = mask_reg.CPTM0;
    mask.CPTM = mask_reg.CPTM;
    mask.CPTA0 = mask_reg.CPTA0;
    mask.CPTA = mask_reg.CPTA;
    mask.EnPACM0 = mask_reg.EnPACM0;
    mask.EnPACM = mask_reg.EnPACM;
    mask.EnIDCP128 = mask_reg.EnIDCP128;
    mask.EASE = mask_reg.EASE;
    mask.EnANERR = mask_reg.EnANERR;
    mask.EnADERR = mask_reg.EnADERR;
    mask.NMEA = mask_reg.NMEA;
    mask[27+: 37] = Zeros{37};
    mask[13+: 6] = Zeros{6};
    mask[0+: 2] = Zeros{2};
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveSCTLR2MASK_EL2"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveSCTLR2MASK_EL2</h3>
      <p class="pseudocode">// EffectiveSCTLR2MASK_EL2()
// =========================
// Return the effective value of SCTLR2MASK_EL2.

func <a id="func_EffectiveSCTLR2MASK_EL2_0"/>EffectiveSCTLR2MASK_EL2() =&gt; SCTLR2_EL2_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    var mask : SCTLR2_EL2_Type = Ones{64};
    let mask_reg : SCTLR2MASK_EL2_Type = SCTLR2MASK_EL2();

    mask.TLBOSNIS = mask_reg.TLBOSNIS;
    mask.FDIT = mask_reg.FDIT;
    mask.BTD = mask_reg.BTD;
    mask.BTD0 = mask_reg.BTD0;
    mask.EnIA2 = mask_reg.EnIA2;
    mask.EnIB2 = mask_reg.EnIB2;
    mask.EnDA2 = mask_reg.EnDA2;
    mask.EnDB2 = mask_reg.EnDB2;
    mask.CPTM0 = mask_reg.CPTM0;
    mask.CPTM = mask_reg.CPTM;
    mask.CPTA0 = mask_reg.CPTA0;
    mask.CPTA = mask_reg.CPTA;
    mask.EnPACM0 = mask_reg.EnPACM0;
    mask.EnPACM = mask_reg.EnPACM;
    mask.EnIDCP128 = mask_reg.EnIDCP128;
    mask.EASE = mask_reg.EASE;
    mask.EnANERR = mask_reg.EnANERR;
    mask.EnADERR = mask_reg.EnADERR;
    mask.NMEA = mask_reg.NMEA;
    mask.EMEC = mask_reg.EMEC;
    mask[27+: 37] = Zeros{37};
    mask[13+: 6] = Zeros{6};
    mask[0+: 1] = '0';
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveSCTLRMASK_EL1"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveSCTLRMASK_EL1</h3>
      <p class="pseudocode">// EffectiveSCTLRMASK_EL1()
// ========================
// Return the effective value of SCTLRMASK_EL1.

func <a id="func_EffectiveSCTLRMASK_EL1_0"/>EffectiveSCTLRMASK_EL1() =&gt; SCTLR_EL1_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; (!<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().SRMASKEn == '0') then
        return Zeros{64};
    end;
    var mask : SCTLR_EL1_Type = Ones{64};
    let mask_reg : SCTLRMASK_EL1_Type = SCTLRMASK_EL1();

    mask.TIDCP = mask_reg.TIDCP;
    mask.SPINTMASK = mask_reg.SPINTMASK;
    mask.NMI = mask_reg.NMI;
    mask.EnTP2 = mask_reg.EnTP2;
    mask.TCSO = mask_reg.TCSO;
    mask.TCSO0 = mask_reg.TCSO0;
    mask.EPAN = mask_reg.EPAN;
    mask.EnALS = mask_reg.EnALS;
    mask.EnAS0 = mask_reg.EnAS0;
    mask.EnASR = mask_reg.EnASR;
    mask.TWEDEL = SignExtend{4}(mask_reg.TWEDEL);
    mask.TWEDEn = mask_reg.TWEDEn;
    mask.DSSBS = mask_reg.DSSBS;
    mask.ATA = mask_reg.ATA;
    mask.ATA0 = mask_reg.ATA0;
    mask.TCF = SignExtend{2}(mask_reg.TCF);
    mask.TCF0 = SignExtend{2}(mask_reg.TCF0);
    mask.ITFSB = mask_reg.ITFSB;
    mask.BT1 = mask_reg.BT1;
    mask.BT0 = mask_reg.BT0;
    mask.EnFPM = mask_reg.EnFPM;
    mask.MSCEn = mask_reg.MSCEn;
    mask.CMOW = mask_reg.CMOW;
    mask.EnIA = mask_reg.EnIA;
    mask.EnIB = mask_reg.EnIB;
    mask.LSMAOE = mask_reg.LSMAOE;
    mask.nTLSMD = mask_reg.nTLSMD;
    mask.EnDA = mask_reg.EnDA;
    mask.UCI = mask_reg.UCI;
    mask.EE = mask_reg.EE;
    mask.E0E = mask_reg.E0E;
    mask.SPAN = mask_reg.SPAN;
    mask.EIS = mask_reg.EIS;
    mask.IESB = mask_reg.IESB;
    mask.TSCXT = mask_reg.TSCXT;
    mask.WXN = mask_reg.WXN;
    mask.nTWE = mask_reg.nTWE;
    mask.nTWI = mask_reg.nTWI;
    mask.UCT = mask_reg.UCT;
    mask.DZE = mask_reg.DZE;
    mask.EnDB = mask_reg.EnDB;
    mask.I = mask_reg.I;
    mask.EOS = mask_reg.EOS;
    mask.EnRCTX = mask_reg.EnRCTX;
    mask.UMA = mask_reg.UMA;
    mask.SED = mask_reg.SED;
    mask.ITD = mask_reg.ITD;
    mask.nAA = mask_reg.nAA;
    mask.CP15BEN = mask_reg.CP15BEN;
    mask.SA0 = mask_reg.SA0;
    mask.SA = mask_reg.SA;
    mask.C = mask_reg.C;
    mask.A = mask_reg.A;
    mask.M = mask_reg.M;
    mask[50+: 4] = Zeros{4};
    mask[17+: 1] = '0';
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveSCTLRMASK_EL2"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveSCTLRMASK_EL2</h3>
      <p class="pseudocode">// EffectiveSCTLRMASK_EL2()
// ========================
// Return the effective value of SCTLRMASK_EL2.

func <a id="func_EffectiveSCTLRMASK_EL2_0"/>EffectiveSCTLRMASK_EL2() =&gt; SCTLR_EL2_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    var mask : SCTLR_EL2_Type = Ones{64};
    let mask_reg : SCTLRMASK_EL2_Type = SCTLRMASK_EL2();

    mask.TIDCP = mask_reg.TIDCP;
    mask.SPINTMASK = mask_reg.SPINTMASK;
    mask.NMI = mask_reg.NMI;
    mask.EnTP2 = mask_reg.EnTP2;
    mask.TCSO = mask_reg.TCSO;
    mask.TCSO0 = mask_reg.TCSO0;
    mask.EPAN = mask_reg.EPAN;
    mask.EnALS = mask_reg.EnALS;
    mask.EnAS0 = mask_reg.EnAS0;
    mask.EnASR = mask_reg.EnASR;
    mask.TWEDEL = SignExtend{4}(mask_reg.TWEDEL);
    mask.TWEDEn = mask_reg.TWEDEn;
    mask.DSSBS = mask_reg.DSSBS;
    mask.ATA = mask_reg.ATA;
    mask.ATA0 = mask_reg.ATA0;
    mask.TCF = SignExtend{2}(mask_reg.TCF);
    mask.TCF0 = SignExtend{2}(mask_reg.TCF0);
    mask.ITFSB = mask_reg.ITFSB;
    mask.BT = mask_reg.BT;
    mask.BT0 = mask_reg.BT0;
    mask.EnFPM = mask_reg.EnFPM;
    mask.MSCEn = mask_reg.MSCEn;
    mask.CMOW = mask_reg.CMOW;
    mask.EnIA = mask_reg.EnIA;
    mask.EnIB = mask_reg.EnIB;
    mask.LSMAOE = mask_reg.LSMAOE;
    mask.nTLSMD = mask_reg.nTLSMD;
    mask.EnDA = mask_reg.EnDA;
    mask.UCI = mask_reg.UCI;
    mask.EE = mask_reg.EE;
    mask.E0E = mask_reg.E0E;
    mask.SPAN = mask_reg.SPAN;
    mask.EIS = mask_reg.EIS;
    mask.IESB = mask_reg.IESB;
    mask.TSCXT = mask_reg.TSCXT;
    mask.WXN = mask_reg.WXN;
    mask.nTWE = mask_reg.nTWE;
    mask.nTWI = mask_reg.nTWI;
    mask.UCT = mask_reg.UCT;
    mask.DZE = mask_reg.DZE;
    mask.EnDB = mask_reg.EnDB;
    mask.I = mask_reg.I;
    mask.EOS = mask_reg.EOS;
    mask.EnRCTX = mask_reg.EnRCTX;
    mask.SED = mask_reg.SED;
    mask.ITD = mask_reg.ITD;
    mask.nAA = mask_reg.nAA;
    mask.CP15BEN = mask_reg.CP15BEN;
    mask.SA0 = mask_reg.SA0;
    mask.SA = mask_reg.SA;
    mask.C = mask_reg.C;
    mask.A = mask_reg.A;
    mask.M = mask_reg.M;
    mask[50+: 4] = Zeros{4};
    mask[17+: 1] = '0';
    mask[9+: 1] = '0';
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveTCR2MASK_EL1"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveTCR2MASK_EL1</h3>
      <p class="pseudocode">// EffectiveTCR2MASK_EL1()
// =======================
// Return the effective value of TCR2MASK_EL1.

func <a id="func_EffectiveTCR2MASK_EL1_0"/>EffectiveTCR2MASK_EL1() =&gt; TCR2_EL1_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; (!<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().SRMASKEn == '0') then
        return Zeros{64};
    end;
    var mask : TCR2_EL1_Type = Ones{64};
    let mask_reg : TCR2MASK_EL1_Type = TCR2MASK_EL1();

    mask.FNGNA1 = mask_reg.FNGNA1;
    mask.FNGNA0 = mask_reg.FNGNA0;
    mask.FNG1 = mask_reg.FNG1;
    mask.FNG0 = mask_reg.FNG0;
    mask.A2 = mask_reg.A2;
    mask.DisCH1 = mask_reg.DisCH1;
    mask.DisCH0 = mask_reg.DisCH0;
    mask.HAFT = mask_reg.HAFT;
    mask.PTTWI = mask_reg.PTTWI;
    mask.D128 = mask_reg.D128;
    mask.AIE = mask_reg.AIE;
    mask.POE = mask_reg.POE;
    mask.E0POE = mask_reg.E0POE;
    mask.PIE = mask_reg.PIE;
    mask.PnCH = mask_reg.PnCH;
    mask[22+: 42] = Zeros{42};
    mask[19+: 1] = '0';
    mask[12+: 2] = Zeros{2};
    mask[6+: 4] = Zeros{4};
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveTCR2MASK_EL2"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveTCR2MASK_EL2</h3>
      <p class="pseudocode">// EffectiveTCR2MASK_EL2()
// =======================
// Return the effective value of TCR2MASK_EL2.

func <a id="func_EffectiveTCR2MASK_EL2_0"/>EffectiveTCR2MASK_EL2() =&gt; TCR2_EL2_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    var mask : TCR2_EL2_Type = Ones{64};
    let mask_reg : TCR2MASK_EL2_Type = TCR2MASK_EL2();

    if !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        mask.AMEC0 = mask_reg.AMEC0;
        mask.HAFT = mask_reg.HAFT;
        mask.PTTWI = mask_reg.PTTWI;
        mask.AIE = mask_reg.AIE;
        mask.POE = mask_reg.POE;
        mask.PIE = mask_reg.PIE;
        mask.PnCH = mask_reg.PnCH;
        mask[13+: 51] = Zeros{51};
        mask[5+: 5] = Zeros{5};
        mask[2+: 1] = '0';
    else
        mask.FNG1 = mask_reg.FNG1;
        mask.FNG0 = mask_reg.FNG0;
        mask.A2 = mask_reg.A2;
        mask.DisCH1 = mask_reg.DisCH1;
        mask.DisCH0 = mask_reg.DisCH0;
        mask.AMEC1 = mask_reg.AMEC1;
        mask.AMEC0 = mask_reg.AMEC0;
        mask.HAFT = mask_reg.HAFT;
        mask.PTTWI = mask_reg.PTTWI;
        mask.D128 = mask_reg.D128;
        mask.AIE = mask_reg.AIE;
        mask.POE = mask_reg.POE;
        mask.E0POE = mask_reg.E0POE;
        mask.PIE = mask_reg.PIE;
        mask.PnCH = mask_reg.PnCH;
        mask[19+: 45] = Zeros{45};
        mask[6+: 4] = Zeros{4};
    end;
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveTCRMASK_EL1"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveTCRMASK_EL1</h3>
      <p class="pseudocode">// EffectiveTCRMASK_EL1()
// ======================
// Return the effective value of TCRMASK_EL1.

func <a id="func_EffectiveTCRMASK_EL1_0"/>EffectiveTCRMASK_EL1() =&gt; TCR_EL1_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_EL2Enabled_0" title="">EL2Enabled</a>() &amp;&amp; (!<a href="shared_pseudocode.html#func_IsHCRXEL2Enabled_0" title="">IsHCRXEL2Enabled</a>() || HCRX_EL2().SRMASKEn == '0') then
        return Zeros{64};
    end;
    var mask : TCR_EL1_Type = Ones{64};
    let mask_reg : TCRMASK_EL1_Type = TCRMASK_EL1();

    mask.MTX1 = mask_reg.MTX1;
    mask.MTX0 = mask_reg.MTX0;
    mask.DS = mask_reg.DS;
    mask.TCMA1 = mask_reg.TCMA1;
    mask.TCMA0 = mask_reg.TCMA0;
    mask.E0PD1 = mask_reg.E0PD1;
    mask.E0PD0 = mask_reg.E0PD0;
    mask.NFD1 = mask_reg.NFD1;
    mask.NFD0 = mask_reg.NFD0;
    mask.TBID1 = mask_reg.TBID1;
    mask.TBID0 = mask_reg.TBID0;
    mask.HWU162 = mask_reg.HWU162;
    mask.HWU161 = mask_reg.HWU161;
    mask.HWU160 = mask_reg.HWU160;
    mask.HWU159 = mask_reg.HWU159;
    mask.HWU062 = mask_reg.HWU062;
    mask.HWU061 = mask_reg.HWU061;
    mask.HWU060 = mask_reg.HWU060;
    mask.HWU059 = mask_reg.HWU059;
    mask.HPD1 = mask_reg.HPD1;
    mask.HPD0 = mask_reg.HPD0;
    mask.HD = mask_reg.HD;
    mask.HA = mask_reg.HA;
    mask.TBI1 = mask_reg.TBI1;
    mask.TBI0 = mask_reg.TBI0;
    mask.AS = mask_reg.AS;
    mask.IPS = SignExtend{3}(mask_reg.IPS);
    mask.TG1 = SignExtend{2}(mask_reg.TG1);
    mask.SH1 = SignExtend{2}(mask_reg.SH1);
    mask.ORGN1 = SignExtend{2}(mask_reg.ORGN1);
    mask.IRGN1 = SignExtend{2}(mask_reg.IRGN1);
    mask.EPD1 = mask_reg.EPD1;
    mask.A1 = mask_reg.A1;
    mask.T1SZ = SignExtend{6}(mask_reg.T1SZ);
    mask.TG0 = SignExtend{2}(mask_reg.TG0);
    mask.SH0 = SignExtend{2}(mask_reg.SH0);
    mask.ORGN0 = SignExtend{2}(mask_reg.ORGN0);
    mask.IRGN0 = SignExtend{2}(mask_reg.IRGN0);
    mask.EPD0 = mask_reg.EPD0;
    mask.T0SZ = SignExtend{6}(mask_reg.T0SZ);
    mask[62+: 2] = Zeros{2};
    mask[35+: 1] = '0';
    mask[6+: 1] = '0';
    return mask;
end;</p>
    </div>
    <div class="ps"><a id="srmask.EffectiveTCRMASK_EL2"/><h3 class="pseudocode">
            Library pseudocode for srmask/EffectiveTCRMASK_EL2</h3>
      <p class="pseudocode">// EffectiveTCRMASK_EL2()
// ======================
// Return the effective value of TCRMASK_EL2.

func <a id="func_EffectiveTCRMASK_EL2_0"/>EffectiveTCRMASK_EL2() =&gt; TCR_EL2_Type
begin
    if !IsFeatureImplemented(FEAT_SRMASK) then return Zeros{64}; end;
    if <a href="shared_pseudocode.html#func_HaveEL_1" title="">HaveEL</a>(<a href="shared_pseudocode.html#global_EL3" title="">EL3</a>) &amp;&amp; SCR_EL3().SRMASKEn == '0' then return Zeros{64}; end;
    var mask : TCR_EL2_Type = Ones{64};
    let mask_reg : TCRMASK_EL2_Type = TCRMASK_EL2();

    if !<a href="shared_pseudocode.html#func_ELIsInHost_1" title="">ELIsInHost</a>(<a href="shared_pseudocode.html#global_EL2" title="">EL2</a>) then
        mask.MTX = mask_reg.MTX;
        mask.DS = mask_reg.DS;
        mask.TCMA = mask_reg.TCMA;
        mask.TBID = mask_reg.TBID;
        mask.HWU62 = mask_reg.HWU62;
        mask.HWU61 = mask_reg.HWU61;
        mask.HWU60 = mask_reg.HWU60;
        mask.HWU59 = mask_reg.HWU59;
        mask.HPD = mask_reg.HPD;
        mask.HD = mask_reg.HD;
        mask.HA = mask_reg.HA;
        mask.TBI = mask_reg.TBI;
        mask.PS = SignExtend{3}(mask_reg.PS);
        mask.TG0 = SignExtend{2}(mask_reg.TG0);
        mask.SH0 = SignExtend{2}(mask_reg.SH0);
        mask.ORGN0 = SignExtend{2}(mask_reg.ORGN0);
        mask.IRGN0 = SignExtend{2}(mask_reg.IRGN0);
        mask.T0SZ = SignExtend{6}(mask_reg.T0SZ);
        mask[34+: 30] = Zeros{30};
        mask[31+: 1] = '0';
        mask[23+: 1] = '0';
        mask[19+: 1] = '0';
        mask[6+: 2] = Zeros{2};
    else
        mask.MTX1 = mask_reg.MTX1;
        mask.MTX0 = mask_reg.MTX0;
        mask.DS = mask_reg.DS;
        mask.TCMA1 = mask_reg.TCMA1;
        mask.TCMA0 = mask_reg.TCMA0;
        mask.E0PD1 = mask_reg.E0PD1;
        mask.E0PD0 = mask_reg.E0PD0;
        mask.NFD1 = mask_reg.NFD1;
        mask.NFD0 = mask_reg.NFD0;
        mask.TBID1 = mask_reg.TBID1;
        mask.TBID0 = mask_reg.TBID0;
        mask.HWU162 = mask_reg.HWU162;
        mask.HWU161 = mask_reg.HWU161;
        mask.HWU160 = mask_reg.HWU160;
        mask.HWU159 = mask_reg.HWU159;
        mask.HWU062 = mask_reg.HWU062;
        mask.HWU061 = mask_reg.HWU061;
        mask.HWU060 = mask_reg.HWU060;
        mask.HWU059 = mask_reg.HWU059;
        mask.HPD1 = mask_reg.HPD1;
        mask.HPD0 = mask_reg.HPD0;
        mask.HD = mask_reg.HD;
        mask.HA = mask_reg.HA;
        mask.TBI1 = mask_reg.TBI1;
        mask.TBI0 = mask_reg.TBI0;
        mask.AS = mask_reg.AS;
        mask.IPS = SignExtend{3}(mask_reg.IPS);
        mask.TG1 = SignExtend{2}(mask_reg.TG1);
        mask.SH1 = SignExtend{2}(mask_reg.SH1);
        mask.ORGN1 = SignExtend{2}(mask_reg.ORGN1);
        mask.IRGN1 = SignExtend{2}(mask_reg.IRGN1);
        mask.EPD1 = mask_reg.EPD1;
        mask.A1 = mask_reg.A1;
        mask.T1SZ = SignExtend{6}(mask_reg.T1SZ);
        mask.TG0 = SignExtend{2}(mask_reg.TG0);
        mask.SH0 = SignExtend{2}(mask_reg.SH0);
        mask.ORGN0 = SignExtend{2}(mask_reg.ORGN0);
        mask.IRGN0 = SignExtend{2}(mask_reg.IRGN0);
        mask.EPD0 = mask_reg.EPD0;
        mask.T0SZ = SignExtend{6}(mask_reg.T0SZ);
        mask[62+: 2] = Zeros{2};
        mask[35+: 1] = '0';
        mask[6+: 1] = '0';
    end;
    return mask;
end;</p>
    </div>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      2025-09_rel_asl1

      2025-10-24 12:15:02
    </p><p class="copyconf">
      Copyright  2010-2025 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
