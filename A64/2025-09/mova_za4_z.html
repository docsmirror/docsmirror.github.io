<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>MOVA (vector to tile, four registers) -- A64</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">MOVA (vector to tile, four registers)</h2><p>Move Z four-vector operand to ZA four-slice operand</p>
      <p class="aml">This instruction operates on a horizontal or
vertical ZA four-slice operand within a ZA tile of the specified element size.</p>
      <p class="aml">The first slice of the four-slice operand is selected by rounding down the
sum of the slice index register and the immediate offset to the nearest lower
multiple of 4, modulo the number of slices in the tile.</p>
      <p class="aml">The immediate offset is a multiple of 4 in the range 0 to the number
of elements in a 128-bit vector segment minus 4.</p>
      <p class="aml">This instruction is unpredicated.</p>
    <p class="desc">This instruction is used by the alias <a href="mov_mova_za4_z.html" title="Move Z four-vector operand to ZA four-slice operand">MOV (vector to tile, four registers)</a>.</p>
    <p class="desc">
      It has encodings from 4 classes:
      <a href="#iclass_8_bit">8-bit</a>
      , 
      <a href="#iclass_16_bit">16-bit</a>
      , 
      <a href="#iclass_32_bit">32-bit</a>
       and 
      <a href="#iclass_64_bit">64-bit</a>
    </p>
    <h3 class="classheading"><a id="iclass_8_bit"/>8-bit<span style="font-size:smaller;"><br/>(FEAT_SME2)
          </span></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">1</td><td class="l">1</td><td class="r">0</td><td class="l">0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">0</td><td class="l">0</td><td class="r">0</td><td class="l">0</td><td>0</td><td class="r">0</td><td class="lr">1</td><td class="lr">0</td><td class="lr">0</td><td class="lr">V</td><td colspan="2" class="lr">Rs</td><td class="l">0</td><td>0</td><td class="r">1</td><td colspan="3" class="lr">Zn</td><td class="l">0</td><td class="r">0</td><td class="lr">0</td><td class="lr">0</td><td class="lr">0</td><td colspan="2" class="lr">off2</td></tr><tr class="secondrow"><td/><td colspan="2"/><td colspan="4"/><td/><td colspan="2" class="droppedname">size</td><td colspan="3"/><td/><td/><td/><td/><td colspan="2"/><td colspan="3"/><td colspan="3"/><td colspan="2"/><td/><td/><td/><td colspan="2"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Encoding</h4><a id="mova_za4_z_b1"/><p class="asm-code">MOVA  ZA0<a href="#HV__6" title="Is the horizontal or vertical slice indicator, ">&lt;HV&gt;</a>.B[<a href="#Ws__3" title="Is the 32-bit name of the slice index register W12-W15, encoded in the &quot;Rs&quot; field.">&lt;Ws&gt;</a>, <a href="#offs1__9" title="For the &quot;8-bit&quot; variant: is the first slice index offset, encoded as &quot;off2&quot; field times 4.">&lt;offs1&gt;</a>:<a href="#offs4__3" title="For the &quot;8-bit&quot; variant: is the fourth slice index offset, encoded as &quot;off2&quot; field times 4 plus 3.">&lt;offs4&gt;</a>], { <a href="#Zn1__6" title="Is the name of the first scalable vector register of the source multi-vector group, encoded as &quot;Zn&quot; times 4.">&lt;Zn1&gt;</a>.B-<a href="#Zn4__3" title="Is the name of the fourth scalable vector register of the source multi-vector group, encoded as &quot;Zn&quot; times 4 plus 3.">&lt;Zn4&gt;</a>.B }</p></div><h4>Decode for this encoding</h4><p class="pseudocode">if !IsFeatureImplemented(FEAT_SME2) then EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>); end;
let s : integer = UInt('011'::Rs);
let nreg : integer{} = 4;
let esize : integer{} = 8;
let n : integer = UInt(Zn::'00');
let d : integer = 0;
let offset : integer = UInt(off2::'00');
let vertical : boolean = V == '1';</p>
    <h3 class="classheading"><a id="iclass_16_bit"/>16-bit<span style="font-size:smaller;"><br/>(FEAT_SME2)
          </span></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">1</td><td class="l">1</td><td class="r">0</td><td class="l">0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">0</td><td class="l">0</td><td class="r">1</td><td class="l">0</td><td>0</td><td class="r">0</td><td class="lr">1</td><td class="lr">0</td><td class="lr">0</td><td class="lr">V</td><td colspan="2" class="lr">Rs</td><td class="l">0</td><td>0</td><td class="r">1</td><td colspan="3" class="lr">Zn</td><td class="l">0</td><td class="r">0</td><td class="lr">0</td><td class="lr">0</td><td class="lr">0</td><td class="lr">ZAd</td><td class="lr">o1</td></tr><tr class="secondrow"><td/><td colspan="2"/><td colspan="4"/><td/><td colspan="2" class="droppedname">size</td><td colspan="3"/><td/><td/><td/><td/><td colspan="2"/><td colspan="3"/><td colspan="3"/><td colspan="2"/><td/><td/><td/><td/><td/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Encoding</h4><a id="mova_za4_z_h1"/><p class="asm-code">MOVA  <a href="#ZAd__2" title="For the &quot;16-bit&quot; variant: is the name of the ZA tile ZA0-ZA1 to be accessed, encoded in the &quot;ZAd&quot; field.">&lt;ZAd&gt;</a><a href="#HV__6" title="Is the horizontal or vertical slice indicator, ">&lt;HV&gt;</a>.H[<a href="#Ws__3" title="Is the 32-bit name of the slice index register W12-W15, encoded in the &quot;Rs&quot; field.">&lt;Ws&gt;</a>, <a href="#offs1__10" title="For the &quot;16-bit&quot; variant: is the first slice index offset, encoded as &quot;o1&quot; field times 4.">&lt;offs1&gt;</a>:<a href="#offs4__5" title="For the &quot;16-bit&quot; variant: is the fourth slice index offset, encoded as &quot;o1&quot; field times 4 plus 3.">&lt;offs4&gt;</a>], { <a href="#Zn1__6" title="Is the name of the first scalable vector register of the source multi-vector group, encoded as &quot;Zn&quot; times 4.">&lt;Zn1&gt;</a>.H-<a href="#Zn4__3" title="Is the name of the fourth scalable vector register of the source multi-vector group, encoded as &quot;Zn&quot; times 4 plus 3.">&lt;Zn4&gt;</a>.H }</p></div><h4>Decode for this encoding</h4><p class="pseudocode">if !IsFeatureImplemented(FEAT_SME2) then EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>); end;
let s : integer = UInt('011'::Rs);
let nreg : integer{} = 4;
let esize : integer{} = 16;
let n : integer = UInt(Zn::'00');
let d : integer = UInt(ZAd);
let offset : integer = UInt(o1::'00');
let vertical : boolean = V == '1';</p>
    <h3 class="classheading"><a id="iclass_32_bit"/>32-bit<span style="font-size:smaller;"><br/>(FEAT_SME2)
          </span></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">1</td><td class="l">1</td><td class="r">0</td><td class="l">0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">0</td><td class="l">1</td><td class="r">0</td><td class="l">0</td><td>0</td><td class="r">0</td><td class="lr">1</td><td class="lr">0</td><td class="lr">0</td><td class="lr">V</td><td colspan="2" class="lr">Rs</td><td class="l">0</td><td>0</td><td class="r">1</td><td colspan="3" class="lr">Zn</td><td class="l">0</td><td class="r">0</td><td class="lr">0</td><td class="lr">0</td><td class="lr">0</td><td colspan="2" class="lr">ZAd</td></tr><tr class="secondrow"><td/><td colspan="2"/><td colspan="4"/><td/><td colspan="2" class="droppedname">size</td><td colspan="3"/><td/><td/><td/><td/><td colspan="2"/><td colspan="3"/><td colspan="3"/><td colspan="2"/><td/><td/><td/><td colspan="2"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Encoding</h4><a id="mova_za4_z_w1"/><p class="asm-code">MOVA  <a href="#ZAd__3" title="For the &quot;32-bit&quot; variant: is the name of the ZA tile ZA0-ZA3 to be accessed, encoded in the &quot;ZAd&quot; field.">&lt;ZAd&gt;</a><a href="#HV__6" title="Is the horizontal or vertical slice indicator, ">&lt;HV&gt;</a>.S[<a href="#Ws__3" title="Is the 32-bit name of the slice index register W12-W15, encoded in the &quot;Rs&quot; field.">&lt;Ws&gt;</a>, <a href="#offs1__6" title="For the &quot;32-bit&quot; and &quot;64-bit&quot; variants: is the first slice index offset, with implicit value 0.">&lt;offs1&gt;</a>:<a href="#offs4__4" title="For the &quot;32-bit&quot; and &quot;64-bit&quot; variants: is the fourth slice index offset, with implicit value 3.">&lt;offs4&gt;</a>], { <a href="#Zn1__6" title="Is the name of the first scalable vector register of the source multi-vector group, encoded as &quot;Zn&quot; times 4.">&lt;Zn1&gt;</a>.S-<a href="#Zn4__3" title="Is the name of the fourth scalable vector register of the source multi-vector group, encoded as &quot;Zn&quot; times 4 plus 3.">&lt;Zn4&gt;</a>.S }</p></div><h4>Decode for this encoding</h4><p class="pseudocode">if !IsFeatureImplemented(FEAT_SME2) then EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>); end;
let s : integer = UInt('011'::Rs);
let nreg : integer{} = 4;
let esize : integer{} = 32;
let n : integer = UInt(Zn::'00');
let d : integer = UInt(ZAd);
let offset : integer = 0;
let vertical : boolean = V == '1';</p>
    <h3 class="classheading"><a id="iclass_64_bit"/>64-bit<span style="font-size:smaller;"><br/>(FEAT_SME2)
          </span></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">1</td><td class="l">1</td><td class="r">0</td><td class="l">0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">0</td><td class="l">1</td><td class="r">1</td><td class="l">0</td><td>0</td><td class="r">0</td><td class="lr">1</td><td class="lr">0</td><td class="lr">0</td><td class="lr">V</td><td colspan="2" class="lr">Rs</td><td class="l">0</td><td>0</td><td class="r">1</td><td colspan="3" class="lr">Zn</td><td class="l">0</td><td class="r">0</td><td class="lr">0</td><td class="lr">0</td><td colspan="3" class="lr">ZAd</td></tr><tr class="secondrow"><td/><td colspan="2"/><td colspan="4"/><td/><td colspan="2" class="droppedname">size</td><td colspan="3"/><td/><td/><td/><td/><td colspan="2"/><td colspan="3"/><td colspan="3"/><td colspan="2"/><td/><td/><td colspan="3"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Encoding</h4><a id="mova_za4_z_d1"/><p class="asm-code">MOVA  <a href="#ZAd" title="For the &quot;64-bit&quot; variant: is the name of the ZA tile ZA0-ZA7 to be accessed, encoded in the &quot;ZAd&quot; field.">&lt;ZAd&gt;</a><a href="#HV__6" title="Is the horizontal or vertical slice indicator, ">&lt;HV&gt;</a>.D[<a href="#Ws__3" title="Is the 32-bit name of the slice index register W12-W15, encoded in the &quot;Rs&quot; field.">&lt;Ws&gt;</a>, <a href="#offs1__6" title="For the &quot;32-bit&quot; and &quot;64-bit&quot; variants: is the first slice index offset, with implicit value 0.">&lt;offs1&gt;</a>:<a href="#offs4__4" title="For the &quot;32-bit&quot; and &quot;64-bit&quot; variants: is the fourth slice index offset, with implicit value 3.">&lt;offs4&gt;</a>], { <a href="#Zn1__6" title="Is the name of the first scalable vector register of the source multi-vector group, encoded as &quot;Zn&quot; times 4.">&lt;Zn1&gt;</a>.D-<a href="#Zn4__3" title="Is the name of the fourth scalable vector register of the source multi-vector group, encoded as &quot;Zn&quot; times 4 plus 3.">&lt;Zn4&gt;</a>.D }</p></div><h4>Decode for this encoding</h4><p class="pseudocode">if !IsFeatureImplemented(FEAT_SME2) then EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>); end;
if MaxImplementedSVL() &lt; 256 then EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>); end;
let s : integer = UInt('011'::Rs);
let nreg : integer{} = 4;
let esize : integer{} = 64;
let n : integer = UInt(Zn::'00');
let d : integer = UInt(ZAd);
let offset : integer = 0;
let vertical : boolean = V == '1';</p>
  <div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;HV&gt;</td><td><a id="HV__6"/>
        <p>Is the horizontal or vertical slice indicator, 
          encoded in
          <q>V</q>:
            </p>
        <table class="valuetable">
          
            <thead>
              <tr>
                <th class="bitfield">V</th>
                <th class="symbol">&lt;HV&gt;</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="bitfield">0</td>
                <td class="symbol">H</td>
              </tr>
              <tr>
                <td class="bitfield">1</td>
                <td class="symbol">V</td>
              </tr>
            </tbody>
          
        </table>
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Ws&gt;</td><td><a id="Ws__3"/>
        
          <p class="aml">Is the 32-bit name of the slice index register W12-W15, encoded in the "Rs" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;offs1&gt;</td><td><a id="offs1__9"/>
        
          <p class="aml">For the "8-bit" variant: is the first slice index offset, encoded as "off2" field times 4.</p>
        
      </td></tr><tr><td/><td><a id="offs1__10"/>
        
          <p class="aml">For the "16-bit" variant: is the first slice index offset, encoded as "o1" field times 4.</p>
        
      </td></tr><tr><td/><td><a id="offs1__6"/>
        
          <p class="aml">For the "32-bit" and "64-bit" variants: is the first slice index offset, with implicit value 0.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;offs4&gt;</td><td><a id="offs4__3"/>
        
          <p class="aml">For the "8-bit" variant: is the fourth slice index offset, encoded as "off2" field times 4 plus 3.</p>
        
      </td></tr><tr><td/><td><a id="offs4__5"/>
        
          <p class="aml">For the "16-bit" variant: is the fourth slice index offset, encoded as "o1" field times 4 plus 3.</p>
        
      </td></tr><tr><td/><td><a id="offs4__4"/>
        
          <p class="aml">For the "32-bit" and "64-bit" variants: is the fourth slice index offset, with implicit value 3.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zn1&gt;</td><td><a id="Zn1__6"/>
        
          <p class="aml">Is the name of the first scalable vector register of the source multi-vector group, encoded as "Zn" times 4.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zn4&gt;</td><td><a id="Zn4__3"/>
        
          <p class="aml">Is the name of the fourth scalable vector register of the source multi-vector group, encoded as "Zn" times 4 plus 3.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;ZAd&gt;</td><td><a id="ZAd__2"/>
        
          <p class="aml">For the "16-bit" variant: is the name of the ZA tile ZA0-ZA1 to be accessed, encoded in the "ZAd" field.</p>
        
      </td></tr><tr><td/><td><a id="ZAd__3"/>
        
          <p class="aml">For the "32-bit" variant: is the name of the ZA tile ZA0-ZA3 to be accessed, encoded in the "ZAd" field.</p>
        
      </td></tr><tr><td/><td><a id="ZAd"/>
        
          <p class="aml">For the "64-bit" variant: is the name of the ZA tile ZA0-ZA7 to be accessed, encoded in the "ZAd" field.</p>
        
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id=""/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">CheckStreamingSVEAndZAEnabled();
let VL : integer{} = CurrentVL();
if nreg == 4 &amp;&amp; esize == 64 &amp;&amp; VL &lt; 256 then EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>); end;
let slices : integer = VL DIV esize;
let index : bits(32) = X{}(s);
let slice : integer = ((UInt(index) - (UInt(index) MOD nreg)) + offset) MOD slices;

for r = 0 to nreg-1 do
    let result : bits(VL) = Z{}(n + r);
    ZAslice{VL}(d, esize, vertical, slice + r) = result;
end;</p>
    </div>
  <h3>Operational information</h3>
    
      
        <p class="aml">This instruction is a data-independent-time instruction as described in <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="ARMARM_BEICCDDAB3">About PSTATE.DIT</a>.</p>
      
    
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      2025-09_rel_asl1

      2025-10-24 12:15:02
    </p><p class="copyconf">
      Copyright Â© 2010-2025 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
