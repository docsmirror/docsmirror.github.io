<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>SETP, SETM, SETE -- A64</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">SETP, SETM, SETE</h2><p>Memory set</p>
      <p class="aml">These instructions set a required number of bytes in memory to the value in the least significant
byte of the source data register. The prologue, main, and epilogue instructions are expected to
be run in succession and to appear consecutively in memory: SETP, then SETM,
and then SETE.</p>
      <p class="aml">SETP performs some preconditioning of the arguments suitable for using the
SETM instruction, and sets an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> portion of the requested number
of bytes. SETM sets a further <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> portion of the remaining bytes.
SETE sets any final remaining bytes.</p>
      <div class="note"><hr class="note"/><h4>Note</h4>
        <p class="aml">The ability to set an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> number of bytes allows an implementation to
optimize how the bytes being set are divided between the different instructions.</p>
      <hr class="note"/></div>
      <p class="aml">For more information on exceptions specific to memory set instructions,
see <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="ARMARM_MDSec.memcpy_and_memset_exceptions">Memory Copy and Memory Set exceptions</a>.</p>
      <p class="aml">The architecture supports two algorithms for the memory set: option A and option B. Which
algorithm is used is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
      <div class="note"><hr class="note"/><h4>Note</h4>
        <p class="aml">Portable software should not assume that the choice of algorithm is constant.</p>
      <hr class="note"/></div>
      <p class="aml">For SETP:</p>
      <ul>
        <li>
          If Xn[63] == '1', the set size is saturated to 0x7FFFFFFFFFFFFFFF.
        </li>
      </ul>
      <p class="aml">On completion of SETP, option A:</p>
      <ul>
        <li>
          Xn holds -1 times the number of bytes in the saturated set size remaining to be set.
        </li>
        <li>
          Xd holds the original Xd + saturated set size.
        </li>
        <li>
          PSTATE.{N,Z,C,V} are set to {0,0,0,0}.
        </li>
      </ul>
      <p class="aml">On completion of SETP, option B:</p>
      <ul>
        <li>
          Xn holds the number of bytes in the saturated set size remaining to be set.
        </li>
        <li>
          Xd holds the lowest address that has not been set.
        </li>
        <li>
          PSTATE.{N,Z,C,V} are set to {0,0,1,0}.
        </li>
      </ul>
      <p class="aml">For SETM, option A, when PSTATE.C = '0':</p>
      <ul>
        <li>
          Xn holds a signed 64-bit integer.
        </li>
        <li>
          Xn holds -1 times the number of bytes remaining to be set.
        </li>
        <li>
          Xd holds the lowest address to be set - Xn.
        </li>
        <li>
          On completion of the instruction, Xn holds -1 times the number of bytes remaining to be set.
        </li>
      </ul>
      <p class="aml">For SETM, option B, when PSTATE.C = '1':</p>
      <ul>
        <li>
          Xn holds the number of bytes remaining to be set.
        </li>
        <li>
          Xd holds the lowest address to be set.
        </li>
        <li>
          On completion of the instruction:<ul>
              <li>
                Xn holds the number of bytes remaining to be set.
              </li>
              <li>
                Xd holds the lowest address that has not been set.
              </li>
            </ul>
          
        </li>
      </ul>
      <p class="aml">For SETE, option A, when PSTATE.C = '0':</p>
      <ul>
        <li>
          Xn holds a signed 64-bit integer.
        </li>
        <li>
          Xn holds -1 times the number of bytes remaining to be set.
        </li>
        <li>
          Xd holds the lowest address to be set - Xn.
        </li>
        <li>
          On completion of the instruction, Xn holds 0.
        </li>
      </ul>
      <p class="aml">For SETE, option B, when PSTATE.C = '1':</p>
      <ul>
        <li>
          Xn holds the number of bytes remaining to be set.
        </li>
        <li>
          Xd holds the lowest address to be set.
        </li>
        <li>
          On completion of the instruction:<ul>
              <li>
                Xn holds 0.
              </li>
              <li>
                Xd holds the lowest address that has not been set.
              </li>
            </ul>
          
        </li>
      </ul>
    
    <h3 class="classheading"><a id="iclass_integer"/>Integer<span style="font-size:smaller;"><br/>(FEAT_MOPS)
          </span></h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td colspan="2" class="lr">sz</td><td class="l">0</td><td>1</td><td class="r">1</td><td class="lr">0</td><td class="l">0</td><td class="r">1</td><td class="l">1</td><td class="r">1</td><td class="lr">0</td><td colspan="5" class="lr">Rs</td><td class="l">x</td><td>x</td><td>0</td><td class="r">0</td><td class="l">0</td><td class="r">1</td><td colspan="5" class="lr">Rn</td><td colspan="5" class="lr">Rd</td></tr><tr class="secondrow"><td colspan="2"/><td colspan="3"/><td class="droppedname">o0</td><td colspan="2"/><td colspan="2" class="droppedname">op1</td><td/><td colspan="5"/><td colspan="4" class="droppedname">op2</td><td colspan="2"/><td colspan="5"/><td colspan="5"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">
              Encoding for the Prologue variant
            </h4><a id="SETP_SET_memcms"/>
        Applies when
        <span class="bitdiff"> (op2 == 0000)</span><p class="asm-code">SETP  [<a href="#XdOrXZR" title="For the &quot;Prologue&quot; variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the &quot;Rd&quot; field.">&lt;Xd&gt;</a>]!, <a href="#XnOrXZR__5" title="For the &quot;Prologue&quot; variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set and is updated by the instruction, encoded in the &quot;Rn&quot; field.">&lt;Xn&gt;</a>!, <a href="#XsOrXZR__7" title="Is the 64-bit name of the general-purpose register that holds the source data, encoded in the &quot;Rs&quot; field.">&lt;Xs&gt;</a></p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Main variant
            </h4><a id="SETM_SET_memcms"/>
        Applies when
        <span class="bitdiff"> (op2 == 0100)</span><p class="asm-code">SETM  [<a href="#XdOrXZR__3" title="For the &quot;Epilogue&quot; and &quot;Main&quot; variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address and for option B is updated by the instruction, encoded in the &quot;Rd&quot; field.">&lt;Xd&gt;</a>]!, <a href="#XnOrXZR__6" title="For the &quot;Main&quot; variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set and is updated by the instruction, encoded in the &quot;Rn&quot; field.">&lt;Xn&gt;</a>!, <a href="#XsOrXZR__7" title="Is the 64-bit name of the general-purpose register that holds the source data, encoded in the &quot;Rs&quot; field.">&lt;Xs&gt;</a></p></div><div class="encoding"><h4 class="encoding">
              Encoding for the Epilogue variant
            </h4><a id="SETE_SET_memcms"/>
        Applies when
        <span class="bitdiff"> (op2 == 1000)</span><p class="asm-code">SETE  [<a href="#XdOrXZR__3" title="For the &quot;Epilogue&quot; and &quot;Main&quot; variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address and for option B is updated by the instruction, encoded in the &quot;Rd&quot; field.">&lt;Xd&gt;</a>]!, <a href="#XnOrXZR__7" title="For the &quot;Epilogue&quot; variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set and is set to zero on completion of the instruction, encoded in the &quot;Rn&quot; field.">&lt;Xn&gt;</a>!, <a href="#XsOrXZR__7" title="Is the 64-bit name of the general-purpose register that holds the source data, encoded in the &quot;Rs&quot; field.">&lt;Xs&gt;</a></p></div><h4>Decode for all variants of this encoding</h4><p class="pseudocode">if !IsFeatureImplemented(FEAT_MOPS) || sz != '00' then EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>); end;

var memset : SETParams;
memset.d = UInt(Rd);
memset.s = UInt(Rs);
memset.n = UInt(Rn);
let options : bits(2) = op2[1:0];
let nontemporal : boolean = options[1] == '1';

case op2[3:2] of
    when '00' =&gt; memset.stage = MOPSStage_Prologue;
    when '01' =&gt; memset.stage = MOPSStage_Main;
    when '10' =&gt; memset.stage = MOPSStage_Epilogue;
    otherwise =&gt; EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>);
end;</p>
  <div class="encoding-notes">
      <p class="aml">For information about the <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span> behavior of this instruction, see <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="CJAEGDJC">Architectural Constraints on UNPREDICTABLE behaviors</a>, and particularly <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="CEGDGDDAG2">Memory Copy and Memory Set SET*</a> and <a class="armarm-xref" title="Reference to Armv8 ARM section" data-linkend="ARMARM_CEGCCGAE">Crossing a page boundary with different memory types or Shareability attributes</a>.</p>
    </div><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Xd&gt;</td><td><a id="XdOrXZR"/>
        
          <p class="aml">For the "Prologue" variant: is the 64-bit name of the general-purpose register that holds the destination address and is updated by the instruction, encoded in the "Rd" field.</p>
        
      </td></tr><tr><td/><td><a id="XdOrXZR__3"/>
        
          <p class="aml">For the "Epilogue" and "Main" variants: is the 64-bit name of the general-purpose register that holds an encoding of the destination address and for option B is updated by the instruction, encoded in the "Rd" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Xn&gt;</td><td><a id="XnOrXZR__5"/>
        
          <p class="aml">For the "Prologue" variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set and is updated by the instruction, encoded in the "Rn" field.</p>
        
      </td></tr><tr><td/><td><a id="XnOrXZR__6"/>
        
          <p class="aml">For the "Main" variant: is the 64-bit name of the general-purpose register that holds an encoding of the number of bytes to be set and is updated by the instruction, encoded in the "Rn" field.</p>
        
      </td></tr><tr><td/><td><a id="XnOrXZR__7"/>
        
          <p class="aml">For the "Epilogue" variant: is the 64-bit name of the general-purpose register that holds the number of bytes to be set and is set to zero on completion of the instruction, encoded in the "Rn" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Xs&gt;</td><td><a id="XsOrXZR__7"/>
        
          <p class="aml">Is the 64-bit name of the general-purpose register that holds the source data, encoded in the "Rs" field.</p>
        
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id=""/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">CheckMOPSEnabled();

CheckSETConstrainedUnpredictable(memset.n, memset.d, memset.s);

let data : bits(8) = X{}(memset.s);
var B : MOPSBlockSize = 0;

memset.is_setg = FALSE;
memset.nzcv = PSTATE.[N,Z,C,V];
memset.toaddress = <a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memset.d);
if memset.stage == MOPSStage_Prologue then
    memset.setsize = UInt(<a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memset.n));
else
    memset.setsize = SInt(<a href="shared_pseudocode.html#accessor_X_2" title="">X</a>{64}(memset.n));
end;
memset.implements_option_a = <a href="shared_pseudocode.html#func_SETOptionA_0" title="">SETOptionA</a>();

let privileged : boolean = (if options[0] == '1' then <a href="shared_pseudocode.html#func_AArch64_IsUnprivAccessPriv_0" title="">AArch64_IsUnprivAccessPriv</a>()
                               else PSTATE.EL != <a href="shared_pseudocode.html#global_EL0" title="">EL0</a>);

let accdesc : <a href="shared_pseudocode.html#type_AccessDescriptor" title="">AccessDescriptor</a> = CreateAccDescMOPS(MemOp_STORE, privileged, nontemporal);

if memset.stage == MOPSStage_Prologue then
    if memset.setsize &gt; <a href="shared_pseudocode.html#global_ArchMaxMOPSBlockSize" title="">ArchMaxMOPSBlockSize</a> then
        memset.setsize = <a href="shared_pseudocode.html#global_ArchMaxMOPSBlockSize" title="">ArchMaxMOPSBlockSize</a>;
    end;

    if memset.implements_option_a then
        memset.nzcv = '0000';
        memset.toaddress = memset.toaddress + memset.setsize;
        memset.setsize   = 0 - memset.setsize;
    else
        memset.nzcv = '0010';
    end;
end;

memset.stagesetsize = <a href="shared_pseudocode.html#func_MemSetStageSize_1" title="">MemSetStageSize</a>(memset);

if memset.stage != MOPSStage_Prologue then
    CheckMemSetParams(memset, options);
end;

var memaddrdesc : <a href="shared_pseudocode.html#type_AddressDescriptor" title="">AddressDescriptor</a>;
var memstatus : <a href="shared_pseudocode.html#type_PhysMemRetStatus" title="">PhysMemRetStatus</a>;
var memory_set : integer;
var fault : boolean = FALSE;

if memset.implements_option_a then
    while memset.stagesetsize &lt; 0 &amp;&amp; !fault looplimit <a href="shared_pseudocode.html#global_ArchMaxMOPSBlockSize" title="">ArchMaxMOPSBlockSize</a> do
        // IMP DEF selection of the block size that is worked on. While many
        // implementations might make this constant, that is not assumed.
        B = SETSizeChoice(memset, 1);
        assert B &lt;= -1 * memset.stagesetsize;

        (memory_set, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress + memset.setsize,
                                                           data, B, accdesc);

        if memory_set != B then
            fault = TRUE;
        else
            memset.setsize      = memset.setsize      + B;
            memset.stagesetsize = memset.stagesetsize + B;
        end;
    end;

else
    while memset.stagesetsize &gt; 0 &amp;&amp; !fault looplimit <a href="shared_pseudocode.html#global_ArchMaxMOPSBlockSize" title="">ArchMaxMOPSBlockSize</a> do
        // IMP DEF selection of the block size that is worked on. While many
        // implementations might make this constant, that is not assumed.
        B = SETSizeChoice(memset, 1);
        assert B &lt;= memset.stagesetsize;

        (memory_set, memaddrdesc, memstatus) = MemSetBytes(memset.toaddress, data, B, accdesc);

        if memory_set != B then
            fault = TRUE;
        else
            memset.toaddress    = memset.toaddress    + B;
            memset.setsize      = memset.setsize      - B;
            memset.stagesetsize = memset.stagesetsize - B;
        end;
    end;
end;

UpdateSetRegisters(memset, fault, memory_set);

if fault then
    if <a href="shared_pseudocode.html#func_IsFault_1" title="">IsFault</a>(memaddrdesc) then
        AArch64_Abort(memaddrdesc.fault);
    else
        let iswrite : boolean = TRUE;
        HandleExternalAbort(memstatus, iswrite, memaddrdesc, B, accdesc);
    end;
end;

if memset.stage == MOPSStage_Prologue then
    PSTATE.[N,Z,C,V] = memset.nzcv;
end;</p>
    </div>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      2025-09_rel_asl1

      2025-10-24 12:15:02
    </p><p class="copyconf">
      Copyright Â© 2010-2025 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
