<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>BFCLAMP -- A64</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">BFCLAMP</h2><p>Multi-vector BFloat16 clamp to minimum/maximum number</p>
      <p class="aml">This instruction clamps each BFloat16 element in the two or four destination vectors
to between the BFloat16 minimum value in the corresponding element of the
first source vector and the BFloat16 maximum value in the corresponding element
of the second source vector and destructively places the clamped results
in the corresponding elements of the two or four destination vectors.</p>
      <p class="aml">Regardless of the value of FPCR.AH, the behavior is as follows for each minimum number and maximum number operation:</p>
      <ul>
        <li>
          Negative zero compares less than positive zero.
        </li>
        <li>
          If one value is numeric and the other
  is a quiet NaN, the result is the numeric
  value.
        </li>
        <li>
          When FPCR.DN is 0, if either value is a signaling NaN or if both values are NaNs,
  the result is a quiet NaN.
        </li>
        <li>
          When FPCR.DN is 1, if either value is a signaling NaN or if both values are NaNs,
  the result is Default NaN.
        </li>
      </ul>
      <p class="aml">This instruction follows SME2 non-widening BFloat16 numerical behaviors
corresponding to instructions that place their results in two or four SVE Z vectors.</p>
      <p class="aml">This instruction is unpredicated.</p>
      <p class="aml">ID_AA64ZFR0_EL1.B16B16 indicates whether this instruction is implemented.</p>
    
    <p class="desc">
      It has encodings from 2 classes:
      <a href="#iclass_two_registers">Two registers</a>
       and 
      <a href="#iclass_four_registers">Four registers</a>
    </p>
    <h3 class="classheading"><a id="iclass_two_registers"/>Two registers<span style="font-size:smaller;"><br/>(FEAT_SME2 &amp;&amp; FEAT_SVE_B16B16)
          </span></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">1</td><td class="l">1</td><td class="r">0</td><td class="l">0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">1</td><td class="l">0</td><td class="r">0</td><td class="lr">1</td><td colspan="5" class="lr">Zm</td><td class="l">1</td><td>1</td><td class="r">0</td><td class="l">0</td><td>0</td><td class="r">0</td><td colspan="5" class="lr">Zn</td><td colspan="4" class="lr">Zd</td><td class="lr">0</td></tr><tr class="secondrow"><td/><td colspan="2"/><td colspan="4"/><td/><td colspan="2" class="droppedname">size</td><td/><td colspan="5"/><td colspan="3"/><td colspan="3"/><td colspan="5"/><td colspan="4"/><td class="droppedname">op</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Encoding</h4><a id="bfclamp_mz_zz_2"/><p class="asm-code">BFCLAMP  { <a href="#Zd1" title="For the &quot;Two registers&quot; variant: is the name of the first scalable vector register of the destination multi-vector group, encoded as &quot;Zd&quot; times 2.">&lt;Zd1&gt;</a>.H-<a href="#Zd2" title="For the &quot;Consecutive&quot; variant: is the name of the second scalable vector register of the destination multi-vector group, encoded as &quot;Zd&quot; times 2 plus 1.">&lt;Zd2&gt;</a>.H }, <a href="#Zn__2" title="Is the name of the first source scalable vector register, encoded in the &quot;Zn&quot; field.">&lt;Zn&gt;</a>.H, <a href="#Zm" title="Is the name of the second source scalable vector register, encoded in the &quot;Zm&quot; field.">&lt;Zm&gt;</a>.H</p></div><h4>Decode for this encoding</h4><p class="pseudocode">if !IsFeatureImplemented(FEAT_SME2) || !IsFeatureImplemented(FEAT_SVE_B16B16) then
    EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>);
end;
let n : integer = UInt(Zn);
let m : integer = UInt(Zm);
let d : integer = UInt(Zd::'0');
let nreg : integer{} = 2;</p>
    <h3 class="classheading"><a id="iclass_four_registers"/>Four registers<span style="font-size:smaller;"><br/>(FEAT_SME2 &amp;&amp; FEAT_SVE_B16B16)
          </span></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">1</td><td class="l">1</td><td class="r">0</td><td class="l">0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">1</td><td class="l">0</td><td class="r">0</td><td class="lr">1</td><td colspan="5" class="lr">Zm</td><td class="l">1</td><td>1</td><td class="r">0</td><td class="l">0</td><td>1</td><td class="r">0</td><td colspan="5" class="lr">Zn</td><td colspan="3" class="lr">Zd</td><td class="lr">0</td><td class="lr">0</td></tr><tr class="secondrow"><td/><td colspan="2"/><td colspan="4"/><td/><td colspan="2" class="droppedname">size</td><td/><td colspan="5"/><td colspan="3"/><td colspan="3"/><td colspan="5"/><td colspan="3"/><td/><td class="droppedname">op</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Encoding</h4><a id="bfclamp_mz_zz_4"/><p class="asm-code">BFCLAMP  { <a href="#Zd1__2" title="For the &quot;Four registers&quot; variant: is the name of the first scalable vector register of the destination multi-vector group, encoded as &quot;Zd&quot; times 4.">&lt;Zd1&gt;</a>.H-<a href="#Zd4" title="For the &quot;Consecutive&quot; variant: is the name of the fourth scalable vector register of the destination multi-vector group, encoded as &quot;Zd&quot; times 4 plus 3.">&lt;Zd4&gt;</a>.H }, <a href="#Zn__2" title="Is the name of the first source scalable vector register, encoded in the &quot;Zn&quot; field.">&lt;Zn&gt;</a>.H, <a href="#Zm" title="Is the name of the second source scalable vector register, encoded in the &quot;Zm&quot; field.">&lt;Zm&gt;</a>.H</p></div><h4>Decode for this encoding</h4><p class="pseudocode">if !IsFeatureImplemented(FEAT_SME2) || !IsFeatureImplemented(FEAT_SVE_B16B16) then
    EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>);
end;
let n : integer = UInt(Zn);
let m : integer = UInt(Zm);
let d : integer = UInt(Zd::'00');
let nreg : integer{} = 4;</p>
  <div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zd1&gt;</td><td><a id="Zd1"/>
        
          <p class="aml">For the "Two registers" variant: is the name of the first scalable vector register of the destination multi-vector group, encoded as "Zd" times 2.</p>
        
      </td></tr><tr><td/><td><a id="Zd1__2"/>
        
          <p class="aml">For the "Four registers" variant: is the name of the first scalable vector register of the destination multi-vector group, encoded as "Zd" times 4.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zd2&gt;</td><td><a id="Zd2"/>
        
          <p class="aml">Is the name of the second scalable vector register of the destination multi-vector group, encoded as "Zd" times 2 plus 1.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zn&gt;</td><td><a id="Zn__2"/>
        
          <p class="aml">Is the name of the first source scalable vector register, encoded in the "Zn" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zm&gt;</td><td><a id="Zm"/>
        
          <p class="aml">Is the name of the second source scalable vector register, encoded in the "Zm" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zd4&gt;</td><td><a id="Zd4"/>
        
          <p class="aml">Is the name of the fourth scalable vector register of the destination multi-vector group, encoded as "Zd" times 4 plus 3.</p>
        
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id=""/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">CheckStreamingSVEEnabled();
let VL : integer{} = CurrentVL();
let elements : integer = VL DIV 16;
var results : array [[4]] of bits(VL);

for r = 0 to nreg-1 do
    let operand1 : bits(VL) = Z{}(n);
    let operand2 : bits(VL) = Z{}(m);
    let operand3 : bits(VL) = Z{}(d+r);
    for e = 0 to elements-1 do
        let element1 : bits(16) = operand1[e*:16];
        let element2 : bits(16) = operand2[e*:16];
        let element3 : bits(16) = operand3[e*:16];
        let maxelement : bits(16) = BFMaxNum{}(element1, element3, FPCR());
        results[[r]][e*:16] = <a href="shared_pseudocode.html#func_BFMinNum_4" title="">BFMinNum</a>{16}(maxelement, element2, FPCR());
    end;
end;

for r = 0 to nreg-1 do
    <a href="shared_pseudocode.html#accessor_Z_2" title="">Z</a>{VL}(d+r) = results[[r]];
end;</p>
    </div>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      2025-09_rel_asl1

      2025-10-24 12:15:02
    </p><p class="copyconf">
      Copyright Â© 2010-2025 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
