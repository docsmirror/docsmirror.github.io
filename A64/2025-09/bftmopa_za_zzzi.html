<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>BFTMOPA (non-widening) -- A64</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">BFTMOPA (non-widening)</h2><p>BFloat16 sparse outer product, accumulating</p>
      <p class="aml">This instruction generates BFloat16 outer
product by multiplying the 1-in-2 selected elements from the
dense sub-matrices in the two first source vectors with the corresponding
elements of the compressed sparse sub-matrix in the second source vector
and accumulates the results to the destination ZA tile elements.</p>
      <p class="aml">The outer product is generated by multiplying the selected 1-in-2 BFloat16
value from each overlapping 16-bit containers of the two SVL<sub>H</sub>×1 sub-matrices in
the first source vectors by the BFloat16 value from the corresponding 16-bit container of
the compressed 1×SVL<sub>H</sub> sub-matrix in the second source vector.</p>
      <p class="aml">The 1-in-2 BFloat16 value in the first source vectors is selected by
2-bit controls in the indexed segment of the control vector register.
If the control bit corresponding to an element in the first source vectors is 0,
the element is discarded and does not contribute to the result. If both bits
of the 2-bit control corresponding to the elements of the first source vectors are 1,
only the element corresponding to the least significant bit is selected.</p>
      <p class="aml">The instruction multiplies the selected elements of sub-matrices of BFloat16
values held in the first source vectors by the corresponding elements of
sub-matrix of BFloat16 values in the second source vector. The resulting
BFloat16 SVL<sub>H</sub>×SVL<sub>H</sub> outer product is then destructively
added to the BFloat16 destination tile.
This is equivalent to performing a single multiply-accumulate to
each of the destination tile elements.</p>
      <p class="aml">This instruction follows SME2 ZA-targeting non-widening BFloat16
numerical behaviors.</p>
      <p class="aml">This instruction is unpredicated.</p>
    
    <h3 class="classheading"><a id="iclass_sme2"/>SME2<span style="font-size:smaller;"><br/>(FEAT_SME_TMOP &amp;&amp; FEAT_SME_B16B16)
          </span></h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">1</td><td class="l">0</td><td class="r">0</td><td class="l">0</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">1</td><td class="l">0</td><td class="r">1</td><td class="lr">1</td><td colspan="5" class="lr">Zm</td><td class="lr">0</td><td class="lr">0</td><td class="lr">0</td><td class="lr">K</td><td colspan="2" class="lr">Zk</td><td colspan="4" class="lr">Zn</td><td colspan="2" class="lr">i2</td><td class="lr">1</td><td class="lr">0</td><td class="lr">0</td><td class="lr">ZAda</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Encoding</h4><a id="bftmopa_za_zzzi_h2x1"/><p class="asm-code">BFTMOPA  <a href="#ZAda__3" title="For the &quot;Half-precision&quot; variant: is the name of the ZA tile ZA0-ZA1, encoded in the &quot;ZAda&quot; field.">&lt;ZAda&gt;</a>.H, { <a href="#Zn1__2" title="Is the name of the first scalable vector register of the first source multi-vector group, encoded as &quot;Zn&quot; times 2.">&lt;Zn1&gt;</a>.H-<a href="#Zn2__2" title="Is the name of the second scalable vector register of the first source multi-vector group, encoded as &quot;Zn&quot; times 2 plus 1.">&lt;Zn2&gt;</a>.H }, <a href="#Zm" title="Is the name of the second source scalable vector register, encoded in the &quot;Zm&quot; field.">&lt;Zm&gt;</a>.H, <a href="#Zk__2" title="Is the name of the control vector register Z20-Z23 or Z28-Z31, encoded in the &quot;K:Zk&quot; fields.">&lt;Zk&gt;</a>[<a href="#index_i2_control_seg_idx" title="Is the control segment index, in the range 0 to 3, encoded in the &quot;i2&quot; field.">&lt;index&gt;</a>]</p></div><h4>Decode for this encoding</h4><p class="pseudocode">if !IsFeatureImplemented(FEAT_SME_TMOP) || !IsFeatureImplemented(FEAT_SME_B16B16) then
    EndOfDecode(<a href="shared_pseudocode.html#enum_Decode_UNDEF" title="">Decode_UNDEF</a>);
end;
let n : integer = UInt(Zn::'0');
let m : integer = UInt(Zm);
let k : integer = UInt('1'::K::'1'::Zk);
let index : integer = UInt(i2);
let da : integer = UInt(ZAda);</p>
  <div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;ZAda&gt;</td><td><a id="ZAda__3"/>
        
          <p class="aml">Is the name of the ZA tile ZA0-ZA1, encoded in the "ZAda" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zn1&gt;</td><td><a id="Zn1__2"/>
        
          <p class="aml">Is the name of the first scalable vector register of the first source multi-vector group, encoded as "Zn" times 2.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zn2&gt;</td><td><a id="Zn2__2"/>
        
          <p class="aml">Is the name of the second scalable vector register of the first source multi-vector group, encoded as "Zn" times 2 plus 1.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zm&gt;</td><td><a id="Zm"/>
        
          <p class="aml">Is the name of the second source scalable vector register, encoded in the "Zm" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zk&gt;</td><td><a id="Zk__2"/>
        
          <p class="aml">Is the name of the control vector register Z20-Z23 or Z28-Z31, encoded in the "K:Zk" fields.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;index&gt;</td><td><a id="index_i2_control_seg_idx"/>
        
          <p class="aml">Is the control segment index, in the range 0 to 3, encoded in the "i2" field.</p>
        
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id=""/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">CheckStreamingSVEAndZAEnabled();
let VL : integer{} = CurrentVL();
let dim : integer{} = VL DIV 16;
let csize : integer{} = VL DIV 8;
let op2 : bits(VL) = Z{}(m);
let op3 : bits(VL) = Z{}(k);
let ctrl : bits(csize) = op3[index*:csize];
let op4 : bits(dim*dim*16) = ZAtile{dim*dim*16}(da, 16);
var result : bits(dim*dim*16);

for row = 0 to dim-1 do
    for col = 0 to dim-1 do
        var i : integer = 0;
        var elem1 : bits(16) = <a href="shared_pseudocode.html#func_BFZero_2" title="">BFZero</a>{16}('0');
        for r = 0 to 1 do
            let op1 : bits(VL) = Z{}(n+r);
            if i &lt; 1 &amp;&amp; ctrl[(2*col + r)*:1] == '1' then
                elem1 = op1[row*:(16)];
                i = i + 1;
            end;
        end;
        let elem2 : bits(16) = op2[col*:(16)];
        let sum : bits(16)   = op4[(row*dim+col)*:(16)];
        result[(row*dim+col)*:(16)] = <a href="shared_pseudocode.html#func_BFMulAdd_ZA_4" title="">BFMulAdd_ZA</a>(sum, elem1, elem2, FPCR());
    end;
end;
ZAtile{dim*dim*16}(da, 16) = result;</p>
    </div>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      2025-09_rel_asl1

      2025-10-24 12:15:02
    </p><p class="copyconf">
      Copyright © 2010-2025 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
